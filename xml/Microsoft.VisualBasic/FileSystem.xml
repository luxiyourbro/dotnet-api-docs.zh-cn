<Type Name="FileSystem" FullName="Microsoft.VisualBasic.FileSystem">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="ac3ffad84738935580a11dd5acf01cdedc2192d2" />
    <Meta Name="ms.sourcegitcommit" Value="9e06b87bcfa4347dbbaaa4b3cc36b43b93b5badb" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-CN" />
    <Meta Name="ms.lasthandoff" Value="11/20/2018" />
    <Meta Name="ms.locfileid" Value="52218299" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class FileSystem" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit FileSystem extends System.Object" />
  <TypeSignature Language="DocId" Value="T:Microsoft.VisualBasic.FileSystem" />
  <TypeSignature Language="VB.NET" Value="Public Module FileSystem" />
  <TypeSignature Language="C++ CLI" Value="public ref class FileSystem sealed" />
  <TypeSignature Language="F#" Value="type FileSystem = class" />
  <AssemblyInfo>
    <AssemblyName>Microsoft.VisualBasic</AssemblyName>
    <AssemblyVersion>7.0.5000.0</AssemblyVersion>
    <AssemblyVersion>8.0.0.0</AssemblyVersion>
    <AssemblyVersion>10.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>Microsoft.VisualBasic.CompilerServices.StandardModule</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.Security.SecurityCritical</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>
      <see langword="FileSystem" /> 模块包含用于执行文件、目录或文件夹以及系统操作的过程。 与使用 <see langword="FileSystem" /> 模块相比，<see langword="My" /> 功能在文件 I/O 操作方面可为您提供更高的效率和更好的性能。 有关详情，请参阅<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此模块支持的 Visual Basic 语言关键字和访问文件和文件夹的运行时库成员。  
  
   
  
## Examples  
 此示例使用`GetAttr`函数来确定文件和目录或文件夹的属性。  
  
 [!code-vb[VbVbalrCatRef#25](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#25)]  
  
 ]]></format>
    </remarks>
    <related type="Article" href="~/docs/visual-basic/language-reference/keywords/directories-and-files-summary.md">目录和文件摘要</related>
    <related type="Article" href="~/docs/visual-basic/language-reference/keywords/input-and-output-summary.md">输入和输出摘要</related>
    <related type="Article" href="~/docs/visual-basic/language-reference/keywords/index.md">关键字 (Visual Basic)</related>
    <related type="Article" href="~/docs/visual-basic/language-reference/runtime-library-members.md">Visual Basic 运行时库成员</related>
  </Docs>
  <Members>
    <Member MemberName="ChDir">
      <MemberSignature Language="C#" Value="public static void ChDir (string Path);" />
      <MemberSignature Language="ILAsm" Value=".method public static void ChDir(string Path) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ChDir (Path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ChDir(System::String ^ Path);" />
      <MemberSignature Language="F#" Value="static member ChDir : string -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.ChDir Path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="Path">必须的。 一个 <see langword="String" /> 表达式，用于标识哪个目录或文件夹将成为新的默认目录或文件夹。 <paramref name="Path" /> 可以包含驱动器。 如果未指定驱动器，则 <see langword="ChDir" /> 更改当前驱动器上的默认目录或文件夹。</param>
        <summary>更改当前目录或文件夹。 与 <see langword="My" /> 函数相比，<see langword="ChDir" /> 功能在文件 I/O 操作方面可提供更高的效率和更好的性能。 有关更多信息，请参见<see cref="P:Microsoft.VisualBasic.FileIO.FileSystem.CurrentDirectory" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `ChDir`函数更改默认目录，但不是在默认驱动器。 例如，如果默认驱动器为 C，以下语句更改驱动器 D 上的默认目录，但 C 仍保留默认的驱动器：  
  
 [!code-vb[VbVbalrCatRef#39](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#39)]  
  
 您可以进行相对目录更改为通过键入两个句点，如下所示：  
  
 [!code-vb[VbVbalrCatRef#40](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#40)]  
  
> [!IMPORTANT]
>  `ChDir`函数需要非托管的代码权限，这可能会影响在部分信任情况下执行。 有关详细信息，请参阅<xref:System.Security.Permissions.SecurityPermission>和。  
  
   
  
## Examples  
 此示例使用`ChDir`函数来更改当前目录或文件夹。  
  
 [!code-vb[VbVbalrCatRef#41](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#41)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="Path" /> 为空。</exception>
        <exception cref="T:System.IO.FileNotFoundException">指定的驱动器无效，或驱动器不可用。</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.ChDrive" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.CurDir" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Dir" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.MkDir(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.RmDir(System.String)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.FileNotFoundException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-parse-file-paths.md">如何：在 Visual Basic 中分析文件路径</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/creating-deleting-and-moving-files-and-directories.md">创建、删除和移动文件和目录 (Visual Basic)</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="ChDrive">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>更改当前驱动器。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ChDrive">
      <MemberSignature Language="C#" Value="public static void ChDrive (char Drive);" />
      <MemberSignature Language="ILAsm" Value=".method public static void ChDrive(char Drive) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.ChDrive(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ChDrive (Drive As Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ChDrive(char Drive);" />
      <MemberSignature Language="F#" Value="static member ChDrive : char -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.ChDrive Drive" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Drive" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="Drive">必须的。 指定现有驱动器的字符串表达式。 如果提供一个零长度字符串 ("")，则当前驱动器不会更改。 如果 <paramref name="Drive" /> 参数为多字符字符串，<see langword="ChDrive" /> 将仅使用第一个字母。</param>
        <summary>更改当前驱动器。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `ChDrive`函数需要非托管代码的权限，这可能会影响其在部分信任情况下执行。 有关详细信息，请参阅<xref:System.Security.Permissions.SecurityPermission>并[代码访问权限](https://msdn.microsoft.com/library/e5ae402f-6dda-4732-bbe8-77296630f675)。  
  
   
  
## Examples  
 此示例使用`ChDrive`函数来更改当前驱动器。 如果驱动器不存在，该函数将引发异常。  
  
 [!code-vb[VbVbalrCatRef#32](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#32)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">指定的驱动器无效，或驱动器不可用。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.CurDir" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Dir" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.MkDir(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.RmDir(System.String)" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">使用 Visual Basic 访问文件</related>
      </Docs>
    </Member>
    <Member MemberName="ChDrive">
      <MemberSignature Language="C#" Value="public static void ChDrive (string Drive);" />
      <MemberSignature Language="ILAsm" Value=".method public static void ChDrive(string Drive) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.ChDrive(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ChDrive (Drive As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ChDrive(System::String ^ Drive);" />
      <MemberSignature Language="F#" Value="static member ChDrive : string -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.ChDrive Drive" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Drive" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="Drive">必须的。 指定现有驱动器的字符串表达式。 如果提供一个零长度字符串 ("")，则当前驱动器不会更改。 如果 <paramref name="Drive" /> 参数为多字符字符串，<see langword="ChDrive" /> 将仅使用第一个字母。</param>
        <summary>更改当前驱动器。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `ChDrive`函数需要非托管代码的权限，这可能会影响其在部分信任情况下执行。 有关详细信息，请参阅<xref:System.Security.Permissions.SecurityPermission>并[代码访问权限](https://msdn.microsoft.com/library/e5ae402f-6dda-4732-bbe8-77296630f675)。  
  
   
  
## Examples  
 此示例使用`ChDrive`函数来更改当前驱动器。 如果驱动器不存在，该函数将引发异常。  
  
 [!code-vb[VbVbalrCatRef#32](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#32)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">指定的驱动器无效，或驱动器不可用。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.CurDir" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Dir" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.MkDir(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.RmDir(System.String)" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">使用 Visual Basic 访问文件</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="CurDir">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>返回表示当前路径的字符串。 与 <see langword="CurDir" /> 相比，<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> 在文件 I/O 操作方面可为您提供更高的效率和更好的性能。 有关详情，请参阅<see cref="P:Microsoft.VisualBasic.FileIO.FileSystem.CurrentDirectory" />。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CurDir">
      <MemberSignature Language="C#" Value="public static string CurDir ();" />
      <MemberSignature Language="ILAsm" Value=".method public static string CurDir() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.CurDir" />
      <MemberSignature Language="VB.NET" Value="Public Function CurDir () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ CurDir();" />
      <MemberSignature Language="F#" Value="static member CurDir : unit -&gt; string" Usage="Microsoft.VisualBasic.FileSystem.CurDir " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回表示当前路径的字符串。 与 <see langword="CurDir" /> 相比，<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> 在文件 I/O 操作方面可为您提供更高的效率和更好的性能。 有关详情，请参阅<see cref="P:Microsoft.VisualBasic.FileIO.FileSystem.CurrentDirectory" />。</summary>
        <returns>表示当前路径的字符串。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 此示例使用`CurDir`函数以返回当前路径。  
  
 [!code-vb[VbVbalrCatRef#65](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#65)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.ChDrive" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.MkDir(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.RmDir(System.String)" />
        <altmember cref="T:System.IO.IOException" />
        <altmember cref="T:System.ArgumentException" />
      </Docs>
    </Member>
    <Member MemberName="CurDir">
      <MemberSignature Language="C#" Value="public static string CurDir (char Drive);" />
      <MemberSignature Language="ILAsm" Value=".method public static string CurDir(char Drive) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.CurDir(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function CurDir (Drive As Char) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ CurDir(char Drive);" />
      <MemberSignature Language="F#" Value="static member CurDir : char -&gt; string" Usage="Microsoft.VisualBasic.FileSystem.CurDir Drive" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Drive" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="Drive">可选。 指定现有驱动器的 <see langword="Char" /> 表达式。 如果未指定驱动器或 <paramref name="Drive" /> 是长度为零的字符串 ("")，则 <see langword="CurDir" /> 返回当前驱动器的路径。</param>
        <summary>返回表示当前路径的字符串。 与 <see langword="CurDir" /> 相比，<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> 在文件 I/O 操作方面可为您提供更高的效率和更好的性能。 有关详情，请参阅<see cref="P:Microsoft.VisualBasic.FileIO.FileSystem.CurrentDirectory" />。</summary>
        <returns>表示当前路径的字符串。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 此示例使用`CurDir`函数以返回当前路径。  
  
 [!code-vb[VbVbalrCatRef#65](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#65)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.ChDrive" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.MkDir(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.RmDir(System.String)" />
        <altmember cref="T:System.IO.IOException" />
        <altmember cref="T:System.ArgumentException" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Dir">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>返回表示文件、目录或文件夹名称的字符串，该文件、目录或文件夹具有指定的模式或文件特性，或者具有指定的驱动器卷标。 与 <see langword="Dir" /> 函数相比，<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> 在文件 I/O 操作方面可为您提供更高的效率和更好的性能。 有关更多信息，请参见<see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetDirectoryInfo(System.String)" />。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dir">
      <MemberSignature Language="C#" Value="public static string Dir ();" />
      <MemberSignature Language="ILAsm" Value=".method public static string Dir() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Dir" />
      <MemberSignature Language="VB.NET" Value="Public Function Dir () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Dir();" />
      <MemberSignature Language="F#" Value="static member Dir : unit -&gt; string" Usage="Microsoft.VisualBasic.FileSystem.Dir " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回表示文件、目录或文件夹名称的字符串，该文件、目录或文件夹具有指定的模式或文件特性，或者具有指定的驱动器卷标。 与 <see langword="Dir" /> 函数相比，<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> 在文件 I/O 操作方面可为您提供更高的效率和更好的性能。 有关更多信息，请参见<see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetDirectoryInfo(System.String)" />。</summary>
        <returns>一个字符串，表示与指定模式或文件特性匹配的文件、目录或文件夹的名称，或者表示驱动器卷标。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Dir`函数支持多个字符的使用 (`*`) 和单字符 (`?`) 通配符来指定多个文件。  
  
 `VbVolume` 返回而不是特定文件名的驱动器卷标。  
  
 必须提供`PathName`第一次调用`Dir`函数。 若要检索的下一项，你可以后续调用`Dir`不带参数的函数。  
  
> [!IMPORTANT]
>  若要正确运行，`Dir`函数需要<xref:System.Security.Permissions.FileIOPermissionAccess.Read>并<xref:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery>标志的<xref:System.Security.Permissions.FileIOPermission>要对其授予对执行代码。 有关详细信息，请参阅<xref:System.Security.Permissions.FileIOPermission>， <xref:System.Security.SecurityException>，并[代码访问权限](https://msdn.microsoft.com/library/e5ae402f-6dda-4732-bbe8-77296630f675)。  
  
 `Attributes`参数枚举值如下所示：  
  
|“值”|返回的常量|描述|  
|-|-|-|  
|`Normal`|`vbnormal`|默认。 指定文件而无需属性。|  
|`ReadOnly`|`vbReadOnly`|指定只读文件，以及文件而无需属性。|  
|`Hidden`|`vbHidden`|指定隐藏的文件，以及文件而无需属性。|  
|`System`|`vbSystem`|指定系统文件以及文件而无需属性。|  
|`Volume`|`vbVolume`|指定卷标签;如果指定任何其他属性，则`vbVolume`将被忽略。|  
|`Directory`|`vbDirectory`|指定目录或文件夹，以及文件而无需属性。|  
|`Archive`|`vbArchive`|文件自上次备份后已更改。|  
|`Alias`|`vbAlias`|文件具有不同的名称。|  
  
> [!NOTE]
>  这些枚举所指定的 Visual Basic 语言并可以在任意位置而不是实际值在代码中。  
  
   
  
## Examples  
 此示例使用`Dir`函数检查是否存在某些文件和目录。  
  
 [!code-vb[VbVbalrCatRef#3](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.ChDrive" />
        <altmember cref="T:Microsoft.VisualBasic.FileAttribute" />
      </Docs>
    </Member>
    <Member MemberName="Dir">
      <MemberSignature Language="C#" Value="public static string Dir (string Pathname, Microsoft.VisualBasic.FileAttribute Attributes = Microsoft.VisualBasic.FileAttribute.Normal);" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Dir(string Pathname, valuetype Microsoft.VisualBasic.FileAttribute Attributes) cil managed" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Dir(System.String,Microsoft.VisualBasic.FileAttribute)" />
      <MemberSignature Language="VB.NET" Value="Public Function Dir (Pathname As String, Optional Attributes As FileAttribute = Microsoft.VisualBasic.FileAttribute.Normal) As String" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="F#" Value="static member Dir : string * Microsoft.VisualBasic.FileAttribute -&gt; string" Usage="Microsoft.VisualBasic.FileSystem.Dir (Pathname, Attributes)" FrameworkAlternate="netframework-2.0" />
      <MemberSignature Language="C#" Value="public static string Dir (string PathName, Microsoft.VisualBasic.FileAttribute Attributes = Microsoft.VisualBasic.FileAttribute.Normal);" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="ILAsm" Value=".method public static string Dir(string PathName, valuetype Microsoft.VisualBasic.FileAttribute Attributes) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="VB.NET" Value="Public Function Dir (PathName As String, Optional Attributes As FileAttribute = Microsoft.VisualBasic.FileAttribute.Normal) As String" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="F#" Value="static member Dir : string * Microsoft.VisualBasic.FileAttribute -&gt; string" Usage="Microsoft.VisualBasic.FileSystem.Dir (PathName, Attributes)" FrameworkAlternate="netframework-1.1;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Pathname" Type="System.String" Index="0" FrameworkAlternate="netframework-1.1" />
        <Parameter Name="PathName" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="Attributes" Type="Microsoft.VisualBasic.FileAttribute" Index="1" />
      </Parameters>
      <Docs>
        <param name="PathName">可选。 <see langword="String" /> 表达式，用于指定文件名、目录或文件夹名或者驱动器卷标。 如果未找到 <paramref name="PathName" />，则返回一个零长度字符串 (<see langword="&quot;&quot;" />)。</param>
        <param name="Pathname">To be added.</param>
        <param name="Attributes">可选。 其值指定文件特性的枚举或数值表达式。 如果省略，则 <see langword="Dir" /> 将返回与 <paramref name="PathName" /> 匹配但不具有任何特性的文件。</param>
        <summary>返回表示文件、目录或文件夹名称的字符串，该文件、目录或文件夹具有指定的模式或文件特性，或者具有指定的驱动器卷标。 与 <see langword="Dir" /> 函数相比，<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> 在文件 I/O 操作方面可为您提供更高的效率和更好的性能。 有关更多信息，请参见<see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetDirectoryInfo(System.String)" />。</summary>
        <returns>一个字符串，表示与指定模式或文件特性匹配的文件、目录或文件夹的名称，或者表示驱动器卷标。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Dir`函数支持多个字符的使用 (`*`) 和单字符 (`?`) 通配符来指定多个文件。  
  
 `VbVolume` 返回而不是特定文件名的驱动器卷标。  
  
 必须提供`PathName`第一次调用`Dir`函数。 若要检索的下一项，你可以后续调用`Dir`不带任何参数的函数。  
  
> [!IMPORTANT]
>  若要正确运行，`Dir`函数需要<xref:System.Security.Permissions.FileIOPermissionAccess.Read>并<xref:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery>标志的<xref:System.Security.Permissions.FileIOPermission>要对其授予对执行代码。 有关详细信息，请参阅<xref:System.Security.Permissions.FileIOPermission>， <xref:System.Security.SecurityException>，并[代码访问权限](https://msdn.microsoft.com/library/e5ae402f-6dda-4732-bbe8-77296630f675)。  
  
 `Attributes`参数枚举值如下所示：  
  
|“值”|返回的常量|描述|  
|-|-|-|  
|`Normal`|`vbnormal`|默认。 指定不具有任何特性的文件。|  
|`ReadOnly`|`vbReadOnly`|指定只读文件，除了不具有任何特性的文件。|  
|`Hidden`|`vbHidden`|指定隐藏的文件，除了不具有任何特性的文件。|  
|`System`|`vbSystem`|指定系统文件，除了不具有任何特性的文件。|  
|`Volume`|`vbVolume`|指定卷标签;如果指定任何其他属性，则`vbVolume`将被忽略。|  
|`Directory`|`vbDirectory`|指定目录或文件夹，以及不具有任何特性的文件。|  
|`Archive`|`vbArchive`|文件自上次备份后已更改。|  
|`Alias`|`vbAlias`|文件具有不同的名称。|  
  
> [!NOTE]
>  这些枚举所指定的 Visual Basic 语言，并可以代替实际值在代码中任意位置使用。  
  
   
  
## Examples  
 此示例使用`Dir`函数检查是否存在某些文件和目录。  
  
 [!code-vb[VbVbalrCatRef#3](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.ChDrive" />
        <altmember cref="T:Microsoft.VisualBasic.FileAttribute" />
      </Docs>
    </Member>
    <Member MemberName="EOF">
      <MemberSignature Language="C#" Value="public static bool EOF (int FileNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public static bool EOF(int32 FileNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.EOF(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function EOF (FileNumber As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool EOF(int FileNumber);" />
      <MemberSignature Language="F#" Value="static member EOF : int -&gt; bool" Usage="Microsoft.VisualBasic.FileSystem.EOF FileNumber" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必须的。 一个包含任何有效文件号的 <see langword="Integer" />。</param>
        <summary>当达到为进行 <see langword="True" /> 或顺序 <see langword="Random" /> 而打开的文件的结尾时，此方法返回布尔值 <see langword="Input" />。</summary>
        <returns>当达到为进行 <see langword="True" /> 或顺序 <see langword="Random" /> 而打开的文件的结尾时，此方法返回布尔值 <see langword="Input" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用`EOF`以避免通过尝试获取输入文件的末尾而产生的错误。  
  
 `EOF`函数返回`False`直到达到文件末尾。 使用文件打开以进行`Random`或`Binary`访问权限，`EOF`返回`False`直到最后一个执行`FileGet`函数不能读取完整记录。  
  
 使用文件打开以进行`Binary`访问，请尝试通过文件使用读取`Input`直到函数`EOF`返回`True`生成一个错误。 使用`LOF`并`Loc`函数而不是`EOF`使用二进制文件中读取时`Input`，或使用`Get`时使用`EOF`函数。 使用文件打开以进行`Output`，`EOF`始终返回`True`。  
  
   
  
## Examples  
 此示例使用`EOF`函数来检测文件的末尾。 此示例假定`Testfile`是一个文本文件，其中包含若干行文本。  
  
 [!code-vb[VbVbalrCatRef#62](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#62)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">文件模式无效。</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Loc(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.LOF(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FileAttr">
      <MemberSignature Language="C#" Value="public static Microsoft.VisualBasic.OpenMode FileAttr (int FileNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public static valuetype Microsoft.VisualBasic.OpenMode FileAttr(int32 FileNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileAttr(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function FileAttr (FileNumber As Integer) As OpenMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Microsoft::VisualBasic::OpenMode FileAttr(int FileNumber);" />
      <MemberSignature Language="F#" Value="static member FileAttr : int -&gt; Microsoft.VisualBasic.OpenMode" Usage="Microsoft.VisualBasic.FileSystem.FileAttr FileNumber" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.VisualBasic.OpenMode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必须的。 <see langword="Integer" />。 任何有效文件数。</param>
        <summary>返回一个枚举，该枚举表示使用 <see langword="FileOpen" /> 函数打开的文件的文件模式。 与 <see langword="FileAttr" /> 函数相比，<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> 在文件 I/O 操作方面可为您提供更高的效率和更好的性能。 有关更多信息，请参见<see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetFileInfo(System.String)" />。</summary>
        <returns>下列枚举值指示文件访问模式： 
 <list type="table"><item><term> “值” 
 </term><description> 模式 
 </description></item><item><term> 1 
 </term><description><see langword="OpenMode.Input" /></description></item><item><term> 2 
 </term><description><see langword="OpenMode.Output" /></description></item><item><term> 4 
 </term><description><see langword="OpenMode.Random" /></description></item><item><term> 8 
 </term><description><see langword="OpenMode.Append" /></description></item><item><term> 32 
 </term><description><see langword="OpenMode.Binary" /></description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此函数返回一个枚举，表示使用打开的文件的文件模式`FileOpen`函数。  
  
   
  
## Examples  
 此示例使用`FileAttr`函数以返回打开的文件的文件模式。  
  
 [!code-vb[VbVbalrCatRef#46](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#46)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.GetAttr(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.SetAttr(System.String,Microsoft.VisualBasic.FileAttribute)" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">使用 Visual Basic 访问文件</related>
      </Docs>
    </Member>
    <Member MemberName="FileClose">
      <MemberSignature Language="C#" Value="public static void FileClose (params int[] FileNumbers);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileClose(int32[] FileNumbers) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileClose(System.Int32[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileClose (ParamArray FileNumbers As Integer())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void FileClose(... cli::array &lt;int&gt; ^ FileNumbers);" />
      <MemberSignature Language="F#" Value="static member FileClose : int[] -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileClose FileNumbers" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumbers" Type="System.Int32[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="FileNumbers">可选。 要关闭的 0 个或多个信道的参数数组。</param>
        <summary>关闭对用 <see langword="FileOpen" /> 函数打开的文件的输入/输出 (I/O)。 <see langword="My" /> 在文件 I/O 操作方面可为您提供更高的效率和更好的性能。 有关更多信息，请参见<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileClose`提供函数是为了向后兼容，可能会影响性能。 对于非旧版应用程序，`My.Computer.FileSystem`对象提供更好的性能。 有关详细信息，请参阅[如何： 使用 StreamReader 文件中读取文本](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-text-from-files-with-a-streamreader.md)，[如何： 使用 StreamWriter 向文件写入文本](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md)，和[演练： 中操作文件和目录Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/walkthrough-manipulating-files-and-directories.md)。  
  
 如果省略`FileNumbers`，打开的所有活动文件`FileOpen`函数将关闭。  
  
 当您关闭已打开的文件`Output`或`Append`，最终输出缓冲区写入到该文件的操作系统缓冲区。 所有关联的缓冲区空间使用的已关闭发布文件。  
  
 当`FileClose`执行函数，而其文件的文件的关联数字结束。  
  
   
  
## Examples  
 此示例使用`FileClose`函数来关闭文件打开以进行`Input`。  
  
 [!code-vb[VbVbalrCatRef#69](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#69)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">
          <paramref name="FileNumber" /> 不存在。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Reset" />
        <related type="Article" href="~/docs/visual-basic/language-reference/statements/end-statement.md">End 语句</related>
        <related type="Article" href="~/docs/visual-basic/language-reference/statements/stop-statement.md">Stop 语句 (Visual Basic)</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">使用 Visual Basic 访问文件</related>
      </Docs>
    </Member>
    <Member MemberName="FileCopy">
      <MemberSignature Language="C#" Value="public static void FileCopy (string Source, string Destination);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileCopy(string Source, string Destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileCopy(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileCopy (Source As String, Destination As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void FileCopy(System::String ^ Source, System::String ^ Destination);" />
      <MemberSignature Language="F#" Value="static member FileCopy : string * string -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileCopy (Source, Destination)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Source" Type="System.String" />
        <Parameter Name="Destination" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="Source">必须的。 指定要复制的文件的名称的 <see langword="String" /> 表达式。 <paramref name="Source" /> 可以包含源文件的驱动器和目录或文件夹。</param>
        <param name="Destination">必须的。 指定目标文件名的 <see langword="String" /> 表达式。 <paramref name="Destination" /> 可包含目标文件的驱动器和目录或文件夹。</param>
        <summary>复制文件。 与 <see langword="FileCopy" /> 相比，<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> 在文件 I/O 操作方面可为您提供更高的效率和更好的性能。 有关更多信息，请参见<see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.CopyFile(System.String,System.String)" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果尝试使用`FileCopy`函数上当前打开的文件，就会出错。  
  
 `FileCopy` 需要完全信任才能在本地驱动器上工作。  
  
   
  
## Examples  
 此示例使用`FileCopy`函数将一个文件复制到另一个。 在此示例中，假定`SrcFile`是包含数据的文件。  
  
 [!code-vb[VbVbalrCatRef#2](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="Source" /> 或 <paramref name="Destination" /> 无效或未指定。</exception>
        <exception cref="T:System.IO.IOException">文件已打开。</exception>
        <exception cref="T:System.IO.FileNotFoundException">文件不存在。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Kill(System.String)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <altmember cref="T:System.IO.FileNotFoundException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-create-a-copy-of-a-file-in-a-different-directory.md">如何：在 Visual Basic 中在不同的目录中创建文件的副本</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-create-a-copy-of-a-file-in-the-same-directory.md">如何：在同一目录中创建文件副本 (Visual Basic)</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-copy-a-directory-to-another-directory.md">如何：在 Visual Basic 中将一个目录复制到另一个目录</related>
      </Docs>
    </Member>
    <Member MemberName="FileDateTime">
      <MemberSignature Language="C#" Value="public static DateTime FileDateTime (string PathName);" />
      <MemberSignature Language="ILAsm" Value=".method public static valuetype System.DateTime FileDateTime(string PathName) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileDateTime(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function FileDateTime (PathName As String) As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static DateTime FileDateTime(System::String ^ PathName);" />
      <MemberSignature Language="F#" Value="static member FileDateTime : string -&gt; DateTime" Usage="Microsoft.VisualBasic.FileSystem.FileDateTime PathName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="PathName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="PathName">必须的。 指定一个文件名的 <see langword="String" /> 表达式。 <paramref name="PathName" /> 可能包括目录或文件夹以及驱动器。</param>
        <summary>返回一个 <see langword="Date" /> 值，该值指示写入文件的日期和时间。 相比 <see langword="FileDateTime" />，<see langword="My" /> 功能可使文件 I/O 操作的效率更高、性能更好。 有关详细信息，请参阅<see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetFileInfo(System.String)" />。</summary>
        <returns>
          <see langword="Date" /> 值，该值指示文件的创建日期和时间或上次修改日期和时间。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 此示例使用`FileDateTime`函数来确定的日期和时间文件已创建或上次修改时间。 日期和时间显示格式基于系统的区域设置。  
  
 [!code-vb[VbVbalrCatRef#34](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#34)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="PathName" /> 无效或包含通配符。</exception>
        <exception cref="T:System.IO.FileNotFoundException">目标文件不存在。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileLen(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.GetAttr(System.String)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.FileNotFoundException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">使用 Visual Basic 访问文件</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="FileGet">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>将数据从打开的磁盘文件读入到一个变量中。 相比 <see langword="FileGet" />，<see langword="My" /> 功能可使文件 I/O 操作的效率更高、性能更好。 有关详情，请参阅<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref bool Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, bool&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Boolean@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Boolean, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Boolean" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必须的。 任何有效文件数。</param>
        <param name="Value">必须的。 数据读入到其中的有效变量名称。</param>
        <param name="RecordNumber">可选。 读取的开始位置处的记录号（<see langword="Random" /> 模式文件）或字节数（<see langword="Binary" /> 模式文件）。</param>
        <summary>将数据从打开的磁盘文件读入到一个变量中。 相比 <see langword="FileGet" />，<see langword="My" /> 功能可使文件 I/O 操作的效率更高、性能更好。 有关详细信息，请参阅<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet` 仅在中有效`Random`和`Binary`模式。  
  
 与读取的数据`FileGet`通常写入到一个文件`FilePut`。  
  
 第一个记录或文件中的字节位置 1，第二个记录或字节在位置 2，依此类推。 如果省略`RecordNumber`下, 一步的记录或最后一个字节`FileGet`或`FilePut`函数 (或指向的最后一个`Seek`函数) 中读取。  
  
> [!IMPORTANT]
>  时从文件读取，不要根据文件扩展名的文件的内容的决策。 例如，名为 form1.vb 的文件不可能的 Visual Basic 源代码文件。  
  
## <a name="random-mode"></a>随机模式  
 有关在中打开文件`Random`模式下，下列规则适用：  
  
-   如果读取的数据的长度小于中指定的长度`RecordLength`子句`FileOpen`函数，`FileGet`读取的记录长度边界上的后续记录。 用文件缓冲区的现有内容填充一条记录的末尾和下一条记录的开始之间的空间。 由于不能与任何颇有自信地确定填充的数据量，它通常是最好使记录的长度与读取的数据的长度匹配。  
  
-   默认情况下，如果变量是一个字符串，`FileGet`读取一个双字节说明符的包含的字符串长度，然后读取该变量的数据。 因此，指定的记录长度`RecordLength`子句`FileOpen`函数必须至少为两个字节大于字符串的实际长度。 Visual Basic 6.0 和早期版本支持固定长度字符串;在放到文件，则不写入长度说明符。 如果你想要读取的字符串，而无需描述符，则应传递`True`到`StringIsFixedLength`参数，并应为正确的长度，读取到的字符串。  
  
-   如果读入的变量是一个数组，可以选择是否要读取的大小和维数的数组说明符。 若要编写描述符，设置`ArrayIsDynamic`参数`True`。 在数组读取时，必须以匹配数组写入的方式。 如果它与描述符写入数组时，您必须读取描述符。 如果未使用说明符，大小和边界的数组传递到`FileGet`确定要读取的内容。  
  
     描述符指定秩的数组、 大小和为每个级别的下限。 其长度等于 2 + 8 时间维度的数目: (2 + 8 * NumberOfDimensions)。 指定的记录长度`RecordLength`中的参数`FileOpen`函数必须是大于或等于写入数组数据和数组描述符需要的所有字节之和。 例如，以下数组声明需要 218 个字节时将数组写入到磁盘。  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     218 个字节分配，如下所示：  
  
    -   描述符的 18 个字节: (2 + 8 * 2)  
  
    -   200 个字节的数据: (5 * 10 * 4)。  
  
-   如果读入的变量是任何其他类型的变量 （不可变长度字符串或对象）`FileGet`只读取变量数据。 指定的记录长度`RecordLength`子句中的`FileOpen`函数必须是大于或等于所读取的数据的长度。  
  
-   `FileGet` 只不过是元素之间没有空白，像每个读取时，单独读取元素的结构。 在磁盘上，用户定义类型的动态数组 (使用编写`FilePut`) 通过其长度等于 2 加上 8 倍的维度数的描述符作为前缀: (2 + 8 * NumberOfDimensions)。 指定的记录长度`RecordLength`子句中的`FileOpen`函数必须是大于或等于读取各个元素所需的所有字节之和。 这包括任何数组和其描述符。 `VBFixedString`特性可以应用于字符串字段中的结构，以指示字符串写入时的大小到磁盘。  
  
## <a name="binary-mode"></a>二进制模式  
 打开的文件中`Binary`模式下，大部分`Random`模式规则适用，有一些例外情况。 在中打开文件的以下规则`Binary`模式不同于为规则`Random`模式：  
  
-   `RecordLength`子句中的`FileOpen`函数不起任何作用。 `FileGet` 连续; 从磁盘读取所有变量也就是说，而不填充记录之间。  
  
-   对于在结构中，数组以外的任何数组`FileGet`只读取数据。 未不读取任何说明符。  
  
-   `FileGet` 读取不是元素的结构不需要双字节长度说明符的可变长度字符串。 读取的字节数等于已中字符串的字符数。  
  
    > [!IMPORTANT]
    >  通过使用从文件中读取`FileGet`函数需要`Read`从访问<xref:System.Security.Permissions.FileIOPermissionAccess>枚举。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 且不等于 -1。</exception>
        <exception cref="T:System.IO.IOException">文件模式无效。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files.md">从文件读取 (Visual Basic)</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">写入文件 (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref byte Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, unsigned int8&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Byte@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Byte, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Byte" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必须的。 任何有效文件数。</param>
        <param name="Value">必须的。 数据读入到其中的有效变量名称。</param>
        <param name="RecordNumber">可选。 读取的开始位置处的记录号（<see langword="Random" /> 模式文件）或字节数（<see langword="Binary" /> 模式文件）。</param>
        <summary>将数据从打开的磁盘文件读入到一个变量中。 相比 <see langword="FileGet" />，<see langword="My" /> 功能可使文件 I/O 操作的效率更高、性能更好。 有关详情，请参阅<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet` 仅在中有效`Random`和`Binary`模式。  
  
 与读取的数据`FileGet`通常写入到一个文件`FilePut`。  
  
 第一个记录或文件中的字节位置 1，第二个记录或字节在位置 2，依此类推。 如果省略`RecordNumber`下, 一步的记录或最后一个字节`FileGet`或`FilePut`函数 (或指向的最后一个`Seek`函数) 中读取。  
  
> [!IMPORTANT]
>  时从文件读取，不要根据文件扩展名的文件的内容的决策。 例如，名为 form1.vb 的文件不可能的 Visual Basic 源代码文件。  
  
## <a name="random-mode"></a>随机模式  
 有关在中打开文件`Random`模式下，下列规则适用：  
  
-   如果读取的数据的长度小于中指定的长度`RecordLength`子句`FileOpen`函数，`FileGet`读取的记录长度边界上的后续记录。 用文件缓冲区的现有内容填充一条记录的末尾和下一条记录的开始之间的空间。 由于不能与任何颇有自信地确定填充的数据量，它通常是最好使记录的长度与读取的数据的长度匹配。  
  
-   默认情况下，如果变量是一个字符串，`FileGet`读取一个双字节说明符的包含的字符串长度，然后读取该变量的数据。 因此，指定的记录长度`RecordLength`子句`FileOpen`函数必须至少为两个字节大于字符串的实际长度。 Visual Basic 6.0 和早期版本支持固定长度字符串;在放到文件，则不写入长度说明符。 如果你想要读取的字符串，而无需描述符，则应传递`True`到`StringIsFixedLength`参数，并应为正确的长度，读取到的字符串。  
  
-   如果读入的变量是一个数组，可以选择是否要读取的大小和维数的数组说明符。 若要编写描述符，设置`ArrayIsDynamic`参数`True`。 在数组读取时，必须以匹配数组写入的方式。 如果它与描述符写入数组时，您必须读取描述符。 如果未使用说明符。 然后，大小和边界的数组传递到`FileGet`确定要读取的内容。  
  
     描述符指定秩的数组、 大小和为每个级别的下限。 其长度等于 2 + 8 时间维度的数目: (2 + 8 * NumberOfDimensions)。 指定的记录长度`RecordLength`中的参数`FileOpen`函数必须是大于或等于写入数组数据和数组描述符需要的所有字节之和。 例如，以下数组声明需要 218 个字节时将数组写入到磁盘。  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     218 个字节分配，如下所示：  
  
    -   描述符的 18 个字节: (2 + 8 * 2)  
  
    -   200 个字节的数据: (5 * 10 * 4)。  
  
-   如果读入的变量是任何其他类型的变量 （不可变长度字符串或对象）`FileGet`只读取变量数据。 指定的记录长度`RecordLength`子句中的`FileOpen`函数必须是大于或等于所读取的数据的长度。  
  
-   `FileGet` 只不过是元素之间没有空白，像每个读取时，单独读取元素的结构。 在磁盘上，用户定义类型的动态数组 (使用编写`FilePut`) 通过其长度等于 2 加上 8 倍的维度数的描述符作为前缀: (2 + 8 * NumberOfDimensions)。 指定的记录长度`RecordLength`子句中的`FileOpen`函数必须是大于或等于读取各个元素所需的所有字节之和。 这包括任何数组和其描述符。 `VBFixedString`特性可以应用于字符串字段中的结构，以指示字符串写入时的大小到磁盘。  
  
## <a name="binary-mode"></a>二进制模式  
 打开的文件中`Binary`模式下，大部分`Random`模式规则适用，有一些例外情况。 在中打开文件的以下规则`Binary`模式不同于为规则`Random`模式：  
  
-   `RecordLength`子句中的`FileOpen`函数不起任何作用。 `FileGet` 连续; 从磁盘读取所有变量也就是说，而不填充记录之间。  
  
-   对于在结构中，数组以外的任何数组`FileGet`只读取数据。 未不读取任何说明符。  
  
-   `FileGet` 读取不是元素的结构不需要双字节长度说明符的可变长度字符串。 读取的字节数等于已中字符串的字符数。  
  
    > [!IMPORTANT]
    >  通过使用从文件中读取`FileGet`函数需要`Read`从访问<xref:System.Security.Permissions.FileIOPermissionAccess>枚举。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 且不等于 -1。</exception>
        <exception cref="T:System.IO.IOException">文件模式无效。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files.md">从文件读取 (Visual Basic)</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">写入文件 (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref char Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, char&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Char@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Char, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Char" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必须的。 任何有效文件数。</param>
        <param name="Value">必须的。 数据读入到其中的有效变量名称。</param>
        <param name="RecordNumber">可选。 读取的开始位置处的记录号（<see langword="Random" /> 模式文件）或字节数（<see langword="Binary" /> 模式文件）。</param>
        <summary>将数据从打开的磁盘文件读入到一个变量中。 相比 <see langword="FileGet" />，<see langword="My" /> 功能可使文件 I/O 操作的效率更高、性能更好。 有关详情，请参阅<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet` 仅在中有效`Random`和`Binary`模式。  
  
 与读取的数据`FileGet`通常写入到一个文件`FilePut`。  
  
 第一个记录或文件中的字节位置 1，第二个记录或字节在位置 2，依此类推。 如果省略`RecordNumber`下, 一步的记录或最后一个字节`FileGet`或`FilePut`函数 (或指向的最后一个`Seek`函数) 中读取。  
  
> [!IMPORTANT]
>  时从文件读取，不要根据文件扩展名的文件的内容的决策。 例如，名为 form1.vb 的文件不可能的 Visual Basic 源代码文件。  
  
## <a name="random-mode"></a>随机模式  
 有关在中打开文件`Random`模式下，下列规则适用：  
  
-   如果读取的数据的长度小于中指定的长度`RecordLength`子句`FileOpen`函数，`FileGet`读取的记录长度边界上的后续记录。 用文件缓冲区的现有内容填充一条记录的末尾和下一条记录的开始之间的空间。 由于不能与任何颇有自信地确定填充的数据量，它通常是最好使记录的长度与读取的数据的长度匹配。  
  
-   默认情况下，如果变量是一个字符串，`FileGet`读取一个双字节说明符的包含的字符串长度，然后读取该变量的数据。 因此，指定的记录长度`RecordLength`子句`FileOpen`函数必须至少为两个字节大于字符串的实际长度。 Visual Basic 6.0 和早期版本支持固定长度字符串;在放到文件，则不写入长度说明符。 如果你想要读取的字符串，而无需描述符，则应传递`True`到`StringIsFixedLength`参数，并应为正确的长度，读取到的字符串。  
  
-   如果读入的变量是一个数组，可以选择是否要读取的大小和维数的数组说明符。 若要编写描述符，设置`ArrayIsDynamic`参数`True`。 在数组读取时，必须以匹配数组写入的方式。 如果它与描述符写入数组时，您必须读取描述符。 如果未使用说明符，大小和边界的数组传递到`FileGet`确定要读取的内容。  
  
     描述符指定秩的数组、 大小和为每个级别的下限。 其长度等于 2 + 8 时间维度的数目: (2 + 8 * NumberOfDimensions)。 指定的记录长度`RecordLength`中的参数`FileOpen`函数必须是大于或等于写入数组数据和数组描述符需要的所有字节之和。 例如，以下数组声明需要 218 个字节时将数组写入到磁盘。  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     218 个字节分配，如下所示：  
  
    -   描述符的 18 个字节: (2 + 8 * 2)  
  
    -   200 个字节的数据: (5 * 10 * 4)。  
  
-   如果读入的变量是任何其他类型的变量 （不可变长度字符串或对象）`FileGet`只读取变量数据。 指定的记录长度`RecordLength`子句中的`FileOpen`函数必须是大于或等于所读取的数据的长度。  
  
-   `FileGet` 只不过是元素之间没有空白，像每个读取时，单独读取元素的结构。 在磁盘上，用户定义类型的动态数组 (使用编写`FilePut`) 通过其长度等于 2 加上 8 倍的维度数的描述符作为前缀: (2 + 8 * NumberOfDimensions)。 指定的记录长度`RecordLength`子句中的`FileOpen`函数必须是大于或等于读取各个元素所需的所有字节之和。 这包括任何数组和其描述符。 `VBFixedString`特性可以应用于字符串字段中的结构，以指示字符串写入时的大小到磁盘。  
  
## <a name="binary-mode"></a>二进制模式  
 打开的文件中`Binary`模式下，大部分`Random`模式规则适用，有一些例外情况。 在中打开文件的以下规则`Binary`模式不同于为规则`Random`模式：  
  
-   `RecordLength`子句中的`FileOpen`函数不起任何作用。 `FileGet` 连续; 从磁盘读取所有变量也就是说，而不填充记录之间。  
  
-   对于在结构中，数组以外的任何数组`FileGet`只读取数据。 未不读取任何说明符。  
  
-   `FileGet` 读取不是元素的结构不需要双字节长度说明符的可变长度字符串。 读取的字节数等于已中字符串的字符数。  
  
    > [!IMPORTANT]
    >  通过使用从文件中读取`FileGet`函数需要`Read`从访问<xref:System.Security.Permissions.FileIOPermissionAccess>枚举。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 且不等于 -1。</exception>
        <exception cref="T:System.IO.IOException">文件模式无效。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files.md">从文件读取 (Visual Basic)</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">写入文件 (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref DateTime Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, valuetype System.DateTime&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.DateTime@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As DateTime, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.DateTime" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必须的。 任何有效文件数。</param>
        <param name="Value">必须的。 数据读入到其中的有效变量名称。</param>
        <param name="RecordNumber">可选。 读取的开始位置处的记录号（<see langword="Random" /> 模式文件）或字节数（<see langword="Binary" /> 模式文件）。</param>
        <summary>将数据从打开的磁盘文件读入到一个变量中。 相比 <see langword="FileGet" />，<see langword="My" /> 功能可使文件 I/O 操作的效率更高、性能更好。 有关详情，请参阅<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet` 仅在中有效`Random`和`Binary`模式。  
  
 与读取的数据`FileGet`通常写入到一个文件`FilePut`。  
  
 第一个记录或文件中的字节位置 1，第二个记录或字节在位置 2，依此类推。 如果省略`RecordNumber`下, 一步的记录或最后一个字节`FileGet`或`FilePut`函数 (或指向的最后一个`Seek`函数) 中读取。  
  
> [!IMPORTANT]
>  时从文件读取，不要根据文件扩展名的文件的内容的决策。 例如，名为 form1.vb 的文件不可能的 Visual Basic 源代码文件。  
  
## <a name="random-mode"></a>随机模式  
 有关在中打开文件`Random`模式下，下列规则适用：  
  
-   如果读取的数据的长度小于中指定的长度`RecordLength`子句`FileOpen`函数，`FileGet`读取的记录长度边界上的后续记录。 用文件缓冲区的现有内容填充一条记录的末尾和下一条记录的开始之间的空间。 由于不能与任何颇有自信地确定填充的数据量，它通常是最好使记录的长度与读取的数据的长度匹配。  
  
-   默认情况下，如果变量是一个字符串，`FileGet`读取一个双字节说明符的包含的字符串长度，然后读取该变量的数据。 因此，指定的记录长度`RecordLength`子句`FileOpen`函数必须至少为两个字节大于字符串的实际长度。 Visual Basic 6.0 和早期版本支持固定长度字符串;在放到文件，则不写入长度说明符。 如果你想要读取的字符串，而无需描述符，则应传递`True`到`StringIsFixedLength`参数，并应为正确的长度，读取到的字符串。  
  
-   如果读入的变量是一个数组，可以选择是否要读取的大小和维数的数组说明符。 若要编写描述符，设置`ArrayIsDynamic`参数`True`。 在数组读取时，必须以匹配数组写入的方式。 如果它与描述符写入数组时，您必须读取描述符。 如果未使用说明符，大小和边界的数组传递到`FileGet`确定要读取的内容。  
  
     描述符指定秩的数组、 大小和为每个级别的下限。 其长度等于 2 + 8 时间维度的数目: (2 + 8 * NumberOfDimensions)。 指定的记录长度`RecordLength`中的参数`FileOpen`函数必须是大于或等于写入数组数据和数组描述符需要的所有字节之和。 例如，以下数组声明需要 218 个字节时将数组写入到磁盘。  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     218 个字节分配，如下所示：  
  
    -   描述符的 18 个字节: (2 + 8 * 2)  
  
    -   200 个字节的数据: (5 * 10 * 4)。  
  
-   如果读入的变量是任何其他类型的变量 （不可变长度字符串或对象）`FileGet`只读取变量数据。 指定的记录长度`RecordLength`子句中的`FileOpen`函数必须是大于或等于所读取的数据的长度。  
  
-   `FileGet` 只不过是元素之间没有空白，像每个读取时，单独读取元素的结构。 在磁盘上，用户定义类型的动态数组 (使用编写`FilePut`) 通过其长度等于 2 加上 8 倍的维度数的描述符作为前缀: (2 + 8 * NumberOfDimensions)。 指定的记录长度`RecordLength`子句中的`FileOpen`函数必须是大于或等于读取各个元素所需的所有字节之和。 这包括任何数组和其描述符。 `VBFixedString`特性可以应用于字符串字段中的结构，以指示字符串写入时的大小到磁盘。  
  
## <a name="binary-mode"></a>二进制模式  
 打开的文件中`Binary`模式下，大部分`Random`模式规则适用，有一些例外情况。 在中打开文件的以下规则`Binary`模式不同于为规则`Random`模式：  
  
-   `RecordLength`子句中的`FileOpen`函数不起任何作用。 `FileGet` 连续; 从磁盘读取所有变量也就是说，而不填充记录之间。  
  
-   对于在结构中，数组以外的任何数组`FileGet`只读取数据。 未不读取任何说明符。  
  
-   `FileGet` 读取不是元素的结构不需要双字节长度说明符的可变长度字符串。 读取的字节数等于已中字符串的字符数。  
  
    > [!IMPORTANT]
    >  通过使用从文件中读取`FileGet`函数需要`Read`从访问<xref:System.Security.Permissions.FileIOPermissionAccess>枚举。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 且不等于 -1。</exception>
        <exception cref="T:System.IO.IOException">文件模式无效。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files.md">从文件读取 (Visual Basic)</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">写入文件 (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref decimal Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, valuetype System.Decimal&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Decimal@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Decimal, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Decimal" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必须的。 任何有效文件数。</param>
        <param name="Value">必须的。 数据读入到其中的有效变量名称。</param>
        <param name="RecordNumber">可选。 读取的开始位置处的记录号（<see langword="Random" /> 模式文件）或字节数（<see langword="Binary" /> 模式文件）。</param>
        <summary>将数据从打开的磁盘文件读入到一个变量中。 相比 <see langword="FileGet" />，<see langword="My" /> 功能可使文件 I/O 操作的效率更高、性能更好。 有关详情，请参阅<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet` 仅在中有效`Random`和`Binary`模式。  
  
 与读取的数据`FileGet`通常通过使用写入到文件`FilePut`。  
  
 第一个记录或文件中的字节位置 1，第二个记录或字节在位置 2，依此类推。 如果省略`RecordNumber`下, 一步的记录或最后一个字节`FileGet`或`FilePut`函数 (或指向的最后一个`Seek`函数) 中读取。  
  
> [!IMPORTANT]
>  时从文件读取，不要根据文件扩展名的文件的内容的决策。 例如，名为 form1.vb 的文件不可能的 Visual Basic 源代码文件。  
  
## <a name="random-mode"></a>随机模式  
 有关在中打开文件`Random`模式下，下列规则适用：  
  
-   如果读取的数据的长度小于中指定的长度`RecordLength`子句`FileOpen`函数，`FileGet`读取的记录长度边界上的后续记录。 用文件缓冲区的现有内容填充一条记录的末尾和下一条记录的开始之间的空间。 由于不能与任何颇有自信地确定填充的数据量，它通常是最好使记录的长度与读取的数据的长度匹配。  
  
-   默认情况下，如果变量是一个字符串，`FileGet`读取一个双字节说明符的包含的字符串长度，然后读取该变量的数据。 因此，指定的记录长度`RecordLength`子句`FileOpen`函数必须至少为两个字节大于字符串的实际长度。 Visual Basic 6.0 和早期版本支持固定长度字符串;在放到文件，则不写入长度说明符。 如果你想要读取的字符串，而无需描述符，则应传递`True`到`StringIsFixedLength`参数，并应为正确的长度，读取到的字符串。  
  
-   如果读入的变量是一个数组，可以选择是否要读取的大小和维数的数组说明符。 若要编写描述符，设置`ArrayIsDynamic`参数`True`。 在数组读取时，必须以匹配数组写入的方式。 如果它与描述符写入数组时，您必须读取描述符。 如果未使用说明符，大小和边界的数组传递到`FileGet`确定要读取的内容。  
  
     描述符指定秩的数组、 大小和为每个级别的下限。 其长度等于 2 + 8 时间维度的数目: (2 + 8 * NumberOfDimensions)。 指定的记录长度`RecordLength`中的参数`FileOpen`函数必须是大于或等于写入数组数据和数组描述符需要的所有字节之和。 例如，以下数组声明需要 218 个字节时将数组写入到磁盘。  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     218 个字节分配，如下所示：  
  
    -   描述符的 18 个字节: (2 + 8 * 2)  
  
    -   200 个字节的数据: (5 * 10 * 4)。  
  
-   如果读入的变量是任何其他类型的变量 （不可变长度字符串或对象）`FileGet`只读取变量数据。 指定的记录长度`RecordLength`子句中的`FileOpen`函数必须是大于或等于所读取的数据的长度。  
  
-   `FileGet` 只不过是元素之间没有空白，像每个读取时，单独读取元素的结构。 在磁盘上，用户定义类型的动态数组 (使用编写`FilePut`) 通过其长度等于 2 加上 8 倍的维度数的描述符作为前缀: (2 + 8 * NumberOfDimensions)。 指定的记录长度`RecordLength`子句中的`FileOpen`函数必须是大于或等于读取各个元素所需的所有字节之和。 这包括任何数组和其描述符。 `VBFixedString`特性可以应用于字符串字段中的结构，以指示字符串写入时的大小到磁盘。  
  
## <a name="binary-mode"></a>二进制模式  
 打开的文件中`Binary`模式下，大部分`Random`模式规则适用，有一些例外情况。 在中打开文件的以下规则`Binary`模式不同于为规则`Random`模式：  
  
-   `RecordLength`子句中的`FileOpen`函数不起任何作用。 `FileGet` 连续; 从磁盘读取所有变量也就是说，而不填充记录之间。  
  
-   对于在结构中，数组以外的任何数组`FileGet`只读取数据。 未不读取任何说明符。  
  
-   `FileGet` 读取不是元素的结构不需要双字节长度说明符的可变长度字符串。 读取的字节数等于已中字符串的字符数。  
  
    > [!IMPORTANT]
    >  通过使用从文件中读取`FileGet`函数需要`Read`从访问<xref:System.Security.Permissions.FileIOPermissionAccess>枚举。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 且不等于 -1。</exception>
        <exception cref="T:System.IO.IOException">文件模式无效。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files.md">从文件读取 (Visual Basic)</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">写入文件 (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref double Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, float64&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Double@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Double, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Double" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必须的。 任何有效文件数。</param>
        <param name="Value">必须的。 数据读入到其中的有效变量名称。</param>
        <param name="RecordNumber">可选。 读取的开始位置处的记录号（<see langword="Random" /> 模式文件）或字节数（<see langword="Binary" /> 模式文件）。</param>
        <summary>将数据从打开的磁盘文件读入到一个变量中。 相比 <see langword="FileGet" />，<see langword="My" /> 功能可使文件 I/O 操作的效率更高、性能更好。 有关详情，请参阅<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet` 仅在中有效`Random`和`Binary`模式。  
  
 与读取的数据`FileGet`通常通过使用写入到文件`FilePut`。  
  
 第一个记录或文件中的字节位置 1，第二个记录或字节在位置 2，依此类推。 如果省略`RecordNumber`下, 一步的记录或最后一个字节`FileGet`或`FilePut`函数 (或指向的最后一个`Seek`函数) 中读取。  
  
> [!IMPORTANT]
>  时从文件读取，不要根据文件扩展名的文件的内容的决策。 例如，名为 form1.vb 的文件不可能的 Visual Basic 源代码文件。  
  
## <a name="random-mode"></a>随机模式  
 有关在中打开文件`Random`模式下，下列规则适用：  
  
-   如果读取的数据的长度小于中指定的长度`RecordLength`子句`FileOpen`函数，`FileGet`读取的记录长度边界上的后续记录。 用文件缓冲区的现有内容填充一条记录的末尾和下一条记录的开始之间的空间。 由于不能与任何颇有自信地确定填充的数据量，它通常是最好使记录的长度与读取的数据的长度匹配。  
  
-   默认情况下，如果变量是一个字符串，`FileGet`读取一个双字节说明符的包含的字符串长度，然后读取该变量的数据。 因此，指定的记录长度`RecordLength`子句`FileOpen`函数必须至少为两个字节大于字符串的实际长度。 Visual Basic 6.0 和早期版本支持固定长度字符串;在放到文件，则不写入长度说明符。 如果你想要读取的字符串，而无需描述符，则应传递`True`到`StringIsFixedLength`参数，并应为正确的长度，读取到的字符串。  
  
-   如果读入的变量是一个数组，可以选择是否要读取的大小和维数的数组说明符。 若要编写描述符，设置`ArrayIsDynamic`参数`True`。 在数组读取时，必须以匹配数组写入的方式。 如果它与描述符写入数组时，您必须读取描述符。 如果未使用说明符，大小和边界的数组传递到`FileGet`确定要读取的内容。  
  
     描述符指定秩的数组、 大小和为每个级别的下限。 其长度等于 2 + 8 时间维度的数目: (2 + 8 * NumberOfDimensions)。 指定的记录长度`RecordLength`中的参数`FileOpen`函数必须是大于或等于写入数组数据和数组描述符需要的所有字节之和。 例如，以下数组声明需要 218 个字节时将数组写入到磁盘。  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     218 个字节分配，如下所示：  
  
    -   描述符的 18 个字节: (2 + 8 * 2)  
  
    -   200 个字节的数据: (5 * 10 * 4)。  
  
-   如果读入的变量是任何其他类型的变量 （不可变长度字符串或对象）`FileGet`只读取变量数据。 指定的记录长度`RecordLength`子句中的`FileOpen`函数必须是大于或等于所读取的数据的长度。  
  
-   `FileGet` 只不过是元素之间没有空白，像每个读取时，单独读取元素的结构。 在磁盘上，用户定义类型的动态数组 (使用编写`FilePut`) 通过其长度等于 2 加上 8 倍的维度数的描述符作为前缀: (2 + 8 * NumberOfDimensions)。 指定的记录长度`RecordLength`子句中的`FileOpen`函数必须是大于或等于读取各个元素所需的所有字节之和。 这包括任何数组和其描述符。 `VBFixedString`特性可以应用于字符串字段中的结构，以指示字符串写入时的大小到磁盘。  
  
## <a name="binary-mode"></a>二进制模式  
 打开的文件中`Binary`模式下，大部分`Random`模式规则适用，有一些例外情况。 在中打开文件的以下规则`Binary`模式不同于为规则`Random`模式：  
  
-   `RecordLength`子句中的`FileOpen`函数不起任何作用。 `FileGet` 连续; 从磁盘读取所有变量也就是说，而不填充记录之间。  
  
-   对于在结构中，数组以外的任何数组`FileGet`只读取数据。 未不读取任何说明符。  
  
-   `FileGet` 读取不是元素的结构不需要双字节长度说明符的可变长度字符串。 读取的字节数等于已中字符串的字符数。  
  
    > [!IMPORTANT]
    >  通过使用从文件中读取`FileGet`函数需要`Read`从访问<xref:System.Security.Permissions.FileIOPermissionAccess>枚举。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 且不等于 -1。</exception>
        <exception cref="T:System.IO.IOException">文件模式无效。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files.md">从文件读取 (Visual Basic)</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">写入文件 (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref short Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, int16&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int16@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Short, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int16" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必须的。 任何有效文件数。</param>
        <param name="Value">必须的。 数据读入到其中的有效变量名称。</param>
        <param name="RecordNumber">可选。 读取的开始位置处的记录号（<see langword="Random" /> 模式文件）或字节数（<see langword="Binary" /> 模式文件）。</param>
        <summary>将数据从打开的磁盘文件读入到一个变量中。 相比 <see langword="FileGet" />，<see langword="My" /> 功能可使文件 I/O 操作的效率更高、性能更好。 有关详情，请参阅<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet` 仅在中有效`Random`和`Binary`模式。  
  
 与读取的数据`FileGet`通常通过使用写入到文件`FilePut`。  
  
 第一个记录或文件中的字节位置 1，第二个记录或字节在位置 2，依此类推。 如果省略`RecordNumber`下, 一步的记录或最后一个字节`FileGet`或`FilePut`函数 (或指向的最后一个`Seek`函数) 中读取。  
  
> [!IMPORTANT]
>  时从文件读取，不要根据文件扩展名的文件的内容的决策。 例如，名为 form1.vb 的文件不可能的 Visual Basic 源代码文件。  
  
## <a name="random-mode"></a>随机模式  
 有关在中打开文件`Random`模式下，下列规则适用：  
  
-   如果读取的数据的长度小于中指定的长度`RecordLength`子句`FileOpen`函数，`FileGet`读取的记录长度边界上的后续记录。 用文件缓冲区的现有内容填充一条记录的末尾和下一条记录的开始之间的空间。 由于不能与任何颇有自信地确定填充的数据量，它通常是最好使记录的长度与读取的数据的长度匹配。  
  
-   默认情况下，如果变量是一个字符串，`FileGet`读取一个双字节说明符的包含的字符串长度，然后读取该变量的数据。 因此，指定的记录长度`RecordLength`子句`FileOpen`函数必须至少为两个字节大于字符串的实际长度。 Visual Basic 6.0 和早期版本支持固定长度字符串;在放到文件，则不写入长度说明符。 如果你想要读取的字符串，而无需描述符，则应传递`True`到`StringIsFixedLength`参数，并应为正确的长度，读取到的字符串。  
  
-   如果读入的变量是一个数组，可以选择是否要读取的大小和维数的数组说明符。 若要编写描述符，设置`ArrayIsDynamic`参数`True`。 在数组读取时，必须以匹配数组写入的方式。 如果它与描述符写入数组时，您必须读取描述符。 如果未使用说明符，大小和边界的数组传递到`FileGet`确定要读取的内容。  
  
     描述符指定秩的数组、 大小和为每个级别的下限。 其长度等于 2 + 8 时间维度的数目: (2 + 8 * NumberOfDimensions)。 指定的记录长度`RecordLength`中的参数`FileOpen`函数必须是大于或等于写入数组数据和数组描述符需要的所有字节之和。 例如，以下数组声明需要 218 个字节时将数组写入到磁盘。  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     218 个字节分配，如下所示：  
  
    -   描述符的 18 个字节: (2 + 8 * 2)  
  
    -   200 个字节的数据: (5 * 10 * 4)。  
  
-   如果读入的变量是任何其他类型的变量 （不可变长度字符串或对象）`FileGet`只读取变量数据。 指定的记录长度`RecordLength`子句中的`FileOpen`函数必须是大于或等于所读取的数据的长度。  
  
-   `FileGet` 只不过是元素之间没有空白，像每个读取时，单独读取元素的结构。 在磁盘上，用户定义类型的动态数组 (使用编写`FilePut`) 通过其长度等于 2 加上 8 倍的维度数的描述符作为前缀: (2 + 8 * NumberOfDimensions)。 指定的记录长度`RecordLength`子句中的`FileOpen`函数必须是大于或等于读取各个元素所需的所有字节之和。 这包括任何数组和其描述符。 `VBFixedString`特性可以应用于字符串字段中的结构，以指示字符串写入时的大小到磁盘。  
  
## <a name="binary-mode"></a>二进制模式  
 打开的文件中`Binary`模式下，大部分`Random`模式规则适用，有一些例外情况。 在中打开文件的以下规则`Binary`模式不同于为规则`Random`模式：  
  
-   `RecordLength`子句中的`FileOpen`函数不起任何作用。 `FileGet` 连续; 从磁盘读取所有变量也就是说，而不填充记录之间。  
  
-   对于在结构中，数组以外的任何数组`FileGet`只读取数据。 未不读取任何说明符。  
  
-   `FileGet` 读取不是元素的结构不需要双字节长度说明符的可变长度字符串。 读取的字节数等于已中字符串的字符数。  
  
    > [!IMPORTANT]
    >  通过使用从文件中读取`FileGet`函数需要`Read`从访问<xref:System.Security.Permissions.FileIOPermissionAccess>枚举。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 且不等于 -1。</exception>
        <exception cref="T:System.IO.IOException">文件模式无效。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files.md">从文件读取 (Visual Basic)</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">写入文件 (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref int Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, int32&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int32@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Integer, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int32" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必须的。 任何有效文件数。</param>
        <param name="Value">必须的。 数据读入到其中的有效变量名称。</param>
        <param name="RecordNumber">可选。 读取的开始位置处的记录号（<see langword="Random" /> 模式文件）或字节数（<see langword="Binary" /> 模式文件）。</param>
        <summary>将数据从打开的磁盘文件读入到一个变量中。 相比 <see langword="FileGet" />，<see langword="My" /> 功能可使文件 I/O 操作的效率更高、性能更好。 有关详情，请参阅<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet` 仅在中有效`Random`和`Binary`模式。  
  
 与读取的数据`FileGet`通常通过使用写入到文件`FilePut`。  
  
 第一个记录或文件中的字节位置 1，第二个记录或字节在位置 2，依此类推。 如果省略`RecordNumber`下, 一步的记录或最后一个字节`FileGet`或`FilePut`函数 (或指向的最后一个`Seek`函数) 中读取。  
  
> [!IMPORTANT]
>  时从文件读取，不要根据文件扩展名的文件的内容的决策。 例如，名为 form1.vb 的文件不可能的 Visual Basic 源代码文件。  
  
## <a name="random-mode"></a>随机模式  
 有关在中打开文件`Random`模式下，下列规则适用：  
  
-   如果读取的数据的长度小于中指定的长度`RecordLength`子句`FileOpen`函数，`FileGet`读取的记录长度边界上的后续记录。 用文件缓冲区的现有内容填充一条记录的末尾和下一条记录的开始之间的空间。 由于不能与任何颇有自信地确定填充的数据量，它通常是最好使记录的长度与读取的数据的长度匹配。  
  
-   默认情况下，如果变量是一个字符串，`FileGet`读取一个双字节说明符的包含的字符串长度，然后读取该变量的数据。 因此，指定的记录长度`RecordLength`子句`FileOpen`函数必须至少为两个字节大于字符串的实际长度。 Visual Basic 6.0 和早期版本支持固定长度字符串;在放到文件，则不写入长度说明符。 如果你想要读取的字符串，而无需描述符，则应传递`True`到`StringIsFixedLength`参数，并应为正确的长度，读取到的字符串。  
  
-   如果读入的变量是一个数组，可以选择是否要读取的大小和维数的数组说明符。 若要编写描述符，设置`ArrayIsDynamic`参数`True`。 在数组读取时，必须以匹配数组写入的方式。 如果它与描述符写入数组时，您必须读取描述符。 如果未使用说明符，大小和边界的数组传递到`FileGet`确定要读取的内容。  
  
     描述符指定秩的数组、 大小和为每个级别的下限。 其长度等于 2 + 8 时间维度的数目: (2 + 8 * NumberOfDimensions)。 指定的记录长度`RecordLength`中的参数`FileOpen`函数必须是大于或等于写入数组数据和数组描述符需要的所有字节之和。 例如，以下数组声明需要 218 个字节时将数组写入到磁盘。  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     218 个字节分配，如下所示：  
  
    -   描述符的 18 个字节: (2 + 8 * 2)  
  
    -   200 个字节的数据: (5 * 10 * 4)。  
  
-   如果读入的变量是任何其他类型的变量 （不可变长度字符串或对象）`FileGet`只读取变量数据。 指定的记录长度`RecordLength`子句中的`FileOpen`函数必须是大于或等于所读取的数据的长度。  
  
-   `FileGet` 只不过是元素之间没有空白，像每个读取时，单独读取元素的结构。 在磁盘上，用户定义类型的动态数组 (使用编写`FilePut`) 通过其长度等于 2 加上 8 倍的维度数的描述符作为前缀: (2 + 8 * NumberOfDimensions)。 指定的记录长度`RecordLength`子句中的`FileOpen`函数必须是大于或等于读取各个元素所需的所有字节之和。 这包括任何数组和其描述符。 `VBFixedString`特性可以应用于字符串字段中的结构，以指示字符串写入时的大小到磁盘。  
  
## <a name="binary-mode"></a>二进制模式  
 打开的文件中`Binary`模式下，大部分`Random`模式规则适用，有一些例外情况。 在中打开文件的以下规则`Binary`模式不同于为规则`Random`模式：  
  
-   `RecordLength`子句中的`FileOpen`函数不起任何作用。 `FileGet` 连续; 从磁盘读取所有变量也就是说，而不填充记录之间。  
  
-   对于在结构中，数组以外的任何数组`FileGet`只读取数据。 未不读取任何说明符。  
  
-   `FileGet` 读取不是元素的结构不需要双字节长度说明符的可变长度字符串。 读取的字节数等于已中字符串的字符数。  
  
    > [!IMPORTANT]
    >  通过使用从文件中读取`FileGet`函数需要`Read`从访问<xref:System.Security.Permissions.FileIOPermissionAccess>枚举。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 且不等于 -1。</exception>
        <exception cref="T:System.IO.IOException">文件模式无效。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files.md">从文件读取 (Visual Basic)</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">写入文件 (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref long Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, int64&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int64@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Long, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int64" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必须的。 任何有效文件数。</param>
        <param name="Value">必须的。 数据读入到其中的有效变量名称。</param>
        <param name="RecordNumber">可选。 读取的开始位置处的记录号（<see langword="Random" /> 模式文件）或字节数（<see langword="Binary" /> 模式文件）。</param>
        <summary>将数据从打开的磁盘文件读入到一个变量中。 相比 <see langword="FileGet" />，<see langword="My" /> 功能可使文件 I/O 操作的效率更高、性能更好。 有关详情，请参阅<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet` 仅在中有效`Random`和`Binary`模式。  
  
 与读取的数据`FileGet`通常通过使用写入到文件`FilePut`。  
  
 第一个记录或文件中的字节位置 1，第二个记录或字节在位置 2，依此类推。 如果省略`RecordNumber`下, 一步的记录或最后一个字节`FileGet`或`FilePut`函数 (或指向的最后一个`Seek`函数) 中读取。  
  
> [!IMPORTANT]
>  时从文件读取，不要根据文件扩展名的文件的内容的决策。 例如，名为 form1.vb 的文件不可能的 Visual Basic 源代码文件。  
  
## <a name="random-mode"></a>随机模式  
 有关在中打开文件`Random`模式下，下列规则适用：  
  
-   如果读取的数据的长度小于中指定的长度`RecordLength`子句`FileOpen`函数，`FileGet`读取的记录长度边界上的后续记录。 用文件缓冲区的现有内容填充一条记录的末尾和下一条记录的开始之间的空间。 由于不能与任何颇有自信地确定填充的数据量，它通常是最好使记录的长度与读取的数据的长度匹配。  
  
-   默认情况下，如果变量是一个字符串，`FileGet`读取一个双字节说明符的包含的字符串长度，然后读取该变量的数据。 因此，指定的记录长度`RecordLength`子句`FileOpen`函数必须至少为两个字节大于字符串的实际长度。 Visual Basic 6.0 和早期版本支持固定长度字符串;在放到文件，则不写入长度说明符。 如果你想要读取的字符串，而无需描述符，则应传递`True`到`StringIsFixedLength`参数，并应为正确的长度，读取到的字符串。  
  
-   如果读入的变量是一个数组，可以选择是否要读取的大小和维数的数组说明符。 若要编写描述符，设置`ArrayIsDynamic`参数`True`。 在数组读取时，必须以匹配数组写入的方式。 如果它与描述符写入数组时，您必须读取描述符。 如果未使用说明符，大小和边界的数组传递到`FileGet`确定要读取的内容。  
  
     描述符指定秩的数组、 大小和为每个级别的下限。 其长度等于 2 + 8 时间维度的数目: (2 + 8 * NumberOfDimensions)。 指定的记录长度`RecordLength`中的参数`FileOpen`函数必须是大于或等于写入数组数据和数组描述符需要的所有字节之和。 例如，以下数组声明需要 218 个字节时将数组写入到磁盘。  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     218 个字节分配，如下所示：  
  
    -   描述符的 18 个字节: (2 + 8 * 2)  
  
    -   200 个字节的数据: (5 * 10 * 4)。  
  
-   如果读入的变量是任何其他类型的变量 （不可变长度字符串或对象）`FileGet`只读取变量数据。 指定的记录长度`RecordLength`子句中的`FileOpen`函数必须是大于或等于所读取的数据的长度。  
  
-   `FileGet` 只不过是元素之间没有空白，像每个读取时，单独读取元素的结构。 在磁盘上，用户定义类型的动态数组 (使用编写`FilePut`) 通过其长度等于 2 加上 8 倍的维度数的描述符作为前缀: (2 + 8 * NumberOfDimensions)。 指定的记录长度`RecordLength`子句中的`FileOpen`函数必须是大于或等于读取各个元素所需的所有字节之和。 这包括任何数组和其描述符。 `VBFixedString`特性可以应用于字符串字段中的结构，以指示字符串写入时的大小到磁盘。  
  
## <a name="binary-mode"></a>二进制模式  
 打开的文件中`Binary`模式下，大部分`Random`模式规则适用，有一些例外情况。 在中打开文件的以下规则`Binary`模式不同于为规则`Random`模式：  
  
-   `RecordLength`子句中的`FileOpen`函数不起任何作用。 `FileGet` 连续; 从磁盘读取所有变量也就是说，而不填充记录之间。  
  
-   对于在结构中，数组以外的任何数组`FileGet`只读取数据。 未不读取任何说明符。  
  
-   `FileGet` 读取不是元素的结构不需要双字节长度说明符的可变长度字符串。 读取的字节数等于已中字符串的字符数。  
  
    > [!IMPORTANT]
    >  通过使用从文件中读取`FileGet`函数需要`Read`从访问<xref:System.Security.Permissions.FileIOPermissionAccess>枚举。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 且不等于 -1。</exception>
        <exception cref="T:System.IO.IOException">文件模式无效。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files.md">从文件读取 (Visual Basic)</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">写入文件 (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref float Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, float32&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Single@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Single, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Single" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必须的。 任何有效文件数。</param>
        <param name="Value">必须的。 数据读入到其中的有效变量名称。</param>
        <param name="RecordNumber">可选。 读取的开始位置处的记录号（<see langword="Random" /> 模式文件）或字节数（<see langword="Binary" /> 模式文件）。</param>
        <summary>将数据从打开的磁盘文件读入到一个变量中。 相比 <see langword="FileGet" />，<see langword="My" /> 功能可使文件 I/O 操作的效率更高、性能更好。 有关详情，请参阅<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet` 仅在中有效`Random`和`Binary`模式。  
  
 与读取的数据`FileGet`通常通过使用写入到文件`FilePut`。  
  
 第一个记录或文件中的字节位置 1，第二个记录或字节在位置 2，依此类推。 如果省略`RecordNumber`下, 一步的记录或最后一个字节`FileGet`或`FilePut`函数 (或指向的最后一个`Seek`函数) 中读取。  
  
> [!IMPORTANT]
>  时从文件读取，不要根据文件扩展名的文件的内容的决策。 例如，名为 form1.vb 的文件不可能的 Visual Basic 源代码文件。  
  
## <a name="random-mode"></a>随机模式  
 有关在中打开文件`Random`模式下，下列规则适用：  
  
-   如果读取的数据的长度小于中指定的长度`RecordLength`子句`FileOpen`函数，`FileGet`读取的记录长度边界上的后续记录。 用文件缓冲区的现有内容填充一条记录的末尾和下一条记录的开始之间的空间。 由于不能与任何颇有自信地确定填充的数据量，它通常是最好使记录的长度与读取的数据的长度匹配。  
  
-   默认情况下，如果变量是一个字符串，`FileGet`读取一个双字节说明符的包含的字符串长度，然后读取该变量的数据。 因此，指定的记录长度`RecordLength`子句`FileOpen`函数必须至少为两个字节大于字符串的实际长度。 Visual Basic 6.0 和早期版本支持固定长度字符串;在放到文件，则不写入长度说明符。 如果你想要读取的字符串，而无需描述符，则应传递`True`到`StringIsFixedLength`参数，并应为正确的长度，读取到的字符串。  
  
-   如果读入的变量是一个数组，可以选择是否要读取的大小和维数的数组说明符。 若要编写描述符，设置`ArrayIsDynamic`参数`True`。 在数组读取时，必须以匹配数组写入的方式。 如果它与描述符写入数组时，您必须读取描述符。 如果未使用说明符，大小和边界的数组传递到`FileGet`确定要读取的内容。  
  
     描述符指定秩的数组、 大小和为每个级别的下限。 其长度等于 2 + 8 时间维度的数目: (2 + 8 * NumberOfDimensions)。 指定的记录长度`RecordLength`中的参数`FileOpen`函数必须是大于或等于写入数组数据和数组描述符需要的所有字节之和。 例如，以下数组声明需要 218 个字节时将数组写入到磁盘。  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     218 个字节分配，如下所示：  
  
    -   描述符的 18 个字节: (2 + 8 * 2)  
  
    -   200 个字节的数据: (5 * 10 * 4)。  
  
-   如果读入的变量是任何其他类型的变量 （不可变长度字符串或对象）`FileGet`只读取变量数据。 指定的记录长度`RecordLength`子句中的`FileOpen`函数必须是大于或等于所读取的数据的长度。  
  
-   `FileGet` 只不过是元素之间没有空白，像每个读取时，单独读取元素的结构。 在磁盘上，用户定义类型的动态数组 (使用编写`FilePut`) 通过其长度等于 2 加上 8 倍的维度数的描述符作为前缀: (2 + 8 * NumberOfDimensions)。 指定的记录长度`RecordLength`子句中的`FileOpen`函数必须是大于或等于读取各个元素所需的所有字节之和。 这包括任何数组和其描述符。 `VBFixedString`特性可以应用于字符串字段中的结构，以指示字符串写入时的大小到磁盘。  
  
## <a name="binary-mode"></a>二进制模式  
 打开的文件中`Binary`模式下，大部分`Random`模式规则适用，有一些例外情况。 在中打开文件的以下规则`Binary`模式不同于为规则`Random`模式：  
  
-   `RecordLength`子句中的`FileOpen`函数不起任何作用。 `FileGet` 连续; 从磁盘读取所有变量也就是说，而不填充记录之间。  
  
-   对于在结构中，数组以外的任何数组`FileGet`只读取数据。 未不读取任何说明符。  
  
-   `FileGet` 读取不是元素的结构不需要双字节长度说明符的可变长度字符串。 读取的字节数等于已中字符串的字符数。  
  
    > [!IMPORTANT]
    >  通过使用从文件中读取`FileGet`函数需要`Read`从访问<xref:System.Security.Permissions.FileIOPermissionAccess>枚举。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 且不等于 -1。</exception>
        <exception cref="T:System.IO.IOException">文件模式无效。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files.md">从文件读取 (Visual Basic)</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">写入文件 (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref ValueType Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, class System.ValueType&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.ValueType@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As ValueType, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.ValueType" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必须的。 任何有效文件数。</param>
        <param name="Value">必须的。 数据读入到其中的有效变量名称。</param>
        <param name="RecordNumber">可选。 读取的开始位置处的记录号（<see langword="Random" /> 模式文件）或字节数（<see langword="Binary" /> 模式文件）。</param>
        <summary>将数据从打开的磁盘文件读入到一个变量中。 相比 <see langword="FileGet" />，<see langword="My" /> 功能可使文件 I/O 操作的效率更高、性能更好。 有关详情，请参阅<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet` 仅在中有效`Random`和`Binary`模式。  
  
 与读取的数据`FileGet`通常通过使用写入到文件`FilePut`。  
  
 第一个记录或文件中的字节位置 1，第二个记录或字节在位置 2，依此类推。 如果省略`RecordNumber`下, 一步的记录或最后一个字节`FileGet`或`FilePut`函数 (或指向的最后一个`Seek`函数) 中读取。  
  
> [!IMPORTANT]
>  时从文件读取，不要根据文件扩展名的文件的内容的决策。 例如，名为 form1.vb 的文件不可能的 Visual Basic 源代码文件。  
  
## <a name="random-mode"></a>随机模式  
 有关在中打开文件`Random`模式下，下列规则适用：  
  
-   如果读取的数据的长度小于中指定的长度`RecordLength`子句`FileOpen`函数，`FileGet`读取的记录长度边界上的后续记录。 用文件缓冲区的现有内容填充一条记录的末尾和下一条记录的开始之间的空间。 由于不能与任何颇有自信地确定填充的数据量，它通常是最好使记录的长度与读取的数据的长度匹配。  
  
-   默认情况下，如果变量是一个字符串，`FileGet`读取一个双字节说明符的包含的字符串长度，然后读取该变量的数据。 因此，指定的记录长度`RecordLength`子句`FileOpen`函数必须至少为两个字节大于字符串的实际长度。 Visual Basic 6.0 和早期版本支持固定长度字符串;在放到文件，则不写入长度说明符。 如果你想要读取的字符串，而无需描述符，则应传递`True`到`StringIsFixedLength`参数，并应为正确的长度，读取到的字符串。  
  
-   如果读入的变量是一个数组，可以选择是否要读取的大小和维数的数组说明符。 若要编写描述符，设置`ArrayIsDynamic`参数`True`。 在数组读取时，必须以匹配数组写入的方式。 如果它与描述符写入数组时，您必须读取描述符。 如果未使用说明符，大小和边界的数组传递到`FileGet`确定要读取的内容。  
  
     描述符指定秩的数组、 大小和为每个级别的下限。 其长度等于 2 + 8 时间维度的数目: (2 + 8 * NumberOfDimensions)。 指定的记录长度`RecordLength`中的参数`FileOpen`函数必须是大于或等于写入数组数据和数组描述符需要的所有字节之和。 例如，以下数组声明需要 218 个字节时将数组写入到磁盘。  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     218 个字节分配，如下所示：  
  
    -   描述符的 18 个字节: (2 + 8 * 2)  
  
    -   200 个字节的数据: (5 * 10 * 4)。  
  
-   如果读入的变量是任何其他类型的变量 （不可变长度字符串或对象）`FileGet`只读取变量数据。 指定的记录长度`RecordLength`子句中的`FileOpen`函数必须是大于或等于所读取的数据的长度。  
  
-   `FileGet` 只不过是元素之间没有空白，像每个读取时，单独读取元素的结构。 在磁盘上，用户定义类型的动态数组 (使用编写`FilePut`) 通过其长度等于 2 加上 8 倍的维度数的描述符作为前缀: (2 + 8 * NumberOfDimensions)。 指定的记录长度`RecordLength`子句中的`FileOpen`函数必须是大于或等于读取各个元素所需的所有字节之和。 这包括任何数组和其描述符。 `VBFixedString`特性可以应用于字符串字段中的结构，以指示字符串写入时的大小到磁盘。  
  
## <a name="binary-mode"></a>二进制模式  
 打开的文件中`Binary`模式下，大部分`Random`模式规则适用，有一些例外情况。 在中打开文件的以下规则`Binary`模式不同于为规则`Random`模式：  
  
-   `RecordLength`子句中的`FileOpen`函数不起任何作用。 `FileGet` 连续; 从磁盘读取所有变量也就是说，而不填充记录之间。  
  
-   对于在结构中，数组以外的任何数组`FileGet`只读取数据。 未不读取任何说明符。  
  
-   `FileGet` 读取不是元素的结构不需要双字节长度说明符的可变长度字符串。 读取的字节数等于已中字符串的字符数。  
  
    > [!IMPORTANT]
    >  通过使用从文件中读取`FileGet`函数需要`Read`从访问<xref:System.Security.Permissions.FileIOPermissionAccess>枚举。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 且不等于 -1。</exception>
        <exception cref="T:System.IO.IOException">文件模式无效。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files.md">从文件读取 (Visual Basic)</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">写入文件 (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref string Value, long RecordNumber = -1, bool StringIsFixedLength = false);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, string&amp; Value, int64 RecordNumber, bool StringIsFixedLength) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.String@,System.Int64,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As String, Optional RecordNumber As Long = -1, Optional StringIsFixedLength As Boolean = false)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 * bool -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber, StringIsFixedLength)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.String" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
        <Parameter Name="StringIsFixedLength" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必须的。 任何有效文件数。</param>
        <param name="Value">必须的。 数据读入到其中的有效变量名称。</param>
        <param name="RecordNumber">可选。 读取的开始位置处的记录号（<see langword="Random" /> 模式文件）或字节数（<see langword="Binary" /> 模式文件）。</param>
        <param name="StringIsFixedLength">可选。 仅在写入字符串时适用。 指定是否为描述长度的字符串写入一个双字节说明符。 默认值为 <see langword="False" />。</param>
        <summary>将数据从打开的磁盘文件读入到一个变量中。 相比 <see langword="FileGet" />，<see langword="My" /> 功能可使文件 I/O 操作的效率更高、性能更好。 有关详情，请参阅<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet` 仅在中有效`Random`和`Binary`模式。  
  
 与读取的数据`FileGet`通常通过使用写入到文件`FilePut`。  
  
 第一个记录或文件中的字节位置 1，第二个记录或字节在位置 2，依此类推。 如果省略`RecordNumber`下, 一步的记录或最后一个字节`FileGet`或`FilePut`函数 (或指向的最后一个`Seek`函数) 中读取。  
  
> [!IMPORTANT]
>  时从文件读取，不要根据文件扩展名的文件的内容的决策。 例如，名为 form1.vb 的文件不可能的 Visual Basic 源代码文件。  
  
## <a name="random-mode"></a>随机模式  
 有关在中打开文件`Random`模式下，下列规则适用：  
  
-   如果读取的数据的长度小于中指定的长度`RecordLength`子句`FileOpen`函数，`FileGet`读取的记录长度边界上的后续记录。 用文件缓冲区的现有内容填充一条记录的末尾和下一条记录的开始之间的空间。 由于不能与任何颇有自信地确定填充的数据量，它通常是最好使记录的长度与读取的数据的长度匹配。  
  
-   默认情况下，如果变量是一个字符串，`FileGet`读取一个双字节说明符的包含的字符串长度，然后读取该变量的数据。 因此，指定的记录长度`RecordLength`子句`FileOpen`函数必须至少为两个字节大于字符串的实际长度。 Visual Basic 6.0 和早期版本支持固定长度字符串;在放到文件，则不写入长度说明符。 如果你想要读取的字符串，而无需描述符，则应传递`True`到`StringIsFixedLength`参数，并应为正确的长度，读取到的字符串。  
  
-   如果读入的变量是一个数组，可以选择是否要读取的大小和维数的数组说明符。 若要编写描述符，设置`ArrayIsDynamic`参数`True`。 在数组读取时，必须以匹配数组写入的方式。 如果它与描述符写入数组时，您必须读取描述符。 如果未使用说明符，大小和边界的数组传递到`FileGet`确定要读取的内容。  
  
     描述符指定秩的数组、 大小和为每个级别的下限。 其长度等于 2 + 8 时间维度的数目: (2 + 8 * NumberOfDimensions)。 指定的记录长度`RecordLength`中的参数`FileOpen`函数必须是大于或等于写入数组数据和数组描述符需要的所有字节之和。 例如，以下数组声明需要 218 个字节时将数组写入到磁盘。  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     218 个字节分配，如下所示：  
  
    -   描述符的 18 个字节: (2 + 8 * 2)  
  
    -   200 个字节的数据: (5 * 10 * 4)。  
  
-   如果读入的变量是任何其他类型的变量 （不可变长度字符串或对象）`FileGet`只读取变量数据。 指定的记录长度`RecordLength`子句中的`FileOpen`函数必须是大于或等于所读取的数据的长度。  
  
-   `FileGet` 只不过是元素之间没有空白，像每个读取时，单独读取元素的结构。 在磁盘上，用户定义类型的动态数组 (使用编写`FilePut`) 通过其长度等于 2 加上 8 倍的维度数的描述符作为前缀: (2 + 8 * NumberOfDimensions)。 指定的记录长度`RecordLength`子句中的`FileOpen`函数必须是大于或等于读取各个元素所需的所有字节之和。 这包括任何数组和其描述符。 `VBFixedString`特性可以应用于字符串字段中的结构，以指示字符串写入时的大小到磁盘。  
  
## <a name="binary-mode"></a>二进制模式  
 打开的文件中`Binary`模式下，大部分`Random`模式规则适用，有一些例外情况。 在中打开文件的以下规则`Binary`模式不同于为规则`Random`模式：  
  
-   `RecordLength`子句中的`FileOpen`函数不起任何作用。 `FileGet` 连续; 从磁盘读取所有变量也就是说，而不填充记录之间。  
  
-   对于在结构中，数组以外的任何数组`FileGet`只读取数据。 未不读取任何说明符。  
  
-   `FileGet` 读取不是元素的结构不需要双字节长度说明符的可变长度字符串。 读取的字节数等于已中字符串的字符数。  
  
    > [!IMPORTANT]
    >  通过使用从文件中读取`FileGet`函数需要`Read`从访问<xref:System.Security.Permissions.FileIOPermissionAccess>枚举。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 且不等于 -1。</exception>
        <exception cref="T:System.IO.IOException">文件模式无效。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files.md">从文件读取 (Visual Basic)</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">写入文件 (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref Array Value, long RecordNumber = -1, bool ArrayIsDynamic = false, bool StringIsFixedLength = false);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, class System.Array&amp; Value, int64 RecordNumber, bool ArrayIsDynamic, bool StringIsFixedLength) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Array@,System.Int64,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Array, Optional RecordNumber As Long = -1, Optional ArrayIsDynamic As Boolean = false, Optional StringIsFixedLength As Boolean = false)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 * bool * bool -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber, ArrayIsDynamic, StringIsFixedLength)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Array" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
        <Parameter Name="ArrayIsDynamic" Type="System.Boolean" />
        <Parameter Name="StringIsFixedLength" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必须的。 任何有效文件数。</param>
        <param name="Value">必须的。 数据读入到其中的有效变量名称。</param>
        <param name="RecordNumber">可选。 读取的开始位置处的记录号（<see langword="Random" /> 模式文件）或字节数（<see langword="Binary" /> 模式文件）。</param>
        <param name="ArrayIsDynamic">可选。 仅当写入数组时使用。 指定是否将数组视为动态数组，以及是否需要描述数组大小和边界的数组说明符。</param>
        <param name="StringIsFixedLength">可选。 仅在写入字符串时适用。 指定是否为描述长度的字符串写入一个双字节说明符。 默认值为 <see langword="False" />。</param>
        <summary>将数据从打开的磁盘文件读入到一个变量中。 相比 <see langword="FileGet" />，<see langword="My" /> 功能可使文件 I/O 操作的效率更高、性能更好。 有关详情，请参阅<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet` 仅在中有效`Random`和`Binary`模式。  
  
 与读取的数据`FileGet`通常通过使用写入到文件`FilePut`。  
  
 第一个记录或文件中的字节位置 1，第二个记录或字节在位置 2，依此类推。 如果省略`RecordNumber`下, 一步的记录或最后一个字节`FileGet`或`FilePut`函数 (或指向的最后一个`Seek`函数) 中读取。  
  
> [!IMPORTANT]
>  时从文件读取，不要根据文件扩展名的文件的内容的决策。 例如，名为 form1.vb 的文件不可能的 Visual Basic 源代码文件。  
  
## <a name="random-mode"></a>随机模式  
 有关在中打开文件`Random`模式下，下列规则适用：  
  
-   如果读取的数据的长度小于中指定的长度`RecordLength`子句`FileOpen`函数，`FileGet`读取的记录长度边界上的后续记录。 用文件缓冲区的现有内容填充一条记录的末尾和下一条记录的开始之间的空间。 由于不能与任何颇有自信地确定填充的数据量，它通常是最好使记录的长度与读取的数据的长度匹配。  
  
-   默认情况下，如果变量是一个字符串，`FileGet`读取一个双字节说明符的包含的字符串长度，然后读取该变量的数据。 因此，指定的记录长度`RecordLength`子句`FileOpen`函数必须至少为两个字节大于字符串的实际长度。 Visual Basic 6.0 和早期版本支持固定长度字符串;在放到文件，则不写入长度说明符。 如果你想要读取的字符串，而无需描述符，则应传递`True`到`StringIsFixedLength`参数，并应为正确的长度，读取到的字符串。  
  
-   如果读入的变量是一个数组，可以选择是否要读取的大小和维数的数组说明符。 若要编写描述符，设置`ArrayIsDynamic`参数`True`。 在数组读取时，必须以匹配数组写入的方式。 如果它与描述符写入数组时，您必须读取描述符。 如果未使用说明符，大小和边界的数组传递到`FileGet`确定要读取的内容。  
  
     描述符指定秩的数组、 大小和为每个级别的下限。 其长度等于 2 + 8 时间维度的数目: (2 + 8 * NumberOfDimensions)。 指定的记录长度`RecordLength`中的参数`FileOpen`函数必须是大于或等于写入数组数据和数组描述符需要的所有字节之和。 例如，以下数组声明需要 218 个字节时将数组写入到磁盘。  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     218 个字节分配，如下所示：  
  
    -   描述符的 18 个字节: (2 + 8 * 2)  
  
    -   200 个字节的数据: (5 * 10 * 4)。  
  
-   如果读入的变量是任何其他类型的变量 （不可变长度字符串或对象）`FileGet`只读取变量数据。 指定的记录长度`RecordLength`子句中的`FileOpen`函数必须是大于或等于所读取的数据的长度。  
  
-   `FileGet` 只不过是元素之间没有空白，像每个读取时，单独读取元素的结构。 在磁盘上，用户定义类型的动态数组 (使用编写`FilePut`) 通过其长度等于 2 加上 8 倍的维度数的描述符作为前缀: (2 + 8 * NumberOfDimensions)。 指定的记录长度`RecordLength`子句中的`FileOpen`函数必须是大于或等于读取各个元素所需的所有字节之和。 这包括任何数组和其描述符。 `VBFixedString`特性可以应用于字符串字段中的结构，以指示字符串写入时的大小到磁盘。  
  
## <a name="binary-mode"></a>二进制模式  
 打开的文件中`Binary`模式下，大部分`Random`模式规则适用，有一些例外情况。 在中打开文件的以下规则`Binary`模式不同于为规则`Random`模式：  
  
-   `RecordLength`子句中的`FileOpen`函数不起任何作用。 `FileGet` 连续; 从磁盘读取所有变量也就是说，而不填充记录之间。  
  
-   对于在结构中，数组以外的任何数组`FileGet`只读取数据。 未不读取任何说明符。  
  
-   `FileGet` 读取不是元素的结构不需要双字节长度说明符的可变长度字符串。 读取的字节数等于已中字符串的字符数。  
  
    > [!IMPORTANT]
    >  通过使用从文件中读取`FileGet`函数需要`Read`从访问<xref:System.Security.Permissions.FileIOPermissionAccess>枚举。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 且不等于 -1。</exception>
        <exception cref="T:System.IO.IOException">文件模式无效。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files.md">从文件读取 (Visual Basic)</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">写入文件 (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="FileGetObject">
      <MemberSignature Language="C#" Value="public static void FileGetObject (int FileNumber, ref object Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGetObject(int32 FileNumber, object&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGetObject (FileNumber As Integer, ByRef Value As Object, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGetObject : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGetObject (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Object" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必须的。 任何有效文件数。</param>
        <param name="Value">必须的。 数据读入到其中的有效变量名称。</param>
        <param name="RecordNumber">可选。 读取的开始位置处的记录号（<see langword="Random" /> 模式文件）或字节数（<see langword="Binary" /> 模式文件）。</param>
        <summary>将数据从打开的磁盘文件读入到一个变量中。  相比 <see langword="FileGetObject" />，<see langword="My" /> 功能可使文件 I/O 操作的效率更高、性能更好。 有关详情，请参阅<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGetObject`而不是使用函数`FileGet`以在编译时避免出现多义性，如果类型`Object`返回而不是另一种类型，如`Integer`， `Long`， `Short`，依次类推。  
  
 如果你想要将写出`Variant`类型，`FileGetObject`是必需的。 如果你使用某个对象作为第二个参数，如有疑问，始终建议你使用`FilePutObject`和`FileGetObject`。  
  
 `FileGetObject` 仅在中有效`Random`和`Binary`模式。  
  
 与读取的数据`FileGetObject`通常与编写`FilePutObject`。  
  
 第一个记录或文件中的字节位置 1，第二个记录或字节在位置 2，依此类推。 如果省略`RecordNumber`，`FileGetObject`上次读取记录号或字节`FileGetObject`或`FilePutObject`函数 (或指向的最后一个`Seek`函数)。  
  
## <a name="random-mode"></a>随机模式  
 有关在中打开文件`Random`模式下，下列规则适用：  
  
-   如果读取的数据的长度小于中指定的长度`RecordLength`子句`FileOpen`函数，`FileGetObject`读取的记录长度边界上的后续记录。 用文件缓冲区的现有内容填充一条记录的末尾和下一条记录的开始之间的空间。 由于不能准确地确定填充的数据量，它是已记录的长度与读取的数据的长度匹配一个好办法。  
  
-   如果读入的变量是一个字符串，默认情况下`FileGetObject`读取一个包含字符串长度的双字节说明符，然后读取该变量的数据。 因此，指定的记录长度`RecordLength`子句`FileOpen`函数必须至少为两个字节大于字符串的实际长度。 Visual Basic 6.0 和早期版本支持固定长度的字符串和读取到文件时，则不会写入长度说明符。 如果你想要读取的字符串，而无需描述符，则应传递`True`到`StringIsFixedLength`参数，并应为正确的长度，读取到的字符串。  
  
-   如果读入的变量为数组，则 `RecordLength` 函数中 `FileOpen` 参数指定的记录长度必须大于或等于写入数组数据和数组描述符需要的所有字节之和。 描述符指定秩的数组、 大小和为每个级别的下限。 其长度等于 2 + 8 倍的维度数： 2 + 8 * NumberOfDimensions。  
  
     例如，以下数组声明需要 218 个字节时将数组写入到磁盘：  
  
     [!code-vb[VbVbalrCatRef#27](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#27)]  
  
     分发了 218 个字节，如下所示：为描述符分发了 18 个字节 (2 + 8 * 2)，为数据分发了 100 个字节 (5 * 10 * 4)。  
  
-   `FileGetObject` 只不过是元素之间没有空白，像每个读取时，单独读取元素的结构。 在磁盘上，用户定义类型的动态数组 (使用编写`FilePutObject`) 其长度等于 2 加上 8 倍的维度数的描述符前缀为： 2 + 8 * NumberOfDimensions。 指定的记录长度`RecordLength`子句中的`FileOpen`函数必须是大于或等于读取各个元素，包括任何数组和其描述符所需的所有字节之和。 <xref:Microsoft.VisualBasic.VBFixedStringAttribute>类可应用于字符串字段中的结构，以指示字符串写入时的大小到磁盘。  
  
## <a name="binary-mode"></a>二进制模式  
 打开的文件中`Binary`模式下，所有的`Random`规则适用，但以下情况例外：  
  
-   `RecordLength`子句中的`FileOpen`函数不起任何作用。 `FileGetObject` 读取所有变量从磁盘连续，也就是说，记录之间没有空白。  
  
-   对于在结构中，数组以外的任何数组`FileGetObject`只读取数据。 未不读取任何说明符。  
  
 `FileGetObject` 读取不是元素的结构不需要双字节长度说明符的可变长度字符串。 读取的字节数等于已中字符串的字符数。  
  
> [!IMPORTANT]
>  时从文件读取，不要根据文件扩展名的文件的内容的决策。 例如，名为 form1.vb 的文件可能不是 Visual Basic 源文件。  
  
   
  
## Examples  
 下面的示例测试文件中读取一条记录，然后检索它。  
  
 [!code-vb[VbVbalrCatRef#26](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#26)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files.md">从文件读取 (Visual Basic)</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">写入文件 (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="FileLen">
      <MemberSignature Language="C#" Value="public static long FileLen (string PathName);" />
      <MemberSignature Language="ILAsm" Value=".method public static int64 FileLen(string PathName) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileLen(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function FileLen (PathName As String) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long FileLen(System::String ^ PathName);" />
      <MemberSignature Language="F#" Value="static member FileLen : string -&gt; int64" Usage="Microsoft.VisualBasic.FileSystem.FileLen PathName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="PathName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="PathName">必须的。 <see langword="String" /> 表达式，用于指定文件。 <paramref name="PathName" /> 可能包括目录或文件夹以及驱动器。</param>
        <summary>返回 <see langword="Long" /> 值，该值以字节为单位指定文件长度。 相比 <see langword="FileLen" />，<see langword="My" /> 功能可使文件 I/O 操作的效率更高、性能更好。 有关详情，请参阅<see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetFileInfo(System.String)" />。</summary>
        <returns>
          <see langword="Long" /> 值，该值以字节为单位指定文件长度。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果指定的文件打开时`FileLen`调用函数，返回的值表示它已打开时的文件的大小。  
  
> [!NOTE]
>  若要获取当前打开的文件的长度，请使用`LOF`函数。  
  
   
  
## Examples  
 此示例使用`FileLen`函数以返回文件的长度以字节为单位。 在此示例中，假定`TestFile`是包含一些数据的文件。  
  
 [!code-vb[VbVbalrCatRef#1](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileNotFoundException">文件不存在。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileDateTime(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.GetAttr(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.LOF(System.Int32)" />
        <altmember cref="T:System.IO.FileNotFoundException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">使用 Visual Basic 访问文件</related>
      </Docs>
    </Member>
    <Member MemberName="FileOpen">
      <MemberSignature Language="C#" Value="public static void FileOpen (int FileNumber, string FileName, Microsoft.VisualBasic.OpenMode Mode, Microsoft.VisualBasic.OpenAccess Access = Microsoft.VisualBasic.OpenAccess.Default, Microsoft.VisualBasic.OpenShare Share = Microsoft.VisualBasic.OpenShare.Default, int RecordLength = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileOpen(int32 FileNumber, string FileName, valuetype Microsoft.VisualBasic.OpenMode Mode, valuetype Microsoft.VisualBasic.OpenAccess Access, valuetype Microsoft.VisualBasic.OpenShare Share, int32 RecordLength) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileOpen (FileNumber As Integer, FileName As String, Mode As OpenMode, Optional Access As OpenAccess = Microsoft.VisualBasic.OpenAccess.Default, Optional Share As OpenShare = Microsoft.VisualBasic.OpenShare.Default, Optional RecordLength As Integer = -1)" />
      <MemberSignature Language="F#" Value="static member FileOpen : int * string * Microsoft.VisualBasic.OpenMode * Microsoft.VisualBasic.OpenAccess * Microsoft.VisualBasic.OpenShare * int -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileOpen (FileNumber, FileName, Mode, Access, Share, RecordLength)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="FileName" Type="System.String" />
        <Parameter Name="Mode" Type="Microsoft.VisualBasic.OpenMode" />
        <Parameter Name="Access" Type="Microsoft.VisualBasic.OpenAccess" />
        <Parameter Name="Share" Type="Microsoft.VisualBasic.OpenShare" />
        <Parameter Name="RecordLength" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必须的。 任何有效文件数。 可使用 <see langword="FreeFile" /> 函数获取下一个可用的文件号。</param>
        <param name="FileName">必须的。 一个指定文件名的 <see langword="String" /> 表达式，其中可包含目录或文件夹以及驱动器。</param>
        <param name="Mode">必须的。 指定文件模式的枚举：<see langword="Append" />、<see langword="Binary" />、<see langword="Input" />、<see langword="Output" /> 或 <see langword="Random" />。 有关更多信息，请参见<see cref="T:Microsoft.VisualBasic.OpenMode" />。</param>
        <param name="Access">可选。 一个枚举，它指定对打开的文件所允许进行的操作：<see langword="Read" />、<see langword="Write" /> 或 <see langword="ReadWrite" />。 默认为 <see langword="ReadWrite" />。 有关更多信息，请参见<see cref="T:Microsoft.VisualBasic.OpenAccess" />。</param>
        <param name="Share">可选。 一个枚举，它指定不允许其他进程对打开的文件所进行的操作：<see langword="Shared" />、<see langword="Lock Read" />、<see langword="Lock Write" /> 和 <see langword="Lock Read Write" />。 默认为 <see langword="Lock Read Write" />。 有关更多信息，请参见<see cref="T:Microsoft.VisualBasic.OpenShare" />。</param>
        <param name="RecordLength">可选。 小于或等于 32,767（字节）的数字。 对于为进行随机访问而打开的文件，此值是记录的长度。 对于顺序文件，此值是缓冲的字符数。</param>
        <summary>打开一个文件以进行输入或输出。 相比 <see langword="FileOpen" />，<see langword="My" /> 功能可使文件 I/O 操作的效率更高、性能更好。 有关详情，请参阅<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileOpen`提供函数是为了向后兼容，可能会影响性能。 对于非旧版应用程序，`My.Computer.FileSystem`对象提供更好的性能。 有关详细信息，请参阅[使用 Visual Basic 访问文件](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)。  
  
 可以对其执行任何 I/O 操作之前，必须打开一个文件。 `FileOpen` 对文件的 I/O 分配缓冲区，并确定要使用缓冲区的访问模式。  
  
> [!IMPORTANT]
>  写入到文件时，应用程序可能需要创建一个文件，如果尝试写入的文件不存在。 若要执行此操作，必须在其中创建文件的目录的权限。 但是，如果指定的文件`FileName`确实存在，应用程序需求`Write`仅对文件本身的权限。 可能的为了提高安全性，任何位置创建文件在部署和授予过程`Write`权限到该文件唯一，而不是整个目录。 为了提高安全性，请将数据写入到的根目录或 Program Files 目录而不是用户目录中。  
  
 若要打开的通道可在使用`FreeFile()`函数。  
  
> [!IMPORTANT]
>  `FileOpen`函数需要`Read`从访问`FileIOPermissionAccess`枚举，它可能会影响它在部分信任情况下执行。 有关详细信息，请参阅 <xref:System.Security.Permissions.FileIOPermissionAccess>。  
  
   
  
## Examples  
 此示例演示了的各种用法`FileOpen`函数，以使输入和输出到文件。  
  
 以下代码打开文件`TestFile`在`Input`模式。  
  
 [!code-vb[VbVbalrCatRef#5](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#5)]  
  
 此示例打开中的文件`Binary`进行只写操作的模式。  
  
 [!code-vb[VbVbalrCatRef#6](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#6)]  
  
 下面的示例打开中的文件`Random`模式。 该文件包含的记录是结构`Person`。  
  
 [!code-vb[VbVbalrCatRef#7](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#7)]  
  
 此代码示例将打开的文件中`Output`模式; 任何进程可以读取或写入文件。  
  
 [!code-vb[VbVbalrCatRef#8](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#8)]  
  
 此代码示例将打开的文件中`Binary`模式进行读取; 其他进程无法读取文件。  
  
 [!code-vb[VbVbalrCatRef#9](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">记录长度是负数（并且不等于 -1）。</exception>
        <exception cref="T:System.IO.IOException">
          <paramref name="FileName" /> 已经打开，或 <paramref name="FileName" /> 无效。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileClose(System.Int32[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FreeFile" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files.md">从文件读取 (Visual Basic)</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">写入文件 (Visual Basic)</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="FilePut">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>将变量中得数据写入磁盘文件中。 相比 <see langword="FilePut" />，<see langword="My" /> 功能可使文件 I/O 操作的效率更高、性能更好。 有关更多信息，请参见 <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, bool Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, bool Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Boolean,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Boolean, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * bool * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Boolean" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必须的。 任何有效文件数。</param>
        <param name="Value">必须的。 有效变量名，它包含写入磁盘的数据。</param>
        <param name="RecordNumber">可选。 开始写入处的记录号（<see langword="Random" /> 模式文件）或字节号（<see langword="Binary" /> 模式文件）。</param>
        <summary>将变量中得数据写入磁盘文件中。 相比 <see langword="FilePut" />，<see langword="My" /> 功能可使文件 I/O 操作的效率更高、性能更好。 有关详情，请参阅<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` 仅在中有效`Random`和`Binary`模式。  
  
 通常使用 `FileGet` 从文件中读取使用 `FilePut` 编写的数据。  
  
 第一个记录或文件中的字节位置 1，第二个记录或字节在位置 2，依此类推。 如果省略`RecordNumber`下, 一步的记录或后的最后一个字节`FileGet`或`FilePut`函数或指向的最后一个`Seek`编写函数。  
  
 `StringIsFixedLength`参数控制函数是否将字符串解释为变量或固定长度。 `FilePut` 当参数是不会写入长度说明符`True`。 如果您使用`StringIsFixedLength`  =  `True`与`FilePut`，您只需使用相同`FileGet`，您必须确保该字符串将初始化为所需的长度。  
  
## <a name="random-mode"></a>随机模式  
 有关在中打开文件`Random`模式下，下列规则适用：  
  
-   如果写入的数据的长度小于中指定的长度`RecordLength`子句`FileOpen`函数，`FilePut`将后续的记录写入记录长度边界上。 用文件缓冲区的现有内容填充一条记录的末尾和下一条记录的开始之间的空间。 由于不能与任何颇有自信地确定填充的数据量，它通常是最好使记录的长度与写入的数据的长度匹配。 如果写入的数据的长度大于中指定的长度`RecordLength`子句`FileOpen`函数，将引发异常。  
  
-   如果写入的变量是一个字符串，`FilePut`将写入一个双字节说明符，包含字符串长度，然后写入该变量的数据。 因此，指定的记录长度`RecordLength`子句中的`FileOpen`函数必须至少为两个字节大于字符串的实际长度。  
  
-   如果写入的变量是包含一个数值类型的对象`FilePut`标识的两个字节写入`VarType`的对象，然后将该变量。 例如，编写一个对象时包含一个整数`FilePut`写入 6 个字节： 标识作为对象的两个字节`VarType(3)`(`Integer`) 和包含的数据的四个字节。 指定的记录长度`RecordLength`中的参数`FileOpen`函数必须至少为两个字节大于实际存储在变量所需的字节数。  
  
-   如果写入的变量是一个对象，包含一个字符串，`FilePut`写入一个双字节说明符标识`VarType(8)`的对象，然后。 指定的记录长度`RecordLength`中的参数`FileOpen`函数必须至少大于字符串的实际长度为四个字节。 如果你想要放入而无需描述符字符串，则应传递`True`到`StringIsFixedLength`参数，并应为正确的长度，读取到的字符串。  
  
-   如果写入的变量是一个数组，则必须选择要写入大小和数组的维数的说明符。 Visual Basic 6.0 和早期版本编写的文件说明符有关的动态数组而不是固定大小的数组。 Visual Basic 2005 默认为不写入描述符。 若要编写描述符，设置`ArrayIsDynamic`参数`True`。 在编写数组时，必须匹配的方法将读取该数组;如果它将读取与描述符，您必须写入描述符。 描述符指定秩的数组、 大小和为每个级别的下限。 其长度等于 2 + 8 时间维度的数目: (2 + 8 * NumberOfDimensions)。 指定的记录长度`RecordLength`子句中的`FileOpen`函数必须是大于或等于写入数组数据和数组描述符需要的所有字节之和。 例如，以下数组声明需要 218 个字节时将数组写入到磁盘。  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   如果写入的变量是任何其他类型的变量 （不可变长度字符串或对象）`FilePut`只写入变量数据。 指定的记录长度`RecordLength`子句中的`FileOpen`函数必须是大于或等于写入的数据的长度。  
  
-   `FilePut` 将元素的结构写入像分别，写入的每个元素之间没有空白的情况除外。 `VBFixedString`特性可以应用于字符串字段中的结构，以指示字符串写入时的大小到磁盘。  
  
    > [!NOTE]
    >  字符串字段大小超过指定值的字节`VBFixedString`属性将被截断时写入到磁盘，  
  
## <a name="binary-mode"></a>二进制模式  
 打开的文件中`Binary`模式下，大部分`Random`模式规则适用，有一些例外情况。 在中打开文件的以下规则`Binary`模式不同于为规则`Random`模式：  
  
-   `RecordLength`子句中的`FileOpen`函数不起任何作用。 `FilePut` 所有将变量写入磁盘连续，也就是说，不带记录之间的填充。  
  
-   对于在结构中，数组以外的任何数组`FilePut`只写入数据。 未不写入任何说明符。  
  
-   `FilePut` 不是元素的结构，无需两个字节的长度说明符写入可变长度字符串。 写入的字节数等于字符串中的字符数。 例如，以下语句将 11 个字节写入文件号 1:  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   通过使用对文件进行写入`FilePut`函数需要`Write`从访问<xref:System.Security.Permissions.FileIOPermissionAccess>枚举。  
  
   
  
## Examples  
 此示例使用`FilePut`函数将数据写入到一个文件。 结构的五个记录`Person`写入到文件。  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 且不等于 -1。</exception>
        <exception cref="T:System.IO.IOException">文件模式无效。</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">写入文件 (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, byte Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, unsigned int8 Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Byte,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Byte, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * byte * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Byte" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必须的。 任何有效文件数。</param>
        <param name="Value">必须的。 有效变量名，它包含写入磁盘的数据。</param>
        <param name="RecordNumber">可选。 开始写入处的记录号（<see langword="Random" /> 模式文件）或字节号（<see langword="Binary" /> 模式文件）。</param>
        <summary>将变量中得数据写入磁盘文件中。 相比 <see langword="FilePut" />，<see langword="My" /> 功能可使文件 I/O 操作的效率更高、性能更好。 有关详情，请参阅<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` 仅在中有效`Random`和`Binary`模式。  
  
 通常使用 `FileGet` 从文件中读取使用 `FilePut` 编写的数据。  
  
 第一个记录或文件中的字节位置 1，第二个记录或字节在位置 2，依此类推。 如果省略`RecordNumber`下, 一步的记录或后的最后一个字节`FileGet`或`FilePut`函数或指向的最后一个`Seek`编写函数。  
  
 `StringIsFixedLength`参数控制函数是否将字符串解释为变量或固定长度。 `FilePut` 当参数是不会写入长度说明符`True`。 如果您使用`StringIsFixedLength`  =  `True`与`FilePut`，您只需使用相同`FileGet`，您必须确保该字符串将初始化为所需的长度。  
  
## <a name="random-mode"></a>随机模式  
 有关在中打开文件`Random`模式下，下列规则适用：  
  
-   如果写入的数据的长度小于中指定的长度`RecordLength`子句`FileOpen`函数，`FilePut`将后续的记录写入记录长度边界上。 用文件缓冲区的现有内容填充一条记录的末尾和下一条记录的开始之间的空间。 由于不能与任何颇有自信地确定填充的数据量，它通常是最好使记录的长度与写入的数据的长度匹配。 如果写入的数据的长度大于中指定的长度`RecordLength`子句`FileOpen`函数，将引发异常。  
  
-   如果写入的变量是一个字符串，`FilePut`将写入一个双字节说明符，包含字符串长度，然后写入该变量的数据。 因此，指定的记录长度`RecordLength`子句中的`FileOpen`函数必须至少为两个字节大于字符串的实际长度。  
  
-   如果写入的变量是包含一个数值类型的对象`FilePut`标识的两个字节写入`VarType`的对象，然后将该变量。 例如，编写一个对象时包含一个整数`FilePut`写入 6 个字节： 标识作为对象的两个字节`VarType(3)`(`Integer`) 和包含的数据的四个字节。 指定的记录长度`RecordLength`中的参数`FileOpen`函数必须至少为两个字节大于实际存储在变量所需的字节数。  
  
-   如果写入的变量是一个对象，包含一个字符串，`FilePut`写入一个双字节说明符标识`VarType(8)`的对象，然后。 指定的记录长度`RecordLength`中的参数`FileOpen`函数必须至少大于字符串的实际长度为四个字节。 如果你想要放入而无需描述符字符串，则应传递`True`到`StringIsFixedLength`参数，并应为正确的长度，读取到的字符串。  
  
-   如果写入的变量是一个数组，则必须选择要写入大小和数组的维数的说明符。 Visual Basic 6.0 和早期版本编写的文件说明符有关的动态数组而不是固定大小的数组。 Visual Basic 2005 默认为不写入描述符。 若要编写描述符，设置`ArrayIsDynamic`参数`True`。 在编写数组时，必须匹配的方法将读取该数组;如果它将读取与描述符，您必须写入描述符。 描述符指定秩的数组、 大小和为每个级别的下限。 其长度等于 2 + 8 时间维度的数目: (2 + 8 * NumberOfDimensions)。 指定的记录长度`RecordLength`子句中的`FileOpen`函数必须是大于或等于写入数组数据和数组描述符需要的所有字节之和。 例如，以下数组声明需要 218 个字节时将数组写入到磁盘。  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   如果写入的变量是任何其他类型的变量 （不可变长度字符串或对象）`FilePut`只写入变量数据。 指定的记录长度`RecordLength`子句中的`FileOpen`函数必须是大于或等于写入的数据的长度。  
  
-   `FilePut` 将元素的结构写入像分别，写入的每个元素之间没有空白的情况除外。 `VBFixedString`特性可以应用于字符串字段中的结构，以指示字符串写入时的大小到磁盘。  
  
    > [!NOTE]
    >  字符串字段大小超过指定值的字节`VBFixedString`属性将被截断时写入到磁盘，  
  
## <a name="binary-mode"></a>二进制模式  
 打开的文件中`Binary`模式下，大部分`Random`模式规则适用，有一些例外情况。 在中打开文件的以下规则`Binary`模式不同于为规则`Random`模式：  
  
-   `RecordLength`子句中的`FileOpen`函数不起任何作用。 `FilePut` 所有将变量写入磁盘连续，也就是说，不带记录之间的填充。  
  
-   对于在结构中，数组以外的任何数组`FilePut`只写入数据。 未不写入任何说明符。  
  
-   `FilePut` 不是元素的结构，无需两个字节的长度说明符写入可变长度字符串。 写入的字节数等于字符串中的字符数。 例如，以下语句将 11 个字节写入文件号 1:  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   通过使用对文件进行写入`FilePut`函数需要`Write`从访问<xref:System.Security.Permissions.FileIOPermissionAccess>枚举。  
  
   
  
## Examples  
 此示例使用`FilePut`函数将数据写入到一个文件。 结构的五个记录`Person`写入到文件。  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 且不等于 -1。</exception>
        <exception cref="T:System.IO.IOException">文件模式无效。</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">写入文件 (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, char Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, char Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Char,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Char, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * char * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Char" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必须的。 任何有效文件数。</param>
        <param name="Value">必须的。 有效变量名，它包含写入磁盘的数据。</param>
        <param name="RecordNumber">可选。 开始写入处的记录号（<see langword="Random" /> 模式文件）或字节号（<see langword="Binary" /> 模式文件）。</param>
        <summary>将变量中得数据写入磁盘文件中。 相比 <see langword="FilePut" />，<see langword="My" /> 功能可使文件 I/O 操作的效率更高、性能更好。 有关详情，请参阅<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` 仅在中有效`Random`和`Binary`模式。  
  
 通常使用 `FileGet` 从文件中读取使用 `FilePut` 编写的数据。  
  
 第一个记录或文件中的字节位置 1，第二个记录或字节在位置 2，依此类推。 如果省略`RecordNumber`下, 一步的记录或后的最后一个字节`FileGet`或`FilePut`函数或指向的最后一个`Seek`编写函数。  
  
 `StringIsFixedLength`参数控制函数是否将字符串解释为变量或固定长度。 `FilePut` 当参数是不会写入长度说明符`True`。 如果您使用`StringIsFixedLength`  =  `True`与`FilePut`，您只需使用相同`FileGet`，您必须确保该字符串将初始化为所需的长度。  
  
## <a name="random-mode"></a>随机模式  
 有关在中打开文件`Random`模式下，下列规则适用：  
  
-   如果写入的数据的长度小于中指定的长度`RecordLength`子句`FileOpen`函数，`FilePut`将后续的记录写入记录长度边界上。 用文件缓冲区的现有内容填充一条记录的末尾和下一条记录的开始之间的空间。 由于不能与任何颇有自信地确定填充的数据量，它通常是最好使记录的长度与写入的数据的长度匹配。 如果写入的数据的长度大于中指定的长度`RecordLength`子句`FileOpen`函数，将引发异常。  
  
-   如果写入的变量是一个字符串，`FilePut`将写入一个双字节说明符，包含字符串长度，然后写入该变量的数据。 因此，指定的记录长度`RecordLength`子句中的`FileOpen`函数必须至少为两个字节大于字符串的实际长度。  
  
-   如果写入的变量是包含一个数值类型的对象`FilePut`标识的两个字节写入`VarType`的对象，然后将该变量。 例如，编写一个对象时包含一个整数`FilePut`写入 6 个字节： 标识作为对象的两个字节`VarType(3)`(`Integer`) 和包含的数据的四个字节。 指定的记录长度`RecordLength`中的参数`FileOpen`函数必须至少为两个字节大于实际存储在变量所需的字节数。  
  
-   如果写入的变量是一个对象，包含一个字符串，`FilePut`写入一个双字节说明符标识`VarType(8)`的对象，然后。 指定的记录长度`RecordLength`中的参数`FileOpen`函数必须至少大于字符串的实际长度为四个字节。 如果你想要放入而无需描述符字符串，则应传递`True`到`StringIsFixedLength`参数，并应为正确的长度，读取到的字符串。  
  
-   如果写入的变量是一个数组，则必须选择要写入大小和数组的维数的说明符。 Visual Basic 6.0 和早期版本编写的文件说明符有关的动态数组而不是固定大小的数组。 Visual Basic 2005 默认为不写入描述符。 若要编写描述符，设置`ArrayIsDynamic`参数`True`。 在编写数组时，必须匹配的方法将读取该数组;如果它将读取与描述符，您必须写入描述符。 描述符指定秩的数组、 大小和为每个级别的下限。 其长度等于 2 + 8 时间维度的数目: (2 + 8 * NumberOfDimensions)。 指定的记录长度`RecordLength`子句中的`FileOpen`函数必须是大于或等于写入数组数据和数组描述符需要的所有字节之和。 例如，以下数组声明需要 218 个字节时将数组写入到磁盘。  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   如果写入的变量是任何其他类型的变量 （不可变长度字符串或对象）`FilePut`只写入变量数据。 指定的记录长度`RecordLength`子句中的`FileOpen`函数必须是大于或等于写入的数据的长度。  
  
-   `FilePut` 将元素的结构写入像分别，写入的每个元素之间没有空白的情况除外。 `VBFixedString`特性可以应用于字符串字段中的结构，以指示字符串写入时的大小到磁盘。  
  
    > [!NOTE]
    >  字符串字段大小超过指定值的字节`VBFixedString`属性将被截断时写入到磁盘，  
  
## <a name="binary-mode"></a>二进制模式  
 打开的文件中`Binary`模式下，大部分`Random`模式规则适用，有一些例外情况。 在中打开文件的以下规则`Binary`模式不同于为规则`Random`模式：  
  
-   `RecordLength`子句中的`FileOpen`函数不起任何作用。 `FilePut` 所有将变量写入磁盘连续，也就是说，不带记录之间的填充。  
  
-   对于在结构中，数组以外的任何数组`FilePut`只写入数据。 未不写入任何说明符。  
  
-   `FilePut` 不是元素的结构，无需两个字节的长度说明符写入可变长度字符串。 写入的字节数等于字符串中的字符数。 例如，以下语句将 11 个字节写入文件号 1:  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   通过使用对文件进行写入`FilePut`函数需要`Write`从访问<xref:System.Security.Permissions.FileIOPermissionAccess>枚举。  
  
   
  
## Examples  
 此示例使用`FilePut`函数将数据写入到一个文件。 结构的五个记录`Person`写入到文件。  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 且不等于 -1。</exception>
        <exception cref="T:System.IO.IOException">文件模式无效。</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">写入文件 (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, DateTime Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, valuetype System.DateTime Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.DateTime,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As DateTime, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * DateTime * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.DateTime" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必须的。 任何有效文件数。</param>
        <param name="Value">必须的。 有效变量名，它包含写入磁盘的数据。</param>
        <param name="RecordNumber">可选。 开始写入处的记录号（<see langword="Random" /> 模式文件）或字节号（<see langword="Binary" /> 模式文件）。</param>
        <summary>将变量中得数据写入磁盘文件中。 相比 <see langword="FilePut" />，<see langword="My" /> 功能可使文件 I/O 操作的效率更高、性能更好。 有关详情，请参阅<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` 仅在中有效`Random`和`Binary`模式。  
  
 通常使用 `FileGet` 从文件中读取使用 `FilePut` 编写的数据。  
  
 第一个记录或文件中的字节位置 1，第二个记录或字节在位置 2，依此类推。 如果省略`RecordNumber`下, 一步的记录或后的最后一个字节`FileGet`或`FilePut`函数或指向的最后一个`Seek`编写函数。  
  
 `StringIsFixedLength`参数控制函数是否将字符串解释为变量或固定长度。 `FilePut` 当参数是不会写入长度说明符`True`。 如果您使用`StringIsFixedLength`  =  `True`与`FilePut`，您只需使用相同`FileGet`，您必须确保该字符串将初始化为所需的长度。  
  
## <a name="random-mode"></a>随机模式  
 有关在中打开文件`Random`模式下，下列规则适用：  
  
-   如果写入的数据的长度小于中指定的长度`RecordLength`子句`FileOpen`函数，`FilePut`将后续的记录写入记录长度边界上。 用文件缓冲区的现有内容填充一条记录的末尾和下一条记录的开始之间的空间。 由于不能与任何颇有自信地确定填充的数据量，它通常是最好使记录的长度与写入的数据的长度匹配。 如果写入的数据的长度大于中指定的长度`RecordLength`子句`FileOpen`函数，将引发异常。  
  
-   如果写入的变量是一个字符串，`FilePut`将写入一个双字节说明符，包含字符串长度，然后写入该变量的数据。 因此，指定的记录长度`RecordLength`子句中的`FileOpen`函数必须至少为两个字节大于字符串的实际长度。  
  
-   如果写入的变量是包含一个数值类型的对象`FilePut`标识的两个字节写入`VarType`的对象，然后将该变量。 例如，编写一个对象时包含一个整数`FilePut`写入 6 个字节： 标识作为对象的两个字节`VarType(3)`(`Integer`) 和包含的数据的四个字节。 指定的记录长度`RecordLength`中的参数`FileOpen`函数必须至少为两个字节大于实际存储在变量所需的字节数。  
  
-   如果写入的变量是一个对象，包含一个字符串，`FilePut`写入一个双字节说明符标识`VarType(8)`的对象，然后。 指定的记录长度`RecordLength`中的参数`FileOpen`函数必须至少大于字符串的实际长度为四个字节。 如果你想要放入而无需描述符字符串，则应传递`True`到`StringIsFixedLength`参数，并应为正确的长度，读取到的字符串。  
  
-   如果写入的变量是一个数组，则必须选择要写入大小和数组的维数的说明符。 Visual Basic 6.0 和早期版本编写的文件说明符有关的动态数组而不是固定大小的数组。 Visual Basic 2005 默认为不写入描述符。 若要编写描述符，设置`ArrayIsDynamic`参数`True`。 在编写数组时，必须匹配的方法将读取该数组;如果它将读取与描述符，您必须写入描述符。 描述符指定秩的数组、 大小和为每个级别的下限。 其长度等于 2 + 8 时间维度的数目: (2 + 8 * NumberOfDimensions)。 指定的记录长度`RecordLength`子句中的`FileOpen`函数必须是大于或等于写入数组数据和数组描述符需要的所有字节之和。 例如，以下数组声明需要 218 个字节时将数组写入到磁盘。  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   如果写入的变量是任何其他类型的变量 （不可变长度字符串或对象）`FilePut`只写入变量数据。 指定的记录长度`RecordLength`子句中的`FileOpen`函数必须是大于或等于写入的数据的长度。  
  
-   `FilePut` 将元素的结构写入像分别，写入的每个元素之间没有空白的情况除外。 `VBFixedString`特性可以应用于字符串字段中的结构，以指示字符串写入时的大小到磁盘。  
  
    > [!NOTE]
    >  字符串字段大小超过指定值的字节`VBFixedString`属性将被截断时写入到磁盘，  
  
## <a name="binary-mode"></a>二进制模式  
 打开的文件中`Binary`模式下，大部分`Random`模式规则适用，有一些例外情况。 在中打开文件的以下规则`Binary`模式不同于为规则`Random`模式：  
  
-   `RecordLength`子句中的`FileOpen`函数不起任何作用。 `FilePut` 所有将变量写入磁盘连续，也就是说，不带记录之间的填充。  
  
-   对于在结构中，数组以外的任何数组`FilePut`只写入数据。 未不写入任何说明符。  
  
-   `FilePut` 不是元素的结构，无需两个字节的长度说明符写入可变长度字符串。 写入的字节数等于字符串中的字符数。 例如，以下语句将 11 个字节写入文件号 1:  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   通过使用对文件进行写入`FilePut`函数需要`Write`从访问<xref:System.Security.Permissions.FileIOPermissionAccess>枚举。  
  
   
  
## Examples  
 此示例使用`FilePut`函数将数据写入到一个文件。 结构的五个记录`Person`写入到文件。  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 且不等于 -1。</exception>
        <exception cref="T:System.IO.IOException">文件模式无效。</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">写入文件 (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, decimal Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, valuetype System.Decimal Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Decimal,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Decimal, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * decimal * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Decimal" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必须的。 任何有效文件数。</param>
        <param name="Value">必须的。 有效变量名，它包含写入磁盘的数据。</param>
        <param name="RecordNumber">可选。 开始写入处的记录号（<see langword="Random" /> 模式文件）或字节号（<see langword="Binary" /> 模式文件）。</param>
        <summary>将变量中得数据写入磁盘文件中。 相比 <see langword="FilePut" />，<see langword="My" /> 功能可使文件 I/O 操作的效率更高、性能更好。 有关详情，请参阅<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` 仅在中有效`Random`和`Binary`模式。  
  
 通常使用 `FileGet` 从文件中读取使用 `FilePut` 编写的数据。  
  
 第一个记录或文件中的字节位置 1，第二个记录或字节在位置 2，依此类推。 如果省略`RecordNumber`下, 一步的记录或后的最后一个字节`FileGet`或`FilePut`函数或指向的最后一个`Seek`编写函数。  
  
 `StringIsFixedLength`参数控制函数是否将字符串解释为变量或固定长度。 `FilePut` 当参数是不会写入长度说明符`True`。 如果您使用`StringIsFixedLength`  =  `True`与`FilePut`，您只需使用相同`FileGet`，您必须确保该字符串将初始化为所需的长度。  
  
## <a name="random-mode"></a>随机模式  
 有关在中打开文件`Random`模式下，下列规则适用：  
  
-   如果写入的数据的长度小于中指定的长度`RecordLength`子句`FileOpen`函数，`FilePut`将后续的记录写入记录长度边界上。 用文件缓冲区的现有内容填充一条记录的末尾和下一条记录的开始之间的空间。 由于不能与任何颇有自信地确定填充的数据量，它通常是最好使记录的长度与写入的数据的长度匹配。 如果写入的数据的长度大于中指定的长度`RecordLength`子句`FileOpen`函数，将引发异常。  
  
-   如果写入的变量是一个字符串，`FilePut`将写入一个双字节说明符，包含字符串长度，然后写入该变量的数据。 因此，指定的记录长度`RecordLength`子句中的`FileOpen`函数必须至少为两个字节大于字符串的实际长度。  
  
-   如果写入的变量是包含一个数值类型的对象`FilePut`标识的两个字节写入`VarType`的对象，然后将该变量。 例如，编写一个对象时包含一个整数`FilePut`写入 6 个字节： 标识作为对象的两个字节`VarType(3)`(`Integer`) 和包含的数据的四个字节。 指定的记录长度`RecordLength`中的参数`FileOpen`函数必须至少为两个字节大于实际存储在变量所需的字节数。  
  
-   如果写入的变量是一个对象，包含一个字符串，`FilePut`写入一个双字节说明符标识`VarType(8)`的对象，然后。 指定的记录长度`RecordLength`中的参数`FileOpen`函数必须至少大于字符串的实际长度为四个字节。 如果你想要放入而无需描述符字符串，则应传递`True`到`StringIsFixedLength`参数，并应为正确的长度，读取到的字符串。  
  
-   如果写入的变量是一个数组，则必须选择要写入大小和数组的维数的说明符。 Visual Basic 6.0 和早期版本编写的文件说明符有关的动态数组而不是固定大小的数组。 Visual Basic 2005 默认为不写入描述符。 若要编写描述符，设置`ArrayIsDynamic`参数`True`。 在编写数组时，必须匹配的方法将读取该数组;如果它将读取与描述符，您必须写入描述符。 描述符指定秩的数组、 大小和为每个级别的下限。 其长度等于 2 + 8 时间维度的数目: (2 + 8 * NumberOfDimensions)。 指定的记录长度`RecordLength`子句中的`FileOpen`函数必须是大于或等于写入数组数据和数组描述符需要的所有字节之和。 例如，以下数组声明需要 218 个字节时将数组写入到磁盘。  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   如果写入的变量是任何其他类型的变量 （不可变长度字符串或对象）`FilePut`只写入变量数据。 指定的记录长度`RecordLength`子句中的`FileOpen`函数必须是大于或等于写入的数据的长度。  
  
-   `FilePut` 将元素的结构写入像分别，写入的每个元素之间没有空白的情况除外。 `VBFixedString`特性可以应用于字符串字段中的结构，以指示字符串写入时的大小到磁盘。  
  
    > [!NOTE]
    >  字符串字段大小超过指定值的字节`VBFixedString`属性将被截断时写入到磁盘，  
  
## <a name="binary-mode"></a>二进制模式  
 打开的文件中`Binary`模式下，大部分`Random`模式规则适用，有一些例外情况。 在中打开文件的以下规则`Binary`模式不同于为规则`Random`模式：  
  
-   `RecordLength`子句中的`FileOpen`函数不起任何作用。 `FilePut` 所有将变量写入磁盘连续，也就是说，不带记录之间的填充。  
  
-   对于在结构中，数组以外的任何数组`FilePut`只写入数据。 未不写入任何说明符。  
  
-   `FilePut` 不是元素的结构，无需两个字节的长度说明符写入可变长度字符串。 写入的字节数等于字符串中的字符数。 例如，以下语句将 11 个字节写入文件号 1:  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   通过使用对文件进行写入`FilePut`函数需要`Write`从访问<xref:System.Security.Permissions.FileIOPermissionAccess>枚举。  
  
   
  
## Examples  
 此示例使用`FilePut`函数将数据写入到一个文件。 结构的五个记录`Person`写入到文件。  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 且不等于 -1。</exception>
        <exception cref="T:System.IO.IOException">文件模式无效。</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">写入文件 (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, double Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, float64 Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Double,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Double, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * double * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Double" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必须的。 任何有效文件数。</param>
        <param name="Value">必须的。 有效变量名，它包含写入磁盘的数据。</param>
        <param name="RecordNumber">可选。 开始写入处的记录号（<see langword="Random" /> 模式文件）或字节号（<see langword="Binary" /> 模式文件）。</param>
        <summary>将变量中得数据写入磁盘文件中。 相比 <see langword="FilePut" />，<see langword="My" /> 功能可使文件 I/O 操作的效率更高、性能更好。 有关详情，请参阅<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` 仅在中有效`Random`和`Binary`模式。  
  
 通常使用 `FileGet` 从文件中读取使用 `FilePut` 编写的数据。  
  
 第一个记录或文件中的字节位置 1，第二个记录或字节在位置 2，依此类推。 如果省略`RecordNumber`下, 一步的记录或后的最后一个字节`FileGet`或`FilePut`函数或指向的最后一个`Seek`编写函数。  
  
 `StringIsFixedLength`参数控制函数是否将字符串解释为变量或固定长度。 `FilePut` 当参数是不会写入长度说明符`True`。 如果您使用`StringIsFixedLength`  =  `True`与`FilePut`，您只需使用相同`FileGet`，您必须确保该字符串将初始化为所需的长度。  
  
## <a name="random-mode"></a>随机模式  
 有关在中打开文件`Random`模式下，下列规则适用：  
  
-   如果写入的数据的长度小于中指定的长度`RecordLength`子句`FileOpen`函数，`FilePut`将后续的记录写入记录长度边界上。 用文件缓冲区的现有内容填充一条记录的末尾和下一条记录的开始之间的空间。 由于不能与任何颇有自信地确定填充的数据量，它通常是最好使记录的长度与写入的数据的长度匹配。 如果写入的数据的长度大于中指定的长度`RecordLength`子句`FileOpen`函数，将引发异常。  
  
-   如果写入的变量是一个字符串，`FilePut`将写入一个双字节说明符，包含字符串长度，然后写入该变量的数据。 因此，指定的记录长度`RecordLength`子句中的`FileOpen`函数必须至少为两个字节大于字符串的实际长度。  
  
-   如果写入的变量是包含一个数值类型的对象`FilePut`标识的两个字节写入`VarType`的对象，然后将该变量。 例如，编写一个对象时包含一个整数`FilePut`写入 6 个字节： 标识作为对象的两个字节`VarType(3)`(`Integer`) 和包含的数据的四个字节。 指定的记录长度`RecordLength`中的参数`FileOpen`函数必须至少为两个字节大于实际存储在变量所需的字节数。  
  
-   如果写入的变量是一个对象，包含一个字符串，`FilePut`写入一个双字节说明符标识`VarType(8)`的对象，然后。 指定的记录长度`RecordLength`中的参数`FileOpen`函数必须至少大于字符串的实际长度为四个字节。 如果你想要放入而无需描述符字符串，则应传递`True`到`StringIsFixedLength`参数，并应为正确的长度，读取到的字符串。  
  
-   如果写入的变量是一个数组，则必须选择要写入大小和数组的维数的说明符。 Visual Basic 6.0 和早期版本编写的文件说明符有关的动态数组而不是固定大小的数组。 Visual Basic 2005 默认为不写入描述符。 若要编写描述符，设置`ArrayIsDynamic`参数`True`。 在编写数组时，必须匹配的方法将读取该数组;如果它将读取与描述符，您必须写入描述符。 描述符指定秩的数组、 大小和为每个级别的下限。 其长度等于 2 + 8 时间维度的数目: (2 + 8 * NumberOfDimensions)。 指定的记录长度`RecordLength`子句中的`FileOpen`函数必须是大于或等于写入数组数据和数组描述符需要的所有字节之和。 例如，以下数组声明需要 218 个字节时将数组写入到磁盘。  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   如果写入的变量是任何其他类型的变量 （不可变长度字符串或对象）`FilePut`只写入变量数据。 指定的记录长度`RecordLength`子句中的`FileOpen`函数必须是大于或等于写入的数据的长度。  
  
-   `FilePut` 将元素的结构写入像分别，写入的每个元素之间没有空白的情况除外。 `VBFixedString`特性可以应用于字符串字段中的结构，以指示字符串写入时的大小到磁盘。  
  
    > [!NOTE]
    >  字符串字段大小超过指定值的字节`VBFixedString`属性将被截断时写入到磁盘，  
  
## <a name="binary-mode"></a>二进制模式  
 打开的文件中`Binary`模式下，大部分`Random`模式规则适用，有一些例外情况。 在中打开文件的以下规则`Binary`模式不同于为规则`Random`模式：  
  
-   `RecordLength`子句中的`FileOpen`函数不起任何作用。 `FilePut` 所有将变量写入磁盘连续，也就是说，不带记录之间的填充。  
  
-   对于在结构中，数组以外的任何数组`FilePut`只写入数据。 未不写入任何说明符。  
  
-   `FilePut` 不是元素的结构，无需两个字节的长度说明符写入可变长度字符串。 写入的字节数等于字符串中的字符数。 例如，以下语句将 11 个字节写入文件号 1:  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   通过使用对文件进行写入`FilePut`函数需要`Write`从访问<xref:System.Security.Permissions.FileIOPermissionAccess>枚举。  
  
   
  
## Examples  
 此示例使用`FilePut`函数将数据写入到一个文件。 结构的五个记录`Person`写入到文件。  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 且不等于 -1。</exception>
        <exception cref="T:System.IO.IOException">文件模式无效。</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">写入文件 (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, short Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, int16 Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int16,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Short, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * int16 * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int16" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必须的。 任何有效文件数。</param>
        <param name="Value">必须的。 有效变量名，它包含写入磁盘的数据。</param>
        <param name="RecordNumber">可选。 开始写入处的记录号（<see langword="Random" /> 模式文件）或字节号（<see langword="Binary" /> 模式文件）。</param>
        <summary>将变量中得数据写入磁盘文件中。 相比 <see langword="FilePut" />，<see langword="My" /> 功能可使文件 I/O 操作的效率更高、性能更好。 有关详情，请参阅<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` 仅在中有效`Random`和`Binary`模式。  
  
 通常使用 `FileGet` 从文件中读取使用 `FilePut` 编写的数据。  
  
 第一个记录或文件中的字节位置 1，第二个记录或字节在位置 2，依此类推。 如果省略`RecordNumber`下, 一步的记录或后的最后一个字节`FileGet`或`FilePut`函数或指向的最后一个`Seek`编写函数。  
  
 `StringIsFixedLength`参数控制函数是否将字符串解释为变量或固定长度。 `FilePut` 当参数是不会写入长度说明符`True`。 如果您使用`StringIsFixedLength`  =  `True`与`FilePut`，您只需使用相同`FileGet`，您必须确保该字符串将初始化为所需的长度。  
  
## <a name="random-mode"></a>随机模式  
 有关在中打开文件`Random`模式下，下列规则适用：  
  
-   如果写入的数据的长度小于中指定的长度`RecordLength`子句`FileOpen`函数，`FilePut`将后续的记录写入记录长度边界上。 用文件缓冲区的现有内容填充一条记录的末尾和下一条记录的开始之间的空间。 由于不能与任何颇有自信地确定填充的数据量，它通常是最好使记录的长度与写入的数据的长度匹配。 如果写入的数据的长度大于中指定的长度`RecordLength`子句`FileOpen`函数，将引发异常。  
  
-   如果写入的变量是一个字符串，`FilePut`将写入一个双字节说明符，包含字符串长度，然后写入该变量的数据。 因此，指定的记录长度`RecordLength`子句中的`FileOpen`函数必须至少为两个字节大于字符串的实际长度。  
  
-   如果写入的变量是包含一个数值类型的对象`FilePut`标识的两个字节写入`VarType`的对象，然后将该变量。 例如，编写一个对象时包含一个整数`FilePut`写入 6 个字节： 标识作为对象的两个字节`VarType(3)`(`Integer`) 和包含的数据的四个字节。 指定的记录长度`RecordLength`中的参数`FileOpen`函数必须至少为两个字节大于实际存储在变量所需的字节数。  
  
-   如果写入的变量是一个对象，包含一个字符串，`FilePut`写入一个双字节说明符标识`VarType(8)`的对象，然后。 指定的记录长度`RecordLength`中的参数`FileOpen`函数必须至少大于字符串的实际长度为四个字节。 如果你想要放入而无需描述符字符串，则应传递`True`到`StringIsFixedLength`参数，并应为正确的长度，读取到的字符串。  
  
-   如果写入的变量是一个数组，则必须选择要写入大小和数组的维数的说明符。 Visual Basic 6.0 和早期版本编写的文件说明符有关的动态数组而不是固定大小的数组。 Visual Basic 2005 默认为不写入描述符。 若要编写描述符，设置`ArrayIsDynamic`参数`True`。 在编写数组时，必须匹配的方法将读取该数组;如果它将读取与描述符，您必须写入描述符。 描述符指定秩的数组、 大小和为每个级别的下限。 其长度等于 2 + 8 时间维度的数目: (2 + 8 * NumberOfDimensions)。 指定的记录长度`RecordLength`子句中的`FileOpen`函数必须是大于或等于写入数组数据和数组描述符需要的所有字节之和。 例如，以下数组声明需要 218 个字节时将数组写入到磁盘。  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   如果写入的变量是任何其他类型的变量 （不可变长度字符串或对象）`FilePut`只写入变量数据。 指定的记录长度`RecordLength`子句中的`FileOpen`函数必须是大于或等于写入的数据的长度。  
  
-   `FilePut` 将元素的结构写入像分别，写入的每个元素之间没有空白的情况除外。 `VBFixedString`特性可以应用于字符串字段中的结构，以指示字符串写入时的大小到磁盘。  
  
    > [!NOTE]
    >  字符串字段大小超过指定值的字节`VBFixedString`属性将被截断时写入到磁盘，  
  
## <a name="binary-mode"></a>二进制模式  
 打开的文件中`Binary`模式下，大部分`Random`模式规则适用，有一些例外情况。 在中打开文件的以下规则`Binary`模式不同于为规则`Random`模式：  
  
-   `RecordLength`子句中的`FileOpen`函数不起任何作用。 `FilePut` 所有将变量写入磁盘连续，也就是说，不带记录之间的填充。  
  
-   对于在结构中，数组以外的任何数组`FilePut`只写入数据。 未不写入任何说明符。  
  
-   `FilePut` 不是元素的结构，无需两个字节的长度说明符写入可变长度字符串。 写入的字节数等于字符串中的字符数。 例如，以下语句将 11 个字节写入文件号 1:  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   通过使用对文件进行写入`FilePut`函数需要`Write`从访问<xref:System.Security.Permissions.FileIOPermissionAccess>枚举。  
  
   
  
## Examples  
 此示例使用`FilePut`函数将数据写入到一个文件。 结构的五个记录`Person`写入到文件。  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 且不等于 -1。</exception>
        <exception cref="T:System.IO.IOException">文件模式无效。</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">写入文件 (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, int Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, int32 Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int32,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Integer, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * int * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int32" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必须的。 任何有效文件数。</param>
        <param name="Value">必须的。 有效变量名，它包含写入磁盘的数据。</param>
        <param name="RecordNumber">可选。 开始写入处的记录号（<see langword="Random" /> 模式文件）或字节号（<see langword="Binary" /> 模式文件）。</param>
        <summary>将变量中得数据写入磁盘文件中。 相比 <see langword="FilePut" />，<see langword="My" /> 功能可使文件 I/O 操作的效率更高、性能更好。 有关详情，请参阅<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` 仅在中有效`Random`和`Binary`模式。  
  
 通常使用 `FileGet` 从文件中读取使用 `FilePut` 编写的数据。  
  
 第一个记录或文件中的字节位置 1，第二个记录或字节在位置 2，依此类推。 如果省略`RecordNumber`下, 一步的记录或后的最后一个字节`FileGet`或`FilePut`函数或指向的最后一个`Seek`编写函数。  
  
 `StringIsFixedLength`参数控制函数是否将字符串解释为变量或固定长度。 `FilePut` 当参数是不会写入长度说明符`True`。 如果您使用`StringIsFixedLength`  =  `True`与`FilePut`，您只需使用相同`FileGet`，您必须确保该字符串将初始化为所需的长度。  
  
## <a name="random-mode"></a>随机模式  
 有关在中打开文件`Random`模式下，下列规则适用：  
  
-   如果写入的数据的长度小于中指定的长度`RecordLength`子句`FileOpen`函数，`FilePut`将后续的记录写入记录长度边界上。 用文件缓冲区的现有内容填充一条记录的末尾和下一条记录的开始之间的空间。 由于不能与任何颇有自信地确定填充的数据量，它通常是最好使记录的长度与写入的数据的长度匹配。 如果写入的数据的长度大于中指定的长度`RecordLength`子句`FileOpen`函数，将引发异常。  
  
-   如果写入的变量是一个字符串，`FilePut`将写入一个双字节说明符，包含字符串长度，然后写入该变量的数据。 因此，指定的记录长度`RecordLength`子句中的`FileOpen`函数必须至少为两个字节大于字符串的实际长度。  
  
-   如果写入的变量是包含一个数值类型的对象`FilePut`标识的两个字节写入`VarType`的对象，然后将该变量。 例如，编写一个对象时包含一个整数`FilePut`写入 6 个字节： 标识作为对象的两个字节`VarType(3)`(`Integer`) 和包含的数据的四个字节。 指定的记录长度`RecordLength`中的参数`FileOpen`函数必须至少为两个字节大于实际存储在变量所需的字节数。  
  
-   如果写入的变量是一个对象，包含一个字符串，`FilePut`写入一个双字节说明符标识`VarType(8)`的对象，然后。 指定的记录长度`RecordLength`中的参数`FileOpen`函数必须至少大于字符串的实际长度为四个字节。 如果你想要放入而无需描述符字符串，则应传递`True`到`StringIsFixedLength`参数，并应为正确的长度，读取到的字符串。  
  
-   如果写入的变量是一个数组，则必须选择要写入大小和数组的维数的说明符。 Visual Basic 6.0 和早期版本编写的文件说明符有关的动态数组而不是固定大小的数组。 Visual Basic 2005 默认为不写入描述符。 若要编写描述符，设置`ArrayIsDynamic`参数`True`。 在编写数组时，必须匹配的方法将读取该数组;如果它将读取与描述符，您必须写入描述符。 描述符指定秩的数组、 大小和为每个级别的下限。 其长度等于 2 + 8 时间维度的数目: (2 + 8 * NumberOfDimensions)。 指定的记录长度`RecordLength`子句中的`FileOpen`函数必须是大于或等于写入数组数据和数组描述符需要的所有字节之和。 例如，以下数组声明需要 218 个字节时将数组写入到磁盘。  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   如果写入的变量是任何其他类型的变量 （不可变长度字符串或对象）`FilePut`只写入变量数据。 指定的记录长度`RecordLength`子句中的`FileOpen`函数必须是大于或等于写入的数据的长度。  
  
-   `FilePut` 将元素的结构写入像分别，写入的每个元素之间没有空白的情况除外。 `VBFixedString`特性可以应用于字符串字段中的结构，以指示字符串写入时的大小到磁盘。  
  
    > [!NOTE]
    >  字符串字段大小超过指定值的字节`VBFixedString`属性将被截断时写入到磁盘，  
  
## <a name="binary-mode"></a>二进制模式  
 打开的文件中`Binary`模式下，大部分`Random`模式规则适用，有一些例外情况。 在中打开文件的以下规则`Binary`模式不同于为规则`Random`模式：  
  
-   `RecordLength`子句中的`FileOpen`函数不起任何作用。 `FilePut` 所有将变量写入磁盘连续，也就是说，不带记录之间的填充。  
  
-   对于在结构中，数组以外的任何数组`FilePut`只写入数据。 未不写入任何说明符。  
  
-   `FilePut` 不是元素的结构，无需两个字节的长度说明符写入可变长度字符串。 写入的字节数等于字符串中的字符数。 例如，以下语句将 11 个字节写入文件号 1:  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   通过使用对文件进行写入`FilePut`函数需要`Write`从访问<xref:System.Security.Permissions.FileIOPermissionAccess>枚举。  
  
   
  
## Examples  
 此示例使用`FilePut`函数将数据写入到一个文件。 结构的五个记录`Person`写入到文件。  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 且不等于 -1。</exception>
        <exception cref="T:System.IO.IOException">文件模式无效。</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">写入文件 (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, long Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, int64 Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Long, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * int64 * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int64" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必须的。 任何有效文件数。</param>
        <param name="Value">必须的。 有效变量名，它包含写入磁盘的数据。</param>
        <param name="RecordNumber">可选。 开始写入处的记录号（<see langword="Random" /> 模式文件）或字节号（<see langword="Binary" /> 模式文件）。</param>
        <summary>将变量中得数据写入磁盘文件中。 相比 <see langword="FilePut" />，<see langword="My" /> 功能可使文件 I/O 操作的效率更高、性能更好。 有关详情，请参阅<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` 仅在中有效`Random`和`Binary`模式。  
  
 通常使用 `FileGet` 从文件中读取使用 `FilePut` 编写的数据。  
  
 第一个记录或文件中的字节位置 1，第二个记录或字节在位置 2，依此类推。 如果省略`RecordNumber`下, 一步的记录或后的最后一个字节`FileGet`或`FilePut`函数或指向的最后一个`Seek`编写函数。  
  
 `StringIsFixedLength`参数控制函数是否将字符串解释为变量或固定长度。 `FilePut` 当参数是不会写入长度说明符`True`。 如果您使用`StringIsFixedLength`  =  `True`与`FilePut`，您只需使用相同`FileGet`，您必须确保该字符串将初始化为所需的长度。  
  
## <a name="random-mode"></a>随机模式  
 有关在中打开文件`Random`模式下，下列规则适用：  
  
-   如果写入的数据的长度小于中指定的长度`RecordLength`子句`FileOpen`函数，`FilePut`将后续的记录写入记录长度边界上。 用文件缓冲区的现有内容填充一条记录的末尾和下一条记录的开始之间的空间。 由于不能与任何颇有自信地确定填充的数据量，它通常是最好使记录的长度与写入的数据的长度匹配。 如果写入的数据的长度大于中指定的长度`RecordLength`子句`FileOpen`函数，将引发异常。  
  
-   如果写入的变量是一个字符串，`FilePut`将写入一个双字节说明符，包含字符串长度，然后写入该变量的数据。 因此，指定的记录长度`RecordLength`子句中的`FileOpen`函数必须至少为两个字节大于字符串的实际长度。  
  
-   如果写入的变量是包含一个数值类型的对象`FilePut`标识的两个字节写入`VarType`的对象，然后将该变量。 例如，编写一个对象时包含一个整数`FilePut`写入 6 个字节： 标识作为对象的两个字节`VarType(3)`(`Integer`) 和包含的数据的四个字节。 指定的记录长度`RecordLength`中的参数`FileOpen`函数必须至少为两个字节大于实际存储在变量所需的字节数。  
  
-   如果写入的变量是一个对象，包含一个字符串，`FilePut`写入一个双字节说明符标识`VarType(8)`的对象，然后。 指定的记录长度`RecordLength`中的参数`FileOpen`函数必须至少大于字符串的实际长度为四个字节。 如果你想要放入而无需描述符字符串，则应传递`True`到`StringIsFixedLength`参数，并应为正确的长度，读取到的字符串。  
  
-   如果写入的变量是一个数组，则必须选择要写入大小和数组的维数的说明符。 Visual Basic 6.0 和早期版本编写的文件说明符有关的动态数组而不是固定大小的数组。 Visual Basic 2005 默认为不写入描述符。 若要编写描述符，设置`ArrayIsDynamic`参数`True`。 在编写数组时，必须匹配的方法将读取该数组;如果它将读取与描述符，您必须写入描述符。 描述符指定秩的数组、 大小和为每个级别的下限。 其长度等于 2 + 8 时间维度的数目: (2 + 8 * NumberOfDimensions)。 指定的记录长度`RecordLength`子句中的`FileOpen`函数必须是大于或等于写入数组数据和数组描述符需要的所有字节之和。 例如，以下数组声明需要 218 个字节时将数组写入到磁盘。  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   如果写入的变量是任何其他类型的变量 （不可变长度字符串或对象）`FilePut`只写入变量数据。 指定的记录长度`RecordLength`子句中的`FileOpen`函数必须是大于或等于写入的数据的长度。  
  
-   `FilePut` 将元素的结构写入像分别，写入的每个元素之间没有空白的情况除外。 `VBFixedString`特性可以应用于字符串字段中的结构，以指示字符串写入时的大小到磁盘。  
  
    > [!NOTE]
    >  字符串字段大小超过指定值的字节`VBFixedString`属性将被截断时写入到磁盘，  
  
## <a name="binary-mode"></a>二进制模式  
 打开的文件中`Binary`模式下，大部分`Random`模式规则适用，有一些例外情况。 在中打开文件的以下规则`Binary`模式不同于为规则`Random`模式：  
  
-   `RecordLength`子句中的`FileOpen`函数不起任何作用。 `FilePut` 所有将变量写入磁盘连续，也就是说，不带记录之间的填充。  
  
-   对于在结构中，数组以外的任何数组`FilePut`只写入数据。 未不写入任何说明符。  
  
-   `FilePut` 不是元素的结构，无需两个字节的长度说明符写入可变长度字符串。 写入的字节数等于字符串中的字符数。 例如，以下语句将 11 个字节写入文件号 1:  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   通过使用对文件进行写入`FilePut`函数需要`Write`从访问<xref:System.Security.Permissions.FileIOPermissionAccess>枚举。  
  
   
  
## Examples  
 此示例使用`FilePut`函数将数据写入到一个文件。 结构的五个记录`Person`写入到文件。  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 且不等于 -1。</exception>
        <exception cref="T:System.IO.IOException">文件模式无效。</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">写入文件 (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, float Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, float32 Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Single,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Single, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * single * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Single" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必须的。 任何有效文件数。</param>
        <param name="Value">必须的。 有效变量名，它包含写入磁盘的数据。</param>
        <param name="RecordNumber">可选。 开始写入处的记录号（<see langword="Random" /> 模式文件）或字节号（<see langword="Binary" /> 模式文件）。</param>
        <summary>将变量中得数据写入磁盘文件中。 相比 <see langword="FilePut" />，<see langword="My" /> 功能可使文件 I/O 操作的效率更高、性能更好。 有关详情，请参阅<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` 仅在中有效`Random`和`Binary`模式。  
  
 通常使用 `FileGet` 从文件中读取使用 `FilePut` 编写的数据。  
  
 第一个记录或文件中的字节位置 1，第二个记录或字节在位置 2，依此类推。 如果省略`RecordNumber`下, 一步的记录或后的最后一个字节`FileGet`或`FilePut`函数或指向的最后一个`Seek`编写函数。  
  
 `StringIsFixedLength`参数控制函数是否将字符串解释为变量或固定长度。 `FilePut` 当参数是不会写入长度说明符`True`。 如果您使用`StringIsFixedLength`  =  `True`与`FilePut`，您只需使用相同`FileGet`，您必须确保该字符串将初始化为所需的长度。  
  
## <a name="random-mode"></a>随机模式  
 有关在中打开文件`Random`模式下，下列规则适用：  
  
-   如果写入的数据的长度小于中指定的长度`RecordLength`子句`FileOpen`函数，`FilePut`将后续的记录写入记录长度边界上。 用文件缓冲区的现有内容填充一条记录的末尾和下一条记录的开始之间的空间。 由于不能与任何颇有自信地确定填充的数据量，它通常是最好使记录的长度与写入的数据的长度匹配。 如果写入的数据的长度大于中指定的长度`RecordLength`子句`FileOpen`函数，将引发异常。  
  
-   如果写入的变量是一个字符串，`FilePut`将写入一个双字节说明符，包含字符串长度，然后写入该变量的数据。 因此，指定的记录长度`RecordLength`子句中的`FileOpen`函数必须至少为两个字节大于字符串的实际长度。  
  
-   如果写入的变量是包含一个数值类型的对象`FilePut`标识的两个字节写入`VarType`的对象，然后将该变量。 例如，编写一个对象时包含一个整数`FilePut`写入 6 个字节： 标识作为对象的两个字节`VarType(3)`(`Integer`) 和包含的数据的四个字节。 指定的记录长度`RecordLength`中的参数`FileOpen`函数必须至少为两个字节大于实际存储在变量所需的字节数。  
  
-   如果写入的变量是一个对象，包含一个字符串，`FilePut`写入一个双字节说明符标识`VarType(8)`的对象，然后。 指定的记录长度`RecordLength`中的参数`FileOpen`函数必须至少大于字符串的实际长度为四个字节。 如果你想要放入而无需描述符字符串，则应传递`True`到`StringIsFixedLength`参数，并应为正确的长度，读取到的字符串。  
  
-   如果写入的变量是一个数组，则必须选择要写入大小和数组的维数的说明符。 Visual Basic 6.0 和早期版本编写的文件说明符有关的动态数组而不是固定大小的数组。 Visual Basic 2005 默认为不写入描述符。 若要编写描述符，设置`ArrayIsDynamic`参数`True`。 在编写数组时，必须匹配的方法将读取该数组;如果它将读取与描述符，您必须写入描述符。 描述符指定秩的数组、 大小和为每个级别的下限。 其长度等于 2 + 8 时间维度的数目: (2 + 8 * NumberOfDimensions)。 指定的记录长度`RecordLength`子句中的`FileOpen`函数必须是大于或等于写入数组数据和数组描述符需要的所有字节之和。 例如，以下数组声明需要 218 个字节时将数组写入到磁盘。  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   如果写入的变量是任何其他类型的变量 （不可变长度字符串或对象）`FilePut`只写入变量数据。 指定的记录长度`RecordLength`子句中的`FileOpen`函数必须是大于或等于写入的数据的长度。  
  
-   `FilePut` 将元素的结构写入像分别，写入的每个元素之间没有空白的情况除外。 `VBFixedString`特性可以应用于字符串字段中的结构，以指示字符串写入时的大小到磁盘。  
  
    > [!NOTE]
    >  字符串字段大小超过指定值的字节`VBFixedString`属性将被截断时写入到磁盘，  
  
## <a name="binary-mode"></a>二进制模式  
 打开的文件中`Binary`模式下，大部分`Random`模式规则适用，有一些例外情况。 在中打开文件的以下规则`Binary`模式不同于为规则`Random`模式：  
  
-   `RecordLength`子句中的`FileOpen`函数不起任何作用。 `FilePut` 所有将变量写入磁盘连续，也就是说，不带记录之间的填充。  
  
-   对于在结构中，数组以外的任何数组`FilePut`只写入数据。 未不写入任何说明符。  
  
-   `FilePut` 不是元素的结构，无需两个字节的长度说明符写入可变长度字符串。 写入的字节数等于字符串中的字符数。 例如，以下语句将 11 个字节写入文件号 1:  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   通过使用对文件进行写入`FilePut`函数需要`Write`从访问<xref:System.Security.Permissions.FileIOPermissionAccess>枚举。  
  
   
  
## Examples  
 此示例使用`FilePut`函数将数据写入到一个文件。 结构的五个记录`Person`写入到文件。  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 且不等于 -1。</exception>
        <exception cref="T:System.IO.IOException">文件模式无效。</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">写入文件 (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, ValueType Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, class System.ValueType Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.ValueType,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As ValueType, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * ValueType * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.ValueType" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必须的。 任何有效文件数。</param>
        <param name="Value">必须的。 有效变量名，它包含写入磁盘的数据。</param>
        <param name="RecordNumber">可选。 开始写入处的记录号（<see langword="Random" /> 模式文件）或字节号（<see langword="Binary" /> 模式文件）。</param>
        <summary>将变量中得数据写入磁盘文件中。 相比 <see langword="FilePut" />，<see langword="My" /> 功能可使文件 I/O 操作的效率更高、性能更好。 有关详情，请参阅<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` 仅在中有效`Random`和`Binary`模式。  
  
 通常使用 `FileGet` 从文件中读取使用 `FilePut` 编写的数据。  
  
 第一个记录或文件中的字节位置 1，第二个记录或字节在位置 2，依此类推。 如果省略`RecordNumber`下, 一步的记录或后的最后一个字节`FileGet`或`FilePut`函数或指向的最后一个`Seek`编写函数。  
  
 `StringIsFixedLength`参数控制函数是否将字符串解释为变量或固定长度。 `FilePut` 当参数是不会写入长度说明符`True`。 如果您使用`StringIsFixedLength`  =  `True`与`FilePut`，您只需使用相同`FileGet`，您必须确保该字符串将初始化为所需的长度。  
  
## <a name="random-mode"></a>随机模式  
 有关在中打开文件`Random`模式下，下列规则适用：  
  
-   如果写入的数据的长度小于中指定的长度`RecordLength`子句`FileOpen`函数，`FilePut`将后续的记录写入记录长度边界上。 用文件缓冲区的现有内容填充一条记录的末尾和下一条记录的开始之间的空间。 由于不能与任何颇有自信地确定填充的数据量，它通常是最好使记录的长度与写入的数据的长度匹配。 如果写入的数据的长度大于中指定的长度`RecordLength`子句`FileOpen`函数，将引发异常。  
  
-   如果写入的变量是一个字符串，`FilePut`将写入一个双字节说明符，包含字符串长度，然后写入该变量的数据。 因此，指定的记录长度`RecordLength`子句中的`FileOpen`函数必须至少为两个字节大于字符串的实际长度。  
  
-   如果写入的变量是包含一个数值类型的对象`FilePut`标识的两个字节写入`VarType`的对象，然后将该变量。 例如，编写一个对象时包含一个整数`FilePut`写入 6 个字节： 标识作为对象的两个字节`VarType(3)`(`Integer`) 和包含的数据的四个字节。 指定的记录长度`RecordLength`中的参数`FileOpen`函数必须至少为两个字节大于实际存储在变量所需的字节数。  
  
-   如果写入的变量是一个对象，包含一个字符串，`FilePut`写入一个双字节说明符标识`VarType(8)`的对象，然后。 指定的记录长度`RecordLength`中的参数`FileOpen`函数必须至少大于字符串的实际长度为四个字节。 如果你想要放入而无需描述符字符串，则应传递`True`到`StringIsFixedLength`参数，并应为正确的长度，读取到的字符串。  
  
-   如果写入的变量是一个数组，则必须选择要写入大小和数组的维数的说明符。 Visual Basic 6.0 和早期版本编写的文件说明符有关的动态数组而不是固定大小的数组。 Visual Basic 2005 默认为不写入描述符。 若要编写描述符，设置`ArrayIsDynamic`参数`True`。 在编写数组时，必须匹配的方法将读取该数组;如果它将读取与描述符，您必须写入描述符。 描述符指定秩的数组、 大小和为每个级别的下限。 其长度等于 2 + 8 时间维度的数目: (2 + 8 * NumberOfDimensions)。 指定的记录长度`RecordLength`子句中的`FileOpen`函数必须是大于或等于写入数组数据和数组描述符需要的所有字节之和。 例如，以下数组声明需要 218 个字节时将数组写入到磁盘。  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   如果写入的变量是任何其他类型的变量 （不可变长度字符串或对象）`FilePut`只写入变量数据。 指定的记录长度`RecordLength`子句中的`FileOpen`函数必须是大于或等于写入的数据的长度。  
  
-   `FilePut` 将元素的结构写入像分别，写入的每个元素之间没有空白的情况除外。 `VBFixedString`特性可以应用于字符串字段中的结构，以指示字符串写入时的大小到磁盘。  
  
    > [!NOTE]
    >  字符串字段大小超过指定值的字节`VBFixedString`属性将被截断时写入到磁盘，  
  
## <a name="binary-mode"></a>二进制模式  
 打开的文件中`Binary`模式下，大部分`Random`模式规则适用，有一些例外情况。 在中打开文件的以下规则`Binary`模式不同于为规则`Random`模式：  
  
-   `RecordLength`子句中的`FileOpen`函数不起任何作用。 `FilePut` 所有将变量写入磁盘连续，也就是说，不带记录之间的填充。  
  
-   对于在结构中，数组以外的任何数组`FilePut`只写入数据。 未不写入任何说明符。  
  
-   `FilePut` 不是元素的结构，无需两个字节的长度说明符写入可变长度字符串。 写入的字节数等于字符串中的字符数。 例如，以下语句将 11 个字节写入文件号 1:  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   通过使用对文件进行写入`FilePut`函数需要`Write`从访问<xref:System.Security.Permissions.FileIOPermissionAccess>枚举。  
  
   
  
## Examples  
 此示例使用`FilePut`函数将数据写入到一个文件。 结构的五个记录`Person`写入到文件。  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 且不等于 -1。</exception>
        <exception cref="T:System.IO.IOException">文件模式无效。</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">写入文件 (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (object FileNumber, object Value, object RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(object FileNumber, object Value, object RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Object,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Object, Value As Object, Optional RecordNumber As Object = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : obj * obj * obj -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("This member has been deprecated. Please use FilePutObject to write Object types, or coerce FileNumber and RecordNumber to Integer for writing non-Object types. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Obsolete("Use FilePutObject to write Object types, or coerce FileNumber and RecordNumber to Integer for writing non-Object types")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Object" />
        <Parameter Name="Value" Type="System.Object" />
        <Parameter Name="RecordNumber" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必须的。 任何有效文件数。</param>
        <param name="Value">必须的。 有效变量名，它包含写入磁盘的数据。</param>
        <param name="RecordNumber">可选。 开始写入处的记录号（<see langword="Random" /> 模式文件）或字节号（<see langword="Binary" /> 模式文件）。</param>
        <summary>将变量中得数据写入磁盘文件中。 相比 <see langword="FilePut" />，<see langword="My" /> 功能可使文件 I/O 操作的效率更高、性能更好。 有关详情，请参阅<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` 仅在中有效`Random`和`Binary`模式。  
  
 通常使用 `FileGet` 从文件中读取使用 `FilePut` 编写的数据。  
  
 第一个记录或文件中的字节位置 1，第二个记录或字节在位置 2，依此类推。 如果省略`RecordNumber`下, 一步的记录或后的最后一个字节`FileGet`或`FilePut`函数或指向的最后一个`Seek`编写函数。  
  
 `StringIsFixedLength`参数控制函数是否将字符串解释为变量或固定长度。 `FilePut` 当参数是不会写入长度说明符`True`。 如果您使用`StringIsFixedLength`  =  `True`与`FilePut`，您只需使用相同`FileGet`，您必须确保该字符串将初始化为所需的长度。  
  
## <a name="random-mode"></a>随机模式  
 有关在中打开文件`Random`模式下，下列规则适用：  
  
-   如果写入的数据的长度小于中指定的长度`RecordLength`子句`FileOpen`函数，`FilePut`将后续的记录写入记录长度边界上。 用文件缓冲区的现有内容填充一条记录的末尾和下一条记录的开始之间的空间。 由于不能与任何颇有自信地确定填充的数据量，它通常是最好使记录的长度与写入的数据的长度匹配。 如果写入的数据的长度大于中指定的长度`RecordLength`子句`FileOpen`函数，将引发异常。  
  
-   如果写入的变量是一个字符串，`FilePut`将写入一个双字节说明符，包含字符串长度，然后写入该变量的数据。 因此，指定的记录长度`RecordLength`子句中的`FileOpen`函数必须至少为两个字节大于字符串的实际长度。  
  
-   如果写入的变量是包含一个数值类型的对象`FilePut`标识的两个字节写入`VarType`的对象，然后将该变量。 例如，编写一个对象时包含一个整数`FilePut`写入 6 个字节： 标识作为对象的两个字节`VarType(3)`(`Integer`) 和包含的数据的四个字节。 指定的记录长度`RecordLength`中的参数`FileOpen`函数必须至少为两个字节大于实际存储在变量所需的字节数。  
  
-   如果写入的变量是一个对象，包含一个字符串，`FilePut`写入一个双字节说明符标识`VarType(8)`的对象，然后。 指定的记录长度`RecordLength`中的参数`FileOpen`函数必须至少大于字符串的实际长度为四个字节。 如果你想要放入而无需描述符字符串，则应传递`True`到`StringIsFixedLength`参数，并应为正确的长度，读取到的字符串。  
  
-   如果写入的变量是一个数组，则必须选择要写入大小和数组的维数的说明符。 Visual Basic 6.0 和早期版本编写的文件说明符有关的动态数组而不是固定大小的数组。 Visual Basic 2005 默认为不写入描述符。 若要编写描述符，设置`ArrayIsDynamic`参数`True`。 在编写数组时，必须匹配的方法将读取该数组;如果它将读取与描述符，您必须写入描述符。 描述符指定秩的数组、 大小和为每个级别的下限。 其长度等于 2 + 8 时间维度的数目: (2 + 8 * NumberOfDimensions)。 指定的记录长度`RecordLength`子句中的`FileOpen`函数必须是大于或等于写入数组数据和数组描述符需要的所有字节之和。 例如，以下数组声明需要 218 个字节时将数组写入到磁盘。  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   如果写入的变量是任何其他类型的变量 （不可变长度字符串或对象）`FilePut`只写入变量数据。 指定的记录长度`RecordLength`子句中的`FileOpen`函数必须是大于或等于写入的数据的长度。  
  
-   `FilePut` 将元素的结构写入像分别，写入的每个元素之间没有空白的情况除外。 `VBFixedString`特性可以应用于字符串字段中的结构，以指示字符串写入时的大小到磁盘。  
  
    > [!NOTE]
    >  字符串字段大小超过指定值的字节`VBFixedString`属性将被截断时写入到磁盘，  
  
## <a name="binary-mode"></a>二进制模式  
 打开的文件中`Binary`模式下，大部分`Random`模式规则适用，有一些例外情况。 在中打开文件的以下规则`Binary`模式不同于为规则`Random`模式：  
  
-   `RecordLength`子句中的`FileOpen`函数不起任何作用。 `FilePut` 所有将变量写入磁盘连续，也就是说，不带记录之间的填充。  
  
-   对于在结构中，数组以外的任何数组`FilePut`只写入数据。 未不写入任何说明符。  
  
-   `FilePut` 不是元素的结构，无需两个字节的长度说明符写入可变长度字符串。 写入的字节数等于字符串中的字符数。 例如，以下语句将 11 个字节写入文件号 1:  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   通过使用对文件进行写入`FilePut`函数需要`Write`从访问<xref:System.Security.Permissions.FileIOPermissionAccess>枚举。  
  
   
  
## Examples  
 此示例使用`FilePut`函数将数据写入到一个文件。 结构的五个记录`Person`写入到文件。  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 且不等于 -1。</exception>
        <exception cref="T:System.IO.IOException">文件模式无效。</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">写入文件 (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, string Value, long RecordNumber = -1, bool StringIsFixedLength = false);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, string Value, int64 RecordNumber, bool StringIsFixedLength) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.String,System.Int64,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As String, Optional RecordNumber As Long = -1, Optional StringIsFixedLength As Boolean = false)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * string * int64 * bool -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber, StringIsFixedLength)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.String" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
        <Parameter Name="StringIsFixedLength" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必须的。 任何有效文件数。</param>
        <param name="Value">必须的。 有效变量名，它包含写入磁盘的数据。</param>
        <param name="RecordNumber">可选。 开始写入处的记录号（<see langword="Random" /> 模式文件）或字节号（<see langword="Binary" /> 模式文件）。</param>
        <param name="StringIsFixedLength">可选。 仅在写入字符串时适用。 指定是否将字符串的双字节字符串长度说明符写入文件中。 默认值为 <see langword="False" />。</param>
        <summary>将变量中得数据写入磁盘文件中。 相比 <see langword="FilePut" />，<see langword="My" /> 功能可使文件 I/O 操作的效率更高、性能更好。 有关更多信息，请参见 <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` 仅在中有效`Random`和`Binary`模式。  
  
 通常使用 `FileGet` 从文件中读取使用 `FilePut` 编写的数据。  
  
 第一个记录或文件中的字节位置 1，第二个记录或字节在位置 2，依此类推。 如果省略`RecordNumber`下, 一步的记录或后的最后一个字节`FileGet`或`FilePut`函数或指向的最后一个`Seek`编写函数。  
  
 `StringIsFixedLength`参数控制函数是否将字符串解释为变量或固定长度。 `FilePut` 当参数是不会写入长度说明符`True`。 如果您使用`StringIsFixedLength`  =  `True`与`FilePut`，您只需使用相同`FileGet`，您必须确保该字符串将初始化为所需的长度。  
  
## <a name="random-mode"></a>随机模式  
 有关在中打开文件`Random`模式下，下列规则适用：  
  
-   如果写入的数据的长度小于中指定的长度`RecordLength`子句`FileOpen`函数，`FilePut`将后续的记录写入记录长度边界上。 用文件缓冲区的现有内容填充一条记录的末尾和下一条记录的开始之间的空间。 由于不能与任何颇有自信地确定填充的数据量，它通常是最好使记录的长度与写入的数据的长度匹配。 如果写入的数据的长度大于中指定的长度`RecordLength`子句`FileOpen`函数，将引发异常。  
  
-   如果写入的变量是一个字符串，`FilePut`将写入一个双字节说明符，包含字符串长度，然后写入该变量的数据。 因此，指定的记录长度`RecordLength`子句中的`FileOpen`函数必须至少为两个字节大于字符串的实际长度。  
  
-   如果写入的变量是包含一个数值类型的对象`FilePut`标识的两个字节写入`VarType`的对象，然后将该变量。 例如，编写一个对象时包含一个整数`FilePut`写入 6 个字节： 标识作为对象的两个字节`VarType(3)`(`Integer`) 和包含的数据的四个字节。 指定的记录长度`RecordLength`中的参数`FileOpen`函数必须至少为两个字节大于实际存储在变量所需的字节数。  
  
-   如果写入的变量是一个对象，包含一个字符串，`FilePut`写入一个双字节说明符标识`VarType(8)`的对象，然后。 指定的记录长度`RecordLength`中的参数`FileOpen`函数必须至少大于字符串的实际长度为四个字节。 如果你想要放入而无需描述符字符串，则应传递`True`到`StringIsFixedLength`参数，并应为正确的长度，读取到的字符串。  
  
-   如果写入的变量是一个数组，则必须选择要写入大小和数组的维数的说明符。 Visual Basic 6.0 和早期版本编写的文件说明符有关的动态数组而不是固定大小的数组。 Visual Basic 2005 默认为不写入描述符。 若要编写描述符，设置`ArrayIsDynamic`参数`True`。 在编写数组时，必须匹配的方法将读取该数组;如果它将读取与描述符，您必须写入描述符。 描述符指定秩的数组、 大小和为每个级别的下限。 其长度等于 2 + 8 时间维度的数目: (2 + 8 * NumberOfDimensions)。 指定的记录长度`RecordLength`子句中的`FileOpen`函数必须是大于或等于写入数组数据和数组描述符需要的所有字节之和。 例如，以下数组声明需要 218 个字节时将数组写入到磁盘。  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   如果写入的变量是任何其他类型的变量 （不可变长度字符串或对象）`FilePut`只写入变量数据。 指定的记录长度`RecordLength`子句中的`FileOpen`函数必须是大于或等于写入的数据的长度。  
  
-   `FilePut` 将元素的结构写入像分别，写入的每个元素之间没有空白的情况除外。 `VBFixedString`特性可以应用于字符串字段中的结构，以指示字符串写入时的大小到磁盘。  
  
    > [!NOTE]
    >  字符串字段大小超过指定值的字节`VBFixedString`属性将被截断时写入到磁盘，  
  
## <a name="binary-mode"></a>二进制模式  
 打开的文件中`Binary`模式下，大部分`Random`模式规则适用，有一些例外情况。 在中打开文件的以下规则`Binary`模式不同于为规则`Random`模式：  
  
-   `RecordLength`子句中的`FileOpen`函数不起任何作用。 `FilePut` 所有将变量写入磁盘连续，也就是说，不带记录之间的填充。  
  
-   对于在结构中，数组以外的任何数组`FilePut`只写入数据。 未不写入任何说明符。  
  
-   `FilePut` 不是元素的结构，无需两个字节的长度说明符写入可变长度字符串。 写入的字节数等于字符串中的字符数。 例如，以下语句将 11 个字节写入文件号 1:  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   通过使用对文件进行写入`FilePut`函数需要`Write`从访问<xref:System.Security.Permissions.FileIOPermissionAccess>枚举。  
  
   
  
## Examples  
 此示例使用`FilePut`函数将数据写入到一个文件。 结构的五个记录`Person`写入到文件。  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 且不等于 -1。</exception>
        <exception cref="T:System.IO.IOException">文件模式无效。</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">写入文件 (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, Array Value, long RecordNumber = -1, bool ArrayIsDynamic = false, bool StringIsFixedLength = false);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, class System.Array Value, int64 RecordNumber, bool ArrayIsDynamic, bool StringIsFixedLength) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Array,System.Int64,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Array, Optional RecordNumber As Long = -1, Optional ArrayIsDynamic As Boolean = false, Optional StringIsFixedLength As Boolean = false)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * Array * int64 * bool * bool -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber, ArrayIsDynamic, StringIsFixedLength)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Array" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
        <Parameter Name="ArrayIsDynamic" Type="System.Boolean" />
        <Parameter Name="StringIsFixedLength" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必须的。 任何有效文件数。</param>
        <param name="Value">必须的。 有效变量名，它包含写入磁盘的数据。</param>
        <param name="RecordNumber">可选。 开始写入处的记录号（<see langword="Random" /> 模式文件）或字节号（<see langword="Binary" /> 模式文件）。</param>
        <param name="ArrayIsDynamic">可选。 仅当写入数组时使用。 指定是否将数组视为动态数组，以及是否写入用于描述字符串长度的数组说明符。</param>
        <param name="StringIsFixedLength">可选。 仅在写入字符串时适用。 指定是否将字符串的双字节字符串长度说明符写入文件中。 默认值为 <see langword="False" />。</param>
        <summary>将变量中得数据写入磁盘文件中。 相比 <see langword="FilePut" />，<see langword="My" /> 功能可使文件 I/O 操作的效率更高、性能更好。 有关详情，请参阅<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` 仅在中有效`Random`和`Binary`模式。  
  
 通常使用 `FileGet` 从文件中读取使用 `FilePut` 编写的数据。  
  
 第一个记录或文件中的字节位置 1，第二个记录或字节在位置 2，依此类推。 如果省略`RecordNumber`下, 一步的记录或后的最后一个字节`FileGet`或`FilePut`函数或指向的最后一个`Seek`编写函数。  
  
 `StringIsFixedLength`参数控制函数是否将字符串解释为变量或固定长度。 `FilePut` 当参数是不会写入长度说明符`True`。 如果您使用`StringIsFixedLength`  =  `True`与`FilePut`，您只需使用相同`FileGet`，您必须确保该字符串将初始化为所需的长度。  
  
## <a name="random-mode"></a>随机模式  
 有关在中打开文件`Random`模式下，下列规则适用：  
  
-   如果写入的数据的长度小于中指定的长度`RecordLength`子句`FileOpen`函数，`FilePut`将后续的记录写入记录长度边界上。 用文件缓冲区的现有内容填充一条记录的末尾和下一条记录的开始之间的空间。 由于不能与任何颇有自信地确定填充的数据量，它通常是最好使记录的长度与写入的数据的长度匹配。 如果写入的数据的长度大于中指定的长度`RecordLength`子句`FileOpen`函数，将引发异常。  
  
-   如果写入的变量是一个字符串，`FilePut`将写入一个双字节说明符，包含字符串长度，然后写入该变量的数据。 因此，指定的记录长度`RecordLength`子句中的`FileOpen`函数必须至少为两个字节大于字符串的实际长度。  
  
-   如果写入的变量是包含一个数值类型的对象`FilePut`标识的两个字节写入`VarType`的对象，然后将该变量。 例如，编写一个对象时包含一个整数`FilePut`写入 6 个字节： 标识作为对象的两个字节`VarType(3)`(`Integer`) 和包含的数据的四个字节。 指定的记录长度`RecordLength`中的参数`FileOpen`函数必须至少为两个字节大于实际存储在变量所需的字节数。  
  
-   如果写入的变量是一个对象，包含一个字符串，`FilePut`写入一个双字节说明符标识`VarType(8)`的对象，然后。 指定的记录长度`RecordLength`中的参数`FileOpen`函数必须至少大于字符串的实际长度为四个字节。 如果你想要放入而无需描述符字符串，则应传递`True`到`StringIsFixedLength`参数，并应为正确的长度，读取到的字符串。  
  
-   如果写入的变量是一个数组，则必须选择要写入大小和数组的维数的说明符。 Visual Basic 6.0 和早期版本编写的文件说明符有关的动态数组而不是固定大小的数组。 Visual Basic 2005 默认为不写入描述符。 若要编写描述符，设置`ArrayIsDynamic`参数`True`。 在编写数组时，必须匹配的方法将读取该数组;如果它将读取与描述符，您必须写入描述符。 描述符指定秩的数组、 大小和为每个级别的下限。 其长度等于 2 + 8 时间维度的数目: (2 + 8 * NumberOfDimensions)。 指定的记录长度`RecordLength`子句中的`FileOpen`函数必须是大于或等于写入数组数据和数组描述符需要的所有字节之和。 例如，以下数组声明需要 218 个字节时将数组写入到磁盘。  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   如果写入的变量是任何其他类型的变量 （不可变长度字符串或对象）`FilePut`只写入变量数据。 指定的记录长度`RecordLength`子句中的`FileOpen`函数必须是大于或等于写入的数据的长度。  
  
-   `FilePut` 将元素的结构写入像分别，写入的每个元素之间没有空白的情况除外。 `VBFixedString`特性可以应用于字符串字段中的结构，以指示字符串写入时的大小到磁盘。  
  
    > [!NOTE]
    >  字符串字段大小超过指定值的字节`VBFixedString`属性将被截断时写入到磁盘，  
  
## <a name="binary-mode"></a>二进制模式  
 打开的文件中`Binary`模式下，大部分`Random`模式规则适用，有一些例外情况。 在中打开文件的以下规则`Binary`模式不同于为规则`Random`模式：  
  
-   `RecordLength`子句中的`FileOpen`函数不起任何作用。 `FilePut` 所有将变量写入磁盘连续，也就是说，不带记录之间的填充。  
  
-   对于在结构中，数组以外的任何数组`FilePut`只写入数据。 未不写入任何说明符。  
  
-   `FilePut` 不是元素的结构，无需两个字节的长度说明符写入可变长度字符串。 写入的字节数等于字符串中的字符数。 例如，以下语句将 11 个字节写入文件号 1:  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   通过使用对文件进行写入`FilePut`函数需要`Write`从访问<xref:System.Security.Permissions.FileIOPermissionAccess>枚举。  
  
   
  
## Examples  
 此示例使用`FilePut`函数将数据写入到一个文件。 结构的五个记录`Person`写入到文件。  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 且不等于 -1。</exception>
        <exception cref="T:System.IO.IOException">文件模式无效。</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">写入文件 (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="FilePutObject">
      <MemberSignature Language="C#" Value="public static void FilePutObject (int FileNumber, object Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePutObject(int32 FileNumber, object Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePutObject(System.Int32,System.Object,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePutObject (FileNumber As Integer, Value As Object, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePutObject : int * obj * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePutObject (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Object" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必须的。 任何有效文件数。</param>
        <param name="Value">必须的。 有效变量名，它包含写入磁盘的数据。</param>
        <param name="RecordNumber">可选。 开始写入处的记录号（<see langword="Random" /> 模式文件）或字节号（<see langword="Binary" /> 模式文件）。</param>
        <summary>将变量中得数据写入磁盘文件中。  相比 <see langword="FilePutObject" />，<see langword="My" /> 功能可使文件 I/O 操作的效率更高、性能更好。 有关详情，请参阅<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePutObject`而不是使用函数`FilePut`以在编译时避免出现多义性，如果类型`Object`传递而不是另一种类型，如`Integer`， `Long`， `Short`，依次类推。  
  
 `FilePutObject` 将写入和读取描述该对象的描述符。 如果你想要将写出`Variant`类型，`FilePutObject`是必需的。 如果你使用某个对象作为第二个参数，如有疑问，我们建议始终使用`FilePutObject`和`FileGetObject`。  
  
 `FilePutObject` 仅在中有效`Random`和`Binary`模式。  
  
 通常使用 `FileGetObject` 从文件中读取使用 `FilePutObject` 编写的数据。  
  
 第一个记录或文件中的字节位置 1，第二个记录或字节在位置 2，依此类推。 如果省略`RecordNumber`，`FilePutObject`上次写入下一个记录或字节`FileGetObject`或`FilePutObject`函数 (或记录号或字节指向由最后一个`Seek`函数)。  
  
 `StringIsFixedLength`参数控制函数是否将字符串解释为变量或固定长度。 `FilePutObject` 当参数是不会写入长度说明符`True`。 如果您使用`StringIsFixedLength`  =  `True`与`FilePutObject`，您只需使用相同`FileGetObject`，您必须还需确保该字符串将初始化为所需的长度。  
  
## <a name="random-mode"></a>随机模式  
 有关在中打开文件`Random`模式下，下列规则适用：  
  
-   如果写入的数据的长度小于中指定的长度`RecordLength`子句`FileOpen`函数，`FilePutObject`将后续的记录写入记录长度边界上。 用文件缓冲区的现有内容填充一条记录的末尾和下一条记录的开始之间的空间。 由于不能准确地确定填充的数据量，它通常是最好使记录的长度与写入的数据的长度匹配。 如果写入的数据的长度大于中指定的长度`RecordLength`子句`FileOpen`函数，将引发异常。  
  
-   如果写入的变量是包含一个数值类型的对象`FilePutObject`标识的两个字节写入`VarType`的对象，然后将该变量。 例如，编写一个对象时包含一个整数`FilePutObject`写入 6 个字节： 标识作为对象的两个字节`VarType(3)`(`Integer`) 和包含的数据的四个字节。 指定的记录长度`RecordLength`中的参数`FileOpen`函数必须至少为两个字节大于实际存储在变量所需的字节数。  
  
-   如果写入的变量是一个对象，包含一个字符串，`FilePutObject`写入一个双字节说明符标识`VarType(8)`的对象，然后。 指定的记录长度`RecordLength`中的参数`FileOpen`函数必须至少大于字符串的实际长度为四个字节。 如果你想要放入而无需描述符字符串，则应传递`True`到`StringIsFixedLength`参数，并应为正确的长度，读取到的字符串。  
  
-   如果写入的变量为数组，则 `RecordLength` 函数中 `FileOpen` 子句指定的记录长度必须大于或等于写入数组数据和数组描述符需要的所有字节之和。 描述符指定秩的数组、 大小和为每个级别的下限。 其长度等于 2 + 8 时间维度的数目: (2 + 8 * NumberOfDimensions)。  
  
## <a name="binary-mode"></a>二进制模式  
 打开的文件中`Binary`模式下，所有`Random`模式规则适用，除外：  
  
-   `RecordLength`子句中的`FileOpen`函数不起任何作用。 `FilePutObject` 所有将变量写入磁盘连续，也就是说，不带记录之间的填充。  
  
   
  
## Examples  
 此示例使用`FilePutObject`函数以将字符串写入文件。  
  
 [!code-vb[VbVbalrCatRef#54](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#54)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">写入文件 (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="FileWidth">
      <MemberSignature Language="C#" Value="public static void FileWidth (int FileNumber, int RecordWidth);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileWidth(int32 FileNumber, int32 RecordWidth) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileWidth(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileWidth (FileNumber As Integer, RecordWidth As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void FileWidth(int FileNumber, int RecordWidth);" />
      <MemberSignature Language="F#" Value="static member FileWidth : int * int -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileWidth (FileNumber, RecordWidth)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="RecordWidth" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必须的。 任何有效文件数。</param>
        <param name="RecordWidth">必须的。 0 到 255（包括 0 和 255）范围内的数值表达式，它表示在开始新一行前每一行中所显示的字符数。 如果 <paramref name="RecordWidth" /> 等于 0，则行的长度没有限制。 <paramref name="RecordWidth" /> 的默认值为 0。</param>
        <summary>为用 <see langword="FileOpen" /> 函数打开的文件分配输出行宽。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 此示例使用`FileWidth`函数设置文件的输出线条宽度。  
  
 [!code-vb[VbVbalrCatRef#10](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">文件模式无效。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">使用 Visual Basic 访问文件</related>
      </Docs>
    </Member>
    <Member MemberName="FreeFile">
      <MemberSignature Language="C#" Value="public static int FreeFile ();" />
      <MemberSignature Language="ILAsm" Value=".method public static int32 FreeFile() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FreeFile" />
      <MemberSignature Language="VB.NET" Value="Public Function FreeFile () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int FreeFile();" />
      <MemberSignature Language="F#" Value="static member FreeFile : unit -&gt; int" Usage="Microsoft.VisualBasic.FileSystem.FreeFile " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回一个 <see langword="Integer" /> 值，该值表示 <see langword="FileOpen" /> 函数可用的下一个文件号。</summary>
        <returns>返回一个 <see langword="Integer" /> 值，该值表示 <see langword="FileOpen" /> 函数可用的下一个文件号。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用`FreeFile`提供尚未使用的文件号。  
  
   
  
## Examples  
 此示例使用`FreeFile`函数以返回下一个可用的文件数。 五个文件打开，以便在循环中，输出和一些示例数据写入到每个。  
  
 [!code-vb[VbVbalrCatRef#55](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#55)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">正在使用的文件数超过 255。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">写入文件 (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="GetAttr">
      <MemberSignature Language="C#" Value="public static Microsoft.VisualBasic.FileAttribute GetAttr (string PathName);" />
      <MemberSignature Language="ILAsm" Value=".method public static valuetype Microsoft.VisualBasic.FileAttribute GetAttr(string PathName) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.GetAttr(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAttr (PathName As String) As FileAttribute" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Microsoft::VisualBasic::FileAttribute GetAttr(System::String ^ PathName);" />
      <MemberSignature Language="F#" Value="static member GetAttr : string -&gt; Microsoft.VisualBasic.FileAttribute" Usage="Microsoft.VisualBasic.FileSystem.GetAttr PathName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.VisualBasic.FileAttribute</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="PathName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="PathName">必须的。 指定一个文件名、目录名或文件夹名的 <see langword="String" /> 表达式。 <paramref name="PathName" /> 可以包含驱动器和目录或文件夹。</param>
        <summary>返回一个表示文件、目录或文件夹的特性的 <see langword="FileAttribute" /> 值。 相比 <see langword="FileAttribute" />，<see langword="My" /> 功能可使文件 I/O 操作的效率更高、性能更好。 有关详情，请参阅<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</summary>
        <returns>由 <see langword="GetAttr" /> 返回的值是下列枚举值的和： 
 <list type="table"><item><term> “值” 
 </term><description> 返回的常量 
 </description><description> 描述 
 </description></item><item><term><see langword="Normal" /></term><description><see langword="vbNormal" /></description><description> 正常。  
  
 </description></item><item><term><see langword="ReadOnly" /></term><description><see langword="vbReadOnly" /></description><description> 只读。  
  
 </description></item><item><term><see langword="Hidden" /></term><description><see langword="vbHidden" /></description><description> 隐藏。  
  
 </description></item><item><term><see langword="System" /></term><description><see langword="vbSystem" /></description><description> 系统文件。  
  
 </description></item><item><term><see langword="Directory" /></term><description><see langword="vbDirectory" /></description><description> 目录或文件夹。  
  
 </description></item><item><term><see langword="Archive" /></term><description><see langword="vbArchive" /></description><description> 文件自上次备份后已更改。  
  
 </description></item><item><term><see langword="Alias" /></term><description><see langword="vbAlias" /></description><description> 文件具有不同的名称。  
  
 </description></item></list><block subset="none" type="note"><para>  
 这些枚举是由 Visual Basic 语言指定的。 可以在代码中的任何位置使用这些名称以代替实际值。  
  
</para></block></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要确定设置了哪些属性，请使用`And`运算符执行返回的值的按位比较`GetAttr`函数和所需的各个文件属性的值。 如果结果不为零，该属性设置为指定的文件。 例如，下面的返回值`And`表达式是零个 if`Archive`未设置属性：  
  
```vb  
Result = GetAttr(FName) And vbArchive  
```  
  
 如果返回非零值`Archive`属性设置。  
  
   
  
## Examples  
 此示例使用`GetAttr`函数来确定文件和目录或文件夹的属性。  
  
 [!code-vb[VbVbalrCatRef#25](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#25)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">
          <paramref name="Pathname" /> 无效或包含通配符。</exception>
        <exception cref="T:System.IO.FileNotFoundException">目标文件不存在。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileAttr(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.SetAttr(System.String,Microsoft.VisualBasic.FileAttribute)" />
        <altmember cref="T:System.IO.IOException" />
        <altmember cref="T:System.IO.FileNotFoundException" />
        <altmember cref="T:Microsoft.VisualBasic.FileAttribute" />
        <related type="Article" href="~/docs/visual-basic/language-reference/operators/and-operator.md">And 运算符 (Visual Basic)</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">使用 Visual Basic 访问文件</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Input">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>读取打开的顺序文件中的数据，并将这些数据赋值给变量。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref bool Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, bool&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, bool % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Boolean" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必须的。 任何有效文件数。</param>
        <param name="Value">必须的。 被赋以从文件中读取的值的变量不能是数组或对象变量。</param>
        <summary>读取打开的顺序文件中的数据，并将这些数据赋值给变量。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Input`提供函数是为了向后兼容，可能会影响性能。 对于非旧版应用程序，`My.Computer.FileSystem`对象提供更好的性能。 有关详细信息，请参阅[使用 Visual Basic 访问文件](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)。  
  
 与读取的数据`Input`通常通过使用写入到文件`Write`。 此函数只能用于在打开的文件`Input`或`Binary`模式。  
  
> [!IMPORTANT]
>  当从文件读取，不要确定基于文件扩展名的文件的内容。 例如，名为 form1.vb 的文件可能不是 Visual Basic 2005 源文件。  
  
 读取时，标准字符串或数值数据分配到无需修改的变量。 下表说明了如何处理其他输入的数据。  
  
|数据|分配给变量的值|  
|-|-|  
|分隔逗号或空行|空|  
|#NULL #|`DBNull`|  
|#TRUE # 或 #FALSE #|`True` 或 `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|日期和/或表达式表示的时间|  
|#ERROR `errornumber`#|`errornumber` （变量是对象标记为错误）|  
  
 如果在输入数据项目时达到文件末尾，停止输入，并出现错误。  
  
> [!NOTE]
>  `Input`函数未进行本地化。 例如，在德语版，如果输入 3,14159，它返回仅 3，因为逗号视为变量分隔符而不是作为小数点。  
  
> [!IMPORTANT]
>  通过使用从文件中读取`Input`函数需要`Read`从访问`FileIOPermissionAccess`枚举。 有关详情，请参阅<xref:System.Security.Permissions.FileIOPermissionAccess>。  
  
   
  
## Examples  
 此示例使用`Input`函数来从文件读取数据，到两个变量。 此示例假定`TestFile`是一个文件，已使用对其写入数据的某些行`Write`函数，每行都包含在引用和由逗号分隔，例如一个数字的字符串: ("Hello"，234)。  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">文件模式无效。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md">如何：在 Visual Basic 中向文件内写入文本</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">使用 Visual Basic 访问文件</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md">如何： 使用 Streamwriter (Visual Basic 中) 的文件中写入文本</related>
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref byte Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, unsigned int8&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Byte@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Byte)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, System::Byte % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Byte" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必须的。 任何有效文件数。</param>
        <param name="Value">必须的。 被赋以从文件中读取的值的变量不能是数组或对象变量。</param>
        <summary>读取打开的顺序文件中的数据，并将这些数据赋值给变量。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Input`提供函数是为了向后兼容，可能会影响性能。 对于非旧版应用程序，`My.Computer.FileSystem`对象提供更好的性能。 有关详细信息，请参阅[使用 Visual Basic 访问文件](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)。  
  
 与读取的数据`Input`通常通过使用写入到文件`Write`。 此函数只能用于在打开的文件`Input`或`Binary`模式。  
  
> [!IMPORTANT]
>  当从文件读取，不要确定基于文件扩展名的文件的内容。 例如，名为 form1.vb 的文件可能不是 Visual Basic 2005 源文件。  
  
 读取时，标准字符串或数值数据分配到无需修改的变量。 下表说明了如何处理其他输入的数据。  
  
|数据|分配给变量的值|  
|-|-|  
|分隔逗号或空行|空|  
|#NULL #|`DBNull`|  
|#TRUE # 或 #FALSE #|`True` 或 `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|日期和/或表达式表示的时间|  
|#ERROR `errornumber`#|`errornumber` （变量是对象标记为错误）|  
  
 如果在输入数据项目时达到文件末尾，停止输入，并出现错误。  
  
> [!NOTE]
>  `Input`函数未进行本地化。 例如，在德语版，如果输入 3,14159，它返回仅 3，因为逗号视为变量分隔符而不是作为小数点。  
  
> [!IMPORTANT]
>  通过使用从文件中读取`Input`函数需要`Read`从访问`FileIOPermissionAccess`枚举。 有关详情，请参阅<xref:System.Security.Permissions.FileIOPermissionAccess>。  
  
   
  
## Examples  
 此示例使用`Input`函数来从文件读取数据，到两个变量。 此示例假定`TestFile`是一个文件，已使用对其写入数据的某些行`Write`函数，每行都包含在引用和由逗号分隔，例如一个数字的字符串: ("Hello"，234)。  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">文件模式无效。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md">如何：在 Visual Basic 中向文件内写入文本</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">使用 Visual Basic 访问文件</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md">如何： 使用 Streamwriter (Visual Basic 中) 的文件中写入文本</related>
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref char Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, char&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Char@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, char % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Char" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必须的。 任何有效文件数。</param>
        <param name="Value">必须的。 被赋以从文件中读取的值的变量不能是数组或对象变量。</param>
        <summary>读取打开的顺序文件中的数据，并将这些数据赋值给变量。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Input`提供函数是为了向后兼容，可能会影响性能。 对于非旧版应用程序，`My.Computer.FileSystem`对象提供更好的性能。 有关详细信息，请参阅[使用 Visual Basic 访问文件](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)。  
  
 与读取的数据`Input`通常通过使用写入到文件`Write`。 此函数只能用于在打开的文件`Input`或`Binary`模式。  
  
> [!IMPORTANT]
>  当从文件读取，不要确定基于文件扩展名的文件的内容。 例如，名为 form1.vb 的文件可能不是 Visual Basic 2005 源文件。  
  
 读取时，标准字符串或数值数据分配到无需修改的变量。 下表说明了如何处理其他输入的数据。  
  
|数据|分配给变量的值|  
|-|-|  
|分隔逗号或空行|空|  
|#NULL #|`DBNull`|  
|#TRUE # 或 #FALSE #|`True` 或 `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|日期和/或表达式表示的时间|  
|#ERROR `errornumber`#|`errornumber` （变量是对象标记为错误）|  
  
 如果在输入数据项目时达到文件末尾，停止输入，并出现错误。  
  
> [!NOTE]
>  `Input`函数未进行本地化。 例如，在德语版，如果输入 3,14159，它返回仅 3，因为逗号视为变量分隔符而不是作为小数点。  
  
> [!IMPORTANT]
>  通过使用从文件中读取`Input`函数需要`Read`从访问`FileIOPermissionAccess`枚举。 有关详情，请参阅<xref:System.Security.Permissions.FileIOPermissionAccess>。  
  
   
  
## Examples  
 此示例使用`Input`函数来从文件读取数据，到两个变量。 此示例假定`TestFile`是一个文件，具有若干行的数据写入到该使用`Write`函数，每行都包含在引用和由逗号分隔，例如一个数字的字符串: ("Hello"，234)。  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">文件模式无效。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md">如何：在 Visual Basic 中向文件内写入文本</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">使用 Visual Basic 访问文件</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md">如何： 使用 Streamwriter (Visual Basic 中) 的文件中写入文本</related>
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref DateTime Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, valuetype System.DateTime&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.DateTime@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As DateTime)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, DateTime % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.DateTime" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必须的。 任何有效文件数。</param>
        <param name="Value">必须的。 被赋以从文件中读取的值的变量不能是数组或对象变量。</param>
        <summary>读取打开的顺序文件中的数据，并将这些数据赋值给变量。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Input`提供函数是为了向后兼容，可能会影响性能。 对于非旧版应用程序，`My.Computer.FileSystem`对象提供更好的性能。 有关详细信息，请参阅[使用 Visual Basic 访问文件](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)。  
  
 与读取的数据`Input`通常通过使用写入到文件`Write`。 此函数只能用于在打开的文件`Input`或`Binary`模式。  
  
> [!IMPORTANT]
>  当从文件读取，不要确定基于文件扩展名的文件的内容。 例如，名为 form1.vb 的文件可能不是 Visual Basic 2005 源文件。  
  
 读取时，标准字符串或数值数据分配到无需修改的变量。 下表说明了如何处理其他输入的数据。  
  
|数据|分配给变量的值|  
|-|-|  
|分隔逗号或空行|空|  
|#NULL #|`DBNull`|  
|#TRUE # 或 #FALSE #|`True` 或 `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|日期和/或表达式表示的时间|  
|#ERROR `errornumber`#|`errornumber` （变量是对象标记为错误）|  
  
 如果在输入数据项目时达到文件末尾，停止输入，并出现错误。  
  
> [!NOTE]
>  `Input`函数未进行本地化。 例如，在德语版，如果输入 3,14159，它返回仅 3，因为逗号视为变量分隔符而不是作为小数点。  
  
> [!IMPORTANT]
>  通过使用从文件中读取`Input`函数需要`Read`从访问`FileIOPermissionAccess`枚举。 有关详情，请参阅<xref:System.Security.Permissions.FileIOPermissionAccess>。  
  
   
  
## Examples  
 此示例使用`Input`函数来从文件读取数据，到两个变量。 此示例假定`TestFile`是一个文件，具有若干行的数据写入到该使用`Write`函数，每行都包含在引用和由逗号分隔，例如一个数字的字符串: ("Hello"，234)。  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">文件模式无效。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md">如何：在 Visual Basic 中向文件内写入文本</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">使用 Visual Basic 访问文件</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md">如何： 使用 Streamwriter (Visual Basic 中) 的文件中写入文本</related>
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref decimal Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, valuetype System.Decimal&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Decimal@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Decimal)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, System::Decimal % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Decimal" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必须的。 任何有效文件数。</param>
        <param name="Value">必须的。 被赋以从文件中读取的值的变量不能是数组或对象变量。</param>
        <summary>读取打开的顺序文件中的数据，并将这些数据赋值给变量。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Input`提供函数是为了向后兼容，可能会影响性能。 对于非旧版应用程序，`My.Computer.FileSystem`对象提供更好的性能。 有关详细信息，请参阅[使用 Visual Basic 访问文件](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)。  
  
 与读取的数据`Input`通常通过使用写入到文件`Write`。 此函数只能用于在打开的文件`Input`或`Binary`模式。  
  
> [!IMPORTANT]
>  当从文件读取，不要确定基于文件扩展名的文件的内容。 例如，名为 form1.vb 的文件可能不是 Visual Basic 2005 源文件。  
  
 读取时，标准字符串或数值数据分配到无需修改的变量。 下表说明了如何处理其他输入的数据。  
  
|数据|分配给变量的值|  
|-|-|  
|分隔逗号或空行|空|  
|#NULL #|`DBNull`|  
|#TRUE # 或 #FALSE #|`True` 或 `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|日期和/或表达式表示的时间|  
|#ERROR `errornumber`#|`errornumber` （变量是对象标记为错误）|  
  
 如果在输入数据项目时达到文件末尾，停止输入，并出现错误。  
  
> [!NOTE]
>  `Input`函数未进行本地化。 例如，在德语版，如果输入 3,14159，它返回仅 3，因为逗号视为变量分隔符而不是作为小数点。  
  
> [!IMPORTANT]
>  通过使用从文件中读取`Input`函数需要`Read`从访问`FileIOPermissionAccess`枚举。 有关详情，请参阅<xref:System.Security.Permissions.FileIOPermissionAccess>。  
  
   
  
## Examples  
 此示例使用`Input`函数来从文件读取数据，到两个变量。 此示例假定`TestFile`是一个文件，具有若干行的数据写入到该使用`Write`函数，每行都包含在引用和由逗号分隔，例如一个数字的字符串: ("Hello"，234)。  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">文件模式无效。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md">如何：在 Visual Basic 中向文件内写入文本</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">使用 Visual Basic 访问文件</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md">如何： 使用 Streamwriter (Visual Basic 中) 的文件中写入文本</related>
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref double Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, float64&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Double@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, double % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Double" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必须的。 任何有效文件数。</param>
        <param name="Value">必须的。 被赋以从文件中读取的值的变量不能是数组或对象变量。</param>
        <summary>读取打开的顺序文件中的数据，并将这些数据赋值给变量。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Input`提供函数是为了向后兼容，可能会影响性能。 对于非旧版应用程序，`My.Computer.FileSystem`对象提供更好的性能。 有关详细信息，请参阅[使用 Visual Basic 访问文件](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)。  
  
 与读取的数据`Input`通常通过使用写入到文件`Write`。 此函数只能用于在打开的文件`Input`或`Binary`模式。  
  
> [!IMPORTANT]
>  当从文件读取，不要确定基于文件扩展名的文件的内容。 例如，名为 form1.vb 的文件可能不是 Visual Basic 2005 源文件。  
  
 读取时，标准字符串或数值数据分配到无需修改的变量。 下表说明了如何处理其他输入的数据。  
  
|数据|分配给变量的值|  
|-|-|  
|分隔逗号或空行|空|  
|#NULL #|`DBNull`|  
|#TRUE # 或 #FALSE #|`True` 或 `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|日期和/或表达式表示的时间|  
|#ERROR `errornumber`#|`errornumber` （变量是对象标记为错误）|  
  
 如果在输入数据项目时达到文件末尾，停止输入，并出现错误。  
  
> [!NOTE]
>  `Input`函数未进行本地化。 例如，在德语版，如果输入 3,14159，它返回仅 3，因为逗号视为变量分隔符而不是作为小数点。  
  
> [!IMPORTANT]
>  通过使用从文件中读取`Input`函数需要`Read`从访问`FileIOPermissionAccess`枚举。 有关详情，请参阅<xref:System.Security.Permissions.FileIOPermissionAccess>。  
  
   
  
## Examples  
 此示例使用`Input`函数来从文件读取数据，到两个变量。 此示例假定`TestFile`是一个文件，具有若干行的数据写入到该使用`Write`函数，每行都包含在引用和由逗号分隔，例如一个数字的字符串: ("Hello"，234)。  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">文件模式无效。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md">如何：在 Visual Basic 中向文件内写入文本</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">使用 Visual Basic 访问文件</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md">如何： 使用 Streamwriter (Visual Basic 中) 的文件中写入文本</related>
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref short Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, int16&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int16@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Short)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, short % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int16" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必须的。 任何有效文件数。</param>
        <param name="Value">必须的。 被赋以从文件中读取的值的变量不能是数组或对象变量。</param>
        <summary>读取打开的顺序文件中的数据，并将这些数据赋值给变量。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Input`提供函数是为了向后兼容，可能会影响性能。 对于非旧版应用程序，`My.Computer.FileSystem`对象提供更好的性能。 有关详细信息，请参阅[使用 Visual Basic 访问文件](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)。  
  
 与读取的数据`Input`通常通过使用写入到文件`Write`。 此函数只能用于在打开的文件`Input`或`Binary`模式。  
  
> [!IMPORTANT]
>  当从文件读取，不要确定基于文件扩展名的文件的内容。 例如，名为 form1.vb 的文件可能不是 Visual Basic 2005 源文件。  
  
 读取时，标准字符串或数值数据分配到无需修改的变量。 下表说明了如何处理其他输入的数据。  
  
|数据|分配给变量的值|  
|-|-|  
|分隔逗号或空行|空|  
|#NULL #|`DBNull`|  
|#TRUE # 或 #FALSE #|`True` 或 `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|日期和/或表达式表示的时间|  
|#ERROR `errornumber`#|`errornumber` （变量是对象标记为错误）|  
  
 如果在输入数据项目时达到文件末尾，停止输入，并出现错误。  
  
> [!NOTE]
>  `Input`函数未进行本地化。 例如，在德语版，如果输入 3,14159，它返回仅 3，因为逗号视为变量分隔符而不是作为小数点。  
  
> [!IMPORTANT]
>  通过使用从文件中读取`Input`函数需要`Read`从访问`FileIOPermissionAccess`枚举。 有关详情，请参阅<xref:System.Security.Permissions.FileIOPermissionAccess>。  
  
   
  
## Examples  
 此示例使用`Input`函数来从文件读取数据，到两个变量。 此示例假定`TestFile`是一个文件，具有若干行的数据写入到该使用`Write`函数，每行都包含在引用和由逗号分隔，例如一个数字的字符串: ("Hello"，234)。  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">文件模式无效。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md">如何：在 Visual Basic 中向文件内写入文本</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">使用 Visual Basic 访问文件</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md">如何： 使用 Streamwriter (Visual Basic 中) 的文件中写入文本</related>
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref int Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, int32&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, int % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int32" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必须的。 任何有效文件数。</param>
        <param name="Value">必须的。 被赋以从文件中读取的值的变量不能是数组或对象变量。</param>
        <summary>读取打开的顺序文件中的数据，并将这些数据赋值给变量。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Input`提供函数是为了向后兼容，可能会影响性能。 对于非旧版应用程序，`My.Computer.FileSystem`对象提供更好的性能。 有关详细信息，请参阅[使用 Visual Basic 访问文件](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)。  
  
 与读取的数据`Input`通常通过使用写入到文件`Write`。 此函数只能用于在打开的文件`Input`或`Binary`模式。  
  
> [!IMPORTANT]
>  当从文件读取，不要确定基于文件扩展名的文件的内容。 例如，名为 form1.vb 的文件可能不是 Visual Basic 2005 源文件。  
  
 读取时，标准字符串或数值数据分配到无需修改的变量。 下表说明了如何处理其他输入的数据。  
  
|数据|分配给变量的值|  
|-|-|  
|分隔逗号或空行|空|  
|#NULL #|`DBNull`|  
|#TRUE # 或 #FALSE #|`True` 或 `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|日期和/或表达式表示的时间|  
|#ERROR `errornumber`#|`errornumber` （变量是对象标记为错误）|  
  
 如果在输入数据项目时达到文件末尾，停止输入，并出现错误。  
  
> [!NOTE]
>  `Input`函数未进行本地化。 例如，在德语版，如果输入 3,14159，它返回仅 3，因为逗号视为变量分隔符而不是作为小数点。  
  
> [!IMPORTANT]
>  通过使用从文件中读取`Input`函数需要`Read`从访问`FileIOPermissionAccess`枚举。 有关详情，请参阅<xref:System.Security.Permissions.FileIOPermissionAccess>。  
  
   
  
## Examples  
 此示例使用`Input`函数来从文件读取数据，到两个变量。 此示例假定`TestFile`是一个文件，具有若干行的数据写入到该使用`Write`函数，每行都包含在引用和由逗号分隔，例如一个数字的字符串: ("Hello"，234)。  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">文件模式无效。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md">如何：在 Visual Basic 中向文件内写入文本</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">使用 Visual Basic 访问文件</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md">如何： 使用 Streamwriter (Visual Basic 中) 的文件中写入文本</related>
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref long Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, int64&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int64@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, long % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int64" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必须的。 任何有效文件数。</param>
        <param name="Value">必须的。 被赋以从文件中读取的值的变量不能是数组或对象变量。</param>
        <summary>读取打开的顺序文件中的数据，并将这些数据赋值给变量。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Input`提供函数是为了向后兼容，可能会影响性能。 对于非旧版应用程序，`My.Computer.FileSystem`对象提供更好的性能。 有关详细信息，请参阅[使用 Visual Basic 访问文件](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)。  
  
 与读取的数据`Input`通常通过使用写入到文件`Write`。 此函数只能用于在打开的文件`Input`或`Binary`模式。  
  
> [!IMPORTANT]
>  当从文件读取，不要确定基于文件扩展名的文件的内容。 例如，名为 form1.vb 的文件可能不是 Visual Basic 2005 源文件。  
  
 读取时，标准字符串或数值数据分配到无需修改的变量。 下表说明了如何处理其他输入的数据。  
  
|数据|分配给变量的值|  
|-|-|  
|分隔逗号或空行|空|  
|#NULL #|`DBNull`|  
|#TRUE # 或 #FALSE #|`True` 或 `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|日期和/或表达式表示的时间|  
|#ERROR `errornumber`#|`errornumber` （变量是对象标记为错误）|  
  
 如果在输入数据项目时达到文件末尾，停止输入，并出现错误。  
  
> [!NOTE]
>  `Input`函数未进行本地化。 例如，在德语版，如果输入 3,14159，它返回仅 3，因为逗号视为变量分隔符而不是作为小数点。  
  
> [!IMPORTANT]
>  通过使用从文件中读取`Input`函数需要`Read`从访问`FileIOPermissionAccess`枚举。 有关详情，请参阅<xref:System.Security.Permissions.FileIOPermissionAccess>。  
  
   
  
## Examples  
 此示例使用`Input`函数来从文件读取数据，到两个变量。 此示例假定`TestFile`是一个文件，具有若干行的数据写入到该使用`Write`函数，每行都包含在引用和由逗号分隔，例如一个数字的字符串: ("Hello"，234)。  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">文件模式无效。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md">如何：在 Visual Basic 中向文件内写入文本</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">使用 Visual Basic 访问文件</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md">如何： 使用 Streamwriter (Visual Basic 中) 的文件中写入文本</related>
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref object Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, object&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Object@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, System::Object ^ % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Object" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必须的。 任何有效文件数。</param>
        <param name="Value">必须的。 被赋以从文件中读取的值的变量不能是数组或对象变量。</param>
        <summary>读取打开的顺序文件中的数据，并将这些数据赋值给变量。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Input`提供函数是为了向后兼容，可能会影响性能。 对于非旧版应用程序，`My.Computer.FileSystem`对象提供更好的性能。 有关详细信息，请参阅[使用 Visual Basic 访问文件](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)。  
  
 与读取的数据`Input`通常通过使用写入到文件`Write`。 此函数只能用于在打开的文件`Input`或`Binary`模式。  
  
> [!IMPORTANT]
>  当从文件读取，不要确定基于文件扩展名的文件的内容。 例如，名为 form1.vb 的文件可能不是 Visual Basic 2005 源文件。  
  
 读取时，标准字符串或数值数据分配到无需修改的变量。 下表说明了如何处理其他输入的数据。  
  
|数据|分配给变量的值|  
|-|-|  
|分隔逗号或空行|空|  
|#NULL #|`DBNull`|  
|#TRUE # 或 #FALSE #|`True` 或 `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|日期和/或表达式表示的时间|  
|#ERROR `errornumber`#|`errornumber` （变量是对象标记为错误）|  
  
 如果在输入数据项目时达到文件末尾，停止输入，并出现错误。  
  
> [!NOTE]
>  `Input`函数未进行本地化。 例如，在德语版，如果输入 3,14159，它返回仅 3，因为逗号视为变量分隔符而不是作为小数点。  
  
> [!IMPORTANT]
>  通过使用从文件中读取`Input`函数需要`Read`从访问`FileIOPermissionAccess`枚举。 有关详情，请参阅<xref:System.Security.Permissions.FileIOPermissionAccess>。  
  
   
  
## Examples  
 此示例使用`Input`函数来从文件读取数据，到两个变量。 此示例假定`TestFile`是一个文件，具有若干行的数据写入到该使用`Write`函数，每行都包含在引用和由逗号分隔，例如一个数字的字符串: ("Hello"，234)。  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">文件模式无效。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md">如何：在 Visual Basic 中向文件内写入文本</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">使用 Visual Basic 访问文件</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md">如何： 使用 Streamwriter (Visual Basic 中) 的文件中写入文本</related>
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref float Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, float32&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Single@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, float % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Single" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必须的。 任何有效文件数。</param>
        <param name="Value">必须的。 被赋以从文件中读取的值的变量不能是数组或对象变量。</param>
        <summary>读取打开的顺序文件中的数据，并将这些数据赋值给变量。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Input`提供函数是为了向后兼容，可能会影响性能。 对于非旧版应用程序，`My.Computer.FileSystem`对象提供更好的性能。 有关详细信息，请参阅[使用 Visual Basic 访问文件](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)。  
  
 与读取的数据`Input`通常通过使用写入到文件`Write`。 此函数只能用于在打开的文件`Input`或`Binary`模式。  
  
> [!IMPORTANT]
>  当从文件读取，不要确定基于文件扩展名的文件的内容。 例如，名为 form1.vb 的文件可能不是 Visual Basic 2005 源文件。  
  
 读取时，标准字符串或数值数据分配到无需修改的变量。 下表说明了如何处理其他输入的数据。  
  
|数据|分配给变量的值|  
|-|-|  
|分隔逗号或空行|空|  
|#NULL #|`DBNull`|  
|#TRUE # 或 #FALSE #|`True` 或 `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|日期和/或表达式表示的时间|  
|#ERROR `errornumber`#|`errornumber` （变量是对象标记为错误）|  
  
 如果在输入数据项目时达到文件末尾，停止输入，并出现错误。  
  
> [!NOTE]
>  `Input`函数未进行本地化。 例如，在德语版，如果输入 3,14159，它返回仅 3，因为逗号视为变量分隔符而不是作为小数点。  
  
> [!IMPORTANT]
>  通过使用从文件中读取`Input`函数需要`Read`从访问`FileIOPermissionAccess`枚举。 有关详情，请参阅<xref:System.Security.Permissions.FileIOPermissionAccess>。  
  
   
  
## Examples  
 此示例使用`Input`函数来从文件读取数据，到两个变量。 此示例假定`TestFile`是一个文件，具有若干行的数据写入到该使用`Write`函数，每行都包含在引用和由逗号分隔，例如一个数字的字符串: ("Hello"，234)。  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">文件模式无效。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md">如何：在 Visual Basic 中向文件内写入文本</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">使用 Visual Basic 访问文件</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md">如何： 使用 Streamwriter (Visual Basic 中) 的文件中写入文本</related>
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref string Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, string&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.String@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, System::String ^ % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.String" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必须的。 任何有效文件数。</param>
        <param name="Value">必须的。 被赋以从文件中读取的值的变量不能是数组或对象变量。</param>
        <summary>读取打开的顺序文件中的数据，并将这些数据赋值给变量。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Input`提供函数是为了向后兼容，可能会影响性能。 对于非旧版应用程序，`My.Computer.FileSystem`对象提供更好的性能。 有关详细信息，请参阅[使用 Visual Basic 访问文件](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)。  
  
 与读取的数据`Input`通常通过使用写入到文件`Write`。 此函数只能用于在打开的文件`Input`或`Binary`模式。  
  
> [!IMPORTANT]
>  当从文件读取，不要确定基于文件扩展名的文件的内容。 例如，名为 form1.vb 的文件可能不是 Visual Basic 2005 源文件。  
  
 读取时，标准字符串或数值数据分配到无需修改的变量。 下表说明了如何处理其他输入的数据。  
  
|数据|分配给变量的值|  
|-|-|  
|分隔逗号或空行|空|  
|#NULL #|`DBNull`|  
|#TRUE # 或 #FALSE #|`True` 或 `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|日期和/或表达式表示的时间|  
|#ERROR `errornumber`#|`errornumber` （变量是对象标记为错误）|  
  
 如果在输入数据项目时达到文件末尾，停止输入，并出现错误。  
  
> [!NOTE]
>  `Input`函数未进行本地化。 例如，在德语版，如果输入 3,14159，它返回仅 3，因为逗号视为变量分隔符而不是作为小数点。  
  
> [!IMPORTANT]
>  通过使用从文件中读取`Input`函数需要`Read`从访问`FileIOPermissionAccess`枚举。 有关详情，请参阅<xref:System.Security.Permissions.FileIOPermissionAccess>。  
  
   
  
## Examples  
 此示例使用`Input`函数来从文件读取数据，到两个变量。 此示例假定`TestFile`是一个文件，具有若干行的数据写入到该使用`Write`函数，每行都包含在引用和由逗号分隔，例如一个数字的字符串: ("Hello"，234)。  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">文件模式无效。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md">如何：在 Visual Basic 中向文件内写入文本</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">使用 Visual Basic 访问文件</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md">如何： 使用 Streamwriter (Visual Basic 中) 的文件中写入文本</related>
      </Docs>
    </Member>
    <Member MemberName="InputString">
      <MemberSignature Language="C#" Value="public static string InputString (int FileNumber, int CharCount);" />
      <MemberSignature Language="ILAsm" Value=".method public static string InputString(int32 FileNumber, int32 CharCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function InputString (FileNumber As Integer, CharCount As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ InputString(int FileNumber, int CharCount);" />
      <MemberSignature Language="F#" Value="static member InputString : int * int -&gt; string" Usage="Microsoft.VisualBasic.FileSystem.InputString (FileNumber, CharCount)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="CharCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必须的。 任何有效文件数。</param>
        <param name="CharCount">必须的。 用于指定要读取的字符数的任何有效数值表达式。</param>
        <summary>返回 <see langword="String" /> 值，该值包含以 <see langword="Input" /> 或 <see langword="Binary" /> 模式打开的文件中的字符。 相比 <see langword="InputString" />，<see langword="My" /> 功能可使文件 I/O 操作的效率更高、性能更好。 有关详情，请参阅<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</summary>
        <returns>返回 <see langword="String" /> 值，该值包含以 <see langword="Input" /> 或 <see langword="Binary" /> 模式打开的文件中的字符。 相比 <see langword="InputString" />，<see langword="My" /> 功能可使文件 I/O 操作的效率更高、性能更好。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `InputString`提供函数是为了向后兼容，可能会影响性能。 对于非旧版应用程序，`My.Computer.FileSystem`对象提供更好的性能。 有关详细信息，请参阅[使用 Visual Basic 访问文件](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)。  
  
 与读取的数据`InputString`函数通常通过使用写入到文件`Print`或`FilePut`。 此函数只能用于在打开的文件`Input`或`Binary`模式。  
  
 与不同`Input`函数，`InputString`函数将返回它所读取的所有字符。 这包括逗号、 回车符、 换行符、 引号和前导空格。  
  
 使用文件打开以进行`Binary`访问，请尝试使用通过文件读取`InputString`直到函数`EOF`返回`True`生成一个错误。 使用`LOF`并`Loc`函数而不是`EOF`通过读取二进制文件时`InputString`，或使用`FileGet`当你使用`EOF`函数。  
  
> [!NOTE]
>  当从文件读取，不要根据文件扩展名的文件的内容的安全决策。 例如，名为 form1.vb 的文件可能不是 Visual Basic 源文件。  
  
   
  
## Examples  
 此示例使用`InputString`函数来从文件一次读取一个字符，并将其打印到`Output`窗口。 此示例假定`MyFile`是具有示例数据的多个行的文本文件。  
  
 [!code-vb[VbVbalrCatRef#33](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#33)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">
          <paramref name="FileNumber" /> 不存在。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="CharCount" />&lt; 0 或 &gt; 214。</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Input" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">使用 Visual Basic 访问文件</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md">如何： 使用 Streamwriter (Visual Basic 中) 的文件中写入文本</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md">如何：在 Visual Basic 中向文件内写入文本</related>
      </Docs>
    </Member>
    <Member MemberName="Kill">
      <MemberSignature Language="C#" Value="public static void Kill (string PathName);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Kill(string PathName) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Kill(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Kill (PathName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Kill(System::String ^ PathName);" />
      <MemberSignature Language="F#" Value="static member Kill : string -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Kill PathName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="PathName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="PathName">必须的。 指定要删除的一个或多个文件名的 <see langword="String" /> 表达式。 <paramref name="PathName" /> 可以包含驱动器和目录或文件夹。</param>
        <summary>从磁盘中删除文件。 相比 <see langword="Kill" />，<see langword="My" /> 功能可使文件 I/O 操作的效率更高、性能更好。 有关更多信息，请参见<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Kill` 支持使用多个字符 (`*`) 和单字符 (`?`) 通配符来指定多个文件。  
  
 **安全说明**若要执行，`Kill`函数要求`Read`并`PathDiscovery`标志的<xref:System.Security.Permissions.FileIOPermission>要对其授予对执行代码。 有关详细信息，请参阅<xref:System.Security.SecurityException>[代码访问权限](https://msdn.microsoft.com/library/e5ae402f-6dda-4732-bbe8-77296630f675)  
  
   
  
## Examples  
 此示例使用`Kill`函数从磁盘中删除文件。  
  
 [!code-vb[VbVbalrCatRef#60](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#60)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">目标文件打开。</exception>
        <exception cref="T:System.IO.FileNotFoundException">目标文件未找到。</exception>
        <exception cref="T:System.Security.SecurityException">权限被拒绝。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.RmDir(System.String)" />
        <altmember cref="T:System.IO.IOException" />
        <altmember cref="T:System.IO.FileNotFoundException" />
      </Docs>
    </Member>
    <Member MemberName="LineInput">
      <MemberSignature Language="C#" Value="public static string LineInput (int FileNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public static string LineInput(int32 FileNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.LineInput(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function LineInput (FileNumber As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ LineInput(int FileNumber);" />
      <MemberSignature Language="F#" Value="static member LineInput : int -&gt; string" Usage="Microsoft.VisualBasic.FileSystem.LineInput FileNumber" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必须的。 任何有效文件数。</param>
        <summary>从打开的顺序文件中读取一行并将其赋值给一个 <see langword="String" /> 变量。</summary>
        <returns>从打开的顺序文件中读取一行并将其赋值给一个 <see langword="String" /> 变量。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `LineInput`提供函数是为了向后兼容，可能会影响性能。 对于非旧版应用程序，`My.Computer.FileSystem`对象提供更好的性能。 有关详细信息，请参阅[使用 Visual Basic 访问文件](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)。  
  
 与读取的数据`LineInput`通常通过使用写入到文件`Print`。  
  
> [!IMPORTANT]
>  时从文件读取，不要根据文件扩展名的文件的内容的决策。 例如，名为 form1.vb 的文件不可能的 Visual Basic 源代码文件。  
  
 `LineInput`函数从文件中的一个字符读取一次直到它遇到回车符 (`Chr(13)`) 或回车符/换行符 (`Chr(13) + Chr(10)`) 序列。 回车/换行符序列将跳过而不是追加到字符字符串。  
  
> [!IMPORTANT]
>  通过使用从文件中读取`LineInput`函数需要`Read`从访问<xref:System.Security.Permissions.FileIOPermissionAccess>枚举。  
  
   
  
## Examples  
 此示例使用`LineInput`函数来从顺序文件中读取一行，并将其分配给一个变量。 此示例假定`TestFile`是具有示例数据的多个行的文本文件。  
  
 [!code-vb[VbVbalrCatRef#19](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#19)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.EndOfStreamException">到达文件末尾。</exception>
        <exception cref="T:System.IO.IOException">
          <paramref name="FileNumber" /> 不存在。</exception>
        <altmember cref="M:Microsoft.VisualBasic.Strings.Chr(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.ChrW(System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Input" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">使用 Visual Basic 访问文件</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md">如何： 使用 Streamwriter (Visual Basic 中) 的文件中写入文本</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md">如何：在 Visual Basic 中向文件内写入文本</related>
      </Docs>
    </Member>
    <Member MemberName="Loc">
      <MemberSignature Language="C#" Value="public static long Loc (int FileNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public static int64 Loc(int32 FileNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Loc(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Loc (FileNumber As Integer) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long Loc(int FileNumber);" />
      <MemberSignature Language="F#" Value="static member Loc : int -&gt; int64" Usage="Microsoft.VisualBasic.FileSystem.Loc FileNumber" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必须的。 任何有效的 <see langword="Integer" /> 文件号。</param>
        <summary>返回指定打开文件中当前读/写位置的 <see langword="Long" /> 值。</summary>
        <returns>返回指定打开文件中当前读/写位置的 <see langword="Long" /> 值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Loc`函数是从零开始的使用它来检索文件中的第一个字节将返回 0。  
  
 `Loc`提供函数是为了向后兼容，可能会影响性能。 对于非旧版应用程序，`My.Computer.FileSystem`对象提供更好的性能。 有关详细信息，请参阅[使用 Visual Basic 访问文件](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)。  
  
 下面介绍每种文件访问模式的返回值：  
  
|模式|返回值|  
|-|-|  
|`Random`|读取或写入到文件中的最后一个记录的数目。|  
|`Sequential`|除以 128 文件中的当前字节位置。 但是，返回的信息`Loc`的顺序文件不是使用也不需要。|  
|`Binary`|读取或写入的最后一个字节的位置。|  
  
   
  
## Examples  
 此示例使用`Loc`函数以返回打开的文件中的当前读/写位置。 此示例假定`MyFile`是具有示例数据的多个行的文本文件。  
  
 [!code-vb[VbVbalrCatRef#17](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#17)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">文件模式无效。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.EOF(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.LOF(System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Lock">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>控制其他进程对使用 <see langword="Open" /> 函数打开的文件的全部或部分的访问。 与 <see langword="My" /> 和 <see langword="Lock" /> 相比，<see langword="Unlock" /> 功能在文件 I/O 操作方面可为您提供更高的效率和更好的性能。 有关详情，请参阅<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Lock">
      <MemberSignature Language="C#" Value="public static void Lock (int FileNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Lock(int32 FileNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Lock(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Lock (FileNumber As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Lock(int FileNumber);" />
      <MemberSignature Language="F#" Value="static member Lock : int -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Lock FileNumber" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必须的。 任何有效文件数。</param>
        <summary>控制其他进程对使用 <see langword="Open" /> 函数打开的文件的全部或部分的访问。 与 <see langword="My" /> 和 <see langword="Lock" /> 相比，<see langword="Unlock" /> 功能在文件 I/O 操作方面可为您提供更高的效率和更好的性能。 有关详情，请参阅<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Lock`和`Unlock`函数用于环境中的多个进程可能需要访问同一文件。  
  
 `Lock` 和`Unlock`函数始终成对使用。 参数`Lock`和`Unlock`必须相同。  
  
 如果`Record`，或`FromRecord`和`ToRecord`是未提供，该锁将在整个文件。 如果`Record`单独指定单个记录将锁定/解锁。  
  
 如果已打开文件进行连续的输入或输出中，`Lock`并`Unlock`会影响整个文件，而不考虑指定的范围`FromRecord`和`ToRecord`。  
  
   
  
## Examples  
 此示例演示如何使用`Lock`和`Unlock`函数。 此示例假定`People.txt`是包含记录的结构的一个文件`Person`。  
  
 [!code-vb[VbVbalrCatRef#13](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">文件模式无效。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">使用 Visual Basic 访问文件</related>
      </Docs>
    </Member>
    <Member MemberName="Lock">
      <MemberSignature Language="C#" Value="public static void Lock (int FileNumber, long Record);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Lock(int32 FileNumber, int64 Record) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Lock(System.Int32,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Lock (FileNumber As Integer, Record As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Lock(int FileNumber, long Record);" />
      <MemberSignature Language="F#" Value="static member Lock : int * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Lock (FileNumber, Record)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Record" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必须的。 任何有效文件数。</param>
        <param name="Record">可选。 唯一要锁定或取消锁定的记录号或字节数</param>
        <summary>控制其他进程对使用 <see langword="Open" /> 函数打开的文件的全部或部分的访问。 与 <see langword="My" /> 和 <see langword="Lock" /> 相比，<see langword="Unlock" /> 功能在文件 I/O 操作方面可为您提供更高的效率和更好的性能。 有关详情，请参阅<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Lock`和`Unlock`函数用于环境中的多个进程可能需要访问同一文件。  
  
 `Lock` 和`Unlock`函数始终成对使用。 参数`Lock`和`Unlock`必须相同。  
  
 如果`Record`，或`FromRecord`和`ToRecord`是未提供，该锁将在整个文件。 如果`Record`单独指定单个记录将锁定/解锁。  
  
 如果已打开文件进行连续的输入或输出中，`Lock`并`Unlock`会影响整个文件，而不考虑指定的范围`FromRecord`和`ToRecord`。  
  
   
  
## Examples  
 此示例演示如何使用`Lock`和`Unlock`函数。 此示例假定`People.txt`是包含记录的结构的一个文件`Person`。  
  
 [!code-vb[VbVbalrCatRef#13](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">文件模式无效。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">使用 Visual Basic 访问文件</related>
      </Docs>
    </Member>
    <Member MemberName="Lock">
      <MemberSignature Language="C#" Value="public static void Lock (int FileNumber, long FromRecord, long ToRecord);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Lock(int32 FileNumber, int64 FromRecord, int64 ToRecord) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Lock(System.Int32,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Lock (FileNumber As Integer, FromRecord As Long, ToRecord As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Lock(int FileNumber, long FromRecord, long ToRecord);" />
      <MemberSignature Language="F#" Value="static member Lock : int * int64 * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Lock (FileNumber, FromRecord, ToRecord)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="FromRecord" Type="System.Int64" />
        <Parameter Name="ToRecord" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必须的。 任何有效文件数。</param>
        <param name="FromRecord">可选。 第一个要锁定或取消锁定的记录号或字节数。</param>
        <param name="ToRecord">可选。 最后一个要锁定或取消锁定的记录号或字节数。</param>
        <summary>控制其他进程对使用 <see langword="Open" /> 函数打开的文件的全部或部分的访问。 与 <see langword="My" /> 和 <see langword="Lock" /> 相比，<see langword="Unlock" /> 功能在文件 I/O 操作方面可为您提供更高的效率和更好的性能。 有关详情，请参阅<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Lock`和`Unlock`函数用于环境中的多个进程可能需要访问同一文件。  
  
 `Lock` 和`Unlock`函数始终成对使用。 参数`Lock`和`Unlock`必须相同。  
  
 如果`Record`，或`FromRecord`和`ToRecord`是未提供，该锁将在整个文件。 如果`Record`单独指定单个记录将锁定/解锁。  
  
 如果已打开文件进行连续的输入或输出中，`Lock`并`Unlock`会影响整个文件，而不考虑指定的范围`FromRecord`和`ToRecord`。  
  
   
  
## Examples  
 此示例演示如何使用`Lock`和`Unlock`函数。 此示例假定`People.txt`是包含记录的结构的一个文件`Person`。  
  
 [!code-vb[VbVbalrCatRef#13](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">文件模式无效。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">使用 Visual Basic 访问文件</related>
      </Docs>
    </Member>
    <Member MemberName="LOF">
      <MemberSignature Language="C#" Value="public static long LOF (int FileNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public static int64 LOF(int32 FileNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.LOF(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function LOF (FileNumber As Integer) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long LOF(int FileNumber);" />
      <MemberSignature Language="F#" Value="static member LOF : int -&gt; int64" Usage="Microsoft.VisualBasic.FileSystem.LOF FileNumber" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必须的。 一个包含有效文件号的 <see langword="Integer" />。</param>
        <summary>返回一个 <see langword="Long" /> 值，该值表示使用 <see langword="FileOpen" /> 函数打开的文件的大小（以字节为单位）。 相比 <see langword="LOF" />，<see langword="My" /> 功能可使文件 I/O 操作的效率更高、性能更好。 有关详情，请参阅<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</summary>
        <returns>返回一个 <see langword="Long" /> 值，该值表示使用 <see langword="FileOpen" /> 函数打开的文件的大小（以字节为单位）。 相比 <see langword="LOF" />，<see langword="My" /> 功能可使文件 I/O 操作的效率更高、性能更好。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用`FileLen`函数以获取未打开的文件的长度。  
  
   
  
## Examples  
 此示例使用`LOF`函数来确定打开的文件的大小。 此示例假定`TestFile`是一个文本文件，其中包含示例数据。  
  
 [!code-vb[VbVbalrCatRef#23](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#23)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">文件模式无效。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.EOF(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileLen(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Loc(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files.md">从文件读取 (Visual Basic)</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">写入文件 (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="MkDir">
      <MemberSignature Language="C#" Value="public static void MkDir (string Path);" />
      <MemberSignature Language="ILAsm" Value=".method public static void MkDir(string Path) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.MkDir(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub MkDir (Path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void MkDir(System::String ^ Path);" />
      <MemberSignature Language="F#" Value="static member MkDir : string -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.MkDir Path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="Path">必须的。 标识要创建的目录的 <see langword="String" /> 表达式。 <paramref name="Path" /> 可以包含驱动器。 如果未指定驱动器，则 <see langword="MkDir" /> 在当前驱动器上创建新目录。</param>
        <summary>新建目录。 相比 <see langword="MkDir" />，<see langword="My" /> 功能可使文件 I/O 操作的效率更高、性能更好。 有关详情，请参阅<see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.CreateDirectory(System.String)" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此函数创建一个新目录。  
  
   
  
## Examples  
 此示例使用`MkDir`函数来创建一个目录。 如果未指定驱动器，则当前驱动器上创建新目录。  
  
 [!code-vb[VbVbalrCatRef#38](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#38)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="Path" /> 未指定或为空。</exception>
        <exception cref="T:System.Security.SecurityException">权限被拒绝。</exception>
        <exception cref="T:System.IO.IOException">目录已存在。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.CurDir" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.RmDir(System.String)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-create-a-directory.md">如何：在 Visual Basic 中创建目录</related>
      </Docs>
    </Member>
    <Member MemberName="Print">
      <MemberSignature Language="C#" Value="public static void Print (int FileNumber, params object[] Output);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Print(int32 FileNumber, object[] Output) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub Print (FileNumber As Integer, ParamArray Output As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Print(int FileNumber, ... cli::array &lt;System::Object ^&gt; ^ Output);" />
      <MemberSignature Language="F#" Value="static member Print : int * obj[] -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Print (FileNumber, Output)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Output" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="FileNumber">必须的。 任何有效文件数。</param>
        <param name="Output">可选。 要写入文件的零个或多个由逗号分隔的表达式。  
  
<paramref name="Output" /> 参数的设置是： 
 <see langword="T:System.IO.IOException" />：文件模式无效。  
  
 <see langword="T:System.IO.IOException" />：<paramref name="FileNumber" /> 不存在。</param>
        <summary>将已设置显示格式的数据写入顺序文件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Print`和`PrintLine`函数是为了向后兼容性，可能会影响性能。 对于非旧版应用程序，`My.Computer.FileSystem`对象提供更好的性能。 有关详细信息，请参阅[使用 Visual Basic 访问文件](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)。  
  
 `Print` 不包括换行符末尾的行;但是，`PrintLine`包括换行符。  
  
 与写入的数据`Print`从文件通常通过使用读取`LineInput`或`Input`。  
  
 如果省略`Output`有关`PrintLine`，该文件; 有关打印一个空行`Print`，没有输出。 用逗号分隔的多个表达式将对齐选项卡边界，但混合使用逗号和`TAB`可能会导致不一致的结果。  
  
 有关`Boolean`数据，而是`True`或`False`打印。 `True`和`False`不转换关键字，而不考虑区域设置。  
  
 日期数据写入该文件使用您的系统所识别的标准的短日期格式。 当日期或时间部分缺失或为零时，仅提供部分写入文件。  
  
 执行任何操作写入到文件，如果`Output`数据为空。 但是，如果`Output`列表中的数据`DBNull`，`Null`写入到文件。  
  
 有关`Error`数据，输出将显示为`Error errorcode`。 `Error`关键字不会转换而不考虑区域设置。  
  
 通过使用写入到文件的所有数据`Print`是国际上通用的; 即，数据的正确格式使用相应的小数分隔符。 如果用户想要输出以供多个区域设置数据`Write`应使用。  
  
 通过使用对文件进行写入`Print`或`PrintLine`函数要求`Write`从访问`FileIOPermissionAccess`枚举。 有关更多信息，请参见<xref:System.Security.Permissions.FileIOPermissionAccess>。  
  
   
  
## Examples  
 此示例使用`Print`和`PrintLine`函数将数据写入到一个文件。  
  
 [!code-vb[VbVbalrCatRef#53](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#53)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.SPC(System.Int16)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.TAB" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">使用 Visual Basic 访问文件</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md">如何：在 Visual Basic 中向文件内写入文本</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md">如何： 使用 Streamwriter (Visual Basic 中) 的文件中写入文本</related>
      </Docs>
    </Member>
    <Member MemberName="PrintLine">
      <MemberSignature Language="C#" Value="public static void PrintLine (int FileNumber, params object[] Output);" />
      <MemberSignature Language="ILAsm" Value=".method public static void PrintLine(int32 FileNumber, object[] Output) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub PrintLine (FileNumber As Integer, ParamArray Output As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void PrintLine(int FileNumber, ... cli::array &lt;System::Object ^&gt; ^ Output);" />
      <MemberSignature Language="F#" Value="static member PrintLine : int * obj[] -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.PrintLine (FileNumber, Output)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Output" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="FileNumber">必须的。 任何有效文件数。</param>
        <param name="Output">可选。 要写入文件的零个或多个由逗号分隔的表达式。  
  
<paramref name="Output" /> 参数的设置是： 
 <see langword="T:System.IO.IOException" />：文件模式无效。  
  
 <see langword="T:System.IO.IOException" />：<paramref name="FileNumber" /> 不存在。</param>
        <summary>将已设置显示格式的数据写入顺序文件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Print`和`PrintLine`函数是为了向后兼容性，可能会影响性能。 对于非旧版应用程序，`My.Computer.FileSystem`对象提供更好的性能。 有关详细信息，请参阅[使用 Visual Basic 访问文件](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)。  
  
 `Print` 不包括换行符末尾的行;但是，`PrintLine`包括换行符。  
  
 与写入的数据`Print`从文件通常通过使用读取`LineInput`或`Input`。  
  
 如果省略`Output`有关`PrintLine`，该文件; 有关打印一个空行`Print`，没有输出。 用逗号分隔的多个表达式将对齐选项卡边界，但混合使用逗号和`TAB`可能会导致不一致的结果。  
  
 有关`Boolean`数据，而是`True`或`False`打印。 `True`和`False`不转换关键字，而不考虑区域设置。  
  
 日期数据写入文件，通过使用系统所识别的标准的短日期格式。 当日期或时间部分缺失或为零时，仅提供部分写入文件。  
  
 执行任何操作写入到文件，如果`Output`数据为空。 但是，如果`Output`列表中的数据`DBNull`，`Null`写入到文件。  
  
 有关`Error`数据，输出将显示为`Error errorcode`。 `Error`关键字不会转换而不考虑区域设置。  
  
 通过使用写入到文件的所有数据`Print`是国际上通用的; 即，数据的正确格式使用相应的小数分隔符。 如果用户想要输出以供多个区域设置数据`Write`应使用。  
  
 通过使用对文件进行写入`Print`或`PrintLine`函数要求`Write`从访问`FileIOPermissionAccess`枚举。 有关更多信息，请参见<xref:System.Security.Permissions.FileIOPermissionAccess>。  
  
   
  
## Examples  
 此示例使用`Print`和`PrintLine`函数将数据写入到一个文件。  
  
 [!code-vb[VbVbalrCatRef#53](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#53)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.SPC(System.Int16)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.TAB" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">使用 Visual Basic 访问文件</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md">如何：在 Visual Basic 中向文件内写入文本</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md">如何： 使用 Streamwriter (Visual Basic 中) 的文件中写入文本</related>
      </Docs>
    </Member>
    <Member MemberName="Rename">
      <MemberSignature Language="C#" Value="public static void Rename (string OldPath, string NewPath);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Rename(string OldPath, string NewPath) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Rename(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Rename (OldPath As String, NewPath As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Rename(System::String ^ OldPath, System::String ^ NewPath);" />
      <MemberSignature Language="F#" Value="static member Rename : string * string -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Rename (OldPath, NewPath)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="OldPath" Type="System.String" />
        <Parameter Name="NewPath" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="OldPath">必须的。 指定现有文件名和位置的 <see langword="String" /> 表达式。 <paramref name="OldPath" /> 可包含文件的目录和驱动器。</param>
        <param name="NewPath">必须的。 指定新文件名和位置的 <see langword="String" /> 表达式。 <paramref name="NewPath" /> 可包含目标位置的目录和驱动器。 <paramref name="NewPath" /> 指定的文件名不能是已存在的文件名。</param>
        <summary>重命名磁盘文件或目录。 相比 <see langword="Rename" />，<see langword="My" /> 功能可使文件 I/O 操作的效率更高、性能更好。 有关详情，请参阅<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Rename`函数重命名文件，并将其移动到另一个目录，如有必要。 `Rename`函数可以将一个文件，在驱动器，但它只能重命名现有目录时同时`NewPath`和`OldPath`位于同一驱动器上。 `Rename` 无法创建新文件或目录。  
  
 使用`Rename`函数对打开的文件会产生错误。 重命名之前，必须关闭打开的文件。 `Rename` 参数不能包含多个字符 （*） 和单字符 （？） 通配符。  
  
> [!IMPORTANT]
>  当使用`Rename`将文件从受保护的位置复制到受保护的位置，则文件，将保留不太受限制的权限。 检查以确保没有引入可能的安全风险。  
  
   
  
## Examples  
 此示例使用`Rename`函数重命名文件。 对于此示例中，假定已指定的目录存在。  
  
 [!code-vb[VbVbalrCatRef#30](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#30)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">路径无效。</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="OldPath" /> 文件不存在。</exception>
        <exception cref="T:System.IO.IOException">无法重命名为不同的设备。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Kill(System.String)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.FileNotFoundException" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-rename-a-file.md">如何：在 Visual Basic 中重命名文件</related>
      </Docs>
    </Member>
    <Member MemberName="Reset">
      <MemberSignature Language="C#" Value="public static void Reset ();" />
      <MemberSignature Language="ILAsm" Value=".method public static void Reset() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Reset" />
      <MemberSignature Language="VB.NET" Value="Public Sub Reset ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Reset();" />
      <MemberSignature Language="F#" Value="static member Reset : unit -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Reset " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>关闭所有使用 <see langword="FileOpen" /> 函数打开的磁盘文件。 相比 <see langword="Reset" />，<see langword="My" /> 功能可使文件 I/O 操作的效率更高、性能更好。 有关详情，请参阅<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Reset`函数将关闭打开的所有活动文件`FileOpen`函数，并具有相同的功能`FileClose()`不带任何参数。  
  
   
  
## Examples  
 此示例使用`Reset`函数来关闭所有打开的文件，并将所有文件缓冲区的内容写入到磁盘。 请注意，使用`Object`变量`FileNumber`作为一个字符串和数字。  
  
 [!code-vb[VbVbalrCatRef#12](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#12)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileClose(System.Int32[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <related type="Article" href="~/docs/visual-basic/language-reference/statements/end-statement.md">End 语句</related>
      </Docs>
    </Member>
    <Member MemberName="RmDir">
      <MemberSignature Language="C#" Value="public static void RmDir (string Path);" />
      <MemberSignature Language="ILAsm" Value=".method public static void RmDir(string Path) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.RmDir(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RmDir (Path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RmDir(System::String ^ Path);" />
      <MemberSignature Language="F#" Value="static member RmDir : string -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.RmDir Path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="Path">必须的。 标识要移除的目录或文件夹的 <see langword="String" /> 表达式。 <paramref name="Path" /> 可以包含驱动器。 如果未指定驱动器，则 <see langword="RmDir" /> 移除当前驱动器上的目录。</param>
        <summary>移除现有目录。 相比 <see langword="RmDir" />，<see langword="My" /> 功能可使文件 I/O 操作的效率更高、性能更好。 有关详情，请参阅<see cref="Overload:Microsoft.VisualBasic.FileIO.FileSystem.DeleteDirectory" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果你尝试使用出错`RmDir`上包含文件的目录。 使用`Kill`函数删除所有文件，再尝试删除一个目录。  
  
   
  
## Examples  
 此示例使用`RmDir`函数来删除现有目录。  
  
 [!code-vb[VbVbalrCatRef#31](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#31)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="Path" /> 未指定或为空。</exception>
        <exception cref="T:System.IO.IOException">目标目录包含文件。</exception>
        <exception cref="T:System.IO.FileNotFoundException">目录不存在。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.CurDir" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Kill(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.MkDir(System.String)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <altmember cref="T:System.IO.FileNotFoundException" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Seek">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>返回 <see langword="Long" />，它指定使用 <see langword="FileOpen" /> 函数打开的文件中的当前读/写位置；或设置使用 <see langword="FileOpen" /> 函数打开的文件中的下一个读/写操作的位置。 相比 <see langword="Seek" />，<see langword="My" /> 功能可使文件 I/O 操作的效率更高、性能更好。 有关详情，请参阅<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Seek">
      <MemberSignature Language="C#" Value="public static long Seek (int FileNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public static int64 Seek(int32 FileNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Seek(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Seek (FileNumber As Integer) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long Seek(int FileNumber);" />
      <MemberSignature Language="F#" Value="static member Seek : int -&gt; int64" Usage="Microsoft.VisualBasic.FileSystem.Seek FileNumber" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必须的。 一个包含有效文件号的 <see langword="Integer" />。</param>
        <summary>返回 <see langword="Long" />，它指定使用 <see langword="FileOpen" /> 函数打开的文件中的当前读/写位置；或设置使用 <see langword="FileOpen" /> 函数打开的文件中的下一个读/写操作的位置。 相比 <see langword="Seek" />，<see langword="My" /> 功能可使文件 I/O 操作的效率更高、性能更好。 有关详情，请参阅<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</summary>
        <returns>返回 <see langword="Long" />，它指定使用 <see langword="FileOpen" /> 函数打开的文件中的当前读/写位置；或设置使用 <see langword="FileOpen" /> 函数打开的文件中的下一个读/写操作的位置。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Seek` 返回 1 和 2,147,483,647 之间的值 (等效于 2 ^31-1)，非独占。  
  
 下面介绍每个文件访问模式的返回的值：  
  
|模式|返回值|  
|-|-|  
|`Random`|读取或写入的下一个记录的数目|  
|`Binary`, `Input`, `Output`, `Append`|下一步操作发生的字节位置。 在文件中的第一个字节位于位置 1，第二个字节在位置 2，依此类推。|  
  
   
  
## Examples  
 此示例使用`Seek`函数以返回当前文件位置。 该示例假定`TestFile`是包含记录的结构的一个文件`Record`。  
  
 [!code-vb[VbVbalrCatRef#47](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#47)]  
  
 打开的文件中`Random`模式下，`Seek`返回下一条记录的数目。  
  
 [!code-vb[VbVbalrCatRef#48](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#48)]  
  
 而不在模式下打开的文件`Random`模式下，`Seek`返回下一步操作发生的字节位置。 假定`TestFile`是包含若干行文本的文件。  
  
 [!code-vb[VbVbalrCatRef#49](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#49)]  
  
 此示例使用`Seek`函数将位置设置为下一次读取或写入的文件中。  
  
 而不在模式下打开的文件`Random`模式下，`Seek`设置下一步操作发生的字节位置。 假定`TestFile`是包含若干行文本的文件。  
  
 [!code-vb[VbVbalrCatRef#52](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#52)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">文件模式无效。</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Loc(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files.md">从文件读取 (Visual Basic)</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">写入文件 (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Seek">
      <MemberSignature Language="C#" Value="public static void Seek (int FileNumber, long Position);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Seek(int32 FileNumber, int64 Position) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Seek(System.Int32,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Seek (FileNumber As Integer, Position As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Seek(int FileNumber, long Position);" />
      <MemberSignature Language="F#" Value="static member Seek : int * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Seek (FileNumber, Position)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Position" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必须的。 一个包含有效文件号的 <see langword="Integer" />。</param>
        <param name="Position">必须的。 一个 1 到 2,147,483,647 范围内（包括 1 和 2,147,483,647）的数字，用于指示下一个读取/写入操作应该发生的位置。</param>
        <summary>返回 <see langword="Long" />，它指定使用 <see langword="FileOpen" /> 函数打开的文件中的当前读/写位置；或设置使用 <see langword="FileOpen" /> 函数打开的文件中的下一个读/写操作的位置。 相比 <see langword="Seek" />，<see langword="My" /> 功能可使文件 I/O 操作的效率更高、性能更好。 有关详情，请参阅<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Seek` 返回 1 和 2,147,483,647 之间的值 (等效于 2 ^31-1)，非独占。  
  
 下面介绍每个文件访问模式的返回的值：  
  
|模式|返回值|  
|-|-|  
|`Random`|读取或写入的下一个记录的数目|  
|`Binary`, `Input`, `Output`, `Append`|下一步操作发生的字节位置。 在文件中的第一个字节位于位置 1，第二个字节在位置 2，依此类推。|  
  
   
  
## Examples  
 此示例使用`Seek`函数以返回当前文件位置。 该示例假定`TestFile`是包含记录的结构的一个文件`Record`。  
  
 [!code-vb[VbVbalrCatRef#47](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#47)]  
  
 打开的文件中`Random`模式下，`Seek`返回下一条记录的数目。  
  
 [!code-vb[VbVbalrCatRef#48](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#48)]  
  
 而不在模式下打开的文件`Random`模式下，`Seek`返回下一步操作发生的字节位置。 假定`TestFile`是包含若干行文本的文件。  
  
 [!code-vb[VbVbalrCatRef#49](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#49)]  
  
 此示例使用`Seek`函数将位置设置为下一次读取或写入的文件中。  
  
 而不在模式下打开的文件`Random`模式下，`Seek`设置下一步操作发生的字节位置。 假定`TestFile`是包含若干行文本的文件。  
  
 [!code-vb[VbVbalrCatRef#52](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#52)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">文件模式无效。</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Loc(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files.md">从文件读取 (Visual Basic)</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">写入文件 (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="SetAttr">
      <MemberSignature Language="C#" Value="public static void SetAttr (string PathName, Microsoft.VisualBasic.FileAttribute Attributes);" />
      <MemberSignature Language="ILAsm" Value=".method public static void SetAttr(string PathName, valuetype Microsoft.VisualBasic.FileAttribute Attributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.SetAttr(System.String,Microsoft.VisualBasic.FileAttribute)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetAttr (PathName As String, Attributes As FileAttribute)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetAttr(System::String ^ PathName, Microsoft::VisualBasic::FileAttribute Attributes);" />
      <MemberSignature Language="F#" Value="static member SetAttr : string * Microsoft.VisualBasic.FileAttribute -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.SetAttr (PathName, Attributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="PathName" Type="System.String" />
        <Parameter Name="Attributes" Type="Microsoft.VisualBasic.FileAttribute" />
      </Parameters>
      <Docs>
        <param name="PathName">必须的。 指定一个文件名的 <see langword="String" /> 表达式。 <paramref name="PathName" /> 可以包含驱动器和目录或文件夹。</param>
        <param name="Attributes">必须的。 常量或数值表达式，所有这些值一起指定文件特性。</param>
        <summary>设置文件的特性信息。 相比 <see langword="SetAttr" />，<see langword="My" /> 功能可使文件 I/O 操作的效率更高、性能更好。 有关详情，请参阅<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果您尝试设置打开的文件的属性，会发生运行时错误。  
  
 `Attributes`参数枚举值如下所示：  
  
|“值”|返回的常量|描述|  
|-|-|-|  
|`Normal`|`vbNormal`|正常 （默认值）。|  
|`ReadOnly`|`vbReadOnly`|只读。|  
|`Hidden`|`vbHidden`|隐藏。|  
|`System`|`vbSystem`|系统文件。|  
|`Volume`|`vbVolume`|卷标|  
|`Directory`|`vbDirectory`|目录或文件夹。|  
|`Archive`|`vbArchive`|文件自上次备份后已更改。|  
|`Alias`|`vbAlias`|文件具有不同的名称。|  
  
> [!NOTE]
>  这些枚举是由 Visual Basic 语言指定的。 名称可以是任意位置在代码中使用而不是实际值。  
  
   
  
## Examples  
 此示例使用`SetAttr`函数设置的文件的属性。  
  
 [!code-vb[VbVbalrCatRef#14](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#14)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="Attribute" /> 类型无效。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileAttr(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.GetAttr(System.String)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:Microsoft.VisualBasic.FileAttribute" />
        <altmember cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />
      </Docs>
    </Member>
    <Member MemberName="SPC">
      <MemberSignature Language="C#" Value="public static Microsoft.VisualBasic.SpcInfo SPC (short Count);" />
      <MemberSignature Language="ILAsm" Value=".method public static valuetype Microsoft.VisualBasic.SpcInfo SPC(int16 Count) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.SPC(System.Int16)" />
      <MemberSignature Language="VB.NET" Value="Public Function SPC (Count As Short) As SpcInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Microsoft::VisualBasic::SpcInfo SPC(short Count);" />
      <MemberSignature Language="F#" Value="static member SPC : int16 -&gt; Microsoft.VisualBasic.SpcInfo" Usage="Microsoft.VisualBasic.FileSystem.SPC Count" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.VisualBasic.SpcInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Count" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="Count">必须的。 在显示或输出列表中下一个表达式之前要插入的空格数。</param>
        <summary>与 <see langword="Print" /> 或 <see langword="PrintLine" /> 函数一起使用以定位输出。</summary>
        <returns>与 <see langword="Print" /> 或 <see langword="PrintLine" /> 函数一起使用以定位输出。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果`Count`小于输出行宽下, 一个输出位置立即遵循打印的空格数。 如果`Count`大于输出行宽，`SPC`计算使用的公式的下一步打印位置：  
  
 `currentprintposition`(+(`Count``Mod``width`))  
  
 例如，如果当前输出位置为 24，输出行的宽度为 80，并指定`SPC(90)`下, 一步的输出将从开始位置 34 （当前打印位置 + 90/80 的其余部分）。 如果当前的输出位置和输出行宽度之间的区别是小于`Count`(或`Count` `Mod` *宽度*)，则`SPC`函数将跳至下一行，并生成空间等于`Count`– (*宽度*–*小于*)。  
  
> [!NOTE]
>  请确保表格列的宽度足以允许较宽的字母。  
  
   
  
## Examples  
 此示例使用`SPC`函数以定位输出文件中并在**输出**窗口。  
  
 [!code-vb[VbVbalrCatRef#16](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#16)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Space(System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.TAB" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileWidth(System.Int32,System.Int32)" />
        <related type="Article" href="~/docs/visual-basic/language-reference/operators/mod-operator.md">Mod 运算符 (Visual Basic)</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="TAB">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>与 <see langword="Print" /> 或 <see langword="PrintLine" /> 函数一起使用以定位输出。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TAB">
      <MemberSignature Language="C#" Value="public static Microsoft.VisualBasic.TabInfo TAB ();" />
      <MemberSignature Language="ILAsm" Value=".method public static valuetype Microsoft.VisualBasic.TabInfo TAB() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.TAB" />
      <MemberSignature Language="VB.NET" Value="Public Function TAB () As TabInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Microsoft::VisualBasic::TabInfo TAB();" />
      <MemberSignature Language="F#" Value="static member TAB : unit -&gt; Microsoft.VisualBasic.TabInfo" Usage="Microsoft.VisualBasic.FileSystem.TAB " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.VisualBasic.TabInfo</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>与 <see langword="Print" /> 或 <see langword="PrintLine" /> 函数一起使用以定位输出。</summary>
        <returns>与 <see langword="Print" /> 或 <see langword="PrintLine" /> 函数一起使用以定位输出。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果当前行上的当前打印位置大于`Column`，`TAB`将跳到列的值等于`Column`下一步的输出行上。 如果`Column`小于 1，`TAB`将打印位置移动到第 1 列。 如果`Column`大于输出行宽，`TAB`计算使用的公式的下一步打印位置：  
  
 Mod 列宽  
  
 例如，如果*宽度*是 80，并指定`TAB(90)`下, 一步的输出将从开始第 10 （90/80 的余数） 列。 如果`Column`小于当前打印位置，开始计算的输出位置的下一行上。 如果计算出的打印位置大于当前打印位置，打印开始计算打印位置在同一行。  
  
 输出行上最左侧的打印位置始终为 1。 当你使用`Print`或`PrintLine`函数来打印到文件，右侧的输出位置是输出文件，您可以使用设置的当前宽度`FileWidth`函数。  
  
 `TAB`函数也可以用于`WriteLine`函数。 它不能用于<xref:System.Diagnostics.Debug.WriteLine%2A?displayProperty=nameWithType>或<xref:System.Console.WriteLine%2A?displayProperty=nameWithType>。  
  
> [!NOTE]
>  请确保表格列的宽度足以包含较宽的字母。  
  
   
  
## Examples  
 此示例使用`TAB`函数以定位输出文件中并在**输出**窗口。  
  
 [!code-vb[VbVbalrCatRef#37](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#37)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Space(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.SPC(System.Int16)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileWidth(System.Int32,System.Int32)" />
        <related type="Article" href="~/docs/visual-basic/language-reference/operators/mod-operator.md">Mod 运算符 (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="TAB">
      <MemberSignature Language="C#" Value="public static Microsoft.VisualBasic.TabInfo TAB (short Column);" />
      <MemberSignature Language="ILAsm" Value=".method public static valuetype Microsoft.VisualBasic.TabInfo TAB(int16 Column) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.TAB(System.Int16)" />
      <MemberSignature Language="VB.NET" Value="Public Function TAB (Column As Short) As TabInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Microsoft::VisualBasic::TabInfo TAB(short Column);" />
      <MemberSignature Language="F#" Value="static member TAB : int16 -&gt; Microsoft.VisualBasic.TabInfo" Usage="Microsoft.VisualBasic.FileSystem.TAB Column" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.VisualBasic.TabInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Column" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="Column">可选。 在显示或输出列表中下一个表达式之前要移动到的列号。 如果省略它，则 <see langword="TAB" /> 将插入点移动到下一个打印区域的开始位置。</param>
        <summary>与 <see langword="Print" /> 或 <see langword="PrintLine" /> 函数一起使用以定位输出。</summary>
        <returns>与 <see langword="Print" /> 或 <see langword="PrintLine" /> 函数一起使用以定位输出。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果当前行上的当前打印位置大于`Column`，`TAB`将跳到列的值等于`Column`下一步的输出行上。 如果`Column`小于 1，`TAB`将打印位置移动到第 1 列。 如果`Column`大于输出行宽，`TAB`计算使用的公式的下一步打印位置：  
  
 Mod 列宽  
  
 例如，如果*宽度*是 80，并指定`TAB(90)`下, 一步的输出将从开始第 10 （90/80 的余数） 列。 如果`Column`小于当前打印位置，开始计算的输出位置的下一行上。 如果计算出的打印位置大于当前打印位置，打印开始计算打印位置在同一行。  
  
 输出行上最左侧的打印位置始终为 1。 当你使用`Print`或`PrintLine`函数来打印到文件，右侧的输出位置是输出文件，您可以使用设置的当前宽度`FileWidth`函数。  
  
 `TAB`函数也可以用于`WriteLine`函数。 它不能用于<xref:System.Diagnostics.Debug.WriteLine%2A?displayProperty=nameWithType>或<xref:System.Console.WriteLine%2A?displayProperty=nameWithType>。  
  
> [!NOTE]
>  请确保表格列的宽度足以包含较宽的字母。  
  
   
  
## Examples  
 此示例使用`TAB`函数以定位输出文件中并在**输出**窗口。  
  
 [!code-vb[VbVbalrCatRef#37](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#37)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Space(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.SPC(System.Int16)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileWidth(System.Int32,System.Int32)" />
        <related type="Article" href="~/docs/visual-basic/language-reference/operators/mod-operator.md">Mod 运算符 (Visual Basic)</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Unlock">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>控制其他进程对使用 <see langword="Open" /> 函数打开的文件的全部或部分的访问。 与 <see langword="My" /> 和 <see langword="Lock" /> 相比，<see langword="Unlock" /> 功能在文件 I/O 操作方面可为您提供更高的效率和更好的性能。 有关详情，请参阅<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Unlock">
      <MemberSignature Language="C#" Value="public static void Unlock (int FileNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Unlock(int32 FileNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Unlock(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Unlock (FileNumber As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Unlock(int FileNumber);" />
      <MemberSignature Language="F#" Value="static member Unlock : int -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Unlock FileNumber" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必须的。 任何有效文件数。</param>
        <summary>控制其他进程对使用 <see langword="Open" /> 函数打开的文件的全部或部分的访问。 与 <see langword="My" /> 和 <see langword="Lock" /> 相比，<see langword="Unlock" /> 功能在文件 I/O 操作方面可为您提供更高的效率和更好的性能。 有关详情，请参阅<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Lock`和`Unlock`函数用于环境中的多个进程可能需要访问同一文件。  
  
 `Lock` 和`Unlock`函数始终成对使用。 参数`Lock`和`Unlock`必须相同。  
  
 如果`Record`，或`FromRecord`和`ToRecord`是未提供，该锁将在整个文件。 如果`Record`单独指定单个记录将锁定/解锁。  
  
 如果已打开文件进行连续的输入或输出中，`Lock`并`Unlock`会影响整个文件，而不考虑指定的范围`FromRecord`和`ToRecord`。  
  
   
  
## Examples  
 此示例演示如何使用`Lock`和`Unlock`函数。 此示例假定`People.txt`是包含记录的结构的一个文件`Person`。  
  
 [!code-vb[VbVbalrCatRef#13](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">文件模式无效。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">使用 Visual Basic 访问文件</related>
      </Docs>
    </Member>
    <Member MemberName="Unlock">
      <MemberSignature Language="C#" Value="public static void Unlock (int FileNumber, long Record);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Unlock(int32 FileNumber, int64 Record) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Unlock(System.Int32,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Unlock (FileNumber As Integer, Record As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Unlock(int FileNumber, long Record);" />
      <MemberSignature Language="F#" Value="static member Unlock : int * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Unlock (FileNumber, Record)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Record" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必须的。 任何有效文件数。</param>
        <param name="Record">可选。 唯一要锁定或取消锁定的记录号或字节数</param>
        <summary>控制其他进程对使用 <see langword="Open" /> 函数打开的文件的全部或部分的访问。 与 <see langword="My" /> 和 <see langword="Lock" /> 相比，<see langword="Unlock" /> 功能在文件 I/O 操作方面可为您提供更高的效率和更好的性能。 有关详情，请参阅<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Lock`和`Unlock`函数用于环境中的多个进程可能需要访问同一文件。  
  
 `Lock` 和`Unlock`函数始终成对使用。 参数`Lock`和`Unlock`必须相同。  
  
 如果`Record`，或`FromRecord`和`ToRecord`是未提供，该锁将在整个文件。 如果`Record`单独指定单个记录将锁定/解锁。  
  
 如果已打开文件进行连续的输入或输出中，`Lock`并`Unlock`会影响整个文件，而不考虑指定的范围`FromRecord`和`ToRecord`。  
  
   
  
## Examples  
 此示例演示如何使用`Lock`和`Unlock`函数。 此示例假定`People.txt`是包含记录的结构的一个文件`Person`。  
  
 [!code-vb[VbVbalrCatRef#13](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">文件模式无效。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">使用 Visual Basic 访问文件</related>
      </Docs>
    </Member>
    <Member MemberName="Unlock">
      <MemberSignature Language="C#" Value="public static void Unlock (int FileNumber, long FromRecord, long ToRecord);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Unlock(int32 FileNumber, int64 FromRecord, int64 ToRecord) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Unlock(System.Int32,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Unlock (FileNumber As Integer, FromRecord As Long, ToRecord As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Unlock(int FileNumber, long FromRecord, long ToRecord);" />
      <MemberSignature Language="F#" Value="static member Unlock : int * int64 * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Unlock (FileNumber, FromRecord, ToRecord)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="FromRecord" Type="System.Int64" />
        <Parameter Name="ToRecord" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必须的。 任何有效文件数。</param>
        <param name="FromRecord">可选。 第一个要锁定或取消锁定的记录号或字节数。</param>
        <param name="ToRecord">可选。 最后一个要锁定或取消锁定的记录号或字节数。</param>
        <summary>控制其他进程对使用 <see langword="Open" /> 函数打开的文件的全部或部分的访问。 与 <see langword="My" /> 和 <see langword="Lock" /> 相比，<see langword="Unlock" /> 功能在文件 I/O 操作方面可为您提供更高的效率和更好的性能。 有关详情，请参阅<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Lock`和`Unlock`函数用于环境中的多个进程可能需要访问同一文件。  
  
 `Lock` 和`Unlock`函数始终成对使用。 参数`Lock`和`Unlock`必须相同。  
  
 如果`Record`，或`FromRecord`和`ToRecord`是未提供，该锁将在整个文件。 如果`Record`单独指定单个记录将锁定/解锁。  
  
 如果已打开文件进行连续的输入或输出中，`Lock`并`Unlock`会影响整个文件，而不考虑指定的范围`FromRecord`和`ToRecord`。  
  
   
  
## Examples  
 此示例演示如何使用`Lock`和`Unlock`函数。 此示例假定`People.txt`是包含记录的结构的一个文件`Person`。  
  
 [!code-vb[VbVbalrCatRef#13](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">文件模式无效。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">使用 Visual Basic 访问文件</related>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public static void Write (int FileNumber, params object[] Output);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Write(int32 FileNumber, object[] Output) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub Write (FileNumber As Integer, ParamArray Output As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Write(int FileNumber, ... cli::array &lt;System::Object ^&gt; ^ Output);" />
      <MemberSignature Language="F#" Value="static member Write : int * obj[] -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Write (FileNumber, Output)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Output" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="FileNumber">必须的。 包含任何有效文件数的 <see langword="Integer" /> 表达式。</param>
        <param name="Output">可选。 要写入文件的一个或多个由逗号分隔的表达式。</param>
        <summary>将数据写入一个顺序文件。 通常使用 <see langword="Input" /> 从文件中读取使用 <see langword="Write" /> 编写的数据。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Write`和`WriteLine`函数是为了向后兼容性，可能会影响性能。 对于非旧版应用程序，`My.Computer.FileSystem`对象提供更好的性能。 有关详细信息，请参阅[使用 Visual Basic 访问文件](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)。  
  
 如果省略`Output`，向文件打印一个空行。 可以用逗号分隔多个表达式。  
  
 与不同`Print`函数，`Write`函数之间插入逗号项和引号将字符串写入该文件。 无需显式分隔符放入列表。 当`Write`用于将数据写入到文件中，仅数字`Boolean`，日期、 null 和`Error`支持数据格式。 下面的通用假设遵循这样的数据始终能够阅读和正确解释使用`Input`，无论区域设置：  
  
-   使用句点作为小数分隔符始终写入数值数据。  
  
-   有关`Boolean`数据，而是`#TRUE#`或`#FALSE#`打印。 `True`和`False`不转换关键字，而不考虑区域设置。  
  
-   日期数据写入到使用通用日期格式的文件。 当日期或时间部分缺失或为零时，仅提供部分写入文件。  
  
-   执行任何操作写入到文件，如果`Output`数据为空。 但是，对于 null 数据`#NULL#`写入。  
  
-   有关`Error`数据，输出将显示为`#ERROR errorcode#`。 `Error`不转换关键字，而不考虑区域设置。  
  
 `WriteLine` 将插入一个换行符 (即回车符/换行符，或`Chr(13) + Chr(10)`)，在其写入的最后一个字符后`Output`的文件。  
  
 您可以通过使用双引号引起来，在字符串中嵌入引号或""。 例如，应用于对象的  
  
 [!code-vb[VbVbalrCatRef#63](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#63)]  
  
 返回一个字符串值为`Double quotation marks aren't "difficult" to handle`。  
  
 通过使用对文件进行写入`Write`或`WriteLine`函数要求`Append`从访问`FileIOPermissionAccess`枚举。 有关更多信息，请参见<xref:System.Security.Permissions.FileIOPermissionAccess>。  
  
   
  
## Examples  
 此示例使用`Write`函数将原始数据写入顺序文件。  
  
 [!code-vb[VbVbalrCatRef#64](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#64)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">文件模式无效。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Input" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">使用 Visual Basic 访问文件</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md">如何：在 Visual Basic 中向文件内写入文本</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md">如何： 使用 Streamwriter (Visual Basic 中) 的文件中写入文本</related>
      </Docs>
    </Member>
    <Member MemberName="WriteLine">
      <MemberSignature Language="C#" Value="public static void WriteLine (int FileNumber, params object[] Output);" />
      <MemberSignature Language="ILAsm" Value=".method public static void WriteLine(int32 FileNumber, object[] Output) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteLine (FileNumber As Integer, ParamArray Output As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteLine(int FileNumber, ... cli::array &lt;System::Object ^&gt; ^ Output);" />
      <MemberSignature Language="F#" Value="static member WriteLine : int * obj[] -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.WriteLine (FileNumber, Output)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Output" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="FileNumber">必须的。 包含任何有效文件数的 <see langword="Integer" /> 表达式。</param>
        <param name="Output">可选。 要写入文件的一个或多个由逗号分隔的表达式。</param>
        <summary>将数据写入一个顺序文件。 通常使用 <see langword="Input" /> 从文件中读取使用 <see langword="Write" /> 编写的数据。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Write`和`WriteLine`函数是为了向后兼容性，可能会影响性能。 对于非旧版应用程序，`My.Computer.FileSystem`对象提供更好的性能。 有关详细信息，请参阅[使用 Visual Basic 访问文件](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)。  
  
 如果省略`Output`，向文件打印一个空行。 可以用逗号分隔多个表达式。  
  
 与不同`Print`函数，`Write`函数之间插入逗号项和引号将字符串写入该文件。 无需显式分隔符放入列表。 当`Write`用于将数据写入到文件中，仅数字`Boolean`，日期、 null 和`Error`支持数据格式。 下面的通用假设遵循这样的数据始终能够阅读和正确解释使用`Input`，无论区域设置：  
  
-   使用句点作为小数分隔符始终写入数值数据。  
  
-   有关`Boolean`数据，而是`#TRUE#`或`#FALSE#`打印。 `True`和`False`不转换关键字，而不考虑区域设置。  
  
-   日期数据写入到使用通用日期格式的文件。 当日期或时间部分缺失或为零时，仅提供部分写入文件。  
  
-   执行任何操作写入到文件，如果`Output`数据为空。 但是，对于 null 数据`#NULL#`写入。  
  
-   有关`Error`数据，输出将显示为`#ERROR errorcode#`。 `Error`不转换关键字，而不考虑区域设置。  
  
 `WriteLine` 将插入一个换行符 (即回车符/换行符，或`Chr(13) + Chr(10)`)，在其写入的最后一个字符后`Output`的文件。  
  
 您可以通过使用双引号引起来，在字符串中嵌入引号或""。 例如，应用于对象的  
  
 [!code-vb[VbVbalrCatRef#63](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#63)]  
  
 返回一个字符串值为`Double quotation marks aren't "difficult" to handle`。  
  
 通过使用对文件进行写入`Write`或`WriteLine`函数要求`Append`从访问`FileIOPermissionAccess`枚举。 有关更多信息，请参见<xref:System.Security.Permissions.FileIOPermissionAccess>。  
  
   
  
## Examples  
 此示例使用`Write`函数将原始数据写入顺序文件。  
  
 [!code-vb[VbVbalrCatRef#64](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#64)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Input" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">使用 Visual Basic 访问文件</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md">如何：在 Visual Basic 中向文件内写入文本</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md">如何： 使用 Streamwriter (Visual Basic 中) 的文件中写入文本</related>
      </Docs>
    </Member>
  </Members>
</Type>
