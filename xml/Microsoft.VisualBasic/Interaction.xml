<Type Name="Interaction" FullName="Microsoft.VisualBasic.Interaction">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="5965814ba1ce87a255e10aeaa0689438d39d9820" />
    <Meta Name="ms.sourcegitcommit" Value="16d2d159872fd213cae4b8f371d7ae9c8b027c89" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-CN" />
    <Meta Name="ms.lasthandoff" Value="11/17/2018" />
    <Meta Name="ms.locfileid" Value="51935724" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class Interaction" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit Interaction extends System.Object" />
  <TypeSignature Language="DocId" Value="T:Microsoft.VisualBasic.Interaction" />
  <TypeSignature Language="VB.NET" Value="Public Module Interaction" />
  <TypeSignature Language="C++ CLI" Value="public ref class Interaction sealed" />
  <TypeSignature Language="F#" Value="type Interaction = class" />
  <AssemblyInfo>
    <AssemblyName>Microsoft.VisualBasic</AssemblyName>
    <AssemblyVersion>7.0.5000.0</AssemblyVersion>
    <AssemblyVersion>8.0.0.0</AssemblyVersion>
    <AssemblyVersion>10.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>Microsoft.VisualBasic.CompilerServices.StandardModule</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>
      <see langword="Interaction" /> 模块包含用于与对象、应用程序和系统交互的过程。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此模块支持的 Visual Basic 语言关键字和运行时库成员，运行其他程序，调用方法或属性，从计算机发出提示音，提供的命令行字符串、 操作 COM 对象，并控制对话框。  
  
   
  
## Examples  
 下面的示例使用`Shell`函数运行用户指定的应用程序。 指定<xref:Microsoft.VisualBasic.AppWinStyle.NormalFocus?displayProperty=nameWithType>为第二个参数将应用程序打开在正常大小，使其具有焦点。  
  
```vb  
Dim procID As Integer  
' Run calculator.  
procID = Shell("C:\Windows\system32\calc.exe", AppWinStyle.NormalFocus)  
' The preceding path is for Windows XP.  
' The Windows 2000 path is C:\WINNT\system32\calc.exe.  
```  
  
 ]]></format>
    </remarks>
    <related type="Article" href="~/docs/visual-basic/language-reference/keywords/information-and-interaction-summary.md">信息和交互摘要</related>
    <related type="Article" href="~/docs/visual-basic/language-reference/keywords/index.md">关键字 (Visual Basic)</related>
    <related type="Article" href="~/docs/visual-basic/language-reference/runtime-library-members.md">Visual Basic 运行时库成员</related>
  </Docs>
  <Members>
    <MemberGroup MemberName="AppActivate">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>激活已经正在运行的应用程序。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AppActivate">
      <MemberSignature Language="C#" Value="public static void AppActivate (int ProcessId);" />
      <MemberSignature Language="ILAsm" Value=".method public static void AppActivate(int32 ProcessId) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Interaction.AppActivate(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AppActivate (ProcessId As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void AppActivate(int ProcessId);" />
      <MemberSignature Language="F#" Value="static member AppActivate : int -&gt; unit" Usage="Microsoft.VisualBasic.Interaction.AppActivate ProcessId" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ProcessId" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ProcessId">
          <see langword="Integer" />，指定分配给该进程的 Win32 进程 ID 号。 可以使用 <see cref="M:Microsoft.VisualBasic.Interaction.Shell(System.String,Microsoft.VisualBasic.AppWinStyle,System.Boolean,System.Int32)" /> 返回的 ID，前提是该 ID 不为零。</param>
        <summary>激活已经正在运行的应用程序。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 您使用`AppActivate`使应用程序的活动窗口成为焦点。 不可能有一个句柄或向活动窗口的引用，或甚至知道哪个窗口在给定时刻处于活动状态。 在这种情况下，不能使用<xref:System.Windows.Forms.Control.Focus%2A>方法。  
  
 `AppActivate`函数，将焦点更改到的命名应用程序或窗口，但不会影响是否是最大化或最小化。 当用户执行某些操作来更改焦点或关闭窗口时，焦点将移走激活的应用程序窗口。 可以使用`Shell`函数以启动应用程序并设置窗口样式。  
  
 如果您使用`Title`参数，`AppActivate`使用不区分大小写的比较，但要求的标题栏内容完全匹配。 它首先会查找顶级窗口，然后通过子窗口。 如果它找不到匹配项，则会引发<xref:System.ArgumentException>。  
  
 可以使用`AppActivate`仅与拥有 windows 的过程。 大多数的控制台应用程序是否拥有的 windows，这意味着，它们不会在列表中会显示处理`AppActivate`搜索。 从一个控制台应用程序运行时，系统将创建单独的进程来运行应用程序，并将输出返回到控制台进程。 因此，当你请求的当前进程 ID，你获得此单独的进程的进程 ID 而不是控制台应用程序的进程 id。  
  
 在运行时，`AppActivate`函数会激活任何运行的应用程序具有与匹配标题`Title`或具有匹配的进程 ID `ProcessId`。 如果没有完全匹配项，则会激活其标题字符串结尾的任何应用程序`Title`。 如果没有名为多个应用程序`Title`，则`AppActivate`函数随机选择一个用于激活。  
  
> [!NOTE]
>  `AppActivate`函数需要`UIPermission`在<xref:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows>级别，可能会影响在部分信任情况下执行。 有关更多信息，请参见<xref:System.Security.Permissions.UIPermission>。  
  
   
  
## Examples  
 此示例演示了的各种用法`AppActivate`函数以激活应用程序窗口。 如果未运行 Notepad 进程，则本示例引发<xref:System.ArgumentException>。 `Shell`过程假设应用程序中指定的路径。  
  
 [!code-vb[VbVbalrCatRef#11](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#11)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.Interaction.Shell(System.String,Microsoft.VisualBasic.AppWinStyle,System.Boolean,System.Int32)" />
        <altmember cref="M:System.Windows.Forms.Control.Focus" />
        <altmember cref="T:System.ArgumentException" />
      </Docs>
    </Member>
    <Member MemberName="AppActivate">
      <MemberSignature Language="C#" Value="public static void AppActivate (string Title);" />
      <MemberSignature Language="ILAsm" Value=".method public static void AppActivate(string Title) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Interaction.AppActivate(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AppActivate (Title As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void AppActivate(System::String ^ Title);" />
      <MemberSignature Language="F#" Value="static member AppActivate : string -&gt; unit" Usage="Microsoft.VisualBasic.Interaction.AppActivate Title" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Title" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="Title">
          <see langword="String" /> 表达式，用于指定要激活的应用程序的标题栏中的标题。 可以使用启动应用程序后分配给该应用程序的标题。</param>
        <summary>激活已经正在运行的应用程序。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 您使用`AppActivate`使应用程序的活动窗口成为焦点。 不可能有一个句柄或向活动窗口的引用，或甚至知道哪个窗口在给定时刻处于活动状态。 在这种情况下，不能使用<xref:System.Windows.Forms.Control.Focus%2A>方法。  
  
 `AppActivate`函数，将焦点更改到的命名应用程序或窗口，但不会影响是否是最大化或最小化。 当用户执行某些操作来更改焦点或关闭窗口时，焦点将移走激活的应用程序窗口。 可以使用`Shell`函数以启动应用程序并设置窗口样式。  
  
 如果您使用`Title`参数，`AppActivate`使用不区分大小写的比较，但要求的标题栏内容完全匹配。 它首先会查找顶级窗口，然后通过子窗口。 如果它找不到匹配项，则会引发<xref:System.ArgumentException>。  
  
 可以使用`AppActivate`仅与拥有 windows 的过程。 大多数的控制台应用程序是否拥有的 windows，这意味着，它们不会在列表中会显示处理`AppActivate`搜索。 从一个控制台应用程序运行时，系统将创建单独的进程来运行应用程序，并将输出返回到控制台进程。 因此，当你请求的当前进程 ID，你获得此单独的进程的进程 ID 而不是控制台应用程序的进程 id。  
  
 在运行时，`AppActivate`函数会激活任何运行的应用程序具有与匹配标题`Title`或具有匹配的进程 ID `ProcessId`。 如果没有完全匹配项，则会激活其标题字符串结尾的任何应用程序`Title`。 如果没有名为多个应用程序`Title`，则`AppActivate`函数随机选择一个用于激活。  
  
> [!NOTE]
>  `AppActivate`函数需要`UIPermission`在<xref:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows>级别，可能会影响在部分信任情况下执行。 有关更多信息，请参见<xref:System.Security.Permissions.UIPermission>。  
  
   
  
## Examples  
 此示例演示了的各种用法`AppActivate`函数以激活应用程序窗口。 如果未运行 Notepad 进程，则本示例引发<xref:System.ArgumentException>。 `Shell`过程假设应用程序中指定的路径。  
  
 [!code-vb[VbVbalrCatRef#11](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#11)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.Interaction.Shell(System.String,Microsoft.VisualBasic.AppWinStyle,System.Boolean,System.Int32)" />
        <altmember cref="M:System.Windows.Forms.Control.Focus" />
        <altmember cref="T:System.ArgumentException" />
      </Docs>
    </Member>
    <Member MemberName="Beep">
      <MemberSignature Language="C#" Value="public static void Beep ();" />
      <MemberSignature Language="ILAsm" Value=".method public static void Beep() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Interaction.Beep" />
      <MemberSignature Language="VB.NET" Value="Public Sub Beep ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Beep();" />
      <MemberSignature Language="F#" Value="static member Beep : unit -&gt; unit" Usage="Microsoft.VisualBasic.Interaction.Beep " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>通过计算机扬声器提示音。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 俯仰和提示音的持续时间取决于硬件和系统软件，因此有所不同的计算机。  
  
> [!NOTE]
>  `Beep`函数需要`UIPermission`在<xref:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows>级别，可能会影响在部分信任情况下执行。 有关详情，请参阅<xref:System.Security.Permissions.UIPermission>。  
  
   
  
## Examples  
 此示例使用 `Beep` 函数通过计算机的扬声器发出音调。  
  
 [!code-vb[VbVbalrCatRef#59](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#59)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/visual-basic/language-reference/runtime-library-members.md">Visual Basic 运行时库成员</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/computer-resources/playing-sounds.md">播放声音</related>
      </Docs>
    </Member>
    <Member MemberName="CallByName">
      <MemberSignature Language="C#" Value="public static object CallByName (object ObjectRef, string ProcName, Microsoft.VisualBasic.CallType UseCallType, params object[] Args);" />
      <MemberSignature Language="ILAsm" Value=".method public static object CallByName(object ObjectRef, string ProcName, valuetype Microsoft.VisualBasic.CallType UseCallType, object[] Args) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Interaction.CallByName(System.Object,System.String,Microsoft.VisualBasic.CallType,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function CallByName (ObjectRef As Object, ProcName As String, UseCallType As CallType, ParamArray Args As Object()) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ CallByName(System::Object ^ ObjectRef, System::String ^ ProcName, Microsoft::VisualBasic::CallType UseCallType, ... cli::array &lt;System::Object ^&gt; ^ Args);" />
      <MemberSignature Language="F#" Value="static member CallByName : obj * string * Microsoft.VisualBasic.CallType * obj[] -&gt; obj" Usage="Microsoft.VisualBasic.Interaction.CallByName (ObjectRef, ProcName, UseCallType, Args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ObjectRef" Type="System.Object" />
        <Parameter Name="ProcName" Type="System.String" />
        <Parameter Name="UseCallType" Type="Microsoft.VisualBasic.CallType" />
        <Parameter Name="Args" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="ObjectRef">必须的。 <see langword="Object" />。 一个指向公开属性或方法的对象的指针。</param>
        <param name="ProcName">必须的。 <see langword="String" />。 一个字符串表达式，包含对象的属性或方法的名称。</param>
        <param name="UseCallType">必须的。 类型 <see cref="T:Microsoft.VisualBasic.CallType" /> 的一个枚举成员，它表示正在被调用的过程的类型。 <see langword="CallType" /> 的值可以是 <see langword="Method" />、<see langword="Get" /> 或 <see langword="Set" />。</param>
        <param name="Args">可选。 <see langword="ParamArray" />。 一个形参数组，包含要传递给正在调用的属性或方法的实参。</param>
        <summary>执行对象的方法，或者设置或返回对象的属性。</summary>
        <returns>执行对象的方法，或者设置或返回对象的属性。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `CallByName`函数用于在运行时获取的属性、 设置属性，或调用方法。  
  
   
  
## Examples  
 在以下示例中，使用第一行`CallByName`若要设置`Text`属性的文本框中，第二行检索的值`Text`属性，并在第三个行调用`Move`方法来移动文本框。  
  
 [!code-vb[VbVbalrFunctions#99](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrFunctions/VB/Class1.vb#99)]  
  
 [!code-vb[VbVbalrFunctions#20](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrFunctions/VB/Class1.vb#20)]  
  
 下面的示例使用`CallByName`函数以调用`Add`和`Item`集合对象的方法。  
  
 [!code-vb[VbVbalrFunctions#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrFunctions/VB/Class1.vb#21)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">无效 <paramref name="UseCallType" /> 值；必须为 <see langword="Method" />、<see langword="Get" /> 或 <see langword="Set" />。</exception>
        <altmember cref="T:Microsoft.VisualBasic.CallType" />
        <altmember cref="T:System.ArgumentException" />
        <related type="Article" href="~/docs/visual-basic/programming-guide/language-features/procedures/parameter-arrays.md">参数数组</related>
        <related type="Article" href="~/docs/visual-basic/programming-guide/language-features/early-late-binding/calling-a-property-or-method-using-a-string-name.md">使用字符串名调用属性或方法</related>
      </Docs>
    </Member>
    <Member MemberName="Choose">
      <MemberSignature Language="C#" Value="public static object Choose (double Index, params object[] Choice);" />
      <MemberSignature Language="ILAsm" Value=".method public static object Choose(float64 Index, object[] Choice) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Interaction.Choose(System.Double,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Choose (Index As Double, ParamArray Choice As Object()) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ Choose(double Index, ... cli::array &lt;System::Object ^&gt; ^ Choice);" />
      <MemberSignature Language="F#" Value="static member Choose : double * obj[] -&gt; obj" Usage="Microsoft.VisualBasic.Interaction.Choose (Index, Choice)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Index" Type="System.Double" />
        <Parameter Name="Choice" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="Index">必须的。 <see langword="Double" />。 数值表达式，它得出的值在 1 和 <c>Choice</c> 参数中传递的元素数目之间。</param>
        <param name="Choice">必须的。 <see langword="Object" /> 参数数组。 可以为以逗号分隔的 <see langword="Object" /> 变量或表达式列表或一维 <see langword="Object" /> 元素数组提供计算为 <see langword="Object" /> 数据类型的单个变量或表达式。</param>
        <summary>从参数列表中选择和返回一个值。</summary>
        <returns>从参数列表中选择和返回一个值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Choose`函数返回列表中传递的成员`Choice()`的值根据`Index`。 选择列表的第一个成员时`Index`为 1。 选择列表的最后一个成员时`Index`是`UBound`(`Choice()`)。 如果`Index`超出这些限制`Choose`返回`Nothing`。  
  
 如果`Index`不是整数，它正在计算之前四舍五入为最接近的整数。  
  
 可以使用`Choose`若要查找的值列表中的可能性。  
  
> [!NOTE]
>  参数列表中的表达式可以包括函数调用。 作为准备为调用的参数列表的一部分`Choose`，Visual Basic 编译器在每个表达式中调用的每个函数。 这意味着您不能依赖于特定情况下选择了不同的表达式时未被调用函数`Index`。  
  
   
  
## Examples  
 此示例使用`Choose`函数来显示名称，以响应传递到过程中的索引`Ind`参数。  
  
 [!code-vb[VbVbalrFunctions#22](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrFunctions/VB/Class1.vb#22)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.Interaction.IIf(System.Boolean,System.Object,System.Object)" />
        <altmember cref="M:Microsoft.VisualBasic.Interaction.Switch(System.Object[])" />
        <related type="Article" href="~/docs/visual-basic/language-reference/statements/select-case-statement.md">Select...Case 语句 (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Command">
      <MemberSignature Language="C#" Value="public static string Command ();" />
      <MemberSignature Language="ILAsm" Value=".method public static string Command() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Interaction.Command" />
      <MemberSignature Language="VB.NET" Value="Public Function Command () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Command();" />
      <MemberSignature Language="F#" Value="static member Command : unit -&gt; string" Usage="Microsoft.VisualBasic.Interaction.Command " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回命令行的参数部分，该命令行用于启动 Visual Basic 或启动使用 Visual Basic 开发的可执行程序。 <see langword="My" /> 功能可以提供比 <see langword="Command" /> 函数更高的效率和更好的性能。 有关详情，请参阅<see cref="P:Microsoft.VisualBasic.ApplicationServices.ConsoleApplicationBase.CommandLineArgs" />。</summary>
        <returns>返回命令行的参数部分，该命令行用于启动 Visual Basic 或启动使用 Visual Basic 开发的可执行程序。  
  
<see langword="My" /> 功能可以提供比 <see langword="Command" /> 函数更高的效率和更好的性能。 有关详情，请参阅<see cref="P:Microsoft.VisualBasic.ApplicationServices.ConsoleApplicationBase.CommandLineArgs" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 返回参数后，您可以搜索常见分隔符，例如空格、 向前或向后斜杠、 连字符或引号中，拆分或搜索每个参数的字符串。  
  
 有关使用 Visual Basic 开发和编译为.exe 文件，应用程序`Command`函数将返回命令行中，在此窗体上的应用程序的名称后显示的任何自变量： `MyApp(cmdlineargs)`。  
  
   
  
## Examples  
 此示例使用`Command`函数返回包含数组的对象的命令行参数。  
  
 [!code-vb[VbVbalrCatRef#58](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#58)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Environment.GetCommandLineArgs" />
        <altmember cref="P:Microsoft.VisualBasic.ApplicationServices.ConsoleApplicationBase.CommandLineArgs" />
        <related type="Article" href="~/docs/visual-basic/language-reference/runtime-library-members.md">Visual Basic 运行时库成员</related>
        <related type="Article" href="~/docs/visual-basic/reference/command-line-compiler/index.md">Visual Basic 命令行编译器</related>
        <related type="Article" href="~/docs/visual-basic/programming-guide/program-structure/structure-of-a-visual-basic-program.md">Visual Basic 程序的结构</related>
      </Docs>
    </Member>
    <Member MemberName="CreateObject">
      <MemberSignature Language="C#" Value="public static object CreateObject (string ProgId, string ServerName = &quot;&quot;);" />
      <MemberSignature Language="ILAsm" Value=".method public static object CreateObject(string ProgId, string ServerName) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Interaction.CreateObject(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateObject (ProgId As String, Optional ServerName As String = &quot;&quot;) As Object" />
      <MemberSignature Language="F#" Value="static member CreateObject : string * string -&gt; obj" Usage="Microsoft.VisualBasic.Interaction.CreateObject (ProgId, ServerName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ProgId" Type="System.String" />
        <Parameter Name="ServerName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="ProgId">必须的。 <see langword="String" />。 要创建的对象的程序 ID。</param>
        <param name="ServerName">可选。 <see langword="String" />。 要在其上创建对象的网络服务器的名称。 如果 <c>ServerName</c> 是空字符串 ("")，则使用本地计算机。</param>
        <summary>创建并返回对 COM 对象的引用。 不能在 Visual Basic 中使用 <see langword="CreateObject" /> 创建这些类的实例，除非将类显式公开为 COM 组件。</summary>
        <returns>创建并返回对 COM 对象的引用。 不能在 Visual Basic 中使用 <see langword="CreateObject" /> 创建这些类的实例，除非将类显式公开为 COM 组件。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要创建 COM 组件的实例，请将返回的对象分配`CreateObject`给对象变量：  
  
```vb  
Sub CreateADODB()  
   Dim adoApp As Object  
   adoApp = CreateObject("ADODB.Connection")  
End Sub  
```  
  
 用于存储返回的对象的对象变量的类型可能会影响应用程序的性能。 声明对象变量与`As Object`子句创建的变量可以包含对任何类型的对象的引用。 但是，对通过该变量的对象的访问是*后期绑定*，绑定，即发生在程序运行。 有很多原因应避免后期绑定，包括应用程序性能下降。  
  
 你可以创建生成早期绑定对象变量，即，绑定时将编译该程序。 为此，请添加对该对象的类型库的引用**COM**选项卡**添加引用**上的对话框**项目**菜单。 然后，声明您的对象的特定类型的对象变量。 在大多数情况下，它是使用更加高效`Dim`语句和主互操作程序集，以创建对象，它是使用比`CreateObject`函数。  
  
## <a name="interacting-with-unmanaged-code"></a>与非托管代码进行交互  
 另一个问题是 COM 对象使用非托管的代码，代码而无需公共语言运行时的优势。 没有了一定程度的复杂性涉及混合与非托管代码的托管的代码的 Visual Basic 从 com。 当添加对 COM 对象的引用时，Visual Basic 中搜索的主互操作程序集 (PIA) 的库;如果找到，则它使用它。 如果找不到 PIA，然后创建包含本地互操作性类为每个类的 COM 库中的互操作性程序集。 有关详细信息，请参阅[.NET Framework 应用程序中的 COM 互操作性](~/docs/visual-basic/programming-guide/com-interop/com-interoperability-in-net-framework-applications.md)。  
  
 通常应使用强绑定的对象和尽可能的主互操作程序集。 使用下面的示例`CreateObject`函数中演示的 Microsoft Office 对象仅目的。 但是，这些对象是易于使用且更可靠，与相应的主互操作程序集一起使用时。  
  
## <a name="creating-an-object-on-a-remote-computer"></a>在远程计算机上创建的对象  
 通过将传递到计算机的名称，可以在一台联网的远程计算机上创建对象`ServerName`自变量的`CreateObject`函数。 该名称是共享名的计算机名称部分相同： 共享名为"\\\MyServer\Public，"`ServerName`是"MyServer"。  
  
> [!NOTE]
>  请参阅 COM 文档 （请参阅 Microsoft Developer Network） 上对应用程序的可访问远程网络计算机上的其他信息。 您可能需要添加一个用于您的应用程序注册表项。  
  
 以下代码将返回一个 Excel 的实例的版本号在名为的远程计算机上运行`MyServer`:  
  
```vb  
Sub CreateRemoteExcelObj()  
    Dim xlApp As Object  
    ' Replace string "\\MyServer" with name of the remote computer.  
    xlApp = CreateObject("Excel.Application", "\\MyServer")  
    MsgBox(xlApp.Version)  
End Sub  
```  
  
 如果远程服务器名称不正确，或如果它不可用，会发生运行时错误。  
  
> [!NOTE]
>  使用`CreateObject`时没有对象的当前实例。 如果尚未运行对象的实例，启动的新实例，并创建指定类型的对象。 若要使用的当前实例，或启动应用程序并将其加载的文件，请使用`GetObject`函数。 如果对象已将自己注册为单实例对象，该对象的一个实例后，无论很多时候`CreateObject`执行。  
  
## <a name="creating-framework-objects"></a>创建框架对象  
 可以使用`CreateObject`函数只能用于创建 COM 对象。 虽然没有完全等效机制用于创建.NET Framework 对象，但<xref:System.Activator>在<xref:System>命名空间包含用于创建本地或远程对象的方法。 具体而言，<xref:System.Activator.CreateInstance%2A>方法或<xref:System.Activator.CreateInstanceFrom%2A>方法可能会很有用。  
  
> [!IMPORTANT]
>  `CreateObject`函数需要非托管的代码的权限，这可能会影响在部分信任情况下执行。 有关详细信息，请参阅<xref:System.Security.Permissions.SecurityPermission>并[代码访问权限](https://msdn.microsoft.com/library/e5ae402f-6dda-4732-bbe8-77296630f675)。  
  
   
  
## Examples  
 下面的示例使用`CreateObject`函数创建一个 Microsoft Excel 工作表，并将工作表保存到文件。 若要使用此示例中，必须在运行此程序的计算机上安装 Excel。 此外，必须添加对从类型库的引用**COM**选项卡**添加引用**上的对话框**项目**菜单。 类型库的名称各不相同，具体取决于您的计算机上安装的 Excel 的版本。 例如，名为的类型库的 Microsoft Excel 2002 **Microsoft Excel 10.0 对象库**。  
  
 [!code-vb[VbVbalrExcelObject#1](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrExcelObject/VB/Class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Exception">服务器不可用。</exception>
        <exception cref="T:System.IO.FileNotFoundException">不存在指定类型的对象。</exception>
        <altmember cref="M:Microsoft.VisualBasic.Interaction.GetObject(System.String,System.String)" />
        <altmember cref="T:System.Exception" />
        <altmember cref="T:System.IO.FileNotFoundException" />
        <altmember cref="T:System.Activator" />
        <altmember cref="Overload:System.Activator.CreateInstance" />
        <altmember cref="Overload:System.Activator.CreateInstanceFrom" />
        <related type="Article" href="~/docs/visual-basic/language-reference/statements/dim-statement.md">Dim 语句 (Visual Basic)</related>
        <related type="Article" href="~/docs/visual-basic/language-reference/statements/declare-statement.md">Declare Statement</related>
        <related type="Article" href="~/docs/visual-basic/programming-guide/com-interop/com-interoperability-in-net-framework-applications.md">.NET Framework 应用程序中的 COM 互操作性</related>
        <related type="Article" href="~/docs/framework/interop/index.md">与非托管代码交互操作</related>
      </Docs>
    </Member>
    <Member MemberName="DeleteSetting">
      <MemberSignature Language="C#" Value="public static void DeleteSetting (string AppName, string Section = null, string Key = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static void DeleteSetting(string AppName, string Section, string Key) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Interaction.DeleteSetting(System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub DeleteSetting (AppName As String, Optional Section As String = null, Optional Key As String = null)" />
      <MemberSignature Language="F#" Value="static member DeleteSetting : string * string * string -&gt; unit" Usage="Microsoft.VisualBasic.Interaction.DeleteSetting (AppName, Section, Key)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="AppName" Type="System.String" />
        <Parameter Name="Section" Type="System.String" />
        <Parameter Name="Key" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="AppName">必须的。 <see langword="String" /> 表达式，包含应用节或项设置的应用程序或项目的名称。</param>
        <param name="Section">必须的。 <see langword="String" /> 表达式，包含要从中删除项设置的节的名称。 如果仅提供了 <c>AppName</c> 和 <c>Section</c>，则将删除指定的节以及所有相关的项设置。</param>
        <param name="Key">可选。 <see langword="String" /> 表达式，包含要删除的项设置的名称。</param>
        <summary>从 Windows 注册表中某个应用程序的项中删除一个节或一个项设置。 与 <see langword="DeleteSetting" /> 函数相比，<see langword="My" /> 功能在注册表操作方面可为你提供更高的效率和更好的性能。 有关更多信息，请参见<see cref="P:Microsoft.VisualBasic.Devices.ServerComputer.Registry" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果未提供所有参数，则删除指定的设置。 如果您尝试使用会发生运行时错误`DeleteSetting`上不存在节或键设置。  
  
 `DeleteSetting` 要求用户登录上将在操作由于`HKEY_LOCAL_USER`注册表项，直到用户以交互方式登录未处于活动状态。  
  
 若要从非交互式进程 （如 Mtx.exe) 访问的注册表设置应存储在`HKEY_LOCAL_MACHINE\Software\`或`HKEY_USER\DEFAULT\Software`注册表项。  
  
   
  
## Examples  
 下面的示例首先使用`SaveSetting`过程来在 Windows 注册表中生成条目`MyApp`应用程序，然后使用`DeleteSetting`函数将其删除。 因为没有`Key`指定参数，则整个`Startup`则将删除节，其中包括节名称和所有其密钥。  
  
 [!code-vb[VbVbalrCatRef#45](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#45)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">用户没有登录。</exception>
        <altmember cref="M:Microsoft.VisualBasic.Interaction.GetAllSettings(System.String,System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.Interaction.GetSetting(System.String,System.String,System.String,System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.Interaction.SaveSetting(System.String,System.String,System.String,System.String)" />
        <altmember cref="T:System.ArgumentException" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Environ">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>返回与操作系统环境变量关联的字符串。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Environ">
      <MemberSignature Language="C#" Value="public static string Environ (int Expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static string Environ(int32 Expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Interaction.Environ(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Environ (Expression As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Environ(int Expression);" />
      <MemberSignature Language="F#" Value="static member Environ : int -&gt; string" Usage="Microsoft.VisualBasic.Interaction.Environ Expression" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Expression" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="Expression">必须的。 此表达式用于计算包含环境变量名称的字符串，或对应于环境字符串表中环境字符串的数字顺序的整数。</param>
        <summary>返回与操作系统环境变量关联的字符串。</summary>
        <returns>返回与操作系统环境变量关联的字符串。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果`Expression`包含一个字符串，<xref:Microsoft.VisualBasic.Interaction.Environ%2A>函数将返回分配给指定的环境字符串的文本-即，后面等号 （=） 为该环境变量的环境字符串表中的文本。 如果在字符串`Expression`无法找到在环境字符串表中，一个零长度字符串 ("") 返回。  
  
 如果`Expression`包含一个整数，占用的环境字符串表中的数字位置返回的字符串。 在这种情况下，<xref:Microsoft.VisualBasic.Interaction.Environ%2A>返回所有文本，包括环境变量的名称。 如果在指定位置中没有任何环境字符串<xref:Microsoft.VisualBasic.Interaction.Environ%2A>返回长度为零的字符串。  
  
> [!IMPORTANT]
>  <xref:Microsoft.VisualBasic.Interaction.Environ%2A>函数需要环境的权限，这可能会影响在部分信任情况下执行。 有关详细信息，请参阅<xref:System.Security.Permissions.SecurityPermission>并[代码访问权限](https://msdn.microsoft.com/library/e5ae402f-6dda-4732-bbe8-77296630f675)。  
  
   
  
## Examples  
 此示例使用<xref:Microsoft.VisualBasic.Interaction.Environ%2A>函数提供入口数目和长度的`PATH`环境字符串表中的语句。  
  
 [!code-vb[VbVbalrCatRef#28](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#28)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">缺少 <paramref name="Expression" />。</exception>
        <altmember cref="T:System.ArgumentException" />
        <related type="Article" href="~/docs/visual-basic/language-reference/runtime-library-members.md">Visual Basic 运行时库成员</related>
      </Docs>
    </Member>
    <Member MemberName="Environ">
      <MemberSignature Language="C#" Value="public static string Environ (string Expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static string Environ(string Expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Interaction.Environ(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Environ (Expression As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Environ(System::String ^ Expression);" />
      <MemberSignature Language="F#" Value="static member Environ : string -&gt; string" Usage="Microsoft.VisualBasic.Interaction.Environ Expression" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Expression" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="Expression">必须的。 此表达式用于计算包含环境变量名称的字符串，或对应于环境字符串表中环境字符串的数字顺序的整数。</param>
        <summary>返回与操作系统环境变量关联的字符串。</summary>
        <returns>返回与操作系统环境变量关联的字符串。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果`Expression`包含一个字符串，<xref:Microsoft.VisualBasic.Interaction.Environ%2A>函数将返回分配给指定的环境字符串的文本-即，后面等号 （=） 为该环境变量的环境字符串表中的文本。 如果在字符串`Expression`无法找到在环境字符串表中，一个零长度字符串 ("") 返回。  
  
 如果`Expression`包含一个整数，占用的环境字符串表中的数字位置返回的字符串。 在这种情况下，<xref:Microsoft.VisualBasic.Interaction.Environ%2A>返回所有文本，包括环境变量的名称。 如果在指定位置中没有任何环境字符串<xref:Microsoft.VisualBasic.Interaction.Environ%2A>返回长度为零的字符串。  
  
> [!IMPORTANT]
>  <xref:Microsoft.VisualBasic.Interaction.Environ%2A>函数需要环境的权限，这可能会影响在部分信任情况下执行。 有关详细信息，请参阅<xref:System.Security.Permissions.SecurityPermission>并[代码访问权限](https://msdn.microsoft.com/library/e5ae402f-6dda-4732-bbe8-77296630f675)。  
  
   
  
## Examples  
 此示例使用<xref:Microsoft.VisualBasic.Interaction.Environ%2A>函数提供入口数目和长度的`PATH`环境字符串表中的语句。  
  
 [!code-vb[VbVbalrCatRef#28](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#28)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">缺少 <paramref name="Expression" />。</exception>
        <altmember cref="T:System.ArgumentException" />
        <related type="Article" href="~/docs/visual-basic/language-reference/runtime-library-members.md">Visual Basic 运行时库成员</related>
      </Docs>
    </Member>
    <Member MemberName="GetAllSettings">
      <MemberSignature Language="C#" Value="public static string[,] GetAllSettings (string AppName, string Section);" />
      <MemberSignature Language="ILAsm" Value=".method public static string[,] GetAllSettings(string AppName, string Section) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Interaction.GetAllSettings(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAllSettings (AppName As String, Section As String) As String(,)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^, 2&gt; ^ GetAllSettings(System::String ^ AppName, System::String ^ Section);" />
      <MemberSignature Language="F#" Value="static member GetAllSettings : string * string -&gt; string[,]" Usage="Microsoft.VisualBasic.Interaction.GetAllSettings (AppName, Section)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[,]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="AppName" Type="System.String" />
        <Parameter Name="Section" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="AppName">必须的。 <see langword="String" /> 表达式，包含请求其项设置的应用程序或项目的名称。</param>
        <param name="Section">必须的。 一个 <see langword="String" /> 表达式，其中包含请求其关键设置的节的名称。 <see langword="GetAllSettings" /> 返回一个包含二维字符串数组的对象。 这些字符串包含指定节中的所有项设置及其相应的值。</param>
        <summary>从 Windows 注册表中某个应用程序的项返回项设置及其各自的值（最初通过 <see langword="SaveSetting" /> 创建）的列表。 与 <see langword="My" /> 相比，<see langword="GetAllSettings" /> 功能在注册表操作方面可为您提供更高的效率和更好的性能。 有关详情，请参阅<see cref="P:Microsoft.VisualBasic.Devices.ServerComputer.Registry" />。</summary>
        <returns>从 Windows 注册表中某个应用程序的项返回项设置及其各自的值（最初通过 <see langword="SaveSetting" /> 创建）的列表。  
  
与 <see langword="My" /> 相比，<see langword="GetAllSettings" /> 功能在注册表操作方面可为您提供更高的效率和更好的性能。 有关详情，请参阅<see cref="P:Microsoft.VisualBasic.Devices.ServerComputer.Registry" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `GetAllSettings` 返回未初始化`Object`如果任一`AppName`或`Section`不存在。  
  
 因为它将在操作`HKEY_LOCAL_USER`注册表项，该项未处于活动状态直至用户以交互方式登录，`GetAllSettings`要求用户进行登录。  
  
 若要从非交互式进程 （如 Mtx.exe) 访问的注册表设置应存储在`HKEY_LOCAL_MACHINE\Software\`或`HKEY_USER\DEFAULT\Software`注册表项。  
  
   
  
## Examples  
 此示例首先使用`SaveSetting`函数来为指定的应用程序在 Windows 注册表中生成条目`AppName`，然后使用`GetAllSettings`函数以显示的设置。 请注意该应用程序名称和`Section`名称不能使用检索`GetAllSettings`。 最后，`DeleteSetting`函数会删除应用程序的条目。  
  
 [!code-vb[VbVbalrCatRef#68](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#68)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">用户没有登录。</exception>
        <altmember cref="M:Microsoft.VisualBasic.Interaction.DeleteSetting(System.String,System.String,System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.Interaction.GetSetting(System.String,System.String,System.String,System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.Interaction.SaveSetting(System.String,System.String,System.String,System.String)" />
        <altmember cref="T:System.ArgumentException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/computer-resources/reading-from-and-writing-to-the-registry.md">读取和写入注册表 (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="GetObject">
      <MemberSignature Language="C#" Value="public static object GetObject (string PathName = null, string Class = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static object GetObject(string PathName, string Class) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Interaction.GetObject(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetObject (Optional PathName As String = null, Optional Class As String = null) As Object" />
      <MemberSignature Language="F#" Value="static member GetObject : string * string -&gt; obj" Usage="Microsoft.VisualBasic.Interaction.GetObject (PathName, Class)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="PathName" Type="System.String" />
        <Parameter Name="Class" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="PathName">可选。 <see langword="String" />。 包含要检索的对象的文件的完整路径和名称。 如果省略 <c>PathName</c>，则必须有 <c>Class</c>。</param>
        <param name="Class">如果未提供 <c>PathName</c>，则为必需项。 <see langword="String" />。 表示对象的类的字符串。 <c>Class</c> 参数具有以下语法和部分： 
 <c>appname</c><c>.</c><c>objecttype</c>  
  
[1|1] 参数 
[1|2]“描述” 
[2|1] <c>appname</c>  
  
[2|2]“所需的”。 <see langword="String" />。 提供对象的应用程序的名称。  
  
[3|1] <c>objecttype</c>  
  
[3|2]“所需的”。 <see langword="String" />。 要创建的对象的类型或类。</param>
        <summary>返回对 COM 组件提供的对象的引用。</summary>
        <returns>返回对 COM 组件提供的对象的引用。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用`GetObject`函数以从文件加载到 COM 组件的实例。 下面的示例阐释了这一点。  
  
```vb  
Dim CADObject As Object  
CADObject = GetObject("C:\CAD\schema.cad")  
```  
  
 当此代码运行时，指定关联的应用程序`PathName`启动和激活指定的文件中的对象。  
  
## <a name="default-cases"></a>默认情况下  
 如果`PathName`是一个零长度字符串 (`""`)，`GetObject`返回指定的类类型的新对象实例。 如果`PathName`省略参数，则`GetObject`返回当前处于活动状态中指定的类类型的对象`Class`。 如果不存在的对象的指定类型，就会出错。  
  
## <a name="accessing-a-subobject"></a>访问子对象  
 某些应用程序允许您激活与文件关联的子对象。 若要执行此操作，将添加一个感叹号 (`!`) 到末尾的文件的名称并遵循其标识文件的一部分的字符串与你想要激活。 有关如何创建此字符串的信息，请参阅创建对象的应用程序的文档。  
  
 例如，一个绘图应用程序中可能具有多个层在文件中存储的图形。 可以使用以下代码以激活调用`schema.cad`。  
  
```vb  
layerObject = GetObject("C:\CAD\schema.cad!Layer3")  
```  
  
## <a name="specifying-a-class"></a>指定某个类  
 如果未指定对象的`Class`，自动化确定启动和对象的应用程序，若要激活，基于所提供的文件名称。 但是，一些文件，可以支持多个对象的类。 例如，绘图可能支持三种不同类型的对象：`Application`对象，`Drawing`对象，和一个`Toolbar`对象，所有这些都是相同的文件的一部分。 若要指定想要激活的对象文件中，使用可选`Class`参数。 下面的示例阐释了这一点。  
  
```vb  
Dim drawObj As Object  
drawObj = GetObject("C:\Drawings\sample.drw", "Figment.Drawing")  
```  
  
 在前面的示例中，`Figment`是一个绘图应用程序的名称和`Drawing`是它支持的对象类型之一。  
  
## <a name="using-the-object"></a>使用对象  
 一旦激活一个对象，则引用它在代码中使用对象变量声明。 在前面的示例中，您可以访问使用对象变量的新对象的属性和方法`drawObj`。 下面的示例阐释了这一点。  
  
```vb  
drawObj.Line(9, 90)  
drawObj.InsertText(9, 100, "Hello, world.")  
drawObj.SaveAs("C:\Drawings\sample.drw")  
```  
  
> [!NOTE]
>  使用`GetObject`函数对象的当前实例时，或者如果你想要使用已加载的文件创建对象。 如果没有当前实例，并且您不希望开始使用的对象加载的文件，请使用<xref:Microsoft.VisualBasic.Interaction.CreateObject%2A>函数。  
>   
>  如果对象已将自己注册为 ActiveX 单实例对象，该对象的一个实例后，无论很多时候`CreateObject`调用。 与单实例对象，`GetObject`始终返回同一实例时使用长度为零的字符串调用 (`""`) 的语法，它会导致错误如果`PathName`省略参数。 不能使用`GetObject`以获取对使用 Visual Basic 创建的类的引用。  
  
> [!IMPORTANT]
>  `GetObject`函数需要非托管的代码的权限，这可能会影响在部分信任情况下执行。 有关详细信息，请参阅<xref:System.Security.Permissions.SecurityPermission>并[代码访问权限](https://msdn.microsoft.com/library/e5ae402f-6dda-4732-bbe8-77296630f675)。  
  
   
  
## Examples  
 下面的示例使用`GetObject`函数获取对特定的 Microsoft Excel 工作表的引用 (`excelObj`)。 它使用工作表的`Application`属性让 Excel 显示出来，以关闭它，并执行其他操作。 使用两个 API 调用，`detectExcel`过程查找 Excel，且如果它正在运行，将进入它在运行对象表中。 首次调用`GetObject`会导致错误，如果 Excel 尚未运行，在此示例会导致`excelWasNotRunning`标志设置为`True`。 第二次调用`GetObject`指定要打开的文件。 如果尚未运行 Excel，第二次调用启动外接程序，并返回到指定的文件，由表示工作表的引用`test.xls`。 该文件必须存在于指定位置;否则，Visual Basic 将引发<xref:System.IO.FileNotFoundException>。 接下来，示例代码会使 Excel 和包含指定的工作表可见的窗口。  
  
 此示例需要`Option Strict Off`因为它使用后期绑定，其中对象分配给类型的变量`Object`。 您可以指定`Option Strict On`，并声明特定对象类型的对象，如果添加对从 Excel 类型库的引用**COM**选项卡**添加引用**对话框中的**项目**Visual Studio 菜单中的。  
  
 [!code-vb[VbVbalrExcelObject#2](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrExcelObject/VB/Class1.vb#2)]  
  
 [!code-vb[VbVbalrExcelObject#4](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrExcelObject/VB/Class1.vb#4)]  
  
 [!code-vb[VbVbalrExcelObject#5](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrExcelObject/VB/Class1.vb#5)]  
  
 当您调用`getExcel`函数，则进行检查以查看是否已运行 Excel。 如果不是这样，被创建实例。  
  
> [!IMPORTANT]
>  为简单起见，前面的示例假定任何窗口调用`XLMAIN`属于 Microsoft Excel 的实例。 如果另一个对象，可能是由非法篡改启动具有该名称创建一个窗口，它将接收适用于 Excel 的所有消息。 在用于生产的应用程序，应包括一些更严格测试，以验证`XLMAIN`确实属于 Excel。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Exception">不存在指定类类型的对象。</exception>
        <exception cref="T:System.IO.FileNotFoundException">不存在具有指定路径和文件名的对象。</exception>
        <altmember cref="M:Microsoft.VisualBasic.Interaction.CreateObject(System.String,System.String)" />
        <altmember cref="T:System.Exception" />
        <altmember cref="T:System.IO.FileNotFoundException" />
        <related type="Article" href="~/docs/visual-basic/language-reference/statements/declare-statement.md">Declare Statement</related>
        <related type="Article" href="~/docs/visual-basic/language-reference/statements/option-strict-statement.md">Option Strict Statement</related>
      </Docs>
    </Member>
    <Member MemberName="GetSetting">
      <MemberSignature Language="C#" Value="public static string GetSetting (string AppName, string Section, string Key, string Default = &quot;&quot;);" />
      <MemberSignature Language="ILAsm" Value=".method public static string GetSetting(string AppName, string Section, string Key, string Default) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Interaction.GetSetting(System.String,System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetSetting (AppName As String, Section As String, Key As String, Optional Default As String = &quot;&quot;) As String" />
      <MemberSignature Language="F#" Value="static member GetSetting : string * string * string * string -&gt; string" Usage="Microsoft.VisualBasic.Interaction.GetSetting (AppName, Section, Key, Default)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="AppName" Type="System.String" />
        <Parameter Name="Section" Type="System.String" />
        <Parameter Name="Key" Type="System.String" />
        <Parameter Name="Default" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="AppName">必须的。 <see langword="String" /> 表达式，包含请求其项设置的应用程序或项目的名称。</param>
        <param name="Section">必须的。 <see langword="String" /> 表达式，包含在其中找到项设置的节的名称。</param>
        <param name="Key">必须的。 <see langword="String" /> 表达式，包含要返回的项设置的名称。</param>
        <param name="Default">可选。 包含要返回的值的表达式（如果没有在 <c>Key</c> 设置中设置值）。 如果省略，则假定 <c>Default</c> 为零长度字符串 ("")。</param>
        <summary>从 Windows 注册表中应用程序的项返回项设置值。 与 <see langword="My" /> 相比，<see langword="GetAllSettings" /> 功能在注册表操作方面可为您提供更高的效率和更好的性能。 有关详情，请参阅<see cref="P:Microsoft.VisualBasic.Devices.ServerComputer.Registry" />。</summary>
        <returns>从 Windows 注册表中应用程序的项返回项设置值。  
  
与 <see langword="My" /> 相比，<see langword="GetAllSettings" /> 功能在注册表操作方面可为您提供更高的效率和更好的性能。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果在任何一项名为`GetSetting`自变量不存在，`GetSetting`返回的值为`Default`。  
  
 因为它将在操作`HKEY_LOCAL_USER`注册表项，该项未处于活动状态直至用户以交互方式登录，`GetSetting`要求用户进行登录。  
  
 若要从非交互式进程 （如 Mtx.exe) 访问的注册表设置应存储在`HKEY_LOCAL_MACHINE\Software\`或`HKEY_USER\DEFAULT\Software`注册表项。  
  
 `GetSetting` 需要`Read` <xref:System.Security.Permissions.RegistryPermission> 。  
  
   
  
## Examples  
 此示例首先使用`SaveSetting`函数来为指定的应用程序在 Windows 注册表中生成条目`AppName`，然后使用`GetSetting`函数以显示设置之一。 因为`Default`指定参数，则某些保证值返回。 请注意，`Section`名称不能使用检索`GetSetting`。 最后，`DeleteSetting`函数会删除应用程序的所有条目。  
  
 [!code-vb[VbVbalrCatRef#61](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#61)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">一个或多个参数不是 <see langword="String" /> 表达式，或用户没有登录。</exception>
        <altmember cref="M:Microsoft.VisualBasic.Interaction.DeleteSetting(System.String,System.String,System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.Interaction.GetAllSettings(System.String,System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.Interaction.SaveSetting(System.String,System.String,System.String,System.String)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.Security.Permissions.RegistryPermission" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/computer-resources/reading-from-and-writing-to-the-registry.md">读取和写入注册表 (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="IIf">
      <MemberSignature Language="C#" Value="public static object IIf (bool Expression, object TruePart, object FalsePart);" />
      <MemberSignature Language="ILAsm" Value=".method public static object IIf(bool Expression, object TruePart, object FalsePart) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Interaction.IIf(System.Boolean,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function IIf (Expression As Boolean, TruePart As Object, FalsePart As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ IIf(bool Expression, System::Object ^ TruePart, System::Object ^ FalsePart);" />
      <MemberSignature Language="F#" Value="static member IIf : bool * obj * obj -&gt; obj" Usage="Microsoft.VisualBasic.Interaction.IIf (Expression, TruePart, FalsePart)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Expression" Type="System.Boolean" />
        <Parameter Name="TruePart" Type="System.Object" />
        <Parameter Name="FalsePart" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="Expression">必须的。 <see langword="Boolean" />。 要计算的表达式。</param>
        <param name="TruePart">必须的。 <see langword="Object" />。 如果 <c>Expression</c> 的计算结果为 <see langword="True" />，则返回。</param>
        <param name="FalsePart">必须的。 <see langword="Object" />。 如果 <c>Expression</c> 的计算结果为 <see langword="False" />，则返回。</param>
        <summary>根据表达式的计算，返回两个对象中的一个。</summary>
        <returns>根据表达式的计算，返回两个对象中的一个。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `IIf`函数提供了对应的三元[条件运算符:？:](https://msdn.microsoft.com/library/88643ee8-7100-4f86-880a-705ec22b6271) Visual c + +。  
  
   
  
## Examples  
 此示例使用`IIf`函数来计算`testMe`参数的`checkIt`过程并返回单词"大型"if 金额大于 1000年; 否则，它返回单词"小"。  
  
 [!code-vb[VbVbalrFunctions#33](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrFunctions/VB/Class1.vb#33)]  
  
 请注意，如果`Option Strict`是`On`，则必须使用`CStr`关键字的返回值显式转换`Object`到`String`。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.Interaction.Choose(System.Double,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.Interaction.Switch(System.Object[])" />
        <related type="Article" href="~/docs/visual-basic/language-reference/statements/option-strict-statement.md">Option Strict Statement</related>
        <related type="Article" href="~/docs/visual-basic/language-reference/functions/type-conversion-functions.md">Type Conversion Functions</related>
        <related type="Article" href="~/docs/visual-basic/language-reference/statements/if-then-else-statement.md">If...Then...Else 语句 (Visual Basic)</related>
        <related type="Article" href="~/docs/visual-basic/language-reference/statements/select-case-statement.md">Select...Case 语句 (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="InputBox">
      <MemberSignature Language="C#" Value="public static string InputBox (string Prompt, string Title = &quot;&quot;, string DefaultResponse = &quot;&quot;, int XPos = -1, int YPos = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static string InputBox(string Prompt, string Title, string DefaultResponse, int32 XPos, int32 YPos) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Interaction.InputBox(System.String,System.String,System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function InputBox (Prompt As String, Optional Title As String = &quot;&quot;, Optional DefaultResponse As String = &quot;&quot;, Optional XPos As Integer = -1, Optional YPos As Integer = -1) As String" />
      <MemberSignature Language="F#" Value="static member InputBox : string * string * string * int * int -&gt; string" Usage="Microsoft.VisualBasic.Interaction.InputBox (Prompt, Title, DefaultResponse, XPos, YPos)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Prompt" Type="System.String" />
        <Parameter Name="Title" Type="System.String" />
        <Parameter Name="DefaultResponse" Type="System.String" />
        <Parameter Name="XPos" Type="System.Int32" />
        <Parameter Name="YPos" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="Prompt">必选的 <see langword="String" /> 表达式，作为消息显示在对话框中。 <c>Prompt</c> 的最大长度大约为 1024 个字符，具体取决于所用字符的宽度。 如果 <c>Prompt</c> 包含多行，可以使用回车符 (<see langword="Chr(" />13<see langword=")" />) 或换行符 (<see langword="Chr(" />10<see langword=")" />)，或组合使用回车符/换行符 (<see langword="Chr(" />13<see langword=")" /> &amp; <see langword="Chr(" />10<see langword=")" />) 来分隔每行。</param>
        <param name="Title">可选。 显示在对话框标题栏中的 <see langword="String" /> 表达式。 如果省略 <c>Title</c>，则标题栏中显示应用程序名称。</param>
        <param name="DefaultResponse">可选。 <see langword="String" /> 表达式。如果未提供其他输入，则作为默认响应显示在文本框中。 如果省略 <c>DefaultResponse</c>，则显示的文本框为空。</param>
        <param name="XPos">可选。 数值表达式，指定屏幕左边缘与对话框左边缘之间的距离（以缇为单位）。 如果省略 <c>XPos</c>，则对话框水平居中。</param>
        <param name="YPos">可选。 数值表达式，指定屏幕顶部与对话框上边缘之间的距离（以缇为单位）。 如果省略 <c>YPos</c>，则对话框垂直定位在屏幕向下大约三分之一处。</param>
        <summary>在对话框中显示提示，等待用户输入文本或单击按钮，然后返回包含文本框内容的字符串。</summary>
        <returns>在对话框中显示提示，等待用户输入文本或单击按钮，然后返回包含文本框内容的字符串。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果用户单击**取消**，则返回长度为零的字符串。  
  
 若要指定多个第一个参数，必须使用`InputBox`在表达式中的函数。 如果省略任何位置实参，你必须保留相应的逗号分隔符。  
  
> [!NOTE]
>  `InputBox`函数需要`UIPermission`在<xref:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows>级别，可能会影响在部分信任情况下执行。 有关详细信息，请参阅和<xref:System.Security.Permissions.UIPermission>。  
  
   
  
## Examples  
 此示例演示各种方法来使用`InputBox`函数来提示用户输入的值。 如果 x 和 y 位置省略、 各自的轴自动居中显示对话框。 该变量`MyValue`包含由用户输入，如果用户单击确定或按 ENTER 键的值。  
  
 [!code-vb[VbVbalrCatRef#67](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#67)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.Interaction.MsgBox(System.Object,Microsoft.VisualBasic.MsgBoxStyle,System.Object)" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Chr(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.ChrW(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="MsgBox">
      <MemberSignature Language="C#" Value="public static Microsoft.VisualBasic.MsgBoxResult MsgBox (object Prompt, Microsoft.VisualBasic.MsgBoxStyle Buttons = Microsoft.VisualBasic.MsgBoxStyle.ApplicationModal, object Title = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static valuetype Microsoft.VisualBasic.MsgBoxResult MsgBox(object Prompt, valuetype Microsoft.VisualBasic.MsgBoxStyle Buttons, object Title) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Interaction.MsgBox(System.Object,Microsoft.VisualBasic.MsgBoxStyle,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function MsgBox (Prompt As Object, Optional Buttons As MsgBoxStyle = Microsoft.VisualBasic.MsgBoxStyle.ApplicationModal, Optional Title As Object = null) As MsgBoxResult" />
      <MemberSignature Language="F#" Value="static member MsgBox : obj * Microsoft.VisualBasic.MsgBoxStyle * obj -&gt; Microsoft.VisualBasic.MsgBoxResult" Usage="Microsoft.VisualBasic.Interaction.MsgBox (Prompt, Buttons, Title)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.VisualBasic.MsgBoxResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Prompt" Type="System.Object" />
        <Parameter Name="Buttons" Type="Microsoft.VisualBasic.MsgBoxStyle" />
        <Parameter Name="Title" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="Prompt">必须的。 作为消息显示在对话框中的 <see langword="String" /> 表达式。 <c>Prompt</c> 的最大长度大约为 1024 个字符，具体取决于所用字符的宽度。 如果 <c>Prompt</c> 包含多行，可以使用回车符 (<see langword="Chr(" />13<see langword=")" />) 或换行符 (<see langword="Chr(" />10<see langword=")" />)，或组合使用回车符/换行符 (<see langword="Chr(" />13<see langword=")" /> &amp; <see langword="Chr(" />10<see langword=")" />) 来分隔每行。</param>
        <param name="Buttons">可选。 数值表达式，它是值的总和，指定显示的按钮数目及按钮类型，使用的图标样式，默认按钮的标识以及消息框的样式等。 如果省略 <c>Buttons</c>，则默认值为 0。</param>
        <param name="Title">可选。 显示在对话框标题栏中的 <see langword="String" /> 表达式。 如果省略 <c>Title</c>，则标题栏中显示应用程序名称。</param>
        <summary>在对话框中显示消息，等待用户单击按钮，然后返回一个整数，该整数指示用户单击的按钮。</summary>
        <returns>
          <list type="table">
            <item>
              <term> 返回的常量 
 </term>
              <description> “值” 
 </description>
            </item>
            <item>
              <term>
                <see langword="OK" />
              </term>
              <description> 1 
 </description>
            </item>
            <item>
              <term>
                <see langword="Cancel" />
              </term>
              <description> 2 
 </description>
            </item>
            <item>
              <term>
                <see langword="Abort" />
              </term>
              <description> 3 
 </description>
            </item>
            <item>
              <term>
                <see langword="Retry" />
              </term>
              <description> 4 
 </description>
            </item>
            <item>
              <term>
                <see langword="Ignore" />
              </term>
              <description> 5 
 </description>
            </item>
            <item>
              <term>
                <see langword="Yes" />
              </term>
              <description> 6 
 </description>
            </item>
            <item>
              <term>
                <see langword="No" />
              </term>
              <description> 7 
 </description>
            </item>
          </list>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果省略任何位置实参，你必须保留相应的逗号分隔符。  
  
 如果对话框显示**取消**按钮，则按 ESC 键具有相同的效果与单击**取消**  
  
 如果对话框包含**帮助**按钮，为对话框提供上下文相关帮助。 但是，在关闭其他任一按钮前，不会返回任何值。 在 Windows 窗体应用程序中，选择**帮助**按钮执行<xref:System.Windows.Forms.Control.HelpRequested>窗体的事件。  
  
> [!NOTE]
>  `MsgBox`函数需要`UIPermission`在<xref:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows>级别，可能会影响在部分信任情况下执行。 有关详情，请参阅<xref:System.Security.Permissions.UIPermission>。  
  
 `MsgBoxStyle`下表列出了枚举值。  
  
|成员|“值”|描述|  
|-|-|-|  
|成员|“值”|描述|  
|`OKOnly`|0|仅显示确定按钮。|  
|`OKCancel`|1|显示确定和取消按钮。|  
|`AbortRetryIgnore`|2|显示中止、 重试，和忽略按钮。|  
|`YesNoCancel`|3|显示是、 否和取消按钮。|  
|`YesNo`|4|显示是和无按钮。|  
|`RetryCancel`|5|显示重试和取消按钮。|  
|`Critical`|16|显示关键消息图标。|  
|`Question`|32|显示警告查询图标。|  
|`Exclamation`|48|显示警告消息图标。|  
|`Information`|64|显示信息性消息图标。|  
|`DefaultButton1`|0|第一个按钮是默认值。|  
|`DefaultButton2`|256|第二个按钮是默认值。|  
|`DefaultButton3`|512|第三个按钮是默认值。|  
|`ApplicationModal`|0|应用程序是模式化。 用户必须响应消息框，才能继续在当前应用程序中工作。|  
|`SystemModal`|4096|系统为模式。 所有应用程序挂起，直到用户响应消息框。|  
|`MsgBoxSetForeground`|65536|指定消息框窗口作为前台窗口。|  
|`MsgBoxRight`|524288|文本是右对齐。|  
|`MsgBoxRtlReading`|1048576|指定文本应显示为右到左读取希伯来语和阿拉伯语系统上。|  
  
 第一组值 (0 – 5) 描述的数量和类型显示在对话框中的按钮。 第二个组 （16、 32、 48、 64） 描述图标样式。 第三个组 （0、 256、 512） 确定哪个按钮是默认值。 第四个组 （0，4096） 确定的消息框中，模式和第五个组指定消息框窗口是前台窗口，以及对齐和中文本的方向。 当添加数字以创建为一个最终值`Buttons`参数，使用每个组中只有一个数字。  
  
   
  
## Examples  
 此示例使用`MsgBox`函数具有是和无按钮的对话框中显示的严重错误消息。 否按钮指定为默认响应。 这是通过组合`MsgBox`到一个数值表达式的常量值。 在这种情况下，加上 4 (是/否按钮组合) 和 16 (**关键消息**窗口) 和 256 （作为默认按钮的第二个按钮） 得到的 276 总计。 返回的值`MsgBox`函数取决于用户选择的按钮: 是返回的值为 6;没有返回一个值为 7。  
  
 [!code-vb[VbVbalrCatRef#20](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#20)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="Prompt" /> 不是一个 <see langword="String" /> 表达式，或者 <paramref name="Title" /> 无效。</exception>
        <exception cref="T:System.InvalidOperationException">进程不是以 User Interactive 模式运行。</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">一个或多个参数，而不是 <see langword="MsgBoxResult" /> 或 <see langword="MsgBoxStyle" /> 枚举的成员。</exception>
        <altmember cref="M:Microsoft.VisualBasic.Interaction.InputBox(System.String,System.String,System.String,System.Int32,System.Int32)" />
        <altmember cref="M:System.Windows.Forms.MessageBox.Show(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Partition">
      <MemberSignature Language="C#" Value="public static string Partition (long Number, long Start, long Stop, long Interval);" />
      <MemberSignature Language="ILAsm" Value=".method public static string Partition(int64 Number, int64 Start, int64 Stop, int64 Interval) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Interaction.Partition(System.Int64,System.Int64,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function Partition (Number As Long, Start As Long, Stop As Long, Interval As Long) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Partition(long Number, long Start, long Stop, long Interval);" />
      <MemberSignature Language="F#" Value="static member Partition : int64 * int64 * int64 * int64 -&gt; string" Usage="Microsoft.VisualBasic.Interaction.Partition (Number, Start, Stop, Interval)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Number" Type="System.Int64" />
        <Parameter Name="Start" Type="System.Int64" />
        <Parameter Name="Stop" Type="System.Int64" />
        <Parameter Name="Interval" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="Number">必须的。 <see langword="Long" />。 要在一个计算范围中找到的整数。</param>
        <param name="Start">必须的。 <see langword="Long" />。 一个整数，指示计算出的范围集的开始值。 <c>Start</c> 不能小于 0。</param>
        <param name="Stop">必须的。 <see langword="Long" />。 一个整数，指示计算出的范围集的结束值。 <c>Stop</c> 不能小于或等于 <c>Start</c>。</param>
        <param name="Interval">必须的。 <see langword="Long" />。 一个整数，指示在 <c>Start</c> 和 <c>Stop</c> 之间计算的每个范围大小。 <c>Interval</c> 不能小于 1。</param>
        <summary>返回一个字符串，该字符串表示包含某个数字的计算范围。</summary>
        <returns>返回一个字符串，该字符串表示包含某个数字的计算范围。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Partition`函数计算的一组数值范围，每个都包含由指定的值的数目`Interval`。 第一个范围开始处`Start`，并最后一个范围结束于`Stop`。 `Partition`函数然后确定哪一个范围包含`Number`，并返回一个描述该范围内的字符串。 范围表示为字符串中"*较*:*值*"，其中范围的低端 (*较*) 分开的高端 (*值*) 一个冒号 （:）。  
  
 如果有必要，请`Partition`函数将插入前的前导空格*较*并*值*，以便它们都具有相同数量的字符的值 （以字符串表示形式`Stop` + 1)。 这可确保，如果使用的输出`Partition`函数中的多个值`Number`，生成的文本都可以正确处理任何后续排序操作过程。  
  
 下表显示了使用三组计算的范围某些示例字符串`Start`， `Stop`，和`Interval`。 "第一个范围"和"最后一个范围"列显示在给定的值时可能的最低和最高范围`Start`和`Stop`。 "之前第一个范围"和"之后，最后一个范围"列显示返回的值的字符串`Number`少于`Start`且大于`Stop`分别。  
  
|`Start`|`Stop`|`Interval`|第一个范围之前|第一个范围|最后一个范围|最后一个范围之后|  
|-|-|-|-|-|-|-|  
|0|99|5|"   : -1"|"0: 4"|"95: 99"|"100:"|  
|20|199|10|": 19 英寸|"20: 29"|"190:199"|"200:"|  
|100|1010|20|": 99"|"100: 119"|"1000:1010"|"1011年:"|  
  
 在上表中，第三行显示结果时`Start`并`Stop`定义一组不能通过平均划分的数字`Interval`。 最后一个范围结束于`Stop`，使其仅有 11 个字符，即使`Interval`为 20。  
  
 如果`Interval`为 1，范围是"`Number`:`Number`"，则无论什么`Start`和`Stop`参数。 例如，如果`Number`是 267，`Stop`为 1000，并`Interval`为 1，`Partition`返回"267: 267"。  
  
 `Partition` 构建数据库查询时，可以很有用。 可以创建显示订单数，例如用发票值从 1 到 1000，各种值范围内发生 1001年到 2000年等等的 SELECT 查询。  
  
   
  
## Examples  
 下面的示例设置范围的一系列几十年来从通过 2049年 1950 年。 它查找的值`year`内的适当的范围和返回`String`显示范围的值。 如果`year`的值为 1984，例如，`Partition`返回"1980: 1989"。  
  
 [!code-vb[VbVbalrFunctions#45](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrFunctions/VB/Class1.vb#45)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="Start" /> &lt; 0、<paramref name="Stop" /> &lt;= <paramref name="Start" /> 或 <paramref name="Interval" /> &lt; 1。</exception>
      </Docs>
    </Member>
    <Member MemberName="SaveSetting">
      <MemberSignature Language="C#" Value="public static void SaveSetting (string AppName, string Section, string Key, string Setting);" />
      <MemberSignature Language="ILAsm" Value=".method public static void SaveSetting(string AppName, string Section, string Key, string Setting) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Interaction.SaveSetting(System.String,System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SaveSetting (AppName As String, Section As String, Key As String, Setting As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SaveSetting(System::String ^ AppName, System::String ^ Section, System::String ^ Key, System::String ^ Setting);" />
      <MemberSignature Language="F#" Value="static member SaveSetting : string * string * string * string -&gt; unit" Usage="Microsoft.VisualBasic.Interaction.SaveSetting (AppName, Section, Key, Setting)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="AppName" Type="System.String" />
        <Parameter Name="Section" Type="System.String" />
        <Parameter Name="Key" Type="System.String" />
        <Parameter Name="Setting" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="AppName">必须的。 <see langword="String" /> 表达式，包含应用该设置的应用程序或项目的名称。</param>
        <param name="Section">必须的。 <see langword="String" /> 表达式，包含在其中保存项设置的节的名称。</param>
        <param name="Key">必须的。 <see langword="String" /> 表达式，包含将保存的项设置的名称。</param>
        <param name="Setting">必须的。 包含值的表达式，<c>Key</c> 将被设置为该值。</param>
        <summary>在 Windows 注册表中保存或创建应用程序项。 与 <see langword="My" /> 相比，<see langword="SaveSetting" /> 功能在注册表操作方面可为您提供更高的效率和更好的性能。 有关详情，请参阅<see cref="P:Microsoft.VisualBasic.Devices.ServerComputer.Registry" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `SaveSetting`函数将添加到密钥`HKEY_CURRENT_USER\Software\VB and VBA Program Settings`。  
  
 如果出于任何原因而无法保存项设置，将会出错。  
  
 `SaveSetting` 要求用户登录上将在操作由于`HKEY_LOCAL_USER`注册表项，直到用户以交互方式登录未处于活动状态。  
  
 若要从非交互式进程 （如 Mtx.exe) 访问的注册表设置应存储在`HKEY_LOCAL_MACHINE\Software\`或`HKEY_USER\DEFAULT\Software`注册表项。  
  
 `SaveSetting` 需要`Write`并`Create` <xref:System.Security.Permissions.RegistryPermission> 。  
  
   
  
## Examples  
 下面的示例首先使用`SaveSetting`函数来在 Windows 注册表中生成条目`MyApp`应用程序，然后使用`DeleteSetting`函数将其删除。  
  
 [!code-vb[VbVbalrCatRef#56](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#56)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">未能创建注册表项，或用户没有登录。</exception>
        <altmember cref="M:Microsoft.VisualBasic.Interaction.DeleteSetting(System.String,System.String,System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.Interaction.GetAllSettings(System.String,System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.Interaction.GetSetting(System.String,System.String,System.String,System.String)" />
        <altmember cref="T:System.Security.Permissions.RegistryPermission" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/computer-resources/reading-from-and-writing-to-the-registry.md">读取和写入注册表 (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Shell">
      <MemberSignature Language="C#" Value="public static int Shell (string Pathname, Microsoft.VisualBasic.AppWinStyle Style = Microsoft.VisualBasic.AppWinStyle.MinimizedFocus, bool Wait = false, int Timeout = -1);" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="ILAsm" Value=".method public static int32 Shell(string Pathname, valuetype Microsoft.VisualBasic.AppWinStyle Style, bool Wait, int32 Timeout) cil managed" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Interaction.Shell(System.String,Microsoft.VisualBasic.AppWinStyle,System.Boolean,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Shell (Pathname As String, Optional Style As AppWinStyle = Microsoft.VisualBasic.AppWinStyle.MinimizedFocus, Optional Wait As Boolean = false, Optional Timeout As Integer = -1) As Integer" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="F#" Value="static member Shell : string * Microsoft.VisualBasic.AppWinStyle * bool * int -&gt; int" Usage="Microsoft.VisualBasic.Interaction.Shell (Pathname, Style, Wait, Timeout)" FrameworkAlternate="netframework-1.1;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="C#" Value="public static int Shell (string PathName, Microsoft.VisualBasic.AppWinStyle Style = Microsoft.VisualBasic.AppWinStyle.MinimizedFocus, bool Wait = false, int Timeout = -1);" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="ILAsm" Value=".method public static int32 Shell(string PathName, valuetype Microsoft.VisualBasic.AppWinStyle Style, bool Wait, int32 Timeout) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="VB.NET" Value="Public Function Shell (PathName As String, Optional Style As AppWinStyle = Microsoft.VisualBasic.AppWinStyle.MinimizedFocus, Optional Wait As Boolean = false, Optional Timeout As Integer = -1) As Integer" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="F#" Value="static member Shell : string * Microsoft.VisualBasic.AppWinStyle * bool * int -&gt; int" Usage="Microsoft.VisualBasic.Interaction.Shell (PathName, Style, Wait, Timeout)" FrameworkAlternate="netframework-2.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Pathname" Type="System.String" Index="0" FrameworkAlternate="netframework-1.1" />
        <Parameter Name="PathName" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="Style" Type="Microsoft.VisualBasic.AppWinStyle" Index="1" />
        <Parameter Name="Wait" Type="System.Boolean" Index="2" />
        <Parameter Name="Timeout" Type="System.Int32" Index="3" />
      </Parameters>
      <Docs>
        <param name="PathName">必须的。 <see langword="String" />。 要执行的程序的名称，以及所有必需的参数和命令行开关。 <c>PathName</c> 也可以包含驱动器和目录路径或文件夹。  
  
如果不知道程序的路径，则可以使用 <see cref="Overload:Microsoft.VisualBasic.FileIO.FileSystem.GetFiles" /> 进行定位。 例如，你可以调用 <c>My.Computer.FileSystem.GetFiles("C:\", True, "testFile.txt")</c>，这将返回驱动器 C:\\ 上任意位置每个名为 <c>testFile.txt</c> 的文件的完整路径。</param>
        <param name="Pathname">To be added.</param>
        <param name="Style">可选。 <see langword="AppWinStyle" />。 从 <see cref="T:Microsoft.VisualBasic.AppWinStyle" /> 中选择的一个值，该值指定将要在其中运行程序的窗口的样式。 如果省略 <c>Style</c>，<see langword="Shell" /> 将使用 <see langword="AppWinStyle.MinimizedFocus" />启动最小化且带焦点的程序。</param>
        <param name="Wait">可选。 <see langword="Boolean" />。 一个指示 <see langword="Shell" /> 函数是否应等待程序完成的值。 如果省略 <c>Wait</c>，则 <see langword="Shell" /> 将使用 <see langword="False" />。</param>
        <param name="Timeout">可选。 <see langword="Integer" />。 如果 <c>Wait</c> 为 <see langword="True" />，则为等待完成的毫秒数。 如果省略 <c>Timeout</c>，则 <see langword="Shell" /> 使用 -1，表示没有超时并且 <see langword="Shell" /> 到程序结束时才返回。 因此，如果省略 <c>Timeout</c> 或将其设置为 -1，则 <see langword="Shell" /> 可能永远不会将控件返回给你的程序。</param>
        <summary>运行一个可执行程序，并且如果该程序仍在运行则返回一个包含该程序的进程 ID 的整数。</summary>
        <returns>运行一个可执行程序，并且如果该程序仍在运行则返回一个包含该程序的进程 ID 的整数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 返回值`Shell`函数取决于程序是否在名为`PathName`仍在执行时`Shell`返回。 如果您设置`Wait`到`True`并在程序完成之前超时到期，`Shell`返回零。 如果在超时到期，或省略`Wait`或将其设置为`False`，`Shell`返回该程序的进程 ID。 进程 ID 是标识正在运行的程序的唯一编号。  
  
## <a name="failure-to-start"></a>启动失败  
 如果`Shell`函数不能启动指定的程序，<xref:System.IO.FileNotFoundException>发生错误。 可以这样做，例如，当您尝试运行 16 位程序，如`command.com`，从应用程序中使用<xref:System.Windows.Forms?displayProperty=nameWithType>。 有关解决方法，可以运行调用所需的 16 位程序的 32 位程序。 情况下`command.com`，可以运行`cmd.exe`作为替代方法。  
  
## <a name="waiting-for-completion"></a>等待完成  
 默认情况下，`Shell`函数以异步方式运行该程序。 这意味着程序入门`Shell`函数可能无法完成执行之后的语句之前`Shell`函数执行的。 如果你想要等待计划完成，然后您再继续，请设置`Wait`到`True`。  
  
## <a name="determining-the-exit-code"></a>确定退出代码  
 一个过程可以返回*退出代码*终止时。 但是，不能使用`Shell`来检索此退出代码，因为`Shell`如果等待终止，则返回零，也因为进程运行在不同的对象中`Shell`。  
  
 若要检索从进程的退出代码，必须编写您自己的代码以启动过程并等待终止。 下面的示例演示如何启动过程，等待其终止，并检索其退出代码。  
  
```vb  
Dim procID As Integer  
Dim newProc As Diagnostics.Process  
newProc = Diagnostics.Process.Start("C:\WINDOWS\NOTEPAD.EXE")  
procID = newProc.Id  
newProc.WaitForExit()  
Dim procEC As Integer = -1  
If newProc.HasExited Then  
    procEC = newProc.ExitCode  
End If  
MsgBox("Process with ID " & CStr(ProcID) & _  
    " terminated with exit code " & CStr(procEC))  
```  
  
## <a name="protecting-the-file-specification"></a>保护的文件规范  
 始终应将整个路径和文件名规范括在引号内，如以下示例所示。  
  
```vb  
ID = Shell("""C:\Program Files\display.exe"" -a -q", , True, 100000)  
```  
  
 每对相邻两个双引号 (`" "`) 在字符串文本解释为一个双引号字符在字符串中。 因此，前面的示例中显示的下列字符串`Shell`函数：  
  
```console  
"C:\Program Files\display.exe" -a -q  
```  
  
 如果您没有用引号括起来的路径，Windows 将查找名为的文件`Program.exe`在 C:\ 目录中，而不是`display.exe`C:\Program Files 目录中。  
  
> [!IMPORTANT]
>  如果不要将路径和文件名规范括在引号中，如果该文件名或路径节点中包含空格则安全风险。 在前面的示例中，路径节点`\Program Files`中包含空格。 如果规范未在单引号中，名为的程序内`Program.exe`已安装在 c:\\，例如由非法篡改，Windows 将执行它而不是`display.exe`。  
  
> [!IMPORTANT]
>  `Shell`函数需要非托管的代码的权限，这可能会影响在部分信任情况下执行。 有关详细信息，请参阅<xref:System.Security.Permissions.SecurityPermission>并[代码访问权限](https://msdn.microsoft.com/library/e5ae402f-6dda-4732-bbe8-77296630f675)。  
  
   
  
## Examples  
 下面的示例使用`Shell`函数运行用户指定的应用程序。 指定<xref:Microsoft.VisualBasic.AppWinStyle.NormalFocus?displayProperty=nameWithType>为第二个参数将应用程序打开在正常大小，使其具有焦点。  
  
 [!code-vb[VbVbalrFunctions#47](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrFunctions/VB/Class1.vb#47)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="Style" /> 不在 0 到 9（包含 0 和 9）范围内。</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <see langword="Shell" /> 找不到 <paramref name="PathName" /> 文件。</exception>
        <exception cref="T:System.NullReferenceException">
          <paramref name="PathName" /> 为 <see langword="Nothing" />。</exception>
        <altmember cref="T:Microsoft.VisualBasic.AppWinStyle" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.FileNotFoundException" />
        <altmember cref="T:System.NullReferenceException" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileIO.FileSystem.GetFiles" />
        <altmember cref="Overload:Microsoft.VisualBasic.Interaction.AppActivate" />
      </Docs>
    </Member>
    <Member MemberName="Switch">
      <MemberSignature Language="C#" Value="public static object Switch (params object[] VarExpr);" />
      <MemberSignature Language="ILAsm" Value=".method public static object Switch(object[] VarExpr) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Interaction.Switch(System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Switch (ParamArray VarExpr As Object()) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ Switch(... cli::array &lt;System::Object ^&gt; ^ VarExpr);" />
      <MemberSignature Language="F#" Value="static member Switch : obj[] -&gt; obj" Usage="Microsoft.VisualBasic.Interaction.Switch VarExpr" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="VarExpr" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="VarExpr">必须的。 <see langword="Object" /> 参数数组。 必须具有偶数个元素。 可以提供以逗号分隔的 <see langword="Object" /> 变量或表达式的列表，或一维 <see langword="Object" /> 元素数组。</param>
        <summary>计算表达式列表，并返回与列表中第一个为 <see langword="Object" /> 的表达式对应的 <see langword="True" /> 值。</summary>
        <returns>计算表达式列表，并返回与列表中第一个为 <see langword="Object" /> 的表达式对应的 <see langword="True" /> 值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 自变量提供给`VarExpr`成对的表达式和值组成。 `Switch`函数计算奇数表达式，从最低到最高的索引，在`VarExpr`，并返回与第一个表达式的计算结果为关联的偶数值`True`。 例如，如果`VarExpr(0)`是`True`，`Switch`返回`VarExpr(1)`，并且如果`VarExpr(0)`是`False`但`VarExpr(2)`是`True`，`Switch`返回`VarExpr(3)`，依次类推。  
  
 如果未提供`VarExpr`参数，`Switch`返回`Nothing`。  
  
> [!NOTE]
>  参数列表中的表达式可以包括函数调用。 作为准备为调用的参数列表的一部分`Switch`，Visual Basic 编译器在每个表达式中调用的每个函数。 这意味着您不能依赖于特定函数参数列表中前面的表达式为时未调用`True`。  
  
   
  
## Examples  
 下面的示例使用`Switch`函数以返回与匹配的城市名称的语言的名称。 该配置要求`Option Strict`是`Off`。  
  
 [!code-vb[VbVbalrFunctions#48](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrFunctions/VB/Class1.vb#48)]  
  
 因为<xref:System.Diagnostics>命名空间还包含一个名为类<xref:System.Diagnostics.Switch>，调用`Switch`函数必须使用限定<xref:Microsoft.VisualBasic>命名空间。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">参数数目为奇数。</exception>
        <altmember cref="M:Microsoft.VisualBasic.Interaction.Choose(System.Double,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.Interaction.IIf(System.Boolean,System.Object,System.Object)" />
        <related type="Article" href="~/docs/visual-basic/language-reference/statements/select-case-statement.md">Select...Case 语句 (Visual Basic)</related>
        <related type="Article" href="~/docs/visual-basic/programming-guide/language-features/procedures/parameter-arrays.md">参数数组</related>
      </Docs>
    </Member>
  </Members>
</Type>