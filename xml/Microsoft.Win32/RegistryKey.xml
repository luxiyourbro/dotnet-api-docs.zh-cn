<Type Name="RegistryKey" FullName="Microsoft.Win32.RegistryKey">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="fa0d4dc6e3dcdcf1ad8c11cc75e8a209dadc0f79" />
    <Meta Name="ms.sourcegitcommit" Value="0d6aa6694f157a08fe52cd25b4d9d3dcf913e812" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-CN" />
    <Meta Name="ms.lasthandoff" Value="10/12/2018" />
    <Meta Name="ms.locfileid" Value="49145533" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class RegistryKey : MarshalByRefObject, IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed RegistryKey extends System.MarshalByRefObject implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:Microsoft.Win32.RegistryKey" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class RegistryKey&#xA;Inherits MarshalByRefObject&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class RegistryKey sealed : MarshalByRefObject, IDisposable" />
  <TypeSignature Language="F#" Value="type RegistryKey = class&#xA;    inherit MarshalByRefObject&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-4.5">System.MarshalByRefObject</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>表示 Windows 注册表中的项级节点。 此类是注册表封装。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要获取的实例<xref:Microsoft.Win32.RegistryKey>，使用的静态成员之一<xref:Microsoft.Win32.Registry>类。  
  
 在注册表的作用好似一台计算机上的操作系统和应用程序信息的中央存储库。 注册表组织层次结构格式，基于存储在它的元素的逻辑顺序 (请参阅<xref:Microsoft.Win32.Registry>此层次结构中的基本项)。 当将信息存储在注册表中，选择相应的位置所存储信息的类型。 请务必避免破坏其他应用程序创建的因为这可能会导致出现意外的行为，这些应用程序，还可以在自己的应用程序时产生不利影响的信息。  
  
> [!IMPORTANT]
>  此类型实现<xref:System.IDisposable>接口。 在使用完类型后，您应直接或间接释放类型。 若要直接释放类型，调用其<xref:System.IDisposable.Dispose%2A>中的方法`try` / `catch`块。 若要间接释放类型，请使用 `using`（在 C# 中）或 `Using`（在 Visual Basic 中）等语言构造。 有关详细信息，请参阅中的"使用对象实现 IDisposable"一节<xref:System.IDisposable>接口主题。  
  
 注册表项是在注册表中，组织的基本单元，并可以在文件资源管理器中的文件夹进行比较。 特定密钥可以有子项，就像一个文件夹可以拥有子文件夹。 每个键可以删除，只要用户具有适当权限来执行此操作，并且不是基项或直接下面这些基项的位置。 每个密钥还可以有与之关联 （值可以比较到一个文件），用于存储信息的多个值-例如，在计算机上安装的应用程序有关的信息。 每个值存储信息，从而可以检索或更新时所需的一个特定的部分。 例如，可以创建<xref:Microsoft.Win32.RegistryKey>公司，在下找到密钥 HKEY_LOCAL_MACHINE\Software，然后一个用于你的公司创建每个应用程序的子项。 每个子项包含的信息特定于该应用程序，如颜色设置、 屏幕位置和大小，或识别文件扩展名。  
  
 请注意，存储在注册表中的信息可供其他应用程序和用户，因此不应存储安全数据或关键应用程序信息。  
  
> [!CAUTION]
>  不会公开<xref:Microsoft.Win32.RegistryKey>，恶意程序无法创建数千个无意义的子项或键/值对的方式中的对象。 例如，不允许调用方可以输入任意键或值。  
  
 从开始[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]，注册表项的长度不再限制为 255 个字符。  
  
   
  
## Examples  
 下面的代码示例演示如何 HKEY_CURRENT_USER 下创建子项、 操作其内容，并删除的子项。  
  
 [!code-cpp[Microsoft.Win32.RegistryKey2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Microsoft.Win32.RegistryKey2/CPP/source.cpp#1)]
 [!code-csharp[Microsoft.Win32.RegistryKey2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Microsoft.Win32.RegistryKey2/CS/source.cs#1)]
 [!code-vb[Microsoft.Win32.RegistryKey2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Microsoft.Win32.RegistryKey2/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:Microsoft.Win32.Registry" />
    <altmember cref="T:Microsoft.Win32.RegistryHive" />
  </Docs>
  <Members>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.RegistryKey.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close();" />
      <MemberSignature Language="F#" Value="member this.Close : unit -&gt; unit" Usage="registryKey.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>关闭该项，如果其内容已修改，则将其刷新到磁盘。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在系统键上调用此方法不会影响，因为永远不会关闭系统密钥。  
  
 此方法不执行任何操作的实例上调用`RegistryKey`已关闭。  
  
   
  
## Examples  
 此代码示例是为提供一个更大示例的一部分<xref:Microsoft.Win32.RegistryKey>类。  
  
 [!code-cpp[Microsoft.Win32.RegistryKey2#4](~/samples/snippets/cpp/VS_Snippets_CLR/Microsoft.Win32.RegistryKey2/CPP/source.cpp#4)]
 [!code-csharp[Microsoft.Win32.RegistryKey2#4](~/samples/snippets/csharp/VS_Snippets_CLR/Microsoft.Win32.RegistryKey2/CS/source.cs#4)]
 [!code-vb[Microsoft.Win32.RegistryKey2#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/Microsoft.Win32.RegistryKey2/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.Win32.RegistryKey.Flush" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateSubKey">
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>创建一个新子项或打开一个现有子项。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateSubKey">
      <MemberSignature Language="C#" Value="public Microsoft.Win32.RegistryKey CreateSubKey (string subkey);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Microsoft.Win32.RegistryKey CreateSubKey(string subkey) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.RegistryKey.CreateSubKey(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateSubKey (subkey As String) As RegistryKey" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Microsoft::Win32::RegistryKey ^ CreateSubKey(System::String ^ subkey);" />
      <MemberSignature Language="F#" Value="member this.CreateSubKey : string -&gt; Microsoft.Win32.RegistryKey" Usage="registryKey.CreateSubKey subkey" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="subkey" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="subkey">要创建或打开的子项的名称或路径。 此字符串不区分大小写。</param>
        <summary>创建一个新子项或打开一个现有子项以进行写访问。</summary>
        <returns>新创建的子项，如果操作失败，则为 <see langword="null" />。 如果为 <paramref name="subkey" /> 指定了长度为零的字符串，则返回当前 <see cref="T:Microsoft.Win32.RegistryKey" /> 对象。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要执行此操作，用户必须具有注册表层次结构中的权限在此级别和更低版本。  
  
> [!CAUTION]
>  不会公开<xref:Microsoft.Win32.RegistryKey>，恶意程序无法创建数千个无意义的子项或键/值对的方式中的对象。 例如，不允许调用方可以输入任意键或值。  
  
   
  
## Examples  
 下面的代码示例演示如何 HKEY_CURRENT_USER 下创建子项、 操作其内容，并删除的子项。  
  
 [!code-cpp[Microsoft.Win32.RegistryKey2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Microsoft.Win32.RegistryKey2/CPP/source.cpp#1)]
 [!code-csharp[Microsoft.Win32.RegistryKey2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Microsoft.Win32.RegistryKey2/CS/source.cs#1)]
 [!code-vb[Microsoft.Win32.RegistryKey2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Microsoft.Win32.RegistryKey2/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="subkey" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.Security.SecurityException">用户没有创建或打开注册表项所需的权限。</exception>
        <exception cref="T:System.ObjectDisposedException">调用此方法时所针对的 <see cref="T:Microsoft.Win32.RegistryKey" /> 已关闭（无法访问已关闭的项）。</exception>
        <exception cref="T:System.UnauthorizedAccessException">无法写入 <see cref="T:Microsoft.Win32.RegistryKey" />；例如，它不是作为可写入项打开的，或者用户没有必需的访问权限。</exception>
        <exception cref="T:System.IO.IOException">嵌套级别超过 510。  
  
或 
出现系统错误，如删除注册表项，或尝试在 <see cref="F:Microsoft.Win32.Registry.LocalMachine" /> 根中创建注册表项。</exception>
        <permission cref="T:System.Security.Permissions.RegistryPermission">无法修改指定的注册表项，如果存在，或创建注册表键如果的功能它尚不存在。 关联枚举： <see cref="F:System.Security.Permissions.RegistryPermissionAccess.Write" />， <see cref="F:System.Security.Permissions.RegistryPermissionAccess.Create" /></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">它能够访问指定的注册表密钥如果它是一个远程的密钥。 关联的枚举： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="M:Microsoft.Win32.RegistryKey.DeleteSubKey(System.String)" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.OpenSubKey(System.String,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="CreateSubKey">
      <MemberSignature Language="C#" Value="public Microsoft.Win32.RegistryKey CreateSubKey (string subkey, Microsoft.Win32.RegistryKeyPermissionCheck permissionCheck);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Microsoft.Win32.RegistryKey CreateSubKey(string subkey, valuetype Microsoft.Win32.RegistryKeyPermissionCheck permissionCheck) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.RegistryKey.CreateSubKey(System.String,Microsoft.Win32.RegistryKeyPermissionCheck)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateSubKey (subkey As String, permissionCheck As RegistryKeyPermissionCheck) As RegistryKey" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Microsoft::Win32::RegistryKey ^ CreateSubKey(System::String ^ subkey, Microsoft::Win32::RegistryKeyPermissionCheck permissionCheck);" />
      <MemberSignature Language="F#" Value="member this.CreateSubKey : string * Microsoft.Win32.RegistryKeyPermissionCheck -&gt; Microsoft.Win32.RegistryKey" Usage="registryKey.CreateSubKey (subkey, permissionCheck)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="subkey" Type="System.String" />
        <Parameter Name="permissionCheck" Type="Microsoft.Win32.RegistryKeyPermissionCheck" />
      </Parameters>
      <Docs>
        <param name="subkey">要创建或打开的子项的名称或路径。 此字符串不区分大小写。</param>
        <param name="permissionCheck">用于指定打开该项是进行读取还是读取/写入访问的枚举值之一。</param>
        <summary>使用指定的权限检查选项创建一个新子项或打开一个现有子项以进行写访问。</summary>
        <returns>新创建的子项，如果操作失败，则为 <see langword="null" />。 如果为 <paramref name="subkey" /> 指定了长度为零的字符串，则返回当前 <see cref="T:Microsoft.Win32.RegistryKey" /> 对象。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要执行此操作，用户必须具有注册表层次结构中的权限在此级别和更低版本。  
  
> [!CAUTION]
>  不会公开<xref:Microsoft.Win32.RegistryKey>，恶意程序无法创建数千个无意义的子项或键/值对的方式中的对象。 例如，不允许调用方可以输入任意键或值。  
  
 若要使用<xref:Microsoft.Win32.RegistryKey.OpenSubKey%2A>方法，您必须拥有的实例<xref:Microsoft.Win32.RegistryKey>类。 若要获取的实例<xref:Microsoft.Win32.RegistryKey>，使用的静态成员之一<xref:Microsoft.Win32.Registry>类。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="subkey" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.Security.SecurityException">用户没有创建或打开注册表项所需的权限。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="permissionCheck" /> 包含无效值。</exception>
        <exception cref="T:System.ObjectDisposedException">调用此方法时所针对的 <see cref="T:Microsoft.Win32.RegistryKey" /> 已关闭（无法访问已关闭的项）。</exception>
        <exception cref="T:System.UnauthorizedAccessException">无法写入 <see cref="T:Microsoft.Win32.RegistryKey" />；例如，它不是作为可写入项打开的，或者用户没有必需的访问权限。</exception>
        <exception cref="T:System.IO.IOException">嵌套级别超过 510。  
  
或 
出现系统错误，如删除注册表项，或尝试在 <see cref="F:Microsoft.Win32.Registry.LocalMachine" /> 根中创建注册表项。</exception>
        <permission cref="T:System.Security.Permissions.RegistryPermission">无法修改指定的注册表项，如果存在，或创建注册表键如果的功能它尚不存在。 关联枚举： <see cref="F:System.Security.Permissions.RegistryPermissionAccess.Write" />， <see cref="F:System.Security.Permissions.RegistryPermissionAccess.Create" /></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">它能够访问指定的注册表密钥如果它是一个远程的密钥。 关联的枚举： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="M:Microsoft.Win32.RegistryKey.DeleteSubKey(System.String)" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.OpenSubKey(System.String,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="CreateSubKey">
      <MemberSignature Language="C#" Value="public Microsoft.Win32.RegistryKey CreateSubKey (string subkey, bool writable);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Microsoft.Win32.RegistryKey CreateSubKey(string subkey, bool writable) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.RegistryKey.CreateSubKey(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateSubKey (subkey As String, writable As Boolean) As RegistryKey" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Microsoft::Win32::RegistryKey ^ CreateSubKey(System::String ^ subkey, bool writable);" />
      <MemberSignature Language="F#" Value="member this.CreateSubKey : string * bool -&gt; Microsoft.Win32.RegistryKey" Usage="registryKey.CreateSubKey (subkey, writable)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="subkey" Type="System.String" />
        <Parameter Name="writable" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="subkey">要创建或打开的子项的名称或路径。 此字符串不区分大小写。</param>
        <param name="writable">如果新子项可写入，则为 <see langword="true" />；否则为 <see langword="false" />。</param>
        <summary>创建一个新子项或打开具有指定访问权限的现有子项。  
  
可以开始于 [!INCLUDE[net_v46](~/includes/net-v46-md.md)]</summary>
        <returns>新创建的子项，如果操作失败，则为 <see langword="null" />。 如果为 <paramref name="subkey" /> 指定了长度为零的字符串，则返回当前 <see cref="T:Microsoft.Win32.RegistryKey" /> 对象。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要执行此操作，用户必须具有注册表层次结构中的权限在此级别和更低版本。  
  
> [!CAUTION]
>  不会公开<xref:Microsoft.Win32.RegistryKey>，恶意程序无法创建数千个无意义的子项或键/值对的方式中的对象。 例如，不允许调用方可以输入任意键或值。  
  
 若要使用<xref:Microsoft.Win32.RegistryKey.CreateSubKey%2A>方法，您必须拥有的实例<xref:Microsoft.Win32.RegistryKey>类。 若要获取的实例<xref:Microsoft.Win32.RegistryKey>，使用的静态成员之一<xref:Microsoft.Win32.Registry>类。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="subkey" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.Security.SecurityException">用户没有创建或打开注册表项所需的权限。</exception>
        <exception cref="T:System.UnauthorizedAccessException">无法写入当前 <see cref="T:Microsoft.Win32.RegistryKey" />；例如，它未作为可写入项打开，或用户没有必要的访问权限。</exception>
        <exception cref="T:System.IO.IOException">嵌套级别超过 510。  
  
或 
出现系统错误，如删除注册表项，或尝试在 <see cref="F:Microsoft.Win32.Registry.LocalMachine" /> 根中创建注册表项。</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateSubKey">
      <MemberSignature Language="C#" Value="public Microsoft.Win32.RegistryKey CreateSubKey (string subkey, Microsoft.Win32.RegistryKeyPermissionCheck permissionCheck, System.Security.AccessControl.RegistrySecurity registrySecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Microsoft.Win32.RegistryKey CreateSubKey(string subkey, valuetype Microsoft.Win32.RegistryKeyPermissionCheck permissionCheck, class System.Security.AccessControl.RegistrySecurity registrySecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.RegistryKey.CreateSubKey(System.String,Microsoft.Win32.RegistryKeyPermissionCheck,System.Security.AccessControl.RegistrySecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Microsoft::Win32::RegistryKey ^ CreateSubKey(System::String ^ subkey, Microsoft::Win32::RegistryKeyPermissionCheck permissionCheck, System::Security::AccessControl::RegistrySecurity ^ registrySecurity);" />
      <MemberSignature Language="F#" Value="member this.CreateSubKey : string * Microsoft.Win32.RegistryKeyPermissionCheck * System.Security.AccessControl.RegistrySecurity -&gt; Microsoft.Win32.RegistryKey" Usage="registryKey.CreateSubKey (subkey, permissionCheck, registrySecurity)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="subkey" Type="System.String" />
        <Parameter Name="permissionCheck" Type="Microsoft.Win32.RegistryKeyPermissionCheck" />
        <Parameter Name="registrySecurity" Type="System.Security.AccessControl.RegistrySecurity" />
      </Parameters>
      <Docs>
        <param name="subkey">要创建或打开的子项的名称或路径。 此字符串不区分大小写。</param>
        <param name="permissionCheck">用于指定打开该项是进行读取还是读取/写入访问的枚举值之一。</param>
        <param name="registrySecurity">新项的访问控制安全性。</param>
        <summary>使用指定的权限检查选项和注册表安全性创建一个新子项或打开一个现有子项以进行写访问。</summary>
        <returns>新创建的子项，如果操作失败，则为 <see langword="null" />。 如果为 <paramref name="subkey" /> 指定了长度为零的字符串，则返回当前 <see cref="T:Microsoft.Win32.RegistryKey" /> 对象。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:Microsoft.Win32.RegistryKey.CreateSubKey%2A>方法创建一个具有指定的访问控制的注册表项`registrySecurity`参数。 <xref:Microsoft.Win32.RegistryKey>返回对象表示的注册表项，但该对象不受中指定的访问控制`registrySecurity`参数。  
  
 如果`permissionCheck`是<xref:Microsoft.Win32.RegistryKeyPermissionCheck.ReadWriteSubTree?displayProperty=nameWithType>，为读/写访问打开项。 如果`permissionCheck`是<xref:Microsoft.Win32.RegistryKeyPermissionCheck.ReadSubTree?displayProperty=nameWithType>，为读取访问权限打开项。  
  
 为了向后兼容的项打开用于读取和写入如果`permissionCheck`是<xref:Microsoft.Win32.RegistryKeyPermissionCheck.Default?displayProperty=nameWithType>和父项也有<xref:Microsoft.Win32.RegistryKeyPermissionCheck.Default?displayProperty=nameWithType>。 如果父项有任何其他设置，读/写状态是由父项的设置控制。  
  
 若要执行此操作，用户必须具有注册表层次结构中的权限在此级别和更低版本。  
  
> [!CAUTION]
>  不会公开<xref:Microsoft.Win32.RegistryKey>，恶意程序无法创建数千个无意义的子项或键/值对的方式中的对象。 例如，不允许调用方可以输入任意键或值。  
  
 若要使用<xref:Microsoft.Win32.RegistryKey.OpenSubKey%2A>方法，您必须拥有的实例<xref:Microsoft.Win32.RegistryKey>类。 若要获取的实例<xref:Microsoft.Win32.RegistryKey>，使用的静态成员之一<xref:Microsoft.Win32.Registry>类。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="subkey" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.Security.SecurityException">用户没有创建或打开注册表项所需的权限。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="permissionCheck" /> 包含无效值。</exception>
        <exception cref="T:System.ObjectDisposedException">调用此方法时所针对的 <see cref="T:Microsoft.Win32.RegistryKey" /> 已关闭（无法访问已关闭的项）。</exception>
        <exception cref="T:System.UnauthorizedAccessException">无法写入当前 <see cref="T:Microsoft.Win32.RegistryKey" />；例如，它未作为可写入项打开，或用户没有必要的访问权限。</exception>
        <exception cref="T:System.IO.IOException">嵌套级别超过 510。  
  
或 
出现系统错误，如删除注册表项，或尝试在 <see cref="F:Microsoft.Win32.Registry.LocalMachine" /> 根中创建注册表项。</exception>
        <permission cref="T:System.Security.Permissions.RegistryPermission">无法修改指定的注册表项，如果存在，或创建注册表键如果的功能它尚不存在。 关联枚举： <see cref="F:System.Security.Permissions.RegistryPermissionAccess.Write" />， <see cref="F:System.Security.Permissions.RegistryPermissionAccess.Create" /></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">它能够访问指定的注册表密钥如果它是一个远程的密钥。 关联的枚举： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="M:Microsoft.Win32.RegistryKey.DeleteSubKey(System.String)" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.OpenSubKey(System.String,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="CreateSubKey">
      <MemberSignature Language="C#" Value="public Microsoft.Win32.RegistryKey CreateSubKey (string subkey, bool writable, Microsoft.Win32.RegistryOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Microsoft.Win32.RegistryKey CreateSubKey(string subkey, bool writable, valuetype Microsoft.Win32.RegistryOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.RegistryKey.CreateSubKey(System.String,System.Boolean,Microsoft.Win32.RegistryOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateSubKey (subkey As String, writable As Boolean, options As RegistryOptions) As RegistryKey" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Microsoft::Win32::RegistryKey ^ CreateSubKey(System::String ^ subkey, bool writable, Microsoft::Win32::RegistryOptions options);" />
      <MemberSignature Language="F#" Value="member this.CreateSubKey : string * bool * Microsoft.Win32.RegistryOptions -&gt; Microsoft.Win32.RegistryKey" Usage="registryKey.CreateSubKey (subkey, writable, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="subkey" Type="System.String" />
        <Parameter Name="writable" Type="System.Boolean" />
        <Parameter Name="options" Type="Microsoft.Win32.RegistryOptions" />
      </Parameters>
      <Docs>
        <param name="subkey">要创建或打开的子项的名称或路径。 此字符串不区分大小写。</param>
        <param name="writable">如果新子项可写入，则为 <see langword="true" />；否则为 <see langword="false" />。</param>
        <param name="options">要使用的注册表选项。</param>
        <summary>创建一个新子项或打开具有指定访问权限的现有子项。  
  
可以开始于 [!INCLUDE[net_v46](~/includes/net-v46-md.md)]</summary>
        <returns>新创建的子项，如果操作失败，则为 <see langword="null" />。 如果为 <paramref name="subkey" /> 指定了长度为零的字符串，则返回当前 <see cref="T:Microsoft.Win32.RegistryKey" /> 对象。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要执行此操作，用户必须具有注册表层次结构中的权限在此级别和更低版本。  
  
> [!CAUTION]
>  不会公开<xref:Microsoft.Win32.RegistryKey>，恶意程序无法创建数千个无意义的子项或键/值对的方式中的对象。 例如，不允许调用方可以输入任意键或值。  
  
 若要使用<xref:Microsoft.Win32.RegistryKey.CreateSubKey%2A>方法，您必须拥有的实例<xref:Microsoft.Win32.RegistryKey>类。 若要获取的实例<xref:Microsoft.Win32.RegistryKey>，使用的静态成员之一<xref:Microsoft.Win32.Registry>类。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="subkey" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="options" /> 未指定有效的选项</exception>
        <exception cref="T:System.Security.SecurityException">用户没有创建或打开注册表项所需的权限。</exception>
        <exception cref="T:System.UnauthorizedAccessException">无法写入当前 <see cref="T:Microsoft.Win32.RegistryKey" />；例如，它未作为可写入项打开，或用户没有必要的访问权限。</exception>
        <exception cref="T:System.IO.IOException">嵌套级别超过 510。  
  
或 
出现系统错误，如删除注册表项，或尝试在 <see cref="F:Microsoft.Win32.Registry.LocalMachine" /> 根中创建注册表项。</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateSubKey">
      <MemberSignature Language="C#" Value="public Microsoft.Win32.RegistryKey CreateSubKey (string subkey, Microsoft.Win32.RegistryKeyPermissionCheck permissionCheck, Microsoft.Win32.RegistryOptions options);" FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.0;netframework-4.8" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Microsoft.Win32.RegistryKey CreateSubKey(string subkey, valuetype Microsoft.Win32.RegistryKeyPermissionCheck permissionCheck, valuetype Microsoft.Win32.RegistryOptions options) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.0;netframework-4.8" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.RegistryKey.CreateSubKey(System.String,Microsoft.Win32.RegistryKeyPermissionCheck,Microsoft.Win32.RegistryOptions)" />
      <MemberSignature Language="C#" Value="public Microsoft.Win32.RegistryKey CreateSubKey (string subkey, Microsoft.Win32.RegistryKeyPermissionCheck permissionCheck, Microsoft.Win32.RegistryOptions registryOptions);" FrameworkAlternate="netcore-2.0;netcore-2.1;dotnet-plat-ext-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Microsoft.Win32.RegistryKey CreateSubKey(string subkey, valuetype Microsoft.Win32.RegistryKeyPermissionCheck permissionCheck, valuetype Microsoft.Win32.RegistryOptions registryOptions) cil managed" FrameworkAlternate="netcore-2.0;netcore-2.1;dotnet-plat-ext-2.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Microsoft::Win32::RegistryKey ^ CreateSubKey(System::String ^ subkey, Microsoft::Win32::RegistryKeyPermissionCheck permissionCheck, Microsoft::Win32::RegistryOptions options);" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateSubKey (subkey As String, permissionCheck As RegistryKeyPermissionCheck, options As RegistryOptions) As RegistryKey" />
      <MemberSignature Language="F#" Value="member this.CreateSubKey : string * Microsoft.Win32.RegistryKeyPermissionCheck * Microsoft.Win32.RegistryOptions -&gt; Microsoft.Win32.RegistryKey" Usage="registryKey.CreateSubKey (subkey, permissionCheck, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="subkey" Type="System.String" Index="0" />
        <Parameter Name="permissionCheck" Type="Microsoft.Win32.RegistryKeyPermissionCheck" Index="1" />
        <Parameter Name="options" Type="Microsoft.Win32.RegistryOptions" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.0;netframework-4.8" />
        <Parameter Name="registryOptions" Type="Microsoft.Win32.RegistryOptions" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;dotnet-plat-ext-2.1" />
      </Parameters>
      <Docs>
        <param name="subkey">要创建或打开的子项的名称或路径。</param>
        <param name="permissionCheck">用于指定打开该项是进行读取还是读取/写入访问的枚举值之一。</param>
        <param name="options">要使用的注册表选项；例如，用于创建可变键的注册表选项。</param>
        <param name="registryOptions">To be added.</param>
        <summary>使用指定的权限检查和注册表选项，创建或打开一个用于写访问的子项。</summary>
        <returns>新创建的子项，如果操作失败，则为 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要获取当前<xref:Microsoft.Win32.RegistryKey>对象，指定一个空字符串 ("") 为`subkey`。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="subkey" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ObjectDisposedException">当前的 <see cref="T:Microsoft.Win32.RegistryKey" /> 对象已关闭（无法访问关闭的项）。</exception>
        <exception cref="T:System.UnauthorizedAccessException">无法写入当前 <see cref="T:Microsoft.Win32.RegistryKey" /> 对象；例如，它未作为可写入项打开，或用户不具有所需的访问权限。</exception>
        <exception cref="T:System.IO.IOException">嵌套级别超过 510。  
  
或 
发生系统错误，例如，删除了项，或者尝试在 <see cref="F:Microsoft.Win32.Registry.LocalMachine" /> 根中创建项。</exception>
        <exception cref="T:System.Security.SecurityException">用户没有创建或打开注册表项所需的权限。</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateSubKey">
      <MemberSignature Language="C#" Value="public Microsoft.Win32.RegistryKey CreateSubKey (string subkey, Microsoft.Win32.RegistryKeyPermissionCheck permissionCheck, Microsoft.Win32.RegistryOptions registryOptions, System.Security.AccessControl.RegistrySecurity registrySecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Microsoft.Win32.RegistryKey CreateSubKey(string subkey, valuetype Microsoft.Win32.RegistryKeyPermissionCheck permissionCheck, valuetype Microsoft.Win32.RegistryOptions registryOptions, class System.Security.AccessControl.RegistrySecurity registrySecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.RegistryKey.CreateSubKey(System.String,Microsoft.Win32.RegistryKeyPermissionCheck,Microsoft.Win32.RegistryOptions,System.Security.AccessControl.RegistrySecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Microsoft::Win32::RegistryKey ^ CreateSubKey(System::String ^ subkey, Microsoft::Win32::RegistryKeyPermissionCheck permissionCheck, Microsoft::Win32::RegistryOptions registryOptions, System::Security::AccessControl::RegistrySecurity ^ registrySecurity);" />
      <MemberSignature Language="F#" Value="member this.CreateSubKey : string * Microsoft.Win32.RegistryKeyPermissionCheck * Microsoft.Win32.RegistryOptions * System.Security.AccessControl.RegistrySecurity -&gt; Microsoft.Win32.RegistryKey" Usage="registryKey.CreateSubKey (subkey, permissionCheck, registryOptions, registrySecurity)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="subkey" Type="System.String" />
        <Parameter Name="permissionCheck" Type="Microsoft.Win32.RegistryKeyPermissionCheck" />
        <Parameter Name="registryOptions" Type="Microsoft.Win32.RegistryOptions" />
        <Parameter Name="registrySecurity" Type="System.Security.AccessControl.RegistrySecurity" />
      </Parameters>
      <Docs>
        <param name="subkey">要创建或打开的子项的名称或路径。</param>
        <param name="permissionCheck">用于指定打开该项是进行读取还是读取/写入访问的枚举值之一。</param>
        <param name="registryOptions">要使用的注册表选项。</param>
        <param name="registrySecurity">新子项的访问控制安全性。</param>
        <summary>使用指定的权限检查选项、注册表选项和注册表安全性，创建或打开一个用于写访问的子项。</summary>
        <returns>新创建的子项，如果操作失败，则为 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要获取当前<xref:Microsoft.Win32.RegistryKey>对象，指定一个空字符串 ("") 为`subkey`。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="subkey" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ObjectDisposedException">当前的 <see cref="T:Microsoft.Win32.RegistryKey" /> 对象被关闭。 无法访问已关闭的项。</exception>
        <exception cref="T:System.UnauthorizedAccessException">无法写入当前 <see cref="T:Microsoft.Win32.RegistryKey" /> 对象；例如，它未作为可写入项打开，或用户不具有所需的访问权限。</exception>
        <exception cref="T:System.IO.IOException">嵌套级别超过 510。  
  
或 
发生系统错误，例如，删除了项，或者尝试在 <see cref="F:Microsoft.Win32.Registry.LocalMachine" /> 根中创建项。</exception>
        <exception cref="T:System.Security.SecurityException">用户没有创建或打开注册表项所需的权限。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="DeleteSubKey">
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>删除指定子项。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DeleteSubKey">
      <MemberSignature Language="C#" Value="public void DeleteSubKey (string subkey);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DeleteSubKey(string subkey) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.RegistryKey.DeleteSubKey(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub DeleteSubKey (subkey As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DeleteSubKey(System::String ^ subkey);" />
      <MemberSignature Language="F#" Value="member this.DeleteSubKey : string -&gt; unit" Usage="registryKey.DeleteSubKey subkey" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="subkey" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="subkey">要删除的子项的名称。 此字符串不区分大小写。</param>
        <summary>删除指定子项。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要删除子级子项，请使用<xref:Microsoft.Win32.RegistryKey.DeleteSubKeyTree%2A>。  
  
 删除注册表项时要格外小心。  
  
   
  
## Examples  
 下面的示例演示如何使用<xref:Microsoft.Win32.RegistryKey.DeleteSubKey%2A>。  
  
 [!code-cpp[Microsoft.Win32.RegistryKey2#5](~/samples/snippets/cpp/VS_Snippets_CLR/Microsoft.Win32.RegistryKey2/CPP/source2.cpp#5)]
 [!code-csharp[Microsoft.Win32.RegistryKey2#5](~/samples/snippets/csharp/VS_Snippets_CLR/Microsoft.Win32.RegistryKey2/CS/source2.cs#5)]
 [!code-vb[Microsoft.Win32.RegistryKey2#5](~/samples/snippets/visualbasic/VS_Snippets_CLR/Microsoft.Win32.RegistryKey2/VB/source2.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="subkey" /> 有子级子项</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="subkey" /> 参数未指定有效的注册表项</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="subkey" /> 为 <see langword="null" /></exception>
        <exception cref="T:System.Security.SecurityException">用户没有删除该项所需的权限。</exception>
        <exception cref="T:System.ObjectDisposedException">要操作的 <see cref="T:Microsoft.Win32.RegistryKey" /> 已关闭（无法访问关闭的项）。</exception>
        <exception cref="T:System.UnauthorizedAccessException">用户没有必需的注册表权限。</exception>
        <permission cref="T:System.Security.Permissions.RegistryPermission">有关修改指定的注册表项的功能。 关联的枚举： <see cref="F:System.Security.Permissions.RegistryPermissionAccess.Write" /></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">它能够访问指定的注册表密钥如果它是一个远程的密钥。 关联的枚举： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="M:Microsoft.Win32.RegistryKey.DeleteSubKeyTree(System.String)" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.CreateSubKey(System.String)" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.DeleteValue(System.String)" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.GetSubKeyNames" />
      </Docs>
    </Member>
    <Member MemberName="DeleteSubKey">
      <MemberSignature Language="C#" Value="public void DeleteSubKey (string subkey, bool throwOnMissingSubKey);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DeleteSubKey(string subkey, bool throwOnMissingSubKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.RegistryKey.DeleteSubKey(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub DeleteSubKey (subkey As String, throwOnMissingSubKey As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DeleteSubKey(System::String ^ subkey, bool throwOnMissingSubKey);" />
      <MemberSignature Language="F#" Value="member this.DeleteSubKey : string * bool -&gt; unit" Usage="registryKey.DeleteSubKey (subkey, throwOnMissingSubKey)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="subkey" Type="System.String" />
        <Parameter Name="throwOnMissingSubKey" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="subkey">要删除的子项的名称。 此字符串不区分大小写。</param>
        <param name="throwOnMissingSubKey">指示在找不到指定子项的情况下是否引发异常。 如果该参数为 <see langword="true" />，并且指定的子项不存在，则引发异常。 如果该参数为 <see langword="false" />，并且指定的子项不存在，则不执行任何操作。</param>
        <summary>删除指定的子项，并指定在找不到该子项时是否引发异常。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要删除子级子项，请使用<xref:Microsoft.Win32.RegistryKey.DeleteSubKeyTree%2A>。  
  
 删除注册表项时要格外小心。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="subkey" /> 有子级子项。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="subkey" /> 未指定有效的注册表项，并且 <paramref name="throwOnMissingSubKey" /> 为 <see langword="true" />。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="subkey" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.Security.SecurityException">用户没有删除该项所需的权限。</exception>
        <exception cref="T:System.ObjectDisposedException">要操作的 <see cref="T:Microsoft.Win32.RegistryKey" /> 已关闭（无法访问关闭的项）。</exception>
        <exception cref="T:System.UnauthorizedAccessException">用户没有必需的注册表权限。</exception>
        <permission cref="T:System.Security.Permissions.RegistryPermission">有关修改指定的注册表项的功能。 关联的枚举： <see cref="F:System.Security.Permissions.RegistryPermissionAccess.Write" /></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">它能够访问指定的注册表密钥如果它是一个远程的密钥。 关联的枚举： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="M:Microsoft.Win32.RegistryKey.DeleteSubKeyTree(System.String)" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.CreateSubKey(System.String)" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.DeleteValue(System.String)" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.GetSubKeyNames" />
      </Docs>
    </Member>
    <MemberGroup MemberName="DeleteSubKeyTree">
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>使用可选的异常处理方以递归方式删除一个子项以及任何子级子项。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DeleteSubKeyTree">
      <MemberSignature Language="C#" Value="public void DeleteSubKeyTree (string subkey);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DeleteSubKeyTree(string subkey) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.RegistryKey.DeleteSubKeyTree(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub DeleteSubKeyTree (subkey As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DeleteSubKeyTree(System::String ^ subkey);" />
      <MemberSignature Language="F#" Value="member this.DeleteSubKeyTree : string -&gt; unit" Usage="registryKey.DeleteSubKeyTree subkey" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="subkey" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="subkey">要删除的子项。 此字符串不区分大小写。</param>
        <summary>递归删除子项和任何子级子项。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 必须具有适当权限才能删除子项，并且其树。  
  
> [!CAUTION]
>  删除特定密钥将在树中删除该密钥下的所有项。 将不提供任何警告。 如果你想要删除一个子项，仅在不必须使用任何子级子项时<xref:Microsoft.Win32.RegistryKey.DeleteSubKey%2A>方法。  
  
   
  
## Examples  
 此代码示例是为提供一个更大示例的一部分<xref:Microsoft.Win32.RegistryKey>类。  
  
 [!code-cpp[Microsoft.Win32.RegistryKey2#4](~/samples/snippets/cpp/VS_Snippets_CLR/Microsoft.Win32.RegistryKey2/CPP/source.cpp#4)]
 [!code-csharp[Microsoft.Win32.RegistryKey2#4](~/samples/snippets/csharp/VS_Snippets_CLR/Microsoft.Win32.RegistryKey2/CS/source.cs#4)]
 [!code-vb[Microsoft.Win32.RegistryKey2#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/Microsoft.Win32.RegistryKey2/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="subkey" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">尝试删除根配置单元。  
  
或 
 <paramref name="subkey" /> 未指定有效的注册表子项。</exception>
        <exception cref="T:System.IO.IOException">发生了 I/O 错误。</exception>
        <exception cref="T:System.Security.SecurityException">用户没有删除该项所需的权限。</exception>
        <exception cref="T:System.ObjectDisposedException">要操作的 <see cref="T:Microsoft.Win32.RegistryKey" /> 已关闭（无法访问关闭的项）。</exception>
        <exception cref="T:System.UnauthorizedAccessException">用户没有必需的注册表权限。</exception>
        <permission cref="T:System.Security.Permissions.RegistryPermission">有关修改指定的注册表项的功能。 关联的枚举： <see cref="F:System.Security.Permissions.RegistryPermissionAccess.Write" /></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">它能够访问指定的注册表密钥如果它是一个远程的密钥。 关联的枚举： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="M:Microsoft.Win32.RegistryKey.DeleteSubKey(System.String)" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.CreateSubKey(System.String)" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.DeleteValue(System.String)" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.GetSubKeyNames" />
        <altmember cref="P:Microsoft.Win32.RegistryKey.SubKeyCount" />
      </Docs>
    </Member>
    <Member MemberName="DeleteSubKeyTree">
      <MemberSignature Language="C#" Value="public void DeleteSubKeyTree (string subkey, bool throwOnMissingSubKey);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DeleteSubKeyTree(string subkey, bool throwOnMissingSubKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.RegistryKey.DeleteSubKeyTree(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub DeleteSubKeyTree (subkey As String, throwOnMissingSubKey As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DeleteSubKeyTree(System::String ^ subkey, bool throwOnMissingSubKey);" />
      <MemberSignature Language="F#" Value="member this.DeleteSubKeyTree : string * bool -&gt; unit" Usage="registryKey.DeleteSubKeyTree (subkey, throwOnMissingSubKey)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="subkey" Type="System.String" />
        <Parameter Name="throwOnMissingSubKey" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="subkey">要删除的子项的名称。 此字符串不区分大小写。</param>
        <param name="throwOnMissingSubKey">指示在找不到指定子项的情况下是否引发异常。 如果该参数为 <see langword="true" />，并且指定的子项不存在，则引发异常。 如果该参数为 <see langword="false" />，并且指定的子项不存在，则不执行任何操作。</param>
        <summary>以递归方式删除指定的子项和任何子级子项，并指定在找不到子项时是否引发异常。</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">尝试删除树的根配置单元。  
  
或 
 <paramref name="subkey" /> 未指定有效的注册表子项，并且 <paramref name="throwOnMissingSubKey" /> 为 <see langword="true" />。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="subkey" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:Microsoft.Win32.RegistryKey" /> 已关闭（无法访问已关闭的项）。</exception>
        <exception cref="T:System.UnauthorizedAccessException">用户没有必需的注册表权限。</exception>
        <exception cref="T:System.Security.SecurityException">用户没有删除该项所需的权限。</exception>
        <permission cref="T:System.Security.Permissions.RegistryPermission">有关修改指定的注册表项的功能。 关联的枚举： <see cref="F:System.Security.Permissions.RegistryPermissionAccess.Write" /></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">它能够访问指定的注册表密钥如果它是一个远程的密钥。 关联的枚举： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="DeleteValue">
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>从此项中删除指定的值，并在找不到该值时引发异常。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DeleteValue">
      <MemberSignature Language="C#" Value="public void DeleteValue (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DeleteValue(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.RegistryKey.DeleteValue(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub DeleteValue (name As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DeleteValue(System::String ^ name);" />
      <MemberSignature Language="F#" Value="member this.DeleteValue : string -&gt; unit" Usage="registryKey.DeleteValue name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">要删除的值的名称。</param>
        <summary>从此项中删除指定值。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在 Windows 95、 Windows 98、 Windows 98 Second Edition 和 Windows Millennium Edition 上，指定空字符串作为`name`参数不会删除默认值。  
  
   
  
## Examples  
 此代码示例是为提供一个更大示例的一部分<xref:Microsoft.Win32.RegistryKey>类。  
  
 [!code-cpp[Microsoft.Win32.RegistryKey2#3](~/samples/snippets/cpp/VS_Snippets_CLR/Microsoft.Win32.RegistryKey2/CPP/source.cpp#3)]
 [!code-csharp[Microsoft.Win32.RegistryKey2#3](~/samples/snippets/csharp/VS_Snippets_CLR/Microsoft.Win32.RegistryKey2/CS/source.cs#3)]
 [!code-vb[Microsoft.Win32.RegistryKey2#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/Microsoft.Win32.RegistryKey2/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> 不是对值的有效引用。</exception>
        <exception cref="T:System.Security.SecurityException">用户没有删除该值所需的权限。</exception>
        <exception cref="T:System.ObjectDisposedException">要操作的 <see cref="T:Microsoft.Win32.RegistryKey" /> 已关闭（无法访问关闭的项）。</exception>
        <exception cref="T:System.UnauthorizedAccessException">正在处理的 <see cref="T:Microsoft.Win32.RegistryKey" /> 为只读。</exception>
        <permission cref="T:System.Security.Permissions.RegistryPermission">用于删除指定的注册表项的功能。 关联的枚举： <see cref="F:System.Security.Permissions.RegistryPermissionAccess.Write" /></permission>
        <altmember cref="M:Microsoft.Win32.RegistryKey.DeleteSubKey(System.String)" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.OpenSubKey(System.String,System.Boolean)" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.GetValue(System.String)" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.GetValueNames" />
        <altmember cref="P:Microsoft.Win32.RegistryKey.ValueCount" />
      </Docs>
    </Member>
    <Member MemberName="DeleteValue">
      <MemberSignature Language="C#" Value="public void DeleteValue (string name, bool throwOnMissingValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DeleteValue(string name, bool throwOnMissingValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.RegistryKey.DeleteValue(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub DeleteValue (name As String, throwOnMissingValue As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DeleteValue(System::String ^ name, bool throwOnMissingValue);" />
      <MemberSignature Language="F#" Value="member this.DeleteValue : string * bool -&gt; unit" Usage="registryKey.DeleteValue (name, throwOnMissingValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="throwOnMissingValue" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="name">要删除的值的名称。</param>
        <param name="throwOnMissingValue">指示在找不到指定值的情况下是否引发异常。 如果该参数为 <see langword="true" />，并且指定的值不存在，则引发异常。 如果该参数为 <see langword="false" />，并且指定的值不存在，则不执行任何操作。</param>
        <summary>从此项中删除指定的值，并指定在找不到该值时是否引发异常。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果`throwOnMissingValue`是`false`，没有办法指示如果已成功删除，而无需随后尝试访问刚刚删除的值。 因此，这种方式在注册表中删除值时要小心。  
  
 在 Windows 95、 Windows 98、 Windows 98 Second Edition 和 Windows Millennium Edition 上，指定空字符串作为`name`参数不会删除默认值。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> 不是对值的有效引用，并且 <paramref name="throwOnMissingValue" /> 为 <see langword="true" />。  
  
或 
 <paramref name="name" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.Security.SecurityException">用户没有删除该值所需的权限。</exception>
        <exception cref="T:System.ObjectDisposedException">要操作的 <see cref="T:Microsoft.Win32.RegistryKey" /> 已关闭（无法访问关闭的项）。</exception>
        <exception cref="T:System.UnauthorizedAccessException">正在处理的 <see cref="T:Microsoft.Win32.RegistryKey" /> 为只读。</exception>
        <permission cref="T:System.Security.Permissions.RegistryPermission">用于删除指定的注册表项的功能。 关联的枚举： <see cref="F:System.Security.Permissions.RegistryPermissionAccess.Write" /></permission>
        <altmember cref="M:Microsoft.Win32.RegistryKey.DeleteSubKey(System.String)" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.OpenSubKey(System.String,System.Boolean)" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.GetValue(System.String)" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.GetValueNames" />
        <altmember cref="P:Microsoft.Win32.RegistryKey.ValueCount" />
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.RegistryKey.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="registryKey.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>释放 <see cref="T:Microsoft.Win32.RegistryKey" /> 类的当前实例所使用的所有资源。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在完成使用 `Dispose` 后，应调用 <xref:Microsoft.Win32.RegistryKey>。 `Dispose` 方法使 <xref:Microsoft.Win32.RegistryKey> 处于不可用状态。 在调用`Dispose`，必须释放对所有引用<xref:Microsoft.Win32.RegistryKey>这样垃圾回收器才能收回内存的<xref:Microsoft.Win32.RegistryKey>占用。  
  
 有关详细信息，请参阅[清理了非托管资源](~/docs/standard/garbage-collection/unmanaged.md)并[实现 Dispose 方法](~/docs/standard/garbage-collection/implementing-dispose.md)。  
  
> [!NOTE]
>  每次释放对 `Dispose` 的最后一个引用前，均应调用 <xref:Microsoft.Win32.RegistryKey>。 否则，在垃圾回收器调用 <xref:Microsoft.Win32.RegistryKey> 对象的 `Finalize` 方法之前，该对象正在使用的资源不会被释放。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~RegistryKey ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.RegistryKey.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!RegistryKey ()" />
      <MemberSignature Language="F#" Value="override this.Finalize : unit -&gt; unit" Usage="registryKey.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Flush">
      <MemberSignature Language="C#" Value="public void Flush ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Flush() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.RegistryKey.Flush" />
      <MemberSignature Language="VB.NET" Value="Public Sub Flush ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Flush();" />
      <MemberSignature Language="F#" Value="member this.Flush : unit -&gt; unit" Usage="registryKey.Flush " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>将指定的打开注册表项的全部特性写到注册表中。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 不需要调用`Flush`写出对项的更改。 注册表更改刷新到磁盘时注册表使用其惰性刷新器。 惰性刷新会自动地定期系统指定的时间间隔后。 注册表更改也会刷新到磁盘上的系统关闭。  
  
 与不同<xref:Microsoft.Win32.RegistryKey.Close%2A>，则`Flush`函数将返回仅当所有数据都写入注册表。  
  
 `Flush`函数还可能写出的部分或所有其他密钥。 过度调用此函数可以具有负面影响应用程序的性能。  
  
 应用程序应只调用`Flush`如果它必须是绝对某些注册表更改记录到磁盘。 一般情况下，`Flush`很少需要使用即使有的话。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.Win32.RegistryKey.Close" />
      </Docs>
    </Member>
    <MemberGroup MemberName="FromHandle">
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>根据指定的句柄创建注册表项。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FromHandle">
      <MemberSignature Language="C#" Value="public static Microsoft.Win32.RegistryKey FromHandle (Microsoft.Win32.SafeHandles.SafeRegistryHandle handle);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.Win32.RegistryKey FromHandle(class Microsoft.Win32.SafeHandles.SafeRegistryHandle handle) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.RegistryKey.FromHandle(Microsoft.Win32.SafeHandles.SafeRegistryHandle)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FromHandle (handle As SafeRegistryHandle) As RegistryKey" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Microsoft::Win32::RegistryKey ^ FromHandle(Microsoft::Win32::SafeHandles::SafeRegistryHandle ^ handle);" />
      <MemberSignature Language="F#" Value="static member FromHandle : Microsoft.Win32.SafeHandles.SafeRegistryHandle -&gt; Microsoft.Win32.RegistryKey" Usage="Microsoft.Win32.RegistryKey.FromHandle handle" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="handle" Type="Microsoft.Win32.SafeHandles.SafeRegistryHandle" />
      </Parameters>
      <Docs>
        <param name="handle">注册表项的句柄。</param>
        <summary>根据指定的句柄创建注册表项。</summary>
        <returns>注册表项。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="handle" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.UnauthorizedAccessException">用户没有必需的注册表权限。</exception>
        <exception cref="T:System.Security.SecurityException">用户没有执行此操作所需的权限。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直接调用方需要完全信任。 不能由部分受信任的或透明的代码使用此成员。</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">它能够访问指定的注册表密钥如果它是一个远程的密钥。 关联的枚举： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="FromHandle">
      <MemberSignature Language="C#" Value="public static Microsoft.Win32.RegistryKey FromHandle (Microsoft.Win32.SafeHandles.SafeRegistryHandle handle, Microsoft.Win32.RegistryView view);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.Win32.RegistryKey FromHandle(class Microsoft.Win32.SafeHandles.SafeRegistryHandle handle, valuetype Microsoft.Win32.RegistryView view) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.RegistryKey.FromHandle(Microsoft.Win32.SafeHandles.SafeRegistryHandle,Microsoft.Win32.RegistryView)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FromHandle (handle As SafeRegistryHandle, view As RegistryView) As RegistryKey" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Microsoft::Win32::RegistryKey ^ FromHandle(Microsoft::Win32::SafeHandles::SafeRegistryHandle ^ handle, Microsoft::Win32::RegistryView view);" />
      <MemberSignature Language="F#" Value="static member FromHandle : Microsoft.Win32.SafeHandles.SafeRegistryHandle * Microsoft.Win32.RegistryView -&gt; Microsoft.Win32.RegistryKey" Usage="Microsoft.Win32.RegistryKey.FromHandle (handle, view)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="handle" Type="Microsoft.Win32.SafeHandles.SafeRegistryHandle" />
        <Parameter Name="view" Type="Microsoft.Win32.RegistryView" />
      </Parameters>
      <Docs>
        <param name="handle">注册表项的句柄。</param>
        <param name="view">要使用的注册表视图。</param>
        <summary>利用指定的句柄和注册表视图设置创建注册表项。</summary>
        <returns>注册表项。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `view`后续操作，例如打开子项中使用此方法的参数。  
  
 如果`view`是<xref:Microsoft.Win32.RegistryView.Registry64>但是计算机正在运行 32 位操作系统，则返回的键将使用<xref:Microsoft.Win32.RegistryView.Registry32>视图。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="view" /> 无效。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="handle" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.UnauthorizedAccessException">用户没有必需的注册表权限。</exception>
        <exception cref="T:System.Security.SecurityException">用户没有执行此操作所需的权限。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直接调用方需要完全信任。 不能由部分受信任的或透明的代码使用此成员。</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">它能够访问指定的注册表密钥如果它是一个远程的密钥。 关联的枚举： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetAccessControl">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>返回当前注册表项的访问控制安全性。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetAccessControl">
      <MemberSignature Language="C#" Value="public System.Security.AccessControl.RegistrySecurity GetAccessControl ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Security.AccessControl.RegistrySecurity GetAccessControl() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.RegistryKey.GetAccessControl" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAccessControl () As RegistrySecurity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Security::AccessControl::RegistrySecurity ^ GetAccessControl();" />
      <MemberSignature Language="F#" Value="member this.GetAccessControl : unit -&gt; System.Security.AccessControl.RegistrySecurity" Usage="registryKey.GetAccessControl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.AccessControl.RegistrySecurity</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回当前注册表项的访问控制安全性。</summary>
        <returns>一个对象，该对象描述针对由当前 <see cref="T:Microsoft.Win32.RegistryKey" /> 表示的注册表项的访问控制权限。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法的重载是等效于调用<xref:Microsoft.Win32.RegistryKey.GetAccessControl%28System.Security.AccessControl.AccessControlSections%29>方法的重载下列标志的按位组合： <xref:System.Security.AccessControl.AccessControlSections.Access?displayProperty=nameWithType>， <xref:System.Security.AccessControl.AccessControlSections.Owner?displayProperty=nameWithType>，和<xref:System.Security.AccessControl.AccessControlSections.Group?displayProperty=nameWithType>。 该重载可用于搜索的其他权限。  
  
 用户必须具有<xref:System.Security.AccessControl.RegistryRights.ReadPermissions?displayProperty=nameWithType>权限才能调用此方法。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">用户没有必要的权限。</exception>
        <exception cref="T:System.ObjectDisposedException">要操作的 <see cref="T:Microsoft.Win32.RegistryKey" /> 已关闭（无法访问关闭的项）。</exception>
        <exception cref="T:System.InvalidOperationException">当前项已被删除。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetAccessControl">
      <MemberSignature Language="C#" Value="public System.Security.AccessControl.RegistrySecurity GetAccessControl (System.Security.AccessControl.AccessControlSections includeSections);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Security.AccessControl.RegistrySecurity GetAccessControl(valuetype System.Security.AccessControl.AccessControlSections includeSections) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.RegistryKey.GetAccessControl(System.Security.AccessControl.AccessControlSections)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAccessControl (includeSections As AccessControlSections) As RegistrySecurity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Security::AccessControl::RegistrySecurity ^ GetAccessControl(System::Security::AccessControl::AccessControlSections includeSections);" />
      <MemberSignature Language="F#" Value="member this.GetAccessControl : System.Security.AccessControl.AccessControlSections -&gt; System.Security.AccessControl.RegistrySecurity" Usage="registryKey.GetAccessControl includeSections" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.AccessControl.RegistrySecurity</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="includeSections" Type="System.Security.AccessControl.AccessControlSections" />
      </Parameters>
      <Docs>
        <param name="includeSections">枚举值的按位组合，它指定要获取的安全信息类型。</param>
        <summary>返回当前注册表项的访问控制安全性的指定部分。</summary>
        <returns>一个对象，该对象描述针对由当前 <see cref="T:Microsoft.Win32.RegistryKey" /> 表示的注册表项的访问控制权限。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要请求当前向用户授予的访问权限，指定以下标志的按位组合： <xref:System.Security.AccessControl.AccessControlSections.Access?displayProperty=nameWithType>， <xref:System.Security.AccessControl.AccessControlSections.Owner?displayProperty=nameWithType>，和<xref:System.Security.AccessControl.AccessControlSections.Group?displayProperty=nameWithType>。 或者，可以使用<xref:Microsoft.Win32.RegistryKey.GetAccessControl>方法重载，它指定确切的值的组合。  
  
 用户必须具有<xref:System.Security.AccessControl.RegistryRights.ReadPermissions?displayProperty=nameWithType>权限才能调用此方法。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">用户没有必要的权限。</exception>
        <exception cref="T:System.ObjectDisposedException">要操作的 <see cref="T:Microsoft.Win32.RegistryKey" /> 已关闭（无法访问关闭的项）。</exception>
        <exception cref="T:System.InvalidOperationException">当前项已被删除。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetSubKeyNames">
      <MemberSignature Language="C#" Value="public string[] GetSubKeyNames ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] GetSubKeyNames() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.RegistryKey.GetSubKeyNames" />
      <MemberSignature Language="VB.NET" Value="Public Function GetSubKeyNames () As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ GetSubKeyNames();" />
      <MemberSignature Language="F#" Value="member this.GetSubKeyNames : unit -&gt; string[]" Usage="registryKey.GetSubKeyNames " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>检索包含所有子项名称的字符串数组。</summary>
        <returns>包含当前项的子项名称的字符串数组。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法执行不是以递归方式查找名称。 它调用它的基级上返回的名称。  
  
   
  
## Examples  
 此代码示例是为提供一个更大示例的一部分<xref:Microsoft.Win32.RegistryKey>类。  
  
 [!code-cpp[Microsoft.Win32.RegistryKey2#2](~/samples/snippets/cpp/VS_Snippets_CLR/Microsoft.Win32.RegistryKey2/CPP/source.cpp#2)]
 [!code-csharp[Microsoft.Win32.RegistryKey2#2](~/samples/snippets/csharp/VS_Snippets_CLR/Microsoft.Win32.RegistryKey2/CS/source.cs#2)]
 [!code-vb[Microsoft.Win32.RegistryKey2#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Microsoft.Win32.RegistryKey2/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">用户没有读取该项所需的权限。</exception>
        <exception cref="T:System.ObjectDisposedException">要操作的 <see cref="T:Microsoft.Win32.RegistryKey" /> 已关闭（无法访问关闭的项）。</exception>
        <exception cref="T:System.UnauthorizedAccessException">用户没有必需的注册表权限。</exception>
        <exception cref="T:System.IO.IOException">发生系统错误，例如，当前项已被删除。</exception>
        <permission cref="T:System.Security.Permissions.RegistryPermission">有关从注册表中读取的功能。 关联的枚举： <see cref="F:System.Security.Permissions.RegistryPermissionAccess.Read" /></permission>
        <altmember cref="P:Microsoft.Win32.RegistryKey.SubKeyCount" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.GetValueNames" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetValue">
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>检索与指定名称关联的值。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public object GetValue (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetValue(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.RegistryKey.GetValue(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetValue (name As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetValue(System::String ^ name);" />
      <MemberSignature Language="F#" Value="member this.GetValue : string -&gt; obj" Usage="registryKey.GetValue name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">要检索的值的名称。 此字符串不区分大小写。</param>
        <summary>检索与指定名称关联的值。 如果注册表中不存在名称/值对，则返回 <see langword="null" />。</summary>
        <returns>与 <paramref name="name" /> 关联的值；如果未找到 <paramref name="name" />，则为 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  注册表项可以具有不与任何名称相关联的一个值。 在注册表编辑器中显示此未命名的值时，而不是名称将显示字符串"(Default)"。 若要检索此未命名的值，指定`null`或空字符串 ("") 为`name`。  
  
 当<xref:Microsoft.Win32.RegistryKey.GetValue%2A>方法检索可扩充字符串值 (<xref:Microsoft.Win32.RegistryValueKind.ExpandString?displayProperty=nameWithType>)，它将展开使用本地环境中的数据的环境字符串。 若要从远程计算机上的注册表中检索可扩充字符串值，请使用<xref:Microsoft.Win32.RegistryKey.GetValue%28System.String%2CSystem.Object%2CMicrosoft.Win32.RegistryValueOptions%29>方法重载来指定不希望扩展的环境字符串。  
  
> [!NOTE]
>  如果已存储为一个字符串值，该值包含对环境变量的可展开引用 (<xref:Microsoft.Win32.RegistryValueKind.String?displayProperty=nameWithType>)，而不是可扩展字符串 (<xref:Microsoft.Win32.RegistryValueKind.ExpandString?displayProperty=nameWithType>)，<xref:Microsoft.Win32.RegistryKey.GetValue%2A>不会展开它。 检索通过调用后，可以扩展此类字符串<xref:System.Environment.ExpandEnvironmentVariables%2A>方法。  
  
> [!NOTE]
>  要从中检索数据的建议<xref:Microsoft.Win32.Registry.PerformanceData>密钥是使用<xref:System.Diagnostics.PerformanceCounter>类而不是<xref:Microsoft.Win32.RegistryKey.GetValue%2A?displayProperty=nameWithType>方法。  
>   
>  <xref:Microsoft.Win32.RegistryKey.GetValue%2A> 不支持类型为 REG_NONE 或 REG_LINK 中读取的值。  在这两种情况下，默认值 (`null`) 返回而不是实际值。  
  
   
  
## Examples  
 下面的代码示例创建一个测试项，并将不同的数据类型的值添加到该密钥。 该示例然后读取名称/值对，并将其显示在控制台中，使用<xref:Microsoft.Win32.RegistryKey.GetValueKind%2A>方法来检索相应的注册表数据类型。  
  
 [!code-cpp[Microsoft.Win32.RegistryValueKind#1](~/samples/snippets/cpp/VS_Snippets_CLR/Microsoft.Win32.RegistryValueKind/CPP/source.cpp#1)]
 [!code-csharp[Microsoft.Win32.RegistryValueKind#1](~/samples/snippets/csharp/VS_Snippets_CLR/Microsoft.Win32.RegistryValueKind/CS/source.cs#1)]
 [!code-vb[Microsoft.Win32.RegistryValueKind#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Microsoft.Win32.RegistryValueKind/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">该用户没有读取注册表项所需的权限。</exception>
        <exception cref="T:System.ObjectDisposedException">包含指定值的 <see cref="T:Microsoft.Win32.RegistryKey" /> 已关闭（无法访问关闭的项）。</exception>
        <exception cref="T:System.IO.IOException">包含指定值的 <see cref="T:Microsoft.Win32.RegistryKey" /> 已标记为删除。</exception>
        <exception cref="T:System.UnauthorizedAccessException">用户没有必需的注册表权限。</exception>
        <permission cref="T:System.Security.Permissions.RegistryPermission">若要从注册表中读取。 关联的枚举： <see cref="F:System.Security.Permissions.RegistryPermissionAccess.Read" /></permission>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">若要读取注册表项的类型 REG_EXPAND_SZ。 关联的枚举： <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
        <altmember cref="M:Microsoft.Win32.RegistryKey.GetValueNames" />
        <altmember cref="Overload:Microsoft.Win32.RegistryKey.SetValue" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.DeleteValue(System.String)" />
        <altmember cref="P:Microsoft.Win32.RegistryKey.ValueCount" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.GetSubKeyNames" />
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public object GetValue (string name, object defaultValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetValue(string name, object defaultValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.RegistryKey.GetValue(System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetValue (name As String, defaultValue As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetValue(System::String ^ name, System::Object ^ defaultValue);" />
      <MemberSignature Language="F#" Value="member this.GetValue : string * obj -&gt; obj" Usage="registryKey.GetValue (name, defaultValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="defaultValue" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="name">要检索的值的名称。 此字符串不区分大小写。</param>
        <param name="defaultValue">当 <c>name</c> 不存在时要返回的值。</param>
        <summary>检索与指定名称关联的值。 如果未找到名称，则返回你提供的默认值。</summary>
        <returns>与 <paramref name="name" /> 关联的值，不展开嵌入的任何环境变量；如果未找到 <paramref name="defaultValue" />，则为 <paramref name="name" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 请使用此重载<xref:Microsoft.Win32.RegistryKey.GetValue%2A>以处理其中尚不存在名称的情况 — 例如，首次运行应用程序。 只要调用此重载，可使用`defaultValue`参数来指定要返回的值`name`不存在。  
  
> [!NOTE]
>  注册表项可以具有不与任何名称相关联的一个值。 在注册表编辑器中显示此未命名的值时，而不是名称将显示字符串"(Default)"。 若要检索此未命名的值，指定`null`或空字符串 ("") 为`name`。  
  
 当<xref:Microsoft.Win32.RegistryKey.GetValue%2A>方法检索可扩充字符串值 (<xref:Microsoft.Win32.RegistryValueKind.ExpandString?displayProperty=nameWithType>)，它将展开使用本地环境中的数据的环境字符串。 若要从远程计算机上的注册表中检索可扩充字符串值，请使用<xref:Microsoft.Win32.RegistryKey.GetValue%2A>重载来指定不希望扩展的环境字符串。  
  
> [!NOTE]
>  如果已存储为一个字符串值，该值包含对环境变量的可展开引用 (<xref:Microsoft.Win32.RegistryValueKind.String?displayProperty=nameWithType>)，而不是可扩展字符串 (<xref:Microsoft.Win32.RegistryValueKind.ExpandString?displayProperty=nameWithType>)，则<xref:Microsoft.Win32.RegistryKey.GetValue%2A>方法不会展开。 检索通过调用后，可以扩展此类字符串<xref:System.Environment.ExpandEnvironmentVariables%2A>方法。  
  
> [!NOTE]
>  要从中检索数据的建议<xref:Microsoft.Win32.Registry.PerformanceData>密钥是使用<xref:System.Diagnostics.PerformanceCounter>类而不是<xref:Microsoft.Win32.RegistryKey.GetValue%2A?displayProperty=nameWithType>方法。  
>   
>  <xref:Microsoft.Win32.RegistryKey.GetValue%2A> 不支持类型为 REG_NONE 或 REG_LINK 中读取的值。  在这两种情况下，默认值 (`null`) 返回而不是实际值。  
  
   
  
## Examples  
 下面的代码示例将创建一个测试项具有值，并检索该值。 然后，此示例尝试检索该密钥; 不存在的值在这种情况下<xref:Microsoft.Win32.RegistryKey.GetValue%2A>方法将返回指定的默认值。  
  
 [!code-cpp[Classic RegistryKey.GetValue Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic RegistryKey.GetValue Example/CPP/source.cpp#1)]
 [!code-csharp[Classic RegistryKey.GetValue Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic RegistryKey.GetValue Example/CS/source.cs#1)]
 [!code-vb[Classic RegistryKey.GetValue Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic RegistryKey.GetValue Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">该用户没有读取注册表项所需的权限。</exception>
        <exception cref="T:System.ObjectDisposedException">包含指定值的 <see cref="T:Microsoft.Win32.RegistryKey" /> 已关闭（无法访问关闭的项）。</exception>
        <exception cref="T:System.IO.IOException">包含指定值的 <see cref="T:Microsoft.Win32.RegistryKey" /> 已标记为删除。</exception>
        <exception cref="T:System.UnauthorizedAccessException">用户没有必需的注册表权限。</exception>
        <permission cref="T:System.Security.Permissions.RegistryPermission">若要从注册表中读取。 关联的枚举： <see cref="F:System.Security.Permissions.RegistryPermissionAccess.Read" /></permission>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">若要读取注册表项的类型 REG_EXPAND_SZ。 关联的枚举： <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
        <altmember cref="M:Microsoft.Win32.RegistryKey.GetValueNames" />
        <altmember cref="Overload:Microsoft.Win32.RegistryKey.SetValue" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.DeleteValue(System.String)" />
        <altmember cref="P:Microsoft.Win32.RegistryKey.ValueCount" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.GetSubKeyNames" />
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public object GetValue (string name, object defaultValue, Microsoft.Win32.RegistryValueOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetValue(string name, object defaultValue, valuetype Microsoft.Win32.RegistryValueOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.RegistryKey.GetValue(System.String,System.Object,Microsoft.Win32.RegistryValueOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetValue (name As String, defaultValue As Object, options As RegistryValueOptions) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetValue(System::String ^ name, System::Object ^ defaultValue, Microsoft::Win32::RegistryValueOptions options);" />
      <MemberSignature Language="F#" Value="member this.GetValue : string * obj * Microsoft.Win32.RegistryValueOptions -&gt; obj" Usage="registryKey.GetValue (name, defaultValue, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="defaultValue" Type="System.Object" />
        <Parameter Name="options" Type="Microsoft.Win32.RegistryValueOptions" />
      </Parameters>
      <Docs>
        <param name="name">要检索的值的名称。 此字符串不区分大小写。</param>
        <param name="defaultValue">当 <c>name</c> 不存在时要返回的值。</param>
        <param name="options">枚举值之一，它指定对所检索值的可选处理方式。</param>
        <summary>检索与指定的名称和检索选项关联的值。 如果未找到名称，则返回你提供的默认值。</summary>
        <returns>与 <paramref name="name" /> 关联的值，按指定的 <paramref name="options" /> 对其进行处理；如果未找到 <paramref name="defaultValue" />，则为 <paramref name="name" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此重载用于指定所检索值的特殊处理。 例如，可以指定<xref:Microsoft.Win32.RegistryValueOptions.DoNotExpandEnvironmentNames?displayProperty=nameWithType>检索类型的注册表值时<xref:Microsoft.Win32.RegistryValueKind.ExpandString?displayProperty=nameWithType>要检索的字符串而不展开嵌入的环境变量。  
  
 使用`defaultValue`参数来指定要返回的值`name`不存在。  
  
> [!NOTE]
>  注册表项可以具有不与任何名称相关联的一个值。 在注册表编辑器中显示此未命名的值时，而不是名称将显示字符串"(Default)"。 若要检索此未命名的值，指定`null`或空字符串 ("") 为`name`。  
>   
>  <xref:Microsoft.Win32.RegistryKey.GetValue%2A> 不支持类型为 REG_NONE 或 REG_LINK 中读取的值。  在这两种情况下，默认值 (`null`) 返回而不是实际值。  
  
   
  
## Examples  
 下面的代码示例创建一个测试项、 添加具有嵌入式的环境变量的值并且检索扩展和非扩展窗体中的值。  
  
 [!code-cpp[RegistryValueOptions#1](~/samples/snippets/cpp/VS_Snippets_CLR/RegistryValueOptions/CPP/RegistryValueOptions.cpp#1)]
 [!code-csharp[RegistryValueOptions#1](~/samples/snippets/csharp/VS_Snippets_CLR/RegistryValueOptions/CS/source.cs#1)]
 [!code-vb[RegistryValueOptions#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/RegistryValueOptions/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">该用户没有读取注册表项所需的权限。</exception>
        <exception cref="T:System.ObjectDisposedException">包含指定值的 <see cref="T:Microsoft.Win32.RegistryKey" /> 已关闭（无法访问关闭的项）。</exception>
        <exception cref="T:System.IO.IOException">包含指定值的 <see cref="T:Microsoft.Win32.RegistryKey" /> 已标记为删除。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="options" /> 不是有效的 <see cref="T:Microsoft.Win32.RegistryValueOptions" /> 值；例如，无效值将强制转换为 <see cref="T:Microsoft.Win32.RegistryValueOptions" />。</exception>
        <exception cref="T:System.UnauthorizedAccessException">用户没有必需的注册表权限。</exception>
        <permission cref="T:System.Security.Permissions.RegistryPermission">若要从注册表中读取。 关联的枚举： <see cref="F:System.Security.Permissions.RegistryPermissionAccess.Read" /></permission>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">若要读取注册表项的类型 REG_EXPAND_SZ。 关联的枚举： <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
        <altmember cref="T:Microsoft.Win32.RegistryValueOptions" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.GetValueNames" />
        <altmember cref="Overload:Microsoft.Win32.RegistryKey.SetValue" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.DeleteValue(System.String)" />
        <altmember cref="P:Microsoft.Win32.RegistryKey.ValueCount" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.GetSubKeyNames" />
      </Docs>
    </Member>
    <Member MemberName="GetValueKind">
      <MemberSignature Language="C#" Value="public Microsoft.Win32.RegistryValueKind GetValueKind (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype Microsoft.Win32.RegistryValueKind GetValueKind(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.RegistryKey.GetValueKind(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetValueKind (name As String) As RegistryValueKind" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Microsoft::Win32::RegistryValueKind GetValueKind(System::String ^ name);" />
      <MemberSignature Language="F#" Value="member this.GetValueKind : string -&gt; Microsoft.Win32.RegistryValueKind" Usage="registryKey.GetValueKind name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryValueKind</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">要检索其注册表数据类型的值的名称。 此字符串不区分大小写。</param>
        <summary>检索与指定名称关联的值的注册表数据类型。</summary>
        <returns>与 <paramref name="name" /> 关联的值的注册表数据类型。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  注册表项可以具有不与任何名称相关联的一个值。 在注册表编辑器中显示此未命名的值时，而不是名称将显示字符串"(Default)"。 若要检索此未命名的值的注册表数据类型，请指定`null`或空字符串 ("") 为`name`。  
  
 有关受支持的注册表数据类型的说明，请参阅<xref:Microsoft.Win32.RegistryValueKind>枚举。  
  
   
  
## Examples  
 下面的代码示例创建一个测试项，并将不同的数据类型的值添加到该密钥。 该示例然后读取名称/值对，并将其显示在控制台中，使用<xref:Microsoft.Win32.RegistryKey.GetValueKind%2A>方法来检索相应的注册表数据类型。  
  
 [!code-cpp[Microsoft.Win32.RegistryValueKind#1](~/samples/snippets/cpp/VS_Snippets_CLR/Microsoft.Win32.RegistryValueKind/CPP/source.cpp#1)]
 [!code-csharp[Microsoft.Win32.RegistryValueKind#1](~/samples/snippets/csharp/VS_Snippets_CLR/Microsoft.Win32.RegistryValueKind/CS/source.cs#1)]
 [!code-vb[Microsoft.Win32.RegistryValueKind#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Microsoft.Win32.RegistryValueKind/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">该用户没有读取注册表项所需的权限。</exception>
        <exception cref="T:System.ObjectDisposedException">包含指定值的 <see cref="T:Microsoft.Win32.RegistryKey" /> 已关闭（无法访问关闭的项）。</exception>
        <exception cref="T:System.IO.IOException">包含指定值的子项不存在。  
  
或 
由 <paramref name="name" /> 指定的名称/值对不存在。  
  
在 Windows 95、Windows 98 或 Windows Millennium Edition 中不引发此异常。</exception>
        <exception cref="T:System.UnauthorizedAccessException">用户没有必需的注册表权限。</exception>
        <permission cref="T:System.Security.Permissions.RegistryPermission">若要从注册表中读取。 关联的枚举： <see cref="F:System.Security.Permissions.RegistryPermissionAccess.Read" /></permission>
        <altmember cref="M:Microsoft.Win32.RegistryKey.GetValueNames" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.GetValue(System.String)" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.SetValue(System.String,System.Object)" />
        <altmember cref="T:Microsoft.Win32.RegistryValueKind" />
      </Docs>
    </Member>
    <Member MemberName="GetValueNames">
      <MemberSignature Language="C#" Value="public string[] GetValueNames ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] GetValueNames() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.RegistryKey.GetValueNames" />
      <MemberSignature Language="VB.NET" Value="Public Function GetValueNames () As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ GetValueNames();" />
      <MemberSignature Language="F#" Value="member this.GetValueNames : unit -&gt; string[]" Usage="registryKey.GetValueNames " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>检索包含与此项关联的所有值名称的字符串数组。</summary>
        <returns>包含当前项的值名称的字符串数组。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果找到该密钥没有值名称，则返回空数组。  
  
 注册表项可以具有默认值-即，在其中名称是空字符串的名称/值对 ("")。 如果已为注册表项设置默认值，返回的数组<xref:Microsoft.Win32.RegistryKey.GetValueNames%2A>方法包含空字符串。  
  
   
  
## Examples  
 此代码示例是为提供一个更大示例的一部分<xref:Microsoft.Win32.RegistryKey>类。  
  
 [!code-cpp[Microsoft.Win32.RegistryKey2#2](~/samples/snippets/cpp/VS_Snippets_CLR/Microsoft.Win32.RegistryKey2/CPP/source.cpp#2)]
 [!code-csharp[Microsoft.Win32.RegistryKey2#2](~/samples/snippets/csharp/VS_Snippets_CLR/Microsoft.Win32.RegistryKey2/CS/source.cs#2)]
 [!code-vb[Microsoft.Win32.RegistryKey2#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Microsoft.Win32.RegistryKey2/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">该用户没有读取注册表项所需的权限。</exception>
        <exception cref="T:System.ObjectDisposedException">要操作的 <see cref="T:Microsoft.Win32.RegistryKey" /> 已关闭（无法访问关闭的项）。</exception>
        <exception cref="T:System.UnauthorizedAccessException">用户没有必需的注册表权限。</exception>
        <exception cref="T:System.IO.IOException">发生系统错误；例如，当前项已被删除。</exception>
        <permission cref="T:System.Security.Permissions.RegistryPermission">有关从注册表中读取的功能。 关联的枚举： <see cref="F:System.Security.Permissions.RegistryPermissionAccess.Read" /></permission>
        <altmember cref="M:Microsoft.Win32.RegistryKey.GetValue(System.String)" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.GetSubKeyNames" />
      </Docs>
    </Member>
    <Member MemberName="Handle">
      <MemberSignature Language="C#" Value="public Microsoft.Win32.SafeHandles.SafeRegistryHandle Handle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.Win32.SafeHandles.SafeRegistryHandle Handle" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Win32.RegistryKey.Handle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Handle As SafeRegistryHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Microsoft::Win32::SafeHandles::SafeRegistryHandle ^ Handle { Microsoft::Win32::SafeHandles::SafeRegistryHandle ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Handle : Microsoft.Win32.SafeHandles.SafeRegistryHandle" Usage="Microsoft.Win32.RegistryKey.Handle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.SafeHandles.SafeRegistryHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个 <see cref="T:Microsoft.Win32.SafeHandles.SafeRegistryHandle" /> 对象，该对象表示当前 <see cref="T:Microsoft.Win32.RegistryKey" /> 对象封装的注册表项。</summary>
        <value>注册表项的句柄。</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">注册表项已关闭。 无法访问已关闭的项。</exception>
        <exception cref="T:System.UnauthorizedAccessException">用户没有必需的注册表权限。</exception>
        <exception cref="T:System.IO.IOException">发生系统错误，例如，删除了当前项。</exception>
        <exception cref="T:System.Security.SecurityException">用户没有读取注册表项所需的权限。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直接调用方需要完全信任。 不能由部分受信任的或透明的代码使用此成员。</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">它能够访问指定的注册表密钥如果它是一个远程的密钥。 关联的枚举： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Win32.RegistryKey.Name" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Name { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Name : string" Usage="Microsoft.Win32.RegistryKey.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>检索项的名称。</summary>
        <value>项的绝对（限定）名称。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 密钥的名称在注册表中，开始时始终在基项 HKEY_LOCAL_MACHINE 中包括此项的绝对路径。  
  
   
  
## Examples  
 此代码示例是为提供一个更大示例的一部分<xref:Microsoft.Win32.RegistryKey>类。  
  
 [!code-cpp[Microsoft.Win32.RegistryKey2#4](~/samples/snippets/cpp/VS_Snippets_CLR/Microsoft.Win32.RegistryKey2/CPP/source.cpp#4)]
 [!code-csharp[Microsoft.Win32.RegistryKey2#4](~/samples/snippets/csharp/VS_Snippets_CLR/Microsoft.Win32.RegistryKey2/CS/source.cs#4)]
 [!code-vb[Microsoft.Win32.RegistryKey2#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/Microsoft.Win32.RegistryKey2/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:Microsoft.Win32.RegistryKey" /> 已关闭（无法访问已关闭的项）。</exception>
        <altmember cref="M:Microsoft.Win32.RegistryKey.ToString" />
      </Docs>
    </Member>
    <Member MemberName="OpenBaseKey">
      <MemberSignature Language="C#" Value="public static Microsoft.Win32.RegistryKey OpenBaseKey (Microsoft.Win32.RegistryHive hKey, Microsoft.Win32.RegistryView view);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.Win32.RegistryKey OpenBaseKey(valuetype Microsoft.Win32.RegistryHive hKey, valuetype Microsoft.Win32.RegistryView view) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.RegistryKey.OpenBaseKey(Microsoft.Win32.RegistryHive,Microsoft.Win32.RegistryView)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenBaseKey (hKey As RegistryHive, view As RegistryView) As RegistryKey" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Microsoft::Win32::RegistryKey ^ OpenBaseKey(Microsoft::Win32::RegistryHive hKey, Microsoft::Win32::RegistryView view);" />
      <MemberSignature Language="F#" Value="static member OpenBaseKey : Microsoft.Win32.RegistryHive * Microsoft.Win32.RegistryView -&gt; Microsoft.Win32.RegistryKey" Usage="Microsoft.Win32.RegistryKey.OpenBaseKey (hKey, view)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="hKey" Type="Microsoft.Win32.RegistryHive" />
        <Parameter Name="view" Type="Microsoft.Win32.RegistryView" />
      </Parameters>
      <Docs>
        <param name="hKey">要打开的 HKEY。</param>
        <param name="view">要使用的注册表视图。</param>
        <summary>打开一个新的 <see cref="T:Microsoft.Win32.RegistryKey" />，它使用指定的视图在本地计算机上表示请求的项。</summary>
        <returns>请求的注册表项。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="hKey" /> 或 <paramref name="view" /> 无效。</exception>
        <exception cref="T:System.UnauthorizedAccessException">用户没有必需的注册表权限。</exception>
        <exception cref="T:System.Security.SecurityException">用户没有执行此操作所需的权限。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="OpenRemoteBaseKey">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>打开一个新的 T:Microsoft.Win32.RegistryKey，它使用指定的注册表视图选项在远程计算机上表示请求的项。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OpenRemoteBaseKey">
      <MemberSignature Language="C#" Value="public static Microsoft.Win32.RegistryKey OpenRemoteBaseKey (Microsoft.Win32.RegistryHive hKey, string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.Win32.RegistryKey OpenRemoteBaseKey(valuetype Microsoft.Win32.RegistryHive hKey, string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.RegistryKey.OpenRemoteBaseKey(Microsoft.Win32.RegistryHive,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenRemoteBaseKey (hKey As RegistryHive, machineName As String) As RegistryKey" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Microsoft::Win32::RegistryKey ^ OpenRemoteBaseKey(Microsoft::Win32::RegistryHive hKey, System::String ^ machineName);" />
      <MemberSignature Language="F#" Value="static member OpenRemoteBaseKey : Microsoft.Win32.RegistryHive * string -&gt; Microsoft.Win32.RegistryKey" Usage="Microsoft.Win32.RegistryKey.OpenRemoteBaseKey (hKey, machineName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="hKey" Type="Microsoft.Win32.RegistryHive" />
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="hKey">要从 <see cref="T:Microsoft.Win32.RegistryHive" /> 枚举中打开的 HKEY。</param>
        <param name="machineName">远程计算机。</param>
        <summary>打开一个新的 <see cref="T:Microsoft.Win32.RegistryKey" />，它表示远程计算机上的请求的项。</summary>
        <returns>请求的注册表项。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果打开本地计算机注册表`machineName`是<xref:System.String.Empty?displayProperty=nameWithType>。 请求的项必须是远程计算机上的根项，并由相应标识<xref:Microsoft.Win32.RegistryHive>值。  
  
 为了使远程打开的密钥，服务器和客户端计算机必须是运行远程注册表服务，而且必须启用远程管理。  
  
   
  
## Examples  
 下面的代码示例显示如何打开远程计算机上的注册表项和枚举密钥的值。 远程计算机必须运行远程注册表服务。 调用该程序时，远程计算机的名称指定为命令行参数。  
  
 [!code-cpp[Microsoft.Win32.RegistryKey.OpenRemoteBaseKey#1](~/samples/snippets/cpp/VS_Snippets_CLR/Microsoft.Win32.RegistryKey.OpenRemoteBaseKey/CPP/source.cpp#1)]
 [!code-csharp[Microsoft.Win32.RegistryKey.OpenRemoteBaseKey#1](~/samples/snippets/csharp/VS_Snippets_CLR/Microsoft.Win32.RegistryKey.OpenRemoteBaseKey/CS/source.cs#1)]
 [!code-vb[Microsoft.Win32.RegistryKey.OpenRemoteBaseKey#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Microsoft.Win32.RegistryKey.OpenRemoteBaseKey/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="hKey" /> 无效。</exception>
        <exception cref="T:System.IO.IOException">
          <paramref name="machineName" /> 未找到。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="machineName" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.Security.SecurityException">用户不具有执行该操作的适当权限。</exception>
        <exception cref="T:System.UnauthorizedAccessException">用户没有必需的注册表权限。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">它能够访问指定的注册表密钥如果它是一个远程的密钥。 关联的枚举： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="T:Microsoft.Win32.RegistryHive" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.OpenSubKey(System.String,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="OpenRemoteBaseKey">
      <MemberSignature Language="C#" Value="public static Microsoft.Win32.RegistryKey OpenRemoteBaseKey (Microsoft.Win32.RegistryHive hKey, string machineName, Microsoft.Win32.RegistryView view);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.Win32.RegistryKey OpenRemoteBaseKey(valuetype Microsoft.Win32.RegistryHive hKey, string machineName, valuetype Microsoft.Win32.RegistryView view) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.RegistryKey.OpenRemoteBaseKey(Microsoft.Win32.RegistryHive,System.String,Microsoft.Win32.RegistryView)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenRemoteBaseKey (hKey As RegistryHive, machineName As String, view As RegistryView) As RegistryKey" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Microsoft::Win32::RegistryKey ^ OpenRemoteBaseKey(Microsoft::Win32::RegistryHive hKey, System::String ^ machineName, Microsoft::Win32::RegistryView view);" />
      <MemberSignature Language="F#" Value="static member OpenRemoteBaseKey : Microsoft.Win32.RegistryHive * string * Microsoft.Win32.RegistryView -&gt; Microsoft.Win32.RegistryKey" Usage="Microsoft.Win32.RegistryKey.OpenRemoteBaseKey (hKey, machineName, view)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="hKey" Type="Microsoft.Win32.RegistryHive" />
        <Parameter Name="machineName" Type="System.String" />
        <Parameter Name="view" Type="Microsoft.Win32.RegistryView" />
      </Parameters>
      <Docs>
        <param name="hKey">要从 <see cref="T:Microsoft.Win32.RegistryHive" /> 枚举中打开的 HKEY。</param>
        <param name="machineName">远程计算机。</param>
        <param name="view">要使用的注册表视图。</param>
        <summary>打开一个新的注册表项，它使用指定的视图在远程计算机上表示请求的项。</summary>
        <returns>请求的注册表项。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果打开本地计算机注册表`machineName`是<xref:System.String.Empty?displayProperty=nameWithType>。 请求的项必须是远程计算机上的根项，并由相应标识<xref:Microsoft.Win32.RegistryHive>值。  
  
 为了使远程打开的密钥，服务器和客户端计算机必须是运行远程注册表服务，而且必须启用远程管理。  
  
 在 64 位版本的 Windows，对于 32 位和 64 位应用程序可以单独存储的注册表部分。 没有 32 位应用程序的 32 位视图和 64 位应用程序的 64 位视图。 如果`view`是<xref:Microsoft.Win32.RegistryView.Registry64>但远程计算机正在运行 32 位操作系统，则返回的键将使用<xref:Microsoft.Win32.RegistryView.Registry32>视图。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="hKey" /> 或 <paramref name="view" /> 无效。</exception>
        <exception cref="T:System.IO.IOException">
          <paramref name="machineName" /> 未找到。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="machineName" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.UnauthorizedAccessException">用户没有必需的注册表权限。</exception>
        <exception cref="T:System.Security.SecurityException">用户不具有执行该操作所需的权限。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="OpenSubKey">
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>检索指定的子项。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OpenSubKey">
      <MemberSignature Language="C#" Value="public Microsoft.Win32.RegistryKey OpenSubKey (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Microsoft.Win32.RegistryKey OpenSubKey(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.RegistryKey.OpenSubKey(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function OpenSubKey (name As String) As RegistryKey" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Microsoft::Win32::RegistryKey ^ OpenSubKey(System::String ^ name);" />
      <MemberSignature Language="F#" Value="member this.OpenSubKey : string -&gt; Microsoft.Win32.RegistryKey" Usage="registryKey.OpenSubKey name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">要以只读方式打开的子项的名称或路径。</param>
        <summary>以只读方式检索子项。</summary>
        <returns>请求的子项；如果操作失败，则为 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 它可以使用其他方法和属性操作之前，必须打开的项。 若要修改键，必须打开的重载与它<xref:Microsoft.Win32.RegistryKey.OpenSubKey%2A>方法，可用于指定写访问权限，如<xref:Microsoft.Win32.RegistryKey.OpenSubKey%28System.String%2CMicrosoft.Win32.RegistryKeyPermissionCheck%29>重载或<xref:Microsoft.Win32.RegistryKey.OpenSubKey%28System.String%2CSystem.Boolean%29>重载。  
  
 如果没有找到指定的子项，然后`null`返回。  
  
 若要使用<xref:Microsoft.Win32.RegistryKey.OpenSubKey%2A>方法，您必须拥有的实例<xref:Microsoft.Win32.RegistryKey>。 若要获取的实例<xref:Microsoft.Win32.RegistryKey>，使用的静态成员的一个<xref:Microsoft.Win32.Registry>类。  
  
   
  
## Examples  
 下面的代码示例创建一个测试项，并使用<xref:Microsoft.Win32.RegistryKey.OpenSubKey%2A>方法打开它，演示这两种方法的重载。  
  
 [!code-cpp[RegistryKey.OpenSubKey#1](~/samples/snippets/cpp/VS_Snippets_CLR/RegistryKey.OpenSubKey/CPP/opensubkey.cpp#1)]
 [!code-csharp[RegistryKey.OpenSubKey#1](~/samples/snippets/csharp/VS_Snippets_CLR/RegistryKey.OpenSubKey/CS/opensubkey.cs#1)]
 [!code-vb[RegistryKey.OpenSubKey#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/RegistryKey.OpenSubKey/VB/opensubkey.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> 为 <see langword="null" /></exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:Microsoft.Win32.RegistryKey" /> 已关闭（无法访问已关闭的项）。</exception>
        <exception cref="T:System.Security.SecurityException">用户没有读取注册表项所需的权限。</exception>
        <permission cref="T:System.Security.Permissions.RegistryPermission">用于读取指定的注册表项的功能。 关联的枚举： <see cref="F:System.Security.Permissions.RegistryPermissionAccess.Read" /></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">它能够访问指定的注册表密钥如果它是一个远程的密钥。 关联的枚举： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="M:Microsoft.Win32.RegistryKey.CreateSubKey(System.String)" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.DeleteSubKey(System.String)" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.DeleteSubKeyTree(System.String)" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.GetSubKeyNames" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.OpenRemoteBaseKey(Microsoft.Win32.RegistryHive,System.String)" />
        <altmember cref="P:Microsoft.Win32.RegistryKey.SubKeyCount" />
        <altmember cref="T:Microsoft.Win32.Registry" />
      </Docs>
    </Member>
    <Member MemberName="OpenSubKey">
      <MemberSignature Language="C#" Value="public Microsoft.Win32.RegistryKey OpenSubKey (string name, Microsoft.Win32.RegistryKeyPermissionCheck permissionCheck);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Microsoft.Win32.RegistryKey OpenSubKey(string name, valuetype Microsoft.Win32.RegistryKeyPermissionCheck permissionCheck) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.RegistryKey.OpenSubKey(System.String,Microsoft.Win32.RegistryKeyPermissionCheck)" />
      <MemberSignature Language="VB.NET" Value="Public Function OpenSubKey (name As String, permissionCheck As RegistryKeyPermissionCheck) As RegistryKey" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Microsoft::Win32::RegistryKey ^ OpenSubKey(System::String ^ name, Microsoft::Win32::RegistryKeyPermissionCheck permissionCheck);" />
      <MemberSignature Language="F#" Value="member this.OpenSubKey : string * Microsoft.Win32.RegistryKeyPermissionCheck -&gt; Microsoft.Win32.RegistryKey" Usage="registryKey.OpenSubKey (name, permissionCheck)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="permissionCheck" Type="Microsoft.Win32.RegistryKeyPermissionCheck" />
      </Parameters>
      <Docs>
        <param name="name">要创建或打开的子项的名称或路径。</param>
        <param name="permissionCheck">用于指定打开该项是进行读取还是读取/写入访问的枚举值之一。</param>
        <summary>检索指定的子项以进行读取或读/写访问。</summary>
        <returns>请求的子项；如果操作失败，则为 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 而不是引发异常，此方法返回`null`如果所需的键不存在。  
  
 如果`permissionCheck`是<xref:Microsoft.Win32.RegistryKeyPermissionCheck.ReadWriteSubTree?displayProperty=nameWithType>，该密钥打开用于读取和写入; 如果`permissionCheck`是<xref:Microsoft.Win32.RegistryKeyPermissionCheck.ReadSubTree?displayProperty=nameWithType>或<xref:Microsoft.Win32.RegistryKeyPermissionCheck.Default?displayProperty=nameWithType>，为读取除非通过打开父项打开项<xref:Microsoft.Win32.RegistryKeyPermissionCheck.ReadWriteSubTree?displayProperty=nameWithType>。  
  
 若要使用<xref:Microsoft.Win32.RegistryKey.OpenSubKey%2A>方法，您必须拥有的实例<xref:Microsoft.Win32.RegistryKey>类。 若要获取的实例<xref:Microsoft.Win32.RegistryKey>，使用的静态成员之一<xref:Microsoft.Win32.Registry>类。  
  
   
  
## Examples  
 下面的代码示例创建一个包含 100 键/值对的子项，并将其关闭。 该示例打开与子项<xref:Microsoft.Win32.RegistryKeyPermissionCheck.Default>，记录它读取所有值，并关闭该子项的时间。 该示例打开与子项<xref:Microsoft.Win32.RegistryKeyPermissionCheck.ReadSubTree>并记录读取所有值所用的时间。 最后，该示例计算并显示提高百分比。  
  
 [!code-csharp[RegistryKey.OpenSubKey_PermCheck#1](~/samples/snippets/csharp/VS_Snippets_CLR/RegistryKey.OpenSubKey_PermCheck/cs/source.cs#1)]
 [!code-vb[RegistryKey.OpenSubKey_PermCheck#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/RegistryKey.OpenSubKey_PermCheck/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> 为 <see langword="null" /></exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="permissionCheck" /> 包含无效值。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:Microsoft.Win32.RegistryKey" /> 已关闭（无法访问已关闭的项）。</exception>
        <exception cref="T:System.Security.SecurityException">用户没有读取注册表项所需的权限。</exception>
        <permission cref="T:System.Security.Permissions.RegistryPermission">用于读取指定的注册表项的功能。 关联的枚举： <see cref="F:System.Security.Permissions.RegistryPermissionAccess.Read" /></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">它能够访问指定的注册表密钥如果它是一个远程的密钥。 关联的枚举： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="M:Microsoft.Win32.RegistryKey.CreateSubKey(System.String)" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.DeleteSubKey(System.String)" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.DeleteSubKeyTree(System.String)" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.GetSubKeyNames" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.OpenRemoteBaseKey(Microsoft.Win32.RegistryHive,System.String)" />
        <altmember cref="P:Microsoft.Win32.RegistryKey.SubKeyCount" />
        <altmember cref="T:Microsoft.Win32.Registry" />
      </Docs>
    </Member>
    <Member MemberName="OpenSubKey">
      <MemberSignature Language="C#" Value="public Microsoft.Win32.RegistryKey OpenSubKey (string name, bool writable);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Microsoft.Win32.RegistryKey OpenSubKey(string name, bool writable) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.RegistryKey.OpenSubKey(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function OpenSubKey (name As String, writable As Boolean) As RegistryKey" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Microsoft::Win32::RegistryKey ^ OpenSubKey(System::String ^ name, bool writable);" />
      <MemberSignature Language="F#" Value="member this.OpenSubKey : string * bool -&gt; Microsoft.Win32.RegistryKey" Usage="registryKey.OpenSubKey (name, writable)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="writable" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="name">要打开的子项的名称或路径。</param>
        <param name="writable">如果需要项的写访问权限，则设置为 <see langword="true" />。</param>
        <summary>检索指定的子项，并指定是否将写访问权限应用于该项。</summary>
        <returns>请求的子项；如果操作失败，则为 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果所需的键不存在，此方法返回`null`而不是引发异常。  
  
 如果`writable`是`true`、 的项将打开用于读取和写入，否则，将以只读方式打开密钥。  
  
 若要使用<xref:Microsoft.Win32.RegistryKey.OpenSubKey%2A>方法，您必须拥有的实例<xref:Microsoft.Win32.RegistryKey>方法。 若要获取的实例<xref:Microsoft.Win32.RegistryKey>，使用的静态成员之一<xref:Microsoft.Win32.Registry>类。  
  
   
  
## Examples  
 下面的代码示例创建一个测试项，并使用<xref:Microsoft.Win32.RegistryKey.OpenSubKey%2A>方法打开它，演示这两种方法的重载。  
  
 [!code-cpp[RegistryKey.OpenSubKey#1](~/samples/snippets/cpp/VS_Snippets_CLR/RegistryKey.OpenSubKey/CPP/opensubkey.cpp#1)]
 [!code-csharp[RegistryKey.OpenSubKey#1](~/samples/snippets/csharp/VS_Snippets_CLR/RegistryKey.OpenSubKey/CS/opensubkey.cs#1)]
 [!code-vb[RegistryKey.OpenSubKey#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/RegistryKey.OpenSubKey/VB/opensubkey.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:Microsoft.Win32.RegistryKey" /> 已关闭（无法访问已关闭的项）。</exception>
        <exception cref="T:System.Security.SecurityException">用户没有在指定模式下访问注册表项所需的权限。</exception>
        <permission cref="T:System.Security.Permissions.RegistryPermission">用于读取指定的注册表项的功能。 关联的枚举： <see cref="F:System.Security.Permissions.RegistryPermissionAccess.Read" /></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">它能够访问指定的注册表密钥如果它是一个远程的密钥。 关联的枚举： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="M:Microsoft.Win32.RegistryKey.CreateSubKey(System.String)" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.DeleteSubKey(System.String)" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.DeleteSubKeyTree(System.String)" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.GetSubKeyNames" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.OpenRemoteBaseKey(Microsoft.Win32.RegistryHive,System.String)" />
        <altmember cref="P:Microsoft.Win32.RegistryKey.SubKeyCount" />
        <altmember cref="T:Microsoft.Win32.Registry" />
      </Docs>
    </Member>
    <Member MemberName="OpenSubKey">
      <MemberSignature Language="C#" Value="public Microsoft.Win32.RegistryKey OpenSubKey (string name, System.Security.AccessControl.RegistryRights rights);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Microsoft.Win32.RegistryKey OpenSubKey(string name, valuetype System.Security.AccessControl.RegistryRights rights) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.RegistryKey.OpenSubKey(System.String,System.Security.AccessControl.RegistryRights)" />
      <MemberSignature Language="VB.NET" Value="Public Function OpenSubKey (name As String, rights As RegistryRights) As RegistryKey" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Microsoft::Win32::RegistryKey ^ OpenSubKey(System::String ^ name, System::Security::AccessControl::RegistryRights rights);" />
      <MemberSignature Language="F#" Value="member this.OpenSubKey : string * System.Security.AccessControl.RegistryRights -&gt; Microsoft.Win32.RegistryKey" Usage="registryKey.OpenSubKey (name, rights)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="rights" Type="System.Security.AccessControl.RegistryRights" />
      </Parameters>
      <Docs>
        <param name="name">要创建或打开的子项的名称或路径。</param>
        <param name="rights">注册表项的权限。</param>
        <summary>检索具有指定名称的子项。  
  
从 .NET Framework 4.6 开始可用</summary>
        <returns>请求的子项；如果操作失败，则为 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 它可以使用其他方法和属性操作之前，必须打开的项。 若要修改键，必须打开的重载与它<xref:Microsoft.Win32.RegistryKey.OpenSubKey%2A>方法，可用于指定写入访问权限。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:Microsoft.Win32.RegistryKey" /> 已关闭（无法访问已关闭的项）。</exception>
        <exception cref="T:System.Security.SecurityException">用户没有在指定模式下访问注册表项所需的权限。</exception>
      </Docs>
    </Member>
    <Member MemberName="OpenSubKey">
      <MemberSignature Language="C#" Value="public Microsoft.Win32.RegistryKey OpenSubKey (string name, Microsoft.Win32.RegistryKeyPermissionCheck permissionCheck, System.Security.AccessControl.RegistryRights rights);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Microsoft.Win32.RegistryKey OpenSubKey(string name, valuetype Microsoft.Win32.RegistryKeyPermissionCheck permissionCheck, valuetype System.Security.AccessControl.RegistryRights rights) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.RegistryKey.OpenSubKey(System.String,Microsoft.Win32.RegistryKeyPermissionCheck,System.Security.AccessControl.RegistryRights)" />
      <MemberSignature Language="VB.NET" Value="Public Function OpenSubKey (name As String, permissionCheck As RegistryKeyPermissionCheck, rights As RegistryRights) As RegistryKey" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Microsoft::Win32::RegistryKey ^ OpenSubKey(System::String ^ name, Microsoft::Win32::RegistryKeyPermissionCheck permissionCheck, System::Security::AccessControl::RegistryRights rights);" />
      <MemberSignature Language="F#" Value="member this.OpenSubKey : string * Microsoft.Win32.RegistryKeyPermissionCheck * System.Security.AccessControl.RegistryRights -&gt; Microsoft.Win32.RegistryKey" Usage="registryKey.OpenSubKey (name, permissionCheck, rights)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="permissionCheck" Type="Microsoft.Win32.RegistryKeyPermissionCheck" />
        <Parameter Name="rights" Type="System.Security.AccessControl.RegistryRights" />
      </Parameters>
      <Docs>
        <param name="name">要创建或打开的子项的名称或路径。</param>
        <param name="permissionCheck">用于指定打开该项是进行读取还是读取/写入访问的枚举值之一。</param>
        <param name="rights">枚举值的按位组合，它指定所需的安全访问。</param>
        <summary>检索指定的子项以进行读取或读/写访问，请求指定的访问权限。</summary>
        <returns>请求的子项；如果操作失败，则为 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 而不是引发异常，此方法返回`null`如果所需的键不存在。  
  
 如果`permissionCheck`是<xref:Microsoft.Win32.RegistryKeyPermissionCheck.ReadWriteSubTree?displayProperty=nameWithType>，该密钥打开用于读取和写入; 如果`permissionCheck`是<xref:Microsoft.Win32.RegistryKeyPermissionCheck.ReadSubTree?displayProperty=nameWithType>或<xref:Microsoft.Win32.RegistryKeyPermissionCheck.Default?displayProperty=nameWithType>，为读取除非通过打开父项打开项<xref:Microsoft.Win32.RegistryKeyPermissionCheck.ReadWriteSubTree?displayProperty=nameWithType>。  
  
 为指定的访问权限`permissionCheck`为指定的访问权限的优先级高于`rights`。 例如，如果您指定<xref:Microsoft.Win32.RegistryKeyPermissionCheck.ReadSubTree?displayProperty=nameWithType>有关`permissionCheck`并<xref:System.Security.AccessControl.RegistryRights.WriteKey?displayProperty=nameWithType>为`rights`，写入到子项的尝试会引发异常。  
  
 若要使用<xref:Microsoft.Win32.RegistryKey.OpenSubKey%2A>方法，您必须拥有的实例<xref:Microsoft.Win32.RegistryKey>类。 若要获取的实例<xref:Microsoft.Win32.RegistryKey>，使用的静态成员之一<xref:Microsoft.Win32.Registry>类。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> 为 <see langword="null" /></exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="permissionCheck" /> 包含无效值。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:Microsoft.Win32.RegistryKey" /> 已关闭（无法访问已关闭的项）。</exception>
        <exception cref="T:System.Security.SecurityException">
          <paramref name="rights" /> 包含无效的注册表权限值。  
  
或 
用户没有所要求的权限。</exception>
        <permission cref="T:System.Security.Permissions.RegistryPermission">用于读取指定的注册表项的功能。 关联的枚举： <see cref="F:System.Security.Permissions.RegistryPermissionAccess.Read" /></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">它能够访问指定的注册表密钥如果它是一个远程的密钥。 关联的枚举： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="M:Microsoft.Win32.RegistryKey.CreateSubKey(System.String)" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.DeleteSubKey(System.String)" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.DeleteSubKeyTree(System.String)" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.GetSubKeyNames" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.OpenRemoteBaseKey(Microsoft.Win32.RegistryHive,System.String)" />
        <altmember cref="P:Microsoft.Win32.RegistryKey.SubKeyCount" />
        <altmember cref="T:Microsoft.Win32.Registry" />
      </Docs>
    </Member>
    <Member MemberName="SetAccessControl">
      <MemberSignature Language="C#" Value="public void SetAccessControl (System.Security.AccessControl.RegistrySecurity registrySecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetAccessControl(class System.Security.AccessControl.RegistrySecurity registrySecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.RegistryKey.SetAccessControl(System.Security.AccessControl.RegistrySecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetAccessControl(System::Security::AccessControl::RegistrySecurity ^ registrySecurity);" />
      <MemberSignature Language="F#" Value="member this.SetAccessControl : System.Security.AccessControl.RegistrySecurity -&gt; unit" Usage="registryKey.SetAccessControl registrySecurity" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="registrySecurity" Type="System.Security.AccessControl.RegistrySecurity" />
      </Parameters>
      <Docs>
        <param name="registrySecurity">要应用于当前子项的访问控制安全性。</param>
        <summary>向现有注册表项应用 Windows 访问控制安全性。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要修改的注册表项的权限，请使用<xref:Microsoft.Win32.RegistryKey.GetAccessControl%2A>方法来获取<xref:System.Security.AccessControl.RegistrySecurity>对象表示的现有 Windows 访问控制安全性，请修改该<xref:System.Security.AccessControl.RegistrySecurity>对象，以及如何将<xref:Microsoft.Win32.RegistryKey.SetAccessControl%2A>方法来更新的安全性键。  
  
> [!CAUTION]
>  <xref:System.Security.AccessControl.RegistrySecurity>对象指定的用于`registrySecurity`替换现有的注册表项的安全性。 若要添加新用户的权限，请使用<xref:Microsoft.Win32.RegistryKey.GetAccessControl%2A>方法来获取现有的访问控制安全性，然后再修改它。  
  
   
  
## Examples  
 下面的代码示例创建一个测试项。 允许当前用户<xref:System.Security.AccessControl.RegistryRights.ReadKey>并<xref:System.Security.AccessControl.RegistryRights.Delete>但拒绝权限<xref:System.Security.AccessControl.RegistryRights.ChangePermissions>和<xref:System.Security.AccessControl.RegistryRights.WriteKey>权限。 后续尝试操作密钥成功或失败，具体取决于这些权限。  
  
 删除密钥之前，代码就会暂停。 您可以切换到注册表编辑器并验证使用注册表编辑器中访问该密钥时，应用相同的访问权限。 (此效果最佳，如果您使用**RunAs**从命令行运行注册表编辑器和示例代码而无需管理员权限的本地用户。 注册表编辑器中始终允许管理员才能更改权限，即使特定管理员已拒绝这些权限。 如果已定义一个名为 TestUser，该命令的本地用户`runas /user:TestUser cmd`打开一个命令窗口，可以从其运行注册表编辑器，然后选择示例代码。)  
  
 [!code-cpp[RegistrySecurity101#1](~/samples/snippets/cpp/VS_Snippets_CLR/RegistrySecurity101/cpp/source.cpp#1)]
 [!code-csharp[RegistrySecurity101#1](~/samples/snippets/csharp/VS_Snippets_CLR/RegistrySecurity101/CS/source.cs#1)]
 [!code-vb[RegistrySecurity101#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/RegistrySecurity101/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">当前的 <see cref="T:Microsoft.Win32.RegistryKey" /> 对象表示一个具有访问控制安全性的项，并且调用方没有 <see cref="F:System.Security.AccessControl.RegistryRights.ChangePermissions" /> 权限。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="registrySecurity" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ObjectDisposedException">要操作的 <see cref="T:Microsoft.Win32.RegistryKey" /> 已关闭（无法访问关闭的项）。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="SetValue">
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>设置注册表项中的名称/值对的值。 从所存储数据的类型或指定的 <see cref="T:Microsoft.Win32.RegistryValueKind" /> 确定注册表数据类型，具体取决于重载。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (string name, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(string name, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.RegistryKey.SetValue(System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetValue (name As String, value As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetValue(System::String ^ name, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="member this.SetValue : string * obj -&gt; unit" Usage="registryKey.SetValue (name, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="name">要存储的值的名称。</param>
        <param name="value">要存储的数据。</param>
        <summary>设置指定的名称/值对。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 由于许多值可以存储在注册表中的每个项，必须使用`name`参数来指定你想要设置的特定值。  
  
> [!NOTE]
>  注册表项可以具有不与任何名称相关联的一个值。 在注册表编辑器中显示此未命名的值时，而不是名称将显示字符串"(Default)"。 若要设置此未命名的值，指定`null`或空字符串 ("") 为`name`。  
  
 若要设置某个项中的值，必须具有写访问权限来打开密钥。 具有写访问权限打开一个键后，您可以更改任何该注册表项中的名称/值对。  
  
 如果指定`name`不存在的项中创建和关联的值设置为`value`。  
  
 此重载<xref:Microsoft.Win32.RegistryKey.SetValue%2A>将 64 位整数存储为字符串 (<xref:Microsoft.Win32.RegistryValueKind.String?displayProperty=nameWithType>)。 若要存储为 64 位数字<xref:Microsoft.Win32.RegistryValueKind.QWord?displayProperty=nameWithType>值，请使用<xref:Microsoft.Win32.RegistryKey.SetValue%28System.String%2CSystem.Object%2CMicrosoft.Win32.RegistryValueKind%29>重载，指定<xref:Microsoft.Win32.RegistryValueKind>。  
  
 此重载<xref:Microsoft.Win32.RegistryKey.SetValue%2A>存储所有字符串值作为<xref:Microsoft.Win32.RegistryValueKind.String?displayProperty=nameWithType>，即使它们包含对环境变量可展开的引用。 若要保存为可展开的字符串的字符串值 (<xref:Microsoft.Win32.RegistryValueKind.ExpandString?displayProperty=nameWithType>)，使用<xref:Microsoft.Win32.RegistryKey.SetValue%28System.String%2CSystem.Object%2CMicrosoft.Win32.RegistryValueKind%29>重载，指定<xref:Microsoft.Win32.RegistryValueKind>。  
  
 此方法的重载数字类型，而不是 32 位整数存储为字符串。 枚举元素存储为包含的元素名称的字符串。  
  
> [!CAUTION]
>  不会公开<xref:Microsoft.Win32.RegistryKey>，恶意程序无法创建数千个无意义的子项或键/值对的方式中的对象。 例如，不允许调用方可以输入任意键或值。  
  
> [!NOTE]
>  在 Windows 98 和 Windows Millennium Edition 上注册表不是 Unicode，而不是所有 Unicode 字符都是有效的所有代码页。 最佳的匹配项都替换为对当前代码页无效的 Unicode 字符。 不引发异常。  
  
   
  
## Examples  
 下面的代码示例演示如何将<xref:Microsoft.Win32.RegistryKey.SetValue%2A>方法确定注册表数据类型时设置值。 该示例创建一个测试项，并向该项添加不同数据类型的值。 该示例然后读取名称/值对，并将其显示在控制台中，使用<xref:Microsoft.Win32.RegistryKey.GetValueKind%2A>方法来显示相应的注册表数据类型。  
  
 [!code-cpp[Microsoft.Win32.RegistryKey.SetValue1#1](~/samples/snippets/cpp/VS_Snippets_CLR/Microsoft.Win32.RegistryKey.SetValue1/CPP/source.cpp#1)]
 [!code-csharp[Microsoft.Win32.RegistryKey.SetValue1#1](~/samples/snippets/csharp/VS_Snippets_CLR/Microsoft.Win32.RegistryKey.SetValue1/CS/source.cs#1)]
 [!code-vb[Microsoft.Win32.RegistryKey.SetValue1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Microsoft.Win32.RegistryKey.SetValue1/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="value" /> 不是受支持的数据类型。</exception>
        <exception cref="T:System.ObjectDisposedException">包含指定值的 <see cref="T:Microsoft.Win32.RegistryKey" /> 已关闭（无法访问关闭的项）。</exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <see cref="T:Microsoft.Win32.RegistryKey" /> 只读，因此无法写入；例如，项不是用写访问权限打开的。  
  
或 
<see cref="T:Microsoft.Win32.RegistryKey" /> 对象表示根级别节点，操作系统为 Windows Millennium Edition 或 Windows 98。</exception>
        <exception cref="T:System.Security.SecurityException">用户没有创建或修改注册表项所需的权限。</exception>
        <exception cref="T:System.IO.IOException">
          <see cref="T:Microsoft.Win32.RegistryKey" /> 对象表示根级别节点，操作系统为 Windows 2000、Windows XP 或 Windows Server 2003。</exception>
        <permission cref="T:System.Security.Permissions.RegistryPermission">若要修改指定的注册表项，如果存在，或创建注册表项，如果尚不存在。 关联枚举： <see cref="F:System.Security.Permissions.RegistryPermissionAccess.Write" />， <see cref="F:System.Security.Permissions.RegistryPermissionAccess.Create" /></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">它能够访问指定的注册表密钥如果它是一个远程的密钥。 关联的枚举： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="M:Microsoft.Win32.RegistryKey.GetValue(System.String)" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.GetValueKind(System.String)" />
        <altmember cref="P:Microsoft.Win32.RegistryKey.ValueCount" />
      </Docs>
    </Member>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (string name, object value, Microsoft.Win32.RegistryValueKind valueKind);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(string name, object value, valuetype Microsoft.Win32.RegistryValueKind valueKind) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.RegistryKey.SetValue(System.String,System.Object,Microsoft.Win32.RegistryValueKind)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetValue (name As String, value As Object, valueKind As RegistryValueKind)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetValue(System::String ^ name, System::Object ^ value, Microsoft::Win32::RegistryValueKind valueKind);" />
      <MemberSignature Language="F#" Value="member this.SetValue : string * obj * Microsoft.Win32.RegistryValueKind -&gt; unit" Usage="registryKey.SetValue (name, value, valueKind)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="valueKind" Type="Microsoft.Win32.RegistryValueKind" />
      </Parameters>
      <Docs>
        <param name="name">要存储的值的名称。</param>
        <param name="value">要存储的数据。</param>
        <param name="valueKind">在存储数据时要使用的注册表数据类型。</param>
        <summary>使用指定的注册表数据类型设置注册表项中的名称/值对的值。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 由于许多值可以存储在注册表中的每个项，必须使用`name`参数来指定你想要设置的特定值。  
  
> [!NOTE]
>  注册表项可以具有不与任何名称相关联的一个值。 在注册表编辑器中显示此未命名的值时，而不是名称将显示字符串"(Default)"。 若要设置此未命名的值，指定`null`或空字符串 ("") 为`name`。  
  
 若要设置某个项中的值，必须具有写访问权限来打开密钥。 具有写访问权限打开一个键后，您可以更改任何该注册表项中的名称/值对。  
  
 如果指定`name`不存在键，它创建，并且相关联的值设置为`value`。  
  
> [!NOTE]
>  指定的注册表数据类型<xref:Microsoft.Win32.RegistryValueKind.Unknown>等同于使用<xref:Microsoft.Win32.RegistryKey.SetValue%2A>重载。  
  
 如果指定的类型`value`不匹配指定`valueKind`，且不能为数据转换，<xref:System.ArgumentException>引发。 例如，可以存储<xref:System.Int64?displayProperty=nameWithType>作为<xref:Microsoft.Win32.RegistryValueKind.DWord?displayProperty=nameWithType>，但前提是其值小于最大值<xref:System.Int32?displayProperty=nameWithType>。 不能存储作为单个字符串值<xref:Microsoft.Win32.RegistryValueKind.MultiString?displayProperty=nameWithType>。  
  
> [!NOTE]
>  如果已装箱的值将传递进行<xref:Microsoft.Win32.RegistryValueKind.DWord?displayProperty=nameWithType>或<xref:Microsoft.Win32.RegistryValueKind.QWord?displayProperty=nameWithType>，执行该转换使用固定区域性。  
  
> [!CAUTION]
>  不会公开<xref:Microsoft.Win32.RegistryKey>，恶意程序无法创建数千个无意义的子项或键/值对的方式中的对象。 例如，不允许调用方可以输入任意键或值。  
  
> [!NOTE]
>  在 Windows 98 和 Windows Millennium Edition 上注册表不是 Unicode，而不是所有 Unicode 字符都是有效的所有代码页。 最佳的匹配项都替换为对当前代码页无效的 Unicode 字符。 不引发异常。  
  
   
  
## Examples  
 下面的代码示例创建一个测试项，并使用<xref:Microsoft.Win32.RegistryKey.SetValue%2A>方法来存储多个值，指定每个值的注册表数据类型。 该示例然后读取名称/值对，并将其显示在控制台中，使用<xref:Microsoft.Win32.RegistryKey.GetValueKind%2A>方法来显示相应的注册表数据类型。  
  
 [!code-cpp[Microsoft.Win32.RegistryValueKind#1](~/samples/snippets/cpp/VS_Snippets_CLR/Microsoft.Win32.RegistryValueKind/CPP/source.cpp#1)]
 [!code-csharp[Microsoft.Win32.RegistryValueKind#1](~/samples/snippets/csharp/VS_Snippets_CLR/Microsoft.Win32.RegistryValueKind/CS/source.cs#1)]
 [!code-vb[Microsoft.Win32.RegistryValueKind#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Microsoft.Win32.RegistryValueKind/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="value" /> 的类型与 <paramref name="valueKind" /> 指定的注册表数据类型不匹配，因此，未能正确转换该数据。</exception>
        <exception cref="T:System.ObjectDisposedException">包含指定值的 <see cref="T:Microsoft.Win32.RegistryKey" /> 已关闭（无法访问关闭的项）。</exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <see cref="T:Microsoft.Win32.RegistryKey" /> 只读，因此无法写入；例如，项不是用写访问权限打开的。  
  
或 
<see cref="T:Microsoft.Win32.RegistryKey" /> 对象表示根级别节点，操作系统为 Windows Millennium Edition 或 Windows 98。</exception>
        <exception cref="T:System.Security.SecurityException">用户没有创建或修改注册表项所需的权限。</exception>
        <exception cref="T:System.IO.IOException">
          <see cref="T:Microsoft.Win32.RegistryKey" /> 对象表示根级别节点，操作系统为 Windows 2000、Windows XP 或 Windows Server 2003。</exception>
        <permission cref="T:System.Security.Permissions.RegistryPermission">若要修改指定的注册表项，如果存在，或创建注册表项，如果尚不存在。 关联枚举： <see cref="F:System.Security.Permissions.RegistryPermissionAccess.Write" />， <see cref="F:System.Security.Permissions.RegistryPermissionAccess.Create" /></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">它能够访问指定的注册表密钥如果它是一个远程的密钥。 关联的枚举： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="M:Microsoft.Win32.RegistryKey.GetValueKind(System.String)" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.GetValue(System.String)" />
        <altmember cref="P:Microsoft.Win32.RegistryKey.ValueCount" />
        <altmember cref="T:Microsoft.Win32.RegistryValueKind" />
      </Docs>
    </Member>
    <Member MemberName="SubKeyCount">
      <MemberSignature Language="C#" Value="public int SubKeyCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 SubKeyCount" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Win32.RegistryKey.SubKeyCount" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SubKeyCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int SubKeyCount { int get(); };" />
      <MemberSignature Language="F#" Value="member this.SubKeyCount : int" Usage="Microsoft.Win32.RegistryKey.SubKeyCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>检索当前项的子项计数。</summary>
        <value>当前项的子项的数目。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此属性执行而不是以递归方式计数名称。 它仅返回从中调用基本级别上的名称的计数。  
  
   
  
## Examples  
 此代码示例是为提供一个更大示例的一部分<xref:Microsoft.Win32.RegistryKey>类。  
  
 [!code-cpp[Microsoft.Win32.RegistryKey2#2](~/samples/snippets/cpp/VS_Snippets_CLR/Microsoft.Win32.RegistryKey2/CPP/source.cpp#2)]
 [!code-csharp[Microsoft.Win32.RegistryKey2#2](~/samples/snippets/csharp/VS_Snippets_CLR/Microsoft.Win32.RegistryKey2/CS/source.cs#2)]
 [!code-vb[Microsoft.Win32.RegistryKey2#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Microsoft.Win32.RegistryKey2/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">用户没有该项的读取权限。</exception>
        <exception cref="T:System.ObjectDisposedException">要操作的 <see cref="T:Microsoft.Win32.RegistryKey" /> 已关闭（无法访问关闭的项）。</exception>
        <exception cref="T:System.UnauthorizedAccessException">用户没有必需的注册表权限。</exception>
        <exception cref="T:System.IO.IOException">发生系统错误，例如，当前项已被删除。</exception>
        <permission cref="T:System.Security.Permissions.RegistryPermission">用于读取指定的注册表项的功能。 关联的枚举： <see cref="F:System.Security.Permissions.RegistryPermissionAccess.Read" /></permission>
        <altmember cref="M:Microsoft.Win32.RegistryKey.GetSubKeyNames" />
      </Docs>
    </Member>
    <Member MemberName="System.IDisposable.Dispose">
      <MemberSignature Language="C#" Value="void IDisposable.Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.IDisposable.Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.RegistryKey.System#IDisposable#Dispose" />
      <MemberSignature Language="VB.NET" Value="Sub Dispose () Implements IDisposable.Dispose" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.IDisposable.Dispose() = IDisposable::Dispose;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.RegistryKey.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="registryKey.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>检索此项的字符串表示形式。</summary>
        <returns>表示此项的字符串。 如果指定的项无效（找不到），则返回 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 返回值包含指定的密钥和密钥的十六进制值的注册表路径。 注册表路径包含指定键的绝对根，始终从 1 开始的基键的注册表中，例如，HKEY_LOCAL_MACHINE。  
  
   
  
## Examples  
 此代码示例是为提供一个更大示例的一部分<xref:Microsoft.Win32.RegistryKey>类。  
  
 [!code-cpp[Microsoft.Win32.RegistryKey2#4](~/samples/snippets/cpp/VS_Snippets_CLR/Microsoft.Win32.RegistryKey2/CPP/source.cpp#4)]
 [!code-csharp[Microsoft.Win32.RegistryKey2#4](~/samples/snippets/csharp/VS_Snippets_CLR/Microsoft.Win32.RegistryKey2/CS/source.cs#4)]
 [!code-vb[Microsoft.Win32.RegistryKey2#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/Microsoft.Win32.RegistryKey2/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">访问的 <see cref="T:Microsoft.Win32.RegistryKey" /> 已关闭（无法访问关闭的项）。</exception>
        <altmember cref="P:Microsoft.Win32.RegistryKey.Name" />
      </Docs>
    </Member>
    <Member MemberName="ValueCount">
      <MemberSignature Language="C#" Value="public int ValueCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ValueCount" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Win32.RegistryKey.ValueCount" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ValueCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ValueCount { int get(); };" />
      <MemberSignature Language="F#" Value="member this.ValueCount : int" Usage="Microsoft.Win32.RegistryKey.ValueCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>检索项中值的计数。</summary>
        <value>项中的名称/值对的数目。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 每个注册表项具有未与任何名称关联的默认值。 此未命名的值可以通过设置<xref:Microsoft.Win32.RegistryKey.SetValue%2A>方法，并指定`null`或空字符串 ("") 为`name`。 如果将永远不会设置默认值，它不计入返回的总计数<xref:Microsoft.Win32.RegistryKey.ValueCount%2A>属性; 后已设置，但是，它始终计数。  
  
   
  
## Examples  
 此代码示例是为提供一个更大示例的一部分<xref:Microsoft.Win32.RegistryKey>类。  
  
 [!code-cpp[Microsoft.Win32.RegistryKey2#2](~/samples/snippets/cpp/VS_Snippets_CLR/Microsoft.Win32.RegistryKey2/CPP/source.cpp#2)]
 [!code-csharp[Microsoft.Win32.RegistryKey2#2](~/samples/snippets/csharp/VS_Snippets_CLR/Microsoft.Win32.RegistryKey2/CS/source.cs#2)]
 [!code-vb[Microsoft.Win32.RegistryKey2#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Microsoft.Win32.RegistryKey2/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">用户没有该项的读取权限。</exception>
        <exception cref="T:System.ObjectDisposedException">要操作的 <see cref="T:Microsoft.Win32.RegistryKey" /> 已关闭（无法访问关闭的项）。</exception>
        <exception cref="T:System.UnauthorizedAccessException">用户没有必需的注册表权限。</exception>
        <exception cref="T:System.IO.IOException">发生系统错误，例如，当前项已被删除。</exception>
        <permission cref="T:System.Security.Permissions.RegistryPermission">用于读取指定的注册表项的功能。 关联的枚举： <see cref="F:System.Security.Permissions.RegistryPermissionAccess.Read" /></permission>
      </Docs>
    </Member>
    <Member MemberName="View">
      <MemberSignature Language="C#" Value="public Microsoft.Win32.RegistryView View { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype Microsoft.Win32.RegistryView View" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Win32.RegistryKey.View" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property View As RegistryView" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Microsoft::Win32::RegistryView View { Microsoft::Win32::RegistryView get(); };" />
      <MemberSignature Language="F#" Value="member this.View : Microsoft.Win32.RegistryView" Usage="Microsoft.Win32.RegistryKey.View" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryView</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取用于创建注册表项的视图。</summary>
        <value>用于创建注册表项的视图。  
  
或 
 如果未使用视图，则为 <see cref="F:Microsoft.Win32.RegistryView.Default" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在 64 位版本的 Windows，对于 32 位和 64 位应用程序可以单独存储的注册表部分。 没有 32 位应用程序的 32 位视图和 64 位应用程序的 64 位视图。  
  
 不要假定视图始终对应的实际视图<xref:Microsoft.Win32.RegistryKey>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>