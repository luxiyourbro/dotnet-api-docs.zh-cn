<Type Name="OracleLob" FullName="System.Data.OracleClient.OracleLob">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="69379b993f96f3e6579fc6f1fe9d4d03c40dd835" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-CN" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36684333" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class OracleLob : System.IO.Stream, ICloneable, System.Data.SqlTypes.INullable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit OracleLob extends System.IO.Stream implements class System.Data.SqlTypes.INullable, class System.ICloneable, class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Data.OracleClient.OracleLob" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class OracleLob&#xA;Inherits Stream&#xA;Implements ICloneable, INullable" />
  <TypeSignature Language="C++ CLI" Value="public ref class OracleLob sealed : System::IO::Stream, ICloneable, System::Data::SqlTypes::INullable" />
  <TypeSignature Language="F#" Value="type OracleLob = class&#xA;    inherit Stream&#xA;    interface ICloneable&#xA;    interface IDisposable&#xA;    interface INullable" />
  <AssemblyInfo>
    <AssemblyName>System.Data.OracleClient</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.IO.Stream</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Data.SqlTypes.INullable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.ICloneable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Represents a large object binary (<see langword="LOB" />) data type stored on an Oracle server. This class cannot be inherited.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.OracleClient.OracleLob>区别<xref:System.Data.OracleClient.OracleBFile>在于数据存储的服务器，而不是在操作系统中的物理文件上。 它还可读写对象，与不同<xref:System.Data.OracleClient.OracleBFile>，这始终是只读的。  
  
 <xref:System.Data.OracleClient.OracleLob>可能是下列其中一<xref:System.Data.OracleClient.OracleType>数据类型。  
  
|OracleType 数据类型|描述|  
|--------------------------|-----------------|  
|`Blob`|Oracle`BLOB`包含最大大小为 4 千兆字节 (GB) 的二进制数据的数据类型。 此方法映射到<xref:System.Array>类型的<xref:System.Byte>。|  
|`Clob`|Oracle`CLOB`包含字符数据，基于默认字符的数据类型设置在服务器上，最大大小为 4 GB。 此方法映射到<xref:System.String>。|  
|`NClob`|Oracle`NCLOB`基于在具有最大大小为 4 GB 的服务器上的区域字符集包含字符数据的数据类型。 此方法映射到<xref:System.String>。|  
  
 .NET 应用程序开发人员可以检索 Oracle`LOB`值到基本.NET 数据类型，例如<xref:System.Array>类型的<xref:System.Byte>和<xref:System.String>，或专用<xref:System.Data.OracleClient.OracleLob>数据类型。 <xref:System.Data.OracleClient.OracleLob>类支持从读取数据并写入 Oracle `LOB` Oracle 数据库中。  
  
 以下是的主要特征<xref:System.Data.OracleClient.OracleLob>区分从基本的.NET 数据类型的数据类型：  
  
-   检索 Oracle 后`LOB`值从 Oracle 数据库到<xref:System.Data.OracleClient.OracleLob>类，你可以更改`LOB`打开的事务和所做的更改中的数据直接反映到数据库。 如果检索 Oracle`LOB`值到<xref:System.Array>类型的<xref:System.Byte>或<xref:System.String>和更新这些阵列，所做的更改不会反映到数据库。  
  
-   当你使用<xref:System.Data.OracleClient.OracleLob>类访问的区块`LOB`值，只将该块区传递从 Oracle 数据库到客户端。 当你使用<xref:System.Data.OracleClient.OracleDataReader.GetChars%2A>方法来访问的区块`LOB`值，该值的整个内容传递从 Oracle 数据库到客户端。  
  
 若要获取<xref:System.Data.OracleClient.OracleLob>对象，请调用<xref:System.Data.OracleClient.OracleDataReader.GetOracleLob%2A>方法。  
  
 您可以构造<xref:System.Data.OracleClient.OracleLob>值为 NULL，使用此格式：  
  
```  
OracleLob myLob = OracleLob.Null;  
```  
  
 此方法主要用于测试是否`LOB`从服务器返回为 NULL，如本示例所示：  
  
```  
If(myLob == OracleLob.Null)  
```  
  
 NULL`LOB`的行为类似于零字节`LOB`在于<xref:System.Data.OracleClient.OracleLob.Read%2A>成功并始终返回零字节。  
  
 选择`LOB`包含一个 null 值的列返回<xref:System.Data.OracleClient.OracleLob.Null>。  
  
 你必须开始事务，然后才能获取临时`LOB`。 否则为<xref:System.Data.OracleClient.OracleDataReader>可能无法获取数据更高版本。  
  
 你也可以打开一个临时`LOB`通过调用 DBMS_LOB Oracle 中。CREATETEMPORARY 系统存储过程和绑定`LOB`输出参数。 在客户端，临时`LOB`行为类似基于表的`LOB`。 例如，若要更新临时`LOB`，它必须括在事务中。  
  
 下面的 C# 示例演示如何打开一个临时`LOB`。  
  
```  
OracleConnection connection = new OracleConnection("server=MyServer; integrated security=yes;");  
connection.Open();  
OracleTransaction transaction = connection.BeginTransaction();  
OracleCommand command = connection.CreateCommand();  
command.Transaction = transaction;  
command.CommandText = "declare xx blob; begin dbms_lob.createtemporary(xx, false, 0); :tempblob := xx; end;";  
command.Parameters.Add(new OracleParameter("tempblob", OracleType.Blob)).Direction = ParameterDirection.Output;  
command.ExecuteNonQuery();  
OracleLob tempLob = (OracleLob)command.Parameters[0].Value;  
byte[] tempbuff = new byte[10000];  
tempLob.BeginBatch(OracleLobOpenMode.ReadWrite);  
tempLob.Write(tempbuff,0,tempbuff.Length);  
tempLob.EndBatch();  
command.Parameters.Clear();  
command.CommandText = "MyTable.MyProc";  
command.CommandType = CommandType.StoredProcedure;    
command.Parameters.Add(new OracleParameter("ImportDoc", OracleType.Blob)).Value = tempLob;  
command.ExecuteNonQuery();  
transaction.Commit();  
connection.Close  
```  
  
> [!NOTE]
>  继承<xref:System.IO.Stream.WriteByte%2A>时用于字符数据，方法会失败和<xref:System.InvalidOperationException>引发。 请改用 <xref:System.Data.OracleClient.OracleLob.Write%2A> 方法。  
>   
>  临时`LOB`仅关闭时关闭连接，但进行池和负载情况下，临时`LOB`不会关闭。 这可以通过释放临时解决`LOB`，通过调用`tempLob.Dispose()`。  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public void Append (System.Data.OracleClient.OracleLob source);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Append(class System.Data.OracleClient.OracleLob source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.OracleClient.OracleLob.Append(System.Data.OracleClient.OracleLob)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Append (source As OracleLob)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Append(System::Data::OracleClient::OracleLob ^ source);" />
      <MemberSignature Language="F#" Value="member this.Append : System.Data.OracleClient.OracleLob -&gt; unit" Usage="oracleLob.Append source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Data.OracleClient.OracleLob" />
      </Parameters>
      <Docs>
        <param name="source">The <see langword="LOB" /> from which to append data.</param>
        <summary>Appends data from the specified <see langword="LOB" /> to the current <see langword="LOB" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 要写入到`LOB`，您必须检索`LOB`使用 FOR UPDATE 子句中的 SQL SELECT 语句，还必须具有开始的本地事务。  
  
 来自源的所有数据`LOB`追加到当前末尾`LOB`。 位置都不`LOB`计算也没有在此过程中更改。  
  
 基础数据类型必须始终相同。 例如，如果要将从追加<xref:System.Data.OracleClient.OracleType.NClob>，目标<xref:System.Data.OracleClient.OracleLob>还必须是<xref:System.Data.OracleClient.OracleType.NClob>。  
  
> [!NOTE]
>  在此版本中，对只读的写入操作`LOB`可能会成功，但不会更新`LOB`服务器上。 在这种情况下，但是的本地副本`LOB`更新。 因此，更高版本上读取操作<xref:System.Data.OracleClient.OracleLob>对象可能会返回写入操作的结果。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">The source <see cref="T:System.Data.OracleClient.OracleLob" /> is null.</exception>
        <exception cref="T:System.InvalidOperationException">The source <see cref="T:System.Data.OracleClient.OracleLob" /> is null, or the connection is closed.</exception>
        <exception cref="T:System.ObjectDisposedException">The source <see cref="T:System.Data.OracleClient.OracleLob" /> object was closed or disposed.</exception>
        <exception cref="T:System.Data.OracleClient.OracleException">An Oracle error has occurred.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginBatch">
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Prevents server-side triggers from firing while performing multiple write operations.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginBatch">
      <MemberSignature Language="C#" Value="public void BeginBatch ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BeginBatch() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.OracleClient.OracleLob.BeginBatch" />
      <MemberSignature Language="VB.NET" Value="Public Sub BeginBatch ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BeginBatch();" />
      <MemberSignature Language="F#" Value="member this.BeginBatch : unit -&gt; unit" Usage="oracleLob.BeginBatch " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Prevents server-side triggers from firing while performing multiple read operations.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 打开`LOB`中<xref:System.Data.OracleClient.OracleLobOpenMode.ReadOnly>模式; 因此，`LOB`可以只从其中读取，不会写入，直到相应地调用<xref:System.Data.OracleClient.OracleLob.EndBatch%2A>。 若要执行批处理写入`LOB`，调用<xref:System.Data.OracleClient.OracleLob.BeginBatch%2A>与<xref:System.Data.OracleClient.OracleLobOpenMode.ReadWrite>。  
  
 调用<xref:System.Data.OracleClient.OracleLob.BeginBatch%2A>不止一次在同一事务中的当前引发 Oracle"ORA 22293: LOB 同一个事务中已经打开了"错误。 此外，如果你获取`LOB`使用另一个<xref:System.Data.OracleClient.OracleDataReader>，且具有不会调用原始调用方<xref:System.Data.OracleClient.OracleLob.EndBatch%2A>生成方法，相同的错误。 因此，必须调用<xref:System.Data.OracleClient.OracleLob.EndBatch%2A>方法完成后使用<xref:System.Data.OracleClient.OracleLob>。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The connection is closed.</exception>
        <exception cref="T:System.ObjectDisposedException">The object was closed or disposed.</exception>
        <exception cref="T:System.Data.OracleClient.OracleException">An Oracle error has occurred.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginBatch">
      <MemberSignature Language="C#" Value="public void BeginBatch (System.Data.OracleClient.OracleLobOpenMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BeginBatch(valuetype System.Data.OracleClient.OracleLobOpenMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.OracleClient.OracleLob.BeginBatch(System.Data.OracleClient.OracleLobOpenMode)" />
      <MemberSignature Language="VB.NET" Value="Public Sub BeginBatch (mode As OracleLobOpenMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BeginBatch(System::Data::OracleClient::OracleLobOpenMode mode);" />
      <MemberSignature Language="F#" Value="member this.BeginBatch : System.Data.OracleClient.OracleLobOpenMode -&gt; unit" Usage="oracleLob.BeginBatch mode" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mode" Type="System.Data.OracleClient.OracleLobOpenMode" />
      </Parameters>
      <Docs>
        <param name="mode">Mode (one of the <see cref="T:System.Data.OracleClient.OracleLobOpenMode" /> values) in which the <see langword="LOB" /> can be accessed between this <see cref="M:System.Data.OracleClient.OracleLob.BeginBatch(System.Data.OracleClient.OracleLobOpenMode)" /> call and the corresponding <see cref="M:System.Data.OracleClient.OracleLob.EndBatch" /> call.</param>
        <summary>Prevents server-side triggers from firing while performing multiple read and write operations in the specified access mode.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 要写入到`LOB`，您必须检索`LOB`使用 FOR UPDATE 子句中的 SQL SELECT 语句，还必须具有开始的本地事务。  
  
 调用<xref:System.Data.OracleClient.OracleLob.BeginBatch%2A>不止一次在同一事务中的当前引发 Oracle"ORA 22293: LOB 同一个事务中已经打开了"错误。 此外，如果你获取`LOB`使用另一个<xref:System.Data.OracleClient.OracleDataReader>，且具有不会调用原始调用方<xref:System.Data.OracleClient.OracleLob.EndBatch%2A>生成方法，相同的错误。 因此，必须调用<xref:System.Data.OracleClient.OracleLob.EndBatch%2A>方法完成后使用<xref:System.Data.OracleClient.OracleLob>。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The connection is closed.</exception>
        <exception cref="T:System.ObjectDisposedException">The object was closed or disposed.</exception>
        <exception cref="T:System.Data.OracleClient.OracleException">An Oracle error has occurred.</exception>
      </Docs>
    </Member>
    <Member MemberName="CanRead">
      <MemberSignature Language="C#" Value="public override bool CanRead { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanRead" />
      <MemberSignature Language="DocId" Value="P:System.Data.OracleClient.OracleLob.CanRead" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanRead As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanRead { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanRead : bool" Usage="System.Data.OracleClient.OracleLob.CanRead" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value indicating whether the <see langword="LOB" /> stream can be read.</summary>
        <value>
          <see langword="true" /> 如果<see langword="LOB" />流支持读取，否则<see langword="false" />如果<see langword="LOB" />关闭或释放为止。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CanSeek">
      <MemberSignature Language="C#" Value="public override bool CanSeek { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanSeek" />
      <MemberSignature Language="DocId" Value="P:System.Data.OracleClient.OracleLob.CanSeek" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanSeek As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanSeek { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanSeek : bool" Usage="System.Data.OracleClient.OracleLob.CanSeek" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value indicating whether forward and backward seek operations can be performed.</summary>
        <value>
          <see langword="false" /> 如果<see langword="LOB" />关闭或断开，否则<see langword="true" />。 始终<see langword="true" />为<see cref="F:System.Data.OracleClient.OracleLob.Null" />。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CanWrite">
      <MemberSignature Language="C#" Value="public override bool CanWrite { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanWrite" />
      <MemberSignature Language="DocId" Value="P:System.Data.OracleClient.OracleLob.CanWrite" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanWrite As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanWrite { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanWrite : bool" Usage="System.Data.OracleClient.OracleLob.CanWrite" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Always returns true, regardless of whether the <see langword="LOB" /> supports writing or not.</summary>
        <value>始终返回<see langword="true" />，无论的打开或未释放<see langword="LOB" />是否，支持写入<see langword="false" />如果<see langword="LOB" />关闭或释放为止。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 要写入到`LOB`，您必须检索`LOB`使用 FOR UPDATE 子句中的 SQL SELECT 语句，你必须已启动对本地事务。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ChunkSize">
      <MemberSignature Language="C#" Value="public int ChunkSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ChunkSize" />
      <MemberSignature Language="DocId" Value="P:System.Data.OracleClient.OracleLob.ChunkSize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ChunkSize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ChunkSize { int get(); };" />
      <MemberSignature Language="F#" Value="member this.ChunkSize : int" Usage="System.Data.OracleClient.OracleLob.ChunkSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value indicating the minimum number of bytes to retrieve from or send to the server during a read/write operation.</summary>
        <value>最小要检索或发送的字节数。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 返回的值<xref:System.Data.OracleClient.OracleLob.ChunkSize%2A>属性不是适用于 Oracle 的.NET Framework 数据提供程序的设置。 相反，它是与服务器通信时使用的 Oracle 调用接口 (OCI) 的值。 使用<xref:System.Data.OracleClient.OracleLob.ChunkSize%2A>以确保客户端块区大小相同。 读取或写入在较小区块中不会缓存数据，并导致到服务器，无优化往返行程，因为未收到或发送完整的数据包。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The connection is closed.</exception>
        <exception cref="T:System.ObjectDisposedException">The object was closed or disposed.</exception>
        <exception cref="T:System.Data.OracleClient.OracleException">An Oracle error has occurred.</exception>
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public object Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.OracleClient.OracleLob.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Function Clone () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ Clone();" />
      <MemberSignature Language="F#" Value="abstract member Clone : unit -&gt; obj&#xA;override this.Clone : unit -&gt; obj" Usage="oracleLob.Clone " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ICloneable.Clone</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Creates a new <see cref="T:System.Data.OracleClient.OracleLob" /> object that references the same Oracle <see langword="LOB" /> as the original <see cref="T:System.Data.OracleClient.OracleLob" /> object.</summary>
        <returns>A new <see cref="T:System.Data.OracleClient.OracleLob" /> object that references the same Oracle <see langword="LOB" /> as the original <see cref="T:System.Data.OracleClient.OracleLob" /> object.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 新属性<xref:System.Data.OracleClient.OracleLob>对象最初具有与原始对象相同的值。 但是之后,<xref:System.Data.OracleClient.OracleLob.Clone%2A>已完成，每个<xref:System.Data.OracleClient.OracleLob>对象是相互独立。 例如，更改的值<xref:System.Data.OracleClient.OracleLob.Position%2A>原始属性<xref:System.Data.OracleClient.OracleLob>不会更改的值<xref:System.Data.OracleClient.OracleLob.Position%2A>的副本。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The connection is closed.</exception>
        <exception cref="T:System.ObjectDisposedException">The object was closed or disposed.</exception>
      </Docs>
    </Member>
    <Member MemberName="Connection">
      <MemberSignature Language="C#" Value="public System.Data.OracleClient.OracleConnection Connection { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.OracleClient.OracleConnection Connection" />
      <MemberSignature Language="DocId" Value="P:System.Data.OracleClient.OracleLob.Connection" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Connection As OracleConnection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::OracleClient::OracleConnection ^ Connection { System::Data::OracleClient::OracleConnection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Connection : System.Data.OracleClient.OracleConnection" Usage="System.Data.OracleClient.OracleLob.Connection" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.OracleClient.OracleConnection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the <see cref="T:System.Data.OracleClient.OracleConnection" /> used by this instance of the <see cref="T:System.Data.OracleClient.OracleLob" />.</summary>
        <value>到数据源的连接。</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">The object was closed or disposed.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="CopyTo">
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Copies from this <see cref="T:System.Data.OracleClient.OracleLob" /> to a destination <see cref="T:System.Data.OracleClient.OracleLob" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public long CopyTo (System.Data.OracleClient.OracleLob destination);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int64 CopyTo(class System.Data.OracleClient.OracleLob destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.OracleClient.OracleLob.CopyTo(System.Data.OracleClient.OracleLob)" />
      <MemberSignature Language="VB.NET" Value="Public Function CopyTo (destination As OracleLob) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; long CopyTo(System::Data::OracleClient::OracleLob ^ destination);" />
      <MemberSignature Language="F#" Value="override this.CopyTo : System.Data.OracleClient.OracleLob -&gt; int64" Usage="oracleLob.CopyTo destination" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Data.OracleClient.OracleLob" />
      </Parameters>
      <Docs>
        <param name="destination">The destination <see cref="T:System.Data.OracleClient.OracleLob" />.</param>
        <summary>Copies from this <see cref="T:System.Data.OracleClient.OracleLob" /> to a destination <see cref="T:System.Data.OracleClient.OracleLob" />.</summary>
        <returns>The number of bytes copied. This excludes any padded bytes.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 基础数据类型必须始终相同。 例如，如果要复制的源<xref:System.Data.OracleClient.OracleType.NClob>，目标<xref:System.Data.OracleClient.OracleLob>还必须是<xref:System.Data.OracleClient.OracleType.NClob>。  
  
 目标偏移量是否超出目标末尾`LOB`、`LOB`扩展到其中复制数据。 末尾之间的空间`LOB`和超出末尾位置的目标偏移量则用零填充`BLOB`数据类型，以空格`CLOB`和`NCLOB`数据类型。  
  
 要写入到`LOB`，您必须检索`LOB`使用 FOR UPDATE 子句中的 SQL SELECT 语句，还必须具有开始的本地事务。  
  
> [!NOTE]
>  在此版本中，对只读的写入操作`LOB`可能成功，但不是更新`LOB`服务器上。 在这种情况下，但是的本地副本`LOB`将更新。 因此，更高版本上读取操作<xref:System.Data.OracleClient.OracleLob>对象可能会返回写入操作的结果。  
>   
>  `CopyTo`方法并不会清除目标的内容`OracleLob`之前执行复制操作。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">The <see cref="T:System.Data.OracleClient.OracleLob" /> specified in the <paramref name="destination" /> parameter is null.</exception>
        <exception cref="T:System.InvalidOperationException">The operation is not within a transaction, the <see cref="T:System.Data.OracleClient.OracleLob" /> object is null, or the connection is closed.</exception>
        <exception cref="T:System.Data.OracleClient.OracleException">An Oracle error has occurred.</exception>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public long CopyTo (System.Data.OracleClient.OracleLob destination, long destinationOffset);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int64 CopyTo(class System.Data.OracleClient.OracleLob destination, int64 destinationOffset) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.OracleClient.OracleLob.CopyTo(System.Data.OracleClient.OracleLob,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function CopyTo (destination As OracleLob, destinationOffset As Long) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; long CopyTo(System::Data::OracleClient::OracleLob ^ destination, long destinationOffset);" />
      <MemberSignature Language="F#" Value="override this.CopyTo : System.Data.OracleClient.OracleLob * int64 -&gt; int64" Usage="oracleLob.CopyTo (destination, destinationOffset)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Data.OracleClient.OracleLob" />
        <Parameter Name="destinationOffset" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="destination">The destination <see cref="T:System.Data.OracleClient.OracleLob" /></param>
        <param name="destinationOffset">The offset to which to copy. For <see langword="CLOB" /> and <see langword="NCLOB" /> data types, this must be an even number of bytes.</param>
        <summary>Copies from this <see cref="T:System.Data.OracleClient.OracleLob" /> to a destination <see cref="T:System.Data.OracleClient.OracleLob" /> with the specified amount of data.</summary>
        <returns>The number of bytes copied. This excludes any padded bytes.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 基础数据类型必须始终相同。 例如，如果要复制的源<xref:System.Data.OracleClient.OracleType.NClob>，目标<xref:System.Data.OracleClient.OracleLob>还必须是<xref:System.Data.OracleClient.OracleType.NClob>。  
  
 目标偏移量是否超出目标末尾`LOB`、`LOB`扩展到其中复制数据。 末尾之间的空间`LOB`和目标超出末尾位置的偏移量则用零填充`BLOB`数据类型，以空格`CLOB`和`NCLOB`数据类型。  
  
 要写入到`LOB`，您必须检索`LOB`使用 FOR UPDATE 子句中的 SQL SELECT 语句，还必须具有开始的本地事务。  
  
> [!NOTE]
>  在此版本中，对只读的写入操作`LOB`可能会成功，但不会更新`LOB`服务器上。 在这种情况下，但是的本地副本`LOB`更新。 因此，更高版本上读取操作<xref:System.Data.OracleClient.OracleLob>对象可能会返回写入操作的结果。  
>   
>  `CopyTo`方法并不会清除目标的内容`OracleLob`之前执行复制操作。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">The <see cref="T:System.Data.OracleClient.OracleLob" /> specified in the <paramref name="destination" /> parameter is full.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">A value specified in the <paramref name="destinationOffset" /> parameter is less than zero or greater than 4 gigabytes.  -or-  A value specified in the <paramref name="destinationOffset" /> parameter for a <see langword="CLOB" /> or <see langword="NCLOB" /> data type is not even.  -or-  You must specify <see langword="CLOB" /> and <see langword="NCLOB" /> data types as an even number of bytes.</exception>
        <exception cref="T:System.InvalidOperationException">The operation is not within a transaction, the <see cref="T:System.Data.OracleClient.OracleLob" /> object is null, or the connection is closed.</exception>
        <exception cref="T:System.Data.OracleClient.OracleException">An Oracle error has occurred.</exception>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public long CopyTo (long sourceOffset, System.Data.OracleClient.OracleLob destination, long destinationOffset, long amount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int64 CopyTo(int64 sourceOffset, class System.Data.OracleClient.OracleLob destination, int64 destinationOffset, int64 amount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.OracleClient.OracleLob.CopyTo(System.Int64,System.Data.OracleClient.OracleLob,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function CopyTo (sourceOffset As Long, destination As OracleLob, destinationOffset As Long, amount As Long) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; long CopyTo(long sourceOffset, System::Data::OracleClient::OracleLob ^ destination, long destinationOffset, long amount);" />
      <MemberSignature Language="F#" Value="override this.CopyTo : int64 * System.Data.OracleClient.OracleLob * int64 * int64 -&gt; int64" Usage="oracleLob.CopyTo (sourceOffset, destination, destinationOffset, amount)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceOffset" Type="System.Int64" />
        <Parameter Name="destination" Type="System.Data.OracleClient.OracleLob" />
        <Parameter Name="destinationOffset" Type="System.Int64" />
        <Parameter Name="amount" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="sourceOffset">The offset from which to copy. For <see langword="CLOB" /> and <see langword="NCLOB" /> data types, this must be an even number.</param>
        <param name="destination">The destination <see langword="OracleLob" /><see cref="N:System.Data.OracleClient" />.</param>
        <param name="destinationOffset">The destination offset to which to copy. For <see langword="CLOB" /> and <see langword="NCLOB" /> data types, this must be an even number.</param>
        <param name="amount">The quantity of data, in bytes, to copy. For <see langword="CLOB" /> and <see langword="NCLOB" /> data types, this must be an even number.</param>
        <summary>Copies from this <see cref="T:System.Data.OracleClient.OracleLob" /> to a destination <see cref="T:System.Data.OracleClient.OracleLob" /> with the specified amount of data, and the source offset.</summary>
        <returns>The number of bytes copied. This excludes any padded bytes.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 基础数据类型必须始终相同。 例如，如果要复制的源<xref:System.Data.OracleClient.OracleType.NClob>，目标<xref:System.Data.OracleClient.OracleLob>还必须是<xref:System.Data.OracleClient.OracleType.NClob>。  
  
 目标偏移量是否超出目标末尾`LOB`、`LOB`扩展到其中复制数据。 末尾之间的空间`LOB`和目标超出末尾位置的偏移量则用零填充`BLOB`数据类型，以空格`CLOB`和`NCLOB`数据类型。  
  
 要写入到`LOB`，您必须检索`LOB`使用 FOR UPDATE 子句中的 SQL SELECT 语句，还必须具有开始的本地事务。  
  
> [!NOTE]
>  在此版本中，对只读的写入操作`LOB`可能会成功，但不会更新`LOB`服务器上。 在这种情况下，但是的本地副本`LOB`更新。 因此，更高版本上读取操作<xref:System.Data.OracleClient.OracleLob>对象可能会返回写入操作的结果。  
>   
>  `CopyTo`方法并不会清除目标的内容`OracleLob`之前执行复制操作。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">The <see cref="T:System.Data.OracleClient.OracleLob" /> specified in the <paramref name="destination" /> parameter is full.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">A value specified in the <paramref name="amount" />, <paramref name="sourceOffset" />, or <paramref name="destinationOffset" /> parameter is less than zero or greater than 4 gigabytes.  -or-  A value specified in the <paramref name="amount" />, <paramref name="sourceOffset" />, or <paramref name="destinationOffset" /> parameter for a <see langword="CLOB" /> or <see langword="NCLOB" /> data type is not even.</exception>
        <exception cref="T:System.InvalidOperationException">The operation is not within a transaction, the <see cref="T:System.Data.OracleClient.OracleLob" /> object is null, or the connection is closed.</exception>
        <exception cref="T:System.Data.OracleClient.OracleException">An Oracle error has occurred.</exception>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.OracleClient.OracleLob.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="override this.Dispose : bool -&gt; unit" Usage="oracleLob.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EndBatch">
      <MemberSignature Language="C#" Value="public void EndBatch ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EndBatch() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.OracleClient.OracleLob.EndBatch" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndBatch ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EndBatch();" />
      <MemberSignature Language="F#" Value="member this.EndBatch : unit -&gt; unit" Usage="oracleLob.EndBatch " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Allows server-side triggers to resume firing after performing multiple write operations.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 调用<xref:System.Data.OracleClient.OracleLob.BeginBatch%2A>方法开始执行之前在写入操作<xref:System.Data.OracleClient.OracleLob>。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The connection is closed.</exception>
        <exception cref="T:System.ObjectDisposedException">The object was closed or disposed.</exception>
        <exception cref="T:System.Data.OracleClient.OracleException">An Oracle error has occurred.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Erase">
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Erases data from this <see cref="T:System.Data.OracleClient.OracleLob" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Erase">
      <MemberSignature Language="C#" Value="public long Erase ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int64 Erase() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.OracleClient.OracleLob.Erase" />
      <MemberSignature Language="VB.NET" Value="Public Function Erase () As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; long Erase();" />
      <MemberSignature Language="F#" Value="member this.Erase : unit -&gt; int64" Usage="oracleLob.Erase " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Erases all data from this <see cref="T:System.Data.OracleClient.OracleLob" />.</summary>
        <returns>The number of bytes erased.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.OracleClient.OracleLob.Erase%2A> 不会不会截断数据。 `LOB`长度保持不变的`BLOB`数据类型和清除的数据替换为 0x00。 `CLOB` 和`NCLOB`数据类型替换为空格。  
  
 要写入到`LOB`，您必须检索`LOB`使用 FOR UPDATE 子句中的 SQL SELECT 语句，还必须具有开始的本地事务。  
  
> [!NOTE]
>  在此版本中，对只读的写入操作`LOB`可能会成功，但不会更新`LOB`服务器上。 在这种情况下，但是的本地副本`LOB`更新。 因此，更高版本上读取操作<xref:System.Data.OracleClient.OracleLob>对象可能会返回写入操作的结果。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The operation is not within a transaction, the <see cref="T:System.Data.OracleClient.OracleLob" /> object is null, or the connection is closed.</exception>
        <exception cref="T:System.ObjectDisposedException">The object was closed or disposed.</exception>
        <exception cref="T:System.Data.OracleClient.OracleException">An Oracle error has occurred.</exception>
      </Docs>
    </Member>
    <Member MemberName="Erase">
      <MemberSignature Language="C#" Value="public long Erase (long offset, long amount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int64 Erase(int64 offset, int64 amount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.OracleClient.OracleLob.Erase(System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function Erase (offset As Long, amount As Long) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; long Erase(long offset, long amount);" />
      <MemberSignature Language="F#" Value="member this.Erase : int64 * int64 -&gt; int64" Usage="oracleLob.Erase (offset, amount)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="offset" Type="System.Int64" />
        <Parameter Name="amount" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="offset">The offset from which to erase. For <see langword="CLOB" /> and <see langword="NCLOB" /> data types, this must be an even number.</param>
        <param name="amount">The quantity of data, in bytes, to erase. For <see langword="CLOB" /> and <see langword="NCLOB" /> data types, this must be an even number.</param>
        <summary>Erases the specified amount of data from this <see cref="T:System.Data.OracleClient.OracleLob" />.</summary>
        <returns>The number of bytes erased.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 中的值的总和`offset`和`amount`参数可以是大于的大小<xref:System.Data.OracleClient.OracleLob>。 因此，指定的值比返回大<xref:System.Data.OracleClient.OracleLob.Length%2A>属性成功; 但是<xref:System.Data.OracleClient.OracleLob.Erase%2A>仅清除到末尾<xref:System.Data.OracleClient.OracleLob>。 (同样，如果传递给负值`offset`，<xref:System.Data.OracleClient.OracleLob.Erase%2A>将成功，但从的开头开始，才清除<xref:System.Data.OracleClient.OracleLob>。)此行为是不同的<xref:System.Data.OracleClient.OracleLob.Read%2A>和<xref:System.Data.OracleClient.OracleLob.Write%2A>方法和产品/服务的优势在于能够擦除所有数据值指定`offset`而不对其他往返进行服务器验证的实际大小。  
  
 <xref:System.Data.OracleClient.OracleLob.Erase%2A> 不会不会截断数据。 `LOB`长度保持不变的`BLOB`数据类型和清除的数据替换为 0x00。 `CLOB` 和`NCLOB`数据类型替换为空格。  
  
 要写入到`LOB`，您必须检索`LOB`使用 FOR UPDATE 子句中的 SQL SELECT 语句，还必须具有开始的本地事务。  
  
> [!NOTE]
>  在此版本中，对只读的写入操作`LOB`可能会成功，但不会更新`LOB`服务器上。 在这种情况下，但是的本地副本`LOB`更新。 因此，更高版本上读取操作<xref:System.Data.OracleClient.OracleLob>对象可能会返回写入操作的结果。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The operation is not within a transaction, the <see cref="T:System.Data.OracleClient.OracleLob" /> object is null, or the connection is closed.</exception>
        <exception cref="T:System.ObjectDisposedException">The object was closed or disposed.</exception>
        <exception cref="T:System.Data.OracleClient.OracleException">An Oracle error has occurred.</exception>
      </Docs>
    </Member>
    <Member MemberName="Flush">
      <MemberSignature Language="C#" Value="public override void Flush ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Flush() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.OracleClient.OracleLob.Flush" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Flush ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Flush();" />
      <MemberSignature Language="F#" Value="override this.Flush : unit -&gt; unit" Usage="oracleLob.Flush " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Not currently supported.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在此版本中，此方法不起作用。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsBatched">
      <MemberSignature Language="C#" Value="public bool IsBatched { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsBatched" />
      <MemberSignature Language="DocId" Value="P:System.Data.OracleClient.OracleLob.IsBatched" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsBatched As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsBatched { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsBatched : bool" Usage="System.Data.OracleClient.OracleLob.IsBatched" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value indicating whether an application called the <see cref="M:System.Data.OracleClient.OracleLob.BeginBatch" /> method.</summary>
        <value>
          <see langword="true" /> 如果应用程序调用<see cref="M:System.Data.OracleClient.OracleLob.BeginBatch" />方法，否则为<see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当使用 Oracle 8.0.5 服务器，Oracle"ORA 00600： 内部错误代码"会引发异常。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Data.OracleClient.OracleException">An Oracle error has occurred.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsNull">
      <MemberSignature Language="C#" Value="public bool IsNull { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNull" />
      <MemberSignature Language="DocId" Value="P:System.Data.OracleClient.OracleLob.IsNull" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNull As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNull { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsNull : bool" Usage="System.Data.OracleClient.OracleLob.IsNull" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Data.SqlTypes.INullable.IsNull</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value that indicates whether the <see cref="T:System.Data.OracleClient.OracleLob" /> is a <see cref="F:System.Data.OracleClient.OracleBFile.Null" /> stream.</summary>
        <value>
          <see langword="true" /> 如果<see cref="T:System.Data.OracleClient.OracleLob" />是<see cref="F:System.Data.OracleClient.OracleBFile.Null" />流，否则为<see langword="false" />。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsTemporary">
      <MemberSignature Language="C#" Value="public bool IsTemporary { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsTemporary" />
      <MemberSignature Language="DocId" Value="P:System.Data.OracleClient.OracleLob.IsTemporary" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsTemporary As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsTemporary { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsTemporary : bool" Usage="System.Data.OracleClient.OracleLob.IsTemporary" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value indicating whether the <see cref="T:System.Data.OracleClient.OracleLob" /> is a temporary <see langword="LOB" />.</summary>
        <value>
          <see langword="true" /> 如果<see cref="T:System.Data.OracleClient.OracleLob" />是临时<see langword="LOB" />，否则为<see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下面的示例演示如何创建一个临时`LOB`。  
  
```  
OracleConnection connection = new OracleConnection("server=MyServer; integrated security=yes;");  
connection.Open();  
OracleTransaction transaction = connection.BeginTransaction();  
OracleCommand command = connection.CreateCommand();  
command.Transaction = transaction;  
command.CommandText = "declare xx blob; begin dbms_lob.createtemporary(xx, false, 0); :tempblob := xx; end;";  
command.Parameters.Add(new OracleParameter("tempblob", OracleType.Blob)).Direction = ParameterDirection.Output;  
command.ExecuteNonQuery();  
OracleLob tempLob = (OracleLob)command.Parameters[0].Value;  
tempLob.BeginBatch(OracleLobOpenMode.ReadWrite);  
tempLob.Write(tempbuff,0,tempbuff.Length);  
tempLob.EndBatch();  
command.Parameters.Clear();  
command.CommandText = "MyTable.MyProc";  
command.CommandType = CommandType.StoredProcedure;    
command.Parameters.Add(new OracleParameter("ImportDoc", OracleType.Blob)).Value = tempLob;  
command.ExecuteNonQuery();  
transaction.Commit();  
connection.Close  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The connection is closed.</exception>
        <exception cref="T:System.ObjectDisposedException">The object was closed or disposed.</exception>
        <exception cref="T:System.Data.OracleClient.OracleException">An Oracle error has occurred.</exception>
      </Docs>
    </Member>
    <Member MemberName="Length">
      <MemberSignature Language="C#" Value="public override long Length { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 Length" />
      <MemberSignature Language="DocId" Value="P:System.Data.OracleClient.OracleLob.Length" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Length As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property long Length { long get(); };" />
      <MemberSignature Language="F#" Value="member this.Length : int64" Usage="System.Data.OracleClient.OracleLob.Length" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value that returns the size of the <see cref="T:System.Data.OracleClient.OracleLob" />.</summary>
        <value>大小<see cref="T:System.Data.OracleClient.OracleLob" />以字节为单位。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 大小<xref:System.Data.OracleClient.OracleLob>始终返回以字节为单位的所有数据。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The connection is closed.</exception>
        <exception cref="T:System.ObjectDisposedException">The object was closed or disposed.</exception>
        <exception cref="T:System.Data.OracleClient.OracleException">An Oracle error has occurred.</exception>
      </Docs>
    </Member>
    <Member MemberName="LobType">
      <MemberSignature Language="C#" Value="public System.Data.OracleClient.OracleType LobType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Data.OracleClient.OracleType LobType" />
      <MemberSignature Language="DocId" Value="P:System.Data.OracleClient.OracleLob.LobType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LobType As OracleType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::OracleClient::OracleType LobType { System::Data::OracleClient::OracleType get(); };" />
      <MemberSignature Language="F#" Value="member this.LobType : System.Data.OracleClient.OracleType" Usage="System.Data.OracleClient.OracleLob.LobType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.OracleClient.OracleType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value that returns the <see langword="LOB" /> data type.</summary>
        <value>之一<see cref="T:System.Data.OracleClient.OracleType" /><see langword="LOB" />数据类型。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.OracleClient.OracleLob>可能是下列项之一<xref:System.Data.OracleClient.OracleType>数据类型。  
  
|OracleType 数据类型|描述|  
|--------------------------|-----------------|  
|`Blob`|Oracle`BLOB`包含最大大小为 4 千兆字节的二进制数据的数据类型。 此方法映射到<xref:System.Array>类型的<xref:System.Byte>。|  
|`Clob`|Oracle`CLOB`包含字符数据，基于默认字符的数据类型设置在服务器上，最大大小为 4 千兆字节。 此方法映射到<xref:System.String>。|  
|`NClob`|Oracle`NCLOB`基于最大大小为 4 千兆字节在服务器上的区域字符集包含字符数据的数据类型。 此方法映射到<xref:System.String>。|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Null">
      <MemberSignature Language="C#" Value="public static readonly System.Data.OracleClient.OracleLob Null;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Data.OracleClient.OracleLob Null" />
      <MemberSignature Language="DocId" Value="F:System.Data.OracleClient.OracleLob.Null" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Null As OracleLob " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Data::OracleClient::OracleLob ^ Null;" />
      <MemberSignature Language="F#" Value=" staticval mutable Null : System.Data.OracleClient.OracleLob" Usage="System.Data.OracleClient.OracleLob.Null" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.OracleClient.OracleLob</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Represents a null <see cref="T:System.Data.OracleClient.OracleLob" /> object.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 您可以构造<xref:System.Data.OracleClient.OracleLob>值为 NULL，使用此格式：  
  
```  
OracleLob myLob = OracleLOB.Null;  
```  
  
 此方法主要用于测试是否`LOB`从服务器返回为 NULL，如本示例所示：  
  
```  
If(myLob == OracleLob.Null)  
```  
  
 NULL`LOB`的行为类似于零字节`LOB`在于<xref:System.Data.OracleClient.OracleLob.Read%2A>成功并始终返回零字节。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Position">
      <MemberSignature Language="C#" Value="public override long Position { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 Position" />
      <MemberSignature Language="DocId" Value="P:System.Data.OracleClient.OracleLob.Position" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Position As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property long Position { long get(); void set(long value); };" />
      <MemberSignature Language="F#" Value="member this.Position : int64 with get, set" Usage="System.Data.OracleClient.OracleLob.Position" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the current read position in the <see cref="T:System.Data.OracleClient.OracleLob" /> stream.</summary>
        <value>中的当前位置<see cref="T:System.Data.OracleClient.OracleLob" />流。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 流必须支持查找要获取或设置位置。 使用<xref:System.Data.OracleClient.OracleLob.CanSeek%2A>属性以确定流是否支持查找。  
  
 支持查找到流的长度超出任何位置。 查找到的奇数位置`CLOB`和`NCLOB`还支持数据类型。 有关详细信息，请参阅备注部分的<xref:System.Data.OracleClient.OracleLob.Read%2A>属性。  
  
 <xref:System.Data.OracleClient.OracleLob.Position%2A>属性不会不跟踪的从和 / 或已用完，跳过，流的字节数。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The connection is closed.</exception>
        <exception cref="T:System.ObjectDisposedException">The object was closed or disposed.</exception>
      </Docs>
    </Member>
    <Member MemberName="Read">
      <MemberSignature Language="C#" Value="public override int Read (byte[] buffer, int offset, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 Read(unsigned int8[] buffer, int32 offset, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.OracleClient.OracleLob.Read(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Read (buffer As Byte(), offset As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int Read(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count);" />
      <MemberSignature Language="F#" Value="override this.Read : byte[] * int * int -&gt; int" Usage="oracleLob.Read (buffer, offset, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">An array of bytes. When this method returns, the buffer contains the specified byte array with the values between <c>offset</c> and (<c>offset</c> + <c>count</c>) replaced by the bytes read from the current source.</param>
        <param name="offset">The zero-based byte offset in <c>buffer</c> at which to begin storing the data read from the current stream. For <see langword="CLOB" /> and <see langword="NCLOB" /> data types, this must be an even number.</param>
        <param name="count">The maximum number of bytes to be read from the current stream. For <see langword="CLOB" /> and <see langword="NCLOB" /> data types, this must be an even number.</param>
        <summary>Reads a sequence of bytes from the current <see cref="T:System.Data.OracleClient.OracleLob" /> stream and advances the position within the stream by the number of bytes read.</summary>
        <returns>The total number of bytes read into the buffer. This may be less than the number of bytes requested if that many bytes are not currently available, or zero (0) if the end of the stream has been reached.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.OracleClient.OracleLob.Read%2A>方法读取的最多`count`字节从当前流，并且将它们存储在`buffer`开始`offset`。 流中的当前位置高级通过读取; 的字节数但是，如果发生异常，将流中的当前位置保持不变。 <xref:System.Data.OracleClient.OracleLob.Read%2A> 返回读取的字节数。 仅当位置当前在流末尾，则返回值为零。 <xref:System.Data.OracleClient.OracleLob.Read%2A> 将一直阻止到至少一个字节的数据可供读取的事件中不会提供数据。<xref:System.Data.OracleClient.OracleLob.Read%2A> 如果你尝试要从其中进行读取，则返回 0`LOB`当前位置时末尾`LOB`。 <xref:System.Data.OracleClient.OracleLob.Read%2A> 即使尚未达到流结尾，则可以返回少于所请求的字节。  
  
 适用于 Oracle 的.NET Framework 数据提供程序将处理所有`CLOB`和`NCLOB`为 Unicode 数据。 因此，在访问时`CLOB`和`NCLOB`数据类型，你始终处理的字节，其中每个字符是 2 个字节数。 例如，如果包含三个字符的文本字符串保存为`NCLOB`Oracle 服务器的字符集为每个字符，4 个字节，其中你执行上`Read`操作，则指定的字符串的长度为 6 个字节，尽管它是存储为在服务器上的 12 个字节。  
  
 下面的 C# 示例演示如何读取<xref:System.Data.OracleClient.OracleLob>对象。  
  
```  
public static void ReadLobExample(OracleCommand command)  
{  
   int actual = 0;  
  
   //Select some data.  
   // Table Schema:  
   //  "CREATE TABLE TableWithLobs (a int, b BLOB, c CLOB, d NCLOB)";  
   //  "INSERT INTO TableWithLobs values (1, 'AA', 'AAA', N'AAAA')";  
   command.CommandText = "SELECT * FROM TableWithLobs";  
   OracleDataReader reader = command.ExecuteReader();  
   using(reader)  
   {  
      //Obtain the first row of data.  
      reader.Read();  
      //Obtain the LOBs (all 3 varieties).  
      OracleLob BLOB = reader.GetOracleLob(1);  
      OracleLob CLOB  = reader.GetOracleLob(2);  
      OracleLob NCLOB = reader.GetOracleLob(3);  
  
      //Example - Reading binary data (in chunks).  
      byte[] buffer = new byte[100];  
      while((actual = BLOB.Read(buffer, 0, buffer.Length)) >0)  
         Console.WriteLine(BLOB.LobType + ".Read(" + buffer + ", " + buffer.Length + ") => " + actual);  
  
      //Example - Reading CLOB/NCLOB data (in chunks).  
      //Note: You can read character data as raw Unicode bytes (using OracleLob.Read as in the above example).  
      //However, because the OracleLob object inherits directly from the.NET stream object,   
      //all the existing classes that manipluate streams can also be used. For example, the   
      //.NET StreamReader makes converting the raw bytes into actual characters easier.  
      StreamReader streamreader = new StreamReader(CLOB, Encoding.Unicode);  
      char[] cbuffer = new char[100];  
      while((actual = streamreader.Read(cbuffer, 0, cbuffer.Length)) >0)  
         Console.WriteLine(CLOB.LobType + ".Read(" + new string(cbuffer, 0, actual) + ", " + cbuffer.Length + ") => " + actual);  
  
      //Example - Reading data (all at once).  
      //You could use StreamReader.ReadToEnd to obtain all the string data,or simply  
      //call OracleLob.Value to obtain a contiguous allocation of all the data.  
      Console.WriteLine(NCLOB.LobType + ".Value => " + NCLOB.Value);  
   }  
}  
```  
  
 您可以构造<xref:System.Data.OracleClient.OracleLob>值为 NULL，使用此格式：  
  
```  
OracleLob myLob = OracleLob.Null;  
```  
  
 此方法主要用于测试是否`LOB`从服务器返回为 NULL，如下面的示例所示。  
  
```  
If(myLob == OracleLob.Null)  
```  
  
 NULL`LOB`的行为类似于零字节`LOB`在于<xref:System.Data.OracleClient.OracleLob.Read%2A>成功并始终返回零字节。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">The <paramref name="buffer" /> is a null reference (<see langword="Nothing" /> in Visual Basic).</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">A value in the <paramref name="offset" /> or <paramref name="count" /> parameter is not positive.  -or-  The sum of the offset and count parameters is larger than the buffer length.  -or-  A value specified in the <paramref name="amount" /> or <paramref name="offset" /> parameter is less than zero or greater than 4 gigabytes.</exception>
        <exception cref="T:System.InvalidOperationException">The operation is not within a transaction, the <see cref="T:System.Data.OracleClient.OracleLob" /> object is null, or the connection is closed.</exception>
        <exception cref="T:System.ObjectDisposedException">The object was closed or disposed.</exception>
        <exception cref="T:System.Data.OracleClient.OracleException">An Oracle error has occurred.</exception>
      </Docs>
    </Member>
    <Member MemberName="Seek">
      <MemberSignature Language="C#" Value="public override long Seek (long offset, System.IO.SeekOrigin origin);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int64 Seek(int64 offset, valuetype System.IO.SeekOrigin origin) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.OracleClient.OracleLob.Seek(System.Int64,System.IO.SeekOrigin)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Seek (offset As Long, origin As SeekOrigin) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override long Seek(long offset, System::IO::SeekOrigin origin);" />
      <MemberSignature Language="F#" Value="override this.Seek : int64 * System.IO.SeekOrigin -&gt; int64" Usage="oracleLob.Seek (offset, origin)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="offset" Type="System.Int64" />
        <Parameter Name="origin" Type="System.IO.SeekOrigin" />
      </Parameters>
      <Docs>
        <param name="offset">A byte offset relative to origin. If <c>offset</c> is negative, the new position precedes the position specified by <c>origin</c> by the number of bytes specified by <c>offset</c>. If <c>offset</c> is zero, the new position is the position specified by <c>origin</c>. If <c>offset</c> is positive, the new position follows the position specified by <c>origin</c> by the number of bytes specified by <c>offset</c>.</param>
        <param name="origin">A value of type <see cref="T:System.IO.SeekOrigin" /> indicating the reference point used to obtain the new position.</param>
        <summary>Sets the position on the current <see cref="T:System.Data.OracleClient.OracleLob" /> stream.</summary>
        <returns>The new position within the current stream.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果`offset`为负，新位置必须位于之前指定的位置`origin`按指定的字节数`offset`。 如果`offset`为零，新位置必须是指定的位置`origin`。 如果`offset`为正，新位置必须遵循指定的位置`origin`按指定的字节数`offset`。  
  
 支持查找到流的长度超出任何位置。 查找到的奇数位置`CLOB`和`NCLOB`还支持数据类型。 有关详细信息，请参阅备注部分的<xref:System.Data.OracleClient.OracleLob.Read%2A>属性。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">The <paramref name="origin" /> parameter does not contain a valid value.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">The resulting position is beyond the length of the value.</exception>
        <exception cref="T:System.ObjectDisposedException">The <see cref="T:System.Data.OracleClient.OracleLob" /> object was closed or disposed.</exception>
        <exception cref="T:System.Data.OracleClient.OracleException">An Oracle error has occurred.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetLength">
      <MemberSignature Language="C#" Value="public override void SetLength (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void SetLength(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.OracleClient.OracleLob.SetLength(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub SetLength (value As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void SetLength(long value);" />
      <MemberSignature Language="F#" Value="override this.SetLength : int64 -&gt; unit" Usage="oracleLob.SetLength value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value">The desired length of the current <see cref="T:System.Data.OracleClient.OracleLob" /> stream in bytes. For <see langword="CLOB" /> and <see langword="NCLOB" /> data types, this must be an even number.</param>
        <summary>Sets the length of the <see cref="T:System.Data.OracleClient.OracleLob" /> stream to a value less than the current length.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 尝试增加的长度<xref:System.Data.OracleClient.OracleLob>流失败，并返回"消息： ORA 22926： 指定剪裁长度大于当前 LOB 值的长度"从 Oracle 服务器。  
  
 流必须支持写入和查找有关<xref:System.Data.OracleClient.OracleLob.SetLength%2A>到函数。  
  
 适用于 Oracle 的.NET Framework 数据提供程序将处理所有`CLOB`和`NCLOB`为 Unicode 数据。 因此，在访问时`CLOB`和`NCLOB`数据类型，你始终处理的字节，其中每个字符是 2 个字节数。 例如，如果包含三个字符的文本字符串保存为`NCLOB`Oracle 服务器的字符集为每个字符，4 个字节，其中你执行上`SetLength`操作，则指定的字符串的长度为 6 个字节，尽管它是存储为在服务器上的 12 个字节。  
  
 要写入到`LOB`，您必须检索`LOB`使用 FOR UPDATE 子句中的 SQL SELECT 语句，还必须具有开始的本地事务。  
  
> [!NOTE]
>  A 会写入操作的只读`LOB`可能会成功，但不会更新`LOB`服务器上。 在这种情况下，但是的本地副本`LOB`更新。 因此，更高版本上读取操作<xref:System.Data.OracleClient.OracleLob>对象可能会返回写入操作的结果。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">A value specified in the <paramref name="value" /> parameter for a <see langword="CLOB" /> or <see langword="NCLOB" /> data type is not even.  -or-  A value specified in the <paramref name="value" /> parameter is less than zero or greater than 4 gigabytes.</exception>
        <exception cref="T:System.InvalidOperationException">The operation is not within a transaction, the <see cref="T:System.Data.OracleClient.OracleLob" /> object is null, or the connection is closed.</exception>
        <exception cref="T:System.ObjectDisposedException">The object was closed or disposed.</exception>
        <exception cref="T:System.Data.OracleClient.OracleException">An Oracle error has occurred.</exception>
      </Docs>
    </Member>
    <Member MemberName="Value">
      <MemberSignature Language="C#" Value="public object Value { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Value" />
      <MemberSignature Language="DocId" Value="P:System.Data.OracleClient.OracleLob.Value" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Value As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ Value { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Value : obj" Usage="System.Data.OracleClient.OracleLob.Value" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the common language runtime stream value equivalent of the underlying value.</summary>
        <value>有关<see cref="F:System.Data.OracleClient.OracleType.Blob" />，类型的数组<see langword="Byte[]" />。 有关<see cref="F:System.Data.OracleClient.OracleType.Clob" />和<see cref="F:System.Data.OracleClient.OracleType.NClob" />、 <see langword="String" />。 为 null 数据一样， <see cref="T:System.DBNull" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 有关<xref:System.Data.OracleClient.OracleType.Blob>数据类型，<xref:System.Data.OracleClient.OracleLob.Value%2A>连续类型的数组的形式返回整个基础数据`Byte[]`。 有关<xref:System.Data.OracleClient.OracleType.Clob>和<xref:System.Data.OracleClient.OracleType.NClob>数据类型，<xref:System.Data.OracleClient.OracleLob.Value%2A>返回所有数据作为`String`数据类型。 为 null 数据一样，<xref:System.Data.OracleClient.OracleLob.Value%2A>返回<xref:System.DBNull>。 通过比较返回的值，可以区分空数据、 null 数据和数据。  
  
> [!NOTE]
>  使用的优点`LOB`数据类型是可检索大量数据在客户端的小区块中的功能。 但是，当使用<xref:System.Data.OracleClient.OracleLob.Value%2A>，获取有关的所有数据`LOB`列作为一个连续的区块，这可以显著提高应用程序开销。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">The object was closed or disposed.</exception>
        <exception cref="T:System.Data.OracleClient.OracleException">An Oracle error has occurred.</exception>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public override void Write (byte[] buffer, int offset, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Write(unsigned int8[] buffer, int32 offset, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.OracleClient.OracleLob.Write(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Write (buffer As Byte(), offset As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Write(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count);" />
      <MemberSignature Language="F#" Value="override this.Write : byte[] * int * int -&gt; unit" Usage="oracleLob.Write (buffer, offset, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">An array of bytes. This method copies the number of bytes specified in <c>count</c> from <c>buffer</c> to the current stream.</param>
        <param name="offset">The zero-based byte offset in <c>buffer</c> at which to begin copying bytes to the current stream. For <see langword="CLOB" /> and <see langword="NCLOB" /> data types, this must be an even number.</param>
        <param name="count">The number of bytes to be written to the current stream. For <see langword="CLOB" /> and <see langword="NCLOB" /> data types, this must be an even number.</param>
        <summary>Writes a sequence of bytes to the current <see cref="T:System.Data.OracleClient.OracleLob" /> stream, and advances the current position within this stream by the number of bytes written.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果写入操作成功，将流内的位置向前移动写入的字节数。 如果发生异常，流中的位置将保持不变。  
  
 结尾之外写入`LOB`允许和放大`LOB`通过写入的字节数。  
  
 适用于 Oracle 的.NET Framework 数据提供程序将处理所有`CLOB`和`NCLOB`为 Unicode 数据。 因此，在访问时`CLOB`和`NCLOB`数据类型，你始终处理的字节，其中每个字符是 2 个字节数。 例如，如果包含三个字符的文本字符串保存为`NCLOB`Oracle 服务器的字符集为每个字符，4 个字节，其中你执行上`Write`操作，则指定的字符串的长度为 6 个字节，尽管它是存储为在服务器上的 12 个字节。  
  
 要写入到`LOB`，您必须检索`LOB`使用 FOR UPDATE 子句中的 SQL SELECT 语句，还必须具有开始的本地事务。  
  
 下面的 C# 示例演示如何将写入到<xref:System.Data.OracleClient.OracleLob>对象。  
  
```  
public static void WriteLobExample(OracleCommand command)  
{  
   //Note: Updating LOB data requires a transaction.  
   command.Transaction = command.Connection.BeginTransaction();  
   //Select some data.  
   //    Table Schema:  
   //        "CREATE TABLE tablewithlobs (a int, b BLOB, c BLOB)";  
   //        "INSERT INTO tablewithlobs values (1, 'AA', 'AAA')";  
   command.CommandText = "SELECT * FROM TableWithLobs FOR UPDATE";  
   OracleDataReader reader = command.ExecuteReader();  
   using(reader)  
   {  
      //Obtain the first row of data.  
      reader.Read();  
      //Obtain both LOBs.  
      OracleLob BLOB1    = reader.GetOracleLob(1);  
      OracleLob BLOB2    = reader.GetOracleLob(2);  
      //Perform any desired operations on the LOB, (read, position, and so on).  
      //...  
      //Example - Writing binary data (directly to the backend).  
      //To write, you can use any of the stream classes, or write raw binary data using   
      //the OracleLob write method. Writing character vs. binary is the same;  
      //however note that character is always in terms of Unicode byte counts  
      //(for example: even number of bytes - 2 bytes for every Unicode character).  
      byte[] buffer = new byte[100];  
      buffer[0] = 0xCC;  
      buffer[1] = 0xDD;  
      BLOB1.Write(buffer, 0, 2);  
      BLOB1.Position = 0;  
      Console.WriteLine(BLOB1.LobType + ".Write(" + buffer + ", 0, 2) => " + BLOB1.Value);  
  
      //Example - Copying data into another LOB.  
      long actual = BLOB1.CopyTo(BLOB2);  
      Console.WriteLine(BLOB1.LobType + ".CopyTo(" + BLOB2.Value + ") => " + actual);  
  
      //Commit the transaction now that everything succeeded.  
      //Note: On error, Transaction.Dispose is called (from the using statement)  
      //and will automatically roll-back the pending transaction.  
      command.Transaction.Commit();  
   }  
}  
```  
  
> [!NOTE]
>  A 会写入操作的只读`LOB`可能会成功，但不会更新`LOB`服务器上。 在这种情况下，但是的本地副本`LOB`更新。 因此，更高版本上读取操作<xref:System.Data.OracleClient.OracleLob>对象可能会返回写入操作的结果。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">The <paramref name="buffer" /> parameter is a null reference (<see langword="Nothing" /> in Visual Basic).</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">A value in the <paramref name="offset" /> or <paramref name="count" /> parameter is not positive.  -or-  The sum of the <paramref name="offset" /> and <paramref name="count" /> parameters is larger than the <paramref name="buffer" /> length.  -or-  A value specified in the <paramref name="count" /> or <paramref name="offset" /> parameter is less than zero or greater than 4 gigabytes.  -or-  You must specify <see langword="CLOB" /> and <see langword="NCLOB" /> data types as an even number of bytes.</exception>
        <exception cref="T:System.InvalidOperationException">The operation is not within a transaction, the <see cref="T:System.Data.OracleClient.OracleLob" /> object is null, or the connection is closed.</exception>
        <exception cref="T:System.ObjectDisposedException">The object was closed or disposed.</exception>
        <exception cref="T:System.Data.OracleClient.OracleException">An Oracle error has occurred.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteByte">
      <MemberSignature Language="C#" Value="public override void WriteByte (byte value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void WriteByte(unsigned int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.OracleClient.OracleLob.WriteByte(System.Byte)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub WriteByte (value As Byte)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void WriteByte(System::Byte value);" />
      <MemberSignature Language="F#" Value="override this.WriteByte : byte -&gt; unit" Usage="oracleLob.WriteByte value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Byte" />
      </Parameters>
      <Docs>
        <param name="value">The byte to write to the stream.</param>
        <summary>Writes a byte to the current position in the <see cref="T:System.Data.OracleClient.OracleLob" /> stream, and advances the position within the stream by one byte.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果写入操作是否成功，将流中的位置向前推进 1 个字节。 如果发生异常，流中的位置将保持不变。  
  
 结尾之外写入`LOB`允许和放大`LOB`1 个字节。  
  
 要写入到`LOB`，您必须检索`LOB`使用 FOR UPDATE 子句中的 SQL SELECT 语句，还必须具有开始的本地事务。  
  
> [!NOTE]
>  A 会写入操作的只读`LOB`可能会成功，但不会更新`LOB`服务器上。 在这种情况下，但是的本地副本`LOB`更新。 因此，更高版本上读取操作<xref:System.Data.OracleClient.OracleLob>对象可能会返回写入操作的结果。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>