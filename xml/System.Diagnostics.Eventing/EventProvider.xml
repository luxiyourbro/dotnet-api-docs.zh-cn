<Type Name="EventProvider" FullName="System.Diagnostics.Eventing.EventProvider">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="816ff1f71aad7b0d0e608e281fb24f1227accf03" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-CN" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30399351" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class EventProvider : IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit EventProvider extends System.Object implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Diagnostics.Eventing.EventProvider" />
  <TypeSignature Language="VB.NET" Value="Public Class EventProvider&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class EventProvider : IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Core</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>该类可用于写入事件。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要使用事件使用编写<xref:System.Diagnostics.Eventing.EventProvider.WriteEvent%2A>和<xref:System.Diagnostics.Eventing.EventProvider.WriteTransferEvent%2A>方法，事件都必须定义清单; 中写入使用事件<xref:System.Diagnostics.Eventing.EventProvider.WriteMessageEvent%2A>方法不需要清单。  
  
 事件可以包含以下托管的数据类型：  
  
-   bool  
  
-   Boolean  
  
-   byte  
  
-   char  
  
-   decimal  
  
-   double  
  
-   float  
  
-   GUID  
  
-   int  
  
-   IntPtr  
  
-   long  
  
-   sbyte  
  
-   short  
  
-   字符串  
  
-   uint  
  
-   UInt64  
  
 如果你的清单中的事件使用`Boolean`，类型不能写入数据元素使用`Boolean`托管代码中的数据类型。 `Boolean`类型在清单中需要 4 字节值，和一个`Boolean`在托管代码中的数据类型为 1 字节。 相反，你必须使用`int`写值的数据类型。 如果你想要登录`Boolean`值，请使用 UInt8 类型在清单中。  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public EventProvider (Guid providerGuid);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Guid providerGuid) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Eventing.EventProvider.#ctor(System.Guid)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (providerGuid As Guid)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; EventProvider(Guid providerGuid);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="providerGuid" Type="System.Guid" />
      </Parameters>
      <Docs>
        <param name="providerGuid">唯一标识提供程序的 GUID。</param>
        <summary>初始化 <see cref="T:System.Diagnostics.Eventing.EventProvider" /> 类的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 注册提供程序。 若要删除的注册完成后，调用<xref:System.Diagnostics.Eventing.EventProvider.Close%2A>方法。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InsufficientMemoryException">没有足够的内存来完成该操作。</exception>
        <exception cref="T:System.PlatformNotSupportedException">
          <see cref="N:System.Diagnostics.Eventing" /> 命名空间中的类仅适用于 Windows Vista。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="providerGuid" /> 参数不能为 null。</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">由 ETW 子系统返回的错误。</exception>
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public virtual void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Eventing.EventProvider.Close" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Close();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>从 ETW 子系统中移除提供程序的注册并释放所有非托管资源。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 你应调用此方法完成而不是等待系统后，若要释放的资源。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">由 ETW 子系统返回的错误。</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateActivityId">
      <MemberSignature Language="C#" Value="public static Guid CreateActivityId ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Guid CreateActivityId() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Eventing.EventProvider.CreateActivityId" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateActivityId () As Guid" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Guid CreateActivityId();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Guid</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>为提供程序创建一个唯一的活动标识符。</summary>
        <returns>在调用 <see cref="M:System.Diagnostics.Eventing.EventProvider.SetActivityId(System.Guid@)" /> 方法为提供程序设置活动标识符时使用的唯一 GUID。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 这是静态方法。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Eventing.EventProvider.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>释放此 <see cref="T:System.Diagnostics.Eventing.EventProvider" /> 对象使用的资源。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Eventing.EventProvider.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Dispose(bool disposing);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">由于没有任何非托管的资源，因此此方法会忽略该参数。</param>
        <summary>释放此 <see cref="T:System.Diagnostics.Eventing.EventProvider" /> 对象使用的资源。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~EventProvider ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Eventing.EventProvider.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!EventProvider ()" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>在通过垃圾回收将实例回收之前，释放资源并执行内部清理。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetLastWriteEventError">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Eventing.EventProvider.WriteEventErrorCode GetLastWriteEventError ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Diagnostics.Eventing.EventProvider/WriteEventErrorCode GetLastWriteEventError() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Eventing.EventProvider.GetLastWriteEventError" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetLastWriteEventError () As EventProvider.WriteEventErrorCode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Diagnostics::Eventing::EventProvider::WriteEventErrorCode GetLastWriteEventError();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Eventing.EventProvider+WriteEventErrorCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>获取与事件写入失败相关联的最后一个错误。</summary>
        <returns>该值可用于确定事件写入失败的原因。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Eventing.EventProvider.WriteEvent%2A>， <xref:System.Diagnostics.Eventing.EventProvider.WriteMessageEvent%2A>，和<xref:System.Diagnostics.Eventing.EventProvider.WriteTransferEvent%2A>方法将此值进行了设置，如果他们未能写入该事件。  
  
 这是静态方法。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="IsEnabled">
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>确定该提供程序是否已经由某个会话启用。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsEnabled">
      <MemberSignature Language="C#" Value="public bool IsEnabled ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsEnabled() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Eventing.EventProvider.IsEnabled" />
      <MemberSignature Language="VB.NET" Value="Public Function IsEnabled () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsEnabled();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>确定该提供程序是否已经由某个会话启用，而与用来启用该提供程序的级别值和关键字值无关。</summary>
        <returns>如果已为某个会话启用该提供程序，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 通常情况下，提供程序不调用此方法以确定是否已由会话; 启用提供程序提供程序只需写入该事件，并 ETW 确定是否将事件记录到会话。 一个提供程序可能想要调用此函数，如果提供程序需要执行额外的工作，以生成事件。 在这种情况下，调用此函数首先可以节省资源和时间。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsEnabled">
      <MemberSignature Language="C#" Value="public bool IsEnabled (byte level, long keywords);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsEnabled(unsigned int8 level, int64 keywords) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Eventing.EventProvider.IsEnabled(System.Byte,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsEnabled (level As Byte, keywords As Long) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsEnabled(System::Byte level, long keywords);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="level" Type="System.Byte" />
        <Parameter Name="keywords" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="level">包括在该事件中的详细程度。</param>
        <param name="keywords">指定事件类别的位掩码。 此掩码应当与在该事件的清单中定义的关键字掩码相同。</param>
        <summary>确认是否有任何会话正在从该提供程序请求指定的事件。</summary>
        <returns>如果有任何会话正在请求指定的事件，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 通常情况下，提供程序不调用此方法以确定是否会话请求指定的事件;提供程序只需写入该事件，并 ETW 确定是否将事件记录到会话。 一个提供程序可能想要调用此函数，如果提供程序需要执行额外的工作，以生成事件。 在这种情况下，调用此函数首先确定是否会话或不请求的事件，可以节省资源和时间。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetActivityId">
      <MemberSignature Language="C#" Value="public static void SetActivityId (ref Guid id);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetActivityId(valuetype System.Guid&amp; id) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Eventing.EventProvider.SetActivityId(System.Guid@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetActivityId (ByRef id As Guid)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetActivityId(Guid % id);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.Guid&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="id">由 <see cref="M:System.Diagnostics.Eventing.EventProvider.CreateActivityId" /> 方法返回的唯一活动标识符。</param>
        <summary>设置由 <see cref="Overload:System.Diagnostics.Eventing.EventProvider.WriteEvent" /> 方法使用的当前活动标识符。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 标识符存储在线程上下文中。  
  
 请注意，在.NET framework 版本 3.5 中，你必须设置`id`此方法的参数和<xref:System.Diagnostics.CorrelationManager.ActivityId%2A>属性值设置为相同的标识符值。 但是，在的 framework 版本 4.0<xref:System.Diagnostics.Eventing.EventProvider.SetActivityId%2A>方法会自动为您设置的相关活动标识符。  
  
 这是静态方法。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteEvent">
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>写入某个事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果你使用清单来定义事件，请使用这些方法。  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteEvent">
      <MemberSignature Language="C#" Value="public bool WriteEvent (ref System.Diagnostics.Eventing.EventDescriptor eventDescriptor, params object[] eventPayload);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool WriteEvent(valuetype System.Diagnostics.Eventing.EventDescriptor&amp; eventDescriptor, object[] eventPayload) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Eventing.EventProvider.WriteEvent(System.Diagnostics.Eventing.EventDescriptor@,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function WriteEvent (ByRef eventDescriptor As EventDescriptor, ParamArray eventPayload As Object()) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool WriteEvent(System::Diagnostics::Eventing::EventDescriptor % eventDescriptor, ... cli::array &lt;System::Object ^&gt; ^ eventPayload);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="eventDescriptor" Type="System.Diagnostics.Eventing.EventDescriptor&amp;" RefType="ref" />
        <Parameter Name="eventPayload" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="eventDescriptor">用来标识要写入的事件的 <see cref="T:System.Diagnostics.Eventing.EventDescriptor" /> 实例。</param>
        <param name="eventPayload">包含要写入的事件数据的对象数组。 该对象必须采用清单中所指定的顺序。 该数组限制为 32 个对象，其中只有八个对象可以是字符串。 事件数据的最大大小限制为 64 KB 减去事件头大小所得的值。 如果会话的缓冲区较小，而且会话中包括事件的扩展数据项，则该事件会较小。  
  
 此参数可以为 null。</param>
        <summary>写入某个事件。 以对象数组形式指定事件数据。</summary>
        <returns>如果写入此事件，则为 <see langword="true" />；否则为 <see langword="false" />。 如果为 false，则调用 <see cref="M:System.Diagnostics.Eventing.EventProvider.GetLastWriteEventError" /> 方法来确定失败的原因。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果调用<xref:System.Diagnostics.Eventing.EventProvider.SetActivityId%2A>方法，以指定事件，此方法的活动标识符从线程上下文中检索的标识符，并包括与该事件。  
  
 如果不支持的对象类型，则该方法将对象的值<xref:System.Object.ToString%2A?displayProperty=nameWithType>负载中的方法。 有关受支持的对象类型的列表，请参阅备注<xref:System.Diagnostics.Eventing.EventProvider>类。  
  
   
  
## Examples  
  
```  
private static Guid providerId = new Guid("{FB33FDA8-45FB-4df0-8A55-EEB4BA88E7E7}");  
  
enum Keyword  
{  
    Read = 0x1,  
    Write = 0x2,  
    Local = 0x4,  
    Remote = 0x8  
}  
  
enum Level  
{  
    Critical = 1,  
    Error,  
    Warning,  
    Information,  
    Verbose  
}  
  
    EventProvider provider = new EventProvider(providerId);  
    EventDescriptor readEvent;  
    string path = @"<PATHGOESHERE>";  
    UInt64 bytesRead = <ASSIGNVALUE>;  
  
    if (provider.IsEnabled(Level.Information, (long)Keyword.Read))  
    {  
        unchecked  
        {  
            readEvent = new EventDescriptor(0x1, 0x0, 0x10, 0x4, 0x0, 0x0, (long)0x8000000000000005);  
        }  
  
        if (!provider.WriteEvent(ref readEvent, new object[] { path, bytesRead }))  
            Console.WriteLine(EventProvider.GetLastWriteEventError());  
    }  
  
    provider.Close();  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="eventPayload" /> 参数包含的对象或字符串太多。</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteEvent">
      <MemberSignature Language="C#" Value="public bool WriteEvent (ref System.Diagnostics.Eventing.EventDescriptor eventDescriptor, string data);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool WriteEvent(valuetype System.Diagnostics.Eventing.EventDescriptor&amp; eventDescriptor, string data) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Eventing.EventProvider.WriteEvent(System.Diagnostics.Eventing.EventDescriptor@,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function WriteEvent (ByRef eventDescriptor As EventDescriptor, data As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool WriteEvent(System::Diagnostics::Eventing::EventDescriptor % eventDescriptor, System::String ^ data);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="eventDescriptor" Type="System.Diagnostics.Eventing.EventDescriptor&amp;" RefType="ref" />
        <Parameter Name="data" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="eventDescriptor">用来标识要写入的事件的 <see cref="T:System.Diagnostics.Eventing.EventDescriptor" /> 实例。</param>
        <param name="data">要作为事件数据写入的字符串。</param>
        <summary>写入某个事件。 以字符串形式指定事件数据。</summary>
        <returns>如果写入此事件，则为 <see langword="true" />；否则为 <see langword="false" />。 如果为 false，则调用 <see cref="M:System.Diagnostics.Eventing.EventProvider.GetLastWriteEventError" /> 方法来确定失败的原因。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果调用<xref:System.Diagnostics.Eventing.EventProvider.SetActivityId%2A>方法，以指定事件，此方法的活动标识符从线程上下文中检索的标识符，并包括与该事件。  
  
 最大字符串长度为减事件标头的大小限制为 64 KB。 如果会话的缓冲区较小，而且会话中包括事件的扩展数据项，则该事件会较小。  
  
   
  
## Examples  
  
```  
private static Guid providerId = new Guid("{FB33FDA8-45FB-4df0-8A55-EEB4BA88E7E7}");  
  
EventProvider provider = new EventProvider(providerId);  
EventDescriptor writeEvent;  
  
if (provider.IsEnabled())  
{  
     unchecked  
     {  
          writeEvent = new EventDescriptor(0x2, 0x0, 0x10, 0x3, 0x0, 0x0, (long)0x8000000000000006);  
     }  
  
     if (!provider.WriteEvent(ref writeEvent, "Write event."))  
          Console.WriteLine(EventProvider.GetLastWriteEventError());  
}  
  
provider.Close();  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">如果 <paramref name="data" /> 为 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteEvent">
      <MemberSignature Language="C#" Value="protected bool WriteEvent (ref System.Diagnostics.Eventing.EventDescriptor eventDescriptor, int dataCount, IntPtr data);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance bool WriteEvent(valuetype System.Diagnostics.Eventing.EventDescriptor&amp; eventDescriptor, int32 dataCount, native int data) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Eventing.EventProvider.WriteEvent(System.Diagnostics.Eventing.EventDescriptor@,System.Int32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Protected Function WriteEvent (ByRef eventDescriptor As EventDescriptor, dataCount As Integer, data As IntPtr) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; bool WriteEvent(System::Diagnostics::Eventing::EventDescriptor % eventDescriptor, int dataCount, IntPtr data);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="eventDescriptor" Type="System.Diagnostics.Eventing.EventDescriptor&amp;" RefType="ref" />
        <Parameter Name="dataCount" Type="System.Int32" />
        <Parameter Name="data" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="eventDescriptor">用来标识要写入的事件的 <see cref="T:System.Diagnostics.Eventing.EventDescriptor" /> 实例。</param>
        <param name="dataCount">
          <c>data</c> 参数所指向的事件数据的大小。 事件数据的最大大小限制为 64 KB 减去事件头大小所得的值。 如果会话的缓冲区较小，而且会话中包括事件的扩展数据项，则该事件会较小。</param>
        <param name="data">指向要写入的事件数据的指针。</param>
        <summary>写入某个事件。 以内存块形式指定事件数据。</summary>
        <returns>如果写入此事件，则为 <see langword="true" />；否则为 <see langword="false" />。 如果为 false，则调用 <see cref="M:System.Diagnostics.Eventing.EventProvider.GetLastWriteEventError" /> 方法来确定失败的原因。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果调用<xref:System.Diagnostics.Eventing.EventProvider.SetActivityId%2A>方法，以指定事件，此方法的活动标识符从线程上下文中检索的标识符，并包括与该事件。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteMessageEvent">
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>写入一个包含字符串数据的事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 这些方法不需要清单即可使用该事件。  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteMessageEvent">
      <MemberSignature Language="C#" Value="public bool WriteMessageEvent (string eventMessage);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool WriteMessageEvent(string eventMessage) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Eventing.EventProvider.WriteMessageEvent(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function WriteMessageEvent (eventMessage As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool WriteMessageEvent(System::String ^ eventMessage);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="eventMessage" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="eventMessage">要作为事件数据写入的字符串。</param>
        <summary>写入一个包含字符串数据的事件。</summary>
        <returns>如果写入此事件，则为 <see langword="true" />；否则为 <see langword="false" />。 如果为 false，则调用 <see cref="M:System.Diagnostics.Eventing.EventProvider.GetLastWriteEventError" /> 方法来确定失败的原因。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 最大字符串长度为减事件标头的大小限制为 64 KB。 如果会话的缓冲区较小，而且会话中包括事件的扩展数据项，则该事件会较小。  
  
   
  
## Examples  
  
```  
if (!provider.WriteMessageEvent("Event string."))  
    Console.WriteLine(EventProvider.GetLastWriteEventError());  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">如果 <paramref name="eventMessage" /> 为 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteMessageEvent">
      <MemberSignature Language="C#" Value="public bool WriteMessageEvent (string eventMessage, byte eventLevel, long eventKeywords);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool WriteMessageEvent(string eventMessage, unsigned int8 eventLevel, int64 eventKeywords) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Eventing.EventProvider.WriteMessageEvent(System.String,System.Byte,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function WriteMessageEvent (eventMessage As String, eventLevel As Byte, eventKeywords As Long) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool WriteMessageEvent(System::String ^ eventMessage, System::Byte eventLevel, long eventKeywords);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="eventMessage" Type="System.String" />
        <Parameter Name="eventLevel" Type="System.Byte" />
        <Parameter Name="eventKeywords" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="eventMessage">要作为事件数据写入的字符串。</param>
        <param name="eventLevel">包括在该事件中的详细程度。 如果提供程序使用某个清单来定义该事件，请将此值设置为该清单中定义的级别。</param>
        <param name="eventKeywords">指定事件类别的位掩码。 如果提供程序使用某个清单来定义该事件，请将此值设置为在该清单中定义的关键字掩码。</param>
        <summary>如果级别值和关键字值与该会话所请求的事件相匹配，则写入一个包含字符串数据的事件。</summary>
        <returns>如果写入此事件，则为 <see langword="true" />；否则为 <see langword="false" />。 如果为 false，则调用 <see cref="M:System.Diagnostics.Eventing.EventProvider.GetLastWriteEventError" /> 方法来确定失败的原因。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 最大字符串长度为减事件标头的大小限制为 64 KB。 如果会话的缓冲区较小，而且会话中包括事件的扩展数据项，则该事件会较小。  
  
   
  
## Examples  
  
```  
// Calling this method with level and keyword set to zero is the same  
// as calling WriteMessageEvent(string); the event is always written.  
if (!provider.WriteMessageEvent("Event string.", 0, 0))  
    Console.WriteLine(EventProvider.GetLastWriteEventError());  
  
// Event is written if the level value of the session is less than or equal to 3, and bit 1 of the session  
// keyword bit-mask is set.  
if (!provider.WriteMessageEvent("Event string.", 3, 2))  
    Console.WriteLine(EventProvider.GetLastWriteEventError());  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">如果 <paramref name="eventMessage" /> 为 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteTransferEvent">
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>在端到端方案中跟踪事件时将多个事件链接在一起。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteTransferEvent">
      <MemberSignature Language="C#" Value="public bool WriteTransferEvent (ref System.Diagnostics.Eventing.EventDescriptor eventDescriptor, Guid relatedActivityId, params object[] eventPayload);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool WriteTransferEvent(valuetype System.Diagnostics.Eventing.EventDescriptor&amp; eventDescriptor, valuetype System.Guid relatedActivityId, object[] eventPayload) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Eventing.EventProvider.WriteTransferEvent(System.Diagnostics.Eventing.EventDescriptor@,System.Guid,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function WriteTransferEvent (ByRef eventDescriptor As EventDescriptor, relatedActivityId As Guid, ParamArray eventPayload As Object()) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool WriteTransferEvent(System::Diagnostics::Eventing::EventDescriptor % eventDescriptor, Guid relatedActivityId, ... cli::array &lt;System::Object ^&gt; ^ eventPayload);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="eventDescriptor" Type="System.Diagnostics.Eventing.EventDescriptor&amp;" RefType="ref" />
        <Parameter Name="relatedActivityId" Type="System.Guid" />
        <Parameter Name="eventPayload" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="eventDescriptor">用来标识要写入的事件的 <see cref="T:System.Diagnostics.Eventing.EventDescriptor" /> 实例。</param>
        <param name="relatedActivityId">上一个组件的活动标识符。 使用该参数可以将您的组件的事件链接到上一个组件的事件。</param>
        <param name="eventPayload">包含要写入的事件数据的对象数组。 该数据必须采用清单中所指定的顺序。 该数组限制为 32 个对象，其中只有八个对象可以是字符串。 事件数据的最大大小限制为 64 KB 减去事件头大小所得的值。 如果会话的缓冲区较小，而且会话中包括事件的扩展数据项，则该事件会较小。</param>
        <summary>在端到端方案中跟踪事件时将多个事件链接在一起。 以对象数组形式指定事件数据。</summary>
        <returns>如果写入此事件，则为 <see langword="true" />；否则为 <see langword="false" />。 如果为 false，则调用 <see cref="M:System.Diagnostics.Eventing.EventProvider.GetLastWriteEventError" /> 方法来确定失败的原因。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 方法使用的线程上下文中设置的活动 ID 来标识此组件。 若要设置活动 ID，调用<xref:System.Diagnostics.Eventing.EventProvider.SetActivityId%2A>方法。  
  
 如果你使用<xref:System.Diagnostics.Trace>类，你不使用<xref:System.Diagnostics.Eventing.EventProvider.SetActivityId%2A>方法，以指定活动 id。 相反，访问<xref:System.Diagnostics.Trace.CorrelationManager%2A>属性来获取<xref:System.Diagnostics.CorrelationManager>对象。 然后，设置<xref:System.Diagnostics.CorrelationManager.ActivityId%2A>属性设置为活动 id。 你还必须设置`relatedActivityId`到<xref:System.Diagnostics.CorrelationManager.ActivityId%2A>值。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">如果 <paramref name="eventPayload" /> 包含的对象或字符串太多。</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteTransferEvent">
      <MemberSignature Language="C#" Value="protected bool WriteTransferEvent (ref System.Diagnostics.Eventing.EventDescriptor eventDescriptor, Guid relatedActivityId, int dataCount, IntPtr data);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance bool WriteTransferEvent(valuetype System.Diagnostics.Eventing.EventDescriptor&amp; eventDescriptor, valuetype System.Guid relatedActivityId, int32 dataCount, native int data) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Eventing.EventProvider.WriteTransferEvent(System.Diagnostics.Eventing.EventDescriptor@,System.Guid,System.Int32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Protected Function WriteTransferEvent (ByRef eventDescriptor As EventDescriptor, relatedActivityId As Guid, dataCount As Integer, data As IntPtr) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; bool WriteTransferEvent(System::Diagnostics::Eventing::EventDescriptor % eventDescriptor, Guid relatedActivityId, int dataCount, IntPtr data);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="eventDescriptor" Type="System.Diagnostics.Eventing.EventDescriptor&amp;" RefType="ref" />
        <Parameter Name="relatedActivityId" Type="System.Guid" />
        <Parameter Name="dataCount" Type="System.Int32" />
        <Parameter Name="data" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="eventDescriptor">用来标识要写入的事件的 <see cref="T:System.Diagnostics.Eventing.EventDescriptor" /> 实例。</param>
        <param name="relatedActivityId">上一个组件的活动标识符。 使用该参数可以将您的组件的事件链接到上一个组件的事件。</param>
        <param name="dataCount">
          <c>data</c> 参数所指向的事件数据的大小。 事件数据的最大大小限制为 64 KB 减去事件头大小所得的值。 如果会话的缓冲区较小，而且会话中包括事件的扩展数据项，则该事件会较小。</param>
        <param name="data">指向要写入的事件数据的指针。</param>
        <summary>在端到端方案中跟踪事件时将多个事件链接在一起。 以内存块形式指定事件数据。</summary>
        <returns>如果写入此事件，则为 <see langword="true" />；否则为 <see langword="false" />。 如果为 false，则调用 <see cref="M:System.Diagnostics.Eventing.EventProvider.GetLastWriteEventError" /> 方法来确定失败的原因。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 方法使用的线程上下文中设置的活动 ID 来标识此组件。 若要设置活动 ID，调用<xref:System.Diagnostics.Eventing.EventProvider.SetActivityId%2A>方法。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>