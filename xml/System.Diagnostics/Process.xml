<Type Name="Process" FullName="System.Diagnostics.Process">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="10bf0daa3bd3743fd402cdd8f360d421086b0ea5" />
    <Meta Name="ms.sourcegitcommit" Value="0ec122ee5f3681159b8460ab15b409fd6e3d3ae0" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-CN" />
    <Meta Name="ms.lasthandoff" Value="10/04/2018" />
    <Meta Name="ms.locfileid" Value="48662903" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class Process : System.ComponentModel.Component" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit Process extends System.ComponentModel.Component" />
  <TypeSignature Language="DocId" Value="T:System.Diagnostics.Process" />
  <TypeSignature Language="VB.NET" Value="Public Class Process&#xA;Inherits Component" />
  <TypeSignature Language="C++ CLI" Value="public ref class Process : System::ComponentModel::Component" />
  <TypeSignature Language="F#" Value="type Process = class&#xA;    inherit Component" />
  <AssemblyInfo>
    <AssemblyName>System.Diagnostics.Process</AssemblyName>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-4.5">System.ComponentModel.Component</BaseTypeName>
  </Base>
  <Interfaces></Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.ComponentModel.DefaultEvent("Exited")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.ComponentModel.DefaultProperty("StartInfo")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.ComponentModel.Designer("System.Diagnostics.Design.ProcessDesigner, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Diagnostics.MonitoringDescription("Provides access to local and remote processes, enabling starting and stopping of local processes.")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1">
      <AttributeName>System.ComponentModel.Designer("System.Diagnostics.Design.ProcessDesigner, System.Design, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
      <AttributeName>System.ComponentModel.Designer("System.Diagnostics.Design.ProcessDesigner, System.Design, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.Diagnostics.MonitoringDescription("ProcessDesc")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8">
      <AttributeName>System.ComponentModel.Designer("System.Diagnostics.Design.ProcessDesigner, System.Design, Version=2.0.5.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>提供对本地和远程进程的访问权限并使你能够启动和停止本地系统进程。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 一个<xref:System.Diagnostics.Process>组件提供了在计算机运行进程的访问权限。 进程，在最简单的术语中，是正在运行的应用。 线程是操作系统向其分配处理器时间的基本单位。 一个线程可以执行进程，包括当前正由另一个线程执行的部分的任何的代码的部分。  
  
 <xref:System.Diagnostics.Process>组件是用于启动、 停止、 控制和监视应用的有用工具。 可以使用<xref:System.Diagnostics.Process>组件，以获取正在运行的进程的列表或您可以启动一个新的进程。 一个<xref:System.Diagnostics.Process>组件用于访问系统进程。 之后<xref:System.Diagnostics.Process>初始化组件，则它可用于获取有关正在运行的进程的信息。 此类信息包括的一套线程，加载的模块 （.dll 和.exe 文件），以及使用的性能信息，例如进程的内存量。  
  
 此类型实现<xref:System.IDisposable>接口。 在使用完类型后，您应直接或间接释放类型。 若要直接释放类型，调用其<xref:System.IDisposable.Dispose%2A>中的方法`try` / `finally`块。 若要间接释放类型，请使用 `using`（在 C# 中）或 `Using`（在 Visual Basic 中）等语言构造。 有关详细信息，请参阅中的"使用对象实现 IDisposable"一节<xref:System.IDisposable>接口主题。  
  
> [!NOTE]
>  32 位进程不能访问 64 位进程的模块。 如果你尝试从 32 位进程获取有关 64 位进程的信息，则会获得<xref:System.ComponentModel.Win32Exception>异常。 64 位进程，但是，可以访问的 32 位进程的模块。  
  
 进程组件获取一次性全部有关属性组的信息。 之后<xref:System.Diagnostics.Process>组件已获取有关任何组的一个成员的信息，它将缓存在该组中的其他属性的值并不获取有关组的其他成员的新信息，直到你调用<xref:System.Diagnostics.Process.Refresh%2A>方法。 因此，属性值无法保证要比上次调用任何新<xref:System.Diagnostics.Process.Refresh%2A>方法。 组细分与操作系统相关。  
  
 如果必须声明在系统中用引号引起来的路径变量，必须完全限定路径的启动在该位置中找到任何进程时。 否则，系统将不到的路径。 例如，如果`c:\mypath`不是在你的路径，并将其使用引号引起来添加： `path = %path%;"c:\mypath"`，必须完全符合中的任何进程`c:\mypath`时启动它。  
  
 系统进程由其进程标识符是唯一标识系统上。 许多 Windows 与资源一样，进程也由其句柄，这可能不是在计算机上唯一标识。 句柄是资源的标识符的通用术语。 操作系统仍然存在进程句柄，可通过访问<xref:System.Diagnostics.Process.Handle%2A>属性的<xref:System.Diagnostics.Process>组件，即使进程已退出。 因此，可以获取进程的管理信息，如<xref:System.Diagnostics.Process.ExitCode%2A>（通常或者为零表示成功或非零错误代码） 和<xref:System.Diagnostics.Process.ExitTime%2A>。 句柄是非常有价值的资源，所以句柄泄漏内存比危害更大。  
  
> [!NOTE]
>  此类包含一个链接要求和继承要求在类级别应用于所有成员。 一个<xref:System.Security.SecurityException>直接调用方或派生的类没有完全信任权限时引发。 有关安全要求的详细信息，请参阅[链接要求](~/docs/framework/misc/link-demands.md)。  
  
<a name="Core"></a>   
## <a name="includenetcoreincludesnet-core-mdmd-notes"></a>[!INCLUDE[net_core](~/includes/net-core-md.md)] 说明  
 在.NET Framework 中，<xref:System.Diagnostics.Process>默认使用的类<xref:System.Console>编码，通常是代码页编码，输入、 输出和错误流。 有关示例代码，代码页 437 上系统区域性为英语 （美国），是用于的默认编码<xref:System.Console>类。 但是，[!INCLUDE[net_core](~/includes/net-core-md.md)]可能会使仅这些编码的受限子网可用。 如果是这样，它将使用<xref:System.Text.Encoding.UTF8%2A?displayProperty=nameWithType>作为默认编码。  
  
 如果<xref:System.Diagnostics.Process>对象依赖于特定代码页编码，您仍然可以它们可通过执行以下*之前*调用任何<xref:System.Diagnostics.Process>方法：  
  
1.  将 System.Text.Encoding.CodePages.dll 程序集的引用添加到你的项目。  
  
2.  检索<xref:System.Text.EncodingProvider>对象从<xref:System.Text.CodePagesEncodingProvider.Instance%2A?displayProperty=nameWithType>属性。  
  
3.  传递<xref:System.Text.EncodingProvider>对象传递给<xref:System.Text.Encoding.RegisterProvider%2A?displayProperty=nameWithType>方法，使其他可用的编码提供程序支持的编码。  
  
 <xref:System.Diagnostics.Process>类将自动使用默认系统编码而不 UTF8，前提是你在任何调用之前注册编码提供程序<xref:System.Diagnostics.Process>方法。  
  
   
  
## Examples  
 下面的示例使用的实例<xref:System.Diagnostics.Process>类，以启动的进程。  
  
 [!code-cpp[Process.Start_instance#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.Start_instance/CPP/processstart.cpp#1)]
 [!code-csharp[Process.Start_instance#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.Start_instance/CS/processstart.cs#1)]
 [!code-vb[Process.Start_instance#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.Start_instance/VB/processstart.vb#1)]  
  
 下面的示例使用<xref:System.Diagnostics.Process>类本身和静态<xref:System.Diagnostics.Process.Start%2A>方法启动的进程。  
  
 [!code-cpp[Process.Start_static#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.Start_static/CPP/processstartstatic.cpp#1)]
 [!code-csharp[Process.Start_static#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.Start_static/CS/processstartstatic.cs#1)]
 [!code-vb[Process.Start_static#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.Start_static/VB/processstartstatic.vb#1)]  
  
 下面的 F # 示例定义`runProc`将启动一个进程的函数捕获所有的输出和错误消息，并记录的进程运行的毫秒数。  `runProc`函数具有三个参数： 应用程序启动，要提供给应用程序，并开始目录的自变量的名称。  
  
 [!code-fsharp[System.Diagnostics.Process#1](~/samples/snippets/fsharp/VS_Snippets_CLR_System/system.diagnostics.process/fs/Start1.fs#1)]  
  
 代码`runProc`函数通过编写[ImaginaryDevelopment](http://fssnip.net/authors/ImaginaryDevelopment)下提供[Microsoft 公共许可证](https://opensource.org/licenses/ms-pl)。  
  
 ]]></format>
    </remarks>
    <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">对于直接调用方的完全信任。 部分受信任的代码不能使用此类。</permission>
    <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand">继承者完全信任。 不能由部分受信任代码继承此类。</permission>
    <altmember cref="M:System.Diagnostics.Process.Start" />
    <altmember cref="T:System.Diagnostics.ProcessStartInfo" />
    <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
    <altmember cref="M:System.Diagnostics.Process.Kill" />
    <altmember cref="T:System.Diagnostics.ProcessThread" />
    <related type="ExternalDocumentation" href="https://code.msdn.microsoft.com/windowsdesktop/Using-the-NET-Process-Class-d70597ef">使用.NET 进程类</related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Process ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Process();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>初始化 <see cref="T:System.Diagnostics.Process" /> 类的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果未指定<xref:System.Diagnostics.Process.MachineName%2A>属性，则默认为本地计算机 ("。")。  
  
 有两个选项可用于将一个新<xref:System.Diagnostics.Process>组件与计算机上的进程。 第一个选项是使用构造函数创建<xref:System.Diagnostics.Process>组件，将设置的适当成员<xref:System.Diagnostics.Process.StartInfo%2A>属性并调用<xref:System.Diagnostics.Process.Start%2A>关联<xref:System.Diagnostics.Process>与新的系统进程。 第二个选项是将相关联<xref:System.Diagnostics.Process>与使用正在运行的系统进程<xref:System.Diagnostics.Process.GetProcessById%2A>或其中一个<xref:System.Diagnostics.Process.GetProcesses%2A>返回值。  
  
 如果您使用`static`的重载<xref:System.Diagnostics.Process.Start%2A>方法以启动一个新的系统进程，该方法创建一个新<xref:System.Diagnostics.Process>组件并将它与进程相关联。  
  
 当<xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=nameWithType>属性设置为其默认值`true`，可以使用类似的方式启动应用程序和文档`Run`对话框中的 Windows`Start`菜单。 当<xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=nameWithType>是`false`，可以启动的可执行文件。  
  
 可以从命令行调用任何可执行文件可在两种方式之一启动： 通过设置适当的成员<xref:System.Diagnostics.Process.StartInfo%2A>属性并调用<xref:System.Diagnostics.Process.Start%2A>方法不带任何参数，或通过将传递到适当的参数`static` <xref:System.Diagnostics.Process.Start%2A>成员。  
  
 您可以创建<xref:System.Diagnostics.Process>组件使用的构造函数，其中一个静态<xref:System.Diagnostics.Process.Start%2A>重载，或任一<xref:System.Diagnostics.Process.GetProcessById%2A>， <xref:System.Diagnostics.Process.GetProcesses%2A>，或<xref:System.Diagnostics.Process.GetProcessesByName%2A>方法。 这样做了之后，必须为关联进程的视图。 这不是进程属性已更改在内存中时自动更新自身的动态视图。 相反，您必须调用<xref:System.Diagnostics.Process.Refresh%2A>为要更新的组件<xref:System.Diagnostics.Process>在应用程序中的属性信息。  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">对于直接调用方的完全信任。 此成员不能由部分信任的代码使用。</permission>
      </Docs>
    </Member>
    <Member MemberName="BasePriority">
      <MemberSignature Language="C#" Value="public int BasePriority { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 BasePriority" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.BasePriority" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property BasePriority As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int BasePriority { int get(); };" />
      <MemberSignature Language="F#" Value="member this.BasePriority : int" Usage="System.Diagnostics.Process.BasePriority" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Base process priority.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessBasePriority")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取关联进程的基本优先级。</summary>
        <value>基本优先级，从关联进程的 <see cref="P:System.Diagnostics.Process.PriorityClass" /> 计算。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.BasePriority%2A>的过程是关联的进程内创建的线程的起始优先级。 可以查看有关通过系统监视器的基本优先级计数器的基本优先级的信息。  
  
 根据运行时间或其他提升，操作系统可以更改的基本优先级，当进程应放置领先于其他的时间。  
  
 <xref:System.Diagnostics.Process.BasePriority%2A>属性，可以查看分配给进程的启动优先级。 但是，因为它是只读的不能使用<xref:System.Diagnostics.Process.BasePriority%2A>设置进程的优先级。 若要更改的优先级，使用<xref:System.Diagnostics.Process.PriorityClass%2A>属性。 <xref:System.Diagnostics.Process.BasePriority%2A>可查看使用系统监视器，而<xref:System.Diagnostics.Process.PriorityClass%2A>不是。 同时<xref:System.Diagnostics.Process.BasePriority%2A>和<xref:System.Diagnostics.Process.PriorityClass%2A>可以以编程方式查看。 下表显示了之间的关系<xref:System.Diagnostics.Process.BasePriority%2A>值和<xref:System.Diagnostics.Process.PriorityClass%2A>值。  
  
|BasePriority|PriorityClass|  
|------------------|-------------------|  
|4|<xref:System.Diagnostics.ProcessPriorityClass.Idle>|  
|8|<xref:System.Diagnostics.ProcessPriorityClass.Normal>|  
|13|<xref:System.Diagnostics.ProcessPriorityClass.High>|  
|24|<xref:System.Diagnostics.ProcessPriorityClass.RealTime>|  
  
   
  
## Examples  
 以下示例启动记事本的实例。 该示例然后检索并显示关联的进程的各种属性。 该示例检测时在进程退出，并显示该进程的退出代码。  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">该平台是 Windows 98 或 Windows Millennium Edition (Windows Me)；将 <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> 属性设置为 <see langword="false" />，以在 Windows 98 和 Windows Me 上访问此属性。</exception>
        <exception cref="T:System.InvalidOperationException">该进程已退出。  
  
或 
尚未启动进程，因此没有进程 ID。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">对于直接调用方的完全信任。 此成员不能由部分信任的代码使用。</permission>
        <altmember cref="P:System.Diagnostics.Process.PriorityClass" />
        <altmember cref="T:System.Diagnostics.ProcessPriorityClass" />
        <altmember cref="T:System.Diagnostics.ThreadPriorityLevel" />
      </Docs>
    </Member>
    <Member MemberName="BeginErrorReadLine">
      <MemberSignature Language="C#" Value="public void BeginErrorReadLine ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BeginErrorReadLine() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.BeginErrorReadLine" />
      <MemberSignature Language="VB.NET" Value="Public Sub BeginErrorReadLine ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BeginErrorReadLine();" />
      <MemberSignature Language="F#" Value="member this.BeginErrorReadLine : unit -&gt; unit" Usage="process.BeginErrorReadLine " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>在应用程序的重定向 <see cref="P:System.Diagnostics.Process.StandardError" /> 流上开始进行异步读取操作。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.StandardError%2A>可以读取流，以同步方式还是以异步方式。 等方法<xref:System.IO.StreamReader.Read%2A>， <xref:System.IO.StreamReader.ReadLine%2A>，和<xref:System.IO.StreamReader.ReadToEnd%2A>执行同步读取的操作的错误输出流的过程。 这些同步读取操作未完成之前关联<xref:System.Diagnostics.Process>写入其<xref:System.Diagnostics.Process.StandardError%2A>流式处理，或关闭流。  
  
 与此相反，<xref:System.Diagnostics.Process.BeginErrorReadLine%2A>开始异步读取操作上<xref:System.Diagnostics.Process.StandardError%2A>流。 此方法启用流输出的指定的事件处理程序，并立即返回给调用方，可以执行其他工作，而流输出定向到事件处理程序。  
  
 请按照下列步骤来执行异步读取的操作上<xref:System.Diagnostics.Process.StandardError%2A>为<xref:System.Diagnostics.Process>:  
  
1.  将 <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> 设置为 `false`。  
  
2.  将 <xref:System.Diagnostics.ProcessStartInfo.RedirectStandardError%2A> 设置为 `true`。  
  
3.  添加事件处理程序到<xref:System.Diagnostics.Process.ErrorDataReceived>事件。 事件处理程序必须与匹配<xref:System.Diagnostics.DataReceivedEventHandler?displayProperty=nameWithType>委托签名。  
  
4.  启动<xref:System.Diagnostics.Process>。  
  
5.  调用<xref:System.Diagnostics.Process.BeginErrorReadLine%2A>为<xref:System.Diagnostics.Process>。 此调用启动的异步读取的操作上<xref:System.Diagnostics.Process.StandardError%2A>。  
  
 调用异步读取的操作开始时，事件处理程序时每次关联<xref:System.Diagnostics.Process>写入到的文本行及其<xref:System.Diagnostics.Process.StandardError%2A>流。  
  
 可以通过调用取消一个异步读的操作<xref:System.Diagnostics.Process.CancelErrorRead%2A>。 由调用方或事件处理程序，可以取消读取的操作。 取消之后，可以调用<xref:System.Diagnostics.Process.BeginErrorReadLine%2A>再次继续异步读取的操作。  
  
> [!NOTE]
>  不能混合异步和同步读取的操作重定向流上。 一次的重定向的流<xref:System.Diagnostics.Process>打开在异步或同步模式下，所有进一步读取该流上的执行操作必须处于相同模式。 例如，不遵循<xref:System.Diagnostics.Process.BeginErrorReadLine%2A>通过调用<xref:System.IO.StreamReader.ReadLine%2A>上<xref:System.Diagnostics.Process.StandardError%2A>流，反之亦然。 但是，您可以读取在不同模式下的两个不同的流。 例如，可以调用<xref:System.Diagnostics.Process.BeginErrorReadLine%2A>，然后调用<xref:System.IO.StreamReader.ReadLine%2A>为<xref:System.Diagnostics.Process.StandardOutput%2A>流。  
  
   
  
## Examples  
 下面的示例使用`net view`命令以列出在远程计算机上的可用的网络资源。 用户提供的目标计算机名称作为命令行参数。 用户还可以提供错误输出的文件名称。 该示例将收集的 net 命令、 等待进程完成，然后写入到控制台的输出结果的输出。 如果用户提供的可选错误文件，该示例会将错误写入到文件。  
  
 [!code-cpp[Process_AsyncStreams#2](~/samples/snippets/cpp/VS_Snippets_CLR/process_asyncstreams/CPP/net_async.cpp#2)]
 [!code-csharp[Process_AsyncStreams#2](~/samples/snippets/csharp/VS_Snippets_CLR/process_asyncstreams/CS/net_async.cs#2)]
 [!code-vb[Process_AsyncStreams#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_asyncstreams/VB/net_async.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" /> 属性为 <see langword="false" />。  
  
\- 或 - 
<see cref="P:System.Diagnostics.Process.StandardError" /> 流上已在进行异步读取操作。  
  
\- 或 - 
同步读取操作已使用 <see cref="P:System.Diagnostics.Process.StandardError" /> 流。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">对于直接调用方的完全信任。 此成员不能由部分信任的代码使用。</permission>
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" />
        <altmember cref="P:System.Diagnostics.Process.StandardError" />
        <altmember cref="E:System.Diagnostics.Process.ErrorDataReceived" />
        <altmember cref="T:System.Diagnostics.DataReceivedEventHandler" />
        <altmember cref="M:System.Diagnostics.Process.CancelErrorRead" />
      </Docs>
    </Member>
    <Member MemberName="BeginOutputReadLine">
      <MemberSignature Language="C#" Value="public void BeginOutputReadLine ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BeginOutputReadLine() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.BeginOutputReadLine" />
      <MemberSignature Language="VB.NET" Value="Public Sub BeginOutputReadLine ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BeginOutputReadLine();" />
      <MemberSignature Language="F#" Value="member this.BeginOutputReadLine : unit -&gt; unit" Usage="process.BeginOutputReadLine " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>在应用程序的重定向 <see cref="P:System.Diagnostics.Process.StandardOutput" /> 流上开始进行异步读取操作。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.StandardOutput%2A>可以读取流，以同步方式还是以异步方式。 等方法<xref:System.IO.StreamReader.Read%2A>， <xref:System.IO.StreamReader.ReadLine%2A>，和<xref:System.IO.StreamReader.ReadToEnd%2A>执行同步读取的操作过程的输出流。 这些同步读取操作未完成之前关联<xref:System.Diagnostics.Process>写入其<xref:System.Diagnostics.Process.StandardOutput%2A>流式处理，或关闭流。  
  
 与此相反，<xref:System.Diagnostics.Process.BeginOutputReadLine%2A>开始异步读取操作上<xref:System.Diagnostics.Process.StandardOutput%2A>流。 此方法启用流输出一个指定的事件处理程序，并立即返回给调用方，可以执行其他工作，而流输出定向到事件处理程序。  
  
 请按照下列步骤来执行异步读取的操作上<xref:System.Diagnostics.Process.StandardOutput%2A>为<xref:System.Diagnostics.Process>:  
  
1.  将 <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> 设置为 `false`。  
  
2.  将 <xref:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput%2A> 设置为 `true`。  
  
3.  添加事件处理程序到<xref:System.Diagnostics.Process.OutputDataReceived>事件。 事件处理程序必须与匹配<xref:System.Diagnostics.DataReceivedEventHandler?displayProperty=nameWithType>委托签名。  
  
4.  启动<xref:System.Diagnostics.Process>。  
  
5.  调用<xref:System.Diagnostics.Process.BeginOutputReadLine%2A>为<xref:System.Diagnostics.Process>。 此调用启动的异步读取的操作上<xref:System.Diagnostics.Process.StandardOutput%2A>。  
  
 调用异步读取的操作开始时，事件处理程序时每次关联<xref:System.Diagnostics.Process>写入到的文本行及其<xref:System.Diagnostics.Process.StandardOutput%2A>流。  
  
 可以通过调用取消一个异步读的操作<xref:System.Diagnostics.Process.CancelOutputRead%2A>。 由调用方或事件处理程序，可以取消读取的操作。 取消之后，可以调用<xref:System.Diagnostics.Process.BeginOutputReadLine%2A>再次继续异步读取的操作。  
  
> [!NOTE]
>  不能混合异步和同步读取的操作重定向流上。 一次的重定向的流<xref:System.Diagnostics.Process>打开在异步或同步模式下，所有进一步读取该流上的执行操作必须处于相同模式。 例如，不遵循<xref:System.Diagnostics.Process.BeginOutputReadLine%2A>通过调用<xref:System.IO.StreamReader.ReadLine%2A>上<xref:System.Diagnostics.Process.StandardOutput%2A>流，反之亦然。 但是，您可以读取在不同模式下的两个不同的流。 例如，可以调用<xref:System.Diagnostics.Process.BeginOutputReadLine%2A>，然后调用<xref:System.IO.StreamReader.ReadLine%2A>为<xref:System.Diagnostics.Process.StandardError%2A>流。  
  
   
  
## Examples  
 下面的示例演示如何执行异步读取的操作上的重定向<xref:System.Diagnostics.Process.StandardOutput%2A>串`sort`命令。 `sort`命令是一个控制台应用程序的读取，并对文本输入进行排序。  
  
 该示例创建一个事件委托，它用于`SortOutputHandler`事件处理程序并将其与<xref:System.Diagnostics.Process.OutputDataReceived>事件。 事件处理程序接收来自的重定向的文本行<xref:System.Diagnostics.Process.StandardOutput%2A>流，格式化文本，并在屏幕上写入的文本。  
  
 [!code-cpp[Process_AsyncStreams#1](~/samples/snippets/cpp/VS_Snippets_CLR/process_asyncstreams/CPP/sort_async.cpp#1)]
 [!code-csharp[Process_AsyncStreams#1](~/samples/snippets/csharp/VS_Snippets_CLR/process_asyncstreams/CS/sort_async.cs#1)]
 [!code-vb[Process_AsyncStreams#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_asyncstreams/VB/sort_async.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" /> 属性为 <see langword="false" />。  
  
\- 或 - 
<see cref="P:System.Diagnostics.Process.StandardOutput" /> 流上已在进行异步读取操作。  
  
\- 或 - 
同步读取操作已使用 <see cref="P:System.Diagnostics.Process.StandardOutput" /> 流。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">对于直接调用方的完全信任。 此成员不能由部分信任的代码使用。</permission>
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" />
        <altmember cref="P:System.Diagnostics.Process.StandardOutput" />
        <altmember cref="E:System.Diagnostics.Process.OutputDataReceived" />
        <altmember cref="T:System.Diagnostics.DataReceivedEventHandler" />
        <altmember cref="M:System.Diagnostics.Process.CancelOutputRead" />
      </Docs>
    </Member>
    <Member MemberName="CancelErrorRead">
      <MemberSignature Language="C#" Value="public void CancelErrorRead ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CancelErrorRead() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.CancelErrorRead" />
      <MemberSignature Language="VB.NET" Value="Public Sub CancelErrorRead ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CancelErrorRead();" />
      <MemberSignature Language="F#" Value="member this.CancelErrorRead : unit -&gt; unit" Usage="process.CancelErrorRead " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>取消在应用程序的重定向 <see cref="P:System.Diagnostics.Process.StandardError" /> 流上执行的异步读取操作。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.BeginErrorReadLine%2A> 启动异步读取操作<xref:System.Diagnostics.Process.StandardError%2A>流。 <xref:System.Diagnostics.Process.CancelErrorRead%2A> 结束异步读操作。  
  
 取消之后，您可以通过来继续异步读取的操作调用<xref:System.Diagnostics.Process.BeginErrorReadLine%2A>试。  
  
 当您调用<xref:System.Diagnostics.Process.CancelErrorRead%2A>，则所有正在进行中的读取操作<xref:System.Diagnostics.Process.StandardError%2A>都已完成，然后又禁用事件处理程序。 所有进一步将输出重定向到<xref:System.Diagnostics.Process.StandardError%2A>保存在缓冲区中。 如果重新启用事件处理程序通过调用<xref:System.Diagnostics.Process.BeginErrorReadLine%2A>、 已保存的输出发送到事件处理程序和异步读取的操作恢复。 如果你想要更改的事件处理程序继续执行异步读取的操作之前，必须在添加新的事件处理程序之前删除现有的事件处理程序：  
  
```csharp  
// At this point the DataReceivedEventHandler(ErrorHandler1)   
// has executed a CancelErrorRead.  
  
// Remove the prior event handler.  
process.ErrorDataReceived -=   
    new DataReceivedEventHandler(ErrorHandler1);  
  
// Register a new event handler.  
process.ErrorDataReceived +=   
    new DataReceivedEventHandler(ErrorHandler2);  
  
// Call the corresponding BeginErrorReadLine.  
process.BeginErrorReadLine();  
```  
  
> [!NOTE]
>  不能混合异步和同步读取的操作上的重定向<xref:System.Diagnostics.Process.StandardError%2A>流。 一次的重定向的流<xref:System.Diagnostics.Process>打开在异步或同步模式下，所有进一步读取该流上的执行操作必须处于相同模式。 如果您取消异步请继续阅读操作<xref:System.Diagnostics.Process.StandardError%2A>，然后需要从流中读取，则必须使用<xref:System.Diagnostics.Process.BeginErrorReadLine%2A>恢复异步读取的操作。 不遵循<xref:System.Diagnostics.Process.CancelErrorRead%2A>同步调用读取方法<xref:System.Diagnostics.Process.StandardError%2A>如<xref:System.IO.StreamReader.Read%2A>， <xref:System.IO.StreamReader.ReadLine%2A>，或<xref:System.IO.StreamReader.ReadToEnd%2A>。  
  
   
  
## Examples  
 下面的示例启动`nmake`命令与用户提供的参数。 以异步方式; 读取错误和输出流收集的文本行是显示到控制台，以及写入到日志文件。 如果命令输出超出指定的行数，将取消异步读取的操作。  
  
 [!code-cpp[Process_AsyncStreams#3](~/samples/snippets/cpp/VS_Snippets_CLR/process_asyncstreams/CPP/nmake_async.cpp#3)]
 [!code-csharp[Process_AsyncStreams#3](~/samples/snippets/csharp/VS_Snippets_CLR/process_asyncstreams/CS/nmake_async.cs#3)]
 [!code-vb[Process_AsyncStreams#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_asyncstreams/VB/nmake_async.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">未针对异步读取操作启用 <see cref="P:System.Diagnostics.Process.StandardError" /> 流。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">对于直接调用方的完全信任。 此成员不能由部分信任的代码使用。</permission>
        <altmember cref="M:System.Diagnostics.Process.BeginErrorReadLine" />
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" />
        <altmember cref="P:System.Diagnostics.Process.StandardError" />
        <altmember cref="E:System.Diagnostics.Process.ErrorDataReceived" />
        <altmember cref="T:System.Diagnostics.DataReceivedEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="CancelOutputRead">
      <MemberSignature Language="C#" Value="public void CancelOutputRead ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CancelOutputRead() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.CancelOutputRead" />
      <MemberSignature Language="VB.NET" Value="Public Sub CancelOutputRead ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CancelOutputRead();" />
      <MemberSignature Language="F#" Value="member this.CancelOutputRead : unit -&gt; unit" Usage="process.CancelOutputRead " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>取消在应用程序的重定向 <see cref="P:System.Diagnostics.Process.StandardOutput" /> 流上执行的异步读取操作。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> 启动异步读取操作<xref:System.Diagnostics.Process.StandardOutput%2A>流。 <xref:System.Diagnostics.Process.CancelOutputRead%2A> 结束异步读操作。  
  
 取消之后，您可以继续执行异步读取的操作通过调用<xref:System.Diagnostics.Process.BeginOutputReadLine%2A>试。  
  
 当您调用<xref:System.Diagnostics.Process.CancelOutputRead%2A>，则所有正在进行中的读取操作<xref:System.Diagnostics.Process.StandardOutput%2A>都已完成，然后又禁用事件处理程序。 所有进一步将输出重定向到<xref:System.Diagnostics.Process.StandardOutput%2A>保存在缓冲区中。 如果重新启用事件处理程序通过调用<xref:System.Diagnostics.Process.BeginOutputReadLine%2A>、 已保存的输出发送到事件处理程序和异步读取的操作恢复。 如果你想要更改的事件处理程序继续执行异步读取的操作之前，必须在添加新的事件处理程序之前删除现有的事件处理程序：  
  
```csharp  
// At this point the DataReceivedEventHandler(OutputHandler1)   
// has executed a CancelOutputRead.  
  
// Remove the prior event handler.  
process.OutputDataReceived -=   
    new DataReceivedEventHandler(OutputHandler1);  
  
// Register a new event handler.  
process.OutputDataReceived +=   
    new DataReceivedEventHandler(OutputHandler2);  
  
// Call the corresponding BeginOutputReadLine.  
process.BeginOutputReadLine();  
```  
  
> [!NOTE]
>  不能混合异步和同步读取的操作上的重定向<xref:System.Diagnostics.Process.StandardOutput%2A>流。 一次的重定向的流<xref:System.Diagnostics.Process>打开在异步或同步模式下，所有进一步读取该流上的执行操作必须处于相同模式。 如果您取消异步请继续阅读操作<xref:System.Diagnostics.Process.StandardOutput%2A>，然后需要从流中读取，则必须使用<xref:System.Diagnostics.Process.BeginOutputReadLine%2A>恢复异步读取的操作。 不遵循<xref:System.Diagnostics.Process.CancelOutputRead%2A>同步调用读取方法<xref:System.Diagnostics.Process.StandardOutput%2A>如<xref:System.IO.StreamReader.Read%2A>， <xref:System.IO.StreamReader.ReadLine%2A>，或<xref:System.IO.StreamReader.ReadToEnd%2A>。  
  
   
  
## Examples  
 下面的示例启动`nmake`命令与用户提供的参数。 以异步方式; 读取错误和输出流收集的文本行是显示到控制台，以及写入到日志文件。 如果命令输出超出指定的行数，将取消异步读取的操作。  
  
 [!code-cpp[Process_AsyncStreams#3](~/samples/snippets/cpp/VS_Snippets_CLR/process_asyncstreams/CPP/nmake_async.cpp#3)]
 [!code-csharp[Process_AsyncStreams#3](~/samples/snippets/csharp/VS_Snippets_CLR/process_asyncstreams/CS/nmake_async.cs#3)]
 [!code-vb[Process_AsyncStreams#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_asyncstreams/VB/nmake_async.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">未针对异步读取操作启用 <see cref="P:System.Diagnostics.Process.StandardOutput" /> 流。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">对于直接调用方的完全信任。 此成员不能由部分信任的代码使用。</permission>
        <altmember cref="M:System.Diagnostics.Process.BeginOutputReadLine" />
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" />
        <altmember cref="P:System.Diagnostics.Process.StandardOutput" />
        <altmember cref="E:System.Diagnostics.Process.OutputDataReceived" />
        <altmember cref="T:System.Diagnostics.DataReceivedEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close();" />
      <MemberSignature Language="F#" Value="member this.Close : unit -&gt; unit" Usage="process.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>释放与此组件关联的所有资源。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.Close%2A>方法将导致该进程停止等待退出正在等待，如果关闭进程句柄，并清除特定于进程的属性。 <xref:System.Diagnostics.Process.Close%2A> 正在从外部引用它们的情况下，不会关闭标准输出、 输入和错误的读取器和编写器。  
  
> [!NOTE]
>  <xref:System.Diagnostics.Process.Dispose%2A> 方法调用 <xref:System.Diagnostics.Process.Close%2A>。 放置<xref:System.Diagnostics.Process>中的对象`using`块释放资源，而无需调用<xref:System.Diagnostics.Process.Close%2A>。  
  
   
  
## Examples  
 以下示例启动记事本的实例。 然后它最长为 10 秒的 2 秒时间间隔内以检索关联的进程的物理内存使用情况。 该示例检测是否在进程退出之前已在过去 10 秒。 如果它仍在运行在 10 秒后，该示例将关闭该过程。  
  
 [!code-cpp[process_refresh#1](~/samples/snippets/cpp/VS_Snippets_CLR/process_refresh/CPP/process_refresh.cpp#1)]
 [!code-csharp[process_refresh#1](~/samples/snippets/csharp/VS_Snippets_CLR/process_refresh/CS/process_refresh.cs#1)]
 [!code-vb[process_refresh#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_refresh/VB/process_refresh.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">对于直接调用方的完全信任。 此成员不能由部分信任的代码使用。</permission>
      </Docs>
    </Member>
    <Member MemberName="CloseMainWindow">
      <MemberSignature Language="C#" Value="public bool CloseMainWindow ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool CloseMainWindow() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.CloseMainWindow" />
      <MemberSignature Language="VB.NET" Value="Public Function CloseMainWindow () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool CloseMainWindow();" />
      <MemberSignature Language="F#" Value="member this.CloseMainWindow : unit -&gt; bool" Usage="process.CloseMainWindow " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>通过向进程的主窗口发送关闭消息来关闭拥有用户界面的进程。</summary>
        <returns>如果成功发送了关闭消息，则为 <see langword="true" />；如果关联进程没有主窗口或禁用了主窗口(例如，如果当前显示模式对话框)，则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 执行进程时，其消息循环之后处于等待状态。 消息循环执行每次操作系统 Windows 消息发送到进程。 调用<xref:System.Diagnostics.Process.CloseMainWindow%2A>接近主窗口中，其格式正确的应用程序中关闭子窗口，并撤消所有正在运行的应用程序消息循环发送到请求。 请求退出进程通过调用<xref:System.Diagnostics.Process.CloseMainWindow%2A>不会强制应用程序退出。 应用程序可以让用户验证在退出之前也可以拒绝它退出。 若要强制应用程序退出，请使用<xref:System.Diagnostics.Process.Kill%2A>方法。 行为<xref:System.Diagnostics.Process.CloseMainWindow%2A>等同于用户关闭应用程序的主窗口中使用系统菜单。 因此，通过关闭主窗口退出该进程的请求不会强制应用程序立即退出。  
  
 编辑进程的数据或资源分配给该过程可能会丢失如果调用<xref:System.Diagnostics.Process.Kill%2A>。 <xref:System.Diagnostics.Process.Kill%2A> 导致异常的进程终止，并应仅在必要时使用。 <xref:System.Diagnostics.Process.CloseMainWindow%2A> 使该过程的有序地终止并关闭所有窗口，以便使用接口的应用程序更好地。 如果<xref:System.Diagnostics.Process.CloseMainWindow%2A>失败，可以使用<xref:System.Diagnostics.Process.Kill%2A>终止进程。 <xref:System.Diagnostics.Process.Kill%2A> 是唯一的方法来终止进程不具有图形界面。  
  
 您可以调用<xref:System.Diagnostics.Process.Kill%2A>和<xref:System.Diagnostics.Process.CloseMainWindow%2A>仅对本地计算机运行的进程。 若要退出的远程计算机上，不能导致进程。 您只能查看在远程计算机上运行进程的信息。  
  
   
  
## Examples  
 以下示例启动记事本的实例。 然后在 10 秒的最长 2 第二个时间间隔检索关联的进程的物理内存使用情况。 该示例检测是否在进程退出之前已在过去 10 秒。 如果它仍在运行在 10 秒后，该示例将关闭该过程。  
  
 [!code-cpp[process_refresh#1](~/samples/snippets/cpp/VS_Snippets_CLR/process_refresh/CPP/process_refresh.cpp#1)]
 [!code-csharp[process_refresh#1](~/samples/snippets/csharp/VS_Snippets_CLR/process_refresh/CS/process_refresh.cs#1)]
 [!code-vb[process_refresh#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_refresh/VB/process_refresh.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">该平台是 Windows 98 或 Windows Millennium Edition (Windows Me)；将 <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> 属性设置为 <see langword="false" />，以在 Windows 98 和 Windows Me 上访问此属性。</exception>
        <exception cref="T:System.InvalidOperationException">已经退出该进程。  
  
或 
没有与此 <see cref="T:System.Diagnostics.Process" /> 对象关联的进程。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">对于直接调用方的完全信任。 此成员不能由部分信任的代码使用。</permission>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="process.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="override this.Dispose : bool -&gt; unit" Usage="process.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">若要释放托管资源和非托管资源，则为 <see langword="true" />；若仅释放非托管资源，则为 <see langword="false" />。</param>
        <summary>释放此进程使用的所有资源。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EnableRaisingEvents">
      <MemberSignature Language="C#" Value="public bool EnableRaisingEvents { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableRaisingEvents" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.EnableRaisingEvents" />
      <MemberSignature Language="VB.NET" Value="Public Property EnableRaisingEvents As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool EnableRaisingEvents { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.EnableRaisingEvents : bool with get, set" Usage="System.Diagnostics.Process.EnableRaisingEvents" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Whether the process component should watch for the associated process to exit, and raise the Exited event.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessEnableRaisingEvents")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置在进程终止时是否应引发 <see cref="E:System.Diagnostics.Process.Exited" /> 事件。</summary>
        <value>如果关联的进程终止（通过退出或者调用 <see cref="M:System.Diagnostics.Process.Kill" />）时应引发 <see cref="E:System.Diagnostics.Process.Exited" /> 事件，则为 <see langword="true" />；否则为 <see langword="false" />。 默认值为 <see langword="false" />。 请注意，<see cref="E:System.Diagnostics.Process.Exited" />引发事件即使的值<see cref="P:System.Diagnostics.Process.EnableRaisingEvents" />是<see langword="false" />时在进程退出过程或用户执行前<see cref="P:System.Diagnostics.Process.HasExited" />检查。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
<xref:System.Diagnostics.Process.EnableRaisingEvents%2A>属性表明操作系统已关闭进程时是否应通知该组件。 <xref:System.Diagnostics.Process.EnableRaisingEvents%2A>属性用于在异步处理通知进程已退出应用程序。 若要强制应用程序同步等待退出事件 （它中断的应用程序处理，直到退出事件已发生），请使用<xref:System.Diagnostics.Process.WaitForExit%2A>方法。

> [!NOTE]
> 如果你使用 Visual Studio，并双击<xref:System.Diagnostics.Process>在项目中，组件<xref:System.Diagnostics.Process.Exited>自动生成的事件委托和事件处理程序。 其他代码集<xref:System.Diagnostics.Process.EnableRaisingEvents%2A>属性设置为`false`。 必须更改此属性设置为`true`对事件处理程序时要执行在关联的进程退出。

如果该组件的<xref:System.Diagnostics.Process.EnableRaisingEvents%2A>值是`true`，或当<xref:System.Diagnostics.Process.EnableRaisingEvents%2A>是`false`和<xref:System.Diagnostics.Process.HasExited%2A>由组件调用检查，该组件可以访问关联的进程，后者仍然的管理信息存储由操作系统中。 此类信息包括<xref:System.Diagnostics.Process.ExitTime%2A>和<xref:System.Diagnostics.Process.ExitCode%2A>。

关联的进程退出后，则<xref:System.Diagnostics.Process.Handle%2A>的该组件不再指向现有进程资源。 相反，它仅可访问的进程资源的操作系统的信息。 操作系统是注意尚未通过发布的已退出进程的句柄<xref:System.Diagnostics.Process>组件，因此它会保留<xref:System.Diagnostics.Process.ExitTime%2A>和<xref:System.Diagnostics.Process.Handle%2A>内存中的信息。

没有与监视进程的退出相关的成本。 如果<xref:System.Diagnostics.Process.EnableRaisingEvents%2A>是`true`，则<xref:System.Diagnostics.Process.Exited>关联的进程终止时引发事件。 对获得的过程<xref:System.Diagnostics.Process.Exited>在该时间运行的事件。

有时，你的应用程序将启动一个进程，但不需要其闭包的通知。 例如，你的应用程序可以启动记事本以允许用户执行文本的编辑，但将不用再使用记事本应用程序。 您可以选择以避免在进程退出，因为它不是与你的应用程序的持续操作时出现通知。 设置<xref:System.Diagnostics.Process.EnableRaisingEvents%2A>到`false`可以节省系统资源。

## Examples  
下面的代码示例创建一个过程，打印文件。 它会设置<xref:System.Diagnostics.Process.EnableRaisingEvents%2A>属性将导致该进程引发<xref:System.Diagnostics.Process.Exited>退出时的事件。 <xref:System.Diagnostics.Process.Exited>事件处理程序显示进程的信息。

[!code-csharp[System.Diagnostics.Process.EnableExited#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Diagnostics.Process.EnableExited/CS/processexitedevent.cs#1)]   
[!code-vb[System.Diagnostics.Process.EnableExited#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Diagnostics.Process.EnableExited/VB/processexitedevent.vb#1)]   
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">对于直接调用方的完全信任。 此成员不能由部分信任的代码使用。</permission>
        <altmember cref="M:System.Diagnostics.Process.WaitForExit(System.Int32)" />
        <altmember cref="E:System.Diagnostics.Process.Exited" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Kill" />
        <altmember cref="P:System.Diagnostics.Process.Handle" />
        <altmember cref="P:System.Diagnostics.Process.ExitTime" />
        <altmember cref="P:System.Diagnostics.Process.HasExited" />
      </Docs>
    </Member>
    <Member MemberName="EnterDebugMode">
      <MemberSignature Language="C#" Value="public static void EnterDebugMode ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void EnterDebugMode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.EnterDebugMode" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub EnterDebugMode ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void EnterDebugMode();" />
      <MemberSignature Language="F#" Value="static member EnterDebugMode : unit -&gt; unit" Usage="System.Diagnostics.Process.EnterDebugMode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>通过启用当前线程的本机属性 <see langword="SeDebugPrivilege" />，将 <see cref="T:System.Diagnostics.Process" /> 组件置于与以特殊模式运行的操作系统进程交互的状态。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 以特殊模式运行某些操作系统进程。 尝试读取的属性或将附加到这些进程不能除非您调用<xref:System.Diagnostics.Process.EnterDebugMode%2A>组件上。 调用<xref:System.Diagnostics.Process.LeaveDebugMode%2A>不再需要对这些特殊模式运行的进程的访问。  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">对于直接调用方的完全信任。 此成员不能由部分信任的代码使用。</permission>
        <altmember cref="M:System.Diagnostics.Process.LeaveDebugMode" />
      </Docs>
    </Member>
    <Member MemberName="ErrorDataReceived">
      <MemberSignature Language="C#" Value="public event System.Diagnostics.DataReceivedEventHandler ErrorDataReceived;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Diagnostics.DataReceivedEventHandler ErrorDataReceived" />
      <MemberSignature Language="DocId" Value="E:System.Diagnostics.Process.ErrorDataReceived" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ErrorDataReceived As DataReceivedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Diagnostics::DataReceivedEventHandler ^ ErrorDataReceived;" />
      <MemberSignature Language="F#" Value="member this.ErrorDataReceived : System.Diagnostics.DataReceivedEventHandler " Usage="member this.ErrorDataReceived : System.Diagnostics.DataReceivedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Indicates if the process component is associated with a real process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessAssociated")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.DataReceivedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当应用程序写入其重定向 <see cref="P:System.Diagnostics.Process.StandardError" /> 流中时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.ErrorDataReceived>事件指示关联的进程已写入其重定向<xref:System.Diagnostics.Process.StandardError%2A>流。  
  
 该事件仅在异步读取操作期间上发生<xref:System.Diagnostics.Process.StandardError%2A>。 若要开始异步读取的操作，必须重定向<xref:System.Diagnostics.Process.StandardError%2A>串<xref:System.Diagnostics.Process>，添加到事件处理程序<xref:System.Diagnostics.Process.ErrorDataReceived>事件，并调用<xref:System.Diagnostics.Process.BeginErrorReadLine%2A>。 此后，<xref:System.Diagnostics.Process.ErrorDataReceived>事件信号每次该过程将行写入到的重定向<xref:System.Diagnostics.Process.StandardError%2A>流式传输，直到该进程退出，或调用<xref:System.Diagnostics.Process.CancelErrorRead%2A>。  
  
> [!NOTE]
>  处理异步输出的应用程序应调用<xref:System.Diagnostics.Process.WaitForExit>方法，以确保已刷新输出缓冲区。 请注意通过使用该指定超时<xref:System.Diagnostics.Process.WaitForExit(System.Int32)>重载 does*不*确保已刷新输出缓冲区。
  
   
  
## Examples  
 下面的示例使用`net view`命令以列出在远程计算机上的可用的网络资源。 用户提供的目标计算机名称作为命令行参数。 用户还可以提供错误输出的文件名称。 该示例将收集的 net 命令、 等待进程完成，然后写入到控制台的输出结果的输出。 如果用户提供的可选错误文件，该示例会将错误写入到文件。  
  
 [!code-cpp[Process_AsyncStreams#2](~/samples/snippets/cpp/VS_Snippets_CLR/process_asyncstreams/CPP/net_async.cpp#2)]
 [!code-csharp[Process_AsyncStreams#2](~/samples/snippets/csharp/VS_Snippets_CLR/process_asyncstreams/CS/net_async.cs#2)]
 [!code-vb[Process_AsyncStreams#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_asyncstreams/VB/net_async.vb#2)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">对于直接调用方的完全信任。 此成员不能由部分信任的代码使用。</permission>
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" />
        <altmember cref="P:System.Diagnostics.Process.StandardError" />
        <altmember cref="M:System.Diagnostics.Process.BeginErrorReadLine" />
        <altmember cref="M:System.Diagnostics.Process.CancelErrorRead" />
        <altmember cref="T:System.Diagnostics.DataReceivedEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="ExitCode">
      <MemberSignature Language="C#" Value="public int ExitCode { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ExitCode" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.ExitCode" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ExitCode As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ExitCode { int get(); };" />
      <MemberSignature Language="F#" Value="member this.ExitCode : int" Usage="System.Diagnostics.Process.ExitCode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The value returned from the associated process when it terminated.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessExitCode")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取关联进程终止时指定的值。</summary>
        <value>关联进程终止时指定的代码。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用<xref:System.Diagnostics.Process.ExitCode%2A>来获取系统进程返回时退出该循环的状态。 您可以使用退出代码更像一个整数，返回值从`main()`过程。  
  
 <xref:System.Diagnostics.Process.ExitCode%2A>进程反映了由该进程的应用程序开发人员实现的特定约定的值。 如果使用退出代码值来决定在代码中，请务必了解使用应用程序进程的退出代码约定。  
  
 开发人员通常指示成功退出<xref:System.Diagnostics.Process.ExitCode%2A>值为零，并且指定的错误的调用的方法可用于确定异常的进程终止原因的非零值。 没有必要遵循这些指导原则，但它们是约定。  
  
 如果尝试获取<xref:System.Diagnostics.Process.ExitCode%2A>进程已退出之前，请尝试将引发异常。 检查<xref:System.Diagnostics.Process.HasExited%2A>属性首次以验证是否已终止关联的进程。  
  
> [!NOTE]
>  如果标准输出重定向到异步事件处理程序，则可能的输出处理还未完成时<xref:System.Diagnostics.Process.HasExited%2A>返回`true`。 若要确保已完成异步事件处理，请调用<xref:System.Diagnostics.Process.WaitForExit>检查之前不接受任何参数的重载<xref:System.Diagnostics.Process.HasExited%2A>。  
  
 可以使用<xref:System.Diagnostics.Process.CloseMainWindow%2A>或<xref:System.Diagnostics.Process.Kill%2A>方法，使关联的进程退出。  
  
 关联的进程退出时收到通知的两种方法： 异步和同步。 同步通知依赖于调用<xref:System.Diagnostics.Process.WaitForExit%2A>方法来暂停应用程序的处理，直到退出关联的组件。 依赖于异步通知<xref:System.Diagnostics.Process.Exited>事件。 使用异步通知时<xref:System.Diagnostics.Process.EnableRaisingEvents%2A>必须设置为`true`为<xref:System.Diagnostics.Process>组件接收通知的进程已退出。  
  
   
  
## Examples  
 以下示例启动记事本的实例。 该示例然后检索并显示关联的进程的各种属性。 该示例检测时在进程退出，并显示该进程的退出代码。  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">进程尚未退出。  
  
或 
进程 <see cref="P:System.Diagnostics.Process.Handle" /> 无效。</exception>
        <exception cref="T:System.NotSupportedException">你正尝试访问在远程计算机上运行的进程的 <see cref="P:System.Diagnostics.Process.ExitCode" /> 属性。 此属性仅可用于本地计算机上运行的进程。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">对于直接调用方的完全信任。 此成员不能由部分信任的代码使用。</permission>
        <altmember cref="P:System.Diagnostics.Process.HasExited" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Kill" />
        <altmember cref="M:System.Diagnostics.Process.WaitForExit(System.Int32)" />
        <altmember cref="P:System.Diagnostics.Process.EnableRaisingEvents" />
      </Docs>
    </Member>
    <Member MemberName="Exited">
      <MemberSignature Language="C#" Value="public event EventHandler Exited;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Exited" />
      <MemberSignature Language="DocId" Value="E:System.Diagnostics.Process.Exited" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Exited As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Exited;" />
      <MemberSignature Language="F#" Value="member this.Exited : EventHandler " Usage="member this.Exited : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("If the WatchForExit property is set to true, then this event is raised when the associated process exits.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessExited")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在进程退出时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.Exited>事件指示关联的进程退出。 此事件意味着任一进程终止 （中止） 或已成功关闭。 仅当发生此事件的值<xref:System.Diagnostics.Process.EnableRaisingEvents%2A>属性是`true`。  
  
 关联的进程退出时收到通知的两种方法： 异步和同步。 同步通知意味着调用<xref:System.Diagnostics.Process.WaitForExit%2A>方法进行阻止当前线程，直到在进程退出。 异步通知使用<xref:System.Diagnostics.Process.Exited>事件，允许调用线程继续执行在此期间。 在后一种情况下，<xref:System.Diagnostics.Process.EnableRaisingEvents%2A>必须设置为`true`调用应用程序以接收已退出事件。  
  
 当操作系统关闭进程时，它通知已注册的已退出事件处理程序的所有其他进程。 在此期间，只需退出的进程的句柄可以用于访问某些属性，例如<xref:System.Diagnostics.Process.ExitTime%2A>和<xref:System.Diagnostics.Process.HasExited%2A>操作系统维护，直到它完全释放该句柄。  
  
> [!NOTE]
>  即使已退出进程的句柄，则不能调用<xref:System.Diagnostics.Process.Start%2A>再次以重新连接到相同的过程。 调用<xref:System.Diagnostics.Process.Start%2A>自动释放关联的进程，并使用同一个文件，但全新连接到进程<xref:System.Diagnostics.Process.Handle%2A>。  
  
 有关使用详细信息<xref:System.Diagnostics.Process.Exited>事件在 Windows 窗体应用程序，请参阅<xref:System.Diagnostics.Process.SynchronizingObject%2A>属性。  
  
   
  
## Examples  
 下面的代码示例创建一个过程，打印文件。 它会发出<xref:System.Diagnostics.Process.Exited>事件时在进程退出，因为<xref:System.Diagnostics.Process.EnableRaisingEvents%2A>过程已创建时设置属性。 <xref:System.Diagnostics.Process.Exited>事件处理程序显示进程的信息。  
  
 [!code-csharp[System.Diagnostics.Process.EnableExited#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Diagnostics.Process.EnableExited/CS/processexitedevent.cs#1)]
 [!code-vb[System.Diagnostics.Process.EnableExited#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Diagnostics.Process.EnableExited/VB/processexitedevent.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">对于直接调用方的完全信任。 此成员不能由部分信任的代码使用。</permission>
      </Docs>
    </Member>
    <Member MemberName="ExitTime">
      <MemberSignature Language="C#" Value="public DateTime ExitTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime ExitTime" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.ExitTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ExitTime As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property DateTime ExitTime { DateTime get(); };" />
      <MemberSignature Language="F#" Value="member this.ExitTime : DateTime" Usage="System.Diagnostics.Process.ExitTime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The time that the associated process exited.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessExitTime")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取关联进程退出的时间。</summary>
        <value>
          <see cref="T:System.DateTime" />，它指示关联进程终止的时间。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果还未终止进程，尝试检索<xref:System.Diagnostics.Process.ExitTime%2A>属性引发异常。 使用<xref:System.Diagnostics.Process.HasExited%2A>之前获取<xref:System.Diagnostics.Process.ExitTime%2A>属性来确定是否已终止关联的进程。  
  
   
  
## Examples  
 下面的代码示例创建一个过程，打印文件。 该过程将引发<xref:System.Diagnostics.Process.Exited>退出时的事件和事件处理程序显示<xref:System.Diagnostics.Process.ExitTime%2A>属性和其他进程的信息。  
  
 [!code-csharp[System.Diagnostics.Process.EnableExited#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Diagnostics.Process.EnableExited/CS/processexitedevent.cs#1)]
 [!code-vb[System.Diagnostics.Process.EnableExited#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Diagnostics.Process.EnableExited/VB/processexitedevent.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">该平台是 Windows 98 或 Windows Millennium Edition (Windows Me)，不支持此属性。</exception>
        <exception cref="T:System.NotSupportedException">你正尝试访问在远程计算机上运行的进程的 <see cref="P:System.Diagnostics.Process.ExitTime" /> 属性。 此属性仅可用于本地计算机上运行的进程。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">对于直接调用方的完全信任。 此成员不能由部分信任的代码使用。</permission>
        <altmember cref="P:System.Diagnostics.Process.Handle" />
        <altmember cref="P:System.Diagnostics.Process.ExitCode" />
      </Docs>
    </Member>
    <Member MemberName="GetCurrentProcess">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process GetCurrentProcess ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process GetCurrentProcess() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.GetCurrentProcess" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetCurrentProcess () As Process" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Diagnostics::Process ^ GetCurrentProcess();" />
      <MemberSignature Language="F#" Value="static member GetCurrentProcess : unit -&gt; System.Diagnostics.Process" Usage="System.Diagnostics.Process.GetCurrentProcess " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>获取新的 <see cref="T:System.Diagnostics.Process" /> 组件并将其与当前活动的进程关联。</summary>
        <returns>与运行调用应用程序的进程资源关联的新的 <see cref="T:System.Diagnostics.Process" /> 组件。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用此方法创建一个新<xref:System.Diagnostics.Process>实例，并将其与本地计算机上的进程资源关联。  
  
 等类似<xref:System.Diagnostics.Process.GetProcessById%2A>， <xref:System.Diagnostics.Process.GetProcessesByName%2A>，并<xref:System.Diagnostics.Process.GetProcesses%2A>方法，<xref:System.Diagnostics.Process.GetCurrentProcess%2A>将现有的资源相关联与新<xref:System.Diagnostics.Process>组件。  
  
   
  
## Examples  
 下面的示例检索当前进程的信息在本地计算机，记事本本地计算机和本地计算机上的特定进程上运行的所有实例上运行的进程。 然后，它将检索远程计算机上的相同的过程信息。  
  
 [!code-cpp[Process.GetProcesses_noexception#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.GetProcesses_noexception/CPP/processstaticget.cpp#1)]
 [!code-csharp[Process.GetProcesses_noexception#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.GetProcesses_noexception/CS/processstaticget.cs#1)]
 [!code-vb[Process.GetProcesses_noexception#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.GetProcesses_noexception/VB/processstaticget.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">对于直接调用方的完全信任。 此成员不能由部分信任的代码使用。</permission>
        <altmember cref="M:System.Diagnostics.Process.GetProcessById(System.Int32,System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessesByName(System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetProcesses" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetProcessById">
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>创建新的 <see cref="T:System.Diagnostics.Process" /> 组件，并将其与您指定的现有进程资源关联。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetProcessById">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process GetProcessById (int processId);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process GetProcessById(int32 processId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.GetProcessById(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetProcessById (processId As Integer) As Process" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Diagnostics::Process ^ GetProcessById(int processId);" />
      <MemberSignature Language="F#" Value="static member GetProcessById : int -&gt; System.Diagnostics.Process" Usage="System.Diagnostics.Process.GetProcessById processId" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="processId" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="processId">进程资源的系统唯一标识符。</param>
        <summary>返回新的 <see cref="T:System.Diagnostics.Process" /> 组件(给定本地计算机上某个进程的标识符)。</summary>
        <returns>与 <paramref name="processId" /> 参数标识的本地进程资源关联的 <see cref="T:System.Diagnostics.Process" /> 组件。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用此方法创建一个新<xref:System.Diagnostics.Process>组件并将其本地计算机上的进程资源关联。 进程资源必须已经存在的计算机上，因为<xref:System.Diagnostics.Process.GetProcessById%28System.Int32%29>不会创建一个系统资源，但而是将资源与应用程序生成相关联<xref:System.Diagnostics.Process>组件。 进程<xref:System.Diagnostics.Process.Id%2A>可以检索仅为当前计算机运行的进程。 在进程终止后，<xref:System.Diagnostics.Process.GetProcessById%28System.Int32%29>将引发异常，如果将其传递一个过期的标识符。  
  
 任何特定计算机上进程的标识符是唯一的。 <xref:System.Diagnostics.Process.GetProcessById%28System.Int32%29> 最多返回一个进程。 如果你想要获取运行特定应用程序，使用的所有进程<xref:System.Diagnostics.Process.GetProcessesByName%28System.String%29>。 如果运行指定的应用程序的计算机上存在多个进程<xref:System.Diagnostics.Process.GetProcessesByName%28System.String%29>返回一个数组，包含所有关联的进程。 您可以查询每个进程又为其标识符。 可以在中查看的进程标识符`Processes`面板的 Windows 任务管理器。 `PID`列将显示分配给进程的进程标识符。  
  
 `processId`参数是<xref:System.Int32>（32 位有符号的整数），尽管基础 Windows API 使用`DWORD`（无符号的 32 位整数） 类似的 api。 这是出于历史原因。
  
## Examples  
 下面的示例检索当前进程的信息在本地计算机，记事本本地计算机和本地计算机上的特定进程上运行的所有实例上运行的进程。 然后，它将检索远程计算机上的相同的过程信息。  
  
 [!code-cpp[Process.GetProcesses_noexception#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.GetProcesses_noexception/CPP/processstaticget.cpp#1)]
 [!code-csharp[Process.GetProcesses_noexception#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.GetProcesses_noexception/CS/processstaticget.cs#1)]
 [!code-vb[Process.GetProcesses_noexception#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.GetProcesses_noexception/VB/processstaticget.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="processId" /> 参数指定的进程未运行。 此标识符可能已过期。</exception>
        <exception cref="T:System.InvalidOperationException">此对象未启动该进程。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">对于直接调用方的完全信任。 此成员不能由部分信任的代码使用。</permission>
        <altmember cref="P:System.Diagnostics.Process.Id" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessesByName(System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetProcesses" />
        <altmember cref="M:System.Diagnostics.Process.GetCurrentProcess" />
      </Docs>
    </Member>
    <Member MemberName="GetProcessById">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process GetProcessById (int processId, string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process GetProcessById(int32 processId, string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.GetProcessById(System.Int32,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetProcessById (processId As Integer, machineName As String) As Process" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Diagnostics::Process ^ GetProcessById(int processId, System::String ^ machineName);" />
      <MemberSignature Language="F#" Value="static member GetProcessById : int * string -&gt; System.Diagnostics.Process" Usage="System.Diagnostics.Process.GetProcessById (processId, machineName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO("There is no support for retrieving process information from a remote machine")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="processId" Type="System.Int32" />
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="processId">进程资源的系统唯一标识符。</param>
        <param name="machineName">网络上计算机的名称。</param>
        <summary>返回新的 <see cref="T:System.Diagnostics.Process" /> 组件(给定进程标识符和网络中计算机的名称)。</summary>
        <returns>与 <paramref name="processId" /> 参数标识的远程进程资源关联的 <see cref="T:System.Diagnostics.Process" /> 组件。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用此方法创建一个新<xref:System.Diagnostics.Process>组件并将其与网络上的远程计算机上的进程资源关联。 进程资源必须已经存在的指定计算机上，因为<xref:System.Diagnostics.Process.GetProcessById%28System.Int32%2CSystem.String%29>不会创建一个系统资源，但而是将资源与应用程序生成相关联<xref:System.Diagnostics.Process>组件。 进程<xref:System.Diagnostics.Process.Id%2A>可以检索仅为当前计算机运行的进程。 在进程终止后，<xref:System.Diagnostics.Process.GetProcessById%28System.Int32%2CSystem.String%29>将引发异常，如果将其传递一个过期的标识符。  
  
 任何特定计算机上进程的标识符是唯一的。 <xref:System.Diagnostics.Process.GetProcessById%28System.Int32%2CSystem.String%29> 最多返回一个进程。 如果你想要获取运行特定应用程序，使用的所有进程<xref:System.Diagnostics.Process.GetProcessesByName%28System.String%29>。 如果运行指定的应用程序的计算机上存在多个进程<xref:System.Diagnostics.Process.GetProcessesByName%28System.String%29>返回一个数组，包含所有关联的进程。 您可以查询每个进程又为其标识符。 可以在中查看的进程标识符`Processes`面板的 Windows 任务管理器。 `PID`列将显示分配给进程的进程标识符。  
  
 如果未指定`machineName`，则使用本地计算机。 或者，您可以通过设置`machineName`为值"。"或为空字符串 ("")。  
  
 `processId`参数是<xref:System.Int32>（32 位有符号的整数），尽管基础 Windows API 使用`DWORD`（无符号的 32 位整数） 类似的 api。 这是出于历史原因。   
  
## Examples  
 下面的示例检索当前进程的信息在本地计算机，记事本本地计算机和本地计算机上的特定进程上运行的所有实例上运行的进程。 然后，它将检索远程计算机上的相同的过程信息。  
  
 [!code-cpp[Process.GetProcesses_noexception#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.GetProcesses_noexception/CPP/processstaticget.cpp#1)]
 [!code-csharp[Process.GetProcesses_noexception#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.GetProcesses_noexception/CS/processstaticget.cs#1)]
 [!code-vb[Process.GetProcesses_noexception#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.GetProcesses_noexception/VB/processstaticget.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="processId" /> 参数指定的进程未运行。 此标识符可能已过期。  
  
或 
<paramref name="machineName" /> 参数的语法无效。 名称的长度可能为零 (0)。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="machineName" /> 参数为 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">此对象未启动该进程。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">对于直接调用方的完全信任。 此成员不能由部分信任的代码使用。</permission>
        <altmember cref="P:System.Diagnostics.Process.Id" />
        <altmember cref="P:System.Diagnostics.Process.MachineName" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessesByName(System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetProcesses" />
        <altmember cref="M:System.Diagnostics.Process.GetCurrentProcess" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetProcesses">
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>创建新的 <see cref="T:System.Diagnostics.Process" /> 组件的数组，并将它们与现有进程资源关联。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetProcesses">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process[] GetProcesses ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process[] GetProcesses() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.GetProcesses" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetProcesses () As Process()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Diagnostics::Process ^&gt; ^ GetProcesses();" />
      <MemberSignature Language="F#" Value="static member GetProcesses : unit -&gt; System.Diagnostics.Process[]" Usage="System.Diagnostics.Process.GetProcesses " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>为本地计算机上的每个进程资源创建一个新的 <see cref="T:System.Diagnostics.Process" /> 组件。</summary>
        <returns>类型 <see cref="T:System.Diagnostics.Process" /> 的数组，表示本地计算机上运行的所有进程资源。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法用于创建新的数组<xref:System.Diagnostics.Process>组件并将其与本地计算机上的所有进程资源关联。 进程资源必须已经存在的本地计算机上，因为<xref:System.Diagnostics.Process.GetProcesses%2A>不会创建系统资源，但而是将资源与应用程序生成相关联<xref:System.Diagnostics.Process>组件。 由于操作系统本身运行后台进程，此数组是永远不会为空。  
  
 如果您不想要检索所有计算机上运行的进程，你可以通过使用限制其号码<xref:System.Diagnostics.Process.GetProcessById%2A>或<xref:System.Diagnostics.Process.GetProcessesByName%2A>方法。 <xref:System.Diagnostics.Process.GetProcessById%2A> 创建<xref:System.Diagnostics.Process>与系统上由传递给方法的进程标识符标识该进程关联的组件。 <xref:System.Diagnostics.Process.GetProcessesByName%2A> 创建的数组<xref:System.Diagnostics.Process>方法传递其关联的进程资源共享的可执行文件的组件。  
  
> [!NOTE]
>  可以将多个 Windows 服务加载服务主机进程 (svchost.exe) 在同一实例。 GetProcesses 不会标识这些单独的服务;为此，请参阅<xref:System.ServiceProcess.ServiceController.GetServices%2A>。  
  
   
  
## Examples  
 下面的示例检索当前进程的信息在本地计算机，记事本本地计算机和本地计算机上的特定进程上运行的所有实例上运行的进程。 然后，它将检索远程计算机上的相同的过程信息。  
  
 [!code-cpp[Process.GetProcesses_noexception#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.GetProcesses_noexception/CPP/processstaticget.cpp#1)]
 [!code-csharp[Process.GetProcesses_noexception#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.GetProcesses_noexception/CS/processstaticget.cs#1)]
 [!code-vb[Process.GetProcesses_noexception#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.GetProcesses_noexception/VB/processstaticget.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">对于直接调用方的完全信任。 此成员不能由部分信任的代码使用。</permission>
        <altmember cref="P:System.Diagnostics.Process.MachineName" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessById(System.Int32,System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessesByName(System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetCurrentProcess" />
      </Docs>
    </Member>
    <Member MemberName="GetProcesses">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process[] GetProcesses (string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process[] GetProcesses(string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.GetProcesses(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetProcesses (machineName As String) As Process()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Diagnostics::Process ^&gt; ^ GetProcesses(System::String ^ machineName);" />
      <MemberSignature Language="F#" Value="static member GetProcesses : string -&gt; System.Diagnostics.Process[]" Usage="System.Diagnostics.Process.GetProcesses machineName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO("There is no support for retrieving process information from a remote machine")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="machineName">从其中读取进程列表的计算机。</param>
        <summary>为指定计算机上的每个进程资源创建一个新的 <see cref="T:System.Diagnostics.Process" /> 组件。</summary>
        <returns>类型 <see cref="T:System.Diagnostics.Process" /> 的数组，表示指定计算机上运行的所有进程资源。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法用于创建新的数组<xref:System.Diagnostics.Process>组件并将其与指定 （通常为远程） 计算机上的所有进程资源关联。 进程资源必须已经存在的本地计算机上，因为<xref:System.Diagnostics.Process.GetProcesses%2A>不会创建系统资源，但而是将资源与应用程序生成相关联<xref:System.Diagnostics.Process>组件。 由于操作系统本身运行后台进程，此数组是永远不会为空。  
  
 如果您不想要检索所有计算机上运行的进程，你可以通过使用限制其号码<xref:System.Diagnostics.Process.GetProcessById%2A>或<xref:System.Diagnostics.Process.GetProcessesByName%2A>方法。 <xref:System.Diagnostics.Process.GetProcessById%2A> 创建<xref:System.Diagnostics.Process>与系统上由传递给方法的进程标识符标识该进程关联的组件。 <xref:System.Diagnostics.Process.GetProcessesByName%2A> 创建的数组<xref:System.Diagnostics.Process>方法传递其关联的进程资源共享的可执行文件的组件。  
  
 此重载<xref:System.Diagnostics.Process.GetProcesses%2A>方法通常用于检索在网络上的远程计算机上运行的进程资源的列表，但您可以通过传递指定本地计算机"。"。  
  
> [!NOTE]
>  可以将多个 Windows 服务加载服务主机进程 (svchost.exe) 在同一实例。 GetProcesses 不会标识这些单独的服务;为此，请参阅<xref:System.ServiceProcess.ServiceController.GetServices%2A>。  
  
   
  
## Examples  
 下面的示例检索当前进程的信息在本地计算机，记事本本地计算机和本地计算机上的特定进程上运行的所有实例上运行的进程。 然后，它将检索远程计算机上的相同的过程信息。  
  
 [!code-cpp[Process.GetProcesses_noexception#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.GetProcesses_noexception/CPP/processstaticget.cpp#1)]
 [!code-csharp[Process.GetProcesses_noexception#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.GetProcesses_noexception/CS/processstaticget.cs#1)]
 [!code-vb[Process.GetProcesses_noexception#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.GetProcesses_noexception/VB/processstaticget.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="machineName" /> 参数的语法无效。 其长度可能为零 (0)。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="machineName" /> 参数为 <see langword="null" />。</exception>
        <exception cref="T:System.PlatformNotSupportedException">操作系统平台不支持在远程计算机上进行此操作。</exception>
        <exception cref="T:System.InvalidOperationException">访问用于获取进程信息的性能计数器 API 时出现问题。 此异常特定于 Windows NT、Windows 2000 和 Windows XP。</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">访问基础系统 API 时出现问题。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">对于直接调用方的完全信任。 此成员不能由部分信任的代码使用。</permission>
        <altmember cref="P:System.Diagnostics.Process.MachineName" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessById(System.Int32,System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessesByName(System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetCurrentProcess" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetProcessesByName">
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>创建新的 <see cref="T:System.Diagnostics.Process" /> 组件的数组，并将它们与共享指定的进程名称的所有现有进程资源关联。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetProcessesByName">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process[] GetProcessesByName (string processName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process[] GetProcessesByName(string processName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.GetProcessesByName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetProcessesByName (processName As String) As Process()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Diagnostics::Process ^&gt; ^ GetProcessesByName(System::String ^ processName);" />
      <MemberSignature Language="F#" Value="static member GetProcessesByName : string -&gt; System.Diagnostics.Process[]" Usage="System.Diagnostics.Process.GetProcessesByName processName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="processName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="processName">该进程的友好名称。</param>
        <summary>创建新的 <see cref="T:System.Diagnostics.Process" /> 组件的数组，并将它们与本地计算机上共享指定的进程名称的所有进程资源关联。</summary>
        <returns>类型 <see cref="T:System.Diagnostics.Process" /> 的数组，表示运行指定应用程序或文件的进程资源。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法用于创建新的数组<xref:System.Diagnostics.Process>组件并将它们与正在运行相同的可执行文件在本地计算机上的所有进程资源关联。 进程资源必须已经存在的计算机上，因为<xref:System.Diagnostics.Process.GetProcessesByName%2A>不会创建系统资源，但而是将它们与应用程序生成关联<xref:System.Diagnostics.Process>组件。 一个`processName`可为指定当前未运行的本地计算机，因此该方法返回的数组可以是空的可执行文件。  
  
 进程名称是该过程中，如 Outlook、 不包含扩展名为.exe 或路径的友好名称。 <xref:System.Diagnostics.Process.GetProcessesByName%2A> 可帮助获取和操作与相同的可执行文件相关联的所有进程。 例如，可以将作为可执行文件名称传递`processName`参数，以便关闭该可执行文件的所有正在运行的实例。  
  
 尽管进程<xref:System.Diagnostics.Process.Id%2A>是唯一的系统上的单个进程资源，在本地计算机上的多个进程可以运行指定的应用程序`processName`参数。 因此，<xref:System.Diagnostics.Process.GetProcessById%2A>最多返回一个进程，但<xref:System.Diagnostics.Process.GetProcessesByName%2A>返回一个数组，包含所有关联的进程。 如果您需要处理使用标准 API 调用的过程，您可以查询每个进程又为其标识符。 无法访问进程资源，通过单独的进程名称中，但一旦检索到的数组<xref:System.Diagnostics.Process>相关联的组件与进程资源，可以启动、 终止和其他操作的系统资源。  
  
   
  
## Examples  
 下面的示例检索当前进程的信息在本地计算机，记事本本地计算机和本地计算机上的特定进程上运行的所有实例上运行的进程。 然后，它将检索远程计算机上的相同的过程信息。  
  
 [!code-cpp[Process.GetProcesses_noexception#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.GetProcesses_noexception/CPP/processstaticget.cpp#1)]
 [!code-csharp[Process.GetProcesses_noexception#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.GetProcesses_noexception/CS/processstaticget.cs#1)]
 [!code-vb[Process.GetProcesses_noexception#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.GetProcesses_noexception/VB/processstaticget.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">访问用于获取进程信息的性能计数器 API 时出现问题。 此异常特定于 Windows NT、Windows 2000 和 Windows XP。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">对于直接调用方的完全信任。 此成员不能由部分信任的代码使用。</permission>
        <altmember cref="P:System.Diagnostics.Process.ProcessName" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessById(System.Int32,System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetProcesses" />
        <altmember cref="M:System.Diagnostics.Process.GetCurrentProcess" />
      </Docs>
    </Member>
    <Member MemberName="GetProcessesByName">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process[] GetProcessesByName (string processName, string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process[] GetProcessesByName(string processName, string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.GetProcessesByName(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetProcessesByName (processName As String, machineName As String) As Process()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Diagnostics::Process ^&gt; ^ GetProcessesByName(System::String ^ processName, System::String ^ machineName);" />
      <MemberSignature Language="F#" Value="static member GetProcessesByName : string * string -&gt; System.Diagnostics.Process[]" Usage="System.Diagnostics.Process.GetProcessesByName (processName, machineName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="processName" Type="System.String" />
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="processName">该进程的友好名称。</param>
        <param name="machineName">网络上计算机的名称。</param>
        <summary>创建新的 <see cref="T:System.Diagnostics.Process" /> 组件的数组，并将它们与远程计算机上共享指定进程名称的所有进程资源关联。</summary>
        <returns>类型 <see cref="T:System.Diagnostics.Process" /> 的数组，表示运行指定应用程序或文件的进程资源。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法用于创建新的数组<xref:System.Diagnostics.Process>组件并将它们与正在运行指定的计算机上的相同可执行文件的所有进程资源关联。 进程资源必须已经存在的计算机上，因为<xref:System.Diagnostics.Process.GetProcessesByName%2A>不会创建系统资源，但而是将它们与应用程序生成关联<xref:System.Diagnostics.Process>组件。 一个`processName`可为指定当前未运行的本地计算机，因此该方法返回的数组可以是空的可执行文件。  
  
 进程名称是该过程中，如 Outlook、 不包含扩展名为.exe 或路径的友好名称。 <xref:System.Diagnostics.Process.GetProcessesByName%2A> 可帮助获取和操作与相同的可执行文件相关联的所有进程。 例如，可以将作为可执行文件名称传递`processName`参数，以便关闭该可执行文件的所有正在运行的实例。  
  
 尽管进程<xref:System.Diagnostics.Process.Id%2A>是唯一的系统上的单个进程资源，在本地计算机上的多个进程可以运行指定的应用程序`processName`参数。 因此，<xref:System.Diagnostics.Process.GetProcessById%2A>最多返回一个进程，但<xref:System.Diagnostics.Process.GetProcessesByName%2A>返回一个数组，包含所有关联的进程。 如果您需要处理使用标准 API 调用的过程，您可以查询每个进程又为其标识符。 无法访问进程资源，通过单独的进程名称中，但一旦检索到的数组<xref:System.Diagnostics.Process>相关联的组件与进程资源，可以启动、 终止和其他操作的系统资源。  
  
 此重载可用于获取本地计算机上以及在远程计算机上的进程。 使用"。"若要指定本地计算机。 存在另一个重载，默认情况下使用本地计算机。  
  
 您可以访问仅以查看有关进程的信息，如统计、 远程计算机上的进程。 不能关闭，终止 (使用<xref:System.Diagnostics.Process.Kill%2A>)，或在远程计算机上启动进程。  
  
   
  
## Examples  
 下面的示例检索当前进程的信息在本地计算机，记事本本地计算机和本地计算机上的特定进程上运行的所有实例上运行的进程。 然后，它将检索远程计算机上的相同的过程信息。  
  
 [!code-cpp[Process.GetProcesses_noexception#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.GetProcesses_noexception/CPP/processstaticget.cpp#1)]
 [!code-csharp[Process.GetProcesses_noexception#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.GetProcesses_noexception/CS/processstaticget.cs#1)]
 [!code-vb[Process.GetProcesses_noexception#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.GetProcesses_noexception/VB/processstaticget.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="machineName" /> 参数的语法无效。 其长度可能为零 (0)。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="machineName" /> 参数为 <see langword="null" />。</exception>
        <exception cref="T:System.PlatformNotSupportedException">操作系统平台不支持在远程计算机上进行此操作。</exception>
        <exception cref="T:System.InvalidOperationException">访问用于获取进程信息的性能计数器 API 时出现问题。 此异常特定于 Windows NT、Windows 2000 和 Windows XP。</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">访问基础系统 API 时出现问题。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">对于直接调用方的完全信任。 此成员不能由部分信任的代码使用。</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">若要调用非托管的代码。 关联的枚举： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="P:System.Diagnostics.Process.ProcessName" />
        <altmember cref="P:System.Diagnostics.Process.MachineName" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessById(System.Int32,System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetProcesses" />
        <altmember cref="M:System.Diagnostics.Process.GetCurrentProcess" />
      </Docs>
    </Member>
    <Member MemberName="Handle">
      <MemberSignature Language="C#" Value="public IntPtr Handle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int Handle" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.Handle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Handle As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr Handle { IntPtr get(); };" />
      <MemberSignature Language="F#" Value="member this.Handle : nativeint" Usage="System.Diagnostics.Process.Handle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Returns the native handle for this process.   The handle is only available if the process was started using this component.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessHandle")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取关联进程的本机句柄。</summary>
        <value>进程启动时操作系统向关联进程分配的句柄。 系统使用此句柄来跟踪过程属性。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 应用程序可以获得可用作许多进程信息和控制函数的参数的进程的句柄。 您可以使用此句柄初始化<xref:System.Threading.WaitHandle>或调用与平台的本机方法调用。  
  
 此进程句柄是私有的应用程序--即，不能共享句柄的过程。 某个进程还拥有进程<xref:System.Diagnostics.Process.Id%2A>的但不同于<xref:System.Diagnostics.Process.Handle%2A>，是唯一的因此，在整个系统有效。  
  
 通过调用启动仅进程<xref:System.Diagnostics.Process.Start%2A>设置<xref:System.Diagnostics.Process.Handle%2A>的相应属性<xref:System.Diagnostics.Process>实例。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">该进程尚未启动或已退出。 不能读取 <see cref="P:System.Diagnostics.Process.Handle" /> 属性，因为没有与此 <see cref="T:System.Diagnostics.Process" /> 实例关联的进程。  
  
或 
<see cref="T:System.Diagnostics.Process" /> 实例已附加到正在运行的进程，但您没有获取具有完全访问权限的句柄所需的权限。</exception>
        <exception cref="T:System.NotSupportedException">你正尝试访问在远程计算机上运行的进程的 <see cref="P:System.Diagnostics.Process.Handle" /> 属性。 此属性仅可用于本地计算机上运行的进程。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">对于直接调用方的完全信任。 此成员不能由部分信任的代码使用。</permission>
        <altmember cref="P:System.Diagnostics.Process.Id" />
        <altmember cref="P:System.Diagnostics.Process.ExitCode" />
        <altmember cref="P:System.Diagnostics.Process.ExitTime" />
        <altmember cref="P:System.Diagnostics.Process.HandleCount" />
        <altmember cref="M:System.Diagnostics.Process.Start" />
        <altmember cref="M:System.Diagnostics.Process.Refresh" />
      </Docs>
    </Member>
    <Member MemberName="HandleCount">
      <MemberSignature Language="C#" Value="public int HandleCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 HandleCount" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.HandleCount" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HandleCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int HandleCount { int get(); };" />
      <MemberSignature Language="F#" Value="member this.HandleCount : int" Usage="System.Diagnostics.Process.HandleCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Handles for this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessHandleCount")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取由进程打开的句柄数。</summary>
        <value>进程打开的操作系统句柄数。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 句柄提供进程要引用的对象的方法。 一个进程可以获取对文件、 资源、 消息队列和许多其他操作系统对象的句柄。 操作系统将回收仅当句柄计数为零时，与该进程关联的内存。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">该平台是 Windows 98 或 Windows Millennium Edition (Windows Me)；将 <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> 属性设置为 <see langword="false" />，以在 Windows 98 和 Windows Me 上访问此属性。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">对于直接调用方的完全信任。 此成员不能由部分信任的代码使用。</permission>
        <altmember cref="P:System.Diagnostics.Process.Handle" />
        <altmember cref="M:System.Diagnostics.Process.Start" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Kill" />
      </Docs>
    </Member>
    <Member MemberName="HasExited">
      <MemberSignature Language="C#" Value="public bool HasExited { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasExited" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.HasExited" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HasExited As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool HasExited { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.HasExited : bool" Usage="System.Diagnostics.Process.HasExited" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Indicates if the associated process has been terminated.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessTerminated")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取指示关联进程是否已终止的值。</summary>
        <value>如果 <see cref="T:System.Diagnostics.Process" /> 组件引用的操作系统进程已终止，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 值为`true`为<xref:System.Diagnostics.Process.HasExited%2A>指示关联的进程已终止，正常或异常。 可以请求或强制关联的进程退出通过调用<xref:System.Diagnostics.Process.CloseMainWindow%2A>或<xref:System.Diagnostics.Process.Kill%2A>。 如果已打开到进程句柄，操作系统将释放的进程内存时进程已退出，但会保留有关过程，如句柄、 退出代码和退出时的管理信息。 若要获取此信息，可以使用<xref:System.Diagnostics.Process.ExitCode%2A>和<xref:System.Diagnostics.Process.ExitTime%2A>属性。 有关此组件启动的进程的自动填充这些属性。 发布管理的信息时所有<xref:System.Diagnostics.Process>与系统进程关联的组件将销毁，并没有更多的句柄保留至已退出进程。  
  
 独立于你的代码可以终止进程。 如果你开始使用此组件的过程，系统将更新的值<xref:System.Diagnostics.Process.HasExited%2A>自动，即使独立关联的进程退出。  
  
> [!NOTE]
>  标准输出重定向到异步事件处理程序，它时，可以在此属性返回时不已完成输出处理`true`。 若要确保已完成异步事件处理，请调用<xref:System.Diagnostics.Process.WaitForExit>检查之前不接受任何参数的重载<xref:System.Diagnostics.Process.HasExited%2A>。  
  
   
  
## Examples  
 以下示例启动记事本的实例。 然后在 10 秒的最长 2 第二个时间间隔检索关联的进程的物理内存使用情况。 该示例检测是否在进程退出之前已在过去 10 秒。 如果它仍在运行在 10 秒后，该示例将关闭该过程。  
  
 [!code-cpp[process_refresh#1](~/samples/snippets/cpp/VS_Snippets_CLR/process_refresh/CPP/process_refresh.cpp#1)]
 [!code-csharp[process_refresh#1](~/samples/snippets/csharp/VS_Snippets_CLR/process_refresh/CS/process_refresh.cs#1)]
 [!code-vb[process_refresh#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_refresh/VB/process_refresh.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">没有与此对象关联的进程。</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">无法检索该进程的退出代码。</exception>
        <exception cref="T:System.NotSupportedException">你正尝试访问在远程计算机上运行的进程的 <see cref="P:System.Diagnostics.Process.HasExited" /> 属性。 此属性仅可用于本地计算机上运行的进程。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">对于直接调用方的完全信任。 此成员不能由部分信任的代码使用。</permission>
        <altmember cref="P:System.Diagnostics.Process.ExitCode" />
        <altmember cref="P:System.Diagnostics.Process.ExitTime" />
        <altmember cref="M:System.Diagnostics.Process.WaitForExit(System.Int32)" />
        <altmember cref="P:System.Diagnostics.Process.EnableRaisingEvents" />
        <altmember cref="M:System.Diagnostics.Process.OnExited" />
      </Docs>
    </Member>
    <Member MemberName="Id">
      <MemberSignature Language="C#" Value="public int Id { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Id" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.Id" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Id As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Id { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Id : int" Usage="System.Diagnostics.Process.Id" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The unique identifier for the process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessId")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取关联进程的唯一标识符。</summary>
        <value>此 <see cref="T:System.Diagnostics.Process" /> 实例引用的、由系统生成的进程的唯一标识符。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 该过程<xref:System.Diagnostics.Process.Id%2A>不是关联的进程未运行时才有效。 因此，应确保该进程运行之前尝试检索<xref:System.Diagnostics.Process.Id%2A>属性。 在进程终止，直到进程标识符唯一标识在整个系统进程。  
  
 你可以连接到新的本地或远程计算机运行的进程<xref:System.Diagnostics.Process>通过将传递到的进程标识符实例<xref:System.Diagnostics.Process.GetProcessById%2A>方法。 <xref:System.Diagnostics.Process.GetProcessById%2A> 是`static`方法，可创建一个新组件，并设置<xref:System.Diagnostics.Process.Id%2A>属性的新<xref:System.Diagnostics.Process>实例会自动。  
  
 由系统，可以重复使用进程标识符。 <xref:System.Diagnostics.Process.Id%2A>属性值是唯一的仅当关联的进程正在运行时。 系统进程终止后，可以重复使用<xref:System.Diagnostics.Process.Id%2A>不相关的进程的属性值。  
  
 因为该标识符是唯一在系统上，您可以将其传递给其他线程作为传递的替代方法<xref:System.Diagnostics.Process>实例。 此操作可以节省系统资源，又可保证正确标识进程。  
  
   
  
## Examples  
 下面的示例演示如何获取<xref:System.Diagnostics.Process.Id%2A>所有正在运行的应用程序的实例。 代码创建记事本的新实例，列出了记事本的所有实例，然后允许用户输入<xref:System.Diagnostics.Process.Id%2A>编号，以删除特定的实例。  
  
 [!code-csharp[System.Diagnostics.Process.Id#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Diagnostics.Process.Id/CS/program.cs#1)]
 [!code-vb[System.Diagnostics.Process.Id#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Diagnostics.Process.Id/VB/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">尚未设置此进程的 <see cref="P:System.Diagnostics.Process.Id" /> 属性。  
  
或 
没有与此 <see cref="T:System.Diagnostics.Process" /> 对象关联的进程。</exception>
        <exception cref="T:System.PlatformNotSupportedException">该平台是 Windows 98 或 Windows Millennium Edition (Windows Me)；将 <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> 属性设置为 <see langword="false" />，以在 Windows 98 和 Windows Me 上访问此属性。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">对于直接调用方的完全信任。 此成员不能由部分信任的代码使用。</permission>
        <altmember cref="P:System.Diagnostics.Process.Handle" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessById(System.Int32,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Kill">
      <MemberSignature Language="C#" Value="public void Kill ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Kill() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Kill" />
      <MemberSignature Language="VB.NET" Value="Public Sub Kill ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Kill();" />
      <MemberSignature Language="F#" Value="member this.Kill : unit -&gt; unit" Usage="process.Kill " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>立即停止关联的进程。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.Kill%2A> 强制终止的进程，而<xref:System.Diagnostics.Process.CloseMainWindow%2A>只是请求终止。 具有图形界面的进程是在执行时，其消息循环将处于等待状态。 消息循环执行每次操作系统 Windows 消息发送到进程。 调用<xref:System.Diagnostics.Process.CloseMainWindow%2A>接近主窗口中，其格式正确的应用程序中关闭子窗口，并撤消所有正在运行的应用程序消息循环发送到请求。 请求退出进程通过调用<xref:System.Diagnostics.Process.CloseMainWindow%2A>不会强制应用程序退出。 应用程序可以让用户验证在退出之前也可以拒绝它退出。 若要强制应用程序退出，请使用<xref:System.Diagnostics.Process.Kill%2A>方法。 行为<xref:System.Diagnostics.Process.CloseMainWindow%2A>等同于用户关闭应用程序的主窗口中使用系统菜单。 因此，通过关闭主窗口退出该进程的请求不会强制应用程序立即退出。  
  
> [!NOTE]
>  <xref:System.Diagnostics.Process.Kill%2A>方法以异步方式执行。 在调用<xref:System.Diagnostics.Process.Kill%2A>方法中，调用<xref:System.Diagnostics.Process.WaitForExit%2A>方法以等待进程退出，或检查<xref:System.Diagnostics.Process.HasExited%2A>属性来确定进程已退出。  
  
 编辑进程的数据或资源分配给该过程可能会丢失如果调用<xref:System.Diagnostics.Process.Kill%2A>。 <xref:System.Diagnostics.Process.Kill%2A> 导致异常的进程终止，因此应仅在必要时。 <xref:System.Diagnostics.Process.CloseMainWindow%2A> 使该过程的有序地终止并关闭所有窗口，以便使用接口的应用程序更好地。 如果<xref:System.Diagnostics.Process.CloseMainWindow%2A>失败，可以使用<xref:System.Diagnostics.Process.Kill%2A>终止进程。 <xref:System.Diagnostics.Process.Kill%2A> 是唯一的方法来终止进程不具有图形界面。  
  
 您可以调用<xref:System.Diagnostics.Process.Kill%2A>和<xref:System.Diagnostics.Process.CloseMainWindow%2A>仅对本地计算机运行的进程。 若要退出的远程计算机上，不能导致进程。 您只能查看在远程计算机上运行进程的信息。  
  
> [!NOTE]
>  如果在调用<xref:System.Diagnostics.Process.Kill%2A>方法由当前正在终止该进程，而<xref:System.ComponentModel.Win32Exception>引发因访问被拒绝。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">无法终止相关联的进程。  
  
或 
进程将终止。  
  
或 
关联的进程是 Win16 可执行文件。</exception>
        <exception cref="T:System.NotSupportedException">你正尝试为远程计算机上运行的进程调用 <see cref="M:System.Diagnostics.Process.Kill" />。 该方法仅对本地计算机上运行的进程可用。</exception>
        <exception cref="T:System.InvalidOperationException">已经退出该进程。  
  
或 
没有与此 <see cref="T:System.Diagnostics.Process" /> 对象关联的进程。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">对于直接调用方的完全信任。 此成员不能由部分信任的代码使用。</permission>
        <altmember cref="M:System.Environment.Exit(System.Int32)" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Start" />
      </Docs>
    </Member>
    <Member MemberName="LeaveDebugMode">
      <MemberSignature Language="C#" Value="public static void LeaveDebugMode ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void LeaveDebugMode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.LeaveDebugMode" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub LeaveDebugMode ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void LeaveDebugMode();" />
      <MemberSignature Language="F#" Value="static member LeaveDebugMode : unit -&gt; unit" Usage="System.Diagnostics.Process.LeaveDebugMode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>使 <see cref="T:System.Diagnostics.Process" /> 组件离开允许它与以特殊模式运行的操作系统进程交互的状态。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 以特殊模式运行某些操作系统进程。 尝试读取的属性或将附加到这些进程不能除非您调用<xref:System.Diagnostics.Process.EnterDebugMode%2A>组件上。 调用<xref:System.Diagnostics.Process.LeaveDebugMode%2A>不再需要对这些特殊模式运行的进程的访问。  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">对于直接调用方的完全信任。 此成员不能由部分信任的代码使用。</permission>
        <altmember cref="M:System.Diagnostics.Process.EnterDebugMode" />
      </Docs>
    </Member>
    <Member MemberName="MachineName">
      <MemberSignature Language="C#" Value="public string MachineName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string MachineName" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.MachineName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MachineName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ MachineName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MachineName : string" Usage="System.Diagnostics.Process.MachineName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The name of the machine the running the process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessMachineName")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取关联进程正在其上运行的计算机的名称。</summary>
        <value>关联进程正在其上运行的计算机的名称。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 您可以查看统计数据，但在远程计算机上运行的进程的进程信息无法调用<xref:System.Diagnostics.Process.Start%2A>， <xref:System.Diagnostics.Process.CloseMainWindow%2A>，或<xref:System.Diagnostics.Process.Kill%2A>远程计算机上。  
  
> [!NOTE]
>  此属性时在本地计算机上执行关联的进程时，返回一个句点 ("。") 的计算机名称。 应使用<xref:System.Environment.MachineName%2A?displayProperty=nameWithType>属性获取正确的计算机名称。  
  
   
  
## Examples  
 若要使用下面的示例，必须先在远程计算机上启动记事本的至少一个实例。 该示例请求在其记事本正在运行，并显示相应的远程计算机的名称<xref:System.Diagnostics.Process.ProcessName%2A>， <xref:System.Diagnostics.Process.Id%2A>，和<xref:System.Diagnostics.Process.MachineName%2A>每个实例的属性。  
  
 [!code-cpp[process_GetProcessesByName2_2#2](~/samples/snippets/cpp/VS_Snippets_CLR/Process_GetProcessesByName2_2/CPP/process_getprocessesbyname2_2.cpp#2)]
 [!code-csharp[process_GetProcessesByName2_2#2](~/samples/snippets/csharp/VS_Snippets_CLR/Process_GetProcessesByName2_2/CS/process_getprocessesbyname2_2.cs#2)]
 [!code-vb[process_GetProcessesByName2_2#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process_GetProcessesByName2_2/VB/process_getprocessesbyname2_2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">没有与此 <see cref="T:System.Diagnostics.Process" /> 对象关联的进程。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">对于直接调用方的完全信任。 此成员不能由部分信任的代码使用。</permission>
        <altmember cref="M:System.Diagnostics.Process.GetProcesses" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessById(System.Int32,System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessesByName(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="MainModule">
      <MemberSignature Language="C#" Value="public System.Diagnostics.ProcessModule MainModule { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Diagnostics.ProcessModule MainModule" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.MainModule" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MainModule As ProcessModule" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Diagnostics::ProcessModule ^ MainModule { System::Diagnostics::ProcessModule ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MainModule : System.Diagnostics.ProcessModule" Usage="System.Diagnostics.Process.MainModule" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The main module of the process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessMainModule")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.ProcessModule</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取关联进程的主模块。</summary>
        <value>用于启动进程的 <see cref="T:System.Diagnostics.ProcessModule" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 进程模块表示加载到特定进程的.dll 或.exe 文件。 <xref:System.Diagnostics.Process.MainModule%2A>属性，可以查看有关用于启动进程，包括模块名称、 文件名和模块内存详细信息的可执行文件的信息。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">你正尝试访问在远程计算机上运行的进程的 <see cref="P:System.Diagnostics.Process.MainModule" /> 属性。 此属性仅可用于本地计算机上运行的进程。</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">32 位进程正尝试访问 64 位进程的模块。</exception>
        <exception cref="T:System.PlatformNotSupportedException">该平台是 Windows 98 或 Windows Millennium Edition (Windows Me)；将 <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> 设置为 <see langword="false" />，以在 Windows 98 和 Windows Me 上访问此属性。</exception>
        <exception cref="T:System.InvalidOperationException">进程 <see cref="P:System.Diagnostics.Process.Id" /> 不可用。  
  
或 
该进程已退出。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">对于直接调用方的完全信任。 此成员不能由部分信任的代码使用。</permission>
        <altmember cref="P:System.Diagnostics.Process.Modules" />
      </Docs>
    </Member>
    <Member MemberName="MainWindowHandle">
      <MemberSignature Language="C#" Value="public IntPtr MainWindowHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int MainWindowHandle" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.MainWindowHandle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MainWindowHandle As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr MainWindowHandle { IntPtr get(); };" />
      <MemberSignature Language="F#" Value="member this.MainWindowHandle : nativeint" Usage="System.Diagnostics.Process.MainWindowHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The handle of the main window of the process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessMainWindowHandle")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取关联进程主窗口的窗口句柄。</summary>
        <value>关联进程主窗口的系统生成的窗口句柄。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 主窗口是当前具有焦点的进程打开的窗口 (<xref:System.Windows.Forms.Form.TopLevel%2A>窗体)。 必须使用<xref:System.Diagnostics.Process.Refresh%2A>方法来刷新<xref:System.Diagnostics.Process>要获取当前的主窗口句柄已更改对象。 一般情况下，由于缓存的窗口句柄，因此使用<xref:System.Diagnostics.Process.Refresh%2A>事先以保证，将检索当前句柄。  
  
 可以获取<xref:System.Diagnostics.Process.MainWindowHandle%2A>仅对本地计算机运行的进程的属性。 <xref:System.Diagnostics.Process.MainWindowHandle%2A>属性是唯一标识与该进程关联的窗口的值。  
  
 某个进程拥有仅当该过程具有图形界面与之关联的主窗口。 如果关联的进程没有主窗口、<xref:System.Diagnostics.Process.MainWindowHandle%2A>值为零。 值也为零的进程的已被隐藏，即，处理不可见的任务栏中的。 这可以是任务栏的以图标在通知区域中，在最右侧中显示的进程这种情况。  
  
 如果你只需启动了一个进程，并想要使用其主窗口句柄，请考虑使用<xref:System.Diagnostics.Process.WaitForInputIdle%2A>方法，以允许该进程完成后从开始，确保已创建了主窗口句柄。 否则，将引发异常。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">未定义 <see cref="P:System.Diagnostics.Process.MainWindowHandle" />，因为进程已退出。</exception>
        <exception cref="T:System.NotSupportedException">你正尝试访问在远程计算机上运行的进程的 <see cref="P:System.Diagnostics.Process.MainWindowHandle" /> 属性。 此属性仅可用于本地计算机上运行的进程。</exception>
        <exception cref="T:System.PlatformNotSupportedException">该平台是 Windows 98 或 Windows Millennium Edition (Windows Me)；将 <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> 设置为 <see langword="false" />，以在 Windows 98 和 Windows Me 上访问此属性。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">对于直接调用方的完全信任。 此成员不能由部分信任的代码使用。</permission>
        <altmember cref="P:System.Diagnostics.Process.MainWindowTitle" />
        <altmember cref="P:System.Diagnostics.Process.MainModule" />
      </Docs>
    </Member>
    <Member MemberName="MainWindowTitle">
      <MemberSignature Language="C#" Value="public string MainWindowTitle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string MainWindowTitle" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.MainWindowTitle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MainWindowTitle As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ MainWindowTitle { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MainWindowTitle : string" Usage="System.Diagnostics.Process.MainWindowTitle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The title of the main window of the process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessMainWindowTitle")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取进程的主窗口标题。</summary>
        <value>进程的主窗口标题。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 某个进程拥有仅当该过程具有图形界面与之关联的主窗口。 如果关联的进程没有主窗口 (以便<xref:System.Diagnostics.Process.MainWindowHandle%2A>为零)，<xref:System.Diagnostics.Process.MainWindowTitle%2A>为空字符串 ("")。 如果你只需启动了一个进程，并想要使用其主窗口标题，请考虑使用<xref:System.Diagnostics.Process.WaitForInputIdle%2A>方法，以允许该进程完成后从开始，确保已创建了主窗口句柄。 否则，系统将引发异常。  
  
> [!NOTE]
>  主窗口是当前具有焦点，则窗口请注意，这可能不是进程的主窗口。 必须使用<xref:System.Diagnostics.Process.Refresh%2A>方法来刷新<xref:System.Diagnostics.Process>要获取当前的主窗口句柄已更改对象。  
  
   
  
## Examples  
 以下示例启动记事本的实例，并检索该过程的主窗口的标题。  
  
 [!code-cpp[process_MainWindowTitle#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process_MainWindowTitle/CPP/process_mainwindowtitle.cpp#1)]
 [!code-csharp[process_MainWindowTitle#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process_MainWindowTitle/CS/process_mainwindowtitle.cs#1)]
 [!code-vb[process_MainWindowTitle#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process_MainWindowTitle/VB/process_mainwindowtitle.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">未定义 <see cref="P:System.Diagnostics.Process.MainWindowTitle" /> 属性，因为进程已退出。</exception>
        <exception cref="T:System.NotSupportedException">你正尝试访问在远程计算机上运行的进程的 <see cref="P:System.Diagnostics.Process.MainWindowTitle" /> 属性。 此属性仅可用于本地计算机上运行的进程。</exception>
        <exception cref="T:System.PlatformNotSupportedException">该平台是 Windows 98 或 Windows Millennium Edition (Windows Me)；将 <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> 设置为 <see langword="false" />，以在 Windows 98 和 Windows Me 上访问此属性。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">对于直接调用方的完全信任。 此成员不能由部分信任的代码使用。</permission>
      </Docs>
    </Member>
    <Member MemberName="MaxWorkingSet">
      <MemberSignature Language="C#" Value="public IntPtr MaxWorkingSet { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int MaxWorkingSet" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.MaxWorkingSet" />
      <MemberSignature Language="VB.NET" Value="Public Property MaxWorkingSet As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr MaxWorkingSet { IntPtr get(); void set(IntPtr value); };" />
      <MemberSignature Language="F#" Value="member this.MaxWorkingSet : nativeint with get, set" Usage="System.Diagnostics.Process.MaxWorkingSet" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The maximum amount of physical memory the process has required since it was started.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessMaxWorkingSet")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置关联进程允许的最大工作集大小（以字节为单位）。</summary>
        <value>内存中允许的进程的最大工作集大小(以字节为单位)。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 进程工作集是物理 RAM 内存中当前可见到进程的内存页的集合。 这些页面是常驻内存，可用于应用程序使用而不会触发页面错误。  
  
 工作集包括数据共享和专用数据。 共享的数据包括页，包含你的应用程序执行，包括您的.dll 文件和 system.dll 文件中的页的所有说明。 工作集大小的增加，会增加内存需求。  
  
 某个进程拥有最小值和最大工作集大小。 创建一个进程资源，每次系统预留等于最小工作集大小的进程的内存量。 虚拟内存管理器尝试保留至少最小内存量常驻时进程处于活动状态，但它永远不会保留最大大小的详细信息。  
  
 系统设置的默认工作集大小。 您可以修改使用这些大小<xref:System.Diagnostics.Process.MaxWorkingSet%2A>和<xref:System.Diagnostics.Process.MinWorkingSet%2A>成员。 但是，设置这些值不保证内存将保留或驻留。  
  
> [!NOTE]
>  如果增加进程工作集大小，你需要从系统的其余部分的物理内存。 请确保你不会请求是太大，因为这样做会降低系统性能最小值或最大工作集大小。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">最大的工作集大小无效。 它必须大于或等于最小的工作集大小。</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">无法从关联的进程资源中检索工作集信息。  
  
或 
进程标识符或进程句柄为零，因为尚未启动该进程。</exception>
        <exception cref="T:System.NotSupportedException">你正尝试访问在远程计算机上运行的进程的 <see cref="P:System.Diagnostics.Process.MaxWorkingSet" /> 属性。 此属性仅可用于本地计算机上运行的进程。</exception>
        <exception cref="T:System.InvalidOperationException">进程 <see cref="P:System.Diagnostics.Process.Id" /> 不可用。  
  
或 
该进程已退出。</exception>
        <exception cref="T:System.PlatformNotSupportedException">该平台是 Windows 98 或 Windows Millennium Edition (Windows Me)，不支持此属性。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">对于直接调用方的完全信任。 此成员不能由部分信任的代码使用。</permission>
        <altmember cref="P:System.Diagnostics.Process.MinWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.WorkingSet64" />
        <altmember cref="P:System.Diagnostics.Process.PeakWorkingSet64" />
      </Docs>
    </Member>
    <Member MemberName="MinWorkingSet">
      <MemberSignature Language="C#" Value="public IntPtr MinWorkingSet { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int MinWorkingSet" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.MinWorkingSet" />
      <MemberSignature Language="VB.NET" Value="Public Property MinWorkingSet As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr MinWorkingSet { IntPtr get(); void set(IntPtr value); };" />
      <MemberSignature Language="F#" Value="member this.MinWorkingSet : nativeint with get, set" Usage="System.Diagnostics.Process.MinWorkingSet" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The minimum amount of physical memory the process has required since it was started.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessMinWorkingSet")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置关联进程允许的最小工作集大小（以字节为单位）。</summary>
        <value>内存中进程所需的最小工作集大小(以字节为单位)。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 进程工作集是物理 RAM 内存中当前可见到进程的内存页的集合。 这些页面是常驻内存，可用于应用程序使用而不会触发页面错误。  
  
 工作集包括数据共享和专用数据。 共享的数据包括页，包含你的应用程序执行，包括您的.dll 文件和 system.dll 文件中的页的所有说明。 工作集大小的增加，会增加内存需求。  
  
 某个进程拥有最小值和最大工作集大小。 创建一个进程资源，每次系统预留等于最小工作集大小的进程的内存量。 虚拟内存管理器尝试保留至少最小内存量常驻时进程处于活动状态，但它永远不会保留最大大小的详细信息。  
  
 系统设置的默认工作集大小。 您可以修改使用这些大小<xref:System.Diagnostics.Process.MaxWorkingSet%2A>和<xref:System.Diagnostics.Process.MinWorkingSet%2A>成员。 但是，设置这些值不保证内存将保留或驻留。  
  
> [!NOTE]
>  如果增加进程工作集大小，你需要从系统的其余部分的物理内存。 请确保你不会请求是太大，因为这样做会降低系统性能最小值或最大工作集大小。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">最小工作集大小无效。 它必须小于或等于最大工作集大小。</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">无法从关联的进程资源中检索工作集信息。  
  
或 
进程标识符或进程句柄为零，因为尚未启动该进程。</exception>
        <exception cref="T:System.NotSupportedException">你正尝试访问在远程计算机上运行的进程的 <see cref="P:System.Diagnostics.Process.MinWorkingSet" /> 属性。 此属性仅可用于本地计算机上运行的进程。</exception>
        <exception cref="T:System.InvalidOperationException">进程 <see cref="P:System.Diagnostics.Process.Id" /> 不可用。  
  
或 
该进程已退出。</exception>
        <exception cref="T:System.PlatformNotSupportedException">该平台是 Windows 98 或 Windows Millennium Edition (Windows Me)，不支持此属性。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">对于直接调用方的完全信任。 此成员不能由部分信任的代码使用。</permission>
        <altmember cref="P:System.Diagnostics.Process.MaxWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.WorkingSet64" />
        <altmember cref="P:System.Diagnostics.Process.PeakWorkingSet64" />
      </Docs>
    </Member>
    <Member MemberName="Modules">
      <MemberSignature Language="C#" Value="public System.Diagnostics.ProcessModuleCollection Modules { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Diagnostics.ProcessModuleCollection Modules" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.Modules" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Modules As ProcessModuleCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Diagnostics::ProcessModuleCollection ^ Modules { System::Diagnostics::ProcessModuleCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Modules : System.Diagnostics.ProcessModuleCollection" Usage="System.Diagnostics.Process.Modules" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The modules that are loaded as part of this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessModules")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.ProcessModuleCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取已由关联进程加载的模块。</summary>
        <value>类型 <see cref="T:System.Diagnostics.ProcessModule" /> 的数组，表示已由关联进程加载的模块。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 进程模块表示加载到特定进程的.dll 或.exe 文件。 一个<xref:System.Diagnostics.ProcessModule>实例，您可以查看有关模块，包括模块名称、 文件名和模块内存详细信息的信息。  
  
 一个进程可以加载到内存中的多个模块。 例如，.exe 文件，加载其他.dll 文件具有多个模块。  
  
 启动进程之后, 此集合为空之前在系统加载过程。 如果进程主窗口，可以调用<xref:System.Diagnostics.Process.WaitForInputIdle%2A>检索此属性以确保该集合为空时之前你获取的列表。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">你正试图访问在远程计算机上运行的进程的 <see cref="P:System.Diagnostics.Process.Modules" /> 属性。 此属性仅可用于本地计算机上运行的进程。</exception>
        <exception cref="T:System.InvalidOperationException">进程 <see cref="P:System.Diagnostics.Process.Id" /> 不可用。</exception>
        <exception cref="T:System.PlatformNotSupportedException">该平台是 Windows 98 或 Windows Millennium Edition (Windows Me)；将 <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> 设置为 <see langword="false" />，以在 Windows 98 和 Windows Me 上访问此属性。</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">您尝试访问系统进程或 Idle 进程的 <see cref="P:System.Diagnostics.Process.Modules" /> 属性。 这些进程没有模块。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">对于直接调用方的完全信任。 此成员不能由部分信任的代码使用。</permission>
        <altmember cref="T:System.Diagnostics.ProcessModule" />
      </Docs>
    </Member>
    <Member MemberName="NonpagedSystemMemorySize">
      <MemberSignature Language="C#" Value="public int NonpagedSystemMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 NonpagedSystemMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.NonpagedSystemMemorySize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property NonpagedSystemMemorySize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int NonpagedSystemMemorySize { int get(); };" />
      <MemberSignature Language="F#" Value="member this.NonpagedSystemMemorySize : int" Usage="System.Diagnostics.Process.NonpagedSystemMemorySize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The number of bytes that are not pageable.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use NonpagedSystemMemorySize64")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.NonpagedSystemMemorySize64 instead.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessNonpagedSystemMemorySize")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取为关联的进程分配的非分页系统内存量（以字节为单位）。</summary>
        <value>系统已为无法写入到虚拟内存分页文件的关联进程分配的内存量(以字节为单位)。</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.PlatformNotSupportedException">该平台是 Windows 98 或 Windows Millennium Edition (Windows Me)，不支持此属性。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">对于直接调用方的完全信任。 此成员不能由部分信任的代码使用。</permission>
        <altmember cref="P:System.Diagnostics.Process.NonpagedSystemMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="NonpagedSystemMemorySize64">
      <MemberSignature Language="C#" Value="public long NonpagedSystemMemorySize64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 NonpagedSystemMemorySize64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.NonpagedSystemMemorySize64" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property NonpagedSystemMemorySize64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long NonpagedSystemMemorySize64 { long get(); };" />
      <MemberSignature Language="F#" Value="member this.NonpagedSystemMemorySize64 : int64" Usage="System.Diagnostics.Process.NonpagedSystemMemorySize64" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The number of bytes that are not pageable.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessNonpagedSystemMemorySize")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取为关联的进程分配的非分页系统内存量（以字节为单位）。</summary>
        <value>为关联的进程分配的、不能写入虚拟内存分页文件中的系统内存量(以字节为单位)。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 返回此属性的值表示使用的过程中，以字节为单位的非分页的系统内存的当前大小。 系统内存是由操作系统使用的物理内存，并且分为分页和非分页池。 非分页的内存分配保留在系统内存中并不都分页输出到的虚拟内存分页文件。  
  
 此属性可以用于监视具有 32 位处理器或 64 位处理器的计算机上的内存使用率。 属性值等于**池非分页字节数**进程的性能计数器。  
  
   
  
## Examples  
 下面的代码示例启动记事本应用程序的实例。 该示例然后检索并显示关联的进程的各种属性。 该示例检测时在进程退出，并显示其退出代码和峰值内存统计信息。  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">该平台是 Windows 98 或 Windows Millennium Edition (Windows Me)，不支持此属性。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">对于直接调用方的完全信任。 此成员不能由部分信任的代码使用。</permission>
        <altmember cref="P:System.Diagnostics.Process.PagedSystemMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="OnExited">
      <MemberSignature Language="C#" Value="protected void OnExited ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void OnExited() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.OnExited" />
      <MemberSignature Language="VB.NET" Value="Protected Sub OnExited ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void OnExited();" />
      <MemberSignature Language="F#" Value="member this.OnExited : unit -&gt; unit" Usage="process.OnExited " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>引发 <see cref="E:System.Diagnostics.Process.Exited" /> 事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.OnExited%2A> 是 API 方法，引发<xref:System.Diagnostics.Process.Exited>事件。 调用<xref:System.Diagnostics.Process.OnExited%2A>会导致<xref:System.Diagnostics.Process.Exited>事件的发生，而是唯一的方法来引发事件使用<xref:System.Diagnostics.Process>组件。 <xref:System.Diagnostics.Process.OnExited%2A> 主要在从组件派生的类时使用。  
  
 作为一种替代方法<xref:System.Diagnostics.Process.OnExited%2A>，可以编写自己的事件处理程序。 创建你自己的事件处理程序委托和事件处理方法。  
  
> [!NOTE]
>  如果使用 Visual Studio 环境时，事件处理程序委托 (AddOnExited) 和一个事件处理方法 (Process1_Exited) 会为您创建在拖动时<xref:System.Diagnostics.Process>组件拖动到窗体上，双击该图标。 创建时要运行代码<xref:System.Diagnostics.Process.Exited>输入到 Process1_Exited 过程发生的事件。 不需要创建<xref:System.Diagnostics.Process.OnExited%2A>成员，因为它实现的。  
  
 引发事件时，将通过委托调用事件处理程序。 有关概述，请参阅[处理和引发事件](~/docs/standard/events/index.md)。  
  
   
  
## Examples  
 下面的示例演示如何使用<xref:System.Diagnostics.Process.OnExited%2A>派生类中的方法。  
  
 [!code-csharp[OnExitSample#1](~/samples/snippets/csharp/VS_Snippets_CLR/onexitsample/cs/program.cs#1)]
 [!code-vb[OnExitSample#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/onexitsample/vb/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">对于直接调用方的完全信任。 此成员不能由部分信任的代码使用。</permission>
        <altmember cref="E:System.Diagnostics.Process.Exited" />
      </Docs>
    </Member>
    <Member MemberName="OutputDataReceived">
      <MemberSignature Language="C#" Value="public event System.Diagnostics.DataReceivedEventHandler OutputDataReceived;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Diagnostics.DataReceivedEventHandler OutputDataReceived" />
      <MemberSignature Language="DocId" Value="E:System.Diagnostics.Process.OutputDataReceived" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event OutputDataReceived As DataReceivedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Diagnostics::DataReceivedEventHandler ^ OutputDataReceived;" />
      <MemberSignature Language="F#" Value="member this.OutputDataReceived : System.Diagnostics.DataReceivedEventHandler " Usage="member this.OutputDataReceived : System.Diagnostics.DataReceivedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Indicates if the process component is associated with a real process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessAssociated")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.DataReceivedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>每次应用程序向其重定向 <see cref="P:System.Diagnostics.Process.StandardOutput" /> 流中写入行时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.OutputDataReceived>事件表示，关联<xref:System.Diagnostics.Process>撰写了行，终止的换行字符，为其重定向<xref:System.Diagnostics.Process.StandardOutput%2A>流。  
  
 该事件在异步读取操作期间启用上<xref:System.Diagnostics.Process.StandardOutput%2A>。 若要开始异步读取的操作，必须重定向<xref:System.Diagnostics.Process.StandardOutput%2A>串<xref:System.Diagnostics.Process>，添加到事件处理程序<xref:System.Diagnostics.Process.OutputDataReceived>事件，并调用<xref:System.Diagnostics.Process.BeginOutputReadLine%2A>。 此后，<xref:System.Diagnostics.Process.OutputDataReceived>事件信号每次该过程将行写入到的重定向<xref:System.Diagnostics.Process.StandardOutput%2A>流式传输，直到该进程退出，或调用<xref:System.Diagnostics.Process.CancelOutputRead%2A>。  
  
> [!NOTE]
>  处理异步输出的应用程序应调用<xref:System.Diagnostics.Process.WaitForExit%2A>方法，以确保已刷新输出缓冲区。  
  
   
  
## Examples  
 下面的示例演示如何执行异步读取的操作上的重定向<xref:System.Diagnostics.Process.StandardOutput%2A>串`ipconfig`命令。  
  
 该示例创建一个事件委托，它用于`OutputHandler`事件处理程序并将其与<xref:System.Diagnostics.Process.OutputDataReceived>事件。 事件处理程序接收来自的重定向的文本行<xref:System.Diagnostics.Process.StandardOutput%2A>流，格式化文本，并将其保存在该示例的控制台窗口中更高版本所示的输出字符串。  
  
 [!code-cpp[Process_AsyncStreams#4](~/samples/snippets/cpp/VS_Snippets_CLR/process_asyncstreams/CPP/datareceivedevent.cpp#4)]
 [!code-csharp[Process_AsyncStreams#4](~/samples/snippets/csharp/VS_Snippets_CLR/process_asyncstreams/CS/datareceivedevent.cs#4)]
 [!code-vb[Process_AsyncStreams#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_asyncstreams/VB/datareceivedevent.vb#4)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">对于直接调用方的完全信任。 此成员不能由部分信任的代码使用。</permission>
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" />
        <altmember cref="P:System.Diagnostics.Process.StandardOutput" />
        <altmember cref="M:System.Diagnostics.Process.BeginOutputReadLine" />
        <altmember cref="M:System.Diagnostics.Process.CancelOutputRead" />
        <altmember cref="T:System.Diagnostics.DataReceivedEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="PagedMemorySize">
      <MemberSignature Language="C#" Value="public int PagedMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 PagedMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PagedMemorySize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PagedMemorySize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int PagedMemorySize { int get(); };" />
      <MemberSignature Language="F#" Value="member this.PagedMemorySize : int" Usage="System.Diagnostics.Process.PagedMemorySize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The number of bytes that are paged.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use PagedMemorySize64")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.PagedMemorySize64 instead.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPagedMemorySize")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取为关联的进程分配的分页内存量（以字节为单位）。</summary>
        <value>由可写入到虚拟内存分页文件的关联进程分配的内存量(以字节为单位)。</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.PlatformNotSupportedException">该平台是 Windows 98 或 Windows Millennium Edition (Windows Me)，不支持此属性。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">对于直接调用方的完全信任。 此成员不能由部分信任的代码使用。</permission>
        <altmember cref="P:System.Diagnostics.Process.PagedMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="PagedMemorySize64">
      <MemberSignature Language="C#" Value="public long PagedMemorySize64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 PagedMemorySize64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PagedMemorySize64" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PagedMemorySize64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long PagedMemorySize64 { long get(); };" />
      <MemberSignature Language="F#" Value="member this.PagedMemorySize64 : int64" Usage="System.Diagnostics.Process.PagedMemorySize64" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The number of bytes that are paged.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPagedMemorySize")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取为关联的进程分配的分页内存量（以字节为单位）。</summary>
        <value>在虚拟内存分页文件中为关联进程分配的内存量(以字节为单位)。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 返回此属性的值表示进程，以字节为单位使用的虚拟内存分页文件中的内存的当前的大小。 操作系统使用物理内存中一起使用的虚拟内存分页文件来管理每个进程的虚拟地址空间。 可分页内存不使用时，它可以被传输到磁盘上的虚拟内存分页文件。 若要获取由操作系统使用为该进程的内存大小，请使用<xref:System.Diagnostics.Process.PagedSystemMemorySize64%2A>属性。  
  
 此属性可以用于监视具有 32 位处理器或 64 位处理器的计算机上的内存使用率。 属性值等于**页文件字节**进程的性能计数器。  
  
   
  
## Examples  
 下面的代码示例启动记事本应用程序的一个实例然后检索并显示关联的进程的各种属性。 该示例检测时在进程退出，并显示其退出代码和峰值内存统计信息。  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">该平台是 Windows 98 或 Windows Millennium Edition (Windows Me)，不支持此属性。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">对于直接调用方的完全信任。 此成员不能由部分信任的代码使用。</permission>
        <altmember cref="P:System.Diagnostics.Process.PeakPagedMemorySize64" />
        <altmember cref="P:System.Diagnostics.Process.PagedSystemMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="PagedSystemMemorySize">
      <MemberSignature Language="C#" Value="public int PagedSystemMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 PagedSystemMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PagedSystemMemorySize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PagedSystemMemorySize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int PagedSystemMemorySize { int get(); };" />
      <MemberSignature Language="F#" Value="member this.PagedSystemMemorySize : int" Usage="System.Diagnostics.Process.PagedSystemMemorySize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of paged system memory in bytes.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use PagedSystemMemorySize64")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.PagedSystemMemorySize64 instead.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPagedSystemMemorySize")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取为关联进程分配的可分页系统内存量（以字节为单位）。</summary>
        <value>系统已为可写入到虚拟内存页面文件的关联进程分配的内存量(以字节为单位)。</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.PlatformNotSupportedException">该平台是 Windows 98 或 Windows Millennium Edition (Windows Me)，不支持此属性。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">对于直接调用方的完全信任。 此成员不能由部分信任的代码使用。</permission>
        <altmember cref="P:System.Diagnostics.Process.PagedSystemMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="PagedSystemMemorySize64">
      <MemberSignature Language="C#" Value="public long PagedSystemMemorySize64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 PagedSystemMemorySize64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PagedSystemMemorySize64" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PagedSystemMemorySize64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long PagedSystemMemorySize64 { long get(); };" />
      <MemberSignature Language="F#" Value="member this.PagedSystemMemorySize64 : int64" Usage="System.Diagnostics.Process.PagedSystemMemorySize64" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of paged system memory in bytes.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPagedSystemMemorySize")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取为关联进程分配的可分页系统内存量（以字节为单位）。</summary>
        <value>为可写入虚拟内存分页文件的关联内存分配的系统内存量(以字节为单位)。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此属性的值返回的值表示使用的过程中，以字节为单位的可分页系统内存的当前大小。 系统内存是由操作系统使用的物理内存，并且分为分页和非分页池。 可分页内存不使用时，它可以被传输到磁盘上的虚拟内存分页文件。 若要获取由进程使用的应用程序内存的大小，请使用<xref:System.Diagnostics.Process.PagedMemorySize64%2A>属性。  
  
 此属性可以用于监视具有 32 位处理器或 64 位处理器的计算机上的内存使用率。 属性值等于**池分页字节数**进程的性能计数器。  
  
   
  
## Examples  
 下面的代码示例启动记事本应用程序的实例。 该示例然后检索并显示关联的进程的各种属性。 该示例检测时在进程退出，并显示其退出代码和峰值内存统计信息。  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">该平台是 Windows 98 或 Windows Millennium Edition (Windows Me)，不支持此属性。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">对于直接调用方的完全信任。 此成员不能由部分信任的代码使用。</permission>
        <altmember cref="P:System.Diagnostics.Process.PagedSystemMemorySize64" />
        <altmember cref="P:System.Diagnostics.Process.NonpagedSystemMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="PeakPagedMemorySize">
      <MemberSignature Language="C#" Value="public int PeakPagedMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 PeakPagedMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PeakPagedMemorySize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PeakPagedMemorySize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int PeakPagedMemorySize { int get(); };" />
      <MemberSignature Language="F#" Value="member this.PeakPagedMemorySize : int" Usage="System.Diagnostics.Process.PeakPagedMemorySize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The maximum amount of paged memory used by this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use PeakPagedMemorySize64")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.PeakPagedMemorySize64 instead.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPeakPagedMemorySize")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取关联的进程使用的虚拟内存分页文件中的最大内存量（以字节为单位）。</summary>
        <value>由可写入到虚拟内存分页文件的关联进程分配的最大内存量(以字节为单位)。</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.PlatformNotSupportedException">该平台是 Windows 98 或 Windows Millennium Edition (Windows Me)，不支持此属性。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">对于直接调用方的完全信任。 此成员不能由部分信任的代码使用。</permission>
        <altmember cref="P:System.Diagnostics.Process.PeakPagedMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="PeakPagedMemorySize64">
      <MemberSignature Language="C#" Value="public long PeakPagedMemorySize64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 PeakPagedMemorySize64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PeakPagedMemorySize64" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PeakPagedMemorySize64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long PeakPagedMemorySize64 { long get(); };" />
      <MemberSignature Language="F#" Value="member this.PeakPagedMemorySize64 : int64" Usage="System.Diagnostics.Process.PeakPagedMemorySize64" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The maximum amount of paged memory used by this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPeakPagedMemorySize")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取关联的进程使用的虚拟内存分页文件中的最大内存量（以字节为单位）。</summary>
        <value>从启动关联的进程以来在为虚拟内存分页文件中关联进程分配的最大内存量(以字节为单位)。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此属性的值返回的值表示自启动，以字节为单位，该进程所使用的虚拟内存分页文件中的内存的最大大小。 操作系统使用物理内存中一起使用的虚拟内存分页文件来管理每个进程的虚拟地址空间。 可分页内存不使用时，它可以被传输到磁盘上的虚拟内存分页文件。  
  
 此属性可以用于监视具有 32 位处理器或 64 位处理器的计算机上的内存使用率。 属性值等于**页面文件字节峰值**进程的性能计数器。  
  
   
  
## Examples  
 下面的代码示例启动记事本应用程序的实例。 该示例然后检索并显示关联的进程的各种属性。 该示例检测时在进程退出，并显示其退出代码和峰值内存统计信息。  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">该平台是 Windows 98 或 Windows Millennium Edition (Windows Me)，不支持此属性。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">对于直接调用方的完全信任。 此成员不能由部分信任的代码使用。</permission>
        <altmember cref="P:System.Diagnostics.Process.PagedMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="PeakVirtualMemorySize">
      <MemberSignature Language="C#" Value="public int PeakVirtualMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 PeakVirtualMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PeakVirtualMemorySize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PeakVirtualMemorySize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int PeakVirtualMemorySize { int get(); };" />
      <MemberSignature Language="F#" Value="member this.PeakVirtualMemorySize : int" Usage="System.Diagnostics.Process.PeakVirtualMemorySize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The maximum amount of virtual memory used by this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use PeakVirtualMemorySize64")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.PeakVirtualMemorySize64 instead.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPeakVirtualMemorySize")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取关联进程使用的最大虚拟内存量（以字节为单位）。</summary>
        <value>关联进程请求的最大虚拟内存量(以字节为单位)。</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.PlatformNotSupportedException">该平台是 Windows 98 或 Windows Millennium Edition (Windows Me)，不支持此属性。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">对于直接调用方的完全信任。 此成员不能由部分信任的代码使用。</permission>
        <altmember cref="P:System.Diagnostics.Process.PeakVirtualMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="PeakVirtualMemorySize64">
      <MemberSignature Language="C#" Value="public long PeakVirtualMemorySize64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 PeakVirtualMemorySize64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PeakVirtualMemorySize64" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PeakVirtualMemorySize64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long PeakVirtualMemorySize64 { long get(); };" />
      <MemberSignature Language="F#" Value="member this.PeakVirtualMemorySize64 : int64" Usage="System.Diagnostics.Process.PeakVirtualMemorySize64" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The maximum amount of virtual memory used by this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPeakVirtualMemorySize")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取关联进程使用的最大虚拟内存量（以字节为单位）。</summary>
        <value>从关联进程启动以来为关联进程分配的最大虚拟内存量(以字节为单位)。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 返回此属性的值表示自启动，以字节为单位，该进程所使用的虚拟内存的最大大小。 操作系统将映射到页加载在物理内存或页面存储在磁盘上的虚拟内存分页文件中每个进程的虚拟地址空间。  
  
 此属性可以用于监视具有 32 位处理器或 64 位处理器的计算机上的内存使用率。 属性值等于**峰值虚拟字节**进程的性能计数器。  
  
   
  
## Examples  
 下面的代码示例启动记事本应用程序的实例。 该示例然后检索并显示关联的进程的各种属性。 该示例检测时在进程退出，并显示其退出代码和峰值内存统计信息。  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">该平台是 Windows 98 或 Windows Millennium Edition (Windows Me)，不支持此属性。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">对于直接调用方的完全信任。 此成员不能由部分信任的代码使用。</permission>
        <altmember cref="P:System.Diagnostics.Process.VirtualMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="PeakWorkingSet">
      <MemberSignature Language="C#" Value="public int PeakWorkingSet { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 PeakWorkingSet" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PeakWorkingSet" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PeakWorkingSet As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int PeakWorkingSet { int get(); };" />
      <MemberSignature Language="F#" Value="member this.PeakWorkingSet : int" Usage="System.Diagnostics.Process.PeakWorkingSet" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The maximum amount of system memory used by this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use PeakWorkingSet64")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.PeakWorkingSet64 instead.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPeakWorkingSet")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取关联进程的峰值工作集大小（以字节为单位）。</summary>
        <value>关联进程一次所需的最大物理内存量（以字节为单位）。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 进程工作集是物理 RAM 内存中当前可见到进程的内存页的集合。 这些页面是常驻内存，可用于应用程序使用而不会触发页面错误。  
  
 工作集包括数据共享和专用数据。 共享的数据包括包含该进程执行，包括进程模块和系统库的所有说明的页。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">该平台是 Windows 98 或 Windows Millennium Edition (Windows Me)，不支持此属性。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">对于直接调用方的完全信任。 此成员不能由部分信任的代码使用。</permission>
        <altmember cref="P:System.Diagnostics.Process.WorkingSet64" />
        <altmember cref="P:System.Diagnostics.Process.MinWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.MaxWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.PeakWorkingSet64" />
      </Docs>
    </Member>
    <Member MemberName="PeakWorkingSet64">
      <MemberSignature Language="C#" Value="public long PeakWorkingSet64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 PeakWorkingSet64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PeakWorkingSet64" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PeakWorkingSet64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long PeakWorkingSet64 { long get(); };" />
      <MemberSignature Language="F#" Value="member this.PeakWorkingSet64 : int64" Usage="System.Diagnostics.Process.PeakWorkingSet64" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The maximum amount of system memory used by this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPeakWorkingSet")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取关联进程使用的最大物理内存量（以字节为单位）。</summary>
        <value>从启动关联进程以来为关联进程分配的最大物理内存量(以字节为单位)。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 返回此属性的值表示工作集内存使用的进程，因为它启动，以字节为单位的最大的大小。 进程工作集是物理 RAM 内存中当前可见到进程的内存页的集合。 这些页面是常驻内存，可用于应用程序使用而不会触发页面错误。  
  
 工作集包括数据共享和专用数据。 共享的数据包括包含该进程执行，包括进程模块和系统库中的说明的所有说明的页。  
  
 此属性可以用于监视具有 32 位处理器或 64 位处理器的计算机上的内存使用率。 属性值等于**工作集峰值**进程的性能计数器。  
  
   
  
## Examples  
 下面的代码示例启动记事本应用程序的实例。 该示例然后检索并显示关联的进程的各种属性。 该示例检测时在进程退出，并显示其退出代码和峰值内存统计信息。  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">该平台是 Windows 98 或 Windows Millennium Edition (Windows Me)，不支持此属性。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">对于直接调用方的完全信任。 此成员不能由部分信任的代码使用。</permission>
        <altmember cref="P:System.Diagnostics.Process.WorkingSet64" />
        <altmember cref="P:System.Diagnostics.Process.MinWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.MaxWorkingSet" />
      </Docs>
    </Member>
    <Member MemberName="PriorityBoostEnabled">
      <MemberSignature Language="C#" Value="public bool PriorityBoostEnabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool PriorityBoostEnabled" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PriorityBoostEnabled" />
      <MemberSignature Language="VB.NET" Value="Public Property PriorityBoostEnabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool PriorityBoostEnabled { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.PriorityBoostEnabled : bool with get, set" Usage="System.Diagnostics.Process.PriorityBoostEnabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Process will be of higher priority while it is actively used.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPriorityBoostEnabled")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值指示主窗口拥有焦点时是否应由操作系统暂时提升关联进程优先级。</summary>
        <value>如果进程离开等待状态时应动态提升进程优先级别，则为 <see langword="true" />；否则为 <see langword="false" />。 默认值为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 一个线程对其的优先级类具有一个动态优先级枚举值的进程中的运行时 (<xref:System.Diagnostics.ProcessPriorityClass.Normal>， <xref:System.Diagnostics.ProcessPriorityClass.High>，或<xref:System.Diagnostics.ProcessPriorityClass.RealTime>)，系统暂时提升线程的优先级时它会从等待状态。 此操作可防止其他进程中断当前线程的处理。 <xref:System.Diagnostics.Process.PriorityBoostEnabled%2A>设置会影响现有的所有线程和进程随后创建的任何线程。 若要还原正常行为，请设置<xref:System.Diagnostics.Process.PriorityBoostEnabled%2A>属性设置为`false`。  
  
> [!NOTE]
>  将优先级提升过高会耗尽基本操作系统和网络功能，从而导致问题的其他操作系统任务的资源。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">未能从关联的进程资源检索到优先级提升信息。</exception>
        <exception cref="T:System.PlatformNotSupportedException">该平台是 Windows 98 或 Windows Millennium Edition (Windows Me)，不支持此属性。  
  
或 
进程标识符或进程句柄为零。 （进程尚未启动。）</exception>
        <exception cref="T:System.NotSupportedException">你正试图访问在远程计算机上运行的进程的 <see cref="P:System.Diagnostics.Process.PriorityBoostEnabled" /> 属性。 此属性仅可用于本地计算机上运行的进程。</exception>
        <exception cref="T:System.InvalidOperationException">进程 <see cref="P:System.Diagnostics.Process.Id" /> 不可用。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">对于直接调用方的完全信任。 此成员不能由部分信任的代码使用。</permission>
        <altmember cref="P:System.Diagnostics.Process.PriorityClass" />
        <altmember cref="P:System.Diagnostics.Process.BasePriority" />
      </Docs>
    </Member>
    <Member MemberName="PriorityClass">
      <MemberSignature Language="C#" Value="public System.Diagnostics.ProcessPriorityClass PriorityClass { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Diagnostics.ProcessPriorityClass PriorityClass" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PriorityClass" />
      <MemberSignature Language="VB.NET" Value="Public Property PriorityClass As ProcessPriorityClass" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Diagnostics::ProcessPriorityClass PriorityClass { System::Diagnostics::ProcessPriorityClass get(); void set(System::Diagnostics::ProcessPriorityClass value); };" />
      <MemberSignature Language="F#" Value="member this.PriorityClass : System.Diagnostics.ProcessPriorityClass with get, set" Usage="System.Diagnostics.Process.PriorityClass" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The priority that the threads in the process run relative to.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPriorityClass")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.ProcessPriorityClass</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置关联进程的总体优先级类别。</summary>
        <value>关联进程的优先级类别，可从该类别计算进程的 <see cref="P:System.Diagnostics.Process.BasePriority" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 进程优先级类包含一系列的线程优先级别。 具有不同优先级的进程中运行的线程运行相对于进程的优先级类。 Win32 了七个基本优先级级别，每个类使用四个优先级类。 这些进程优先级类中捕获<xref:System.Diagnostics.ProcessPriorityClass>枚举，该对话框可以将进程优先级设置为<xref:System.Diagnostics.ProcessPriorityClass.Idle>， <xref:System.Diagnostics.ProcessPriorityClass.Normal>， <xref:System.Diagnostics.ProcessPriorityClass.High>， <xref:System.Diagnostics.ProcessPriorityClass.AboveNormal>， <xref:System.Diagnostics.ProcessPriorityClass.BelowNormal>，或<xref:System.Diagnostics.ProcessPriorityClass.RealTime>。 基于的时间的进程需要会得到领先于其他人访问处理器时，可以由操作系统更改运行时间或其他提升，基本优先级别。 此外，可以设置<xref:System.Diagnostics.Process.PriorityBoostEnabled%2A>以暂时提升脱离等待状态的线程优先级别。 该过程返回到等待状态时，会重置优先级。  
  
 <xref:System.Diagnostics.Process.BasePriority%2A>属性，可以查看分配给进程的启动优先级。 但是，因为它是只读的不能使用<xref:System.Diagnostics.Process.BasePriority%2A>属性来设置进程的优先级。 若要更改的优先级，使用<xref:System.Diagnostics.Process.PriorityClass%2A>属性，用于获取或设置进程的总体优先级类别。  
  
 不能使用系统监视器查看的优先级类。 下表显示了之间的关系<xref:System.Diagnostics.Process.BasePriority%2A>和<xref:System.Diagnostics.Process.PriorityClass%2A>值。  
  
|BasePriority|PriorityClass|  
|------------------|-------------------|  
|4|<xref:System.Diagnostics.ProcessPriorityClass.Idle>|  
|8|<xref:System.Diagnostics.ProcessPriorityClass.Normal>|  
|13|<xref:System.Diagnostics.ProcessPriorityClass.High>|  
|24|<xref:System.Diagnostics.ProcessPriorityClass.RealTime>|  
  
   
  
## Examples  
 以下示例启动记事本的实例。 该示例然后检索并显示关联的进程的各种属性。 该示例检测时在进程退出，并显示该进程的退出代码。  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">无法从关联的进程资源中设置或检索进程优先级信息。  
  
或 
进程标识符或进程句柄为零。 （进程尚未启动。）</exception>
        <exception cref="T:System.NotSupportedException">你正试图访问在远程计算机上运行的进程的 <see cref="P:System.Diagnostics.Process.PriorityClass" /> 属性。 此属性仅可用于本地计算机上运行的进程。</exception>
        <exception cref="T:System.InvalidOperationException">进程 <see cref="P:System.Diagnostics.Process.Id" /> 不可用。</exception>
        <exception cref="T:System.PlatformNotSupportedException">当使用 Windows 98 或 Windows Millennium Edition (Windows Me) 时，已将 <see cref="P:System.Diagnostics.Process.PriorityClass" /> 设置为 <see langword="AboveNormal" /> 或 <see langword="BelowNormal" />。 这些平台不支持优先级类的这些值。</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">无法设置优先级类，因为它不使用有效的值，如 <see cref="T:System.Diagnostics.ProcessPriorityClass" /> 枚举中所定义。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">对于直接调用方的完全信任。 此成员不能由部分信任的代码使用。</permission>
        <altmember cref="P:System.Diagnostics.Process.BasePriority" />
        <altmember cref="P:System.Diagnostics.Process.PriorityBoostEnabled" />
      </Docs>
    </Member>
    <Member MemberName="PrivateMemorySize">
      <MemberSignature Language="C#" Value="public int PrivateMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 PrivateMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PrivateMemorySize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PrivateMemorySize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int PrivateMemorySize { int get(); };" />
      <MemberSignature Language="F#" Value="member this.PrivateMemorySize : int" Usage="System.Diagnostics.Process.PrivateMemorySize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of memory exclusively used by this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use PrivateMemorySize64")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.PrivateMemorySize64 instead.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPrivateMemorySize")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取为关联的进程分配的专用内存量（以字节为单位）。</summary>
        <value>由关联的进程分配的、不能与其他进程共享的字节数。</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.PlatformNotSupportedException">该平台是 Windows 98 或 Windows Millennium Edition (Windows Me)，不支持此属性。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">对于直接调用方的完全信任。 此成员不能由部分信任的代码使用。</permission>
        <altmember cref="P:System.Diagnostics.Process.PrivateMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="PrivateMemorySize64">
      <MemberSignature Language="C#" Value="public long PrivateMemorySize64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 PrivateMemorySize64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PrivateMemorySize64" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PrivateMemorySize64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long PrivateMemorySize64 { long get(); };" />
      <MemberSignature Language="F#" Value="member this.PrivateMemorySize64 : int64" Usage="System.Diagnostics.Process.PrivateMemorySize64" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of memory exclusively used by this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPrivateMemorySize")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取为关联的进程分配的专用内存量（以字节为单位）。</summary>
        <value>为关联进程分配的不能与其他进程共享的内存量(以字节为单位)。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 返回此属性的值表示使用的过程中，以字节为单位，不能与其他进程共享内存的当前大小。  
  
 此属性可以用于监视具有 32 位处理器或 64 位处理器的计算机上的内存使用率。 属性值等于**专用字节数**进程的性能计数器。  
  
   
  
## Examples  
 下面的代码示例启动记事本应用程序的实例。 该示例然后检索并显示关联的进程的各种属性。 该示例检测时在进程退出，并显示其退出代码和峰值内存统计信息。  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">该平台是 Windows 98 或 Windows Millennium Edition (Windows Me)，不支持此属性。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">对于直接调用方的完全信任。 此成员不能由部分信任的代码使用。</permission>
      </Docs>
    </Member>
    <Member MemberName="PrivilegedProcessorTime">
      <MemberSignature Language="C#" Value="public TimeSpan PrivilegedProcessorTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan PrivilegedProcessorTime" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PrivilegedProcessorTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PrivilegedProcessorTime As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TimeSpan PrivilegedProcessorTime { TimeSpan get(); };" />
      <MemberSignature Language="F#" Value="member this.PrivilegedProcessorTime : TimeSpan" Usage="System.Diagnostics.Process.PrivilegedProcessorTime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of CPU time the process spent inside the operating system core.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPrivilegedProcessorTime")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取此进程的特权处理器时间。</summary>
        <value>
          <see cref="T:System.TimeSpan" />，它指示进程在操作系统内核中运行代码所用的时间。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 以下示例启动记事本的实例。 该示例然后检索并显示关联的进程的各种属性。 该示例检测时在进程退出，并显示该进程的退出代码。  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">该平台是 Windows 98 或 Windows Millennium Edition (Windows Me)，不支持此属性。</exception>
        <exception cref="T:System.NotSupportedException">你正试图访问在远程计算机上运行的进程的 <see cref="P:System.Diagnostics.Process.PrivilegedProcessorTime" /> 属性。 此属性仅可用于本地计算机上运行的进程。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">对于直接调用方的完全信任。 此成员不能由部分信任的代码使用。</permission>
        <altmember cref="P:System.Diagnostics.Process.UserProcessorTime" />
        <altmember cref="P:System.Diagnostics.Process.PrivilegedProcessorTime" />
      </Docs>
    </Member>
    <Member MemberName="ProcessName">
      <MemberSignature Language="C#" Value="public string ProcessName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ProcessName" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.ProcessName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ProcessName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ProcessName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ProcessName : string" Usage="System.Diagnostics.Process.ProcessName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The name of this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessProcessName")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取该进程的名称。</summary>
        <value>系统用以向用户标识该进程的名称。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.ProcessName%2A>属性包含一个可执行文件名称，如 Outlook、 不包含扩展名为.exe 或路径。 它可帮助获取和操作与相同的可执行文件相关联的所有进程。  
  
> [!NOTE]
>  上[!INCLUDE[Win2kFamily](~/includes/win2kfamily-md.md)]操作系统中，<xref:System.Diagnostics.Process.ProcessName%2A>属性可能会截断至 15 个字符，如果无法获取进程模块信息。  
  
 您可以调用<xref:System.Diagnostics.Process.GetProcessesByName%2A>，并向其传递一个可执行文件名称，若要检索包含指定的计算机上每个正在运行的实例的数组。 可以使用此数组，例如，若要关闭的情况下可执行文件的所有正在运行的实例。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">进程没有标识符，或者没有与 <see cref="T:System.Diagnostics.Process" /> 关联的进程。  
  
或 
关联进程已退出。</exception>
        <exception cref="T:System.PlatformNotSupportedException">该平台是 Windows 98 或 Windows Millennium Edition (Windows Me)；将 <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> 设置为 <see langword="false" />，以在 Windows 98 和 Windows Me 上访问此属性。</exception>
        <exception cref="T:System.NotSupportedException">进程不在此计算机上。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">对于直接调用方的完全信任。 此成员不能由部分信任的代码使用。</permission>
        <altmember cref="M:System.Diagnostics.Process.GetProcessesByName(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="ProcessorAffinity">
      <MemberSignature Language="C#" Value="public IntPtr ProcessorAffinity { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int ProcessorAffinity" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.ProcessorAffinity" />
      <MemberSignature Language="VB.NET" Value="Public Property ProcessorAffinity As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr ProcessorAffinity { IntPtr get(); void set(IntPtr value); };" />
      <MemberSignature Language="F#" Value="member this.ProcessorAffinity : nativeint with get, set" Usage="System.Diagnostics.Process.ProcessorAffinity" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Allowed processor that can be used by this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessProcessorAffinity")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一些处理器，此进程中的线程可以按计划在这些处理器上运行。</summary>
        <value>位掩码，表示关联进程内的线程可以在其上运行的处理器。 默认值取决于计算机上的处理器数。 默认值为 2 <sup>n</sup> -1，其中 n 是处理器数。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在 Windows 2000 及更高版本，在进程中的线程可以迁移处理器间重新加载处理器缓存每个迁移。 在高系统负荷下指定哪些处理器运行特定的线程可以提高性能，从而重新加载处理器缓存的次数。 处理器和线程之间的关联称为处理器关联。  
  
 每个处理器都表示为一位。 位 0 是一个处理器，位 1 是处理器两个，等等。 如果有点设为值 1，则为线程分配选择相应的处理器。 当您将设置<xref:System.Diagnostics.Process.ProcessorAffinity%2A>值为零，操作系统线程的关联的计划算法集。 当<xref:System.Diagnostics.Process.ProcessorAffinity%2A>值设置为任何非零值，该值被解释为指定可供选择的处理器的位掩码。  
  
 下表显示了一系列<xref:System.Diagnostics.Process.ProcessorAffinity%2A>具有八个处理器的系统值。  
  
|位掩码|二进制值|符合条件的处理器|  
|-------------|------------------|-------------------------|  
|0x0001|00000000 00000001|1|  
|0x0003|00000000 00000011|1 和 2|  
|0x0007|00000000 00000111|1、 2 和 3|  
|0x0009|00000000 00001001|1 和 4|  
|0x007F|00000000 01111111|1、 2、 3、 4、 5、 6 和 7|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">未能从关联的进程资源设置或检索 <see cref="P:System.Diagnostics.Process.ProcessorAffinity" /> 信息。  
  
或 
进程标识符或进程句柄为零。 （进程尚未启动。）</exception>
        <exception cref="T:System.NotSupportedException">你正试图访问在远程计算机上运行的进程的 <see cref="P:System.Diagnostics.Process.ProcessorAffinity" /> 属性。 此属性仅可用于本地计算机上运行的进程。</exception>
        <exception cref="T:System.InvalidOperationException">进程 <see cref="P:System.Diagnostics.Process.Id" /> 不可用。  
  
或 
该进程已退出。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">对于直接调用方的完全信任。 此成员不能由部分信任的代码使用。</permission>
      </Docs>
    </Member>
    <Member MemberName="Refresh">
      <MemberSignature Language="C#" Value="public void Refresh ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Refresh() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Refresh" />
      <MemberSignature Language="VB.NET" Value="Public Sub Refresh ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Refresh();" />
      <MemberSignature Language="F#" Value="member this.Refresh : unit -&gt; unit" Usage="process.Refresh " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>放弃已缓存到进程组件的关联仅存的任何相关信息。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 之后<xref:System.Diagnostics.Process.Refresh%2A>调用时，第一个请求的每个属性信息导致进程组件从关联进程中获取新值。  
  
 当<xref:System.Diagnostics.Process>组件是关联的进程资源，属性值的<xref:System.Diagnostics.Process>立即填充根据关联的进程的状态。 如果随后更改关联的进程有关的信息，这些更改将不会反映在<xref:System.Diagnostics.Process>组件的缓存的值。 <xref:System.Diagnostics.Process>组件是在它们所关联的时间的进程资源的快照。 若要查看为关联进程的当前值，调用<xref:System.Diagnostics.Process.Refresh%2A>方法。  
  
   
  
## Examples  
 以下示例启动记事本的实例。 然后在 10 秒的最长 2 第二个时间间隔检索关联的进程的物理内存使用情况。 该示例检测是否在进程退出之前已在过去 10 秒。 如果它仍在运行在 10 秒后，该示例将关闭该过程。  
  
 [!code-cpp[process_refresh#1](~/samples/snippets/cpp/VS_Snippets_CLR/process_refresh/CPP/process_refresh.cpp#1)]
 [!code-csharp[process_refresh#1](~/samples/snippets/csharp/VS_Snippets_CLR/process_refresh/CS/process_refresh.cs#1)]
 [!code-vb[process_refresh#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_refresh/VB/process_refresh.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">对于直接调用方的完全信任。 此成员不能由部分信任的代码使用。</permission>
      </Docs>
    </Member>
    <Member MemberName="Responding">
      <MemberSignature Language="C#" Value="public bool Responding { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Responding" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.Responding" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Responding As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Responding { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.Responding : bool" Usage="System.Diagnostics.Process.Responding" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Is this process responsive.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessResponding")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取指示进程的用户界面当前是否响应的值。</summary>
        <value>如果关联进程的用户界面当前响应系统，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果某个进程拥有的用户界面，<xref:System.Diagnostics.Process.Responding%2A>属性联系来确定进程是否正在响应用户输入的用户界面。 如果接口不会立即响应<xref:System.Diagnostics.Process.Responding%2A>属性返回`false`。 使用此属性确定关联的进程的界面已停止响应。  
  
 如果进程不具有<xref:System.Diagnostics.Process.MainWindowHandle%2A>，此属性返回`true`。  
  
   
  
## Examples  
 以下示例启动记事本的实例。 该示例然后检索并显示关联的进程的各种属性。 该示例检测时在进程退出，并显示该进程的退出代码。  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">该平台是 Windows 98 或 Windows Millennium Edition (Windows Me)；将 <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> 设置为 <see langword="false" />，以在 Windows 98 和 Windows Me 上访问此属性。</exception>
        <exception cref="T:System.InvalidOperationException">没有与此 <see cref="T:System.Diagnostics.Process" /> 对象关联的进程。</exception>
        <exception cref="T:System.NotSupportedException">你正试图访问在远程计算机上运行的进程的 <see cref="P:System.Diagnostics.Process.Responding" /> 属性。 此属性仅可用于本地计算机上运行的进程。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">对于直接调用方的完全信任。 此成员不能由部分信任的代码使用。</permission>
        <altmember cref="P:System.Diagnostics.Process.MainWindowHandle" />
      </Docs>
    </Member>
    <Member MemberName="SafeHandle">
      <MemberSignature Language="C#" Value="public Microsoft.Win32.SafeHandles.SafeProcessHandle SafeHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.Win32.SafeHandles.SafeProcessHandle SafeHandle" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.SafeHandle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SafeHandle As SafeProcessHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Microsoft::Win32::SafeHandles::SafeProcessHandle ^ SafeHandle { Microsoft::Win32::SafeHandles::SafeProcessHandle ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SafeHandle : Microsoft.Win32.SafeHandles.SafeProcessHandle" Usage="System.Diagnostics.Process.SafeHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.SafeHandles.SafeProcessHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取此进程的本机句柄。</summary>
        <value>此进程的本机句柄。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 句柄才可用，如果调用组件启动进程。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SessionId">
      <MemberSignature Language="C#" Value="public int SessionId { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 SessionId" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.SessionId" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SessionId As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int SessionId { int get(); };" />
      <MemberSignature Language="F#" Value="member this.SessionId : int" Usage="System.Diagnostics.Process.SessionId" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The session ID for this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoNotSupported("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessSessionId")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取关联进程的终端服务会话标识符。</summary>
        <value>关联进程的终端服务会话标识符。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.SessionId%2A>属性标识在其中应用程序当前正在运行的会话。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NullReferenceException">没有与此进程关联的会话。</exception>
        <exception cref="T:System.InvalidOperationException">没有与此会话标识符关联的进程。  
  
或 
关联的进程不在此计算机上。</exception>
        <exception cref="T:System.PlatformNotSupportedException">Windows 98 不支持 <see cref="P:System.Diagnostics.Process.SessionId" /> 属性。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">对于直接调用方的完全信任。 此成员不能由部分信任的代码使用。</permission>
      </Docs>
    </Member>
    <Member MemberName="StandardError">
      <MemberSignature Language="C#" Value="public System.IO.StreamReader StandardError { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.StreamReader StandardError" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.StandardError" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property StandardError As StreamReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::StreamReader ^ StandardError { System::IO::StreamReader ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.StandardError : System.IO.StreamReader" Usage="System.Diagnostics.Process.StandardError" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Standard error stream of the process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessStandardError")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.StreamReader</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取用于读取应用程序错误输出的流。</summary>
        <value>可用于读取应用程序的标准错误流的 <see cref="T:System.IO.StreamReader" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当<xref:System.Diagnostics.Process>将文本写入到它的标准错误流，通常在控制台上显示文本。 通过将重定向<xref:System.Diagnostics.Process.StandardError%2A>流，可以操作或取消进程的错误输出。 例如，可以筛选文本、 格式设置不同，或将输出写入到控制台和一个指定的日志文件。  
  
> [!NOTE]
>  若要使用<xref:System.Diagnostics.Process.StandardError%2A>，则必须设置<xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=nameWithType>到`false`，并且你必须将<xref:System.Diagnostics.ProcessStartInfo.RedirectStandardError%2A?displayProperty=nameWithType>到`true`。 否则，从读取<xref:System.Diagnostics.Process.StandardError%2A>流将引发异常。  
  
 重定向<xref:System.Diagnostics.Process.StandardError%2A>可以读取流，以同步方式还是以异步方式。 等方法<xref:System.IO.StreamReader.Read%2A>， <xref:System.IO.StreamReader.ReadLine%2A>，和<xref:System.IO.StreamReader.ReadToEnd%2A>执行同步读取的操作的错误输出流的过程。 这些同步读取操作未完成之前关联<xref:System.Diagnostics.Process>写入其<xref:System.Diagnostics.Process.StandardError%2A>流式处理，或关闭流。  
  
 与此相反，<xref:System.Diagnostics.Process.BeginErrorReadLine%2A>开始异步读取操作上<xref:System.Diagnostics.Process.StandardError%2A>流。 此方法启用流输出一个指定的事件处理程序，并立即返回给调用方，可以执行其他工作，而流输出定向到事件处理程序。  
  
 同步读取操作引入了读取从调用方之间的依赖关系<xref:System.Diagnostics.Process.StandardError%2A>流和子进程的写入该流。 这些依赖关系可能会导致死锁情况。 当调用方读取子进程的重定向流时，它所依赖的子。 调用方子写入流或关闭流之前等待读取操作。 子进程在编写时数据不足，无法填充其重定向的流，它是依赖于父。 子进程先等待下一个写入操作的父项从完整的流中读取或关闭流。 当调用方和子进程互相等待完成操作，并且都可以继续时，将产生死锁情况。 可以通过评估的调用方和子进程之间的依赖关系来避免死锁。  
  
 以下 C# 代码，例如，显示了如何从重定向流中读取并等待子进程退出。  
  
```csharp  
// Start the child process.  
 Process p = new Process();  
 // Redirect the error stream of the child process.  
 p.StartInfo.UseShellExecute = false;  
 p.StartInfo.RedirectStandardError = true;  
 p.StartInfo.FileName = "Write500Lines.exe";  
 p.Start();  
 // Do not wait for the child process to exit before  
 // reading to the end of its redirected error stream.  
 // p.WaitForExit();  
 // Read the error stream first and then wait.  
 string error = p.StandardError.ReadToEnd();  
 p.WaitForExit();  
```  
  
 代码示例调用，因此可避免死锁条件`p.StandardError.ReadToEnd`之前`p.WaitForExit`。 如果父进程的调用可能导致死锁条件`p.WaitForExit`之前`p.StandardError.ReadToEnd`和子进程会写入足够多的文本以填充重定向的流。 父进程将无限期地等待子进程退出。 子进程将无限期地等待父读取完整<xref:System.Diagnostics.Process.StandardError%2A>流。  
  
 从标准输出和标准错误流中读取的所有文本时出现类似问题。 以下 C# 代码，例如，执行这两个流的读取的操作。  
  
```csharp  
// Do not perform a synchronous read to the end of both   
// redirected streams.  
// string output = p.StandardOutput.ReadToEnd();  
// string error = p.StandardError.ReadToEnd();  
// p.WaitForExit();  
// Use asynchronous read operations on at least one of the streams.  
p.BeginOutputReadLine();  
string error = p.StandardError.ReadToEnd();  
p.WaitForExit();  
```  
  
 代码示例执行异步读取操作上，因此可避免死锁条件<xref:System.Diagnostics.Process.StandardOutput%2A>流。 如果父进程调用产生死锁情况`p.StandardOutput.ReadToEnd`跟`p.StandardError.ReadToEnd`和子进程会写入足够多的文本以填充其错误流。 父进程将无限期地等待子进程关闭其<xref:System.Diagnostics.Process.StandardOutput%2A>流。 子进程将无限期地等待父读取完整<xref:System.Diagnostics.Process.StandardError%2A>流。  
  
 异步读取的操作可用于避免这些依赖关系和其潜在的死锁。 或者，您可以通过创建两个线程和读取单独的线程上的每个流的输出来避免死锁情况。  
  
> [!NOTE]
>  不能混合异步和同步读取的操作重定向流上。 一次的重定向的流<xref:System.Diagnostics.Process>打开在异步或同步模式下，所有进一步读取该流上的执行操作必须处于相同模式。 例如，不遵循<xref:System.Diagnostics.Process.BeginErrorReadLine%2A>通过调用<xref:System.IO.StreamReader.ReadLine%2A>上<xref:System.Diagnostics.Process.StandardError%2A>流，反之亦然。 但是，您可以读取在不同模式下的两个不同的流。 例如，可以调用<xref:System.Diagnostics.Process.BeginOutputReadLine%2A>，然后调用<xref:System.IO.StreamReader.ReadLine%2A>为<xref:System.Diagnostics.Process.StandardError%2A>流。  
  
   
  
## Examples  
 下面的示例使用`net use`命令和用户提供的参数映射的网络资源。 然后，读取的 net 命令标准错误流，并将其写入控制台。  
  
 [!code-cpp[Process_StandardError#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process_StandardError/CPP/source.cpp#1)]
 [!code-csharp[Process_StandardError#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process_StandardError/CS/source.cs#1)]
 [!code-vb[Process_StandardError#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process_StandardError/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">尚未对 <see cref="P:System.Diagnostics.Process.StandardError" /> 流进行重定向定义；请确保 <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" /> 设置为 <see langword="true" /> 且 <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> 设置为 <see langword="false" />。  
  
\- 或 - 
已打开 <see cref="P:System.Diagnostics.Process.StandardError" /> 流，以使用 <see cref="M:System.Diagnostics.Process.BeginErrorReadLine" /> 进行异步读取操作。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">对于直接调用方的完全信任。 此成员不能由部分信任的代码使用。</permission>
        <altmember cref="P:System.Diagnostics.Process.StandardInput" />
        <altmember cref="P:System.Diagnostics.Process.StandardOutput" />
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" />
      </Docs>
    </Member>
    <Member MemberName="StandardInput">
      <MemberSignature Language="C#" Value="public System.IO.StreamWriter StandardInput { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.StreamWriter StandardInput" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.StandardInput" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property StandardInput As StreamWriter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::StreamWriter ^ StandardInput { System::IO::StreamWriter ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.StandardInput : System.IO.StreamWriter" Usage="System.Diagnostics.Process.StandardInput" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Standard input stream of the process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessStandardInput")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.StreamWriter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取用于写入应用程序输入的流。</summary>
        <value>
          <see cref="T:System.IO.StreamWriter" />，可用于写入应用程序的标准输入流。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 一个<xref:System.Diagnostics.Process>可以读取从其标准输入流，通常是键盘输入的文本。 通过将重定向<xref:System.Diagnostics.Process.StandardInput%2A>流，你可以以编程方式指定的输入。 例如，而不是使用键盘输入，可以提供从指定文件的内容的文本或从另一个应用程序的输出。  
  
> [!NOTE]
>  若要使用<xref:System.Diagnostics.Process.StandardInput%2A>，则必须设置<xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=nameWithType>到`false`，并且你必须将<xref:System.Diagnostics.ProcessStartInfo.RedirectStandardInput%2A?displayProperty=nameWithType>到`true`。 否则，写入<xref:System.Diagnostics.Process.StandardInput%2A>流将引发异常。  
  
   
  
## Examples  
 下面的示例演示如何重定向<xref:System.Diagnostics.Process.StandardInput%2A>进程的流。 该示例启动`sort`命令和重定向的输入。 然后，它会提示用户输入文本，并将其传递到`sort`进程通过重定向<xref:System.Diagnostics.Process.StandardInput%2A>流。 `sort`结果显示到控制台上的用户。  
  
 [!code-cpp[Process_StandardInput#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process_StandardInput/CPP/process_standardinput.cpp#1)]
 [!code-csharp[Process_StandardInput#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process_StandardInput/CS/process_standardinput.cs#1)]
 [!code-vb[Process_StandardInput#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process_StandardInput/VB/process_standardinput.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:System.Diagnostics.Process.StandardInput" /> 流尚未定义，因为 <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardInput" /> 设置为 <see langword="false" />。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">对于直接调用方的完全信任。 此成员不能由部分信任的代码使用。</permission>
        <altmember cref="P:System.Diagnostics.Process.StandardOutput" />
        <altmember cref="P:System.Diagnostics.Process.StandardError" />
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardInput" />
      </Docs>
    </Member>
    <Member MemberName="StandardOutput">
      <MemberSignature Language="C#" Value="public System.IO.StreamReader StandardOutput { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.StreamReader StandardOutput" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.StandardOutput" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property StandardOutput As StreamReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::StreamReader ^ StandardOutput { System::IO::StreamReader ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.StandardOutput : System.IO.StreamReader" Usage="System.Diagnostics.Process.StandardOutput" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Standard output stream of the process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessStandardOutput")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.StreamReader</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取用于读取应用程序文本输出的流。</summary>
        <value>
          <see cref="T:System.IO.StreamReader" />，可用于读取应用程序的标准输出流。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当<xref:System.Diagnostics.Process>将文本写入其标准流，通常在控制台上显示文本。 通过将重定向<xref:System.Diagnostics.Process.StandardOutput%2A>流，可以操作或取消进程的输出。 例如，可以筛选文本、 格式设置不同，或将输出写入到控制台和一个指定的日志文件。  
  
> [!NOTE]
>  若要使用<xref:System.Diagnostics.Process.StandardOutput%2A>，则必须设置<xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=nameWithType>到`false`，并且你必须将<xref:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput%2A?displayProperty=nameWithType>到`true`。 否则，从读取<xref:System.Diagnostics.Process.StandardOutput%2A>流将引发异常。  
  
 重定向<xref:System.Diagnostics.Process.StandardOutput%2A>可以读取流，以同步方式还是以异步方式。 等方法<xref:System.IO.StreamReader.Read%2A>， <xref:System.IO.StreamReader.ReadLine%2A>，和<xref:System.IO.StreamReader.ReadToEnd%2A>执行同步读取的操作过程的输出流。 这些同步读取操作未完成之前关联<xref:System.Diagnostics.Process>写入其<xref:System.Diagnostics.Process.StandardOutput%2A>流式处理，或关闭流。  
  
 与此相反，<xref:System.Diagnostics.Process.BeginOutputReadLine%2A>开始异步读取操作上<xref:System.Diagnostics.Process.StandardOutput%2A>流。 此方法启用流输出一个指定的事件处理程序，并立即返回给调用方，可以执行其他工作，而流输出定向到事件处理程序。  
  
 同步读取操作引入了读取从调用方之间的依赖关系<xref:System.Diagnostics.Process.StandardOutput%2A>流和子进程的写入该流。 这些依赖关系可能会导致死锁情况。 当调用方读取子进程的重定向流时，它所依赖的子。 调用方子写入流或关闭流之前等待读取操作。 子进程在编写时数据不足，无法填充其重定向的流，它是依赖于父。 子进程先等待下一个写入操作的父项从完整的流中读取或关闭流。 当调用方和子进程互相等待完成操作，并且都可以继续时，将产生死锁情况。 可以通过评估的调用方和子进程之间的依赖关系来避免死锁。  
  
 以下 C# 代码，例如，显示了如何从重定向流中读取并等待子进程退出。  
  
```csharp  
Process p = new Process();  
p.StartInfo.UseShellExecute = false;  
p.StartInfo.RedirectStandardOutput = true;  
p.StartInfo.FileName = "Write500Lines.exe";  
p.Start();  
  
// To avoid deadlocks, always read the output stream first and then wait.  
string output = p.StandardOutput.ReadToEnd();  
p.WaitForExit();  
```  
  
 代码示例调用，因此可避免死锁条件`p.StandardOutput.ReadToEnd`之前`p.WaitForExit`。 如果父进程的调用可能导致死锁条件`p.WaitForExit`之前`p.StandardOutput.ReadToEnd`和子进程会写入足够多的文本以填充重定向的流。 父进程将无限期地等待子进程退出。 子进程将无限期地等待父读取完整<xref:System.Diagnostics.Process.StandardOutput%2A>流。  
  
 从标准输出和标准错误流中读取的所有文本时出现类似问题。 以下 C# 代码，例如，执行这两个流的读取的操作。  
  
```csharp  
// To avoid deadlocks, use asynchronous read operations on at least one of the streams.  
// Do not perform a synchronous read to the end of both redirected streams.  
p.BeginOutputReadLine();  
string error = p.StandardError.ReadToEnd();  
p.WaitForExit();  
```  
  
 代码示例执行异步读取操作上，因此可避免死锁条件<xref:System.Diagnostics.Process.StandardOutput%2A>流。 如果父进程调用产生死锁情况`p.StandardOutput.ReadToEnd`跟`p.StandardError.ReadToEnd`和子进程会写入足够多的文本以填充其错误流。 父进程将无限期地等待子进程关闭其<xref:System.Diagnostics.Process.StandardOutput%2A>流。 子进程将无限期地等待父读取完整<xref:System.Diagnostics.Process.StandardError%2A>流。  
  
 异步读取的操作可用于避免这些依赖关系和其潜在的死锁。 或者，您可以通过创建两个线程和读取单独的线程上的每个流的输出来避免死锁情况。  
  
> [!NOTE]
>  不能混合异步和同步读取的操作重定向流上。 一次的重定向的流<xref:System.Diagnostics.Process>打开在异步或同步模式下，所有进一步读取该流上的执行操作必须处于相同模式。 例如，不遵循<xref:System.Diagnostics.Process.BeginOutputReadLine%2A>通过调用<xref:System.IO.StreamReader.ReadLine%2A>上<xref:System.Diagnostics.Process.StandardOutput%2A>流，反之亦然。 但是，您可以读取在不同模式下的两个不同的流。 例如，可以调用<xref:System.Diagnostics.Process.BeginOutputReadLine%2A>，然后调用<xref:System.IO.StreamReader.ReadLine%2A>为<xref:System.Diagnostics.Process.StandardError%2A>流。  
  
   
  
## Examples  
 下面的示例运行 ipconfig.exe 命令，并将其标准输出重定向到该示例的控制台窗口。  
  
 [!code-cpp[Process_StandardOutput#2](~/samples/snippets/cpp/VS_Snippets_CLR/Process_StandardOutput/CPP/process_standardoutput.cpp#2)]
 [!code-csharp[Process_StandardOutput#2](~/samples/snippets/csharp/VS_Snippets_CLR/Process_StandardOutput/CS/process_standardoutput.cs#2)]
 [!code-vb[Process_StandardOutput#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process_StandardOutput/VB/process_standardoutput.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">尚未对 <see cref="P:System.Diagnostics.Process.StandardOutput" /> 流进行重定向定义；请确保 <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" /> 设置为 <see langword="true" /> 且 <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> 设置为 <see langword="false" />。  
  
\- 或 - 
已打开 <see cref="P:System.Diagnostics.Process.StandardOutput" /> 流，以使用 <see cref="M:System.Diagnostics.Process.BeginOutputReadLine" /> 进行异步读取操作。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">对于直接调用方的完全信任。 此成员不能由部分信任的代码使用。</permission>
        <altmember cref="P:System.Diagnostics.Process.StandardInput" />
        <altmember cref="P:System.Diagnostics.Process.StandardError" />
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Start">
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>启动进程资源并将其与 <see cref="T:System.Diagnostics.Process" /> 组件关联。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public bool Start ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Start() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Start" />
      <MemberSignature Language="VB.NET" Value="Public Function Start () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Start();" />
      <MemberSignature Language="F#" Value="member this.Start : unit -&gt; bool" Usage="process.Start " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>启动(或重用)此 <see cref="T:System.Diagnostics.Process" /> 组件的 <see cref="P:System.Diagnostics.Process.StartInfo" /> 属性指定的进程资源，并将其与该组件关联。</summary>
        <returns>如果启动了进程资源，则为 <see langword="true" />；如果没有启动新的进程资源(例如，如果重用了现有进程)，则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用此重载来启动进程资源并将其与当前<xref:System.Diagnostics.Process>组件。 返回值`true`指示已启动新的进程资源。 如果指定的进程资源，则<xref:System.Diagnostics.ProcessStartInfo.FileName%2A>的成员<xref:System.Diagnostics.Process.StartInfo%2A>属性已在计算机上运行，没有额外的进程启动资源。 相反，正在运行的进程资源中将重复使用和`false`返回。  
  
 可以通过指定最初从中安装应用程序的位置 （例如，Web 地址） 来启动 ClickOnce 应用程序。 不通过指定其安装的位置在硬盘驱动器上启动 ClickOnce 应用程序。  
  
> [!NOTE]
>  如果使用 Visual Studio 中，此重载<xref:System.Diagnostics.Process.Start%2A>方法是插入到代码后您拖动一个<xref:System.Diagnostics.Process>组件拖动到设计器上。 使用`Properties`窗口中展开`StartInfo`类别和写入到适当的值`FileName`属性。 所做的更改将显示在窗体的`InitializeComponent`过程。  
  
 此重载<xref:System.Diagnostics.Process.Start%2A>不是`static`方法。 必须调用它的实例从<xref:System.Diagnostics.Process>类。 然后再调用<xref:System.Diagnostics.Process.Start%2A>，您必须首先指定<xref:System.Diagnostics.Process.StartInfo%2A>此属性信息<xref:System.Diagnostics.Process>实例，因为该信息用于确定要启动的进程资源。  
  
 其他重载<xref:System.Diagnostics.Process.Start%2A>方法是`static`成员。 不需要创建的实例<xref:System.Diagnostics.Process>组件之前调用该方法的重载。 相反，您可以调用<xref:System.Diagnostics.Process.Start%2A>有关<xref:System.Diagnostics.Process>类本身，和一个新<xref:System.Diagnostics.Process>如果该进程已启动，则创建组件。 或者，`null`返回如果重用了进程。 进程资源会自动与新关联<xref:System.Diagnostics.Process>组件返回的<xref:System.Diagnostics.Process.Start%2A>方法。  
  
 <xref:System.Diagnostics.Process.StartInfo%2A>成员可用于复制的功能`Run`对话框中的 Windows`Start`菜单。 可以通过设置适当的值启动的可在命令行中键入任何内容<xref:System.Diagnostics.Process.StartInfo%2A>属性。 唯一<xref:System.Diagnostics.Process.StartInfo%2A>必须设置的属性是<xref:System.Diagnostics.ProcessStartInfo.FileName%2A>属性。 <xref:System.Diagnostics.ProcessStartInfo.FileName%2A>属性不具有为可执行文件。 它可以是任何文件类型扩展名已经为其与系统安装的应用程序相关联。 例如，<xref:System.Diagnostics.ProcessStartInfo.FileName%2A>属性可以具有.txt 扩展名，如果已与编辑器 （如记事本） 关联的文本文件或如果您已经将利用文字处理工具，如 Microsoft Word 的文本文件，它可以具有扩展名为.doc。  
  
 在命令行中，可以指定要执行某些类型的文件的操作。 例如，可以打印文档或编辑文本文件。 指定使用这些操作<xref:System.Diagnostics.ProcessStartInfo.Verb%2A>的成员<xref:System.Diagnostics.Process.StartInfo%2A>属性。 对于其他类型的文件，您可以指定命令行参数启动中的文件时`Run`对话框。 例如，作为参数传递一个 URL，如果指定为在浏览器<xref:System.Diagnostics.ProcessStartInfo.FileName%2A>。 可以在中指定这些参数<xref:System.Diagnostics.Process.StartInfo%2A>属性的<xref:System.Diagnostics.ProcessStartInfo.Arguments%2A>成员。  
  
 如果必须声明在系统中用引号引起来的路径变量，必须完全限定路径的启动在该位置中找到任何进程时。 否则，系统将不到的路径。 例如，如果`c:\mypath`不是在你的路径，并将其使用引号引起来添加： `path = %path%;"c:\mypath"`，必须完全符合中的任何进程`c:\mypath`时启动它。  
  
> [!NOTE]
>  在 ASP.NET 工作进程在 Web 服务器上的上下文中执行 ASP.NET Web 页和服务器控件的代码。  如果使用<xref:System.Diagnostics.Process.Start%2A>方法中的 ASP.NET 网页或服务器控件，在具有受限权限的 Web 服务器上执行新进程。 该过程不会启动与客户端的浏览器，在同一上下文中并不能在用户桌面上的访问。  
  
 您每次使用<xref:System.Diagnostics.Process.Start%2A>若要启动进程时，可能需要将其关闭，否则您可能会丢失系统资源。 使用关闭进程<xref:System.Diagnostics.Process.CloseMainWindow%2A>或<xref:System.Diagnostics.Process.Kill%2A>。 你可以检查是否已关闭进程通过其<xref:System.Diagnostics.Process.HasExited%2A>属性。  
  
 有关托管线程中的单元状态的说明就有必要。 当<xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A>是`true`上进程组件<xref:System.Diagnostics.Process.StartInfo%2A>属性，请确保已在应用程序上设置线程模型，通过将属性设置`[STAThread]`上`main()`方法。 否则，托管的线程可以采用`unknown`状态或放入`MTA`状态，后者与冲突<xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A>正在`true`。 某些方法要求使用的单元状态，不是`unknown`。 如果未显式设置状态，当应用程序遇到这种方法，则默认为`MTA`，并完成设置后，就无法更改的单元状态。 但是，`MTA`操作系统外壳管理的线程时引发异常。  
  
   
  
## Examples  
 下面的示例使用的实例<xref:System.Diagnostics.Process>类，以启动的进程。  
  
 [!code-cpp[Process.Start_instance#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.Start_instance/CPP/processstart.cpp#1)]
 [!code-csharp[Process.Start_instance#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.Start_instance/CS/processstart.cs#1)]
 [!code-vb[Process.Start_instance#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.Start_instance/VB/processstart.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">在 <see cref="T:System.Diagnostics.Process" /> 组件的 <see cref="P:System.Diagnostics.Process.StartInfo" /> 中未指定任何文件名。
或者，当 <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardInput" />、<see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" /> 或 <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" /> 为 <see langword="true" /> 时，<see cref="P:System.Diagnostics.Process.StartInfo" /> 属性的 <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> 成员为 <see langword="true" />。</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">打开关联的文件时出错。</exception>
        <exception cref="T:System.ObjectDisposedException">已释放此进程对象。</exception>
        <exception cref="T:System.PlatformNotSupportedException">不支持 shell 的操作系统（如，仅适用于.NET Core 的 Nano Server）不支持此方法。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">对于直接调用方的完全信任。 此成员不能由部分信任的代码使用。</permission>
        <altmember cref="P:System.Diagnostics.Process.StartInfo" />
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.FileName" />
        <altmember cref="T:System.Diagnostics.ProcessStartInfo" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Kill" />
      </Docs>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process Start (System.Diagnostics.ProcessStartInfo startInfo);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process Start(class System.Diagnostics.ProcessStartInfo startInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Start(System.Diagnostics.ProcessStartInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Start (startInfo As ProcessStartInfo) As Process" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Diagnostics::Process ^ Start(System::Diagnostics::ProcessStartInfo ^ startInfo);" />
      <MemberSignature Language="F#" Value="static member Start : System.Diagnostics.ProcessStartInfo -&gt; System.Diagnostics.Process" Usage="System.Diagnostics.Process.Start startInfo" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startInfo" Type="System.Diagnostics.ProcessStartInfo" />
      </Parameters>
      <Docs>
        <param name="startInfo">
          <see cref="T:System.Diagnostics.ProcessStartInfo" />，包含用于启动进程的信息(包括文件名和任何命令行参数)。</param>
        <summary>启动由包含进程启动信息(例如，要启动的进程的文件名)的参数指定的进程资源，并将该资源与新的 <see cref="T:System.Diagnostics.Process" /> 组件关联。</summary>
        <returns>与进程资源关联的新 <see cref="T:System.Diagnostics.Process" />，如果未启动进程资源，则为 <see langword="null" />。 请注意，随着同一进程已在运行的实例启动的新进程将独立于其他进程。 此外，启动可能返回一个 <see cref="P:System.Diagnostics.Process.HasExited" /> 属性已设置为 <see langword="true" /> 的非 null 进程。 在这种情况下，启动的进程可能已激活现有实例自身，然后退出。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用此重载通过指定启动进程资源<xref:System.Diagnostics.ProcessStartInfo>实例。 该重载将资源与新<xref:System.Diagnostics.Process>对象。  
  
> [!NOTE]
>  如果要启动的可执行文件的地址为 URL，则不会启动进程和`null`返回。  
  
 此重载使您无需首先创建一个新启动的进程<xref:System.Diagnostics.Process>实例。 使用此重载具有<xref:System.Diagnostics.ProcessStartInfo>参数是创建一个新的显式步骤的替代方法<xref:System.Diagnostics.Process>实例，设置其<xref:System.Diagnostics.Process.StartInfo%2A>的属性以及调用<xref:System.Diagnostics.Process.Start%2A>为<xref:System.Diagnostics.Process>实例。  
  
 使用<xref:System.Diagnostics.ProcessStartInfo>实例用作参数，可以调用<xref:System.Diagnostics.Process.Start%2A>充分控制内容传递到启动过程的调用。 如果需要传递只能出现文件名或文件名称和参数，不需要创建一个新<xref:System.Diagnostics.ProcessStartInfo>实例，尽管这是一个选项。 唯一<xref:System.Diagnostics.Process.StartInfo%2A?displayProperty=nameWithType>必须设置的属性是<xref:System.Diagnostics.ProcessStartInfo.FileName%2A>属性。 <xref:System.Diagnostics.ProcessStartInfo.FileName%2A>属性不需要表示一个可执行文件。 它可以是任何文件类型扩展名已经为其与系统安装的应用程序相关联。 例如，<xref:System.Diagnostics.ProcessStartInfo.FileName%2A>属性可以具有.txt 扩展名，如果已与编辑器 （如记事本） 关联的文本文件或如果您已经将利用文字处理工具，如 Microsoft Word 的文本文件，它可以具有扩展名为.doc。  
  
 可以通过指定最初从中安装应用程序的位置 （例如，Web 地址） 来启动 ClickOnce 应用程序。 不通过指定其安装的位置在硬盘驱动器上启动 ClickOnce 应用程序。  
  
 如果<xref:System.Diagnostics.ProcessStartInfo.UserName%2A?displayProperty=nameWithType>并<xref:System.Diagnostics.ProcessStartInfo.Password%2A?displayProperty=nameWithType>的属性<xref:System.Diagnostics.Process.StartInfo%2A>实例的设置，非托管`CreateProcessWithLogonW`调用函数时，该过程启动新窗口即使<xref:System.Diagnostics.ProcessStartInfo.CreateNoWindow%2A?displayProperty=nameWithType>属性值是`true`或<xref:System.Diagnostics.ProcessStartInfo.WindowStyle%2A?displayProperty=nameWithType>属性值是<xref:System.Diagnostics.ProcessWindowStyle.Hidden?displayProperty=nameWithType>。 如果<xref:System.Diagnostics.ProcessStartInfo.Domain%2A?displayProperty=nameWithType>属性是`null`，则<xref:System.Diagnostics.ProcessStartInfo.UserName%2A?displayProperty=nameWithType>属性必须以 UPN 格式*用户*@*DNS_domain_name*。   
  
 与其他重载，重载<xref:System.Diagnostics.Process.Start%2A>没有任何参数不是`static`成员。 使用该重载在您创建了<xref:System.Diagnostics.Process>实例，指定的开始信息 （包括文件名），并且想要启动进程资源并将其与现有<xref:System.Diagnostics.Process>实例。 使用之一`static`重载时想要创建一个新<xref:System.Diagnostics.Process>组件而不是为现有组件启动进程。 此重载和不具有任何参数的重载允许您通过使用指定的进程资源的开始信息<xref:System.Diagnostics.ProcessStartInfo>实例。  
  
 如果必须声明在系统中用引号引起来的路径变量，必须完全限定路径的启动在该位置中找到任何进程时。 否则，系统将不到的路径。 例如，如果`c:\mypath`不是在你的路径，并将其使用引号引起来添加： `path = %path%;"c:\mypath"`，必须完全符合中的任何进程`c:\mypath`时启动它。  
  
> [!NOTE]
>  在 ASP.NET 工作进程在 Web 服务器上的上下文中执行 ASP.NET Web 页和服务器控件的代码。  如果使用<xref:System.Diagnostics.Process.Start%2A>方法中的 ASP.NET 网页或服务器控件，在具有受限权限的 Web 服务器上执行新进程。 该过程不会启动与客户端的浏览器，在同一上下文中并不能在用户桌面上的访问。  
  
 您每次使用<xref:System.Diagnostics.Process.Start%2A>若要启动进程时，可能需要将其关闭，否则您可能会丢失系统资源。 使用关闭进程<xref:System.Diagnostics.Process.CloseMainWindow%2A>或<xref:System.Diagnostics.Process.Kill%2A>。 你可以检查是否已关闭进程通过其<xref:System.Diagnostics.Process.HasExited%2A>属性。  
  
 有关托管线程中的单元状态的说明就有必要。 当<xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A>是`true`上`startInfo`参数，请确保已在应用程序上设置线程模型，通过将属性设置`[STAThread]`上`main()`方法。 否则，托管的线程可以采用`unknown`状态或放入`MTA`状态，后者与冲突<xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A>正在`true`。 某些方法要求使用的单元状态，不是`unknown`。 如果未显式设置状态，当应用程序遇到这种方法，则默认为`MTA`，并完成设置后，就无法更改的单元状态。 但是，`MTA`操作系统外壳管理的线程时引发异常。  
  
   
  
## Examples  
 下面的示例首先生成的 Internet Explorer 实例，并在浏览器中显示的收藏夹文件夹的内容。 然后，启动 Internet Explorer 的一些其他实例，并显示某些特定页面或站点。 最后，它与在浏览到特定站点时最小化窗口启动 Internet Explorer。  
  
 有关此方法的其他用法的其他示例，请参阅的各个属性<xref:System.Diagnostics.ProcessStartInfo>类。  
  
 [!code-cpp[Process.Start_static#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.Start_static/CPP/processstartstatic.cpp#1)]
 [!code-csharp[Process.Start_static#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.Start_static/CS/processstartstatic.cs#1)]
 [!code-vb[Process.Start_static#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.Start_static/VB/processstartstatic.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">在 <paramref name="startInfo" /> 参数的 <see cref="P:System.Diagnostics.ProcessStartInfo.FileName" /> 属性中未指定任何文件名。  
  
或 
<paramref name="startInfo" /> 参数的 <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> 属性值为 <see langword="true" />，且 <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardInput" />、<see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" /> 或 <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" /> 属性的值也为 <see langword="true" />。  
  
或 
<paramref name="startInfo" /> 参数的 <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> 属性值为 <see langword="true" />，且 <see cref="P:System.Diagnostics.ProcessStartInfo.UserName" /> 属性值不为 <see langword="null" /> 或空，或者 <see cref="P:System.Diagnostics.ProcessStartInfo.Password" /> 属性值不为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="startInfo" /> 参数为 <see langword="null" />。</exception>
        <exception cref="T:System.ObjectDisposedException">已释放此进程对象。</exception>
        <exception cref="T:System.IO.FileNotFoundException">在 <paramref name="startInfo" /> 参数的 <see cref="P:System.Diagnostics.ProcessStartInfo.FileName" /> 属性中指定的文件未找到。</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">打开关联的文件时出错。  
  
或 
参数的长度与该进程的完整路径的长度的总和超过了 2080。 与此异常关联的错误消息可能为以下消息之一：“传递到系统调用的数据区域太小。” 或“拒绝访问。”</exception>
        <exception cref="T:System.PlatformNotSupportedException">不支持 shell 的操作系统（如，仅适用于.NET Core 的 Nano Server）不支持此方法。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">对于直接调用方的完全信任。 此成员不能由部分信任的代码使用。</permission>
        <altmember cref="P:System.Diagnostics.Process.StartInfo" />
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.FileName" />
        <altmember cref="T:System.Diagnostics.ProcessStartInfo" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Kill" />
      </Docs>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process Start (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process Start(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Start(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Start (fileName As String) As Process" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Diagnostics::Process ^ Start(System::String ^ fileName);" />
      <MemberSignature Language="F#" Value="static member Start : string -&gt; System.Diagnostics.Process" Usage="System.Diagnostics.Process.Start fileName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">要在进程中运行的文档或应用程序文件的名称。</param>
        <summary>通过指定文档或应用程序文件的名称来启动进程资源，并将资源与新的 <see cref="T:System.Diagnostics.Process" /> 组件关联。</summary>
        <returns>与进程资源关联的新 <see cref="T:System.Diagnostics.Process" />，如果未启动进程资源，则为 <see langword="null" />。 请注意，随着同一进程已在运行的实例启动的新进程将独立于其他进程。 此外，启动可能返回一个 <see cref="P:System.Diagnostics.Process.HasExited" /> 属性已设置为 <see langword="true" /> 的非 null 进程。 在这种情况下，启动的进程可能已激活现有实例自身，然后退出。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用此重载通过指定其文件名中启动进程资源。 该重载将资源与新<xref:System.Diagnostics.Process>对象。  
  
> [!NOTE]
>  如果要启动的可执行文件的地址为 URL，则不会启动进程和`null`返回。  
  
 此重载使您无需首先创建一个新启动的进程<xref:System.Diagnostics.Process>实例。 此重载是创建一个新的显式步骤的替代方法<xref:System.Diagnostics.Process>实例，设置<xref:System.Diagnostics.ProcessStartInfo.FileName%2A>的成员<xref:System.Diagnostics.Process.StartInfo%2A>属性，然后调用<xref:System.Diagnostics.Process.Start%2A>为<xref:System.Diagnostics.Process>实例。  
  
 可以通过设置启动 ClickOnce 应用程序`fileName`最初从中安装应用程序的位置 （例如，Web 地址） 的参数。 不通过指定其安装的位置在硬盘驱动器上启动 ClickOnce 应用程序。  
  
 通过指定其文件名中启动进程会类似于键入中的信息`Run`对话框中的 Windows`Start`菜单。 因此，文件名称不需要表示一个可执行文件。 它可以是为其扩展已关联与应用程序在系统上安装任何文件类型。 有关示例的文件的名称可以具有.txt 扩展名，如果已与编辑器 （如记事本） 关联的文本文件或如果您已经将利用文字处理工具，如 Microsoft Word 的文本文件，它可以具有.doc。 同样，在相同的方式`Run`对话框中可以接受带或不带扩展名为.exe 的可执行文件名称，扩展名为.exe 中是可选`fileName`参数。 例如，可以设置`fileName`"Notepad.exe"或"记事本"的参数。  
  
 此重载不允许的进程的命令行参数。 如果您需要指定一个或多个进程的命令行参数，使用<xref:System.Diagnostics.Process.Start%28System.Diagnostics.ProcessStartInfo%29?displayProperty=nameWithType>或<xref:System.Diagnostics.Process.Start%28System.String%2CSystem.String%29?displayProperty=nameWithType>重载。  
  
 与其他重载，重载<xref:System.Diagnostics.Process.Start%2A>没有任何参数不是`static`成员。 使用该重载在您创建了<xref:System.Diagnostics.Process>实例，指定的开始信息 （包括文件名），并且想要启动进程资源并将其与现有<xref:System.Diagnostics.Process>实例。 使用之一`static`重载时想要创建一个新<xref:System.Diagnostics.Process>组件而不是为现有组件启动进程。 此重载和不具有任何参数的重载，可以指定要启动的进程资源的文件名。  
  
 如果必须声明在系统中用引号引起来的路径变量，必须完全限定路径的启动在该位置中找到任何进程时。 否则，系统将不到的路径。 例如，如果`c:\mypath`不是在你的路径，并将其使用引号引起来添加： `path = %path%;"c:\mypath"`，必须完全符合中的任何进程`c:\mypath`时启动它。  
  
> [!NOTE]
>  在 ASP.NET 工作进程在 Web 服务器上的上下文中执行 ASP.NET Web 页和服务器控件的代码。  如果使用<xref:System.Diagnostics.Process.Start%2A>方法中的 ASP.NET 网页或服务器控件，在具有受限权限的 Web 服务器上执行新进程。 该过程不会启动与客户端的浏览器，在同一上下文中并不能在用户桌面上的访问。  
  
 您每次使用<xref:System.Diagnostics.Process.Start%2A>若要启动进程时，可能需要将其关闭，否则您可能会丢失系统资源。 使用关闭进程<xref:System.Diagnostics.Process.CloseMainWindow%2A>或<xref:System.Diagnostics.Process.Kill%2A>。 你可以检查是否已关闭进程通过其<xref:System.Diagnostics.Process.HasExited%2A>属性。  
  
 有关托管线程中的单元状态的说明就有必要。 当<xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A>是`true`上进程组件<xref:System.Diagnostics.Process.StartInfo%2A>属性，请确保已在应用程序上设置线程模型，通过将属性设置`[STAThread]`上`main()`方法。 否则，托管的线程可以采用`unknown`状态或放入`MTA`状态，后者与冲突<xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A>正在`true`。 某些方法要求使用的单元状态，不是`unknown`。 如果未显式设置状态，当应用程序遇到这种方法，则默认为`MTA`，并完成设置后，就无法更改的单元状态。 但是，`MTA`操作系统外壳管理的线程时引发异常。  
  
   
  
## Examples  
 下面的示例首先生成的 Internet Explorer 实例，并在浏览器中显示的收藏夹文件夹的内容。 然后，启动 Internet Explorer 的一些其他实例，并显示某些特定页面或站点。 最后，它与在浏览到特定站点时最小化窗口启动 Internet Explorer。  
  
 [!code-cpp[Process.Start_static#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.Start_static/CPP/processstartstatic.cpp#1)]
 [!code-csharp[Process.Start_static#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.Start_static/CS/processstartstatic.cs#1)]
 [!code-vb[Process.Start_static#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.Start_static/VB/processstartstatic.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">打开关联的文件时出错。</exception>
        <exception cref="T:System.ObjectDisposedException">已释放此进程对象。</exception>
        <exception cref="T:System.IO.FileNotFoundException">PATH 环境变量具有一个包含引号的字符串。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">对于直接调用方的完全信任。 此成员不能由部分信任的代码使用。</permission>
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.FileName" />
        <altmember cref="P:System.Diagnostics.Process.StartInfo" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Kill" />
      </Docs>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process Start (string fileName, string arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process Start(string fileName, string arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Start(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Start (fileName As String, arguments As String) As Process" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Diagnostics::Process ^ Start(System::String ^ fileName, System::String ^ arguments);" />
      <MemberSignature Language="F#" Value="static member Start : string * string -&gt; System.Diagnostics.Process" Usage="System.Diagnostics.Process.Start (fileName, arguments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="arguments" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">要在进程中运行的应用程序文件的名称。</param>
        <param name="arguments">启动该进程时传递的命令行参数。</param>
        <summary>通过指定应用程序的名称和一组命令行参数来启动一个进程资源，并将该资源与新的 <see cref="T:System.Diagnostics.Process" /> 组件相关联。</summary>
        <returns>与进程资源关联的新 <see cref="T:System.Diagnostics.Process" />，如果未启动进程资源，则为 <see langword="null" />。 请注意，随着同一进程已在运行的实例启动的新进程将独立于其他进程。 此外，启动可能返回一个 <see cref="P:System.Diagnostics.Process.HasExited" /> 属性已设置为 <see langword="true" /> 的非 null 进程。 在这种情况下，启动的进程可能已激活现有实例自身，然后退出。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用此重载通过指定其文件的名称和命令行参数启动进程资源。 该重载将资源与新<xref:System.Diagnostics.Process>对象。  
  
> [!NOTE]
>  如果要启动的可执行文件的地址为 URL，则不会启动进程和`null`返回。  
  
 此重载使您无需首先创建一个新启动的进程<xref:System.Diagnostics.Process>实例。 此重载是创建一个新的显式步骤的替代方法<xref:System.Diagnostics.Process>实例，设置<xref:System.Diagnostics.ProcessStartInfo.FileName%2A>并<xref:System.Diagnostics.ProcessStartInfo.Arguments%2A>的成员<xref:System.Diagnostics.Process.StartInfo%2A>属性，并调用<xref:System.Diagnostics.Process.Start%2A>为<xref:System.Diagnostics.Process>实例。  
  
 通过指定其文件的名称和参数来启动进程会类似于输入文件的名称和中的命令行参数`Run`对话框中的 Windows`Start`菜单。 因此，文件名称不需要表示一个可执行文件。 它可以是为其扩展已关联与应用程序在系统上安装任何文件类型。 有关示例的文件的名称可以具有.txt 扩展名，如果已与编辑器 （如记事本） 关联的文本文件或如果您已经将利用文字处理工具，如 Microsoft Word 的文本文件，它可以具有.doc。 同样，在相同的方式`Run`对话框中可以接受带或不带扩展名为.exe 的可执行文件名称，扩展名为.exe 中是可选`fileName`参数。 例如，可以设置`fileName`"Notepad.exe"或"记事本"的参数。 如果`fileName`参数表示的可执行文件`arguments`参数可能表示要执行操作，如文本文件中的文件`Notepad.exe myfile.txt`。 如果`fileName`参数表示的命令 (.cmd) 文件，`arguments`参数必须包含"`/c`"或"`/k`"参数，以指定是否在命令窗口退出或完成后保持。  
  
 与其他重载，重载<xref:System.Diagnostics.Process.Start%2A>没有任何参数不是`static`成员。 使用该重载在您创建了<xref:System.Diagnostics.Process>实例，指定的开始信息 （包括文件名），并且想要启动进程资源并将其与现有<xref:System.Diagnostics.Process>实例。 使用之一`static`重载时想要创建一个新<xref:System.Diagnostics.Process>组件而不是为现有组件启动进程。 此重载和不具有任何参数的重载，可以指定要启动进程资源并传递命令行参数的文件名称。  
  
 如果必须声明在系统中用引号引起来的路径变量，必须完全限定路径的启动在该位置中找到任何进程时。 否则，系统将不到的路径。 例如，如果`c:\mypath`不是在你的路径，并将其使用引号引起来添加： `path = %path%;"c:\mypath"`，必须完全符合中的任何进程`c:\mypath`时启动它。  
  
> [!NOTE]
>  在 ASP.NET 工作进程在 Web 服务器上的上下文中执行 ASP.NET Web 页和服务器控件的代码。  如果使用<xref:System.Diagnostics.Process.Start%2A>方法中的 ASP.NET 网页或服务器控件，在具有受限权限的 Web 服务器上执行新进程。 该过程不会启动与客户端的浏览器，在同一上下文中并不能在用户桌面上的访问。  
  
 您每次使用<xref:System.Diagnostics.Process.Start%2A>若要启动进程时，可能需要将其关闭，否则您可能会丢失系统资源。 使用关闭进程<xref:System.Diagnostics.Process.CloseMainWindow%2A>或<xref:System.Diagnostics.Process.Kill%2A>。 你可以检查是否已关闭进程通过其<xref:System.Diagnostics.Process.HasExited%2A>属性...  
  
 有关托管线程中的单元状态的说明就有必要。 当<xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A>是`true`上进程组件<xref:System.Diagnostics.Process.StartInfo%2A>属性，请确保已在应用程序上设置线程模型，通过将属性设置`[STAThread]`上`main()`方法。 否则，托管的线程可以采用`unknown`状态或放入`MTA`状态，后者与冲突<xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A>正在`true`。 某些方法要求使用的单元状态，不是`unknown`。 如果未显式设置状态，当应用程序遇到这种方法，则默认为`MTA`，并完成设置后，就无法更改的单元状态。 但是，`MTA`操作系统外壳管理的线程时引发异常。  
  
   
  
## Examples  
 下面的示例首先生成的 Internet Explorer 实例，并在浏览器中显示的收藏夹文件夹的内容。 然后，启动 Internet Explorer 的一些其他实例，并显示某些特定页面或站点。 最后，它与在浏览到特定站点时最小化窗口启动 Internet Explorer。  
  
 [!code-cpp[Process.Start_static#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.Start_static/CPP/processstartstatic.cpp#1)]
 [!code-csharp[Process.Start_static#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.Start_static/CS/processstartstatic.cs#1)]
 [!code-vb[Process.Start_static#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.Start_static/VB/processstartstatic.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="fileName" /> 或 <paramref name="arguments" /> 参数为 <see langword="null" />。</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">打开关联的文件时出错。  
  
或 
参数的长度与该进程的完整路径的长度的总和超过了 2080。 与此异常关联的错误消息可能为以下消息之一：“传递到系统调用的数据区域太小。” 或“拒绝访问。”</exception>
        <exception cref="T:System.ObjectDisposedException">已释放此进程对象。</exception>
        <exception cref="T:System.IO.FileNotFoundException">PATH 环境变量具有一个包含引号的字符串。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">对于直接调用方的完全信任。 此成员不能由部分信任的代码使用。</permission>
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.FileName" />
        <altmember cref="P:System.Diagnostics.Process.StartInfo" />
        <altmember cref="T:System.Diagnostics.ProcessStartInfo" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Kill" />
      </Docs>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process Start (string fileName, string userName, System.Security.SecureString password, string domain);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process Start(string fileName, string userName, class System.Security.SecureString password, string domain) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Start(System.String,System.String,System.Security.SecureString,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Start (fileName As String, userName As String, password As SecureString, domain As String) As Process" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Diagnostics::Process ^ Start(System::String ^ fileName, System::String ^ userName, System::Security::SecureString ^ password, System::String ^ domain);" />
      <MemberSignature Language="F#" Value="static member Start : string * string * System.Security.SecureString * string -&gt; System.Diagnostics.Process" Usage="System.Diagnostics.Process.Start (fileName, userName, password, domain)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="userName" Type="System.String" />
        <Parameter Name="password" Type="System.Security.SecureString" />
        <Parameter Name="domain" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">要在进程中运行的应用程序文件的名称。</param>
        <param name="userName">启动进程时使用的用户名。</param>
        <param name="password">包含启动进程时要使用的密码的 <see cref="T:System.Security.SecureString" />。</param>
        <param name="domain">启动进程时要使用的域。</param>
        <summary>通过指定应用程序的名称、用户名、密码和域来启动一个进程资源，并将该资源与新的 <see cref="T:System.Diagnostics.Process" /> 组件关联起来。</summary>
        <returns>与进程资源关联的新 <see cref="T:System.Diagnostics.Process" />，如果未启动进程资源，则为 <see langword="null" />。 请注意，随着同一进程已在运行的实例启动的新进程将独立于其他进程。 此外，启动可能返回一个 <see cref="P:System.Diagnostics.Process.HasExited" /> 属性已设置为 <see langword="true" /> 的非 null 进程。 在这种情况下，启动的进程可能已激活现有实例自身，然后退出。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用此重载通过指定其文件的名称、 用户名、 密码和域中创建新的进程和其主线程。 然后，新进程指定的凭据 （用户、 域和密码） 的安全上下文中运行指定的可执行文件。  
  
> [!NOTE]
>  在可执行文件位于远程驱动器上，必须通过使用统一资源标识符 (URI)，未链接的驱动器号来标识网络共享。  
  
> [!NOTE]
>  如果要启动的可执行文件的地址为 URL，则不会启动进程和`null`返回。  
  
 此重载使您无需首先创建一个新启动的进程<xref:System.Diagnostics.Process>实例。 此重载是创建一个新的显式步骤的替代方法<xref:System.Diagnostics.Process>实例，设置<xref:System.Diagnostics.ProcessStartInfo.FileName%2A>， <xref:System.Diagnostics.ProcessStartInfo.UserName%2A>， <xref:System.Diagnostics.ProcessStartInfo.Password%2A>，并<xref:System.Diagnostics.ProcessStartInfo.Domain%2A>属性的<xref:System.Diagnostics.Process.StartInfo%2A>属性，并调用<xref:System.Diagnostics.Process.Start%2A>的<xref:System.Diagnostics.Process>实例。  
  
 同样，在相同的方式**运行**对话框框中，可以接受带或不带扩展名为.exe 的可执行文件名称、 扩展名为.exe 中是可选`fileName`参数。 例如，可以设置`fileName`"Notepad.exe"或"记事本"的参数。 如果`fileName`参数表示的可执行文件`arguments`参数可能表示要执行操作，如文本文件中的文件`Notepad.exe myfile.txt`。  
  
> [!NOTE]
>  文件名称必须表示可执行文件中的<xref:System.Diagnostics.Process.Start%2A>具有的重载`userName`， `password`，和`domain`参数。  
  
 您每次使用<xref:System.Diagnostics.Process.Start%2A>若要启动进程时，可能需要将其关闭，否则您可能会丢失系统资源。 使用关闭进程<xref:System.Diagnostics.Process.CloseMainWindow%2A>或<xref:System.Diagnostics.Process.Kill%2A>。 你可以检查是否已关闭进程通过其<xref:System.Diagnostics.Process.HasExited%2A>属性...  
  
   
  
## Examples  
 下面的代码示例演示如何使用此重载，以启动可执行文件，并且还演示的引发<xref:System.ComponentModel.Win32Exception>时尝试启动应用程序与非可执行文件相关联。  
  
 [!code-csharp[System.Diagnostics.Process.Start#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Diagnostics.Process.Start/CS/program.cs#1)]
 [!code-vb[System.Diagnostics.Process.Start#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Diagnostics.Process.Start/VB/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">未指定文件名。</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">打开关联的文件时出错。</exception>
        <exception cref="T:System.ObjectDisposedException">已释放此进程对象。</exception>
        <exception cref="T:System.PlatformNotSupportedException">Linux 或 macOS （仅适用于.NET Core）不支持此方法。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">对于直接调用方的完全信任。 此成员不能由部分信任的代码使用。</permission>
      </Docs>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process Start (string fileName, string arguments, string userName, System.Security.SecureString password, string domain);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process Start(string fileName, string arguments, string userName, class System.Security.SecureString password, string domain) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Start(System.String,System.String,System.String,System.Security.SecureString,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Start (fileName As String, arguments As String, userName As String, password As SecureString, domain As String) As Process" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Diagnostics::Process ^ Start(System::String ^ fileName, System::String ^ arguments, System::String ^ userName, System::Security::SecureString ^ password, System::String ^ domain);" />
      <MemberSignature Language="F#" Value="static member Start : string * string * string * System.Security.SecureString * string -&gt; System.Diagnostics.Process" Usage="System.Diagnostics.Process.Start (fileName, arguments, userName, password, domain)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="arguments" Type="System.String" />
        <Parameter Name="userName" Type="System.String" />
        <Parameter Name="password" Type="System.Security.SecureString" />
        <Parameter Name="domain" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">要在进程中运行的应用程序文件的名称。</param>
        <param name="arguments">启动该进程时传递的命令行参数。</param>
        <param name="userName">启动进程时使用的用户名。</param>
        <param name="password">包含启动进程时要使用的密码的 <see cref="T:System.Security.SecureString" />。</param>
        <param name="domain">启动进程时要使用的域。</param>
        <summary>通过指定应用程序的名称、一组命令行参数、用户名、密码和域来启动一个进程资源，并将该资源与新的 <see cref="T:System.Diagnostics.Process" /> 组件关联起来。</summary>
        <returns>与进程资源关联的新 <see cref="T:System.Diagnostics.Process" />，如果未启动进程资源，则为 <see langword="null" />。 请注意，随着同一进程已在运行的实例启动的新进程将独立于其他进程。 此外，启动可能返回一个 <see cref="P:System.Diagnostics.Process.HasExited" /> 属性已设置为 <see langword="true" /> 的非 null 进程。 在这种情况下，启动的进程可能已激活现有实例自身，然后退出。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用此重载通过指定文件的名称、 命令行参数、 用户名、 密码和域中创建新的进程和其主线程。 然后，新进程指定的凭据 （用户、 域和密码） 的安全上下文中运行指定的可执行文件。  
  
> [!NOTE]
>  在可执行文件位于远程驱动器上，必须通过使用统一资源标识符 (URI)，未链接的驱动器号来标识网络共享。  
  
> [!NOTE]
>  如果要启动的可执行文件的地址为 URL，则不会启动进程和`null`返回。  
  
 此重载使您无需首先创建一个新启动的进程<xref:System.Diagnostics.Process>实例。 此重载是创建一个新的显式步骤的替代方法<xref:System.Diagnostics.Process>实例，设置<xref:System.Diagnostics.ProcessStartInfo.FileName%2A>， <xref:System.Diagnostics.ProcessStartInfo.Arguments%2A>， <xref:System.Diagnostics.ProcessStartInfo.UserName%2A>， <xref:System.Diagnostics.ProcessStartInfo.Password%2A>，和<xref:System.Diagnostics.ProcessStartInfo.Domain%2A>的属性<xref:System.Diagnostics.Process.StartInfo%2A>属性，并调用<xref:System.Diagnostics.Process.Start%2A>为<xref:System.Diagnostics.Process>实例。  
  
 同样，在相同的方式**运行**对话框框中，可以接受带或不带扩展名为.exe 的可执行文件名称、 扩展名为.exe 中是可选`fileName`参数。 例如，可以设置`fileName`"Notepad.exe"或"记事本"的参数。 如果`fileName`参数表示的可执行文件`arguments`参数可能表示要执行操作，如文本文件中的文件`Notepad.exe myfile.txt`。  
  
> [!NOTE]
>  文件名称必须表示可执行文件中的<xref:System.Diagnostics.Process.Start%2A>具有的重载`userName`， `password`，和`domain`参数。  
  
 您每次使用<xref:System.Diagnostics.Process.Start%2A>若要启动进程时，可能需要将其关闭，否则您可能会丢失系统资源。 使用关闭进程<xref:System.Diagnostics.Process.CloseMainWindow%2A>或<xref:System.Diagnostics.Process.Kill%2A>。 你可以检查是否已关闭进程通过其<xref:System.Diagnostics.Process.HasExited%2A>属性...  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">未指定文件名。</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">打开关联的文件时出错。  
  
或 
参数的长度与该关联文件的完整路径的长度的总和超过了 2080。 与此异常关联的错误消息可能为以下消息之一：“传递到系统调用的数据区域太小。” 或“拒绝访问。”</exception>
        <exception cref="T:System.ObjectDisposedException">已释放此进程对象。</exception>
        <exception cref="T:System.PlatformNotSupportedException">Linux 或 macOS （仅适用于.NET Core）不支持此方法。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">对于直接调用方的完全信任。 此成员不能由部分信任的代码使用。</permission>
      </Docs>
    </Member>
    <Member MemberName="StartInfo">
      <MemberSignature Language="C#" Value="public System.Diagnostics.ProcessStartInfo StartInfo { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Diagnostics.ProcessStartInfo StartInfo" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.StartInfo" />
      <MemberSignature Language="VB.NET" Value="Public Property StartInfo As ProcessStartInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Diagnostics::ProcessStartInfo ^ StartInfo { System::Diagnostics::ProcessStartInfo ^ get(); void set(System::Diagnostics::ProcessStartInfo ^ value); };" />
      <MemberSignature Language="F#" Value="member this.StartInfo : System.Diagnostics.ProcessStartInfo with get, set" Usage="System.Diagnostics.Process.StartInfo" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Content)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Specifies information used to start a process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessStartInfo")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.ProcessStartInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置要传递给 <see cref="T:System.Diagnostics.Process" /> 的 <see cref="M:System.Diagnostics.Process.Start" /> 方法的属性。</summary>
        <value>表示启动进程时要使用的数据的 <see cref="T:System.Diagnostics.ProcessStartInfo" />。 这些自变量包括用于启动该进程的可执行文件或文档的名称。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.StartInfo%2A> 表示要用于启动过程的参数集。 当<xref:System.Diagnostics.Process.Start%2A>调用时，<xref:System.Diagnostics.Process.StartInfo%2A>用于指定要启动的进程。 仅必要<xref:System.Diagnostics.Process.StartInfo%2A>成员设置为<xref:System.Diagnostics.ProcessStartInfo.FileName%2A>属性。 通过指定启动进程<xref:System.Diagnostics.ProcessStartInfo.FileName%2A>属性是类似于键入中的信息**运行**的 Windows 对话框**启动**菜单。 因此，<xref:System.Diagnostics.ProcessStartInfo.FileName%2A>属性不需要表示一个可执行文件。 它可以是为其扩展已关联与应用程序在系统上安装任何文件类型。 例如<xref:System.Diagnostics.ProcessStartInfo.FileName%2A>如果已与编辑器 （如记事本） 关联的文本文件或如果您已经将利用文字处理工具，如 Microsoft Word 的文本文件，它可以具有.doc 可以具有.txt 扩展名。 同样，在相同的方式**运行**对话框框中，可以接受带或不带扩展名为.exe 的可执行文件名称、 扩展名为.exe 中是可选<xref:System.Diagnostics.ProcessStartInfo.FileName%2A>成员。 例如，可以设置<xref:System.Diagnostics.ProcessStartInfo.FileName%2A>属性设置为"Notepad.exe"或"记事本"。  
  
 可以通过设置启动 ClickOnce 应用程序<xref:System.Diagnostics.ProcessStartInfo.FileName%2A>属性设置为最初从中安装应用程序的位置 （例如，Web 地址）。 不通过指定其安装的位置在硬盘驱动器上启动 ClickOnce 应用程序。  
  
 如果文件名涉及不可执行文件，例如.doc 文件，可以包含一个谓词指定要对文件执行的操作。 例如，可以设置<xref:System.Diagnostics.ProcessStartInfo.Verb%2A>"print"以.doc 扩展名结尾的文件。 中指定的文件名称<xref:System.Diagnostics.ProcessStartInfo.FileName%2A>属性不需要提供一个扩展，如果手动输入一个值<xref:System.Diagnostics.ProcessStartInfo.Verb%2A>属性。 但是，如果您使用<xref:System.Diagnostics.ProcessStartInfo.Verbs%2A>属性来确定哪些谓词可用，必须包括扩展名。  
  
 你可以在指定的参数<xref:System.Diagnostics.Process.StartInfo%2A>属性调用时间<xref:System.Diagnostics.Process.Start%2A>过程的方法。 启动进程后，更改<xref:System.Diagnostics.Process.StartInfo%2A>值不会影响或重新启动关联的进程。 如果调用<xref:System.Diagnostics.Process.Start%28System.Diagnostics.ProcessStartInfo%29>方法替换<xref:System.Diagnostics.ProcessStartInfo.UserName%2A?displayProperty=nameWithType>并<xref:System.Diagnostics.ProcessStartInfo.Password%2A?displayProperty=nameWithType>属性集，则非托管`CreateProcessWithLogonW`调用函数时，该过程启动新窗口即使<xref:System.Diagnostics.ProcessStartInfo.CreateNoWindow%2A>属性值是`true`或<xref:System.Diagnostics.ProcessStartInfo.WindowStyle%2A>属性值是<xref:System.Diagnostics.ProcessWindowStyle.Hidden>。  
  
 如果未使用<xref:System.Diagnostics.Process.Start%2A>方法以启动一个进程，<xref:System.Diagnostics.Process.StartInfo%2A>属性不会反映用于启动过程的参数。 例如，如果您使用<xref:System.Diagnostics.Process.GetProcesses%2A>若要获取的计算机上运行的进程数组<xref:System.Diagnostics.Process.StartInfo%2A>每个属性<xref:System.Diagnostics.Process>不包含原始文件名称或用于启动过程的参数。  
  
 当启动进程时，文件名称是填充 （只读） 的文件<xref:System.Diagnostics.Process.MainModule%2A>属性。 如果你想要检索与该进程关联的可执行文件启动过程后，请使用<xref:System.Diagnostics.Process.MainModule%2A>属性。 如果你想要设置的可执行文件<xref:System.Diagnostics.Process>实例有关的关联的进程尚未启动，请使用<xref:System.Diagnostics.Process.StartInfo%2A>属性的<xref:System.Diagnostics.ProcessStartInfo.FileName%2A>成员。 因为的成员<xref:System.Diagnostics.Process.StartInfo%2A>属性是指传递给参数<xref:System.Diagnostics.Process.Start%2A>方法的过程中，更改<xref:System.Diagnostics.ProcessStartInfo.FileName%2A>属性关联的进程启动后将不会重置<xref:System.Diagnostics.Process.MainModule%2A>属性。 这些属性仅用于初始化关联的进程。  
  
   
  
## Examples  
 下面的示例填充<xref:System.Diagnostics.Process.StartInfo%2A>对其执行该操作与要执行的文件，以及它是否应显示用户界面。 有关其他示例，请参阅的属性的参考页<xref:System.Diagnostics.ProcessStartInfo>类。  
  
 [!code-cpp[Process.Start_instance#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.Start_instance/CPP/processstart.cpp#1)]
 [!code-csharp[Process.Start_instance#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.Start_instance/CS/processstart.cs#1)]
 [!code-vb[Process.Start_instance#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.Start_instance/VB/processstart.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">指定 <see cref="P:System.Diagnostics.Process.StartInfo" /> 的值为 <see langword="null" />。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">对于直接调用方的完全信任。 此成员不能由部分信任的代码使用。</permission>
        <altmember cref="M:System.Diagnostics.Process.Start" />
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.FileName" />
      </Docs>
    </Member>
    <Member MemberName="StartTime">
      <MemberSignature Language="C#" Value="public DateTime StartTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime StartTime" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.StartTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property StartTime As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property DateTime StartTime { DateTime get(); };" />
      <MemberSignature Language="F#" Value="member this.StartTime : DateTime" Usage="System.Diagnostics.Process.StartTime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The time at which the process was started.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessStartTime")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取关联进程启动的时间。</summary>
        <value>指示进程启动的时间的对象。 如果进程未运行，将会引发异常。</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.PlatformNotSupportedException">该平台是 Windows 98 或 Windows Millennium Edition (Windows Me)，不支持此属性。</exception>
        <exception cref="T:System.NotSupportedException">你正试图访问在远程计算机上运行的进程的 <see cref="P:System.Diagnostics.Process.StartTime" /> 属性。 此属性仅可用于本地计算机上运行的进程。</exception>
        <exception cref="T:System.InvalidOperationException">该进程已退出。  
  
或 
该进程尚未启动。</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">调用 Windows 函数时出错。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">对于直接调用方的完全信任。 此成员不能由部分信任的代码使用。</permission>
      </Docs>
    </Member>
    <Member MemberName="SynchronizingObject">
      <MemberSignature Language="C#" Value="public System.ComponentModel.ISynchronizeInvoke SynchronizingObject { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ComponentModel.ISynchronizeInvoke SynchronizingObject" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.SynchronizingObject" />
      <MemberSignature Language="VB.NET" Value="Public Property SynchronizingObject As ISynchronizeInvoke" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ComponentModel::ISynchronizeInvoke ^ SynchronizingObject { System::ComponentModel::ISynchronizeInvoke ^ get(); void set(System::ComponentModel::ISynchronizeInvoke ^ value); };" />
      <MemberSignature Language="F#" Value="member this.SynchronizingObject : System.ComponentModel.ISynchronizeInvoke with get, set" Usage="System.Diagnostics.Process.SynchronizingObject" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The object used to marshal the event handler calls issued as a result of a Process exit.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessSynchronizingObject")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.ISynchronizeInvoke</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置用于封送由于进程退出事件而发出的事件处理程序调用的对象。</summary>
        <value>
          <see cref="T:System.ComponentModel.ISynchronizeInvoke" />，它用于封送由于进程上的 <see cref="E:System.Diagnostics.Process.Exited" /> 事件而发出的事件处理程序调用。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当<xref:System.Diagnostics.EventLog.SynchronizingObject%2A>是`null`，方法，用于处理<xref:System.Diagnostics.Process.Exited>从系统线程池线程上调用事件。 有关系统线程池的详细信息，请参阅<xref:System.Threading.ThreadPool>。  
  
 当<xref:System.Diagnostics.Process.Exited>事件由 visual 的 Windows 窗体组件，如处理<xref:System.Windows.Forms.Button>，通过系统线程池访问组件可能无法工作，或可能会导致异常。 通过设置来避免这<xref:System.Diagnostics.Process.SynchronizingObject%2A>到 Windows 窗体组件时，这将导致处理的方法<xref:System.Diagnostics.Process.Exited>在其创建该组件在同一线程上调用的事件。  
  
 如果<xref:System.Diagnostics.Process>内部使用[!INCLUDE[vsprvslong](~/includes/vsprvslong-md.md)]在 Windows 窗体设计器中，<xref:System.Diagnostics.Process.SynchronizingObject%2A>自动设置为包含的控件<xref:System.Diagnostics.Process>。 例如，如果将置于<xref:System.Diagnostics.Process>的设计器上`Form1`(它是从<xref:System.Windows.Forms.Form>)<xref:System.Diagnostics.Process.SynchronizingObject%2A>属性<xref:System.Diagnostics.Process>设置为的实例`Form1`:  
  
 [!code-cpp[Process_SynchronizingObject#2](~/samples/snippets/cpp/VS_Snippets_CLR/Process_SynchronizingObject/CPP/remarks.cpp#2)]
 [!code-csharp[Process_SynchronizingObject#2](~/samples/snippets/csharp/VS_Snippets_CLR/Process_SynchronizingObject/CS/remarks.cs#2)]
 [!code-vb[Process_SynchronizingObject#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process_SynchronizingObject/VB/remarks.vb#2)]  
  
 通常情况下，此属性设置时该组件放置控件或窗体，因为这些组件绑定到特定线程。  
  
   
  
## Examples  
 [!code-cpp[Process_SynchronizingObject#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process_SynchronizingObject/CPP/process_synchronizingobject.cpp#1)]
 [!code-csharp[Process_SynchronizingObject#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process_SynchronizingObject/CS/process_synchronizingobject.cs#1)]
 [!code-vb[Process_SynchronizingObject#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process_SynchronizingObject/VB/process_synchronizingobject.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">对于直接调用方的完全信任。 此成员不能由部分信任的代码使用。</permission>
        <altmember cref="P:System.Diagnostics.Process.SynchronizingObject" />
      </Docs>
    </Member>
    <Member MemberName="Threads">
      <MemberSignature Language="C#" Value="public System.Diagnostics.ProcessThreadCollection Threads { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Diagnostics.ProcessThreadCollection Threads" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.Threads" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Threads As ProcessThreadCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Diagnostics::ProcessThreadCollection ^ Threads { System::Diagnostics::ProcessThreadCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Threads : System.Diagnostics.ProcessThreadCollection" Usage="System.Diagnostics.Process.Threads" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The number of threads of this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessThreads")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.ProcessThreadCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取在关联进程中运行的一组线程。</summary>
        <value>类型 <see cref="T:System.Diagnostics.ProcessThread" /> 的数组，表示当前在关联进程中运行的操作系统线程。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 一个线程在进程中执行代码。 每个进程开始使用单个线程中，其主线程。 任何线程都可以创建其他线程。 进程内的线程共享进程的地址空间。  
  
 使用<xref:System.Diagnostics.ProcessThread>可获取与当前进程关联的所有线程。 主线程不一定是位于索引零数组中。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.SystemException">进程没有 <see cref="P:System.Diagnostics.Process.Id" />，或者没有与 <see cref="T:System.Diagnostics.Process" /> 实例关联的进程。  
  
或 
关联进程已退出。</exception>
        <exception cref="T:System.PlatformNotSupportedException">该平台是 Windows 98 或 Windows Millennium Edition (Windows Me)；将 <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> 设置为 <see langword="false" />，以在 Windows 98 和 Windows Me 上访问此属性。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">对于直接调用方的完全信任。 此成员不能由部分信任的代码使用。</permission>
        <altmember cref="T:System.Diagnostics.ProcessThread" />
        <altmember cref="P:System.Diagnostics.Process.BasePriority" />
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="process.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>如果适用，则将进程的名称格式化为字符串，并与父组件类型组合。</summary>
        <returns>
          <see cref="P:System.Diagnostics.Process.ProcessName" />，与基组件的 <see cref="M:System.Object.ToString" /> 返回值组合。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 以下示例启动记事本的实例。 该示例然后检索并显示关联的进程的各种属性。 该示例检测时在进程退出，并显示该进程的退出代码。  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Windows 98 不支持 <see cref="M:System.Diagnostics.Process.ToString" />。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">对于直接调用方的完全信任。 此成员不能由部分信任的代码使用。</permission>
      </Docs>
    </Member>
    <Member MemberName="TotalProcessorTime">
      <MemberSignature Language="C#" Value="public TimeSpan TotalProcessorTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan TotalProcessorTime" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.TotalProcessorTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TotalProcessorTime As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TimeSpan TotalProcessorTime { TimeSpan get(); };" />
      <MemberSignature Language="F#" Value="member this.TotalProcessorTime : TimeSpan" Usage="System.Diagnostics.Process.TotalProcessorTime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of CPU time the process has used.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessTotalProcessorTime")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取此进程的总的处理器时间。</summary>
        <value>
          <see cref="T:System.TimeSpan" />，它指示关联进程使用 CPU 的时间。 此值是 <see cref="P:System.Diagnostics.Process.UserProcessorTime" /> 和 <see cref="P:System.Diagnostics.Process.PrivilegedProcessorTime" /> 的和。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 以下示例启动记事本的实例。 该示例然后检索并显示关联的进程的各种属性。 该示例检测时在进程退出，并显示该进程的退出代码。  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">该平台是 Windows 98 或 Windows Millennium Edition (Windows Me)，不支持此属性。</exception>
        <exception cref="T:System.NotSupportedException">你正试图访问在远程计算机上运行的进程的 <see cref="P:System.Diagnostics.Process.TotalProcessorTime" /> 属性。 此属性仅可用于本地计算机上运行的进程。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">对于直接调用方的完全信任。 此成员不能由部分信任的代码使用。</permission>
        <altmember cref="P:System.Diagnostics.Process.UserProcessorTime" />
        <altmember cref="P:System.Diagnostics.Process.PrivilegedProcessorTime" />
      </Docs>
    </Member>
    <Member MemberName="UserProcessorTime">
      <MemberSignature Language="C#" Value="public TimeSpan UserProcessorTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan UserProcessorTime" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.UserProcessorTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property UserProcessorTime As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TimeSpan UserProcessorTime { TimeSpan get(); };" />
      <MemberSignature Language="F#" Value="member this.UserProcessorTime : TimeSpan" Usage="System.Diagnostics.Process.UserProcessorTime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of CPU time the process spent outside the operating system core.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessUserProcessorTime")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取此进程的用户处理器时间。</summary>
        <value>
          <see cref="T:System.TimeSpan" />，它指示关联进程在该进程的应用程序部分内(而不是在操作系统内核中)运行代码所用的时间。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 以下示例启动记事本的实例。 该示例然后检索并显示关联的进程的各种属性。 该示例检测时在进程退出，并显示该进程的退出代码。  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">该平台是 Windows 98 或 Windows Millennium Edition (Windows Me)，不支持此属性。</exception>
        <exception cref="T:System.NotSupportedException">你正试图访问在远程计算机上运行的进程的 <see cref="P:System.Diagnostics.Process.UserProcessorTime" /> 属性。 此属性仅可用于本地计算机上运行的进程。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">对于直接调用方的完全信任。 此成员不能由部分信任的代码使用。</permission>
        <altmember cref="P:System.Diagnostics.Process.UserProcessorTime" />
        <altmember cref="P:System.Diagnostics.Process.PrivilegedProcessorTime" />
      </Docs>
    </Member>
    <Member MemberName="VirtualMemorySize">
      <MemberSignature Language="C#" Value="public int VirtualMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 VirtualMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.VirtualMemorySize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property VirtualMemorySize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int VirtualMemorySize { int get(); };" />
      <MemberSignature Language="F#" Value="member this.VirtualMemorySize : int" Usage="System.Diagnostics.Process.VirtualMemorySize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of virtual memory currently used for this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use VirtualMemorySize64")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.VirtualMemorySize64 instead.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessVirtualMemorySize")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取进程的虚拟内存大小（以字节为单位）。</summary>
        <value>关联进程请求的虚拟内存量(以字节为单位)。</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.PlatformNotSupportedException">该平台是 Windows 98 或 Windows Millennium Edition (Windows Me)，不支持此属性。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">对于直接调用方的完全信任。 此成员不能由部分信任的代码使用。</permission>
        <altmember cref="P:System.Diagnostics.Process.VirtualMemorySize64" />
        <altmember cref="P:System.Diagnostics.Process.PeakVirtualMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="VirtualMemorySize64">
      <MemberSignature Language="C#" Value="public long VirtualMemorySize64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 VirtualMemorySize64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.VirtualMemorySize64" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property VirtualMemorySize64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long VirtualMemorySize64 { long get(); };" />
      <MemberSignature Language="F#" Value="member this.VirtualMemorySize64 : int64" Usage="System.Diagnostics.Process.VirtualMemorySize64" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of virtual memory currently used for this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessVirtualMemorySize")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取为关联进程分配的虚拟内存量（以字节为单位）。</summary>
        <value>为关联进程分配的虚拟内存量(以字节为单位)。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 返回此属性的值表示使用的过程中，以字节为单位的虚拟内存的当前大小。 操作系统将映射到页加载在物理内存或页面存储在磁盘上的虚拟内存分页文件中每个进程的虚拟地址空间。  
  
 此属性可以用于监视具有 32 位处理器或 64 位处理器的计算机上的内存使用率。 属性值等于**虚拟字节**进程的性能计数器。  
  
   
  
## Examples  
 下面的代码示例启动记事本应用程序的实例。 该示例然后检索并显示关联的进程的各种属性。 该示例检测时在进程退出，并显示其退出代码和峰值内存统计信息。  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">该平台是 Windows 98 或 Windows Millennium Edition (Windows Me)，不支持此属性。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">对于直接调用方的完全信任。 此成员不能由部分信任的代码使用。</permission>
        <altmember cref="P:System.Diagnostics.Process.PeakVirtualMemorySize64" />
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitForExit">
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>设置等待关联进程退出的时间段，并在该段时间结束前或该进程退出前，阻止当前线程执行。 若要避免妨碍当前线程，请使用 <see cref="E:System.Diagnostics.Process.Exited" /> 事件。  
  
有关代码示例，请参阅 <see cref="P:System.Diagnostics.Process.StandardError" /> 和 <see cref="P:System.Diagnostics.Process.ExitCode" /> 属性参考页。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitForExit">
      <MemberSignature Language="C#" Value="public void WaitForExit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WaitForExit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.WaitForExit" />
      <MemberSignature Language="VB.NET" Value="Public Sub WaitForExit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WaitForExit();" />
      <MemberSignature Language="F#" Value="member this.WaitForExit : unit -&gt; unit" Usage="process.WaitForExit " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>指示 <see cref="T:System.Diagnostics.Process" /> 组件无限期地等待关联进程退出。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.WaitForExit> 使当前线程等待，直到关联的进程终止。  在过程调用的所有其他方法后，应调用它。 若要避免妨碍当前线程，请使用 <xref:System.Diagnostics.Process.Exited> 事件。  
  
 此方法指示<xref:System.Diagnostics.Process>组件等待无限长的过程和事件处理程序以退出的时间。 这会导致应用程序停止响应。 例如，如果您调用<xref:System.Diagnostics.Process.CloseMainWindow%2A>对于具有用户界面的进程，终止关联的进程对操作系统请求可能不会处理如果进程被编写为永远不会进入其消息循环。  
  
> [!NOTE]
>  在中[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]及更早版本<xref:System.Diagnostics.Process.WaitForExit>重载会等待<xref:System.Int32.MaxValue>毫秒 （大约 24 天），并不是无限期。 此外，以前的版本不会等待的事件处理程序退出完整<xref:System.Int32.MaxValue>时间已达到。  
  
 此重载可确保已包括的重定向标准输出的异步事件处理完成所有处理。 在调用后，应使用此重载<xref:System.Diagnostics.Process.WaitForExit%28System.Int32%29>重载时标准输出已被重定向到异步事件处理程序。  
  
 关联的进程退出时 （即，当它由操作系统通过正常或异常终止关闭），系统存储过程的管理信息，并返回到调用过的组件<xref:System.Diagnostics.Process.WaitForExit>。 <xref:System.Diagnostics.Process>组件可访问的信息，其中包括<xref:System.Diagnostics.Process.ExitTime%2A>，通过使用<xref:System.Diagnostics.Process.Handle%2A>已退出进程。  
  
 关联的进程已退出，因为<xref:System.Diagnostics.Process.Handle%2A>组件属性不再指向现有进程资源。 相反，该句柄仅用于访问有关进程资源的操作系统的信息。 系统已注意到尚未通过发布的已退出进程的句柄<xref:System.Diagnostics.Process>组件，因此它会保留<xref:System.Diagnostics.Process.ExitTime%2A>和<xref:System.Diagnostics.Process.Handle%2A>之前的内存中的信息<xref:System.Diagnostics.Process>组件明确释放这些资源。 出于此原因，任何时候调用<xref:System.Diagnostics.Process.Start%2A>有关<xref:System.Diagnostics.Process>实例时，调用<xref:System.Diagnostics.Process.Close%2A>时关联的进程已终止且不再需要任何管理相关信息。 <xref:System.Diagnostics.Process.Close%2A> 释放分配给已退出进程的内存。  
  
   
  
## Examples  
 请参阅备注部分的<xref:System.Diagnostics.Process.StandardError%2A>属性参考页。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">无法访问等待设置。</exception>
        <exception cref="T:System.SystemException">尚未设置进程 <see cref="P:System.Diagnostics.Process.Id" />，而且不存在可从其确定 <see cref="P:System.Diagnostics.Process.Id" /> 属性的 <see cref="P:System.Diagnostics.Process.Handle" />。  
  
或 
没有与此 <see cref="T:System.Diagnostics.Process" /> 对象关联的进程。  
  
或 
你正尝试为远程计算机上运行的进程调用 <see cref="M:System.Diagnostics.Process.WaitForExit" />。 此方法仅对本地计算机上运行的进程可用。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">对于直接调用方的完全信任。 此成员不能由部分信任的代码使用。</permission>
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Kill" />
        <altmember cref="P:System.Diagnostics.Process.Handle" />
        <altmember cref="P:System.Diagnostics.Process.ExitTime" />
        <altmember cref="P:System.Diagnostics.Process.EnableRaisingEvents" />
        <altmember cref="P:System.Diagnostics.Process.HasExited" />
        <altmember cref="E:System.Diagnostics.Process.Exited" />
      </Docs>
    </Member>
    <Member MemberName="WaitForExit">
      <MemberSignature Language="C#" Value="public bool WaitForExit (int milliseconds);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool WaitForExit(int32 milliseconds) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.WaitForExit(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function WaitForExit (milliseconds As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool WaitForExit(int milliseconds);" />
      <MemberSignature Language="F#" Value="member this.WaitForExit : int -&gt; bool" Usage="process.WaitForExit milliseconds" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="milliseconds" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="milliseconds">等待关联进程退出的时间(以毫秒为单位)。 最大值为 32 位整数的最大可能值，这对于操作系统而言表示无限大。</param>
        <summary>指示 <see cref="T:System.Diagnostics.Process" /> 组件在指定的毫秒数内等待关联进程退出。</summary>
        <returns>如果关联进程已退出，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.WaitForExit%28System.Int32%29> 使当前线程等待，直到关联的进程终止。 在过程调用的所有其他方法后，应调用它。 若要避免妨碍当前线程，请使用 <xref:System.Diagnostics.Process.Exited> 事件。  
  
 此方法指示<xref:System.Diagnostics.Process>组件等待在有限的进程退出的时间。 如果关联的进程不退出的时间间隔结束时终止请求被拒绝，因为`false`返回到调用过程。 您可以指定<xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>有关`milliseconds`，并<xref:System.Diagnostics.Process.WaitForExit%28System.Int32%29?displayProperty=nameWithType>行为将与相同<xref:System.Diagnostics.Process.WaitForExit>重载。 如果您将 0 （零） 传递给该方法，它将返回`true`仅当该进程已退出; 否则，将立即返回`false`。  
  
> [!NOTE]
>  在中[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]及更早版本，如果`milliseconds`为-1，<xref:System.Diagnostics.Process.WaitForExit%28System.Int32%29>重载会等待<xref:System.Int32.MaxValue>毫秒 （大约 24 天），并不是无限期。  
  
 当标准输出重定向到异步事件处理程序时，就可以输出处理将不具有在此方法返回时完成。 若要确保已完成异步事件处理，请调用<xref:System.Diagnostics.Process.WaitForExit>接收后不接受任何参数的重载`true`从此重载。 为了帮助确保<xref:System.Diagnostics.Process.Exited>在 Windows 窗体应用程序中正确处理事件，请将设置<xref:System.Diagnostics.Process.SynchronizingObject%2A>属性。  
  
 当关联的进程退出 （关闭的情况下由操作系统通过正常或异常终止），系统存储过程的管理信息并返回到调用过的组件<xref:System.Diagnostics.Process.WaitForExit%28System.Int32%29>。 <xref:System.Diagnostics.Process>组件可访问的信息，其中包括<xref:System.Diagnostics.Process.ExitTime%2A>，通过使用<xref:System.Diagnostics.Process.Handle%2A>已退出进程。  
  
 关联的进程已退出，因为<xref:System.Diagnostics.Process.Handle%2A>组件属性不再指向现有进程资源。 相反，该句柄仅用于访问有关进程资源的操作系统的信息。 系统已注意到尚未通过发布的已退出进程的句柄<xref:System.Diagnostics.Process>组件，因此它会保留<xref:System.Diagnostics.Process.ExitTime%2A>和<xref:System.Diagnostics.Process.Handle%2A>之前的内存中的信息<xref:System.Diagnostics.Process>组件明确释放这些资源。 出于此原因，任何时候调用<xref:System.Diagnostics.Process.Start%2A>有关<xref:System.Diagnostics.Process>实例时，调用<xref:System.Diagnostics.Process.Close%2A>时关联的进程已终止且不再需要任何管理相关信息。 <xref:System.Diagnostics.Process.Close%2A> 释放分配给已退出进程的内存。  
  
   
  
## Examples  
 代码示例，请参阅<xref:System.Diagnostics.Process.ExitCode%2A>属性。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">无法访问等待设置。</exception>
        <exception cref="T:System.SystemException">尚未设置进程 <see cref="P:System.Diagnostics.Process.Id" />，而且不存在可从其确定 <see cref="P:System.Diagnostics.Process.Id" /> 属性的 <see cref="P:System.Diagnostics.Process.Handle" />。  
  
或 
没有与此 <see cref="T:System.Diagnostics.Process" /> 对象关联的进程。  
  
或 
你正尝试为远程计算机上运行的进程调用 <see cref="M:System.Diagnostics.Process.WaitForExit(System.Int32)" />。 此方法仅对本地计算机上运行的进程可用。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="milliseconds" /> 是一个非 -1 的负数，而 -1 表示无限期超时。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">对于直接调用方的完全信任。 此成员不能由部分信任的代码使用。</permission>
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Kill" />
        <altmember cref="P:System.Diagnostics.Process.Handle" />
        <altmember cref="P:System.Diagnostics.Process.ExitTime" />
        <altmember cref="P:System.Diagnostics.Process.EnableRaisingEvents" />
        <altmember cref="P:System.Diagnostics.Process.HasExited" />
        <altmember cref="E:System.Diagnostics.Process.Exited" />
        <altmember cref="P:System.Diagnostics.Process.SynchronizingObject" />
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitForInputIdle">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>使 <see cref="T:System.Diagnostics.Process" /> 组件等待关联进程进入空闲状态。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitForInputIdle">
      <MemberSignature Language="C#" Value="public bool WaitForInputIdle ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool WaitForInputIdle() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.WaitForInputIdle" />
      <MemberSignature Language="VB.NET" Value="Public Function WaitForInputIdle () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool WaitForInputIdle();" />
      <MemberSignature Language="F#" Value="member this.WaitForInputIdle : unit -&gt; bool" Usage="process.WaitForInputIdle " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>使 <see cref="T:System.Diagnostics.Process" /> 组件无限期地等待关联进程进入空闲状态。 此重载仅适用于具有用户界面并因此具有消息循环的进程。</summary>
        <returns>如果关联进程已经达到空闲状态，则为 <see langword="true" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用<xref:System.Diagnostics.Process.WaitForInputIdle>强制等待，直到消息循环已为空闲状态返回应用程序的处理。 具有用户界面的进程是在执行时，其消息循环将执行每次操作系统 Windows 消息发送到进程。 然后，该进程返回到消息循环。 说进程时它正在等待消息的消息循环内处于空闲状态。 此状态是很有用，例如，当你的应用程序需要等待完成之前与该窗口进行通信的应用程序创建其主窗口启动的进程时。  
  
 如果进程不具有消息循环<xref:System.Diagnostics.Process.WaitForInputIdle>引发<xref:System.InvalidOperationException>。  
  
 <xref:System.Diagnostics.Process.WaitForInputIdle>重载指示<xref:System.Diagnostics.Process>组件无限期地等待进程变为空闲状态消息循环中。 此指令可能会导致应用程序停止响应。 例如，如果该过程始终写入其消息循环立即退出，如下所示的代码片段`while(true)`。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">进程不具有图形界面。  
  
或 
发生未知错误。 进程无法进入空闲状态。  
  
或 
已经退出该进程。  
  
或 
没有与此 <see cref="T:System.Diagnostics.Process" /> 对象关联的进程。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">对于直接调用方的完全信任。 此成员不能由部分信任的代码使用。</permission>
        <altmember cref="M:System.Diagnostics.Process.Start" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
      </Docs>
    </Member>
    <Member MemberName="WaitForInputIdle">
      <MemberSignature Language="C#" Value="public bool WaitForInputIdle (int milliseconds);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool WaitForInputIdle(int32 milliseconds) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.WaitForInputIdle(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function WaitForInputIdle (milliseconds As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool WaitForInputIdle(int milliseconds);" />
      <MemberSignature Language="F#" Value="member this.WaitForInputIdle : int -&gt; bool" Usage="process.WaitForInputIdle milliseconds" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="milliseconds" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="milliseconds">1 到 <see cref="F:System.Int32.MaxValue" /> 的值以毫秒为单位指定了等待关联进程变为空闲状态的时间量。 0 值指定立即返回，而 -1 值则指定无限期等待。</param>
        <summary>使 <see cref="T:System.Diagnostics.Process" /> 组件在指定的毫秒数内等待关联进程进入空闲状态。 此重载仅适用于具有用户界面并因此具有消息循环的进程。</summary>
        <returns>如果关联进程已经达到空闲状态，则为 <see langword="true" />；否则，为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用<xref:System.Diagnostics.Process.WaitForInputIdle%28System.Int32%29>强制等待，直到消息循环已为空闲状态返回应用程序的处理。 具有用户界面的进程是在执行时，其消息循环将执行每次操作系统 Windows 消息发送到进程。 然后，该进程返回到消息循环。 说进程时它正在等待消息的消息循环内处于空闲状态。 此状态是很有用，例如，当你的应用程序需要等待完成之前与该窗口进行通信的应用程序创建其主窗口启动的进程时。  
  
 如果进程不具有消息循环<xref:System.Diagnostics.Process.WaitForInputIdle%28System.Int32%29>引发<xref:System.InvalidOperationException>。  
  
 <xref:System.Diagnostics.Process.WaitForInputIdle%28System.Int32%29>重载指示<xref:System.Diagnostics.Process>组件等待有限的时间进程进入空闲状态消息循环中。 如果关联的进程不具有进入空闲状态的间隔结束时循环仍在处理消息，因为`false`返回到调用过程。  
  
 有关处理事件的详细信息，请参阅[处理和引发事件](~/docs/standard/events/index.md)。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">进程不具有图形界面。  
  
或 
发生未知错误。 进程无法进入空闲状态。  
  
或 
已经退出该进程。  
  
或 
没有与此 <see cref="T:System.Diagnostics.Process" /> 对象关联的进程。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">对于直接调用方的完全信任。 此成员不能由部分信任的代码使用。</permission>
        <altmember cref="M:System.Diagnostics.Process.Start" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
      </Docs>
    </Member>
    <Member MemberName="WorkingSet">
      <MemberSignature Language="C#" Value="public int WorkingSet { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 WorkingSet" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.WorkingSet" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property WorkingSet As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int WorkingSet { int get(); };" />
      <MemberSignature Language="F#" Value="member this.WorkingSet : int" Usage="System.Diagnostics.Process.WorkingSet" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of physical memory currently used for this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use WorkingSet64")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.WorkingSet64 instead.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessWorkingSet")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取关联进程的物理内存使用量（以字节为单位）。</summary>
        <value>关联进程当前使用的物理内存总量(以字节为单位)。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 返回此属性的值表示工作集内存使用的过程中，以字节为单位的当前的大小。 进程工作集是物理 RAM 内存中当前可见到进程的内存页的集合。 这些页面是常驻内存，可用于应用程序使用而不会触发页面错误。  
  
 工作集包括数据共享和专用数据。 共享的数据包括包含该进程执行，包括进程模块和系统库的所有说明的页。  
  
   
  
## Examples  
 以下示例启动记事本的实例。 该示例然后检索并显示关联的进程的各种属性。 该示例检测时在进程退出，并显示进程的退出代码。  
  
 [!code-cpp[process_sample#1](~/samples/snippets/cpp/VS_Snippets_CLR/process_sample/CPP/process_sample.cpp#1)]
 [!code-csharp[process_sample#1](~/samples/snippets/csharp/VS_Snippets_CLR/process_sample/CS/process_sample.cs#1)]
 [!code-vb[process_sample#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_sample/VB/process_sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">该平台是 Windows 98 或 Windows Millennium Edition (Windows Me)，不支持此属性。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">对于直接调用方的完全信任。 此成员不能由部分信任的代码使用。</permission>
        <altmember cref="P:System.Diagnostics.Process.MinWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.MaxWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.PeakWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.PeakWorkingSet64" />
        <altmember cref="P:System.Diagnostics.Process.WorkingSet64" />
      </Docs>
    </Member>
    <Member MemberName="WorkingSet64">
      <MemberSignature Language="C#" Value="public long WorkingSet64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 WorkingSet64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.WorkingSet64" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property WorkingSet64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long WorkingSet64 { long get(); };" />
      <MemberSignature Language="F#" Value="member this.WorkingSet64 : int64" Usage="System.Diagnostics.Process.WorkingSet64" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of physical memory currently used for this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessWorkingSet")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取为关联的进程分配的物理内存量（以字节为单位）。</summary>
        <value>为关的进程分配的物理内存量(以字节为单位)。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 返回此属性的值表示工作集内存使用的过程中，以字节为单位的当前的大小。 进程工作集是物理 RAM 内存中当前可见到进程的内存页的集合。 这些页面是常驻内存，可用于应用程序使用而不会触发页面错误。  
  
 工作集包括数据共享和专用数据。 共享的数据包括包含该进程执行，包括进程模块和系统库中的说明进行操作的所有说明的页。  
  
 此属性可以用于监视具有 32 位处理器或 64 位处理器的计算机上的内存使用率。 属性值等于**Working Set**进程的性能计数器。  
  
   
  
## Examples  
 下面的代码示例启动记事本应用程序的实例。 该示例然后检索并显示关联的进程的各种属性。 该示例检测时在进程退出，并显示其退出代码和峰值内存统计信息。  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">该平台是 Windows 98 或 Windows Millennium Edition (Windows Me)，不支持此属性。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">对于直接调用方的完全信任。 此成员不能由部分信任的代码使用。</permission>
        <altmember cref="P:System.Diagnostics.Process.MinWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.MaxWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.PeakWorkingSet64" />
      </Docs>
    </Member>
  </Members>
</Type>