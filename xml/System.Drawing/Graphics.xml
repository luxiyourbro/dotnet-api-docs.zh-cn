<Type Name="Graphics" FullName="System.Drawing.Graphics">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="9207695453282e660bd1743c5458ee211c87c426" />
    <Meta Name="ms.sourcegitcommit" Value="16d2d159872fd213cae4b8f371d7ae9c8b027c89" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-CN" />
    <Meta Name="ms.lasthandoff" Value="11/17/2018" />
    <Meta Name="ms.locfileid" Value="51939832" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class Graphics : MarshalByRefObject, IDisposable, System.Drawing.IDeviceContext" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit Graphics extends System.MarshalByRefObject implements class System.Drawing.IDeviceContext, class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Drawing.Graphics" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class Graphics&#xA;Inherits MarshalByRefObject&#xA;Implements IDeviceContext, IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class Graphics sealed : MarshalByRefObject, IDisposable, System::Drawing::IDeviceContext" />
  <TypeSignature Language="F#" Value="type Graphics = class&#xA;    inherit MarshalByRefObject&#xA;    interface IDisposable&#xA;    interface IDeviceContext" />
  <AssemblyInfo>
    <AssemblyName>System.Drawing</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Drawing.Common</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.MarshalByRefObject</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Drawing.IDeviceContext</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1">
      <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>封装一个 GDI+ 绘图图面。 此类不能被继承。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Drawing.Graphics>类提供了对象绘制到显示设备的方法。 一个<xref:System.Drawing.Graphics>与特定设备上下文相关联。  
  
 你可以获取<xref:System.Drawing.Graphics>对象通过调用<xref:System.Windows.Forms.Control.CreateGraphics%2A?displayProperty=nameWithType>继承的对象上的方法<xref:System.Windows.Forms.Control?displayProperty=nameWithType>，或通过处理控件的<xref:System.Windows.Forms.Control.Paint?displayProperty=nameWithType>事件和访问<xref:System.Windows.Forms.PaintEventArgs.Graphics%2A>属性<xref:System.Windows.Forms.PaintEventArgs?displayProperty=nameWithType>类。 此外可以创建<xref:System.Drawing.Graphics>对象使用的映像从<xref:System.Drawing.Graphics.FromImage%2A>方法。 有关创建的详细信息<xref:System.Drawing.Graphics>对象，请参阅[如何： 创建用于绘制的图形对象](~/docs/framework/winforms/advanced/how-to-create-graphics-objects-for-drawing.md)。  
  
 可以通过绘制多个不同的形状和线条<xref:System.Drawing.Graphics>对象。 有关如何绘制线条和形状的详细信息，请参阅特定于`Draw` *GraphicalElement*方法的行或你想要绘制的形状。 这些方法包括<xref:System.Drawing.Graphics.DrawLine%2A>， <xref:System.Drawing.Graphics.DrawArc%2A>， <xref:System.Drawing.Graphics.DrawClosedCurve%2A>， <xref:System.Drawing.Graphics.DrawPolygon%2A>，和<xref:System.Drawing.Graphics.DrawRectangle%2A>。 有关如何绘制线条和形状的详细信息，请参阅[用笔和绘制线条和形状](~/docs/framework/winforms/advanced/using-a-pen-to-draw-lines-and-shapes.md)并[使用画笔填充形状到](~/docs/framework/winforms/advanced/using-a-brush-to-fill-shapes.md)。  
  
 您还可以通过绘制图像和图标<xref:System.Drawing.Graphics.DrawImage%2A>和<xref:System.Drawing.Graphics.DrawIcon%2A>方法，分别。 执行颜色数据位块传输从屏幕到绘图图面的<xref:System.Drawing.Graphics>对象，请参阅<xref:System.Drawing.Graphics.CopyFromScreen%2A>。 有关如何绘制图像的详细信息<xref:System.Drawing.Graphics>对象，请参阅[使用图像、 位图、 图标和图元文件](~/docs/framework/winforms/advanced/working-with-images-bitmaps-icons-and-metafiles.md)。  
  
 此外，你能够使用的坐标系统<xref:System.Drawing.Graphics>对象。 坐标系统以及如何对其进行操作的详细信息，请参阅[坐标系和坐标转换](~/docs/framework/winforms/advanced/coordinate-systems-and-transformations.md)。  
  
   
  
## Examples  
 下面的代码示例设计为使用 Windows 窗体，并需要<xref:System.Windows.Forms.PaintEventArgs>对象。 <xref:System.Windows.Forms.PaintEventArgs>对象被命名为`e`和参数的<xref:System.Windows.Forms.Control.Paint>事件处理程序。 该代码执行下列操作：  
  
-   从 JPEG 文件创建映像。 该文件命名为 sampimag.jpg 位于同和位于该示例的文件夹中。  
  
-   创建在其中绘制图像的左上角的点。  
  
-   通过将不成比例的图像绘制到屏幕<xref:System.Drawing.Graphics>对象。  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples#40](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CPP/form1.cpp#40)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples#40](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CS/form1.cs#40)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples#40](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/VB/form1.vb#40)]  
  
 ]]></format>
    </remarks>
    <related type="Article" href="https://msdn.microsoft.com/library/162861f9-f050-445e-8abb-b2c43a918b8b">如何：创建用于绘制的 Graphics 对象</related>
    <related type="Article" href="https://msdn.microsoft.com/library/eb0f6d6f-9e52-4167-9592-ff4b82fb5869">图形编程入门</related>
    <related type="Article" href="https://msdn.microsoft.com/library/6207cad1-7a34-4bd6-bfc1-db823ca7a73e">管理 Graphics 对象的状态</related>
  </Docs>
  <Members>
    <Member MemberName="AddMetafileComment">
      <MemberSignature Language="C#" Value="public void AddMetafileComment (byte[] data);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddMetafileComment(unsigned int8[] data) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.AddMetafileComment(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddMetafileComment (data As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddMetafileComment(cli::array &lt;System::Byte&gt; ^ data);" />
      <MemberSignature Language="F#" Value="member this.AddMetafileComment : byte[] -&gt; unit" Usage="graphics.AddMetafileComment data" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="data">包含注释的字节的数组。</param>
        <summary>向当前 <see cref="T:System.Drawing.Imaging.Metafile" /> 添加注释。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法是仅当此有效<xref:System.Drawing.Graphics>与关联<xref:System.Drawing.Imaging.Metafile>。  
  
   
  
## Examples  
 下面的代码示例设计为使用 Windows 窗体，并且它需要<xref:System.Windows.Forms.PaintEventArgs> `e`，这是一个参数的<xref:System.Windows.Forms.Control.Paint>事件处理程序，以及`thisForm`，则<xref:System.Windows.Forms.Form>的示例。 该代码执行下列操作：  
  
-   创建一个临时<xref:System.Drawing.Graphics>用于创建的图元文件和获取`hdc`，其设备上下文的句柄。  
  
-   创建一个新的图元文件使用`hdc`。  
  
-   创建<xref:System.Drawing.Graphics>以显示图元文件从<xref:System.Drawing.Imaging.Metafile>。  
  
-   向图元文件绘制一个矩形。  
  
-   将注释添加到图元文件。  
  
-   释放<xref:System.Drawing.Graphics>的图元文件对象关闭图元文件。  
  
-   释放图元文件。  
  
-   释放该临时`hdc`。  
  
-   释放该临时<xref:System.Drawing.Graphics>。  
  
-   从以前创建的文件创建第二个图元文件。  
  
-   将图元文件绘制到屏幕。  
  
-   释放图元文件。  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CPP/form1.cpp#1)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CS/form1.cs#1)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginContainer">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>保存具有此 <see cref="T:System.Drawing.Graphics" /> 的当前状态的图形容器，然后打开并使用新的图形容器。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginContainer">
      <MemberSignature Language="C#" Value="public System.Drawing.Drawing2D.GraphicsContainer BeginContainer ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Drawing.Drawing2D.GraphicsContainer BeginContainer() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.BeginContainer" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginContainer () As GraphicsContainer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Drawing::Drawing2D::GraphicsContainer ^ BeginContainer();" />
      <MemberSignature Language="F#" Value="member this.BeginContainer : unit -&gt; System.Drawing.Drawing2D.GraphicsContainer" Usage="graphics.BeginContainer " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Drawing2D.GraphicsContainer</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>保存具有此 <see cref="T:System.Drawing.Graphics" /> 的当前状态的图形容器，然后打开并使用新的图形容器。</summary>
        <returns>此方法返回一个 <see cref="T:System.Drawing.Drawing2D.GraphicsContainer" />，该对象表示该方法调用运行时此 <see cref="T:System.Drawing.Graphics" /> 的状态。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 将此方法用于<xref:System.Drawing.Graphics.EndContainer%2A>方法来创建嵌套的图形容器。 图形容器保留的图形状态，例如转换、 剪辑区域和呈现属性。  
  
 当您调用<xref:System.Drawing.Graphics.BeginContainer%2A>方法<xref:System.Drawing.Graphics>，保存的状态信息块<xref:System.Drawing.Graphics>放在堆栈上。 <xref:System.Drawing.Graphics.BeginContainer%2A>方法将返回<xref:System.Drawing.Drawing2D.GraphicsContainer>，用于标识该信息块。 当您标识将对象传递给<xref:System.Drawing.Graphics.EndContainer%2A>方法，该信息块从堆栈中移除并用于还原<xref:System.Drawing.Graphics>时的状态为<xref:System.Drawing.Graphics.BeginContainer%2A>方法调用。  
  
 可以嵌套容器;也就是说，可以调用<xref:System.Drawing.Graphics.BeginContainer%2A>方法在调用之前几次<xref:System.Drawing.Graphics.EndContainer%2A>方法。 每次调用<xref:System.Drawing.Graphics.BeginContainer%2A>方法中，信息块放置在堆栈上，并且您收到<xref:System.Drawing.Drawing2D.GraphicsContainer>信息块。 当传递到这些对象之一<xref:System.Drawing.Graphics.EndContainer%2A>方法，<xref:System.Drawing.Graphics>返回到它所处的时间的状态<xref:System.Drawing.Graphics.BeginContainer%2A>方法调用返回了该特定<xref:System.Drawing.Drawing2D.GraphicsContainer>。 信息块放置在堆栈上的<xref:System.Drawing.Graphics.BeginContainer%2A>方法调用将从堆栈中，删除，所有信息块后，都放置在该堆栈上<xref:System.Drawing.Graphics.BeginContainer%2A>方法调用也将被删除。  
  
 调用<xref:System.Drawing.Graphics.Save%2A>方法相同调用堆栈上的位置信息块<xref:System.Drawing.Graphics.BeginContainer%2A>方法。 就像<xref:System.Drawing.Graphics.EndContainer%2A>方法调用搭配<xref:System.Drawing.Graphics.BeginContainer%2A>方法调用<xref:System.Drawing.Graphics.Restore%2A>方法调用搭配<xref:System.Drawing.Graphics.Save%2A>方法调用。  
  
 当您调用<xref:System.Drawing.Graphics.EndContainer%2A>方法中，所有信息块都放置在堆栈上 (通过<xref:System.Drawing.Graphics.Save%2A>方法或通过<xref:System.Drawing.Graphics.BeginContainer%2A>方法) 后的对应调用<xref:System.Drawing.Graphics.BeginContainer%2A>方法从堆栈中移除。 同样，当您调用<xref:System.Drawing.Graphics.Restore%2A>方法中，所有信息块都放置在堆栈上 (通过<xref:System.Drawing.Graphics.Save%2A>方法或通过<xref:System.Drawing.Graphics.BeginContainer%2A>方法) 后的对应调用<xref:System.Drawing.Graphics.Save%2A>方法从堆栈中移除。  
  
 图形状态由<xref:System.Drawing.Graphics.BeginContainer%2A>方法包括默认图形状态的呈现质量; 任何呈现质量状态更改时调用的方法的现有重置为默认值。  
  
   
  
## Examples  
 下面的代码示例设计为使用 Windows 窗体，并且它需要<xref:System.Windows.Forms.PaintEventArgs> `e`，这是一个参数的<xref:System.Windows.Forms.Control.Paint>事件处理程序。 该代码执行下列操作：  
  
-   打开新的图形容器，并保存旧的容器。  
  
-   将转换的世界坐标以容器。  
  
-   填入一个红色矩形 (转换的坐标) 新的容器。  
  
-   关闭新的容器并将还原已保存的容器。  
  
-   填充已保存容器的绿色矩形 （为未转换的坐标中）。  
  
 结果是覆盖相同大小的红色矩形之上的绿色矩形。  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples#2](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CPP/form1.cpp#2)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples#2](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CS/form1.cs#2)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/VB/form1.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginContainer">
      <MemberSignature Language="C#" Value="public System.Drawing.Drawing2D.GraphicsContainer BeginContainer (System.Drawing.Rectangle dstrect, System.Drawing.Rectangle srcrect, System.Drawing.GraphicsUnit unit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Drawing.Drawing2D.GraphicsContainer BeginContainer(valuetype System.Drawing.Rectangle dstrect, valuetype System.Drawing.Rectangle srcrect, valuetype System.Drawing.GraphicsUnit unit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.BeginContainer(System.Drawing.Rectangle,System.Drawing.Rectangle,System.Drawing.GraphicsUnit)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginContainer (dstrect As Rectangle, srcrect As Rectangle, unit As GraphicsUnit) As GraphicsContainer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Drawing::Drawing2D::GraphicsContainer ^ BeginContainer(System::Drawing::Rectangle dstrect, System::Drawing::Rectangle srcrect, System::Drawing::GraphicsUnit unit);" />
      <MemberSignature Language="F#" Value="member this.BeginContainer : System.Drawing.Rectangle * System.Drawing.Rectangle * System.Drawing.GraphicsUnit -&gt; System.Drawing.Drawing2D.GraphicsContainer" Usage="graphics.BeginContainer (dstrect, srcrect, unit)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Drawing2D.GraphicsContainer</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dstrect" Type="System.Drawing.Rectangle" />
        <Parameter Name="srcrect" Type="System.Drawing.Rectangle" />
        <Parameter Name="unit" Type="System.Drawing.GraphicsUnit" />
      </Parameters>
      <Docs>
        <param name="dstrect">
          <see cref="T:System.Drawing.Rectangle" /> 结构，它与 <c>srcrect</c> 参数一起为容器指定缩放变换。</param>
        <param name="srcrect">
          <see cref="T:System.Drawing.Rectangle" /> 结构，它与 <c>dstrect</c> 参数一起为容器指定缩放变换。</param>
        <param name="unit">
          <see cref="T:System.Drawing.GraphicsUnit" /> 枚举的成员，它指定容器的度量单位。</param>
        <summary>保存具有此 <see cref="T:System.Drawing.Graphics" /> 的当前状态的图形容器，然后打开并使用具有指定缩放变形的新图形容器。</summary>
        <returns>此方法返回一个 <see cref="T:System.Drawing.Drawing2D.GraphicsContainer" />，该对象表示该方法调用运行时此 <see cref="T:System.Drawing.Graphics" /> 的状态。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 将此方法用于<xref:System.Drawing.Graphics.EndContainer%2A>方法来创建嵌套的图形容器。 图形容器保留的图形状态，例如转换、 剪辑区域和呈现属性。  
  
 当您调用<xref:System.Drawing.Graphics.BeginContainer%2A>方法<xref:System.Drawing.Graphics>，保存的状态信息块<xref:System.Drawing.Graphics>放在堆栈上。 <xref:System.Drawing.Graphics.BeginContainer%2A>方法将返回<xref:System.Drawing.Drawing2D.GraphicsContainer>，用于标识该信息块。 当您标识将对象传递给<xref:System.Drawing.Graphics.EndContainer%2A>方法，该信息块从堆栈中移除并用于还原<xref:System.Drawing.Graphics>时的状态为<xref:System.Drawing.Graphics.BeginContainer%2A>方法调用。  
  
 可以嵌套容器;也就是说，可以调用<xref:System.Drawing.Graphics.BeginContainer%2A>方法在调用之前几次<xref:System.Drawing.Graphics.EndContainer%2A>方法。 每次调用<xref:System.Drawing.Graphics.BeginContainer%2A>方法中，信息块放置在堆栈上，并且您收到<xref:System.Drawing.Drawing2D.GraphicsContainer>信息块。 当传递到这些对象之一<xref:System.Drawing.Graphics.EndContainer%2A>方法，<xref:System.Drawing.Graphics>返回到它所处的时间的状态<xref:System.Drawing.Graphics.BeginContainer%2A>方法调用返回了该特定<xref:System.Drawing.Drawing2D.GraphicsContainer>。 信息块放置在堆栈上的<xref:System.Drawing.Graphics.BeginContainer%2A>方法调用将从堆栈中，删除，所有信息块后，都放置在该堆栈上<xref:System.Drawing.Graphics.BeginContainer%2A>方法调用也将被删除。  
  
 调用<xref:System.Drawing.Graphics.Save%2A>方法相同调用堆栈上的位置信息块<xref:System.Drawing.Graphics.BeginContainer%2A>方法。 就像<xref:System.Drawing.Graphics.EndContainer%2A>方法调用搭配<xref:System.Drawing.Graphics.BeginContainer%2A>方法调用<xref:System.Drawing.Graphics.Restore%2A>方法调用搭配<xref:System.Drawing.Graphics.Save%2A>方法调用。  
  
 当您调用<xref:System.Drawing.Graphics.EndContainer%2A>方法中，所有信息块都放置在堆栈上 (通过<xref:System.Drawing.Graphics.Save%2A>方法或通过<xref:System.Drawing.Graphics.BeginContainer%2A>方法) 后的对应调用<xref:System.Drawing.Graphics.BeginContainer%2A>方法从堆栈中移除。 同样，当您调用<xref:System.Drawing.Graphics.Restore%2A>方法中，所有信息块都放置在堆栈上 (通过<xref:System.Drawing.Graphics.Save%2A>方法或通过<xref:System.Drawing.Graphics.BeginContainer%2A>方法) 后的对应调用<xref:System.Drawing.Graphics.Save%2A>方法从堆栈中移除。  
  
 此方法指定缩放变换为与新的图形容器`dstrect`和`srcrect`参数。 小数位数等于转换，当应用于`srcrect`，会导致`dstrect`。  
  
 图形状态由<xref:System.Drawing.Graphics.BeginContainer%2A>方法包括默认图形状态的呈现质量; 任何呈现质量状态更改时调用的方法的现有重置为默认值。  
  
   
  
## Examples  
 下面的代码示例设计为使用 Windows 窗体，并且它需要<xref:System.Windows.Forms.PaintEventArgs> `e`，这是一个参数的<xref:System.Windows.Forms.Control.Paint>事件处理程序。 该代码执行下列操作：  
  
-   创建两个矩形指定缩放变换为新的容器。  
  
-   打开新的图形容器，并保存旧的容器。  
  
-   填入一个红色矩形 (缩放的坐标) 新的容器。  
  
-   关闭新的容器并将还原已保存的容器。  
  
-   填充已保存容器的绿色矩形 （为不成比例的坐标中）。  
  
 结果是覆盖较小的红色矩形之上的绿色矩形。  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples#3](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CPP/form1.cpp#3)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples#3](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CS/form1.cs#3)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples#3](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/VB/form1.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginContainer">
      <MemberSignature Language="C#" Value="public System.Drawing.Drawing2D.GraphicsContainer BeginContainer (System.Drawing.RectangleF dstrect, System.Drawing.RectangleF srcrect, System.Drawing.GraphicsUnit unit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Drawing.Drawing2D.GraphicsContainer BeginContainer(valuetype System.Drawing.RectangleF dstrect, valuetype System.Drawing.RectangleF srcrect, valuetype System.Drawing.GraphicsUnit unit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.BeginContainer(System.Drawing.RectangleF,System.Drawing.RectangleF,System.Drawing.GraphicsUnit)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginContainer (dstrect As RectangleF, srcrect As RectangleF, unit As GraphicsUnit) As GraphicsContainer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Drawing::Drawing2D::GraphicsContainer ^ BeginContainer(System::Drawing::RectangleF dstrect, System::Drawing::RectangleF srcrect, System::Drawing::GraphicsUnit unit);" />
      <MemberSignature Language="F#" Value="member this.BeginContainer : System.Drawing.RectangleF * System.Drawing.RectangleF * System.Drawing.GraphicsUnit -&gt; System.Drawing.Drawing2D.GraphicsContainer" Usage="graphics.BeginContainer (dstrect, srcrect, unit)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Drawing2D.GraphicsContainer</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dstrect" Type="System.Drawing.RectangleF" />
        <Parameter Name="srcrect" Type="System.Drawing.RectangleF" />
        <Parameter Name="unit" Type="System.Drawing.GraphicsUnit" />
      </Parameters>
      <Docs>
        <param name="dstrect">
          <see cref="T:System.Drawing.RectangleF" /> 结构，它与 <c>srcrect</c> 参数一起为新的图形容器指定缩放变换。</param>
        <param name="srcrect">
          <see cref="T:System.Drawing.RectangleF" /> 结构，它与 <c>dstrect</c> 参数一起为新的图形容器指定缩放变换。</param>
        <param name="unit">
          <see cref="T:System.Drawing.GraphicsUnit" /> 枚举的成员，它指定容器的度量单位。</param>
        <summary>保存具有此 <see cref="T:System.Drawing.Graphics" /> 的当前状态的图形容器，然后打开并使用具有指定缩放变形的新图形容器。</summary>
        <returns>此方法返回一个 <see cref="T:System.Drawing.Drawing2D.GraphicsContainer" />，该对象表示该方法调用运行时此 <see cref="T:System.Drawing.Graphics" /> 的状态。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 将此方法用于<xref:System.Drawing.Graphics.EndContainer%2A>方法来创建嵌套的图形容器。 图形容器保留的图形状态，例如转换、 剪辑区域和呈现属性。  
  
 当您调用<xref:System.Drawing.Graphics.BeginContainer%2A>方法<xref:System.Drawing.Graphics>，保存的状态信息块<xref:System.Drawing.Graphics>放在堆栈上。 <xref:System.Drawing.Graphics.BeginContainer%2A>方法将返回<xref:System.Drawing.Drawing2D.GraphicsContainer>，用于标识该信息块。 当您标识将对象传递给<xref:System.Drawing.Graphics.EndContainer%2A>方法，该信息块从堆栈中移除并用于还原<xref:System.Drawing.Graphics>时的状态为<xref:System.Drawing.Graphics.BeginContainer%2A>方法调用。  
  
 可以嵌套容器;也就是说，可以调用<xref:System.Drawing.Graphics.BeginContainer%2A>方法在调用之前几次<xref:System.Drawing.Graphics.EndContainer%2A>方法。 每次调用<xref:System.Drawing.Graphics.BeginContainer%2A>方法中，信息块放置在堆栈上，并且您收到<xref:System.Drawing.Drawing2D.GraphicsContainer>信息块。 当传递到这些对象之一<xref:System.Drawing.Graphics.EndContainer%2A>方法，<xref:System.Drawing.Graphics>返回到它所处的时间的状态<xref:System.Drawing.Graphics.BeginContainer%2A>方法调用返回了该特定<xref:System.Drawing.Drawing2D.GraphicsContainer>。 信息块放置在堆栈上的<xref:System.Drawing.Graphics.BeginContainer%2A>方法调用将从堆栈中，删除，所有信息块后，都放置在该堆栈上<xref:System.Drawing.Graphics.BeginContainer%2A>方法调用也将被删除。  
  
 调用<xref:System.Drawing.Graphics.Save%2A>方法相同调用堆栈上的位置信息块<xref:System.Drawing.Graphics.BeginContainer%2A>方法。 就像<xref:System.Drawing.Graphics.EndContainer%2A>方法调用搭配<xref:System.Drawing.Graphics.BeginContainer%2A>方法调用<xref:System.Drawing.Graphics.Restore%2A>方法调用搭配<xref:System.Drawing.Graphics.Save%2A>方法调用。  
  
 当您调用<xref:System.Drawing.Graphics.EndContainer%2A>方法中，所有信息块都放置在堆栈上 (通过`Save`方法或通过<xref:System.Drawing.Graphics.BeginContainer%2A>方法) 后的对应调用<xref:System.Drawing.Graphics.BeginContainer%2A>方法从堆栈中移除。 同样，当您调用<xref:System.Drawing.Graphics.Restore%2A>方法中，所有信息块都放置在堆栈上 (通过<xref:System.Drawing.Graphics.Save%2A>方法或通过<xref:System.Drawing.Graphics.BeginContainer%2A>方法) 后的对应调用<xref:System.Drawing.Graphics.Save%2A>方法从堆栈中移除。  
  
 此方法指定缩放变换为与新的图形容器`dstrect`和`srcrect`参数。 小数位数等于转换，当应用于`srcrect`，会导致`dstrect`。  
  
 图形状态由<xref:System.Drawing.Graphics.BeginContainer%2A>方法包括默认图形状态的呈现质量; 任何呈现质量状态更改时调用的方法的现有重置为默认值。  
  
   
  
## Examples  
 下面的代码示例设计为使用 Windows 窗体，并且它需要<xref:System.Windows.Forms.PaintEventArgs> `e`，这是一个参数的<xref:System.Windows.Forms.Control.Paint>事件处理程序。 该代码执行下列操作：  
  
-   创建两个矩形指定缩放变换为新的容器。  
  
-   打开新的图形容器，并保存旧的容器。  
  
-   填入一个红色矩形 (缩放的坐标) 新的容器。  
  
-   关闭新的容器并将还原已保存的容器。  
  
-   填充已保存容器的绿色矩形 （为不成比例的坐标中）。  
  
 结果是覆盖较小的红色矩形之上的绿色矩形。  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples#4](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CPP/form1.cpp#4)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples#4](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CS/form1.cs#4)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples#4](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/VB/form1.vb#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public void Clear (System.Drawing.Color color);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Clear(valuetype System.Drawing.Color color) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.Clear(System.Drawing.Color)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Clear(System::Drawing::Color color);" />
      <MemberSignature Language="F#" Value="member this.Clear : System.Drawing.Color -&gt; unit" Usage="graphics.Clear color" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="color" Type="System.Drawing.Color" />
      </Parameters>
      <Docs>
        <param name="color">
          <see cref="T:System.Drawing.Color" /> 结构，它表示绘图面的背景色。</param>
        <summary>清除整个绘图面并以指定背景色填充。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Drawing.Graphics.Clear%2A>方法清除图形对象的状态并不能更新图形对象时不应调用。 例如，如果<xref:System.Drawing.Graphics.Clear%2A>在终端服务器会话中，在安全桌面上上调用方法<xref:System.Runtime.InteropServices.ExternalException>可能会发生，离开<xref:System.Drawing.Graphics>处于不一致状态的对象。  
  
   
  
## Examples  
 下面的代码示例设计为使用 Windows 窗体，并且它需要<xref:System.Windows.Forms.PaintEventArgs> `e`，这是一个参数的<xref:System.Windows.Forms.Control.Paint>事件处理程序。 则代码将清除绘图图面的<xref:System.Drawing.Graphics>将背景颜色设置为系统定义的青色。  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples#5](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CPP/form1.cpp#5)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples#5](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CS/form1.cs#5)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples#5](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/VB/form1.vb#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Clip">
      <MemberSignature Language="C#" Value="public System.Drawing.Region Clip { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Drawing.Region Clip" />
      <MemberSignature Language="DocId" Value="P:System.Drawing.Graphics.Clip" />
      <MemberSignature Language="VB.NET" Value="Public Property Clip As Region" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::Region ^ Clip { System::Drawing::Region ^ get(); void set(System::Drawing::Region ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Clip : System.Drawing.Region with get, set" Usage="System.Drawing.Graphics.Clip" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Region</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置 <see cref="T:System.Drawing.Region" />，它限定此 <see cref="T:System.Drawing.Graphics" /> 的绘图区域。</summary>
        <value>一个 <see cref="T:System.Drawing.Region" />，它限定此 <see cref="T:System.Drawing.Graphics" /> 当前可用的绘图区域。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 修改<xref:System.Drawing.Region>返回的对象<xref:System.Drawing.Graphics.Clip%2A>属性不会影响后续绘制与<xref:System.Drawing.Graphics>对象。 若要更改的剪辑区域，请替换<xref:System.Drawing.Graphics.Clip%2A>具有一个新属性值<xref:System.Drawing.Region>对象。 若要确定的剪辑区域是否为无限，检索<xref:System.Drawing.Graphics.Clip%2A>属性并调用其<xref:System.Drawing.Region.IsInfinite%2A>方法。  
  
   
  
## Examples  
 下面的代码示例演示如何将<xref:System.Drawing.Graphics.Clip%2A>属性。 此示例旨在与 Windows 窗体一起使用。 将代码粘贴到窗体并调用`SetAndFillClip`方法时处理该窗体<xref:System.Windows.Forms.Control.Paint>事件，并传递`e`作为<xref:System.Windows.Forms.PaintEventArgs>。  
  
 [!code-cpp[System.Drawing.GraphicsProperties#4](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.GraphicsProperties/CPP/form1.cpp#4)]
 [!code-csharp[System.Drawing.GraphicsProperties#4](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.GraphicsProperties/CS/form1.cs#4)]
 [!code-vb[System.Drawing.GraphicsProperties#4](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.GraphicsProperties/VB/form1.vb#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ClipBounds">
      <MemberSignature Language="C#" Value="public System.Drawing.RectangleF ClipBounds { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.RectangleF ClipBounds" />
      <MemberSignature Language="DocId" Value="P:System.Drawing.Graphics.ClipBounds" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ClipBounds As RectangleF" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::RectangleF ClipBounds { System::Drawing::RectangleF get(); };" />
      <MemberSignature Language="F#" Value="member this.ClipBounds : System.Drawing.RectangleF" Usage="System.Drawing.Graphics.ClipBounds" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.RectangleF</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个 <see cref="T:System.Drawing.RectangleF" /> 结构，该结构限定此 <see cref="T:System.Drawing.Graphics" /> 的剪辑区域。</summary>
        <value>一个 <see cref="T:System.Drawing.RectangleF" /> 结构，它表示此 <see cref="T:System.Drawing.Graphics" /> 的剪辑区域的边框。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 所得矩形的大小的单位由<xref:System.Drawing.Graphics.PageUnit%2A>属性。 默认单位为像素。 一个<xref:System.Drawing.Graphics>通常与控件相关联，该矩形的原点将相对于该控件的客户端区域。  
  
 如果的剪辑区域为无限，<xref:System.Drawing.Graphics.ClipBounds%2A>属性将返回无意义的大矩形。 若要确定的剪辑区域是否为无限，检索<xref:System.Drawing.Graphics.Clip%2A>属性并调用其<xref:System.Drawing.Region.IsInfinite%2A>方法。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CompositingMode">
      <MemberSignature Language="C#" Value="public System.Drawing.Drawing2D.CompositingMode CompositingMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Drawing2D.CompositingMode CompositingMode" />
      <MemberSignature Language="DocId" Value="P:System.Drawing.Graphics.CompositingMode" />
      <MemberSignature Language="VB.NET" Value="Public Property CompositingMode As CompositingMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::Drawing2D::CompositingMode CompositingMode { System::Drawing::Drawing2D::CompositingMode get(); void set(System::Drawing::Drawing2D::CompositingMode value); };" />
      <MemberSignature Language="F#" Value="member this.CompositingMode : System.Drawing.Drawing2D.CompositingMode with get, set" Usage="System.Drawing.Graphics.CompositingMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Drawing2D.CompositingMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指定如何将合成图像绘制到此 <see cref="T:System.Drawing.Graphics" />。</summary>
        <value>此属性指定 <see cref="T:System.Drawing.Drawing2D.CompositingMode" /> 枚举的成员。 默认值为 <see cref="F:System.Drawing.Drawing2D.CompositingMode.SourceOver" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 复合模式确定从源映像的像素是覆盖还是组合使用背景像素。  
  
> [!NOTE]
>  不应使用<xref:System.Drawing.Graphics.CompositingMode%2A>属性值为<xref:System.Drawing.Drawing2D.CompositingMode.SourceCopy>时<xref:System.Drawing.Graphics.TextRenderingHint%2A>属性设置为<xref:System.Drawing.Text.TextRenderingHint.ClearTypeGridFit>。 可能会发生异常或图像可能无法正确呈现。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CompositingQuality">
      <MemberSignature Language="C#" Value="public System.Drawing.Drawing2D.CompositingQuality CompositingQuality { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Drawing2D.CompositingQuality CompositingQuality" />
      <MemberSignature Language="DocId" Value="P:System.Drawing.Graphics.CompositingQuality" />
      <MemberSignature Language="VB.NET" Value="Public Property CompositingQuality As CompositingQuality" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::Drawing2D::CompositingQuality CompositingQuality { System::Drawing::Drawing2D::CompositingQuality get(); void set(System::Drawing::Drawing2D::CompositingQuality value); };" />
      <MemberSignature Language="F#" Value="member this.CompositingQuality : System.Drawing.Drawing2D.CompositingQuality with get, set" Usage="System.Drawing.Graphics.CompositingQuality" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Drawing2D.CompositingQuality</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置绘制到此 <see cref="T:System.Drawing.Graphics" /> 的合成图像的呈现质量。</summary>
        <value>此属性指定 <see cref="T:System.Drawing.Drawing2D.CompositingQuality" /> 枚举的成员。 默认值为 <see cref="F:System.Drawing.Drawing2D.CompositingQuality.Default" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 组合的情况下质量决定将合成图像的呈现质量级别。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="CopyFromScreen">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>执行颜色数据从屏幕到 <see cref="T:System.Drawing.Graphics" /> 的绘图图面的位块传输。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CopyFromScreen">
      <MemberSignature Language="C#" Value="public void CopyFromScreen (System.Drawing.Point upperLeftSource, System.Drawing.Point upperLeftDestination, System.Drawing.Size blockRegionSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CopyFromScreen(valuetype System.Drawing.Point upperLeftSource, valuetype System.Drawing.Point upperLeftDestination, valuetype System.Drawing.Size blockRegionSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.CopyFromScreen(System.Drawing.Point,System.Drawing.Point,System.Drawing.Size)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyFromScreen (upperLeftSource As Point, upperLeftDestination As Point, blockRegionSize As Size)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyFromScreen(System::Drawing::Point upperLeftSource, System::Drawing::Point upperLeftDestination, System::Drawing::Size blockRegionSize);" />
      <MemberSignature Language="F#" Value="member this.CopyFromScreen : System.Drawing.Point * System.Drawing.Point * System.Drawing.Size -&gt; unit" Usage="graphics.CopyFromScreen (upperLeftSource, upperLeftDestination, blockRegionSize)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="upperLeftSource" Type="System.Drawing.Point" />
        <Parameter Name="upperLeftDestination" Type="System.Drawing.Point" />
        <Parameter Name="blockRegionSize" Type="System.Drawing.Size" />
      </Parameters>
      <Docs>
        <param name="upperLeftSource">位于源矩形左上角的点。</param>
        <param name="upperLeftDestination">位于目标矩形左上角的点。</param>
        <param name="blockRegionSize">要传输的区域大小。</param>
        <summary>执行颜色数据（对应于由像素组成的矩形）从屏幕到 <see cref="T:System.Drawing.Graphics" /> 的绘图图面的位块传输。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Drawing.Graphics.CopyFromScreen%2A>方法可用于基于另一个分层一个映像。 若要指定如何混合源和目标颜色，请使用之一<xref:System.Drawing.Graphics.CopyFromScreen%2A>方法采用<xref:System.Drawing.CopyPixelOperation>参数。  
  
   
  
## Examples  
 下面的示例演示如何使用 <xref:System.Drawing.Graphics.CopyFromScreen%2A> 方法。 若要运行此示例中，将其粘贴到 Windows 窗体。 处理该窗体<xref:System.Windows.Forms.Control.Paint>事件，并调用`CopyPixels1`方法从<xref:System.Windows.Forms.Control.Paint>事件处理方法，传递`e`作为<xref:System.Windows.Forms.PaintEventArgs>。  
  
 [!code-csharp[System.Drawing.MiscWhidbeySnippets#4](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.MiscWhidbeySnippets/CS/Form1.cs#4)]
 [!code-vb[System.Drawing.MiscWhidbeySnippets#4](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.MiscWhidbeySnippets/VB/Form1.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">操作失败。</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">用于访问所有窗口。 相关的枚举： <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" />。</permission>
        <related type="Article" href="https://msdn.microsoft.com/library/c8dff5f8-f56a-4c07-ae31-64643b31f8fc">如何：打印 Windows 窗体</related>
        <related type="Article" href="https://msdn.microsoft.com/library/33b76910-13a3-4521-be98-5c097341ae3b">如何： 复制像素以减少在 Windows 窗体中的闪烁</related>
      </Docs>
    </Member>
    <Member MemberName="CopyFromScreen">
      <MemberSignature Language="C#" Value="public void CopyFromScreen (System.Drawing.Point upperLeftSource, System.Drawing.Point upperLeftDestination, System.Drawing.Size blockRegionSize, System.Drawing.CopyPixelOperation copyPixelOperation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CopyFromScreen(valuetype System.Drawing.Point upperLeftSource, valuetype System.Drawing.Point upperLeftDestination, valuetype System.Drawing.Size blockRegionSize, valuetype System.Drawing.CopyPixelOperation copyPixelOperation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.CopyFromScreen(System.Drawing.Point,System.Drawing.Point,System.Drawing.Size,System.Drawing.CopyPixelOperation)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyFromScreen(System::Drawing::Point upperLeftSource, System::Drawing::Point upperLeftDestination, System::Drawing::Size blockRegionSize, System::Drawing::CopyPixelOperation copyPixelOperation);" />
      <MemberSignature Language="F#" Value="member this.CopyFromScreen : System.Drawing.Point * System.Drawing.Point * System.Drawing.Size * System.Drawing.CopyPixelOperation -&gt; unit" Usage="graphics.CopyFromScreen (upperLeftSource, upperLeftDestination, blockRegionSize, copyPixelOperation)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="upperLeftSource" Type="System.Drawing.Point" />
        <Parameter Name="upperLeftDestination" Type="System.Drawing.Point" />
        <Parameter Name="blockRegionSize" Type="System.Drawing.Size" />
        <Parameter Name="copyPixelOperation" Type="System.Drawing.CopyPixelOperation" />
      </Parameters>
      <Docs>
        <param name="upperLeftSource">位于源矩形左上角的点。</param>
        <param name="upperLeftDestination">位于目标矩形左上角的点。</param>
        <param name="blockRegionSize">要传输的区域大小。</param>
        <param name="copyPixelOperation">
          <see cref="T:System.Drawing.CopyPixelOperation" /> 值之一。</param>
        <summary>执行颜色数据（对应于由像素组成的矩形）从屏幕到 <see cref="T:System.Drawing.Graphics" /> 的绘图图面的位块传输。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Drawing.Graphics.CopyFromScreen%2A>方法可用于基于另一个分层一个映像。 `copyPixelOperation`参数允许您指定如果和源颜色如何应与目标区域中的颜色混合。  
  
   
  
## Examples  
 下面的示例演示如何使用 <xref:System.Drawing.Graphics.CopyFromScreen%2A> 方法。 若要运行此示例中，将其粘贴到 Windows 窗体。 处理该窗体<xref:System.Windows.Forms.Control.Paint>事件，并调用`CopyPixels2`方法从<xref:System.Windows.Forms.Control.Paint>事件处理方法，传递`e`作为<xref:System.Windows.Forms.PaintEventArgs>。  
  
 [!code-csharp[System.Drawing.MiscWhidbeySnippets#5](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.MiscWhidbeySnippets/CS/Form1.cs#5)]
 [!code-vb[System.Drawing.MiscWhidbeySnippets#5](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.MiscWhidbeySnippets/VB/Form1.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="copyPixelOperation" /> 不是 <see cref="T:System.Drawing.CopyPixelOperation" /> 的成员。</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">操作失败。</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">用于访问所有窗口。 相关的枚举： <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" />。</permission>
        <related type="Article" href="https://msdn.microsoft.com/library/c8dff5f8-f56a-4c07-ae31-64643b31f8fc">如何：打印 Windows 窗体</related>
        <related type="Article" href="https://msdn.microsoft.com/library/33b76910-13a3-4521-be98-5c097341ae3b">如何： 复制像素以减少在 Windows 窗体中的闪烁</related>
      </Docs>
    </Member>
    <Member MemberName="CopyFromScreen">
      <MemberSignature Language="C#" Value="public void CopyFromScreen (int sourceX, int sourceY, int destinationX, int destinationY, System.Drawing.Size blockRegionSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CopyFromScreen(int32 sourceX, int32 sourceY, int32 destinationX, int32 destinationY, valuetype System.Drawing.Size blockRegionSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.CopyFromScreen(System.Int32,System.Int32,System.Int32,System.Int32,System.Drawing.Size)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyFromScreen (sourceX As Integer, sourceY As Integer, destinationX As Integer, destinationY As Integer, blockRegionSize As Size)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyFromScreen(int sourceX, int sourceY, int destinationX, int destinationY, System::Drawing::Size blockRegionSize);" />
      <MemberSignature Language="F#" Value="member this.CopyFromScreen : int * int * int * int * System.Drawing.Size -&gt; unit" Usage="graphics.CopyFromScreen (sourceX, sourceY, destinationX, destinationY, blockRegionSize)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceX" Type="System.Int32" />
        <Parameter Name="sourceY" Type="System.Int32" />
        <Parameter Name="destinationX" Type="System.Int32" />
        <Parameter Name="destinationY" Type="System.Int32" />
        <Parameter Name="blockRegionSize" Type="System.Drawing.Size" />
      </Parameters>
      <Docs>
        <param name="sourceX">位于源矩形左上角的点的 x 坐标。</param>
        <param name="sourceY">位于源矩形左上角的点的 y 坐标。</param>
        <param name="destinationX">位于目标矩形左上角的点的 x 坐标。</param>
        <param name="destinationY">位于目标矩形左上角的点的 y 坐标。</param>
        <param name="blockRegionSize">要传输的区域大小。</param>
        <summary>执行颜色数据（对应于由像素组成的矩形）从屏幕到 <see cref="T:System.Drawing.Graphics" /> 的绘图图面的位块传输。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Drawing.Graphics.CopyFromScreen%2A>方法可用于基于另一个分层一个映像。 若要指定如何混合源和目标颜色，请使用之一<xref:System.Drawing.Graphics.CopyFromScreen%2A>方法采用<xref:System.Drawing.CopyPixelOperation>参数。  
  
   
  
## Examples  
 下面的代码示例演示如何使用<xref:System.Drawing.Graphics.CopyFromScreen%2A>用于打印当前窗体的副本。  
  
 [!code-csharp[System.Drawing.Graphics.CopyFromScreen#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.Graphics.CopyFromScreen/CS/Form1.cs#1)]
 [!code-vb[System.Drawing.Graphics.CopyFromScreen#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.Graphics.CopyFromScreen/VB/Form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">操作失败。</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">用于访问所有窗口。 相关的枚举： <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" />。</permission>
        <related type="Article" href="https://msdn.microsoft.com/library/c8dff5f8-f56a-4c07-ae31-64643b31f8fc">如何：打印 Windows 窗体</related>
        <related type="Article" href="https://msdn.microsoft.com/library/33b76910-13a3-4521-be98-5c097341ae3b">如何： 复制像素以减少在 Windows 窗体中的闪烁</related>
      </Docs>
    </Member>
    <Member MemberName="CopyFromScreen">
      <MemberSignature Language="C#" Value="public void CopyFromScreen (int sourceX, int sourceY, int destinationX, int destinationY, System.Drawing.Size blockRegionSize, System.Drawing.CopyPixelOperation copyPixelOperation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CopyFromScreen(int32 sourceX, int32 sourceY, int32 destinationX, int32 destinationY, valuetype System.Drawing.Size blockRegionSize, valuetype System.Drawing.CopyPixelOperation copyPixelOperation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.CopyFromScreen(System.Int32,System.Int32,System.Int32,System.Int32,System.Drawing.Size,System.Drawing.CopyPixelOperation)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyFromScreen(int sourceX, int sourceY, int destinationX, int destinationY, System::Drawing::Size blockRegionSize, System::Drawing::CopyPixelOperation copyPixelOperation);" />
      <MemberSignature Language="F#" Value="member this.CopyFromScreen : int * int * int * int * System.Drawing.Size * System.Drawing.CopyPixelOperation -&gt; unit" Usage="graphics.CopyFromScreen (sourceX, sourceY, destinationX, destinationY, blockRegionSize, copyPixelOperation)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceX" Type="System.Int32" />
        <Parameter Name="sourceY" Type="System.Int32" />
        <Parameter Name="destinationX" Type="System.Int32" />
        <Parameter Name="destinationY" Type="System.Int32" />
        <Parameter Name="blockRegionSize" Type="System.Drawing.Size" />
        <Parameter Name="copyPixelOperation" Type="System.Drawing.CopyPixelOperation" />
      </Parameters>
      <Docs>
        <param name="sourceX">位于源矩形左上角的点的 x 坐标。</param>
        <param name="sourceY">位于源矩形左上角的点的 y 坐标</param>
        <param name="destinationX">位于目标矩形左上角的点的 x 坐标。</param>
        <param name="destinationY">位于目标矩形左上角的点的 y 坐标。</param>
        <param name="blockRegionSize">要传输的区域大小。</param>
        <param name="copyPixelOperation">
          <see cref="T:System.Drawing.CopyPixelOperation" /> 值之一。</param>
        <summary>执行颜色数据（对应于由像素组成的矩形）从屏幕到 <see cref="T:System.Drawing.Graphics" /> 的绘图图面的位块传输。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Drawing.Graphics.CopyFromScreen%2A>方法可用于基于另一个分层一个映像。 `copyPixelOperation`参数允许您指定如果和源颜色如何应与目标区域中的颜色混合。  
  
   
  
## Examples  
 下面的示例演示如何使用 <xref:System.Drawing.Graphics.CopyFromScreen%2A> 方法。 若要运行此示例中，将其粘贴到 Windows 窗体。 处理该窗体<xref:System.Windows.Forms.Control.Paint>事件，并调用`CopyPixels4`方法从<xref:System.Windows.Forms.Control.Paint>事件处理方法，传递`e`作为<xref:System.Windows.Forms.PaintEventArgs>。  
  
 [!code-csharp[System.Drawing.MiscWhidbeySnippets#7](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.MiscWhidbeySnippets/CS/Form1.cs#7)]
 [!code-vb[System.Drawing.MiscWhidbeySnippets#7](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.MiscWhidbeySnippets/VB/Form1.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="copyPixelOperation" /> 不是 <see cref="T:System.Drawing.CopyPixelOperation" /> 的成员。</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">操作失败。</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">用于访问所有窗口。 相关的枚举： <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" />。</permission>
        <related type="Article" href="https://msdn.microsoft.com/library/c8dff5f8-f56a-4c07-ae31-64643b31f8fc">如何：打印 Windows 窗体</related>
        <related type="Article" href="https://msdn.microsoft.com/library/33b76910-13a3-4521-be98-5c097341ae3b">如何： 复制像素以减少在 Windows 窗体中的闪烁</related>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="graphics.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>释放此 <see cref="T:System.Drawing.Graphics" /> 使用的所有资源。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 调用<xref:System.Drawing.Graphics.Dispose%2A>允许使用的资源<xref:System.Drawing.Graphics>重新分配用于其他目的。  
  
   
  
## Examples  
 下面的代码示例设计为使用 Windows 窗体，并且它需要<xref:System.Windows.Forms.PaintEventArgs> `e`，这是一个参数的<xref:System.Windows.Forms.Control.Paint>事件处理程序。 该代码执行下列操作：  
  
-   创建<xref:System.Drawing.Image>从一种图形文件 sampimag.jpg 位于同在示例目录中。  
  
-   创建<xref:System.Drawing.Graphics>从<xref:System.Drawing.Image>。  
  
-   通过填充在其中一个矩形来改变该图像。  
  
-   绘制<xref:System.Drawing.Image>到屏幕。  
  
-   释放所创建<xref:System.Drawing.Graphics>。  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples#6](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CPP/form1.cpp#6)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples#6](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CS/form1.cs#6)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples#6](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/VB/form1.vb#6)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DpiX">
      <MemberSignature Language="C#" Value="public float DpiX { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float32 DpiX" />
      <MemberSignature Language="DocId" Value="P:System.Drawing.Graphics.DpiX" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DpiX As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property float DpiX { float get(); };" />
      <MemberSignature Language="F#" Value="member this.DpiX : single" Usage="System.Drawing.Graphics.DpiX" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取此 <see cref="T:System.Drawing.Graphics" /> 的水平分辨率。</summary>
        <value>此 <see cref="T:System.Drawing.Graphics" /> 支持的水平分辨率的值（以每英寸点数为单位）。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 有关创建高分辨率应用程序的详细信息，请参阅  
  
 [高 DPI](https://go.microsoft.com/fwlink/?LinkId=159804)。  
  
   
  
## Examples  
 以下方法演示如何使用<xref:System.Drawing.Graphics.DpiX%2A>和<xref:System.Drawing.Graphics.DpiY%2A>属性。 此示例设计用于 Windows 窗体。 若要运行此示例，请将其粘贴到包含一个窗体<xref:System.Windows.Forms.ListBox>名为 listBox1 和从窗体的构造函数调用此方法。  
  
 [!code-cpp[System.Drawing.MiscExamples#4](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.MiscExamples/CPP/form1.cpp#4)]
 [!code-csharp[System.Drawing.MiscExamples#4](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.MiscExamples/CS/form1.cs#4)]
 [!code-vb[System.Drawing.MiscExamples#4](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.MiscExamples/VB/form1.vb#4)]  
  
 ]]></format>
        </remarks>
        <related type="ExternalDocumentation" href="https://go.microsoft.com/fwlink/?LinkId=159804">高 DPI</related>
      </Docs>
    </Member>
    <Member MemberName="DpiY">
      <MemberSignature Language="C#" Value="public float DpiY { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float32 DpiY" />
      <MemberSignature Language="DocId" Value="P:System.Drawing.Graphics.DpiY" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DpiY As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property float DpiY { float get(); };" />
      <MemberSignature Language="F#" Value="member this.DpiY : single" Usage="System.Drawing.Graphics.DpiY" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取此 <see cref="T:System.Drawing.Graphics" /> 的垂直分辨率。</summary>
        <value>此 <see cref="T:System.Drawing.Graphics" /> 支持的垂直分辨率的值（以每英寸点数为单位）。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 有关创建高分辨率应用程序的详细信息，请参阅  
  
 [高 DPI](https://go.microsoft.com/fwlink/?LinkId=159804)。  
  
   
  
## Examples  
 以下方法演示如何使用<xref:System.Drawing.Graphics.DpiX%2A>和<xref:System.Drawing.Graphics.DpiY%2A>属性。 此示例设计用于 Windows 窗体。 若要运行此示例，请将其粘贴到包含一个窗体<xref:System.Windows.Forms.ListBox>名为 listBox1 和从窗体的构造函数调用此方法。  
  
 [!code-cpp[System.Drawing.MiscExamples#4](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.MiscExamples/CPP/form1.cpp#4)]
 [!code-csharp[System.Drawing.MiscExamples#4](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.MiscExamples/CS/form1.cs#4)]
 [!code-vb[System.Drawing.MiscExamples#4](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.MiscExamples/VB/form1.vb#4)]  
  
 ]]></format>
        </remarks>
        <related type="ExternalDocumentation" href="https://go.microsoft.com/fwlink/?LinkId=159804">高 DPI</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="DrawArc">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>绘制一段弧线，它表示由一对坐标、宽度和高度指定的椭圆部分。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DrawArc">
      <MemberSignature Language="C#" Value="public void DrawArc (System.Drawing.Pen pen, System.Drawing.Rectangle rect, float startAngle, float sweepAngle);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawArc(class System.Drawing.Pen pen, valuetype System.Drawing.Rectangle rect, float32 startAngle, float32 sweepAngle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawArc(System.Drawing.Pen,System.Drawing.Rectangle,System.Single,System.Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawArc(System::Drawing::Pen ^ pen, System::Drawing::Rectangle rect, float startAngle, float sweepAngle);" />
      <MemberSignature Language="F#" Value="member this.DrawArc : System.Drawing.Pen * System.Drawing.Rectangle * single * single -&gt; unit" Usage="graphics.DrawArc (pen, rect, startAngle, sweepAngle)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pen" Type="System.Drawing.Pen" />
        <Parameter Name="rect" Type="System.Drawing.Rectangle" />
        <Parameter Name="startAngle" Type="System.Single" />
        <Parameter Name="sweepAngle" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="pen">
          <see cref="T:System.Drawing.Pen" />，它确定弧线的颜色、宽度和样式。</param>
        <param name="rect">
          <see cref="T:System.Drawing.RectangleF" /> 结构，它定义椭圆的边界。</param>
        <param name="startAngle">从 x 轴到弧线的起始点沿顺时针方向度量的角（以度为单位）。</param>
        <param name="sweepAngle">从 <c>startAngle</c> 参数到弧线的结束点沿顺时针方向度量的角（以度为单位）。</param>
        <summary>绘制一段弧线，它表示 <see cref="T:System.Drawing.Rectangle" /> 结构指定的椭圆的一部分。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法绘制一段弧线的椭圆的外围网络的一部分。 该椭圆的矩形的边界定义。 弧线是外围网络之间的椭圆的一部分`startAngle`参数和`startAngle`  +  `sweepAngle`参数。  
  
   
  
## Examples  
 下面的代码示例设计为使用 Windows 窗体，并且它需要<xref:System.Windows.Forms.PaintEventArgs> `e`，这是一个参数的<xref:System.Windows.Forms.Control.Paint>事件处理程序。 该代码执行下列操作：  
  
-   创建黑色的笔。  
  
-   创建要绑定一个椭圆的矩形。  
  
-   定义开始 （45 度为单位） 和扫描 （270 度为单位） 的角度。  
  
-   在屏幕上绘制椭圆弧。  
  
 结果是部分椭圆，缺少之间的线段 + 和-x 轴的 45 度。  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples#7](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CPP/form1.cpp#7)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples#7](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CS/form1.cs#7)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples#7](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/VB/form1.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="pen" /> 为 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="DrawArc">
      <MemberSignature Language="C#" Value="public void DrawArc (System.Drawing.Pen pen, System.Drawing.RectangleF rect, float startAngle, float sweepAngle);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawArc(class System.Drawing.Pen pen, valuetype System.Drawing.RectangleF rect, float32 startAngle, float32 sweepAngle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawArc(System.Drawing.Pen,System.Drawing.RectangleF,System.Single,System.Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawArc(System::Drawing::Pen ^ pen, System::Drawing::RectangleF rect, float startAngle, float sweepAngle);" />
      <MemberSignature Language="F#" Value="member this.DrawArc : System.Drawing.Pen * System.Drawing.RectangleF * single * single -&gt; unit" Usage="graphics.DrawArc (pen, rect, startAngle, sweepAngle)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pen" Type="System.Drawing.Pen" />
        <Parameter Name="rect" Type="System.Drawing.RectangleF" />
        <Parameter Name="startAngle" Type="System.Single" />
        <Parameter Name="sweepAngle" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="pen">
          <see cref="T:System.Drawing.Pen" />，它确定弧线的颜色、宽度和样式。</param>
        <param name="rect">
          <see cref="T:System.Drawing.RectangleF" /> 结构，它定义椭圆的边界。</param>
        <param name="startAngle">从 x 轴到弧线的起始点沿顺时针方向度量的角（以度为单位）。</param>
        <param name="sweepAngle">从 <c>startAngle</c> 参数到弧线的结束点沿顺时针方向度量的角（以度为单位）。</param>
        <summary>绘制一段弧线，它表示 <see cref="T:System.Drawing.RectangleF" /> 结构指定的椭圆的一部分。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法绘制一段弧线的椭圆的外围网络的一部分。 该椭圆的矩形的边界定义。 弧线是外围网络之间的椭圆的一部分`startAngle`参数和`startAngle`  +  `sweepAngle`参数。  
  
   
  
## Examples  
 下面的代码示例设计为使用 Windows 窗体，并且它需要<xref:System.Windows.Forms.PaintEventArgs> `e`，这是一个参数的<xref:System.Windows.Forms.Control.Paint>事件处理程序。 该代码执行下列操作：  
  
-   创建黑色的笔。  
  
-   创建要绑定一个椭圆的矩形。  
  
-   定义开始 （45 度为单位） 和扫描 （270 度为单位） 的角度。  
  
-   在屏幕上绘制椭圆弧。  
  
 结果是部分椭圆，缺少之间的线段 + 和-x 轴的 45 度。  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples#8](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CPP/form1.cpp#8)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples#8](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CS/form1.cs#8)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples#8](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/VB/form1.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="pen" /> 为 <see langword="null" /></exception>
      </Docs>
    </Member>
    <Member MemberName="DrawArc">
      <MemberSignature Language="C#" Value="public void DrawArc (System.Drawing.Pen pen, int x, int y, int width, int height, int startAngle, int sweepAngle);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawArc(class System.Drawing.Pen pen, int32 x, int32 y, int32 width, int32 height, int32 startAngle, int32 sweepAngle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawArc(System.Drawing.Pen,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawArc(System::Drawing::Pen ^ pen, int x, int y, int width, int height, int startAngle, int sweepAngle);" />
      <MemberSignature Language="F#" Value="member this.DrawArc : System.Drawing.Pen * int * int * int * int * int * int -&gt; unit" Usage="graphics.DrawArc (pen, x, y, width, height, startAngle, sweepAngle)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pen" Type="System.Drawing.Pen" />
        <Parameter Name="x" Type="System.Int32" />
        <Parameter Name="y" Type="System.Int32" />
        <Parameter Name="width" Type="System.Int32" />
        <Parameter Name="height" Type="System.Int32" />
        <Parameter Name="startAngle" Type="System.Int32" />
        <Parameter Name="sweepAngle" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="pen">
          <see cref="T:System.Drawing.Pen" />，它确定弧线的颜色、宽度和样式。</param>
        <param name="x">定义椭圆的矩形的左上角的 x 坐标。</param>
        <param name="y">定义椭圆的矩形的左上角的 y 坐标。</param>
        <param name="width">定义椭圆的矩形的宽度。</param>
        <param name="height">定义椭圆的矩形的高度。</param>
        <param name="startAngle">从 x 轴到弧线的起始点沿顺时针方向度量的角（以度为单位）。</param>
        <param name="sweepAngle">从 <c>startAngle</c> 参数到弧线的结束点沿顺时针方向度量的角（以度为单位）。</param>
        <summary>绘制一段弧线，它表示由一对坐标、宽度和高度指定的椭圆部分。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法绘制一段弧线的椭圆的外围网络的一部分。 该椭圆的矩形的边界定义。 弧线是外围网络之间的椭圆的一部分`startAngle`参数和`startAngle`  +  `sweepAngle`参数。  
  
   
  
## Examples  
 下面的代码示例设计为使用 Windows 窗体，并且它需要<xref:System.Windows.Forms.PaintEventArgs> `e`，这是一个参数的<xref:System.Windows.Forms.Control.Paint>事件处理程序。 该代码执行下列操作：  
  
-   创建黑色的笔。  
  
-   创建位置和要绑定一个椭圆的矩形的大小。  
  
-   定义开始 （45 度为单位） 和扫描 （270 度为单位） 的角度。  
  
-   在屏幕上绘制椭圆弧。  
  
 结果是部分椭圆，缺少之间的线段 + 和-x 轴的 45 度。  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples#9](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CPP/form1.cpp#9)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples#9](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CS/form1.cs#9)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples#9](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/VB/form1.vb#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rects" /> 是一个长度为零的数组。</exception>
      </Docs>
    </Member>
    <Member MemberName="DrawArc">
      <MemberSignature Language="C#" Value="public void DrawArc (System.Drawing.Pen pen, float x, float y, float width, float height, float startAngle, float sweepAngle);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawArc(class System.Drawing.Pen pen, float32 x, float32 y, float32 width, float32 height, float32 startAngle, float32 sweepAngle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawArc(System.Drawing.Pen,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawArc(System::Drawing::Pen ^ pen, float x, float y, float width, float height, float startAngle, float sweepAngle);" />
      <MemberSignature Language="F#" Value="member this.DrawArc : System.Drawing.Pen * single * single * single * single * single * single -&gt; unit" Usage="graphics.DrawArc (pen, x, y, width, height, startAngle, sweepAngle)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pen" Type="System.Drawing.Pen" />
        <Parameter Name="x" Type="System.Single" />
        <Parameter Name="y" Type="System.Single" />
        <Parameter Name="width" Type="System.Single" />
        <Parameter Name="height" Type="System.Single" />
        <Parameter Name="startAngle" Type="System.Single" />
        <Parameter Name="sweepAngle" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="pen">
          <see cref="T:System.Drawing.Pen" />，它确定弧线的颜色、宽度和样式。</param>
        <param name="x">定义椭圆的矩形的左上角的 x 坐标。</param>
        <param name="y">定义椭圆的矩形的左上角的 y 坐标。</param>
        <param name="width">定义椭圆的矩形的宽度。</param>
        <param name="height">定义椭圆的矩形的高度。</param>
        <param name="startAngle">从 x 轴到弧线的起始点沿顺时针方向度量的角（以度为单位）。</param>
        <param name="sweepAngle">从 <c>startAngle</c> 参数到弧线的结束点沿顺时针方向度量的角（以度为单位）。</param>
        <summary>绘制一段弧线，它表示由一对坐标、宽度和高度指定的椭圆部分。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法绘制一段弧线的椭圆的外围网络的一部分。 该椭圆的矩形的边界定义。 弧线是外围网络之间的椭圆的一部分`startAngle`参数和`startAngle`  +  `sweepAngle`参数。  
  
   
  
## Examples  
 下面的代码示例设计为使用 Windows 窗体，并且它需要<xref:System.Windows.Forms.PaintEventArgs> `e`，这是一个参数的<xref:System.Windows.Forms.Control.Paint>事件处理程序。 该代码执行下列操作：  
  
-   创建黑色的笔。  
  
-   创建位置和要绑定一个椭圆的矩形的大小。  
  
-   定义开始 （45 度为单位） 和扫描 （270 度为单位） 的角度。  
  
-   在屏幕上绘制椭圆弧。  
  
 结果是部分椭圆，缺少之间的线段 + 和-x 轴的 45 度。  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples#10](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CPP/form1.cpp#10)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples#10](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CS/form1.cs#10)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples#10](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/VB/form1.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="pen" /> 为 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="DrawBezier">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>绘制由 4 个 <see cref="T:System.Drawing.Point" /> 结构定义的贝塞尔样条。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DrawBezier">
      <MemberSignature Language="C#" Value="public void DrawBezier (System.Drawing.Pen pen, System.Drawing.Point pt1, System.Drawing.Point pt2, System.Drawing.Point pt3, System.Drawing.Point pt4);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawBezier(class System.Drawing.Pen pen, valuetype System.Drawing.Point pt1, valuetype System.Drawing.Point pt2, valuetype System.Drawing.Point pt3, valuetype System.Drawing.Point pt4) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawBezier(System.Drawing.Pen,System.Drawing.Point,System.Drawing.Point,System.Drawing.Point,System.Drawing.Point)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawBezier(System::Drawing::Pen ^ pen, System::Drawing::Point pt1, System::Drawing::Point pt2, System::Drawing::Point pt3, System::Drawing::Point pt4);" />
      <MemberSignature Language="F#" Value="member this.DrawBezier : System.Drawing.Pen * System.Drawing.Point * System.Drawing.Point * System.Drawing.Point * System.Drawing.Point -&gt; unit" Usage="graphics.DrawBezier (pen, pt1, pt2, pt3, pt4)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pen" Type="System.Drawing.Pen" />
        <Parameter Name="pt1" Type="System.Drawing.Point" />
        <Parameter Name="pt2" Type="System.Drawing.Point" />
        <Parameter Name="pt3" Type="System.Drawing.Point" />
        <Parameter Name="pt4" Type="System.Drawing.Point" />
      </Parameters>
      <Docs>
        <param name="pen">
          <see cref="T:System.Drawing.Pen" /> 结构，它确定曲线的颜色、宽度和样式。</param>
        <param name="pt1">
          <see cref="T:System.Drawing.Point" /> 结构，它表示曲线的起始点。</param>
        <param name="pt2">
          <see cref="T:System.Drawing.Point" /> 结构，它表示曲线的第一个控制点。</param>
        <param name="pt3">
          <see cref="T:System.Drawing.Point" /> 结构，它表示曲线的第二个控制点。</param>
        <param name="pt4">
          <see cref="T:System.Drawing.Point" /> 结构，它表示曲线的结束点。</param>
        <summary>绘制由 4 个 <see cref="T:System.Drawing.Point" /> 结构定义的贝塞尔样条。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 从第一个点到第四个点绘制贝塞尔曲线。 第二个和第三个点是确定曲线的形状的控制点。  
  
   
  
## Examples  
 下面的代码示例设计为使用 Windows 窗体，并且它需要<xref:System.Windows.Forms.PaintEventArgs> `e`，这是一个参数的<xref:System.Windows.Forms.Control.Paint>事件处理程序。 该代码执行下列操作：  
  
-   创建黑色的笔。  
  
-   创建开始时间、 结束时和曲线的两个控制点。  
  
-   在屏幕上绘制贝塞尔曲线。  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples#11](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CPP/form1.cpp#11)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples#11](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CS/form1.cs#11)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples#11](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/VB/form1.vb#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="pen" /> 为 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="DrawBezier">
      <MemberSignature Language="C#" Value="public void DrawBezier (System.Drawing.Pen pen, System.Drawing.PointF pt1, System.Drawing.PointF pt2, System.Drawing.PointF pt3, System.Drawing.PointF pt4);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawBezier(class System.Drawing.Pen pen, valuetype System.Drawing.PointF pt1, valuetype System.Drawing.PointF pt2, valuetype System.Drawing.PointF pt3, valuetype System.Drawing.PointF pt4) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawBezier(System.Drawing.Pen,System.Drawing.PointF,System.Drawing.PointF,System.Drawing.PointF,System.Drawing.PointF)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawBezier(System::Drawing::Pen ^ pen, System::Drawing::PointF pt1, System::Drawing::PointF pt2, System::Drawing::PointF pt3, System::Drawing::PointF pt4);" />
      <MemberSignature Language="F#" Value="member this.DrawBezier : System.Drawing.Pen * System.Drawing.PointF * System.Drawing.PointF * System.Drawing.PointF * System.Drawing.PointF -&gt; unit" Usage="graphics.DrawBezier (pen, pt1, pt2, pt3, pt4)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pen" Type="System.Drawing.Pen" />
        <Parameter Name="pt1" Type="System.Drawing.PointF" />
        <Parameter Name="pt2" Type="System.Drawing.PointF" />
        <Parameter Name="pt3" Type="System.Drawing.PointF" />
        <Parameter Name="pt4" Type="System.Drawing.PointF" />
      </Parameters>
      <Docs>
        <param name="pen">
          <see cref="T:System.Drawing.Pen" />，它确定曲线的颜色、宽度和样式。</param>
        <param name="pt1">
          <see cref="T:System.Drawing.PointF" /> 结构，它表示曲线的起始点。</param>
        <param name="pt2">
          <see cref="T:System.Drawing.PointF" /> 结构，它表示曲线的第一个控制点。</param>
        <param name="pt3">
          <see cref="T:System.Drawing.PointF" /> 结构，它表示曲线的第二个控制点。</param>
        <param name="pt4">
          <see cref="T:System.Drawing.PointF" /> 结构，它表示曲线的结束点。</param>
        <summary>绘制由 4 个 <see cref="T:System.Drawing.PointF" /> 结构定义的贝塞尔样条。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 从第一个点到第四个点绘制贝塞尔样条。 第二个和第三个点是确定曲线的形状的控制点。  
  
   
  
## Examples  
 下面的代码示例设计为使用 Windows 窗体，并且它需要<xref:System.Windows.Forms.PaintEventArgs> `e`，这是一个参数的<xref:System.Windows.Forms.Control.Paint>事件处理程序。 该代码执行下列操作：  
  
-   创建黑色的笔。  
  
-   创建开始时间、 结束时和曲线的两个控制点。  
  
-   在屏幕上绘制贝塞尔曲线。  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples#12](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CPP/form1.cpp#12)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples#12](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CS/form1.cs#12)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples#12](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/VB/form1.vb#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="pen" /> 为 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="DrawBezier">
      <MemberSignature Language="C#" Value="public void DrawBezier (System.Drawing.Pen pen, float x1, float y1, float x2, float y2, float x3, float y3, float x4, float y4);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawBezier(class System.Drawing.Pen pen, float32 x1, float32 y1, float32 x2, float32 y2, float32 x3, float32 y3, float32 x4, float32 y4) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawBezier(System.Drawing.Pen,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawBezier(System::Drawing::Pen ^ pen, float x1, float y1, float x2, float y2, float x3, float y3, float x4, float y4);" />
      <MemberSignature Language="F#" Value="member this.DrawBezier : System.Drawing.Pen * single * single * single * single * single * single * single * single -&gt; unit" Usage="graphics.DrawBezier (pen, x1, y1, x2, y2, x3, y3, x4, y4)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pen" Type="System.Drawing.Pen" />
        <Parameter Name="x1" Type="System.Single" />
        <Parameter Name="y1" Type="System.Single" />
        <Parameter Name="x2" Type="System.Single" />
        <Parameter Name="y2" Type="System.Single" />
        <Parameter Name="x3" Type="System.Single" />
        <Parameter Name="y3" Type="System.Single" />
        <Parameter Name="x4" Type="System.Single" />
        <Parameter Name="y4" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="pen">
          <see cref="T:System.Drawing.Pen" />，它确定曲线的颜色、宽度和样式。</param>
        <param name="x1">曲线起始点的 X 坐标。</param>
        <param name="y1">曲线起始点的 Y 坐标。</param>
        <param name="x2">曲线的第一个控制点的 X 坐标。</param>
        <param name="y2">曲线的第一个控制点的 Y 坐标。</param>
        <param name="x3">曲线的第二个控制点的 X 坐标。</param>
        <param name="y3">曲线的第二个控制点的 Y 坐标。</param>
        <param name="x4">曲线的结束点的 X 坐标。</param>
        <param name="y4">曲线的结束点的 Y 坐标。</param>
        <summary>绘制由四个表示点的有序坐标对定义的贝塞尔样条。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 从第一个点到第四个点绘制贝塞尔样条。 第二个和第三个点是确定曲线的形状的控制点。  
  
   
  
## Examples  
 下面的代码示例设计为使用 Windows 窗体，并且它需要<xref:System.Windows.Forms.PaintEventArgs> `e`，这是一个参数的<xref:System.Windows.Forms.Control.Paint>事件处理程序。 该代码执行下列操作：  
  
-   创建黑色的笔。  
  
-   创建的开始、 结束时间和曲线的两个控点的坐标。  
  
-   在屏幕上绘制贝塞尔曲线。  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples#13](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CPP/form1.cpp#13)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples#13](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CS/form1.cs#13)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples#13](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/VB/form1.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="pen" /> 为 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="DrawBeziers">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>用 <see cref="T:System.Drawing.Point" /> 结构数组绘制一系列贝塞尔样条。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DrawBeziers">
      <MemberSignature Language="C#" Value="public void DrawBeziers (System.Drawing.Pen pen, System.Drawing.Point[] points);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawBeziers(class System.Drawing.Pen pen, valuetype System.Drawing.Point[] points) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawBeziers(System.Drawing.Pen,System.Drawing.Point[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawBeziers(System::Drawing::Pen ^ pen, cli::array &lt;System::Drawing::Point&gt; ^ points);" />
      <MemberSignature Language="F#" Value="member this.DrawBeziers : System.Drawing.Pen * System.Drawing.Point[] -&gt; unit" Usage="graphics.DrawBeziers (pen, points)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pen" Type="System.Drawing.Pen" />
        <Parameter Name="points" Type="System.Drawing.Point[]" />
      </Parameters>
      <Docs>
        <param name="pen">
          <see cref="T:System.Drawing.Pen" />，它确定曲线的颜色、宽度和样式。</param>
        <param name="points">
          <see cref="T:System.Drawing.Point" /> 结构的数组，这些结构表示确定曲线的点。 此数组中的点数应为 3 的倍数加 1，如 4、7 或 10。</param>
        <summary>用 <see cref="T:System.Drawing.Point" /> 结构数组绘制一系列贝塞尔样条。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 数组中的点数应为 3 的倍数加 1，因为第一个自由绘制曲线需要 4 个点，并且其他自由绘制曲线需要 3 个点。 第一个贝塞尔样条是从第一个点到点数组中的第四个点绘制的。 第二个和第三个点是确定曲线的形状的控制点。 每个后续的曲线需要完全三个点： 两个控制点和结束点。 前一条曲线的结束点用作一条曲线的起始点。  
  
   
  
## Examples  
 下面的代码示例设计为使用 Windows 窗体，并且它需要<xref:System.Windows.Forms.PaintEventArgs> `e`，这是一个参数的<xref:System.Windows.Forms.Control.Paint>事件处理程序。 该代码执行下列操作：  
  
-   创建黑色的笔。  
  
-   创建开始时间、 结束时，和两个控制点第一条曲线和终结点和第二条曲线的两个控制点。  
  
-   在屏幕上绘制连续的贝塞尔曲线。  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples#14](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CPP/form1.cpp#14)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples#14](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CS/form1.cs#14)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples#14](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/VB/form1.vb#14)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="pen" /> 为 <see langword="null" />。  
  
或 
 <paramref name="points" /> 为 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="DrawBeziers">
      <MemberSignature Language="C#" Value="public void DrawBeziers (System.Drawing.Pen pen, System.Drawing.PointF[] points);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawBeziers(class System.Drawing.Pen pen, valuetype System.Drawing.PointF[] points) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawBeziers(System.Drawing.Pen,System.Drawing.PointF[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawBeziers(System::Drawing::Pen ^ pen, cli::array &lt;System::Drawing::PointF&gt; ^ points);" />
      <MemberSignature Language="F#" Value="member this.DrawBeziers : System.Drawing.Pen * System.Drawing.PointF[] -&gt; unit" Usage="graphics.DrawBeziers (pen, points)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pen" Type="System.Drawing.Pen" />
        <Parameter Name="points" Type="System.Drawing.PointF[]" />
      </Parameters>
      <Docs>
        <param name="pen">
          <see cref="T:System.Drawing.Pen" />，它确定曲线的颜色、宽度和样式。</param>
        <param name="points">
          <see cref="T:System.Drawing.PointF" /> 结构的数组，这些结构表示确定曲线的点。 此数组中的点数应为 3 的倍数加 1，如 4、7 或 10。</param>
        <summary>用 <see cref="T:System.Drawing.PointF" /> 结构数组绘制一系列贝塞尔样条。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 数组中的点数应为 3 的倍数加 1，因为第一个自由绘制曲线需要 4 个点，并且其他自由绘制曲线需要 3 个点。 第一个贝塞尔曲线是从第一个点到点数组中的第四个点绘制的。 第二个和第三个点是确定曲线的形状的控制点。 每个后续的曲线需要完全三个点： 两个控制点和结束点。 前一条曲线的结束点用作一条曲线的起始点。  
  
   
  
## Examples  
 下面的代码示例设计为使用 Windows 窗体，并且它需要<xref:System.Windows.Forms.PaintEventArgs> `e`，这是一个参数的<xref:System.Windows.Forms.Control.Paint>事件处理程序。 该代码执行下列操作：  
  
-   创建黑色的笔。  
  
-   创建开始时间、 结束时，和两个控制点第一条曲线和终结点和第二条曲线的两个控制点。  
  
-   在屏幕上绘制连续的贝塞尔曲线。  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples#15](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CPP/form1.cpp#15)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples#15](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CS/form1.cs#15)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples#15](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/VB/form1.vb#15)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="pen" /> 为 <see langword="null" />。  
  
或 
 <paramref name="points" /> 为 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="DrawClosedCurve">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>绘制由 <see cref="T:System.Drawing.Point" /> 结构的数组定义的闭合基数样条。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DrawClosedCurve">
      <MemberSignature Language="C#" Value="public void DrawClosedCurve (System.Drawing.Pen pen, System.Drawing.Point[] points);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawClosedCurve(class System.Drawing.Pen pen, valuetype System.Drawing.Point[] points) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawClosedCurve(System.Drawing.Pen,System.Drawing.Point[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawClosedCurve(System::Drawing::Pen ^ pen, cli::array &lt;System::Drawing::Point&gt; ^ points);" />
      <MemberSignature Language="F#" Value="member this.DrawClosedCurve : System.Drawing.Pen * System.Drawing.Point[] -&gt; unit" Usage="graphics.DrawClosedCurve (pen, points)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pen" Type="System.Drawing.Pen" />
        <Parameter Name="points" Type="System.Drawing.Point[]" />
      </Parameters>
      <Docs>
        <param name="pen">
          <see cref="T:System.Drawing.Pen" />，它确定曲线的颜色、宽度和高度。</param>
        <param name="points">
          <see cref="T:System.Drawing.Point" /> 结构数组，这些结构定义样条。</param>
        <summary>绘制由 <see cref="T:System.Drawing.Point" /> 结构的数组定义的闭合基数样条。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法绘制经过数组中每个点的闭合基数样条。 如果最后一个点不匹配的第一个点，附加曲线段是在最后一个点添加到的第一个点，以关闭该图中。  
  
 点的数组必须包含至少四个<xref:System.Drawing.Point>结构。  
  
 此方法使用默认张力 0.5。  
  
   
  
## Examples  
 下面的代码示例设计为使用 Windows 窗体，并且它需要<xref:System.Windows.Forms.PaintEventArgs> `e`，这是一个参数的<xref:System.Windows.Forms.Control.Paint>事件处理程序。 该代码执行下列操作：  
  
-   创建红色和绿色的笔。  
  
-   创建七个点来定义一条曲线。  
  
-   七个点来形成闭合的多边形之间绘制七个红色的直线。  
  
-   绘制通过七个点的绿色闭合的曲线。  
  
 该方法使用默认张力 0.5。  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples#16](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CPP/form1.cpp#16)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples#16](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CS/form1.cs#16)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples#16](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/VB/form1.vb#16)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="pen" /> 为 <see langword="null" />。  
  
或 
 <paramref name="points" /> 为 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="DrawClosedCurve">
      <MemberSignature Language="C#" Value="public void DrawClosedCurve (System.Drawing.Pen pen, System.Drawing.PointF[] points);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawClosedCurve(class System.Drawing.Pen pen, valuetype System.Drawing.PointF[] points) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawClosedCurve(System.Drawing.Pen,System.Drawing.PointF[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawClosedCurve(System::Drawing::Pen ^ pen, cli::array &lt;System::Drawing::PointF&gt; ^ points);" />
      <MemberSignature Language="F#" Value="member this.DrawClosedCurve : System.Drawing.Pen * System.Drawing.PointF[] -&gt; unit" Usage="graphics.DrawClosedCurve (pen, points)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pen" Type="System.Drawing.Pen" />
        <Parameter Name="points" Type="System.Drawing.PointF[]" />
      </Parameters>
      <Docs>
        <param name="pen">
          <see cref="T:System.Drawing.Pen" />，它确定曲线的颜色、宽度和高度。</param>
        <param name="points">
          <see cref="T:System.Drawing.PointF" /> 结构数组，这些结构定义样条。</param>
        <summary>绘制由 <see cref="T:System.Drawing.PointF" /> 结构的数组定义的闭合基数样条。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法绘制经过数组中每个点的闭合基数样条。 如果最后一个点不匹配的第一个点，附加曲线段在最后一个点添加到第一个点，以将其关闭。  
  
 点的数组必须包含至少四个<xref:System.Drawing.PointF>结构。  
  
 此方法使用默认张力 0.5。  
  
   
  
## Examples  
 下面的代码示例设计为使用 Windows 窗体，并且它需要<xref:System.Windows.Forms.PaintEventArgs> `e`，这是一个参数的<xref:System.Windows.Forms.Control.Paint>事件处理程序。 该代码执行下列操作：  
  
-   创建红色和绿色的笔。  
  
-   创建七个点来定义一条曲线。  
  
-   七个点来形成闭合的多边形之间绘制七个红色的直线。  
  
-   绘制通过七个点的绿色闭合的曲线。  
  
 该方法使用默认张力 0.5。  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples#18](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CPP/form1.cpp#18)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples#18](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CS/form1.cs#18)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples#18](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/VB/form1.vb#18)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="pen" /> 为 <see langword="null" />。  
  
或 
 <paramref name="points" /> 为 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="DrawClosedCurve">
      <MemberSignature Language="C#" Value="public void DrawClosedCurve (System.Drawing.Pen pen, System.Drawing.Point[] points, float tension, System.Drawing.Drawing2D.FillMode fillmode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawClosedCurve(class System.Drawing.Pen pen, valuetype System.Drawing.Point[] points, float32 tension, valuetype System.Drawing.Drawing2D.FillMode fillmode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawClosedCurve(System.Drawing.Pen,System.Drawing.Point[],System.Single,System.Drawing.Drawing2D.FillMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawClosedCurve(System::Drawing::Pen ^ pen, cli::array &lt;System::Drawing::Point&gt; ^ points, float tension, System::Drawing::Drawing2D::FillMode fillmode);" />
      <MemberSignature Language="F#" Value="member this.DrawClosedCurve : System.Drawing.Pen * System.Drawing.Point[] * single * System.Drawing.Drawing2D.FillMode -&gt; unit" Usage="graphics.DrawClosedCurve (pen, points, tension, fillmode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pen" Type="System.Drawing.Pen" />
        <Parameter Name="points" Type="System.Drawing.Point[]" />
        <Parameter Name="tension" Type="System.Single" />
        <Parameter Name="fillmode" Type="System.Drawing.Drawing2D.FillMode" />
      </Parameters>
      <Docs>
        <param name="pen">
          <see cref="T:System.Drawing.Pen" />，它确定曲线的颜色、宽度和高度。</param>
        <param name="points">
          <see cref="T:System.Drawing.Point" /> 结构数组，这些结构定义样条。</param>
        <param name="tension">大于或等于 0.0F 的值，该值指定曲线的张力。</param>
        <param name="fillmode">
          <see cref="T:System.Drawing.Drawing2D.FillMode" /> 枚举的成员，它确定填充曲线的方式。 需要此参数但被忽略。</param>
        <summary>使用指定的张力绘制由 <see cref="T:System.Drawing.Point" /> 结构数组定义的闭合基数样条。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法绘制经过数组中每个点的闭合基数样条。 如果最后一个点不匹配的第一个点，附加曲线段在最后一个点添加到第一个点，以将其关闭。  
  
 点的数组必须包含至少四个<xref:System.Drawing.Point>结构。  
  
 `tension`参数确定的自由绘制曲线形状。 如果的值`tension`参数为 0.0F 时，此方法绘制直线段连接的点。 通常情况下，`tension`参数小于或等于 1.0 f。 超过 1.0 f 的值将产生不正常的结果。  
  
   
  
## Examples  
 下面的代码示例设计为使用 Windows 窗体，并且它需要<xref:System.Windows.Forms.PaintEventArgs> `e`，这是一个参数的<xref:System.Windows.Forms.Control.Paint>事件处理程序。 该代码执行下列操作：  
  
-   创建红色和绿色的笔。  
  
-   创建七个点来定义曲线。  
  
-   以形成一个多边形的七个点之间绘制七个红色的直线。  
  
-   创建张力和填充模式设置。  
  
-   绘制通过七个点的绿色闭合的曲线。  
  
 该方法使用 1.0 张力和填充模式设置为`FillMode.Alternate`。  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples#17](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CPP/form1.cpp#17)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples#17](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CS/form1.cs#17)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples#17](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/VB/form1.vb#17)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="pen" /> 为 <see langword="null" />。  
  
或 
 <paramref name="points" /> 为 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="DrawClosedCurve">
      <MemberSignature Language="C#" Value="public void DrawClosedCurve (System.Drawing.Pen pen, System.Drawing.PointF[] points, float tension, System.Drawing.Drawing2D.FillMode fillmode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawClosedCurve(class System.Drawing.Pen pen, valuetype System.Drawing.PointF[] points, float32 tension, valuetype System.Drawing.Drawing2D.FillMode fillmode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawClosedCurve(System.Drawing.Pen,System.Drawing.PointF[],System.Single,System.Drawing.Drawing2D.FillMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawClosedCurve(System::Drawing::Pen ^ pen, cli::array &lt;System::Drawing::PointF&gt; ^ points, float tension, System::Drawing::Drawing2D::FillMode fillmode);" />
      <MemberSignature Language="F#" Value="member this.DrawClosedCurve : System.Drawing.Pen * System.Drawing.PointF[] * single * System.Drawing.Drawing2D.FillMode -&gt; unit" Usage="graphics.DrawClosedCurve (pen, points, tension, fillmode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pen" Type="System.Drawing.Pen" />
        <Parameter Name="points" Type="System.Drawing.PointF[]" />
        <Parameter Name="tension" Type="System.Single" />
        <Parameter Name="fillmode" Type="System.Drawing.Drawing2D.FillMode" />
      </Parameters>
      <Docs>
        <param name="pen">
          <see cref="T:System.Drawing.Pen" />，它确定曲线的颜色、宽度和高度。</param>
        <param name="points">
          <see cref="T:System.Drawing.PointF" /> 结构数组，这些结构定义样条。</param>
        <param name="tension">大于或等于 0.0F 的值，该值指定曲线的张力。</param>
        <param name="fillmode">
          <see cref="T:System.Drawing.Drawing2D.FillMode" /> 枚举的成员，它确定填充曲线的方式。 需要此参数但被忽略。</param>
        <summary>使用指定的张力绘制由 <see cref="T:System.Drawing.PointF" /> 结构数组定义的闭合基数样条。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法绘制经过数组中每个点的闭合基数样条。 如果最后一个点不匹配的第一个点，附加曲线段在最后一个点添加到第一个点，以将其关闭。  
  
 点的数组必须包含至少四个<xref:System.Drawing.PointF>结构。  
  
 `tension`参数确定的自由绘制曲线形状。 如果的值`tension`参数为 0.0F 时，此方法绘制直线段连接的点。 通常情况下，`tension`参数小于或等于 1.0 f。 超过 1.0 f 的值将产生不正常的结果。  
  
   
  
## Examples  
 下面的代码示例设计为使用 Windows 窗体，并且它需要<xref:System.Windows.Forms.PaintEventArgs> `e`，这是一个参数的<xref:System.Windows.Forms.Control.Paint>事件处理程序。 该代码执行下列操作：  
  
-   创建红色和绿色的笔。  
  
-   创建七个点来定义曲线。  
  
-   以形成一个多边形的七个点之间绘制七个红色的直线。  
  
-   创建张力和填充模式设置。  
  
-   绘制通过七个点的绿色闭合的曲线。  
  
 该方法使用 1.0 张力和填充模式设置为`FillMode.Alternate`。  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples#19](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CPP/form1.cpp#19)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples#19](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CS/form1.cs#19)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples#19](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/VB/form1.vb#19)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="pen" /> 为 <see langword="null" />。  
  
或 
 <paramref name="points" /> 为 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="DrawCurve">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>绘制经过一组指定的 <see cref="T:System.Drawing.Point" /> 结构的基数样条。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DrawCurve">
      <MemberSignature Language="C#" Value="public void DrawCurve (System.Drawing.Pen pen, System.Drawing.Point[] points);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawCurve(class System.Drawing.Pen pen, valuetype System.Drawing.Point[] points) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawCurve(System.Drawing.Pen,System.Drawing.Point[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawCurve(System::Drawing::Pen ^ pen, cli::array &lt;System::Drawing::Point&gt; ^ points);" />
      <MemberSignature Language="F#" Value="member this.DrawCurve : System.Drawing.Pen * System.Drawing.Point[] -&gt; unit" Usage="graphics.DrawCurve (pen, points)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pen" Type="System.Drawing.Pen" />
        <Parameter Name="points" Type="System.Drawing.Point[]" />
      </Parameters>
      <Docs>
        <param name="pen">
          <see cref="T:System.Drawing.Pen" />，它确定曲线的颜色、宽度和高度。</param>
        <param name="points">
          <see cref="T:System.Drawing.Point" /> 结构数组，这些结构定义样条。</param>
        <summary>绘制经过一组指定的 <see cref="T:System.Drawing.Point" /> 结构的基数样条。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法绘制经过数组中每个点的基数样条。  
  
 点的数组必须包含至少三个<xref:System.Drawing.Point>曲线要绘制的结构。  
  
 此方法使用默认张力 0.5。  
  
   
  
## Examples  
 下面的代码示例设计为使用 Windows 窗体，并且它需要<xref:System.Windows.Forms.PaintEventArgs> `e`，这是一个参数的<xref:System.Windows.Forms.Control.Paint>事件处理程序。 该代码执行下列操作：  
  
-   创建红色和绿色的笔。  
  
-   创建七个点来定义一条曲线。  
  
-   以形成一个不完整的多边形的七个点之间绘制六个红色的直线。  
  
-   绘制通过七个点打开绿色曲线。  
  
 该方法使用默认张力 0.5。  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples#20](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CPP/form1.cpp#20)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples#20](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CS/form1.cs#20)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples#20](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/VB/form1.vb#20)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="pen" /> 为 <see langword="null" />。  
  
或 
 <paramref name="points" /> 为 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="DrawCurve">
      <MemberSignature Language="C#" Value="public void DrawCurve (System.Drawing.Pen pen, System.Drawing.PointF[] points);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawCurve(class System.Drawing.Pen pen, valuetype System.Drawing.PointF[] points) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawCurve(System.Drawing.Pen,System.Drawing.PointF[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawCurve(System::Drawing::Pen ^ pen, cli::array &lt;System::Drawing::PointF&gt; ^ points);" />
      <MemberSignature Language="F#" Value="member this.DrawCurve : System.Drawing.Pen * System.Drawing.PointF[] -&gt; unit" Usage="graphics.DrawCurve (pen, points)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pen" Type="System.Drawing.Pen" />
        <Parameter Name="points" Type="System.Drawing.PointF[]" />
      </Parameters>
      <Docs>
        <param name="pen">
          <see cref="T:System.Drawing.Pen" />，它确定曲线的颜色、宽度和样式。</param>
        <param name="points">
          <see cref="T:System.Drawing.PointF" /> 结构数组，这些结构定义样条。</param>
        <summary>绘制经过一组指定的 <see cref="T:System.Drawing.PointF" /> 结构的基数样条。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法绘制经过数组中每个点的基数样条。  
  
 点的数组必须包含至少三个<xref:System.Drawing.PointF>曲线要绘制的结构。  
  
 此方法使用默认张力 0.5。  
  
   
  
## Examples  
 下面的代码示例设计为使用 Windows 窗体，并且它需要<xref:System.Windows.Forms.PaintEventArgs> `e`，这是一个参数的<xref:System.Windows.Forms.Control.Paint>事件处理程序。 该代码执行下列操作：  
  
-   创建红色和绿色的笔。  
  
-   创建七个点来定义一条曲线。  
  
-   以形成一个不完整的多边形的七个点之间绘制六个红色的直线。  
  
-   绘制通过七个点打开绿色曲线。  
  
 该方法使用默认张力 0.5。  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples#23](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CPP/form1.cpp#23)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples#23](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CS/form1.cs#23)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples#23](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/VB/form1.vb#23)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="pen" /> 为 <see langword="null" />。  
  
或 
 <paramref name="points" /> 为 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="DrawCurve">
      <MemberSignature Language="C#" Value="public void DrawCurve (System.Drawing.Pen pen, System.Drawing.Point[] points, float tension);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawCurve(class System.Drawing.Pen pen, valuetype System.Drawing.Point[] points, float32 tension) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawCurve(System.Drawing.Pen,System.Drawing.Point[],System.Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawCurve(System::Drawing::Pen ^ pen, cli::array &lt;System::Drawing::Point&gt; ^ points, float tension);" />
      <MemberSignature Language="F#" Value="member this.DrawCurve : System.Drawing.Pen * System.Drawing.Point[] * single -&gt; unit" Usage="graphics.DrawCurve (pen, points, tension)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pen" Type="System.Drawing.Pen" />
        <Parameter Name="points" Type="System.Drawing.Point[]" />
        <Parameter Name="tension" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="pen">
          <see cref="T:System.Drawing.Pen" />，它确定曲线的颜色、宽度和样式。</param>
        <param name="points">
          <see cref="T:System.Drawing.Point" /> 结构数组，这些结构定义样条。</param>
        <param name="tension">大于或等于 0.0F 的值，该值指定曲线的张力。</param>
        <summary>使用指定的张力绘制经过一组指定的 <see cref="T:System.Drawing.Point" /> 结构的基数样条。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法绘制经过数组中每个点的基数样条。  
  
 点的数组必须包含至少三个<xref:System.Drawing.Point>曲线要绘制的结构。  
  
 `tension`参数确定的自由绘制曲线形状。 如果的值`tension`参数为 0.0F 时，此方法绘制直线段连接的点。 通常情况下，`tension`参数小于或等于 1.0 f。 超过 1.0 f 的值将产生不正常的结果。  
  
   
  
## Examples  
 下面的代码示例设计为使用 Windows 窗体，并且它需要<xref:System.Windows.Forms.PaintEventArgs> `e`，这是一个参数的<xref:System.Windows.Forms.Control.Paint>事件处理程序。 该代码执行下列操作：  
  
-   创建红色和绿色的笔。  
  
-   创建七个点来定义曲线。  
  
-   以形成一个不完整的多边形的七个点之间绘制六个红色的直线。  
  
-   创建张力设置。  
  
-   绘制通过七个点打开绿色闭合的曲线。  
  
 该方法使用 1.0 的张力。  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples#22](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CPP/form1.cpp#22)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples#22](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CS/form1.cs#22)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples#22](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/VB/form1.vb#22)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="pen" /> 为 <see langword="null" />。  
  
或 
 <paramref name="points" /> 为 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="DrawCurve">
      <MemberSignature Language="C#" Value="public void DrawCurve (System.Drawing.Pen pen, System.Drawing.PointF[] points, float tension);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawCurve(class System.Drawing.Pen pen, valuetype System.Drawing.PointF[] points, float32 tension) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawCurve(System.Drawing.Pen,System.Drawing.PointF[],System.Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawCurve(System::Drawing::Pen ^ pen, cli::array &lt;System::Drawing::PointF&gt; ^ points, float tension);" />
      <MemberSignature Language="F#" Value="member this.DrawCurve : System.Drawing.Pen * System.Drawing.PointF[] * single -&gt; unit" Usage="graphics.DrawCurve (pen, points, tension)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pen" Type="System.Drawing.Pen" />
        <Parameter Name="points" Type="System.Drawing.PointF[]" />
        <Parameter Name="tension" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="pen">
          <see cref="T:System.Drawing.Pen" />，它确定曲线的颜色、宽度和样式。</param>
        <param name="points">
          <see cref="T:System.Drawing.PointF" /> 结构的数组，这些结构表示定义曲线的点。</param>
        <param name="tension">大于或等于 0.0F 的值，该值指定曲线的张力。</param>
        <summary>使用指定的张力绘制经过一组指定的 <see cref="T:System.Drawing.PointF" /> 结构的基数样条。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法绘制经过数组中每个点的基数样条。  
  
 点的数组必须包含至少三个<xref:System.Drawing.PointF>曲线要绘制的结构。  
  
 `tension`参数确定的自由绘制曲线形状。 如果的值`tension`参数为 0.0F 时，此方法绘制直线段连接的点。 通常情况下，`tension`参数小于或等于 1.0 f。 超过 1.0 f 的值将产生不正常的结果。  
  
   
  
## Examples  
 下面的代码示例设计为使用 Windows 窗体，并且它需要<xref:System.Windows.Forms.PaintEventArgs> `e`，这是一个参数的<xref:System.Windows.Forms.Control.Paint>事件处理程序。 该代码执行下列操作：  
  
-   创建红色和绿色的笔。  
  
-   创建七个点来定义曲线。  
  
-   以形成一个不完整的多边形的七个点之间绘制六个红色的直线。  
  
-   创建张力设置。  
  
-   绘制通过七个点打开绿色闭合的曲线。  
  
 该方法使用 1.0 的张力。  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples#26](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CPP/form1.cpp#26)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples#26](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CS/form1.cs#26)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples#26](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/VB/form1.vb#26)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="pen" /> 为 <see langword="null" />。  
  
或 
 <paramref name="points" /> 为 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="DrawCurve">
      <MemberSignature Language="C#" Value="public void DrawCurve (System.Drawing.Pen pen, System.Drawing.PointF[] points, int offset, int numberOfSegments);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawCurve(class System.Drawing.Pen pen, valuetype System.Drawing.PointF[] points, int32 offset, int32 numberOfSegments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawCurve(System.Drawing.Pen,System.Drawing.PointF[],System.Int32,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawCurve(System::Drawing::Pen ^ pen, cli::array &lt;System::Drawing::PointF&gt; ^ points, int offset, int numberOfSegments);" />
      <MemberSignature Language="F#" Value="member this.DrawCurve : System.Drawing.Pen * System.Drawing.PointF[] * int * int -&gt; unit" Usage="graphics.DrawCurve (pen, points, offset, numberOfSegments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pen" Type="System.Drawing.Pen" />
        <Parameter Name="points" Type="System.Drawing.PointF[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="numberOfSegments" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="pen">
          <see cref="T:System.Drawing.Pen" />，它确定曲线的颜色、宽度和样式。</param>
        <param name="points">
          <see cref="T:System.Drawing.PointF" /> 结构数组，这些结构定义样条。</param>
        <param name="offset">从 <c>points</c> 参数数组中的第一个元素到曲线中起始点的偏移量。</param>
        <param name="numberOfSegments">起始点之后要包含在曲线中的段数。</param>
        <summary>绘制经过一组指定的 <see cref="T:System.Drawing.PointF" /> 结构的基数样条。 从相对于数组开始位置的偏移量开始绘制。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法绘制经过数组中每个点的基数样条。  
  
 点的数组必须包含至少三个<xref:System.Drawing.PointF>曲线要绘制的结构。  
  
 值`offset`参数指定要跳过数组中的元素数。 已跳过的元素之后的第一个元素表示曲线的起始点。  
  
 值`numberOfSegments`参数指定的段数之后以绘制曲线中起始点。 值`numberOfSegments`参数必须是至少为 1。 值`offset`参数和值`numberOfSegments`参数必须是中的数组的元素数小于`points`参数。  
  
 此方法使用默认张力 0.5。  
  
   
  
## Examples  
 下面的代码示例设计为使用 Windows 窗体，并且它需要<xref:System.Windows.Forms.PaintEventArgs> `e`，这是一个参数的<xref:System.Windows.Forms.Control.Paint>事件处理程序。 该代码执行下列操作：  
  
-   创建红色和绿色的笔。  
  
-   创建七个点来定义一条曲线。  
  
-   以形成一个不完整的多边形的七个点之间绘制六个红色的直线。  
  
-   定义的起始点偏移量和的段数。  
  
-   绘制一打开绿色条曲线 （从第三个点） 通过最后五个点。  
  
 该方法使用默认张力 0.5。  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples#24](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CPP/form1.cpp#24)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples#24](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CS/form1.cs#24)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples#24](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/VB/form1.vb#24)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="pen" /> 为 <see langword="null" />。  
  
或 
 <paramref name="points" /> 为 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="DrawCurve">
      <MemberSignature Language="C#" Value="public void DrawCurve (System.Drawing.Pen pen, System.Drawing.Point[] points, int offset, int numberOfSegments, float tension);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawCurve(class System.Drawing.Pen pen, valuetype System.Drawing.Point[] points, int32 offset, int32 numberOfSegments, float32 tension) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawCurve(System.Drawing.Pen,System.Drawing.Point[],System.Int32,System.Int32,System.Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawCurve(System::Drawing::Pen ^ pen, cli::array &lt;System::Drawing::Point&gt; ^ points, int offset, int numberOfSegments, float tension);" />
      <MemberSignature Language="F#" Value="member this.DrawCurve : System.Drawing.Pen * System.Drawing.Point[] * int * int * single -&gt; unit" Usage="graphics.DrawCurve (pen, points, offset, numberOfSegments, tension)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pen" Type="System.Drawing.Pen" />
        <Parameter Name="points" Type="System.Drawing.Point[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="numberOfSegments" Type="System.Int32" />
        <Parameter Name="tension" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="pen">
          <see cref="T:System.Drawing.Pen" />，它确定曲线的颜色、宽度和样式。</param>
        <param name="points">
          <see cref="T:System.Drawing.Point" /> 结构数组，这些结构定义样条。</param>
        <param name="offset">从 <c>points</c> 参数数组中的第一个元素到曲线中起始点的偏移量。</param>
        <param name="numberOfSegments">起始点之后要包含在曲线中的段数。</param>
        <param name="tension">大于或等于 0.0F 的值，该值指定曲线的张力。</param>
        <summary>使用指定的张力绘制经过一组指定的 <see cref="T:System.Drawing.Point" /> 结构的基数样条。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法绘制经过数组中每个点的基数样条。  
  
 点的数组必须包含至少三个<xref:System.Drawing.Point>曲线要绘制的结构。  
  
 值`offset`参数指定要跳过数组中的元素数。 已跳过的元素之后的第一个元素表示曲线的起始点。  
  
 值`numberOfSegments`参数指定的段数之后以绘制曲线中起始点。 值`numberOfSegments`参数必须是至少为 1。 值`offset`参数和值`numberOfSegments`参数必须是中的数组的元素数小于`points`参数。  
  
 `tension`参数确定的自由绘制曲线形状。 如果的值`tension`参数为 0.0F 时，此方法绘制直线段连接的点。 通常情况下，`tension`参数小于或等于 1.0 f。 超过 1.0 f 的值将产生不正常的结果。  
  
   
  
## Examples  
 下面的代码示例设计为使用 Windows 窗体，并且它需要<xref:System.Windows.Forms.PaintEventArgs> `e`，这是一个参数的<xref:System.Windows.Forms.Control.Paint>事件处理程序。 该代码执行下列操作：  
  
-   创建红色和绿色的笔。  
  
-   创建七个点来定义一条曲线。  
  
-   以形成一个不完整的多边形的七个点之间绘制六个红色的直线。  
  
-   定义的起始点偏移量和的段数。  
  
-   定义张力。  
  
-   绘制一打开绿色条曲线 （从第三个点） 通过最后五个点。  
  
 该方法将设置为 1.0 的张力。  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples#21](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CPP/form1.cpp#21)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples#21](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CS/form1.cs#21)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples#21](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/VB/form1.vb#21)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="pen" /> 为 <see langword="null" />。  
  
或 
 <paramref name="points" /> 为 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="DrawCurve">
      <MemberSignature Language="C#" Value="public void DrawCurve (System.Drawing.Pen pen, System.Drawing.PointF[] points, int offset, int numberOfSegments, float tension);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawCurve(class System.Drawing.Pen pen, valuetype System.Drawing.PointF[] points, int32 offset, int32 numberOfSegments, float32 tension) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawCurve(System.Drawing.Pen,System.Drawing.PointF[],System.Int32,System.Int32,System.Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawCurve(System::Drawing::Pen ^ pen, cli::array &lt;System::Drawing::PointF&gt; ^ points, int offset, int numberOfSegments, float tension);" />
      <MemberSignature Language="F#" Value="member this.DrawCurve : System.Drawing.Pen * System.Drawing.PointF[] * int * int * single -&gt; unit" Usage="graphics.DrawCurve (pen, points, offset, numberOfSegments, tension)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pen" Type="System.Drawing.Pen" />
        <Parameter Name="points" Type="System.Drawing.PointF[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="numberOfSegments" Type="System.Int32" />
        <Parameter Name="tension" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="pen">
          <see cref="T:System.Drawing.Pen" />，它确定曲线的颜色、宽度和样式。</param>
        <param name="points">
          <see cref="T:System.Drawing.PointF" /> 结构数组，这些结构定义样条。</param>
        <param name="offset">从 <c>points</c> 参数数组中的第一个元素到曲线中起始点的偏移量。</param>
        <param name="numberOfSegments">起始点之后要包含在曲线中的段数。</param>
        <param name="tension">大于或等于 0.0F 的值，该值指定曲线的张力。</param>
        <summary>使用指定的张力绘制经过一组指定的 <see cref="T:System.Drawing.PointF" /> 结构的基数样条。 从相对于数组开始位置的偏移量开始绘制。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法绘制经过数组中每个点的基数样条。  
  
 点的数组必须包含至少三个<xref:System.Drawing.PointF>要绘制曲线的结构。  
  
 值`offset`参数指定要跳过数组中的元素数。 已跳过的元素之后的第一个元素表示曲线的起始点。  
  
 值`numberOfSegments`参数指定的段数之后以绘制曲线中起始点。 值`numberOfSegments`参数必须是至少为 1。 值`offset`参数和值`numberOfSegments`参数必须是中的数组的元素数小于`points`参数。  
  
 `tension`参数确定的自由绘制曲线形状。 如果的值`tension`参数为 0.0F 时，此方法绘制直线段连接的点。 通常情况下，`tension`参数小于或等于 1.0 f。 超过 1.0 f 的值将产生不正常的结果。  
  
   
  
## Examples  
 下面的代码示例设计为使用 Windows 窗体，并且它需要<xref:System.Windows.Forms.PaintEventArgs> `e`，这是一个参数的<xref:System.Windows.Forms.Control.Paint>事件处理程序。 该代码执行下列操作：  
  
-   创建红色和绿色的笔。  
  
-   创建七个点来定义一条曲线。  
  
-   以形成一个不完整的多边形的七个点之间绘制六个红色的直线。  
  
-   定义的起始点偏移量和的段数。  
  
-   定义张力。  
  
-   绘制一打开绿色条曲线 （从第三个点） 通过最后五个点。  
  
 该方法将设置为 1.0 的张力。  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples#25](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CPP/form1.cpp#25)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples#25](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CS/form1.cs#25)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples#25](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/VB/form1.vb#25)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="pen" /> 为 <see langword="null" />。  
  
或 
 <paramref name="points" /> 为 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="DrawEllipse">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>绘制一个由边框（该边框由一对坐标、高度和宽度指定）定义的椭圆。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DrawEllipse">
      <MemberSignature Language="C#" Value="public void DrawEllipse (System.Drawing.Pen pen, System.Drawing.Rectangle rect);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawEllipse(class System.Drawing.Pen pen, valuetype System.Drawing.Rectangle rect) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawEllipse(System.Drawing.Pen,System.Drawing.Rectangle)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawEllipse(System::Drawing::Pen ^ pen, System::Drawing::Rectangle rect);" />
      <MemberSignature Language="F#" Value="member this.DrawEllipse : System.Drawing.Pen * System.Drawing.Rectangle -&gt; unit" Usage="graphics.DrawEllipse (pen, rect)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pen" Type="System.Drawing.Pen" />
        <Parameter Name="rect" Type="System.Drawing.Rectangle" />
      </Parameters>
      <Docs>
        <param name="pen">
          <see cref="T:System.Drawing.Pen" />，它确定曲线的颜色、宽度和样式。</param>
        <param name="rect">
          <see cref="T:System.Drawing.Rectangle" /> 结构，它定义椭圆的边界。</param>
        <summary>绘制边界 <see cref="T:System.Drawing.Rectangle" /> 结构指定的椭圆。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法绘制由指定的边界矩形来定义一个椭圆`rect`参数。  
  
   
  
## Examples  
 下面的代码示例设计为使用 Windows 窗体，并且它需要<xref:System.Windows.Forms.PaintEventArgs> `e`，这是一个参数的<xref:System.Windows.Forms.Control.Paint>事件处理程序。 该代码执行下列操作：  
  
-   创建黑色的笔。  
  
-   创建要绑定一个椭圆的矩形。  
  
-   在屏幕上绘制椭圆。  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples#27](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CPP/form1.cpp#27)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples#27](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CS/form1.cs#27)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples#27](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/VB/form1.vb#27)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="pen" /> 为 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="DrawEllipse">
      <MemberSignature Language="C#" Value="public void DrawEllipse (System.Drawing.Pen pen, System.Drawing.RectangleF rect);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawEllipse(class System.Drawing.Pen pen, valuetype System.Drawing.RectangleF rect) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawEllipse(System.Drawing.Pen,System.Drawing.RectangleF)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawEllipse(System::Drawing::Pen ^ pen, System::Drawing::RectangleF rect);" />
      <MemberSignature Language="F#" Value="member this.DrawEllipse : System.Drawing.Pen * System.Drawing.RectangleF -&gt; unit" Usage="graphics.DrawEllipse (pen, rect)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pen" Type="System.Drawing.Pen" />
        <Parameter Name="rect" Type="System.Drawing.RectangleF" />
      </Parameters>
      <Docs>
        <param name="pen">
          <see cref="T:System.Drawing.Pen" />，它确定曲线的颜色、宽度和样式。</param>
        <param name="rect">
          <see cref="T:System.Drawing.RectangleF" /> 结构，它定义椭圆的边界。</param>
        <summary>绘制边界 <see cref="T:System.Drawing.RectangleF" /> 定义的椭圆。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法绘制由指定的边界矩形来定义一个椭圆`rect`参数。  
  
   
  
## Examples  
 下面的代码示例设计为使用 Windows 窗体，并且它需要<xref:System.Windows.Forms.PaintEventArgs> `e`，这是一个参数的<xref:System.Windows.Forms.Control.Paint>事件处理程序。 该代码执行下列操作：  
  
-   创建黑色的笔。  
  
-   创建要绑定一个椭圆的矩形。  
  
-   在屏幕上绘制椭圆。  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples#28](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CPP/form1.cpp#28)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples#28](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CS/form1.cs#28)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples#28](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/VB/form1.vb#28)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="pen" /> 为 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="DrawEllipse">
      <MemberSignature Language="C#" Value="public void DrawEllipse (System.Drawing.Pen pen, int x, int y, int width, int height);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawEllipse(class System.Drawing.Pen pen, int32 x, int32 y, int32 width, int32 height) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawEllipse(System.Drawing.Pen,System.Int32,System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawEllipse(System::Drawing::Pen ^ pen, int x, int y, int width, int height);" />
      <MemberSignature Language="F#" Value="member this.DrawEllipse : System.Drawing.Pen * int * int * int * int -&gt; unit" Usage="graphics.DrawEllipse (pen, x, y, width, height)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pen" Type="System.Drawing.Pen" />
        <Parameter Name="x" Type="System.Int32" />
        <Parameter Name="y" Type="System.Int32" />
        <Parameter Name="width" Type="System.Int32" />
        <Parameter Name="height" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="pen">
          <see cref="T:System.Drawing.Pen" />，它确定曲线的颜色、宽度和样式。</param>
        <param name="x">定义椭圆的边框的左上角的 X 坐标。</param>
        <param name="y">定义椭圆的边框的左上角的 Y 坐标。</param>
        <param name="width">定义椭圆的边框的宽度。</param>
        <param name="height">定义椭圆的边框的高度。</param>
        <summary>绘制一个由边框定义的椭圆，该边框由矩形的左上角坐标、高度和宽度指定。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法绘制一个椭圆所定义所描述的边框`x`， `y`， `width`，和`height`参数。  
  
   
  
## Examples  
 下面的代码示例设计为使用 Windows 窗体，并且它需要<xref:System.Windows.Forms.PaintEventArgs> `e`，这是一个参数的<xref:System.Windows.Forms.Control.Paint>事件处理程序。 该代码执行下列操作：  
  
-   创建黑色的笔。  
  
-   创建位置和要绑定一个椭圆的矩形的大小。  
  
-   在屏幕上绘制椭圆。  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples#29](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CPP/form1.cpp#29)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples#29](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CS/form1.cs#29)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples#29](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/VB/form1.vb#29)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="pen" /> 为 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="DrawEllipse">
      <MemberSignature Language="C#" Value="public void DrawEllipse (System.Drawing.Pen pen, float x, float y, float width, float height);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawEllipse(class System.Drawing.Pen pen, float32 x, float32 y, float32 width, float32 height) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawEllipse(System.Drawing.Pen,System.Single,System.Single,System.Single,System.Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawEllipse(System::Drawing::Pen ^ pen, float x, float y, float width, float height);" />
      <MemberSignature Language="F#" Value="member this.DrawEllipse : System.Drawing.Pen * single * single * single * single -&gt; unit" Usage="graphics.DrawEllipse (pen, x, y, width, height)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pen" Type="System.Drawing.Pen" />
        <Parameter Name="x" Type="System.Single" />
        <Parameter Name="y" Type="System.Single" />
        <Parameter Name="width" Type="System.Single" />
        <Parameter Name="height" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="pen">
          <see cref="T:System.Drawing.Pen" />，它确定曲线的颜色、宽度和样式。</param>
        <param name="x">定义椭圆的边框的左上角的 X 坐标。</param>
        <param name="y">定义椭圆的边框的左上角的 Y 坐标。</param>
        <param name="width">定义椭圆的边框的宽度。</param>
        <param name="height">定义椭圆的边框的高度。</param>
        <summary>绘制一个由边框（该边框由一对坐标、高度和宽度指定）定义的椭圆。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法绘制一个椭圆所定义所描述的边框`x`， `y`， `width`，和`height`参数。  
  
   
  
## Examples  
 下面的代码示例设计为使用 Windows 窗体，并且它需要<xref:System.Windows.Forms.PaintEventArgs> `e`，这是一个参数的<xref:System.Windows.Forms.Control.Paint>事件处理程序。 该代码执行下列操作：  
  
-   创建黑色的笔。  
  
-   创建位置和要绑定一个椭圆的矩形的大小。  
  
-   在屏幕上绘制椭圆。  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples#30](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CPP/form1.cpp#30)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples#30](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CS/form1.cs#30)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples#30](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/VB/form1.vb#30)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="pen" /> 为 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="DrawIcon">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>在指定坐标处绘制由指定的 <see cref="T:System.Drawing.Icon" /> 表示的图像。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DrawIcon">
      <MemberSignature Language="C#" Value="public void DrawIcon (System.Drawing.Icon icon, System.Drawing.Rectangle targetRect);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawIcon(class System.Drawing.Icon icon, valuetype System.Drawing.Rectangle targetRect) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawIcon(System.Drawing.Icon,System.Drawing.Rectangle)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawIcon(System::Drawing::Icon ^ icon, System::Drawing::Rectangle targetRect);" />
      <MemberSignature Language="F#" Value="member this.DrawIcon : System.Drawing.Icon * System.Drawing.Rectangle -&gt; unit" Usage="graphics.DrawIcon (icon, targetRect)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="icon" Type="System.Drawing.Icon" />
        <Parameter Name="targetRect" Type="System.Drawing.Rectangle" />
      </Parameters>
      <Docs>
        <param name="icon">要绘制的 <see cref="T:System.Drawing.Icon" />。</param>
        <param name="targetRect">
          <see cref="T:System.Drawing.Rectangle" /> 结构，它指定显示面上结果图像的位置和大小。 将 <c>icon</c> 参数中包含的图像缩放为此矩形区域的尺寸。</param>
        <summary>在 <see cref="T:System.Drawing.Icon" /> 结构指定的区域内绘制指定的 <see cref="T:System.Drawing.Rectangle" /> 表示的图像。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下面的代码示例设计为使用 Windows 窗体，并且它需要<xref:System.Windows.Forms.PaintEventArgs> `e`，这是一个参数的<xref:System.Windows.Forms.Control.Paint>事件处理程序。 该代码执行下列操作：  
  
-   通过标准的 Windows 图标文件 SampIcon.ico 示例文件夹中创建一个图标。  
  
-   创建要在其中绘制该图标的矩形。  
  
-   在屏幕上绘制图标。  
  
 矩形的位置查找图标在屏幕上，并绘制图标的缩放比例的矩形的大小确定。  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples#31](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CPP/form1.cpp#31)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples#31](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CS/form1.cs#31)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples#31](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/VB/form1.vb#31)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="icon" /> 为 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="DrawIcon">
      <MemberSignature Language="C#" Value="public void DrawIcon (System.Drawing.Icon icon, int x, int y);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawIcon(class System.Drawing.Icon icon, int32 x, int32 y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawIcon(System.Drawing.Icon,System.Int32,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawIcon(System::Drawing::Icon ^ icon, int x, int y);" />
      <MemberSignature Language="F#" Value="member this.DrawIcon : System.Drawing.Icon * int * int -&gt; unit" Usage="graphics.DrawIcon (icon, x, y)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="icon" Type="System.Drawing.Icon" />
        <Parameter Name="x" Type="System.Int32" />
        <Parameter Name="y" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="icon">要绘制的 <see cref="T:System.Drawing.Icon" />。</param>
        <param name="x">所绘制图像的左上角的 x 坐标。</param>
        <param name="y">所绘制图像的左上角的 y 坐标。</param>
        <summary>在指定坐标处绘制由指定的 <see cref="T:System.Drawing.Icon" /> 表示的图像。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下面的代码示例设计为使用 Windows 窗体，并且它需要<xref:System.Windows.Forms.PaintEventArgs> `e`，这是一个参数的<xref:System.Windows.Forms.Control.Paint>事件处理程序。 该代码执行下列操作：  
  
-   通过标准的 Windows 图标文件 SampIcon.ico 示例文件夹中创建一个图标。  
  
-   创建在其中绘制该图标在左上角的坐标。  
  
-   在屏幕上绘制图标。  
  
 绘制的图标是不成比例。  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples#32](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CPP/form1.cpp#32)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples#32](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CS/form1.cs#32)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples#32](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/VB/form1.vb#32)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="icon" /> 为 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="DrawIconUnstretched">
      <MemberSignature Language="C#" Value="public void DrawIconUnstretched (System.Drawing.Icon icon, System.Drawing.Rectangle targetRect);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawIconUnstretched(class System.Drawing.Icon icon, valuetype System.Drawing.Rectangle targetRect) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawIconUnstretched(System.Drawing.Icon,System.Drawing.Rectangle)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawIconUnstretched(System::Drawing::Icon ^ icon, System::Drawing::Rectangle targetRect);" />
      <MemberSignature Language="F#" Value="member this.DrawIconUnstretched : System.Drawing.Icon * System.Drawing.Rectangle -&gt; unit" Usage="graphics.DrawIconUnstretched (icon, targetRect)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="icon" Type="System.Drawing.Icon" />
        <Parameter Name="targetRect" Type="System.Drawing.Rectangle" />
      </Parameters>
      <Docs>
        <param name="icon">要绘制的 <see cref="T:System.Drawing.Icon" />。</param>
        <param name="targetRect">
          <see cref="T:System.Drawing.Rectangle" /> 结构，它指定所绘制图像的位置和大小。 不缩放图像以适合此矩形的大小，但保留其原始大小。 如果该图像比该矩形大，将它剪裁到适合它的大小。</param>
        <summary>绘制指定的 <see cref="T:System.Drawing.Icon" /> 表示的图像，而不缩放该图像。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下面的代码示例设计为使用 Windows 窗体，并且它需要<xref:System.Windows.Forms.PaintEventArgs> `e`，这是一个参数的<xref:System.Windows.Forms.Control.Paint>事件处理程序。 该代码执行下列操作：  
  
-   通过标准的 Windows 图标文件 SampIcon.ico 示例文件夹中创建一个图标。  
  
-   创建要在其中绘制该图标的矩形。  
  
-   在屏幕上绘制图标。  
  
 矩形的位置在屏幕上，查找该图标，并不成比例，也未剪裁绘制的图标。  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples#33](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CPP/form1.cpp#33)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples#33](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CS/form1.cs#33)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples#33](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/VB/form1.vb#33)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="icon" /> 为 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="DrawImage">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>在指定位置并且按原始大小绘制指定的 <see cref="T:System.Drawing.Image" />。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DrawImage">
      <MemberSignature Language="C#" Value="public void DrawImage (System.Drawing.Image image, System.Drawing.Point point);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawImage(class System.Drawing.Image image, valuetype System.Drawing.Point point) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawImage(System.Drawing.Image,System.Drawing.Point)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawImage(System::Drawing::Image ^ image, System::Drawing::Point point);" />
      <MemberSignature Language="F#" Value="member this.DrawImage : System.Drawing.Image * System.Drawing.Point -&gt; unit" Usage="graphics.DrawImage (image, point)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="image" Type="System.Drawing.Image" />
        <Parameter Name="point" Type="System.Drawing.Point" />
      </Parameters>
      <Docs>
        <param name="image">要绘制的 <see cref="T:System.Drawing.Image" />。</param>
        <param name="point">
          <see cref="T:System.Drawing.Point" /> 结构，它表示所绘制图像的左上角的位置。</param>
        <summary>在指定的位置使用原始物理大小绘制指定的 <see cref="T:System.Drawing.Image" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Drawing.Image>存储像素宽度值和水平分辨率 （每英寸点数） 的值。 物理宽度，以英寸为单位的单位是图像的像素宽度除以的水平分辨率。 例如，使用像素宽度为 216 和 72 点 / 英寸的水平分辨率的图像具有物理 3 英寸的宽度。 说明同样适用于像素高度和物理的高度。  
  
 此方法绘制图像使用的物理大小，因此该图像将出现正确的大小，以英寸为单位，而不考虑显示设备的分辨率 （每英寸点数）。 例如，假设图像具有像素宽度为 216 和 72 点 / 英寸的水平分辨率。 如果调用此方法以绘制该图像的分辨率为 96 点 / 英寸的设备上，呈现的图像的像素宽度将是 (216/72) * 96 = 288 条。  
  
   
  
## Examples  
 下面的代码示例设计为使用 Windows 窗体，并且它需要<xref:System.Windows.Forms.PaintEventArgs> `e`，这是一个参数的<xref:System.Windows.Forms.Control.Paint>事件处理程序。 该代码执行下列操作：  
  
-   创建从 JPEG 文件的文件夹中的示例 sampimag.jpg 位于同一个图像。  
  
-   创建在其中绘制图像的左上角的点。  
  
-   将不成比例的图像绘制到屏幕。  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples#34](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CPP/form1.cpp#34)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples#34](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CS/form1.cs#34)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples#34](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/VB/form1.vb#34)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="image" /> 为 <see langword="null" />。</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">图像、位图和图元文件</related>
      </Docs>
    </Member>
    <Member MemberName="DrawImage">
      <MemberSignature Language="C#" Value="public void DrawImage (System.Drawing.Image image, System.Drawing.Point[] destPoints);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawImage(class System.Drawing.Image image, valuetype System.Drawing.Point[] destPoints) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawImage(System.Drawing.Image,System.Drawing.Point[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawImage(System::Drawing::Image ^ image, cli::array &lt;System::Drawing::Point&gt; ^ destPoints);" />
      <MemberSignature Language="F#" Value="member this.DrawImage : System.Drawing.Image * System.Drawing.Point[] -&gt; unit" Usage="graphics.DrawImage (image, destPoints)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="image" Type="System.Drawing.Image" />
        <Parameter Name="destPoints" Type="System.Drawing.Point[]" />
      </Parameters>
      <Docs>
        <param name="image">要绘制的 <see cref="T:System.Drawing.Image" />。</param>
        <param name="destPoints">由三个 <see cref="T:System.Drawing.Point" /> 结构组成的数组，这三个结构定义一个平行四边形。</param>
        <summary>在指定位置并且按指定形状和大小绘制指定的 <see cref="T:System.Drawing.Image" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `destPoints`参数指定的平行四边形的三个点。 这三个<xref:System.Drawing.Point>结构表示的平行四边形的左上角、 右上方和左下角。 第四个点推断出的前三个以形成一个平行四边形。  
  
 表示的图像`image`缩放和剪切以适合指定的平行四边形的形状参数`destPoints`参数。  
  
   
  
## Examples  
 下面的代码示例设计为使用 Windows 窗体，并且它需要<xref:System.Windows.Forms.PaintEventArgs> `e`，这是一个参数的<xref:System.Windows.Forms.Control.Paint>事件处理程序。 该代码执行下列操作：  
  
-   创建从 JPEG 文件的文件夹中的示例 sampimag.jpg 位于同一个图像。  
  
-   创建定义要在其中绘制图像的一个平行四边形的点。  
  
-   将图像绘制到屏幕。  
  
 平行四边形的位置确定图像在屏幕上，而原始映像和大小的大小和形状平行四边形的确定的缩放和剪切所绘制图像。  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples#35](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CPP/form1.cpp#35)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples#35](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CS/form1.cs#35)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples#35](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/VB/form1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="image" /> 为 <see langword="null" />。</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">图像、位图和图元文件</related>
      </Docs>
    </Member>
    <Member MemberName="DrawImage">
      <MemberSignature Language="C#" Value="public void DrawImage (System.Drawing.Image image, System.Drawing.PointF point);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawImage(class System.Drawing.Image image, valuetype System.Drawing.PointF point) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawImage(System.Drawing.Image,System.Drawing.PointF)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawImage(System::Drawing::Image ^ image, System::Drawing::PointF point);" />
      <MemberSignature Language="F#" Value="member this.DrawImage : System.Drawing.Image * System.Drawing.PointF -&gt; unit" Usage="graphics.DrawImage (image, point)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="image" Type="System.Drawing.Image" />
        <Parameter Name="point" Type="System.Drawing.PointF" />
      </Parameters>
      <Docs>
        <param name="image">要绘制的 <see cref="T:System.Drawing.Image" />。</param>
        <param name="point">
          <see cref="T:System.Drawing.PointF" /> 结构，它指定所绘制图像的左上角。</param>
        <summary>在指定的位置使用原始物理大小绘制指定的 <see cref="T:System.Drawing.Image" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Drawing.Image>存储像素宽度值和水平分辨率 （每英寸点数） 的值。 物理宽度，以英寸为单位的单位是图像的像素宽度除以的水平分辨率。 例如，使用像素宽度为 216 和 72 点 / 英寸的水平分辨率的图像具有物理 3 英寸的宽度。 说明同样适用于像素高度和物理的高度。  
  
 此方法绘制图像使用的物理大小，因此该图像将出现正确的大小，以英寸为单位，而不考虑显示设备的分辨率 （每英寸点数）。 例如，假设图像具有像素宽度为 216 和 72 点 / 英寸的水平分辨率。 如果调用此方法以绘制该图像的分辨率为 96 点 / 英寸的设备上，呈现的图像的像素宽度将是 (216/72) * 96 = 288 条。  
  
   
  
## Examples  
 下面的代码示例设计为使用 Windows 窗体，并且它需要<xref:System.Windows.Forms.PaintEventArgs> `e`，这是一个参数的<xref:System.Windows.Forms.Control.Paint>事件处理程序。 该代码执行下列操作：  
  
-   创建从 JPEG 文件的文件夹中的示例 sampimag.jpg 位于同一个图像。  
  
-   创建在其中绘制图像的左上角的点。  
  
-   将不成比例的图像绘制到屏幕。  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples#40](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CPP/form1.cpp#40)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples#40](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CS/form1.cs#40)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples#40](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/VB/form1.vb#40)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="image" /> 为 <see langword="null" />。</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">图像、位图和图元文件</related>
      </Docs>
    </Member>
    <Member MemberName="DrawImage">
      <MemberSignature Language="C#" Value="public void DrawImage (System.Drawing.Image image, System.Drawing.PointF[] destPoints);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawImage(class System.Drawing.Image image, valuetype System.Drawing.PointF[] destPoints) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawImage(System.Drawing.Image,System.Drawing.PointF[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawImage(System::Drawing::Image ^ image, cli::array &lt;System::Drawing::PointF&gt; ^ destPoints);" />
      <MemberSignature Language="F#" Value="member this.DrawImage : System.Drawing.Image * System.Drawing.PointF[] -&gt; unit" Usage="graphics.DrawImage (image, destPoints)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="image" Type="System.Drawing.Image" />
        <Parameter Name="destPoints" Type="System.Drawing.PointF[]" />
      </Parameters>
      <Docs>
        <param name="image">要绘制的 <see cref="T:System.Drawing.Image" />。</param>
        <param name="destPoints">由三个 <see cref="T:System.Drawing.PointF" /> 结构组成的数组，这三个结构定义一个平行四边形。</param>
        <summary>在指定位置并且按指定形状和大小绘制指定的 <see cref="T:System.Drawing.Image" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `destPoints`参数指定的平行四边形的三个点。 这三个<xref:System.Drawing.PointF>结构表示的平行四边形的左上角、 右上方和左下角。 第四个点推断出的前三个以形成一个平行四边形。  
  
 表示的图像`image`缩放和剪切以适合指定的平行四边形的形状对象`destPoints`参数。  
  
   
  
## Examples  
 下面的代码示例设计为使用 Windows 窗体，并且它需要<xref:System.Windows.Forms.PaintEventArgs> `e`，这是一个参数的<xref:System.Windows.Forms.Control.Paint>事件处理程序。 该代码执行下列操作：  
  
-   创建从 JPEG 文件的文件夹中的示例 sampimag.jpg 位于同一个图像。  
  
-   创建定义要在其中绘制图像的一个平行四边形的点。  
  
-   将图像绘制到屏幕。  
  
 平行四边形的位置确定图像在屏幕上，而原始映像和大小的大小和形状平行四边形的确定的缩放和剪切所绘制图像。  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples#41](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CPP/form1.cpp#41)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples#41](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CS/form1.cs#41)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples#41](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/VB/form1.vb#41)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="image" /> 为 <see langword="null" />。</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">图像、位图和图元文件</related>
      </Docs>
    </Member>
    <Member MemberName="DrawImage">
      <MemberSignature Language="C#" Value="public void DrawImage (System.Drawing.Image image, System.Drawing.Rectangle rect);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawImage(class System.Drawing.Image image, valuetype System.Drawing.Rectangle rect) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawImage(System.Drawing.Image,System.Drawing.Rectangle)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawImage(System::Drawing::Image ^ image, System::Drawing::Rectangle rect);" />
      <MemberSignature Language="F#" Value="member this.DrawImage : System.Drawing.Image * System.Drawing.Rectangle -&gt; unit" Usage="graphics.DrawImage (image, rect)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="image" Type="System.Drawing.Image" />
        <Parameter Name="rect" Type="System.Drawing.Rectangle" />
      </Parameters>
      <Docs>
        <param name="image">要绘制的 <see cref="T:System.Drawing.Image" />。</param>
        <param name="rect">
          <see cref="T:System.Drawing.Rectangle" /> 结构，它指定所绘制图像的位置和大小。</param>
        <summary>在指定位置并且按指定大小绘制指定的 <see cref="T:System.Drawing.Image" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 表示的图像`image`对象的维度进行缩放`rect`矩形。  
  
   
  
## Examples  
 下面的代码示例设计为使用 Windows 窗体，并且它需要<xref:System.Windows.Forms.PaintEventArgs> `e`，这是一个参数的<xref:System.Windows.Forms.Control.Paint>事件处理程序。 该代码执行下列操作：  
  
-   创建从 JPEG 文件的文件夹中的示例 sampimag.jpg 位于同一个图像。  
  
-   创建在其中绘制图像的矩形。  
  
-   将图像绘制到屏幕。  
  
 矩形的位置确定图像在屏幕上，而原始图像的大小和矩形的大小确定所绘制图像的缩放。  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples#46](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CPP/form1.cpp#46)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples#46](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CS/form1.cs#46)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples#46](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/VB/form1.vb#46)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="image" /> 为 <see langword="null" />。</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">图像、位图和图元文件</related>
      </Docs>
    </Member>
    <Member MemberName="DrawImage">
      <MemberSignature Language="C#" Value="public void DrawImage (System.Drawing.Image image, System.Drawing.RectangleF rect);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawImage(class System.Drawing.Image image, valuetype System.Drawing.RectangleF rect) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawImage(System.Drawing.Image,System.Drawing.RectangleF)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawImage(System::Drawing::Image ^ image, System::Drawing::RectangleF rect);" />
      <MemberSignature Language="F#" Value="member this.DrawImage : System.Drawing.Image * System.Drawing.RectangleF -&gt; unit" Usage="graphics.DrawImage (image, rect)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="image" Type="System.Drawing.Image" />
        <Parameter Name="rect" Type="System.Drawing.RectangleF" />
      </Parameters>
      <Docs>
        <param name="image">要绘制的 <see cref="T:System.Drawing.Image" />。</param>
        <param name="rect">
          <see cref="T:System.Drawing.RectangleF" /> 结构，它指定所绘制图像的位置和大小。</param>
        <summary>在指定位置并且按指定大小绘制指定的 <see cref="T:System.Drawing.Image" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 表示的图像`image`对象的维度进行缩放`rect`矩形。  
  
   
  
## Examples  
 下面的代码示例设计为使用 Windows 窗体，并且它需要<xref:System.Windows.Forms.PaintEventArgs> `e`，这是一个参数的<xref:System.Windows.Forms.Control.Paint>事件处理程序。 该代码执行下列操作：  
  
-   创建从 JPEG 文件的文件夹中的示例 sampimag.jpg 位于同一个图像。  
  
-   创建在其中绘制图像的矩形。  
  
-   将图像绘制到屏幕。  
  
 矩形的位置确定图像在屏幕上，而图像的原始大小和矩形的大小确定所绘制图像的缩放。  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples2#56](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CPP/form1.cpp#56)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples2#56](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CS/form1.cs#56)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples2#56](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/VB/form1.vb#56)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="image" /> 为 <see langword="null" />。</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">图像、位图和图元文件</related>
      </Docs>
    </Member>
    <Member MemberName="DrawImage">
      <MemberSignature Language="C#" Value="public void DrawImage (System.Drawing.Image image, int x, int y);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawImage(class System.Drawing.Image image, int32 x, int32 y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawImage(System.Drawing.Image,System.Int32,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawImage(System::Drawing::Image ^ image, int x, int y);" />
      <MemberSignature Language="F#" Value="member this.DrawImage : System.Drawing.Image * int * int -&gt; unit" Usage="graphics.DrawImage (image, x, y)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="image" Type="System.Drawing.Image" />
        <Parameter Name="x" Type="System.Int32" />
        <Parameter Name="y" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="image">要绘制的 <see cref="T:System.Drawing.Image" />。</param>
        <param name="x">所绘制图像的左上角的 x 坐标。</param>
        <param name="y">所绘制图像的左上角的 y 坐标。</param>
        <summary>在由坐标对指定的位置，使用图像的原始物理大小绘制指定的图像。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Drawing.Image>存储像素宽度值和水平分辨率 （每英寸点数） 的值。 物理宽度，以英寸为单位的单位是图像的像素宽度除以的水平分辨率。 例如，使用像素宽度为 216 和 72 点 / 英寸的水平分辨率的图像具有物理 3 英寸的宽度。 说明同样适用于像素高度和物理的高度。  
  
 <xref:System.Drawing.Graphics.DrawImage%2A>方法绘制一个图像使用的物理大小，因此该图像将出现正确的大小，以英寸为单位，而不考虑显示设备的分辨率 （每英寸点数）。 例如，假设图像具有像素宽度为 216 和 72 点 / 英寸的水平分辨率。 如果调用<xref:System.Drawing.Graphics.DrawImage%2A>绘制该图像的分辨率为 96 点 / 英寸的设备上，呈现的图像的像素宽度将是 (216/72) * 96 = 288 条。  
  
   
  
## Examples  
 下面的代码示例设计为使用 Windows 窗体，并且它需要<xref:System.Windows.Forms.PaintEventArgs> `e`，这是一个参数的<xref:System.Windows.Forms.Control.Paint>事件处理程序。 该代码执行下列操作：  
  
-   创建从 JPEG 文件的文件夹中的示例中的示例文件夹中的 sampimag.jpg 位于同 sampimag.jpg 位于同一个图像。  
  
-   创建在其中绘制图像的左上角的点的坐标。  
  
-   绘制不成比例的图像。  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples2#58](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CPP/form1.cpp#58)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples2#58](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CS/form1.cs#58)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples2#58](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/VB/form1.vb#58)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="image" /> 为 <see langword="null" />。</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">图像、位图和图元文件</related>
      </Docs>
    </Member>
    <Member MemberName="DrawImage">
      <MemberSignature Language="C#" Value="public void DrawImage (System.Drawing.Image image, float x, float y);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawImage(class System.Drawing.Image image, float32 x, float32 y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawImage(System.Drawing.Image,System.Single,System.Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawImage(System::Drawing::Image ^ image, float x, float y);" />
      <MemberSignature Language="F#" Value="member this.DrawImage : System.Drawing.Image * single * single -&gt; unit" Usage="graphics.DrawImage (image, x, y)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="image" Type="System.Drawing.Image" />
        <Parameter Name="x" Type="System.Single" />
        <Parameter Name="y" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="image">要绘制的 <see cref="T:System.Drawing.Image" />。</param>
        <param name="x">所绘制图像的左上角的 x 坐标。</param>
        <param name="y">所绘制图像的左上角的 y 坐标。</param>
        <summary>在指定的位置使用原始物理大小绘制指定的 <see cref="T:System.Drawing.Image" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Drawing.Image>存储像素宽度值和水平分辨率 （每英寸点数） 的值。 物理宽度，以英寸为单位的单位是图像的像素宽度除以的水平分辨率。 例如，使用像素宽度为 216 和 72 点 / 英寸的水平分辨率的图像具有物理 3 英寸的宽度。 说明同样适用于像素高度和物理的高度。  
  
 此方法绘制图像使用的物理大小，因此该图像将出现正确的大小，以英寸为单位，而不考虑显示设备的分辨率 （每英寸点数）。 例如，假设图像具有像素宽度为 216 和 72 点 / 英寸的水平分辨率。 如果调用此方法以绘制该图像的分辨率为 96 点 / 英寸的设备上，呈现的图像的像素宽度将是 (216/72) * 96 = 288 条。  
  
   
  
## Examples  
 下面的代码示例设计为使用 Windows 窗体，并且它需要<xref:System.Windows.Forms.PaintEventArgs> `e`，这是一个参数的<xref:System.Windows.Forms.Control.Paint>事件处理程序。 该代码执行下列操作：  
  
-   创建从 JPEG 文件的文件夹中的示例 sampimag.jpg 位于同一个图像。  
  
-   创建在其中绘制图像的左上角的点的坐标。  
  
-   将不成比例的图像绘制到屏幕。  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples2#61](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CPP/form1.cpp#61)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples2#61](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CS/form1.cs#61)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples2#61](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/VB/form1.vb#61)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="image" /> 为 <see langword="null" />。</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">图像、位图和图元文件</related>
      </Docs>
    </Member>
    <Member MemberName="DrawImage">
      <MemberSignature Language="C#" Value="public void DrawImage (System.Drawing.Image image, System.Drawing.Point[] destPoints, System.Drawing.Rectangle srcRect, System.Drawing.GraphicsUnit srcUnit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawImage(class System.Drawing.Image image, valuetype System.Drawing.Point[] destPoints, valuetype System.Drawing.Rectangle srcRect, valuetype System.Drawing.GraphicsUnit srcUnit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawImage(System.Drawing.Image,System.Drawing.Point[],System.Drawing.Rectangle,System.Drawing.GraphicsUnit)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawImage(System::Drawing::Image ^ image, cli::array &lt;System::Drawing::Point&gt; ^ destPoints, System::Drawing::Rectangle srcRect, System::Drawing::GraphicsUnit srcUnit);" />
      <MemberSignature Language="F#" Value="member this.DrawImage : System.Drawing.Image * System.Drawing.Point[] * System.Drawing.Rectangle * System.Drawing.GraphicsUnit -&gt; unit" Usage="graphics.DrawImage (image, destPoints, srcRect, srcUnit)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="image" Type="System.Drawing.Image" />
        <Parameter Name="destPoints" Type="System.Drawing.Point[]" />
        <Parameter Name="srcRect" Type="System.Drawing.Rectangle" />
        <Parameter Name="srcUnit" Type="System.Drawing.GraphicsUnit" />
      </Parameters>
      <Docs>
        <param name="image">要绘制的 <see cref="T:System.Drawing.Image" />。</param>
        <param name="destPoints">由三个 <see cref="T:System.Drawing.Point" /> 结构组成的数组，这三个结构定义一个平行四边形。</param>
        <param name="srcRect">
          <see cref="T:System.Drawing.Rectangle" /> 结构，它指定 <c>image</c> 对象中要绘制的部分。</param>
        <param name="srcUnit">
          <see cref="T:System.Drawing.GraphicsUnit" /> 枚举的成员，它指定 <c>srcRect</c> 参数所用的度量单位。</param>
        <summary>在指定位置并且按指定大小绘制指定的 <see cref="T:System.Drawing.Image" /> 的指定部分。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `destPoints`参数指定的平行四边形的三个点。 这三个<xref:System.Drawing.Point>结构表示的平行四边形的左上角、 右上方和左下角。 第四个点推断出的前三个以形成一个平行四边形。  
  
 `srcRect`参数指定一个矩形部分的`image`对象来绘制。 此部分进行缩放和剪切，以适合由指定的平行四边形`destPoints`参数。  
  
   
  
## Examples  
 下面的代码示例设计为使用 Windows 窗体，并且它需要<xref:System.Windows.Forms.PaintEventArgs> `e`，这是一个参数的<xref:System.Windows.Forms.Control.Paint>事件处理程序。 该代码执行下列操作：  
  
-   创建从 JPEG 文件的文件夹中的示例 sampimag.jpg 位于同一个图像。  
  
-   创建定义要在其中绘制图像的一个平行四边形的点。  
  
-   创建一个矩形来选择要绘制的图像的一部分。  
  
-   设置图形绘制像素为单位。  
  
-   将图像绘制到屏幕。  
  
 平行四边形的位置确定图像在屏幕上，并该矩形和大小的大小和形状平行四边形的确定的缩放和剪切所绘制图像。  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples#36](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CPP/form1.cpp#36)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples#36](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CS/form1.cs#36)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples#36](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/VB/form1.vb#36)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="image" /> 为 <see langword="null" />。</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">图像、位图和图元文件</related>
      </Docs>
    </Member>
    <Member MemberName="DrawImage">
      <MemberSignature Language="C#" Value="public void DrawImage (System.Drawing.Image image, System.Drawing.PointF[] destPoints, System.Drawing.RectangleF srcRect, System.Drawing.GraphicsUnit srcUnit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawImage(class System.Drawing.Image image, valuetype System.Drawing.PointF[] destPoints, valuetype System.Drawing.RectangleF srcRect, valuetype System.Drawing.GraphicsUnit srcUnit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawImage(System.Drawing.Image,System.Drawing.PointF[],System.Drawing.RectangleF,System.Drawing.GraphicsUnit)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawImage(System::Drawing::Image ^ image, cli::array &lt;System::Drawing::PointF&gt; ^ destPoints, System::Drawing::RectangleF srcRect, System::Drawing::GraphicsUnit srcUnit);" />
      <MemberSignature Language="F#" Value="member this.DrawImage : System.Drawing.Image * System.Drawing.PointF[] * System.Drawing.RectangleF * System.Drawing.GraphicsUnit -&gt; unit" Usage="graphics.DrawImage (image, destPoints, srcRect, srcUnit)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="image" Type="System.Drawing.Image" />
        <Parameter Name="destPoints" Type="System.Drawing.PointF[]" />
        <Parameter Name="srcRect" Type="System.Drawing.RectangleF" />
        <Parameter Name="srcUnit" Type="System.Drawing.GraphicsUnit" />
      </Parameters>
      <Docs>
        <param name="image">要绘制的 <see cref="T:System.Drawing.Image" />。</param>
        <param name="destPoints">由三个 <see cref="T:System.Drawing.PointF" /> 结构组成的数组，这三个结构定义一个平行四边形。</param>
        <param name="srcRect">
          <see cref="T:System.Drawing.RectangleF" /> 结构，它指定 <c>image</c> 对象中要绘制的部分。</param>
        <param name="srcUnit">
          <see cref="T:System.Drawing.GraphicsUnit" /> 枚举的成员，它指定 <c>srcRect</c> 参数所用的度量单位。</param>
        <summary>在指定位置并且按指定大小绘制指定的 <see cref="T:System.Drawing.Image" /> 的指定部分。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `destPoints`参数指定的平行四边形的三个点。 这三个<xref:System.Drawing.PointF>结构表示的平行四边形的左上角、 右上方和左下角。 第四个点推断出的前三个以形成一个平行四边形。  
  
 `srcRect`参数指定一个矩形部分的`image`对象来绘制。 此部分进行缩放和剪切，以适合由指定的平行四边形`destPoints`参数。  
  
   
  
## Examples  
 下面的代码示例设计为使用 Windows 窗体，并且它需要<xref:System.Windows.Forms.PaintEventArgs> `e`，这是一个参数的<xref:System.Windows.Forms.Control.Paint>事件处理程序。 该代码执行下列操作：  
  
-   创建从 JPEG 文件的文件夹中的示例 sampimag.jpg 位于同一个图像。  
  
-   创建定义要绘制图像在其中一个目标平行四边形的点。  
  
-   创建要从中提取图像的一部分的源矩形。  
  
-   设置源矩形的度量单位为像素。  
  
-   将图像绘制到屏幕。  
  
 目标的平行四边形的位置确定图像在屏幕上，源矩形和大小的大小和形状目标平行四边形确定的缩放和剪切所绘制图像的并确定矩形的大小原始图像的哪个部分绘制到屏幕。  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples#42](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CPP/form1.cpp#42)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples#42](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CS/form1.cs#42)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples#42](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/VB/form1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="image" /> 为 <see langword="null" />。</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">图像、位图和图元文件</related>
      </Docs>
    </Member>
    <Member MemberName="DrawImage">
      <MemberSignature Language="C#" Value="public void DrawImage (System.Drawing.Image image, System.Drawing.Rectangle destRect, System.Drawing.Rectangle srcRect, System.Drawing.GraphicsUnit srcUnit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawImage(class System.Drawing.Image image, valuetype System.Drawing.Rectangle destRect, valuetype System.Drawing.Rectangle srcRect, valuetype System.Drawing.GraphicsUnit srcUnit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawImage(System.Drawing.Image,System.Drawing.Rectangle,System.Drawing.Rectangle,System.Drawing.GraphicsUnit)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawImage(System::Drawing::Image ^ image, System::Drawing::Rectangle destRect, System::Drawing::Rectangle srcRect, System::Drawing::GraphicsUnit srcUnit);" />
      <MemberSignature Language="F#" Value="member this.DrawImage : System.Drawing.Image * System.Drawing.Rectangle * System.Drawing.Rectangle * System.Drawing.GraphicsUnit -&gt; unit" Usage="graphics.DrawImage (image, destRect, srcRect, srcUnit)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="image" Type="System.Drawing.Image" />
        <Parameter Name="destRect" Type="System.Drawing.Rectangle" />
        <Parameter Name="srcRect" Type="System.Drawing.Rectangle" />
        <Parameter Name="srcUnit" Type="System.Drawing.GraphicsUnit" />
      </Parameters>
      <Docs>
        <param name="image">要绘制的 <see cref="T:System.Drawing.Image" />。</param>
        <param name="destRect">
          <see cref="T:System.Drawing.Rectangle" /> 结构，它指定所绘制图像的位置和大小。 将图像进行缩放以适合该矩形。</param>
        <param name="srcRect">
          <see cref="T:System.Drawing.Rectangle" /> 结构，它指定 <c>image</c> 对象中要绘制的部分。</param>
        <param name="srcUnit">
          <see cref="T:System.Drawing.GraphicsUnit" /> 枚举的成员，它指定 <c>srcRect</c> 参数所用的度量单位。</param>
        <summary>在指定位置并且按指定大小绘制指定的 <see cref="T:System.Drawing.Image" /> 的指定部分。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `srcRect`参数指定一个矩形部分的`image`对象来绘制。 此部分缩放以适合指定的矩形`destRect`参数。  
  
   
  
## Examples  
 下面的代码示例设计为使用 Windows 窗体，并且它需要<xref:System.Windows.Forms.PaintEventArgs> `e`，这是一个参数的<xref:System.Windows.Forms.Control.Paint>事件处理程序。 该代码执行下列操作：  
  
-   创建从 JPEG 文件的文件夹中的示例 sampimag.jpg 位于同一个图像。  
  
-   创建在其中绘制图像的目标矩形。  
  
-   创建要从中提取图像的一部分的源矩形。  
  
-   设置源矩形的度量单位为像素。  
  
-   将图像绘制到屏幕。  
  
 目标矩形的位置确定在屏幕上图像、 源和目标矩形的大小确定所绘制图像的缩放和源矩形的大小确定原始图像的哪个部分绘制到屏幕。  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples#47](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CPP/form1.cpp#47)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples#47](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CS/form1.cs#47)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples#47](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/VB/form1.vb#47)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="image" /> 为 <see langword="null" />。</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">图像、位图和图元文件</related>
      </Docs>
    </Member>
    <Member MemberName="DrawImage">
      <MemberSignature Language="C#" Value="public void DrawImage (System.Drawing.Image image, System.Drawing.RectangleF destRect, System.Drawing.RectangleF srcRect, System.Drawing.GraphicsUnit srcUnit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawImage(class System.Drawing.Image image, valuetype System.Drawing.RectangleF destRect, valuetype System.Drawing.RectangleF srcRect, valuetype System.Drawing.GraphicsUnit srcUnit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawImage(System.Drawing.Image,System.Drawing.RectangleF,System.Drawing.RectangleF,System.Drawing.GraphicsUnit)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawImage(System::Drawing::Image ^ image, System::Drawing::RectangleF destRect, System::Drawing::RectangleF srcRect, System::Drawing::GraphicsUnit srcUnit);" />
      <MemberSignature Language="F#" Value="member this.DrawImage : System.Drawing.Image * System.Drawing.RectangleF * System.Drawing.RectangleF * System.Drawing.GraphicsUnit -&gt; unit" Usage="graphics.DrawImage (image, destRect, srcRect, srcUnit)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="image" Type="System.Drawing.Image" />
        <Parameter Name="destRect" Type="System.Drawing.RectangleF" />
        <Parameter Name="srcRect" Type="System.Drawing.RectangleF" />
        <Parameter Name="srcUnit" Type="System.Drawing.GraphicsUnit" />
      </Parameters>
      <Docs>
        <param name="image">要绘制的 <see cref="T:System.Drawing.Image" />。</param>
        <param name="destRect">
          <see cref="T:System.Drawing.RectangleF" /> 结构，它指定所绘制图像的位置和大小。 将图像进行缩放以适合该矩形。</param>
        <param name="srcRect">
          <see cref="T:System.Drawing.RectangleF" /> 结构，它指定 <c>image</c> 对象中要绘制的部分。</param>
        <param name="srcUnit">
          <see cref="T:System.Drawing.GraphicsUnit" /> 枚举的成员，它指定 <c>srcRect</c> 参数所用的度量单位。</param>
        <summary>在指定位置并且按指定大小绘制指定的 <see cref="T:System.Drawing.Image" /> 的指定部分。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `srcRect`参数指定一个矩形部分的`image`对象来绘制。 此部分缩放以适合指定的矩形`destRect`参数。  
  
   
  
## Examples  
 下面的代码示例设计为使用 Windows 窗体，并且它需要<xref:System.Windows.Forms.PaintEventArgs> `e`，这是一个参数的<xref:System.Windows.Forms.Control.Paint>事件处理程序。 该代码执行下列操作：  
  
-   创建从 JPEG 文件的文件夹中的示例 sampimag.jpg 位于同一个图像。  
  
-   创建在其中绘制图像的目标矩形。  
  
-   创建要从中提取图像的一部分的源矩形。  
  
-   设置源矩形的度量单位为像素。  
  
-   将图像绘制到屏幕。  
  
 目标矩形的位置确定在屏幕上图像、 源和目标矩形的大小确定所绘制图像的缩放和源矩形的大小确定原始图像的哪个部分绘制到屏幕。  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples2#57](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CPP/form1.cpp#57)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples2#57](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CS/form1.cs#57)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples2#57](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/VB/form1.vb#57)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="image" /> 为 <see langword="null" />。</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">图像、位图和图元文件</related>
      </Docs>
    </Member>
    <Member MemberName="DrawImage">
      <MemberSignature Language="C#" Value="public void DrawImage (System.Drawing.Image image, System.Drawing.Point[] destPoints, System.Drawing.Rectangle srcRect, System.Drawing.GraphicsUnit srcUnit, System.Drawing.Imaging.ImageAttributes imageAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawImage(class System.Drawing.Image image, valuetype System.Drawing.Point[] destPoints, valuetype System.Drawing.Rectangle srcRect, valuetype System.Drawing.GraphicsUnit srcUnit, class System.Drawing.Imaging.ImageAttributes imageAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawImage(System.Drawing.Image,System.Drawing.Point[],System.Drawing.Rectangle,System.Drawing.GraphicsUnit,System.Drawing.Imaging.ImageAttributes)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawImage(System::Drawing::Image ^ image, cli::array &lt;System::Drawing::Point&gt; ^ destPoints, System::Drawing::Rectangle srcRect, System::Drawing::GraphicsUnit srcUnit, System::Drawing::Imaging::ImageAttributes ^ imageAttr);" />
      <MemberSignature Language="F#" Value="member this.DrawImage : System.Drawing.Image * System.Drawing.Point[] * System.Drawing.Rectangle * System.Drawing.GraphicsUnit * System.Drawing.Imaging.ImageAttributes -&gt; unit" Usage="graphics.DrawImage (image, destPoints, srcRect, srcUnit, imageAttr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="image" Type="System.Drawing.Image" />
        <Parameter Name="destPoints" Type="System.Drawing.Point[]" />
        <Parameter Name="srcRect" Type="System.Drawing.Rectangle" />
        <Parameter Name="srcUnit" Type="System.Drawing.GraphicsUnit" />
        <Parameter Name="imageAttr" Type="System.Drawing.Imaging.ImageAttributes" />
      </Parameters>
      <Docs>
        <param name="image">要绘制的 <see cref="T:System.Drawing.Image" />。</param>
        <param name="destPoints">由三个 <see cref="T:System.Drawing.Point" /> 结构组成的数组，这三个结构定义一个平行四边形。</param>
        <param name="srcRect">
          <see cref="T:System.Drawing.Rectangle" /> 结构，它指定 <c>image</c> 对象中要绘制的部分。</param>
        <param name="srcUnit">
          <see cref="T:System.Drawing.GraphicsUnit" /> 枚举的成员，它指定 <c>srcRect</c> 参数所用的度量单位。</param>
        <param name="imageAttr">
          <see cref="T:System.Drawing.Imaging.ImageAttributes" />，它指定 <c>image</c> 对象的重新着色和伽玛信息。</param>
        <summary>在指定位置绘制指定的 <see cref="T:System.Drawing.Image" /> 的指定部分。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `destPoints`参数指定的平行四边形的三个点。 这三个<xref:System.Drawing.Point>结构表示的平行四边形的左上角、 右上方和左下角。 第四个点推断出的前三个以形成一个平行四边形。  
  
 `srcRect`参数指定一个矩形部分的`image`对象来绘制。 此部分进行缩放和剪切，以适合由指定的平行四边形`destPoints`参数。  
  
   
  
## Examples  
 下面的代码示例设计为使用 Windows 窗体，并且它需要<xref:System.Windows.Forms.PaintEventArgs> `e`，这是一个参数的<xref:System.Windows.Forms.Control.Paint>事件处理程序。 该代码执行下列操作：  
  
-   创建从 JPEG 文件的文件夹中的示例 sampimag.jpg 位于同一个图像。  
  
-   创建定义要在其中绘制图像的一个平行四边形的点。  
  
-   创建一个矩形来选择要绘制的图像的一部分。  
  
-   设置图形绘制像素为单位。  
  
-   将原始图像绘制到屏幕。  
  
-   创建要在其中绘制调整后的图像的附加平行四边形。  
  
-   创建并设置调整后的映像，以便具有比平常的伽玛值的属性。  
  
-   将调整后的图像绘制到屏幕。  
  
 对于原始、 未调整平行四边形中，该位置确定图像在屏幕上，并矩形和大小的大小和形状平行四边形的确定的缩放和剪切所绘制图像。  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples#37](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CPP/form1.cpp#37)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples#37](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CS/form1.cs#37)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples#37](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/VB/form1.vb#37)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="image" /> 为 <see langword="null" />。</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">图像、位图和图元文件</related>
      </Docs>
    </Member>
    <Member MemberName="DrawImage">
      <MemberSignature Language="C#" Value="public void DrawImage (System.Drawing.Image image, System.Drawing.PointF[] destPoints, System.Drawing.RectangleF srcRect, System.Drawing.GraphicsUnit srcUnit, System.Drawing.Imaging.ImageAttributes imageAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawImage(class System.Drawing.Image image, valuetype System.Drawing.PointF[] destPoints, valuetype System.Drawing.RectangleF srcRect, valuetype System.Drawing.GraphicsUnit srcUnit, class System.Drawing.Imaging.ImageAttributes imageAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawImage(System.Drawing.Image,System.Drawing.PointF[],System.Drawing.RectangleF,System.Drawing.GraphicsUnit,System.Drawing.Imaging.ImageAttributes)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawImage(System::Drawing::Image ^ image, cli::array &lt;System::Drawing::PointF&gt; ^ destPoints, System::Drawing::RectangleF srcRect, System::Drawing::GraphicsUnit srcUnit, System::Drawing::Imaging::ImageAttributes ^ imageAttr);" />
      <MemberSignature Language="F#" Value="member this.DrawImage : System.Drawing.Image * System.Drawing.PointF[] * System.Drawing.RectangleF * System.Drawing.GraphicsUnit * System.Drawing.Imaging.ImageAttributes -&gt; unit" Usage="graphics.DrawImage (image, destPoints, srcRect, srcUnit, imageAttr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="image" Type="System.Drawing.Image" />
        <Parameter Name="destPoints" Type="System.Drawing.PointF[]" />
        <Parameter Name="srcRect" Type="System.Drawing.RectangleF" />
        <Parameter Name="srcUnit" Type="System.Drawing.GraphicsUnit" />
        <Parameter Name="imageAttr" Type="System.Drawing.Imaging.ImageAttributes" />
      </Parameters>
      <Docs>
        <param name="image">要绘制的 <see cref="T:System.Drawing.Image" />。</param>
        <param name="destPoints">由三个 <see cref="T:System.Drawing.PointF" /> 结构组成的数组，这三个结构定义一个平行四边形。</param>
        <param name="srcRect">
          <see cref="T:System.Drawing.RectangleF" /> 结构，它指定 <c>image</c> 对象中要绘制的部分。</param>
        <param name="srcUnit">
          <see cref="T:System.Drawing.GraphicsUnit" /> 枚举的成员，它指定 <c>srcRect</c> 参数所用的度量单位。</param>
        <param name="imageAttr">
          <see cref="T:System.Drawing.Imaging.ImageAttributes" />，它指定 <c>image</c> 对象的重新着色和伽玛信息。</param>
        <summary>在指定位置并且按指定大小绘制指定的 <see cref="T:System.Drawing.Image" /> 的指定部分。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `destPoints`参数指定的平行四边形的三个点。 这三个<xref:System.Drawing.PointF>结构表示的平行四边形的左上角、 右上方和左下角。 第四个点推断出的前三个以形成一个平行四边形。  
  
 `srcRect`参数指定一个矩形部分的`image`对象来绘制。 此部分进行缩放和剪切，以适合由指定的平行四边形`destPoints`参数。  
  
   
  
## Examples  
 下面的代码示例设计为使用 Windows 窗体，并且它需要<xref:System.Windows.Forms.PaintEventArgs> `e`，这是一个参数的<xref:System.Windows.Forms.Control.Paint>事件处理程序。 该代码执行下列操作：  
  
-   创建从 JPEG 文件的文件夹中的示例 sampimag.jpg 位于同一个图像。  
  
-   创建定义要绘制图像在其中一个目标平行四边形的点。  
  
-   创建要从中提取图像的一部分的源矩形。  
  
-   设置源矩形的度量单位为像素。  
  
-   将原始图像绘制到屏幕。  
  
-   创建要在其中绘制调整后的图像的附加平行四边形。  
  
-   创建并设置调整后的映像，以便具有比平常的伽玛值的属性。  
  
-   将调整后的图像绘制到屏幕。  
  
 对于原始、 未调整目标平行四边形，位置确定在屏幕中，源矩形的大小和大小的图像而目标平行四边形形状确定的缩放和剪切以及所绘制的图像的大小矩形确定原始图像的哪个部分绘制到屏幕。  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples#43](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CPP/form1.cpp#43)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples#43](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CS/form1.cs#43)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples#43](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/VB/form1.vb#43)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="image" /> 为 <see langword="null" />。</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">图像、位图和图元文件</related>
      </Docs>
    </Member>
    <Member MemberName="DrawImage">
      <MemberSignature Language="C#" Value="public void DrawImage (System.Drawing.Image image, int x, int y, System.Drawing.Rectangle srcRect, System.Drawing.GraphicsUnit srcUnit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawImage(class System.Drawing.Image image, int32 x, int32 y, valuetype System.Drawing.Rectangle srcRect, valuetype System.Drawing.GraphicsUnit srcUnit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawImage(System.Drawing.Image,System.Int32,System.Int32,System.Drawing.Rectangle,System.Drawing.GraphicsUnit)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawImage(System::Drawing::Image ^ image, int x, int y, System::Drawing::Rectangle srcRect, System::Drawing::GraphicsUnit srcUnit);" />
      <MemberSignature Language="F#" Value="member this.DrawImage : System.Drawing.Image * int * int * System.Drawing.Rectangle * System.Drawing.GraphicsUnit -&gt; unit" Usage="graphics.DrawImage (image, x, y, srcRect, srcUnit)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="image" Type="System.Drawing.Image" />
        <Parameter Name="x" Type="System.Int32" />
        <Parameter Name="y" Type="System.Int32" />
        <Parameter Name="srcRect" Type="System.Drawing.Rectangle" />
        <Parameter Name="srcUnit" Type="System.Drawing.GraphicsUnit" />
      </Parameters>
      <Docs>
        <param name="image">要绘制的 <see cref="T:System.Drawing.Image" />。</param>
        <param name="x">所绘制图像的左上角的 x 坐标。</param>
        <param name="y">所绘制图像的左上角的 y 坐标。</param>
        <param name="srcRect">
          <see cref="T:System.Drawing.Rectangle" /> 结构，它指定 <c>image</c> 对象中要绘制的部分。</param>
        <param name="srcUnit">
          <see cref="T:System.Drawing.GraphicsUnit" /> 枚举的成员，它指定 <c>srcRect</c> 参数所用的度量单位。</param>
        <summary>在指定的位置绘制图像的一部分。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Drawing.Image>存储像素宽度值和水平分辨率 （每英寸点数） 的值。 物理宽度，以英寸为单位的单位是图像的像素宽度除以的水平分辨率。 例如，像素宽度为 360、 72 点 / 英寸的水平分辨率的图像具有物理宽度为 5 英寸。 说明同样适用于像素高度和物理的高度。  
  
 此方法绘制图像使用的物理大小，因此图像部分将具有其正确的大小，以英寸为单位，而不考虑显示设备的分辨率 （每英寸点数） 的一部分。 例如，假设绘制图像部分的像素宽度为 216 和 72 点 / 英寸的水平分辨率。 如果调用此方法以每英寸 96 点的分辨率的设备上绘制该图像部分，呈现的图像部分的像素宽度将是 (216/72) * 96 = 288 条。  
  
   
  
## Examples  
 下面的代码示例设计为使用 Windows 窗体，并且它需要<xref:System.Windows.Forms.PaintEventArgs> `e`，这是一个参数的<xref:System.Windows.Forms.Control.Paint>事件处理程序。 该代码执行下列操作：  
  
-   创建从 JPEG 文件的文件夹中的示例 sampimag.jpg 位于同一个图像。  
  
-   创建在其中绘制图像的左上角的坐标。  
  
-   创建要从中提取图像的一部分的源矩形。  
  
-   设置源矩形的度量单位为像素。  
  
-   将图像绘制到屏幕。  
  
 源矩形的大小确定不成比例的原始图像的哪个部分绘制到屏幕。  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples2#59](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CPP/form1.cpp#59)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples2#59](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CS/form1.cs#59)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples2#59](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/VB/form1.vb#59)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="image" /> 为 <see langword="null" />。</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">图像、位图和图元文件</related>
      </Docs>
    </Member>
    <Member MemberName="DrawImage">
      <MemberSignature Language="C#" Value="public void DrawImage (System.Drawing.Image image, int x, int y, int width, int height);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawImage(class System.Drawing.Image image, int32 x, int32 y, int32 width, int32 height) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawImage(System.Drawing.Image,System.Int32,System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawImage(System::Drawing::Image ^ image, int x, int y, int width, int height);" />
      <MemberSignature Language="F#" Value="member this.DrawImage : System.Drawing.Image * int * int * int * int -&gt; unit" Usage="graphics.DrawImage (image, x, y, width, height)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="image" Type="System.Drawing.Image" />
        <Parameter Name="x" Type="System.Int32" />
        <Parameter Name="y" Type="System.Int32" />
        <Parameter Name="width" Type="System.Int32" />
        <Parameter Name="height" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="image">要绘制的 <see cref="T:System.Drawing.Image" />。</param>
        <param name="x">所绘制图像的左上角的 x 坐标。</param>
        <param name="y">所绘制图像的左上角的 y 坐标。</param>
        <param name="width">所绘制图像的宽度。</param>
        <param name="height">所绘制图像的高度。</param>
        <summary>在指定位置并且按指定大小绘制指定的 <see cref="T:System.Drawing.Image" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 定义的矩形`x`， `y`， `width`，和`height`参数确定的位置和所绘制图像的大小。  
  
   
  
## Examples  
 下面的代码示例设计为使用 Windows 窗体，并且它需要<xref:System.Windows.Forms.PaintEventArgs> `e`，这是一个参数的<xref:System.Windows.Forms.Control.Paint>事件处理程序。 该代码执行下列操作：  
  
-   创建从 JPEG 文件的文件夹中的示例 sampimag.jpg 位于同一个图像。  
  
-   创建位置和在其中绘制图像的矩形的大小。  
  
-   将图像绘制到屏幕。  
  
 矩形的位置确定图像在屏幕上，而原始图像的大小和矩形的大小确定所绘制图像的缩放。  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples2#60](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CPP/form1.cpp#60)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples2#60](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CS/form1.cs#60)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples2#60](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/VB/form1.vb#60)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="image" /> 为 <see langword="null" />。</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">图像、位图和图元文件</related>
      </Docs>
    </Member>
    <Member MemberName="DrawImage">
      <MemberSignature Language="C#" Value="public void DrawImage (System.Drawing.Image image, float x, float y, System.Drawing.RectangleF srcRect, System.Drawing.GraphicsUnit srcUnit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawImage(class System.Drawing.Image image, float32 x, float32 y, valuetype System.Drawing.RectangleF srcRect, valuetype System.Drawing.GraphicsUnit srcUnit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawImage(System.Drawing.Image,System.Single,System.Single,System.Drawing.RectangleF,System.Drawing.GraphicsUnit)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawImage(System::Drawing::Image ^ image, float x, float y, System::Drawing::RectangleF srcRect, System::Drawing::GraphicsUnit srcUnit);" />
      <MemberSignature Language="F#" Value="member this.DrawImage : System.Drawing.Image * single * single * System.Drawing.RectangleF * System.Drawing.GraphicsUnit -&gt; unit" Usage="graphics.DrawImage (image, x, y, srcRect, srcUnit)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="image" Type="System.Drawing.Image" />
        <Parameter Name="x" Type="System.Single" />
        <Parameter Name="y" Type="System.Single" />
        <Parameter Name="srcRect" Type="System.Drawing.RectangleF" />
        <Parameter Name="srcUnit" Type="System.Drawing.GraphicsUnit" />
      </Parameters>
      <Docs>
        <param name="image">要绘制的 <see cref="T:System.Drawing.Image" />。</param>
        <param name="x">所绘制图像的左上角的 x 坐标。</param>
        <param name="y">所绘制图像的左上角的 y 坐标。</param>
        <param name="srcRect">
          <see cref="T:System.Drawing.RectangleF" /> 结构，它指定 <see cref="T:System.Drawing.Image" /> 中要绘制的部分。</param>
        <param name="srcUnit">
          <see cref="T:System.Drawing.GraphicsUnit" /> 枚举的成员，它指定 <c>srcRect</c> 参数所用的度量单位。</param>
        <summary>在指定的位置绘制图像的一部分。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Drawing.Image>存储像素宽度值和水平分辨率 （每英寸点数） 的值。 物理宽度，以英寸为单位的单位是图像的像素宽度除以的水平分辨率。 例如，像素宽度为 360、 72 点 / 英寸的水平分辨率的图像具有物理宽度为 5 英寸。 说明同样适用于像素高度和物理的高度。  
  
 此方法绘制图像使用的物理大小，因此图像部分将具有其正确的大小，以英寸为单位，而不考虑显示设备的分辨率 （每英寸点数） 的一部分。 例如，假设绘制图像部分的像素宽度为 216 和 72 点 / 英寸的水平分辨率。 如果调用此方法以每英寸 96 点的分辨率的设备上绘制该图像部分，呈现的图像部分的像素宽度将是 (216/72) * 96 = 288 条。  
  
   
  
## Examples  
 下面的代码示例设计为使用 Windows 窗体，并且它需要<xref:System.Windows.Forms.PaintEventArgs> `e`，这是一个参数的<xref:System.Windows.Forms.Control.Paint>事件处理程序。 该代码执行下列操作：  
  
-   创建从 JPEG 文件的文件夹中的示例 sampimag.jpg 位于同一个图像。  
  
-   创建在其中绘制图像的左上角的坐标。  
  
-   创建要从中提取图像的一部分的源矩形。  
  
-   设置源矩形的度量单位为像素。  
  
-   将图像绘制到屏幕。  
  
 源矩形的大小确定不成比例的原始图像的哪个部分绘制到屏幕。  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples2#62](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CPP/form1.cpp#62)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples2#62](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CS/form1.cs#62)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples2#62](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/VB/form1.vb#62)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="image" /> 为 <see langword="null" />。</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">图像、位图和图元文件</related>
      </Docs>
    </Member>
    <Member MemberName="DrawImage">
      <MemberSignature Language="C#" Value="public void DrawImage (System.Drawing.Image image, float x, float y, float width, float height);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawImage(class System.Drawing.Image image, float32 x, float32 y, float32 width, float32 height) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawImage(System.Drawing.Image,System.Single,System.Single,System.Single,System.Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawImage(System::Drawing::Image ^ image, float x, float y, float width, float height);" />
      <MemberSignature Language="F#" Value="member this.DrawImage : System.Drawing.Image * single * single * single * single -&gt; unit" Usage="graphics.DrawImage (image, x, y, width, height)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="image" Type="System.Drawing.Image" />
        <Parameter Name="x" Type="System.Single" />
        <Parameter Name="y" Type="System.Single" />
        <Parameter Name="width" Type="System.Single" />
        <Parameter Name="height" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="image">要绘制的 <see cref="T:System.Drawing.Image" />。</param>
        <param name="x">所绘制图像的左上角的 x 坐标。</param>
        <param name="y">所绘制图像的左上角的 y 坐标。</param>
        <param name="width">所绘制图像的宽度。</param>
        <param name="height">所绘制图像的高度。</param>
        <summary>在指定位置并且按指定大小绘制指定的 <see cref="T:System.Drawing.Image" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 定义的矩形`x`， `y`， `width`，和`height`参数确定的位置和所绘制图像的大小。  
  
   
  
## Examples  
 下面的代码示例设计为使用 Windows 窗体，并且它需要<xref:System.Windows.Forms.PaintEventArgs> `e`，这是一个参数的<xref:System.Windows.Forms.Control.Paint>事件处理程序。 该代码执行下列操作：  
  
-   创建从 JPEG 文件的文件夹中的示例 sampimag.jpg 位于同一个图像。  
  
-   创建位置和在其中绘制图像的矩形的大小。  
  
-   将图像绘制到屏幕。  
  
 矩形的位置确定图像在屏幕上，而原始图像的大小和矩形的大小确定所绘制图像的缩放。  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples2#63](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CPP/form1.cpp#63)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples2#63](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CS/form1.cs#63)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples2#63](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/VB/form1.vb#63)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="image" /> 为 <see langword="null" />。</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">图像、位图和图元文件</related>
      </Docs>
    </Member>
    <Member MemberName="DrawImage">
      <MemberSignature Language="C#" Value="public void DrawImage (System.Drawing.Image image, System.Drawing.Point[] destPoints, System.Drawing.Rectangle srcRect, System.Drawing.GraphicsUnit srcUnit, System.Drawing.Imaging.ImageAttributes imageAttr, System.Drawing.Graphics.DrawImageAbort callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawImage(class System.Drawing.Image image, valuetype System.Drawing.Point[] destPoints, valuetype System.Drawing.Rectangle srcRect, valuetype System.Drawing.GraphicsUnit srcUnit, class System.Drawing.Imaging.ImageAttributes imageAttr, class System.Drawing.Graphics/DrawImageAbort callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawImage(System.Drawing.Image,System.Drawing.Point[],System.Drawing.Rectangle,System.Drawing.GraphicsUnit,System.Drawing.Imaging.ImageAttributes,System.Drawing.Graphics.DrawImageAbort)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawImage(System::Drawing::Image ^ image, cli::array &lt;System::Drawing::Point&gt; ^ destPoints, System::Drawing::Rectangle srcRect, System::Drawing::GraphicsUnit srcUnit, System::Drawing::Imaging::ImageAttributes ^ imageAttr, System::Drawing::Graphics::DrawImageAbort ^ callback);" />
      <MemberSignature Language="F#" Value="member this.DrawImage : System.Drawing.Image * System.Drawing.Point[] * System.Drawing.Rectangle * System.Drawing.GraphicsUnit * System.Drawing.Imaging.ImageAttributes * System.Drawing.Graphics.DrawImageAbort -&gt; unit" Usage="graphics.DrawImage (image, destPoints, srcRect, srcUnit, imageAttr, callback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="image" Type="System.Drawing.Image" />
        <Parameter Name="destPoints" Type="System.Drawing.Point[]" />
        <Parameter Name="srcRect" Type="System.Drawing.Rectangle" />
        <Parameter Name="srcUnit" Type="System.Drawing.GraphicsUnit" />
        <Parameter Name="imageAttr" Type="System.Drawing.Imaging.ImageAttributes" />
        <Parameter Name="callback" Type="System.Drawing.Graphics+DrawImageAbort" />
      </Parameters>
      <Docs>
        <param name="image">要绘制的 <see cref="T:System.Drawing.Image" />。</param>
        <param name="destPoints">由三个 <see cref="T:System.Drawing.PointF" /> 结构组成的数组，这三个结构定义一个平行四边形。</param>
        <param name="srcRect">
          <see cref="T:System.Drawing.Rectangle" /> 结构，它指定 <c>image</c> 对象中要绘制的部分。</param>
        <param name="srcUnit">
          <see cref="T:System.Drawing.GraphicsUnit" /> 枚举的成员，它指定 <c>srcRect</c> 参数所用的度量单位。</param>
        <param name="imageAttr">
          <see cref="T:System.Drawing.Imaging.ImageAttributes" />，它指定 <c>image</c> 对象的重新着色和伽玛信息。</param>
        <param name="callback">
          <see cref="T:System.Drawing.Graphics.DrawImageAbort" /> 委托，它指定在绘制图像期间要调用的方法。 此方法被频繁调用以检查是否根据应用程序确定的条件停止 <see cref="M:System.Drawing.Graphics.DrawImage(System.Drawing.Image,System.Drawing.Point[],System.Drawing.Rectangle,System.Drawing.GraphicsUnit,System.Drawing.Imaging.ImageAttributes,System.Drawing.Graphics.DrawImageAbort)" /> 方法的执行。</param>
        <summary>在指定位置并且按指定大小绘制指定的 <see cref="T:System.Drawing.Image" /> 的指定部分。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `destPoints`参数指定的平行四边形的三个点。 这三个<xref:System.Drawing.PointF>结构表示的平行四边形的左上角、 右上方和左下角。 第四个点推断出的前三个以形成一个平行四边形。  
  
 `srcRect`参数指定一个矩形部分的`image`对象来绘制。 此部分进行缩放和剪切，以适合由指定的平行四边形`destPoints`参数。  
  
 使用此重载`callback`参数提供了根据条件由应用程序启动后停止的图像的绘制的方法。 例如，应用程序可能开始绘制一个大图像，用户可能会滚动屏幕上，用例应用程序可以在其中停止绘制图像。  
  
   
  
## Examples  
 下面的代码示例设计为使用 Windows 窗体，并且它需要<xref:System.Windows.Forms.PaintEventArgs> `e`，这是一个参数的<xref:System.Windows.Forms.Control.Paint>事件处理程序。 代码首先定义回调方法，以<xref:System.Drawing.Graphics.DrawImageAbort>委托; 定义是过于简单，只是测试以了解是否<xref:System.Drawing.Graphics.DrawImage%2A>方法调用它为 null`callBackData`参数。 该示例的主要部分执行以下操作：  
  
-   创建的实例<xref:System.Drawing.Graphics.DrawImageAbort>回调方法：  
  
-   创建从 JPEG 文件的文件夹中的示例 sampimag.jpg 位于同一个图像。  
  
-   创建定义要在其中绘制图像的一个平行四边形的点。  
  
-   创建一个矩形来选择要绘制的图像的一部分。  
  
-   设置图形绘制像素为单位。  
  
-   将原始图像绘制到屏幕。  
  
-   创建要在其中绘制调整后的图像的附加平行四边形。  
  
-   创建并设置调整后的映像，以便具有比平常的伽玛值的属性。  
  
-   将调整后的图像绘制到屏幕。  
  
 对于原始、 未调整平行四边形中，该位置确定图像在屏幕上，并矩形和大小的大小和形状平行四边形的确定的缩放和剪切所绘制图像。  
  
 因为此示例使用未通过的重载`callBackData`参数，<xref:System.Drawing.Graphics.DrawImageAbort>回调返回`true`，这将导致<xref:System.Drawing.Graphics.DrawImage%2A>结束，并在示例中包含的异常处理代码的方法将输出异常文本而不是绘制图像。  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples#38](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CPP/form1.cpp#38)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples#38](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CS/form1.cs#38)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples#38](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/VB/form1.vb#38)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="image" /> 为 <see langword="null" />。</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">图像、位图和图元文件</related>
      </Docs>
    </Member>
    <Member MemberName="DrawImage">
      <MemberSignature Language="C#" Value="public void DrawImage (System.Drawing.Image image, System.Drawing.PointF[] destPoints, System.Drawing.RectangleF srcRect, System.Drawing.GraphicsUnit srcUnit, System.Drawing.Imaging.ImageAttributes imageAttr, System.Drawing.Graphics.DrawImageAbort callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawImage(class System.Drawing.Image image, valuetype System.Drawing.PointF[] destPoints, valuetype System.Drawing.RectangleF srcRect, valuetype System.Drawing.GraphicsUnit srcUnit, class System.Drawing.Imaging.ImageAttributes imageAttr, class System.Drawing.Graphics/DrawImageAbort callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawImage(System.Drawing.Image,System.Drawing.PointF[],System.Drawing.RectangleF,System.Drawing.GraphicsUnit,System.Drawing.Imaging.ImageAttributes,System.Drawing.Graphics.DrawImageAbort)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawImage(System::Drawing::Image ^ image, cli::array &lt;System::Drawing::PointF&gt; ^ destPoints, System::Drawing::RectangleF srcRect, System::Drawing::GraphicsUnit srcUnit, System::Drawing::Imaging::ImageAttributes ^ imageAttr, System::Drawing::Graphics::DrawImageAbort ^ callback);" />
      <MemberSignature Language="F#" Value="member this.DrawImage : System.Drawing.Image * System.Drawing.PointF[] * System.Drawing.RectangleF * System.Drawing.GraphicsUnit * System.Drawing.Imaging.ImageAttributes * System.Drawing.Graphics.DrawImageAbort -&gt; unit" Usage="graphics.DrawImage (image, destPoints, srcRect, srcUnit, imageAttr, callback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="image" Type="System.Drawing.Image" />
        <Parameter Name="destPoints" Type="System.Drawing.PointF[]" />
        <Parameter Name="srcRect" Type="System.Drawing.RectangleF" />
        <Parameter Name="srcUnit" Type="System.Drawing.GraphicsUnit" />
        <Parameter Name="imageAttr" Type="System.Drawing.Imaging.ImageAttributes" />
        <Parameter Name="callback" Type="System.Drawing.Graphics+DrawImageAbort" />
      </Parameters>
      <Docs>
        <param name="image">要绘制的 <see cref="T:System.Drawing.Image" />。</param>
        <param name="destPoints">由三个 <see cref="T:System.Drawing.PointF" /> 结构组成的数组，这三个结构定义一个平行四边形。</param>
        <param name="srcRect">
          <see cref="T:System.Drawing.RectangleF" /> 结构，它指定 <c>image</c> 对象中要绘制的部分。</param>
        <param name="srcUnit">
          <see cref="T:System.Drawing.GraphicsUnit" /> 枚举的成员，它指定 <c>srcRect</c> 参数所用的度量单位。</param>
        <param name="imageAttr">
          <see cref="T:System.Drawing.Imaging.ImageAttributes" />，它指定 <c>image</c> 对象的重新着色和伽玛信息。</param>
        <param name="callback">
          <see cref="T:System.Drawing.Graphics.DrawImageAbort" /> 委托，它指定在绘制图像期间要调用的方法。 此方法被频繁调用以检查是否根据应用程序确定的条件停止 <see cref="M:System.Drawing.Graphics.DrawImage(System.Drawing.Image,System.Drawing.PointF[],System.Drawing.RectangleF,System.Drawing.GraphicsUnit,System.Drawing.Imaging.ImageAttributes,System.Drawing.Graphics.DrawImageAbort)" /> 方法的执行。</param>
        <summary>在指定位置并且按指定大小绘制指定的 <see cref="T:System.Drawing.Image" /> 的指定部分。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `destPoints`参数指定的平行四边形的三个点。 这三个<xref:System.Drawing.PointF>结构表示的平行四边形的左上角、 右上方和左下角。 第四个点推断出的前三个以形成一个平行四边形。  
  
 `srcRect`参数指定一个矩形部分的`image`对象来绘制。 此部分进行缩放和剪切，以适合由指定的平行四边形`destPoints`参数。  
  
 使用此重载`callback`参数提供了根据条件由应用程序启动后停止的图像的绘制的方法。 例如，应用程序可能开始绘制一个大图像，用户可能会滚动屏幕上，用例应用程序可以在其中停止绘制图像。  
  
   
  
## Examples  
 下面的代码示例设计为使用 Windows 窗体，并且它需要<xref:System.Windows.Forms.PaintEventArgs> `e`，这是一个参数的<xref:System.Windows.Forms.Control.Paint>事件处理程序。 代码首先定义回调方法，以<xref:System.Drawing.Graphics.DrawImageAbort>委托; 定义是过于简单，只是测试以了解是否<xref:System.Drawing.Graphics.DrawImage%2A>方法调用它为 null`callBackData`参数。 该示例的主要部分执行以下操作：  
  
-   创建的实例<xref:System.Drawing.Graphics.DrawImageAbort>回调方法。  
  
-   创建从 JPEG 文件的文件夹中的示例 sampimag.jpg 位于同一个图像。  
  
-   创建定义要在其中绘制图像的一个平行四边形的点。  
  
-   创建一个矩形来选择要绘制的图像的一部分。  
  
-   设置图形绘制像素为单位。  
  
-   将原始图像绘制到屏幕。  
  
-   创建要在其中绘制调整后的图像的附加平行四边形。  
  
-   创建并设置调整后的映像，以便具有比平常的伽玛值的属性。  
  
-   将调整后的图像绘制到屏幕。  
  
 对于原始、 未调整平行四边形中，该位置确定图像在屏幕上，并矩形和大小的大小和形状平行四边形的确定的缩放和剪切所绘制图像。  
  
 因为此示例使用未通过的重载`callBackData`参数，<xref:System.Drawing.Graphics.DrawImageAbort>回调返回`true`，这将导致<xref:System.Drawing.Graphics.DrawImage%2A>结束，并在示例中包含的异常处理代码的方法将输出异常文本而不是绘制图像。  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples#44](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CPP/form1.cpp#44)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples#44](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CS/form1.cs#44)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples#44](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/VB/form1.vb#44)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="image" /> 为 <see langword="null" />。</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">图像、位图和图元文件</related>
      </Docs>
    </Member>
    <Member MemberName="DrawImage">
      <MemberSignature Language="C#" Value="public void DrawImage (System.Drawing.Image image, System.Drawing.Point[] destPoints, System.Drawing.Rectangle srcRect, System.Drawing.GraphicsUnit srcUnit, System.Drawing.Imaging.ImageAttributes imageAttr, System.Drawing.Graphics.DrawImageAbort callback, int callbackData);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawImage(class System.Drawing.Image image, valuetype System.Drawing.Point[] destPoints, valuetype System.Drawing.Rectangle srcRect, valuetype System.Drawing.GraphicsUnit srcUnit, class System.Drawing.Imaging.ImageAttributes imageAttr, class System.Drawing.Graphics/DrawImageAbort callback, int32 callbackData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawImage(System.Drawing.Image,System.Drawing.Point[],System.Drawing.Rectangle,System.Drawing.GraphicsUnit,System.Drawing.Imaging.ImageAttributes,System.Drawing.Graphics.DrawImageAbort,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawImage(System::Drawing::Image ^ image, cli::array &lt;System::Drawing::Point&gt; ^ destPoints, System::Drawing::Rectangle srcRect, System::Drawing::GraphicsUnit srcUnit, System::Drawing::Imaging::ImageAttributes ^ imageAttr, System::Drawing::Graphics::DrawImageAbort ^ callback, int callbackData);" />
      <MemberSignature Language="F#" Value="member this.DrawImage : System.Drawing.Image * System.Drawing.Point[] * System.Drawing.Rectangle * System.Drawing.GraphicsUnit * System.Drawing.Imaging.ImageAttributes * System.Drawing.Graphics.DrawImageAbort * int -&gt; unit" Usage="graphics.DrawImage (image, destPoints, srcRect, srcUnit, imageAttr, callback, callbackData)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="image" Type="System.Drawing.Image" />
        <Parameter Name="destPoints" Type="System.Drawing.Point[]" />
        <Parameter Name="srcRect" Type="System.Drawing.Rectangle" />
        <Parameter Name="srcUnit" Type="System.Drawing.GraphicsUnit" />
        <Parameter Name="imageAttr" Type="System.Drawing.Imaging.ImageAttributes" />
        <Parameter Name="callback" Type="System.Drawing.Graphics+DrawImageAbort" />
        <Parameter Name="callbackData" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="image">要绘制的 <see cref="T:System.Drawing.Image" />。</param>
        <param name="destPoints">由三个 <see cref="T:System.Drawing.PointF" /> 结构组成的数组，这三个结构定义一个平行四边形。</param>
        <param name="srcRect">
          <see cref="T:System.Drawing.Rectangle" /> 结构，它指定 <c>image</c> 对象中要绘制的部分。</param>
        <param name="srcUnit">
          <see cref="T:System.Drawing.GraphicsUnit" /> 枚举的成员，它指定 <c>srcRect</c> 参数所用的度量单位。</param>
        <param name="imageAttr">
          <see cref="T:System.Drawing.Imaging.ImageAttributes" />，它指定 <c>image</c> 对象的重新着色和伽玛信息。</param>
        <param name="callback">
          <see cref="T:System.Drawing.Graphics.DrawImageAbort" /> 委托，它指定在绘制图像期间要调用的方法。 此方法被频繁调用以检查是否根据应用程序确定的条件停止 <see cref="M:System.Drawing.Graphics.DrawImage(System.Drawing.Image,System.Drawing.Point[],System.Drawing.Rectangle,System.Drawing.GraphicsUnit,System.Drawing.Imaging.ImageAttributes,System.Drawing.Graphics.DrawImageAbort,System.Int32)" /> 方法的执行。</param>
        <param name="callbackData">一个值，它为 <see cref="T:System.Drawing.Graphics.DrawImageAbort" /> 委托指定在检查是否停止执行 <see cref="M:System.Drawing.Graphics.DrawImage(System.Drawing.Image,System.Drawing.Point[],System.Drawing.Rectangle,System.Drawing.GraphicsUnit,System.Drawing.Imaging.ImageAttributes,System.Drawing.Graphics.DrawImageAbort,System.Int32)" /> 方法时要使用的附加数据。</param>
        <summary>在指定位置并且按指定大小绘制指定的 <see cref="T:System.Drawing.Image" /> 的指定部分。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `destPoints`参数指定的平行四边形的三个点。 这三个<xref:System.Drawing.PointF>结构表示的平行四边形的左上角、 右上方和左下角。 第四个点推断出的前三个以形成一个平行四边形。  
  
 `srcRect`参数指定一个矩形部分的`image`对象来绘制。 此部分进行缩放和剪切，以适合由指定的平行四边形`destPoints`参数。  
  
 使用此重载`callback`和`callbackData`参数提供了根据条件和数据由应用程序启动后停止的图像的绘制的方法。 例如，应用程序可能开始绘制一个大图像，用户可能会滚动屏幕上，用例应用程序可以在其中停止绘制图像。  
  
   
  
## Examples  
 下面的代码示例设计为使用 Windows 窗体，并且它需要<xref:System.Windows.Forms.PaintEventArgs> `e`，这是一个参数的<xref:System.Windows.Forms.Control.Paint>事件处理程序。 代码首先定义回调方法，以<xref:System.Drawing.Graphics.DrawImageAbort>委托; 定义是过于简单，只是测试以了解是否<xref:System.Drawing.Graphics.DrawImage%2A>方法调用它为 null`callBackData`参数。 该示例的主要部分执行以下操作：  
  
-   创建的实例<xref:System.Drawing.Graphics.DrawImageAbort>回调方法。  
  
-   创建从 JPEG 文件的文件夹中的示例 sampimag.jpg 位于同一个图像。  
  
-   创建定义要在其中绘制图像的一个平行四边形的点。  
  
-   创建一个矩形来选择要绘制的图像的一部分。  
  
-   设置图形绘制像素为单位。  
  
-   将原始图像绘制到屏幕。  
  
-   创建要在其中绘制调整后的图像的附加平行四边形。  
  
-   创建并设置调整后的映像，以便具有比平常的伽玛值的属性。  
  
-   将调整后的图像绘制到屏幕。  
  
 对于原始、 未调整平行四边形中，该位置确定图像在屏幕上，并矩形和大小的大小和形状平行四边形的确定的缩放和剪切所绘制图像。  
  
 因为此示例使用传递的重载`callBackData`参数，<xref:System.Drawing.Graphics.DrawImageAbort>回调返回`false`，这将导致<xref:System.Drawing.Graphics.DrawImage%2A>方法，若要继续，以及的示例将调整后的图像绘制到屏幕。  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples#39](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CPP/form1.cpp#39)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples#39](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CS/form1.cs#39)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples#39](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/VB/form1.vb#39)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">图像、位图和图元文件</related>
      </Docs>
    </Member>
    <Member MemberName="DrawImage">
      <MemberSignature Language="C#" Value="public void DrawImage (System.Drawing.Image image, System.Drawing.PointF[] destPoints, System.Drawing.RectangleF srcRect, System.Drawing.GraphicsUnit srcUnit, System.Drawing.Imaging.ImageAttributes imageAttr, System.Drawing.Graphics.DrawImageAbort callback, int callbackData);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawImage(class System.Drawing.Image image, valuetype System.Drawing.PointF[] destPoints, valuetype System.Drawing.RectangleF srcRect, valuetype System.Drawing.GraphicsUnit srcUnit, class System.Drawing.Imaging.ImageAttributes imageAttr, class System.Drawing.Graphics/DrawImageAbort callback, int32 callbackData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawImage(System.Drawing.Image,System.Drawing.PointF[],System.Drawing.RectangleF,System.Drawing.GraphicsUnit,System.Drawing.Imaging.ImageAttributes,System.Drawing.Graphics.DrawImageAbort,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawImage(System::Drawing::Image ^ image, cli::array &lt;System::Drawing::PointF&gt; ^ destPoints, System::Drawing::RectangleF srcRect, System::Drawing::GraphicsUnit srcUnit, System::Drawing::Imaging::ImageAttributes ^ imageAttr, System::Drawing::Graphics::DrawImageAbort ^ callback, int callbackData);" />
      <MemberSignature Language="F#" Value="member this.DrawImage : System.Drawing.Image * System.Drawing.PointF[] * System.Drawing.RectangleF * System.Drawing.GraphicsUnit * System.Drawing.Imaging.ImageAttributes * System.Drawing.Graphics.DrawImageAbort * int -&gt; unit" Usage="graphics.DrawImage (image, destPoints, srcRect, srcUnit, imageAttr, callback, callbackData)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="image" Type="System.Drawing.Image" />
        <Parameter Name="destPoints" Type="System.Drawing.PointF[]" />
        <Parameter Name="srcRect" Type="System.Drawing.RectangleF" />
        <Parameter Name="srcUnit" Type="System.Drawing.GraphicsUnit" />
        <Parameter Name="imageAttr" Type="System.Drawing.Imaging.ImageAttributes" />
        <Parameter Name="callback" Type="System.Drawing.Graphics+DrawImageAbort" />
        <Parameter Name="callbackData" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="image">要绘制的 <see cref="T:System.Drawing.Image" />。</param>
        <param name="destPoints">由三个 <see cref="T:System.Drawing.PointF" /> 结构组成的数组，这三个结构定义一个平行四边形。</param>
        <param name="srcRect">
          <see cref="T:System.Drawing.RectangleF" /> 结构，它指定 <c>image</c> 对象中要绘制的部分。</param>
        <param name="srcUnit">
          <see cref="T:System.Drawing.GraphicsUnit" /> 枚举的成员，它指定 <c>srcRect</c> 参数所用的度量单位。</param>
        <param name="imageAttr">
          <see cref="T:System.Drawing.Imaging.ImageAttributes" />，它指定 <c>image</c> 对象的重新着色和伽玛信息。</param>
        <param name="callback">
          <see cref="T:System.Drawing.Graphics.DrawImageAbort" /> 委托，它指定在绘制图像期间要调用的方法。 此方法被频繁调用以检查是否根据应用程序确定的条件停止 <see cref="M:System.Drawing.Graphics.DrawImage(System.Drawing.Image,System.Drawing.PointF[],System.Drawing.RectangleF,System.Drawing.GraphicsUnit,System.Drawing.Imaging.ImageAttributes,System.Drawing.Graphics.DrawImageAbort,System.Int32)" /> 方法的执行。</param>
        <param name="callbackData">一个值，它为 <see cref="T:System.Drawing.Graphics.DrawImageAbort" /> 委托指定在检查是否停止执行 <see cref="M:System.Drawing.Graphics.DrawImage(System.Drawing.Image,System.Drawing.PointF[],System.Drawing.RectangleF,System.Drawing.GraphicsUnit,System.Drawing.Imaging.ImageAttributes,System.Drawing.Graphics.DrawImageAbort,System.Int32)" /> 方法时要使用的附加数据。</param>
        <summary>在指定位置并且按指定大小绘制指定的 <see cref="T:System.Drawing.Image" /> 的指定部分。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `destPoints`参数指定的平行四边形的三个点。 这三个<xref:System.Drawing.PointF>结构表示的平行四边形的左上角、 右上方和左下角。 第四个点推断出的前三个以形成一个平行四边形。  
  
 `srcRect`参数指定一个矩形部分的`image`对象来绘制。 此部分进行缩放和剪切，以适合由指定的平行四边形`destPoints`参数。  
  
 使用此重载`callback`和`callbackData`参数提供了根据条件和数据由应用程序启动后停止的图像的绘制的方法。 例如，应用程序可能开始绘制一个大图像，用户可能会滚动屏幕上，用例应用程序可以在其中停止绘制图像。  
  
   
  
## Examples  
 下面的代码示例设计为使用 Windows 窗体，并且它需要<xref:System.Windows.Forms.PaintEventArgs> `e`，这是一个参数的`Pa`<xref:System.Windows.Forms.Control.Paint>事件处理程序。 代码首先定义回调方法，以<xref:System.Drawing.Graphics.DrawImageAbort>委托; 定义是过于简单，只是测试以了解是否<xref:System.Drawing.Graphics.DrawImage%2A>方法调用它为 null`callBackData`参数。 该示例的主要部分执行以下操作：  
  
-   创建的实例<xref:System.Drawing.Graphics.DrawImageAbort>回调方法。  
  
-   创建从 JPEG 文件的文件夹中的示例 sampimag.jpg 位于同一个图像。  
  
-   创建定义要在其中绘制图像的一个平行四边形的点。  
  
-   创建一个矩形来选择要绘制的图像的一部分。  
  
-   设置图形绘制像素为单位。  
  
-   将原始图像绘制到屏幕。  
  
-   创建要在其中绘制调整后的图像的附加平行四边形。  
  
-   创建并设置调整后的映像，以便具有比平常的伽玛值的属性。  
  
-   将调整后的图像绘制到屏幕。  
  
 对于原始、 未调整平行四边形中，该位置确定图像在屏幕上，并矩形和大小的大小和形状平行四边形的确定的缩放和剪切所绘制图像。  
  
 因为此示例使用传递的重载`callBackData`参数，<xref:System.Drawing.Graphics.DrawImageAbort>回调返回`false`，这将导致<xref:System.Drawing.Graphics.DrawImage%2A>方法，若要继续，以及的示例将调整后的图像绘制到屏幕。  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples#45](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CPP/form1.cpp#45)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples#45](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CS/form1.cs#45)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples#45](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/VB/form1.vb#45)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="image" /> 为 <see langword="null" />。</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">图像、位图和图元文件</related>
      </Docs>
    </Member>
    <Member MemberName="DrawImage">
      <MemberSignature Language="C#" Value="public void DrawImage (System.Drawing.Image image, System.Drawing.Rectangle destRect, int srcX, int srcY, int srcWidth, int srcHeight, System.Drawing.GraphicsUnit srcUnit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawImage(class System.Drawing.Image image, valuetype System.Drawing.Rectangle destRect, int32 srcX, int32 srcY, int32 srcWidth, int32 srcHeight, valuetype System.Drawing.GraphicsUnit srcUnit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawImage(System.Drawing.Image,System.Drawing.Rectangle,System.Int32,System.Int32,System.Int32,System.Int32,System.Drawing.GraphicsUnit)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawImage(System::Drawing::Image ^ image, System::Drawing::Rectangle destRect, int srcX, int srcY, int srcWidth, int srcHeight, System::Drawing::GraphicsUnit srcUnit);" />
      <MemberSignature Language="F#" Value="member this.DrawImage : System.Drawing.Image * System.Drawing.Rectangle * int * int * int * int * System.Drawing.GraphicsUnit -&gt; unit" Usage="graphics.DrawImage (image, destRect, srcX, srcY, srcWidth, srcHeight, srcUnit)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="image" Type="System.Drawing.Image" />
        <Parameter Name="destRect" Type="System.Drawing.Rectangle" />
        <Parameter Name="srcX" Type="System.Int32" />
        <Parameter Name="srcY" Type="System.Int32" />
        <Parameter Name="srcWidth" Type="System.Int32" />
        <Parameter Name="srcHeight" Type="System.Int32" />
        <Parameter Name="srcUnit" Type="System.Drawing.GraphicsUnit" />
      </Parameters>
      <Docs>
        <param name="image">要绘制的 <see cref="T:System.Drawing.Image" />。</param>
        <param name="destRect">
          <see cref="T:System.Drawing.Rectangle" /> 结构，它指定所绘制图像的位置和大小。 将图像进行缩放以适合该矩形。</param>
        <param name="srcX">要绘制的源图像部分的左上角的 x 坐标。</param>
        <param name="srcY">要绘制的源图像部分的左上角的 y 坐标。</param>
        <param name="srcWidth">要绘制的源图像部分的宽度。</param>
        <param name="srcHeight">要绘制的源图像部分的高度。</param>
        <param name="srcUnit">
          <see cref="T:System.Drawing.GraphicsUnit" /> 枚举的成员，它指定用于确定源矩形的度量单位。</param>
        <summary>在指定位置并且按指定大小绘制指定的 <see cref="T:System.Drawing.Image" /> 的指定部分。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `srcX`， `srcY`， `srcWidth`，和`srcHeight`参数指定的一个矩形部分`image`对象来绘制。 该矩形是相对于源映像的左上角。 此部分缩放以适合指定的矩形`destRect`参数。  
  
   
  
## Examples  
 下面的代码示例设计为使用 Windows 窗体，并且它需要<xref:System.Windows.Forms.PaintEventArgs> `e`，这是一个参数的<xref:System.Windows.Forms.Control.Paint>事件处理程序。 该代码执行下列操作：  
  
-   创建从 JPEG 文件的文件夹中的示例 sampimag.jpg 位于同一个图像。  
  
-   创建在其中绘制图像的目标矩形。  
  
-   创建要从中提取图像的一部分的源矩形的坐标。  
  
-   设置源矩形的度量单位为像素。  
  
-   将图像绘制到屏幕。  
  
 目标矩形的位置确定图像在屏幕上，以及源和目标矩形的大小确定所绘制图像的缩放和源矩形的大小确定原始图像的哪个部分绘制到屏幕。  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples#48](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CPP/form1.cpp#48)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples#48](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CS/form1.cs#48)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples#48](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/VB/form1.vb#48)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="image" /> 为 <see langword="null" />。</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">图像、位图和图元文件</related>
      </Docs>
    </Member>
    <Member MemberName="DrawImage">
      <MemberSignature Language="C#" Value="public void DrawImage (System.Drawing.Image image, System.Drawing.Rectangle destRect, float srcX, float srcY, float srcWidth, float srcHeight, System.Drawing.GraphicsUnit srcUnit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawImage(class System.Drawing.Image image, valuetype System.Drawing.Rectangle destRect, float32 srcX, float32 srcY, float32 srcWidth, float32 srcHeight, valuetype System.Drawing.GraphicsUnit srcUnit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawImage(System.Drawing.Image,System.Drawing.Rectangle,System.Single,System.Single,System.Single,System.Single,System.Drawing.GraphicsUnit)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawImage(System::Drawing::Image ^ image, System::Drawing::Rectangle destRect, float srcX, float srcY, float srcWidth, float srcHeight, System::Drawing::GraphicsUnit srcUnit);" />
      <MemberSignature Language="F#" Value="member this.DrawImage : System.Drawing.Image * System.Drawing.Rectangle * single * single * single * single * System.Drawing.GraphicsUnit -&gt; unit" Usage="graphics.DrawImage (image, destRect, srcX, srcY, srcWidth, srcHeight, srcUnit)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="image" Type="System.Drawing.Image" />
        <Parameter Name="destRect" Type="System.Drawing.Rectangle" />
        <Parameter Name="srcX" Type="System.Single" />
        <Parameter Name="srcY" Type="System.Single" />
        <Parameter Name="srcWidth" Type="System.Single" />
        <Parameter Name="srcHeight" Type="System.Single" />
        <Parameter Name="srcUnit" Type="System.Drawing.GraphicsUnit" />
      </Parameters>
      <Docs>
        <param name="image">要绘制的 <see cref="T:System.Drawing.Image" />。</param>
        <param name="destRect">
          <see cref="T:System.Drawing.Rectangle" /> 结构，它指定所绘制图像的位置和大小。 将图像进行缩放以适合该矩形。</param>
        <param name="srcX">要绘制的源图像部分的左上角的 x 坐标。</param>
        <param name="srcY">要绘制的源图像部分的左上角的 y 坐标。</param>
        <param name="srcWidth">要绘制的源图像部分的宽度。</param>
        <param name="srcHeight">要绘制的源图像部分的高度。</param>
        <param name="srcUnit">
          <see cref="T:System.Drawing.GraphicsUnit" /> 枚举的成员，它指定用于确定源矩形的度量单位。</param>
        <summary>在指定位置并且按指定大小绘制指定的 <see cref="T:System.Drawing.Image" /> 的指定部分。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `srcX`， `srcY`， `srcWidth`，和`srcHeight`参数指定的一个矩形部分`image`对象来绘制。 该矩形是相对于源映像的左上角。 此部分缩放以适合指定的矩形`destRect`参数。  
  
   
  
## Examples  
 下面的代码示例设计为使用 Windows 窗体，并且它需要<xref:System.Windows.Forms.PaintEventArgs> `e`，这是一个参数的<xref:System.Windows.Forms.Control.Paint>事件处理程序。 该代码执行下列操作：  
  
-   创建从 JPEG 文件的文件夹中的示例 sampimag.jpg 位于同一个图像。  
  
-   创建要在其中绘制图像的目标矩形的坐标。  
  
-   创建要从中提取图像的一部分的源矩形。  
  
-   设置源矩形的度量单位为像素。  
  
-   将图像绘制到屏幕。  
  
 目标矩形的位置确定在屏幕上图像、 源和目标矩形的大小确定所绘制图像的缩放和源矩形的大小确定原始图像的哪个部分绘制到屏幕。  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples#52](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CPP/form1.cpp#52)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples#52](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CS/form1.cs#52)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples#52](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/VB/form1.vb#52)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="image" /> 为 <see langword="null" />。</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">图像、位图和图元文件</related>
      </Docs>
    </Member>
    <Member MemberName="DrawImage">
      <MemberSignature Language="C#" Value="public void DrawImage (System.Drawing.Image image, System.Drawing.Rectangle destRect, int srcX, int srcY, int srcWidth, int srcHeight, System.Drawing.GraphicsUnit srcUnit, System.Drawing.Imaging.ImageAttributes imageAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawImage(class System.Drawing.Image image, valuetype System.Drawing.Rectangle destRect, int32 srcX, int32 srcY, int32 srcWidth, int32 srcHeight, valuetype System.Drawing.GraphicsUnit srcUnit, class System.Drawing.Imaging.ImageAttributes imageAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawImage(System.Drawing.Image,System.Drawing.Rectangle,System.Int32,System.Int32,System.Int32,System.Int32,System.Drawing.GraphicsUnit,System.Drawing.Imaging.ImageAttributes)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawImage(System::Drawing::Image ^ image, System::Drawing::Rectangle destRect, int srcX, int srcY, int srcWidth, int srcHeight, System::Drawing::GraphicsUnit srcUnit, System::Drawing::Imaging::ImageAttributes ^ imageAttr);" />
      <MemberSignature Language="F#" Value="member this.DrawImage : System.Drawing.Image * System.Drawing.Rectangle * int * int * int * int * System.Drawing.GraphicsUnit * System.Drawing.Imaging.ImageAttributes -&gt; unit" Usage="graphics.DrawImage (image, destRect, srcX, srcY, srcWidth, srcHeight, srcUnit, imageAttr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="image" Type="System.Drawing.Image" />
        <Parameter Name="destRect" Type="System.Drawing.Rectangle" />
        <Parameter Name="srcX" Type="System.Int32" />
        <Parameter Name="srcY" Type="System.Int32" />
        <Parameter Name="srcWidth" Type="System.Int32" />
        <Parameter Name="srcHeight" Type="System.Int32" />
        <Parameter Name="srcUnit" Type="System.Drawing.GraphicsUnit" />
        <Parameter Name="imageAttr" Type="System.Drawing.Imaging.ImageAttributes" />
      </Parameters>
      <Docs>
        <param name="image">要绘制的 <see cref="T:System.Drawing.Image" />。</param>
        <param name="destRect">
          <see cref="T:System.Drawing.Rectangle" /> 结构，它指定所绘制图像的位置和大小。 将图像进行缩放以适合该矩形。</param>
        <param name="srcX">要绘制的源图像部分的左上角的 x 坐标。</param>
        <param name="srcY">要绘制的源图像部分的左上角的 y 坐标。</param>
        <param name="srcWidth">要绘制的源图像部分的宽度。</param>
        <param name="srcHeight">要绘制的源图像部分的高度。</param>
        <param name="srcUnit">
          <see cref="T:System.Drawing.GraphicsUnit" /> 枚举的成员，它指定用于确定源矩形的度量单位。</param>
        <param name="imageAttr">
          <see cref="T:System.Drawing.Imaging.ImageAttributes" />，它指定 <c>image</c> 对象的重新着色和伽玛信息。</param>
        <summary>在指定位置并且按指定大小绘制指定的 <see cref="T:System.Drawing.Image" /> 的指定部分。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `srcX`， `srcY`， `srcWidth`，和`srcHeight`参数指定的一个矩形部分`image`对象来绘制。 该矩形是相对于源映像的左上角。 此部分缩放以适合指定的矩形`destRect`参数。  
  
   
  
## Examples  
 下面的代码示例设计为使用 Windows 窗体，并且它需要<xref:System.Windows.Forms.PaintEventArgs> `e`，这是一个参数的<xref:System.Windows.Forms.Control.Paint>事件处理程序。 该代码执行下列操作：  
  
-   创建从 JPEG 文件的文件夹中的示例 sampimag.jpg 位于同一个图像。  
  
-   创建在其中绘制图像的目标矩形。  
  
-   创建要从中提取图像的一部分的源矩形的坐标。  
  
-   设置源矩形的度量单位为像素。  
  
-   将原始图像绘制到屏幕。  
  
-   创建要在其中绘制调整后的图像的附加矩形。  
  
-   创建并设置调整后的映像，以便具有比平常的伽玛值的属性。  
  
-   将调整后的图像绘制到屏幕。  
  
 原始的、 未调整目标矩形的位置确定图像在屏幕上，以及源和目标矩形的大小确定所绘制图像的缩放和源矩形的大小决定的哪些部分原始图像绘制到屏幕。  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples#49](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CPP/form1.cpp#49)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples#49](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CS/form1.cs#49)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples#49](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/VB/form1.vb#49)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="image" /> 为 <see langword="null" />。</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">图像、位图和图元文件</related>
      </Docs>
    </Member>
    <Member MemberName="DrawImage">
      <MemberSignature Language="C#" Value="public void DrawImage (System.Drawing.Image image, System.Drawing.Rectangle destRect, float srcX, float srcY, float srcWidth, float srcHeight, System.Drawing.GraphicsUnit srcUnit, System.Drawing.Imaging.ImageAttributes imageAttrs);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawImage(class System.Drawing.Image image, valuetype System.Drawing.Rectangle destRect, float32 srcX, float32 srcY, float32 srcWidth, float32 srcHeight, valuetype System.Drawing.GraphicsUnit srcUnit, class System.Drawing.Imaging.ImageAttributes imageAttrs) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawImage(System.Drawing.Image,System.Drawing.Rectangle,System.Single,System.Single,System.Single,System.Single,System.Drawing.GraphicsUnit,System.Drawing.Imaging.ImageAttributes)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawImage(System::Drawing::Image ^ image, System::Drawing::Rectangle destRect, float srcX, float srcY, float srcWidth, float srcHeight, System::Drawing::GraphicsUnit srcUnit, System::Drawing::Imaging::ImageAttributes ^ imageAttrs);" />
      <MemberSignature Language="F#" Value="member this.DrawImage : System.Drawing.Image * System.Drawing.Rectangle * single * single * single * single * System.Drawing.GraphicsUnit * System.Drawing.Imaging.ImageAttributes -&gt; unit" Usage="graphics.DrawImage (image, destRect, srcX, srcY, srcWidth, srcHeight, srcUnit, imageAttrs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="image" Type="System.Drawing.Image" />
        <Parameter Name="destRect" Type="System.Drawing.Rectangle" />
        <Parameter Name="srcX" Type="System.Single" />
        <Parameter Name="srcY" Type="System.Single" />
        <Parameter Name="srcWidth" Type="System.Single" />
        <Parameter Name="srcHeight" Type="System.Single" />
        <Parameter Name="srcUnit" Type="System.Drawing.GraphicsUnit" />
        <Parameter Name="imageAttrs" Type="System.Drawing.Imaging.ImageAttributes" />
      </Parameters>
      <Docs>
        <param name="image">要绘制的 <see cref="T:System.Drawing.Image" />。</param>
        <param name="destRect">
          <see cref="T:System.Drawing.Rectangle" /> 结构，它指定所绘制图像的位置和大小。 将图像进行缩放以适合该矩形。</param>
        <param name="srcX">要绘制的源图像部分的左上角的 x 坐标。</param>
        <param name="srcY">要绘制的源图像部分的左上角的 y 坐标。</param>
        <param name="srcWidth">要绘制的源图像部分的宽度。</param>
        <param name="srcHeight">要绘制的源图像部分的高度。</param>
        <param name="srcUnit">
          <see cref="T:System.Drawing.GraphicsUnit" /> 枚举的成员，它指定用于确定源矩形的度量单位。</param>
        <param name="imageAttrs">
          <see cref="T:System.Drawing.Imaging.ImageAttributes" />，它指定 <c>image</c> 对象的重新着色和伽玛信息。</param>
        <summary>在指定位置并且按指定大小绘制指定的 <see cref="T:System.Drawing.Image" /> 的指定部分。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `srcX`， `srcY`， `srcWidth`，和`srcHeight`参数指定的一个矩形部分`image`对象来绘制。 该矩形是相对于源映像的左上角。 此部分缩放以适合指定的矩形`destRect`参数。  
  
   
  
## Examples  
 下面的代码示例设计为使用 Windows 窗体，并且它需要<xref:System.Windows.Forms.PaintEventArgs> `e`，这是一个参数的<xref:System.Windows.Forms.Control.Paint>事件处理程序。 该代码执行下列操作：  
  
-   创建从 JPEG 文件的文件夹中的示例 sampimag.jpg 位于同一个图像。  
  
-   创建在其中绘制图像的目标矩形。  
  
-   创建要从中提取图像的一部分的源矩形的坐标。  
  
-   设置源矩形的度量单位为像素。  
  
-   将原始图像绘制到屏幕。  
  
-   创建要在其中绘制调整后的图像的附加矩形。  
  
-   创建并设置调整后的映像，以便具有比平常的伽玛值的属性。  
  
-   将调整后的图像绘制到屏幕。  
  
 原始的、 未调整目标矩形的位置确定图像在屏幕上，以及源和目标矩形的大小确定所绘制图像的缩放和源矩形的大小决定的哪些部分原始图像绘制到屏幕。  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples#53](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CPP/form1.cpp#53)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples#53](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CS/form1.cs#53)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples#53](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/VB/form1.vb#53)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="image" /> 为 <see langword="null" />。</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">图像、位图和图元文件</related>
      </Docs>
    </Member>
    <Member MemberName="DrawImage">
      <MemberSignature Language="C#" Value="public void DrawImage (System.Drawing.Image image, System.Drawing.Rectangle destRect, int srcX, int srcY, int srcWidth, int srcHeight, System.Drawing.GraphicsUnit srcUnit, System.Drawing.Imaging.ImageAttributes imageAttr, System.Drawing.Graphics.DrawImageAbort callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawImage(class System.Drawing.Image image, valuetype System.Drawing.Rectangle destRect, int32 srcX, int32 srcY, int32 srcWidth, int32 srcHeight, valuetype System.Drawing.GraphicsUnit srcUnit, class System.Drawing.Imaging.ImageAttributes imageAttr, class System.Drawing.Graphics/DrawImageAbort callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawImage(System.Drawing.Image,System.Drawing.Rectangle,System.Int32,System.Int32,System.Int32,System.Int32,System.Drawing.GraphicsUnit,System.Drawing.Imaging.ImageAttributes,System.Drawing.Graphics.DrawImageAbort)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawImage(System::Drawing::Image ^ image, System::Drawing::Rectangle destRect, int srcX, int srcY, int srcWidth, int srcHeight, System::Drawing::GraphicsUnit srcUnit, System::Drawing::Imaging::ImageAttributes ^ imageAttr, System::Drawing::Graphics::DrawImageAbort ^ callback);" />
      <MemberSignature Language="F#" Value="member this.DrawImage : System.Drawing.Image * System.Drawing.Rectangle * int * int * int * int * System.Drawing.GraphicsUnit * System.Drawing.Imaging.ImageAttributes * System.Drawing.Graphics.DrawImageAbort -&gt; unit" Usage="graphics.DrawImage (image, destRect, srcX, srcY, srcWidth, srcHeight, srcUnit, imageAttr, callback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="image" Type="System.Drawing.Image" />
        <Parameter Name="destRect" Type="System.Drawing.Rectangle" />
        <Parameter Name="srcX" Type="System.Int32" />
        <Parameter Name="srcY" Type="System.Int32" />
        <Parameter Name="srcWidth" Type="System.Int32" />
        <Parameter Name="srcHeight" Type="System.Int32" />
        <Parameter Name="srcUnit" Type="System.Drawing.GraphicsUnit" />
        <Parameter Name="imageAttr" Type="System.Drawing.Imaging.ImageAttributes" />
        <Parameter Name="callback" Type="System.Drawing.Graphics+DrawImageAbort" />
      </Parameters>
      <Docs>
        <param name="image">要绘制的 <see cref="T:System.Drawing.Image" />。</param>
        <param name="destRect">
          <see cref="T:System.Drawing.Rectangle" /> 结构，它指定所绘制图像的位置和大小。 将图像进行缩放以适合该矩形。</param>
        <param name="srcX">要绘制的源图像部分的左上角的 x 坐标。</param>
        <param name="srcY">要绘制的源图像部分的左上角的 y 坐标。</param>
        <param name="srcWidth">要绘制的源图像部分的宽度。</param>
        <param name="srcHeight">要绘制的源图像部分的高度。</param>
        <param name="srcUnit">
          <see cref="T:System.Drawing.GraphicsUnit" /> 枚举的成员，它指定用于确定源矩形的度量单位。</param>
        <param name="imageAttr">
          <see cref="T:System.Drawing.Imaging.ImageAttributes" />，它指定 <c>image</c> 的重新着色和伽玛信息。</param>
        <param name="callback">
          <see cref="T:System.Drawing.Graphics.DrawImageAbort" /> 委托，它指定在绘制图像期间要调用的方法。 此方法被频繁调用以检查是否根据应用程序确定的条件停止 <see cref="M:System.Drawing.Graphics.DrawImage(System.Drawing.Image,System.Drawing.Rectangle,System.Int32,System.Int32,System.Int32,System.Int32,System.Drawing.GraphicsUnit,System.Drawing.Imaging.ImageAttributes,System.Drawing.Graphics.DrawImageAbort)" /> 方法的执行。</param>
        <summary>在指定位置并且按指定大小绘制指定的 <see cref="T:System.Drawing.Image" /> 的指定部分。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `srcX`， `srcY`， `srcWidth`，和`srcHeight`参数指定的一个矩形部分`image`对象来绘制。 该矩形是相对于源映像的左上角。 此部分缩放以适合指定的矩形`destRect`对象。  
  
 使用此重载`callback`参数提供了根据条件由应用程序启动后停止的图像的绘制的方法。 例如，应用程序可能开始绘制一个大图像，用户可能会滚动屏幕上，用例应用程序可以在其中停止绘制图像。  
  
   
  
## Examples  
 下面的代码示例设计为使用 Windows 窗体，并且它需要<xref:System.Windows.Forms.PaintEventArgs> `e`，这是一个参数的<xref:System.Windows.Forms.Control.Paint>事件处理程序。 代码首先定义回调方法，以<xref:System.Drawing.Graphics.DrawImageAbort>委托; 定义是过于简单，只是测试以了解是否<xref:System.Drawing.Graphics.DrawImage%2A>方法调用它为 null`callBackData`参数。 该示例的主要部分执行以下操作：  
  
-   创建的实例<xref:System.Drawing.Graphics.DrawImageAbort>回调方法。  
  
-   创建从 JPEG 文件的文件夹中的示例 sampimag.jpg 位于同一个图像。  
  
-   创建定义在其中绘制图像的目标矩形的点。  
  
-   创建一个源矩形来选择要绘制的图像的一部分。  
  
-   设置图形绘制像素为单位。  
  
-   将原始图像绘制到屏幕。  
  
-   创建要在其中绘制调整后的图像的附加目标矩形。  
  
-   创建并设置调整后的映像，以便具有比平常的伽玛值的属性。  
  
-   将调整后的图像绘制到屏幕。  
  
 对于原始、 未调整目标矩形中，位置在屏幕上，确定图像和源矩形和大小的大小和形状目标矩形确定所绘制图像的缩放。  
  
 因为此示例使用未通过的重载`callBackData`参数，<xref:System.Drawing.Graphics.DrawImageAbort>回调返回`true`，这将导致<xref:System.Drawing.Graphics.DrawImage%2A>结束，并在示例中包含的异常处理代码的方法将输出异常文本而不是绘制图像。  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples#50](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CPP/form1.cpp#50)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples#50](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CS/form1.cs#50)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples#50](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/VB/form1.vb#50)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="image" /> 为 <see langword="null" />。</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">图像、位图和图元文件</related>
      </Docs>
    </Member>
    <Member MemberName="DrawImage">
      <MemberSignature Language="C#" Value="public void DrawImage (System.Drawing.Image image, System.Drawing.Rectangle destRect, float srcX, float srcY, float srcWidth, float srcHeight, System.Drawing.GraphicsUnit srcUnit, System.Drawing.Imaging.ImageAttributes imageAttrs, System.Drawing.Graphics.DrawImageAbort callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawImage(class System.Drawing.Image image, valuetype System.Drawing.Rectangle destRect, float32 srcX, float32 srcY, float32 srcWidth, float32 srcHeight, valuetype System.Drawing.GraphicsUnit srcUnit, class System.Drawing.Imaging.ImageAttributes imageAttrs, class System.Drawing.Graphics/DrawImageAbort callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawImage(System.Drawing.Image,System.Drawing.Rectangle,System.Single,System.Single,System.Single,System.Single,System.Drawing.GraphicsUnit,System.Drawing.Imaging.ImageAttributes,System.Drawing.Graphics.DrawImageAbort)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawImage(System::Drawing::Image ^ image, System::Drawing::Rectangle destRect, float srcX, float srcY, float srcWidth, float srcHeight, System::Drawing::GraphicsUnit srcUnit, System::Drawing::Imaging::ImageAttributes ^ imageAttrs, System::Drawing::Graphics::DrawImageAbort ^ callback);" />
      <MemberSignature Language="F#" Value="member this.DrawImage : System.Drawing.Image * System.Drawing.Rectangle * single * single * single * single * System.Drawing.GraphicsUnit * System.Drawing.Imaging.ImageAttributes * System.Drawing.Graphics.DrawImageAbort -&gt; unit" Usage="graphics.DrawImage (image, destRect, srcX, srcY, srcWidth, srcHeight, srcUnit, imageAttrs, callback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="image" Type="System.Drawing.Image" />
        <Parameter Name="destRect" Type="System.Drawing.Rectangle" />
        <Parameter Name="srcX" Type="System.Single" />
        <Parameter Name="srcY" Type="System.Single" />
        <Parameter Name="srcWidth" Type="System.Single" />
        <Parameter Name="srcHeight" Type="System.Single" />
        <Parameter Name="srcUnit" Type="System.Drawing.GraphicsUnit" />
        <Parameter Name="imageAttrs" Type="System.Drawing.Imaging.ImageAttributes" />
        <Parameter Name="callback" Type="System.Drawing.Graphics+DrawImageAbort" />
      </Parameters>
      <Docs>
        <param name="image">要绘制的 <see cref="T:System.Drawing.Image" />。</param>
        <param name="destRect">
          <see cref="T:System.Drawing.Rectangle" /> 结构，它指定所绘制图像的位置和大小。 将图像进行缩放以适合该矩形。</param>
        <param name="srcX">要绘制的源图像部分的左上角的 x 坐标。</param>
        <param name="srcY">要绘制的源图像部分的左上角的 y 坐标。</param>
        <param name="srcWidth">要绘制的源图像部分的宽度。</param>
        <param name="srcHeight">要绘制的源图像部分的高度。</param>
        <param name="srcUnit">
          <see cref="T:System.Drawing.GraphicsUnit" /> 枚举的成员，它指定用于确定源矩形的度量单位。</param>
        <param name="imageAttrs">
          <see cref="T:System.Drawing.Imaging.ImageAttributes" />，它指定 <c>image</c> 对象的重新着色和伽玛信息。</param>
        <param name="callback">
          <see cref="T:System.Drawing.Graphics.DrawImageAbort" /> 委托，它指定在绘制图像期间要调用的方法。 此方法被频繁调用以检查是否根据应用程序确定的条件停止 <see cref="M:System.Drawing.Graphics.DrawImage(System.Drawing.Image,System.Drawing.Rectangle,System.Single,System.Single,System.Single,System.Single,System.Drawing.GraphicsUnit,System.Drawing.Imaging.ImageAttributes,System.Drawing.Graphics.DrawImageAbort)" /> 方法的执行。</param>
        <summary>在指定位置并且按指定大小绘制指定的 <see cref="T:System.Drawing.Image" /> 的指定部分。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `srcX`， `srcY`， `srcWidth`，和`srcHeight`参数指定的一个矩形部分`image`对象来绘制。 该矩形是相对于源映像的左上角。 此部分缩放以适合指定的矩形`destRect`参数。  
  
 使用此重载`callback`参数提供了根据条件由应用程序启动后停止的图像的绘制的方法。 例如，应用程序可能开始绘制一个大图像，用户可能会滚动屏幕上，用例应用程序可以在其中停止绘制图像。  
  
   
  
## Examples  
 下面的代码示例设计为使用 Windows 窗体，并且它需要<xref:System.Windows.Forms.PaintEventArgs> `e`，这是一个参数的<xref:System.Windows.Forms.Control.Paint>事件处理程序。 代码首先定义回调方法，以<xref:System.Drawing.Graphics.DrawImageAbort>委托; 定义是过于简单，只是测试以了解是否<xref:System.Drawing.Graphics.DrawImage%2A>方法调用它为 null`callBackData`参数。 该示例的主要部分执行以下操作：  
  
-   创建的实例<xref:System.Drawing.Graphics.DrawImageAbort>回调方法。  
  
-   创建从 JPEG 文件的文件夹中的示例 sampimag.jpg 位于同一个图像。  
  
-   创建定义在其中绘制图像的目标矩形的点。  
  
-   创建一个源矩形来选择要绘制的图像的一部分。  
  
-   设置图形绘制像素为单位。  
  
-   将原始图像绘制到屏幕。  
  
-   创建要在其中绘制调整后的图像的附加目标矩形。  
  
-   创建并设置调整后的映像，以便具有比平常的伽玛值的属性。  
  
-   将调整后的图像绘制到屏幕。  
  
 对于原始、 未调整目标矩形中，位置在屏幕上，确定图像和源矩形和大小的大小和形状目标矩形确定所绘制图像的缩放。  
  
 因为此示例使用未通过的重载`callBackData`参数，<xref:System.Drawing.Graphics.DrawImageAbort>回调返回`true`，这将导致<xref:System.Drawing.Graphics.DrawImage%2A>结束，并在示例中包含的异常处理代码的方法将输出异常文本而不是绘制图像。  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples#54](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CPP/form1.cpp#54)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples#54](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CS/form1.cs#54)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples#54](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/VB/form1.vb#54)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="image" /> 为 <see langword="null" />。</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">图像、位图和图元文件</related>
      </Docs>
    </Member>
    <Member MemberName="DrawImage">
      <MemberSignature Language="C#" Value="public void DrawImage (System.Drawing.Image image, System.Drawing.Rectangle destRect, int srcX, int srcY, int srcWidth, int srcHeight, System.Drawing.GraphicsUnit srcUnit, System.Drawing.Imaging.ImageAttributes imageAttrs, System.Drawing.Graphics.DrawImageAbort callback, IntPtr callbackData);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawImage(class System.Drawing.Image image, valuetype System.Drawing.Rectangle destRect, int32 srcX, int32 srcY, int32 srcWidth, int32 srcHeight, valuetype System.Drawing.GraphicsUnit srcUnit, class System.Drawing.Imaging.ImageAttributes imageAttrs, class System.Drawing.Graphics/DrawImageAbort callback, native int callbackData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawImage(System.Drawing.Image,System.Drawing.Rectangle,System.Int32,System.Int32,System.Int32,System.Int32,System.Drawing.GraphicsUnit,System.Drawing.Imaging.ImageAttributes,System.Drawing.Graphics.DrawImageAbort,System.IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawImage(System::Drawing::Image ^ image, System::Drawing::Rectangle destRect, int srcX, int srcY, int srcWidth, int srcHeight, System::Drawing::GraphicsUnit srcUnit, System::Drawing::Imaging::ImageAttributes ^ imageAttrs, System::Drawing::Graphics::DrawImageAbort ^ callback, IntPtr callbackData);" />
      <MemberSignature Language="F#" Value="member this.DrawImage : System.Drawing.Image * System.Drawing.Rectangle * int * int * int * int * System.Drawing.GraphicsUnit * System.Drawing.Imaging.ImageAttributes * System.Drawing.Graphics.DrawImageAbort * nativeint -&gt; unit" Usage="graphics.DrawImage (image, destRect, srcX, srcY, srcWidth, srcHeight, srcUnit, imageAttrs, callback, callbackData)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="image" Type="System.Drawing.Image" />
        <Parameter Name="destRect" Type="System.Drawing.Rectangle" />
        <Parameter Name="srcX" Type="System.Int32" />
        <Parameter Name="srcY" Type="System.Int32" />
        <Parameter Name="srcWidth" Type="System.Int32" />
        <Parameter Name="srcHeight" Type="System.Int32" />
        <Parameter Name="srcUnit" Type="System.Drawing.GraphicsUnit" />
        <Parameter Name="imageAttrs" Type="System.Drawing.Imaging.ImageAttributes" />
        <Parameter Name="callback" Type="System.Drawing.Graphics+DrawImageAbort" />
        <Parameter Name="callbackData" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="image">要绘制的 <see cref="T:System.Drawing.Image" />。</param>
        <param name="destRect">
          <see cref="T:System.Drawing.Rectangle" /> 结构，它指定所绘制图像的位置和大小。 将图像进行缩放以适合该矩形。</param>
        <param name="srcX">要绘制的源图像部分的左上角的 x 坐标。</param>
        <param name="srcY">要绘制的源图像部分的左上角的 y 坐标。</param>
        <param name="srcWidth">要绘制的源图像部分的宽度。</param>
        <param name="srcHeight">要绘制的源图像部分的高度。</param>
        <param name="srcUnit">
          <see cref="T:System.Drawing.GraphicsUnit" /> 枚举的成员，它指定用于确定源矩形的度量单位。</param>
        <param name="imageAttrs">
          <see cref="T:System.Drawing.Imaging.ImageAttributes" />，它指定 <c>image</c> 对象的重新着色和伽玛信息。</param>
        <param name="callback">
          <see cref="T:System.Drawing.Graphics.DrawImageAbort" /> 委托，它指定在绘制图像期间要调用的方法。 此方法被频繁调用以检查是否根据应用程序确定的条件停止 <see cref="M:System.Drawing.Graphics.DrawImage(System.Drawing.Image,System.Drawing.Rectangle,System.Int32,System.Int32,System.Int32,System.Int32,System.Drawing.GraphicsUnit,System.Drawing.Imaging.ImageAttributes,System.Drawing.Graphics.DrawImageAbort,System.IntPtr)" /> 方法的执行。</param>
        <param name="callbackData">一个值，它为 <see cref="T:System.Drawing.Graphics.DrawImageAbort" /> 委托指定在检查是否停止执行 <see langword="DrawImage" /> 方法时要使用的附加数据。</param>
        <summary>在指定位置并且按指定大小绘制指定的 <see cref="T:System.Drawing.Image" /> 的指定部分。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `srcX`， `srcY`， `srcWidth`，和`srcHeight`参数指定的一个矩形部分`image`对象来绘制。 该矩形是相对于源映像的左上角。 此部分缩放以适合指定的矩形`destRect`参数。  
  
 使用此重载`callback`和`callbackData`参数提供了根据条件和数据由应用程序启动后停止的图像的绘制的方法。 例如，应用程序可能开始绘制一个大图像，用户可能会滚动屏幕上，用例应用程序可以在其中停止绘制图像。  
  
   
  
## Examples  
 下面的代码示例设计为使用 Windows 窗体，并且它需要<xref:System.Windows.Forms.PaintEventArgs> `e`，这是一个参数的<xref:System.Windows.Forms.Control.Paint>事件处理程序。 代码首先定义回调方法，以<xref:System.Drawing.Graphics.DrawImageAbort>委托; 定义是过于简单，只是测试以了解是否<xref:System.Drawing.Graphics.DrawImage%2A>方法调用它为 null`callBackData`参数。 该示例的主要部分执行以下操作：  
  
-   创建的实例<xref:System.Drawing.Graphics.DrawImageAbort>回调方法。  
  
-   创建从 JPEG 文件的文件夹中的示例 sampimag.jpg 位于同一个图像。  
  
-   创建定义在其中绘制图像的目标矩形的点。  
  
-   创建一个源矩形来选择要绘制的图像的一部分。  
  
-   设置图形绘制像素为单位。  
  
-   将原始图像绘制到屏幕。  
  
-   创建要在其中绘制调整后的图像的附加目标矩形。  
  
-   创建并设置调整后的映像，以便具有比平常的伽玛值的属性。  
  
-   将调整后的图像绘制到屏幕。  
  
 对于原始、 未调整目标矩形中，位置在屏幕上，确定图像和源矩形和大小的大小和形状目标矩形确定所绘制图像的缩放。  
  
 因为此示例使用传递的重载`callBackData`参数，<xref:System.Drawing.Graphics.DrawImageAbort>回调返回`false`，这将导致<xref:System.Drawing.Graphics.DrawImage%2A>方法，若要继续，以及的示例将调整后的图像绘制到屏幕。  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples#51](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CPP/form1.cpp#51)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples#51](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CS/form1.cs#51)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples#51](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/VB/form1.vb#51)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="image" /> 为 <see langword="null" />。</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">图像、位图和图元文件</related>
      </Docs>
    </Member>
    <Member MemberName="DrawImage">
      <MemberSignature Language="C#" Value="public void DrawImage (System.Drawing.Image image, System.Drawing.Rectangle destRect, float srcX, float srcY, float srcWidth, float srcHeight, System.Drawing.GraphicsUnit srcUnit, System.Drawing.Imaging.ImageAttributes imageAttrs, System.Drawing.Graphics.DrawImageAbort callback, IntPtr callbackData);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawImage(class System.Drawing.Image image, valuetype System.Drawing.Rectangle destRect, float32 srcX, float32 srcY, float32 srcWidth, float32 srcHeight, valuetype System.Drawing.GraphicsUnit srcUnit, class System.Drawing.Imaging.ImageAttributes imageAttrs, class System.Drawing.Graphics/DrawImageAbort callback, native int callbackData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawImage(System.Drawing.Image,System.Drawing.Rectangle,System.Single,System.Single,System.Single,System.Single,System.Drawing.GraphicsUnit,System.Drawing.Imaging.ImageAttributes,System.Drawing.Graphics.DrawImageAbort,System.IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawImage(System::Drawing::Image ^ image, System::Drawing::Rectangle destRect, float srcX, float srcY, float srcWidth, float srcHeight, System::Drawing::GraphicsUnit srcUnit, System::Drawing::Imaging::ImageAttributes ^ imageAttrs, System::Drawing::Graphics::DrawImageAbort ^ callback, IntPtr callbackData);" />
      <MemberSignature Language="F#" Value="member this.DrawImage : System.Drawing.Image * System.Drawing.Rectangle * single * single * single * single * System.Drawing.GraphicsUnit * System.Drawing.Imaging.ImageAttributes * System.Drawing.Graphics.DrawImageAbort * nativeint -&gt; unit" Usage="graphics.DrawImage (image, destRect, srcX, srcY, srcWidth, srcHeight, srcUnit, imageAttrs, callback, callbackData)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="image" Type="System.Drawing.Image" />
        <Parameter Name="destRect" Type="System.Drawing.Rectangle" />
        <Parameter Name="srcX" Type="System.Single" />
        <Parameter Name="srcY" Type="System.Single" />
        <Parameter Name="srcWidth" Type="System.Single" />
        <Parameter Name="srcHeight" Type="System.Single" />
        <Parameter Name="srcUnit" Type="System.Drawing.GraphicsUnit" />
        <Parameter Name="imageAttrs" Type="System.Drawing.Imaging.ImageAttributes" />
        <Parameter Name="callback" Type="System.Drawing.Graphics+DrawImageAbort" />
        <Parameter Name="callbackData" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="image">要绘制的 <see cref="T:System.Drawing.Image" />。</param>
        <param name="destRect">
          <see cref="T:System.Drawing.Rectangle" /> 结构，它指定所绘制图像的位置和大小。 将图像进行缩放以适合该矩形。</param>
        <param name="srcX">要绘制的源图像部分的左上角的 x 坐标。</param>
        <param name="srcY">要绘制的源图像部分的左上角的 y 坐标。</param>
        <param name="srcWidth">要绘制的源图像部分的宽度。</param>
        <param name="srcHeight">要绘制的源图像部分的高度。</param>
        <param name="srcUnit">
          <see cref="T:System.Drawing.GraphicsUnit" /> 枚举的成员，它指定用于确定源矩形的度量单位。</param>
        <param name="imageAttrs">
          <see cref="T:System.Drawing.Imaging.ImageAttributes" />，它指定 <c>image</c> 对象的重新着色和伽玛信息。</param>
        <param name="callback">
          <see cref="T:System.Drawing.Graphics.DrawImageAbort" /> 委托，它指定在绘制图像期间要调用的方法。 此方法被频繁调用以检查是否根据应用程序确定的条件停止 <see cref="M:System.Drawing.Graphics.DrawImage(System.Drawing.Image,System.Drawing.Rectangle,System.Single,System.Single,System.Single,System.Single,System.Drawing.GraphicsUnit,System.Drawing.Imaging.ImageAttributes,System.Drawing.Graphics.DrawImageAbort,System.IntPtr)" /> 方法的执行。</param>
        <param name="callbackData">一个值，它为 <see cref="T:System.Drawing.Graphics.DrawImageAbort" /> 委托指定在检查是否停止执行 <see langword="DrawImage" /> 方法时要使用的附加数据。</param>
        <summary>在指定位置并且按指定大小绘制指定的 <see cref="T:System.Drawing.Image" /> 的指定部分。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `srcX`， `srcY`， `srcWidth`，和`srcHeight`参数指定的一个矩形部分`image`对象来绘制。 该矩形是相对于源映像的左上角。 此部分缩放以适合指定的矩形`destRect`参数。  
  
 使用此重载`callback`和`callbackData`参数提供了根据条件和数据由应用程序启动后停止的图像的绘制的方法。 例如，应用程序可能开始绘制一个大图像，用户可能会滚动屏幕上，用例应用程序可以在其中停止绘制图像。  
  
   
  
## Examples  
 下面的代码示例设计为使用 Windows 窗体，并且它需要<xref:System.Windows.Forms.PaintEventArgs> `e`，这是一个参数的<xref:System.Windows.Forms.Control.Paint>事件处理程序。 代码首先定义回调方法，以<xref:System.Drawing.Graphics.DrawImageAbort>委托; 定义是过于简单，只是测试以了解是否<xref:System.Drawing.Graphics.DrawImage%2A>方法调用它为 null`callBackData`参数。 该示例的主要部分执行以下操作：  
  
-   创建的实例<xref:System.Drawing.Graphics.DrawImageAbort>回调方法。  
  
-   创建从 JPEG 文件的文件夹中的示例 sampimag.jpg 位于同一个图像。  
  
-   创建定义在其中绘制图像的目标矩形的点。  
  
-   创建一个源矩形来选择要绘制的图像的一部分。  
  
-   设置图形绘制像素为单位。  
  
-   将原始图像绘制到屏幕。  
  
-   创建要在其中绘制调整后的图像的附加目标矩形。  
  
-   创建并设置调整后的映像，以便具有比平常的伽玛值的属性。  
  
-   将调整后的图像绘制到屏幕。  
  
 对于原始、 未调整目标矩形中，位置在屏幕上，确定图像和源矩形和大小的大小和形状目标矩形确定所绘制图像的缩放。  
  
 因为此示例使用传递的重载`callBackData`参数，<xref:System.Drawing.Graphics.DrawImageAbort>回调返回`false`，这将导致<xref:System.Drawing.Graphics.DrawImage%2A>方法，若要继续，以及的示例将调整后的图像绘制到屏幕。  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples2#55](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CPP/form1.cpp#55)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples2#55](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CS/form1.cs#55)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples2#55](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/VB/form1.vb#55)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="image" /> 为 <see langword="null" />。</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">图像、位图和图元文件</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="DrawImageUnscaled">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>在由坐标对指定的位置，使用图像的原始物理大小绘制指定的图像。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DrawImageUnscaled">
      <MemberSignature Language="C#" Value="public void DrawImageUnscaled (System.Drawing.Image image, System.Drawing.Point point);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawImageUnscaled(class System.Drawing.Image image, valuetype System.Drawing.Point point) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawImageUnscaled(System.Drawing.Image,System.Drawing.Point)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawImageUnscaled(System::Drawing::Image ^ image, System::Drawing::Point point);" />
      <MemberSignature Language="F#" Value="member this.DrawImageUnscaled : System.Drawing.Image * System.Drawing.Point -&gt; unit" Usage="graphics.DrawImageUnscaled (image, point)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="image" Type="System.Drawing.Image" />
        <Parameter Name="point" Type="System.Drawing.Point" />
      </Parameters>
      <Docs>
        <param name="image">要绘制的 <see cref="T:System.Drawing.Image" />。</param>
        <param name="point">
          <see cref="T:System.Drawing.Point" /> 结构，它指定所绘制图像的左上角。</param>
        <summary>在指定的位置使用图像的原始物理大小绘制指定的图像。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Drawing.Image>存储像素宽度值和水平分辨率 （每英寸点数） 的值。 物理宽度，以英寸为单位的单位是图像的像素宽度除以的水平分辨率。 例如，使用像素宽度为 216 和 72 点 / 英寸的水平分辨率的图像具有物理 3 英寸的宽度。 说明同样适用于像素高度和物理的高度。  
  
 <xref:System.Drawing.Graphics.DrawImageUnscaled%2A>方法绘制一个图像使用的物理大小，因此该图像将出现正确的大小，以英寸为单位，而不考虑显示设备的分辨率 （每英寸点数）。 例如，假设图像具有像素宽度为 216 和 72 点 / 英寸的水平分辨率。 如果调用<xref:System.Drawing.Graphics.DrawImageUnscaled%2A>绘制该图像的分辨率为 96 点 / 英寸的设备上，呈现的图像的像素宽度将是 (216/72) * 96 = 288 条。  
  
   
  
## Examples  
 下面的代码示例设计为使用 Windows 窗体，并且它需要<xref:System.Windows.Forms.PaintEventArgs> `e`，这是一个参数的<xref:System.Windows.Forms.Control.Paint>事件处理程序。 该代码执行下列操作：  
  
-   创建从 JPEG 文件的文件夹中的示例 sampimag.jpg 位于同一个图像。  
  
-   创建在其中绘制图像的左上角的点。  
  
-   绘制整个图像使用的物理大小。  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples2#64](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CPP/form1.cpp#64)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples2#64](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CS/form1.cs#64)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples2#64](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/VB/form1.vb#64)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="image" /> 为 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="DrawImageUnscaled">
      <MemberSignature Language="C#" Value="public void DrawImageUnscaled (System.Drawing.Image image, System.Drawing.Rectangle rect);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawImageUnscaled(class System.Drawing.Image image, valuetype System.Drawing.Rectangle rect) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawImageUnscaled(System.Drawing.Image,System.Drawing.Rectangle)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawImageUnscaled(System::Drawing::Image ^ image, System::Drawing::Rectangle rect);" />
      <MemberSignature Language="F#" Value="member this.DrawImageUnscaled : System.Drawing.Image * System.Drawing.Rectangle -&gt; unit" Usage="graphics.DrawImageUnscaled (image, rect)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="image" Type="System.Drawing.Image" />
        <Parameter Name="rect" Type="System.Drawing.Rectangle" />
      </Parameters>
      <Docs>
        <param name="image">要绘制的 <see cref="T:System.Drawing.Image" />。</param>
        <param name="rect">
          <see cref="T:System.Drawing.Rectangle" />，它指定了所绘制图像的左上角。 该矩形的 X 和 Y 属性指定左上角。 宽度和高度属性被忽略。</param>
        <summary>在指定的位置使用图像的原始物理大小绘制指定的图像。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Drawing.Image>存储像素宽度值和水平分辨率 （每英寸点数） 的值。 物理宽度，以英寸为单位的单位是图像的像素宽度除以的水平分辨率。 例如，使用像素宽度为 216 和 72 点 / 英寸的水平分辨率的图像具有物理 3 英寸的宽度。 说明同样适用于像素高度和物理的高度。  
  
 <xref:System.Drawing.Graphics.DrawImageUnscaled%2A>方法绘制一个图像使用的物理大小，因此该图像将出现正确的大小，以英寸为单位，而不考虑显示设备的分辨率 （每英寸点数）。 例如，假设图像具有像素宽度为 216 和 72 点 / 英寸的水平分辨率。 如果调用<xref:System.Drawing.Graphics.DrawImageUnscaled%2A>绘制该图像的分辨率为 96 点 / 英寸的设备上，呈现的图像的像素宽度将是 (216/72) * 96 = 288 条。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="image" /> 为 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="DrawImageUnscaled">
      <MemberSignature Language="C#" Value="public void DrawImageUnscaled (System.Drawing.Image image, int x, int y);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawImageUnscaled(class System.Drawing.Image image, int32 x, int32 y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawImageUnscaled(System.Drawing.Image,System.Int32,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawImageUnscaled(System::Drawing::Image ^ image, int x, int y);" />
      <MemberSignature Language="F#" Value="member this.DrawImageUnscaled : System.Drawing.Image * int * int -&gt; unit" Usage="graphics.DrawImageUnscaled (image, x, y)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="image" Type="System.Drawing.Image" />
        <Parameter Name="x" Type="System.Int32" />
        <Parameter Name="y" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="image">要绘制的 <see cref="T:System.Drawing.Image" />。</param>
        <param name="x">所绘制图像的左上角的 x 坐标。</param>
        <param name="y">所绘制图像的左上角的 y 坐标。</param>
        <summary>在由坐标对指定的位置，使用图像的原始物理大小绘制指定的图像。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Drawing.Image>存储像素宽度值和水平分辨率 （每英寸点数） 的值。 物理宽度，以英寸为单位的单位是图像的像素宽度除以的水平分辨率。 例如，使用像素宽度为 216 和 72 点 / 英寸的水平分辨率的图像具有物理 3 英寸的宽度。 说明同样适用于像素高度和物理的高度。  
  
 <xref:System.Drawing.Graphics.DrawImageUnscaled%2A>方法绘制一个图像使用的物理大小，因此该图像将出现正确的大小，以英寸为单位，而不考虑显示设备的分辨率 （每英寸点数）。 例如，假设图像具有像素宽度为 216 和 72 点 / 英寸的水平分辨率。 如果调用<xref:System.Drawing.Graphics.DrawImageUnscaled%2A>绘制该图像的分辨率为 96 点 / 英寸的设备上，呈现的图像的像素宽度将是 (216/72) * 96 = 288 条。  
  
   
  
## Examples  
 下面的代码示例设计为使用 Windows 窗体，并且它需要<xref:System.Windows.Forms.PaintEventArgs> `e`，这是一个参数的<xref:System.Windows.Forms.Control.Paint>事件处理程序。 该代码执行下列操作：  
  
-   从 JPEG 文件，sampimag.jpg 位于同，该示例的文件夹中创建映像。  
  
-   创建在其中绘制图像的左上角的点。  
  
-   绘制整个图像使用的物理大小。  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples2#65](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CPP/form1.cpp#65)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples2#65](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CS/form1.cs#65)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples2#65](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/VB/form1.vb#65)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="image" /> 为 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="DrawImageUnscaled">
      <MemberSignature Language="C#" Value="public void DrawImageUnscaled (System.Drawing.Image image, int x, int y, int width, int height);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawImageUnscaled(class System.Drawing.Image image, int32 x, int32 y, int32 width, int32 height) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawImageUnscaled(System.Drawing.Image,System.Int32,System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawImageUnscaled(System::Drawing::Image ^ image, int x, int y, int width, int height);" />
      <MemberSignature Language="F#" Value="member this.DrawImageUnscaled : System.Drawing.Image * int * int * int * int -&gt; unit" Usage="graphics.DrawImageUnscaled (image, x, y, width, height)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="image" Type="System.Drawing.Image" />
        <Parameter Name="x" Type="System.Int32" />
        <Parameter Name="y" Type="System.Int32" />
        <Parameter Name="width" Type="System.Int32" />
        <Parameter Name="height" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="image">要绘制的 <see cref="T:System.Drawing.Image" />。</param>
        <param name="x">所绘制图像的左上角的 x 坐标。</param>
        <param name="y">所绘制图像的左上角的 y 坐标。</param>
        <param name="width">未使用。</param>
        <param name="height">未使用。</param>
        <summary>在指定的位置使用图像的原始物理大小绘制指定的图像。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Drawing.Image>存储像素宽度值和水平分辨率 （每英寸点数） 的值。 物理宽度，以英寸为单位的单位是图像的像素宽度除以的水平分辨率。 例如，使用像素宽度为 216 和 72 点 / 英寸的水平分辨率的图像具有物理 3 英寸的宽度。 说明同样适用于像素高度和物理的高度。  
  
 <xref:System.Drawing.Graphics.DrawImageUnscaled%2A>方法绘制一个图像使用的物理大小，因此该图像将出现正确的大小，以英寸为单位，而不考虑显示设备的分辨率 （每英寸点数）。 例如，假设图像具有像素宽度为 216 和 72 点 / 英寸的水平分辨率。 如果调用<xref:System.Drawing.Graphics.DrawImageUnscaled%2A>绘制该图像的分辨率为 96 点 / 英寸的设备上，呈现的图像的像素宽度将是 (216/72) * 96 = 288 条。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="image" /> 为 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="DrawImageUnscaledAndClipped">
      <MemberSignature Language="C#" Value="public void DrawImageUnscaledAndClipped (System.Drawing.Image image, System.Drawing.Rectangle rect);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawImageUnscaledAndClipped(class System.Drawing.Image image, valuetype System.Drawing.Rectangle rect) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawImageUnscaledAndClipped(System.Drawing.Image,System.Drawing.Rectangle)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawImageUnscaledAndClipped(System::Drawing::Image ^ image, System::Drawing::Rectangle rect);" />
      <MemberSignature Language="F#" Value="member this.DrawImageUnscaledAndClipped : System.Drawing.Image * System.Drawing.Rectangle -&gt; unit" Usage="graphics.DrawImageUnscaledAndClipped (image, rect)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="image" Type="System.Drawing.Image" />
        <Parameter Name="rect" Type="System.Drawing.Rectangle" />
      </Parameters>
      <Docs>
        <param name="image">要绘制的 <see cref="T:System.Drawing.Image" />。</param>
        <param name="rect">要在其中绘制图像的 <see cref="T:System.Drawing.Rectangle" />。</param>
        <summary>在不进行缩放的情况下绘制指定的图像，并在需要时剪辑该图像以适合指定的矩形。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下面的示例演示如何使用 <xref:System.Drawing.Graphics.DrawImageUnscaledAndClipped%2A> 方法。 若要运行此示例中，将其粘贴到 Windows 窗体。 处理该窗体<xref:System.Windows.Forms.Control.Paint>事件，并调用`DrawImageUnscaled`方法从<xref:System.Windows.Forms.Control.Paint>事件处理方法，传递`e`作为<xref:System.Windows.Forms.PaintEventArgs>。  
  
 [!code-csharp[System.Drawing.MiscWhidbeySnippets#8](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.MiscWhidbeySnippets/CS/Form1.cs#8)]
 [!code-vb[System.Drawing.MiscWhidbeySnippets#8](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.MiscWhidbeySnippets/VB/Form1.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="image" /> 为 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="DrawLine">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>绘制一条连接由坐标对指定的两个点的线条。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DrawLine">
      <MemberSignature Language="C#" Value="public void DrawLine (System.Drawing.Pen pen, System.Drawing.Point pt1, System.Drawing.Point pt2);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawLine(class System.Drawing.Pen pen, valuetype System.Drawing.Point pt1, valuetype System.Drawing.Point pt2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawLine(System.Drawing.Pen,System.Drawing.Point,System.Drawing.Point)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawLine(System::Drawing::Pen ^ pen, System::Drawing::Point pt1, System::Drawing::Point pt2);" />
      <MemberSignature Language="F#" Value="member this.DrawLine : System.Drawing.Pen * System.Drawing.Point * System.Drawing.Point -&gt; unit" Usage="graphics.DrawLine (pen, pt1, pt2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pen" Type="System.Drawing.Pen" />
        <Parameter Name="pt1" Type="System.Drawing.Point" />
        <Parameter Name="pt2" Type="System.Drawing.Point" />
      </Parameters>
      <Docs>
        <param name="pen">
          <see cref="T:System.Drawing.Pen" />，它确定线条的颜色、宽度和样式。</param>
        <param name="pt1">
          <see cref="T:System.Drawing.Point" /> 结构，它表示要连接的第一个点。</param>
        <param name="pt2">
          <see cref="T:System.Drawing.Point" /> 结构，它表示要连接的第二个点。</param>
        <summary>绘制一条连接两个 <see cref="T:System.Drawing.Point" /> 结构的线。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下面的代码示例设计为使用 Windows 窗体，并且它需要<xref:System.Windows.Forms.PaintEventArgs> `e`，这是一个参数的<xref:System.Windows.Forms.Control.Paint>事件处理程序。 该代码执行下列操作：  
  
-   创建黑色的笔。  
  
-   创建线条的点的终结点。  
  
-   在屏幕上绘制线条。  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples2#66](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CPP/form1.cpp#66)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples2#66](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CS/form1.cs#66)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples2#66](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/VB/form1.vb#66)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="pen" /> 为 <see langword="null" />。</exception>
        <related type="Article" href="~/docs/framework/winforms/advanced/using-a-pen-to-draw-lines-and-shapes.md">使用钢笔绘制线条和形状</related>
      </Docs>
    </Member>
    <Member MemberName="DrawLine">
      <MemberSignature Language="C#" Value="public void DrawLine (System.Drawing.Pen pen, System.Drawing.PointF pt1, System.Drawing.PointF pt2);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawLine(class System.Drawing.Pen pen, valuetype System.Drawing.PointF pt1, valuetype System.Drawing.PointF pt2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawLine(System.Drawing.Pen,System.Drawing.PointF,System.Drawing.PointF)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawLine(System::Drawing::Pen ^ pen, System::Drawing::PointF pt1, System::Drawing::PointF pt2);" />
      <MemberSignature Language="F#" Value="member this.DrawLine : System.Drawing.Pen * System.Drawing.PointF * System.Drawing.PointF -&gt; unit" Usage="graphics.DrawLine (pen, pt1, pt2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pen" Type="System.Drawing.Pen" />
        <Parameter Name="pt1" Type="System.Drawing.PointF" />
        <Parameter Name="pt2" Type="System.Drawing.PointF" />
      </Parameters>
      <Docs>
        <param name="pen">
          <see cref="T:System.Drawing.Pen" />，它确定线条的颜色、宽度和样式。</param>
        <param name="pt1">
          <see cref="T:System.Drawing.PointF" /> 结构，它表示要连接的第一个点。</param>
        <param name="pt2">
          <see cref="T:System.Drawing.PointF" /> 结构，它表示要连接的第二个点。</param>
        <summary>绘制一条连接两个 <see cref="T:System.Drawing.PointF" /> 结构的线。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法绘制一条连接由指定的两个点`pt1`和 p`2`参数。  
  
   
  
## Examples  
 下面的代码示例设计为使用 Windows 窗体，并且它需要<xref:System.Windows.Forms.PaintEventArgs> `e`，这是一个参数的<xref:System.Windows.Forms.Control.Paint>事件处理程序。 该代码执行下列操作：  
  
-   创建黑色的笔。  
  
-   创建线条的点的终结点。  
  
-   在屏幕上绘制线条。  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples2#67](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CPP/form1.cpp#67)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples2#67](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CS/form1.cs#67)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples2#67](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/VB/form1.vb#67)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="pen" /> 为 <see langword="null" />。</exception>
        <related type="Article" href="~/docs/framework/winforms/advanced/using-a-pen-to-draw-lines-and-shapes.md">使用钢笔绘制线条和形状</related>
      </Docs>
    </Member>
    <Member MemberName="DrawLine">
      <MemberSignature Language="C#" Value="public void DrawLine (System.Drawing.Pen pen, int x1, int y1, int x2, int y2);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawLine(class System.Drawing.Pen pen, int32 x1, int32 y1, int32 x2, int32 y2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawLine(System.Drawing.Pen,System.Int32,System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawLine(System::Drawing::Pen ^ pen, int x1, int y1, int x2, int y2);" />
      <MemberSignature Language="F#" Value="member this.DrawLine : System.Drawing.Pen * int * int * int * int -&gt; unit" Usage="graphics.DrawLine (pen, x1, y1, x2, y2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pen" Type="System.Drawing.Pen" />
        <Parameter Name="x1" Type="System.Int32" />
        <Parameter Name="y1" Type="System.Int32" />
        <Parameter Name="x2" Type="System.Int32" />
        <Parameter Name="y2" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="pen">
          <see cref="T:System.Drawing.Pen" />，它确定线条的颜色、宽度和样式。</param>
        <param name="x1">第一个点的 x 坐标。</param>
        <param name="y1">第一个点的 y 坐标。</param>
        <param name="x2">第二个点的 x 坐标。</param>
        <param name="y2">第二个点的 y 坐标。</param>
        <summary>绘制一条连接由坐标对指定的两个点的线条。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法绘制一条连接由指定的两个点`x1`， `y1`， `x2`，和`y2`参数。  
  
   
  
## Examples  
 下面的代码示例设计为使用 Windows 窗体，并且它需要<xref:System.Windows.Forms.PaintEventArgs> `e`，这是一个参数的<xref:System.Windows.Forms.Control.Paint>事件处理程序。 该代码执行下列操作：  
  
-   创建黑色的笔。  
  
-   创建线终结点的坐标。  
  
-   在屏幕上绘制线条。  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples2#68](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CPP/form1.cpp#68)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples2#68](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CS/form1.cs#68)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples2#68](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/VB/form1.vb#68)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="pen" /> 为 <see langword="null" />。</exception>
        <related type="Article" href="~/docs/framework/winforms/advanced/using-a-pen-to-draw-lines-and-shapes.md">使用钢笔绘制线条和形状</related>
      </Docs>
    </Member>
    <Member MemberName="DrawLine">
      <MemberSignature Language="C#" Value="public void DrawLine (System.Drawing.Pen pen, float x1, float y1, float x2, float y2);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawLine(class System.Drawing.Pen pen, float32 x1, float32 y1, float32 x2, float32 y2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawLine(System.Drawing.Pen,System.Single,System.Single,System.Single,System.Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawLine(System::Drawing::Pen ^ pen, float x1, float y1, float x2, float y2);" />
      <MemberSignature Language="F#" Value="member this.DrawLine : System.Drawing.Pen * single * single * single * single -&gt; unit" Usage="graphics.DrawLine (pen, x1, y1, x2, y2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pen" Type="System.Drawing.Pen" />
        <Parameter Name="x1" Type="System.Single" />
        <Parameter Name="y1" Type="System.Single" />
        <Parameter Name="x2" Type="System.Single" />
        <Parameter Name="y2" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="pen">
          <see cref="T:System.Drawing.Pen" />，它确定线条的颜色、宽度和样式。</param>
        <param name="x1">第一个点的 x 坐标。</param>
        <param name="y1">第一个点的 y 坐标。</param>
        <param name="x2">第二个点的 x 坐标。</param>
        <param name="y2">第二个点的 y 坐标。</param>
        <summary>绘制一条连接由坐标对指定的两个点的线条。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法绘制一条连接由指定的两个点`x1`， `y1`， `x2`，和`y2`参数。  
  
   
  
## Examples  
 下面的代码示例设计为使用 Windows 窗体，并且它需要<xref:System.Windows.Forms.PaintEventArgs> `e`，这是一个参数的<xref:System.Windows.Forms.Control.Paint>事件处理程序。 该代码执行下列操作：  
  
-   创建黑色的笔。  
  
-   创建线终结点的坐标。  
  
-   在屏幕上绘制线条。  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples2#69](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CPP/form1.cpp#69)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples2#69](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CS/form1.cs#69)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples2#69](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/VB/form1.vb#69)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="pen" /> 为 <see langword="null" />。</exception>
        <related type="Article" href="~/docs/framework/winforms/advanced/using-a-pen-to-draw-lines-and-shapes.md">使用钢笔绘制线条和形状</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="DrawLines">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>绘制一系列连接一组 <see cref="T:System.Drawing.Point" /> 结构的线段。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DrawLines">
      <MemberSignature Language="C#" Value="public void DrawLines (System.Drawing.Pen pen, System.Drawing.Point[] points);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawLines(class System.Drawing.Pen pen, valuetype System.Drawing.Point[] points) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawLines(System.Drawing.Pen,System.Drawing.Point[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawLines(System::Drawing::Pen ^ pen, cli::array &lt;System::Drawing::Point&gt; ^ points);" />
      <MemberSignature Language="F#" Value="member this.DrawLines : System.Drawing.Pen * System.Drawing.Point[] -&gt; unit" Usage="graphics.DrawLines (pen, points)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pen" Type="System.Drawing.Pen" />
        <Parameter Name="points" Type="System.Drawing.Point[]" />
      </Parameters>
      <Docs>
        <param name="pen">
          <see cref="T:System.Drawing.Pen" />，它确定线段的颜色、宽度和样式。</param>
        <param name="points">
          <see cref="T:System.Drawing.Point" /> 结构数组，这些结构表示要连接的点。</param>
        <summary>绘制一系列连接一组 <see cref="T:System.Drawing.Point" /> 结构的线段。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法绘制一系列连接一组终结点的行。 数组中的前两个点指定的第一个行。 每个其他点指定一条线段的起始点是前一条线段的终点的末尾。  
  
   
  
## Examples  
 下面的代码示例设计为使用 Windows 窗体，并且它需要<xref:System.Windows.Forms.PaintEventArgs> `e`，这是一个参数的<xref:System.Windows.Forms.Control.Paint>事件处理程序。 该代码执行下列操作：  
  
-   创建黑色的笔。  
  
-   创建一个段的线条的点的数组。  
  
-   在屏幕上绘制的已连接的直线线段。  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples2#70](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CPP/form1.cpp#70)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples2#70](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CS/form1.cs#70)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples2#70](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/VB/form1.vb#70)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="pen" /> 为 <see langword="null" />。  
  
或 
 <paramref name="points" /> 为 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="DrawLines">
      <MemberSignature Language="C#" Value="public void DrawLines (System.Drawing.Pen pen, System.Drawing.PointF[] points);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawLines(class System.Drawing.Pen pen, valuetype System.Drawing.PointF[] points) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawLines(System.Drawing.Pen,System.Drawing.PointF[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawLines(System::Drawing::Pen ^ pen, cli::array &lt;System::Drawing::PointF&gt; ^ points);" />
      <MemberSignature Language="F#" Value="member this.DrawLines : System.Drawing.Pen * System.Drawing.PointF[] -&gt; unit" Usage="graphics.DrawLines (pen, points)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pen" Type="System.Drawing.Pen" />
        <Parameter Name="points" Type="System.Drawing.PointF[]" />
      </Parameters>
      <Docs>
        <param name="pen">
          <see cref="T:System.Drawing.Pen" />，它确定线段的颜色、宽度和样式。</param>
        <param name="points">
          <see cref="T:System.Drawing.PointF" /> 结构数组，这些结构表示要连接的点。</param>
        <summary>绘制一系列连接一组 <see cref="T:System.Drawing.PointF" /> 结构的线段。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法绘制一系列连接一组终结点的行。 数组中的前两个点指定的第一个行。 每个其他点指定一条线段的起始点是前一条线段的终点的末尾。  
  
   
  
## Examples  
 下面的代码示例设计为使用 Windows 窗体，并且它需要<xref:System.Windows.Forms.PaintEventArgs> `e`，这是一个参数的<xref:System.Windows.Forms.Control.Paint>事件处理程序。 该代码执行下列操作：  
  
-   代码将创建黑色的笔。  
  
-   创建一个段的线条的点的数组。  
  
-   在屏幕上绘制的已连接的直线线段。  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples2#71](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CPP/form1.cpp#71)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples2#71](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CS/form1.cs#71)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples2#71](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/VB/form1.vb#71)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="pen" /> 为 <see langword="null" />。  
  
或 
 <paramref name="points" /> 为 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="DrawPath">
      <MemberSignature Language="C#" Value="public void DrawPath (System.Drawing.Pen pen, System.Drawing.Drawing2D.GraphicsPath path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawPath(class System.Drawing.Pen pen, class System.Drawing.Drawing2D.GraphicsPath path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawPath(System.Drawing.Pen,System.Drawing.Drawing2D.GraphicsPath)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawPath(System::Drawing::Pen ^ pen, System::Drawing::Drawing2D::GraphicsPath ^ path);" />
      <MemberSignature Language="F#" Value="member this.DrawPath : System.Drawing.Pen * System.Drawing.Drawing2D.GraphicsPath -&gt; unit" Usage="graphics.DrawPath (pen, path)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pen" Type="System.Drawing.Pen" />
        <Parameter Name="path" Type="System.Drawing.Drawing2D.GraphicsPath" />
      </Parameters>
      <Docs>
        <param name="pen">
          <see cref="T:System.Drawing.Pen" />，它确定路径的颜色、宽度和样式。</param>
        <param name="path">要绘制的 <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />。</param>
        <summary>绘制 <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 将图形上下文中的当前转换应用于<xref:System.Drawing.Drawing2D.GraphicsPath>绘制之前。  
  
   
  
## Examples  
 下面的代码示例设计为使用 Windows 窗体，并且它需要<xref:System.Windows.Forms.PaintEventArgs> `e`，这是一个参数的<xref:System.Windows.Forms.Control.Paint>事件处理程序。 该代码执行下列操作：  
  
-   创建图形路径对象，并向它添加一个椭圆。  
  
-   创建黑色的笔。  
  
-   在屏幕上绘制的图形路径。  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples2#72](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CPP/form1.cpp#72)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples2#72](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CS/form1.cs#72)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples2#72](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/VB/form1.vb#72)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="pen" /> 为 <see langword="null" />。  
  
或 
 <paramref name="path" /> 为 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="DrawPie">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>绘制一个扇形，该形状由一个坐标对、宽度、高度以及两条射线所指定的椭圆定义。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DrawPie">
      <MemberSignature Language="C#" Value="public void DrawPie (System.Drawing.Pen pen, System.Drawing.Rectangle rect, float startAngle, float sweepAngle);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawPie(class System.Drawing.Pen pen, valuetype System.Drawing.Rectangle rect, float32 startAngle, float32 sweepAngle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawPie(System.Drawing.Pen,System.Drawing.Rectangle,System.Single,System.Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawPie(System::Drawing::Pen ^ pen, System::Drawing::Rectangle rect, float startAngle, float sweepAngle);" />
      <MemberSignature Language="F#" Value="member this.DrawPie : System.Drawing.Pen * System.Drawing.Rectangle * single * single -&gt; unit" Usage="graphics.DrawPie (pen, rect, startAngle, sweepAngle)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pen" Type="System.Drawing.Pen" />
        <Parameter Name="rect" Type="System.Drawing.Rectangle" />
        <Parameter Name="startAngle" Type="System.Single" />
        <Parameter Name="sweepAngle" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="pen">
          <see cref="T:System.Drawing.Pen" />，它确定扇形的颜色、宽度和样式。</param>
        <param name="rect">
          <see cref="T:System.Drawing.Rectangle" /> 结构，它表示定义该扇形所属的椭圆的边框。</param>
        <param name="startAngle">从 x 轴到扇形的第一条边沿顺时针方向度量的角（以度为单位）。</param>
        <param name="sweepAngle">从 <c>startAngle</c> 参数到扇形的第二条边沿顺时针方向度量的角（以度为单位）。</param>
        <summary>绘制由一个 <see cref="T:System.Drawing.Rectangle" /> 结构和两条射线所指定的椭圆定义的扇形。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法绘制一个椭圆和两条射线相交的一段弧线，弧的终结点与所定义的扇形。该椭圆的边框的定义。 饼图形状包含定义的两条射线`startAngle`和`sweepAngle`参数和之间交集的射线与椭圆弧。  
  
 如果`sweepAngle`参数为大于 360 度或小于-360 度时，它被视为，就好像 360 度或-360 度，分别。  
  
   
  
## Examples  
 下面的代码示例设计为使用 Windows 窗体，并且它需要<xref:System.Windows.Forms.PaintEventArgs> `e`，这是一个参数的<xref:System.Windows.Forms.Control.Paint>事件处理程序。 该代码执行下列操作：  
  
-   创建黑色的笔。  
  
-   创建限定整个椭圆的矩形。  
  
-   定义在开始绘制 （相对于 x 轴） 的角度和用来绘制 （同时处于顺时针方向）。  
  
-   在屏幕上绘制饼图段。  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples2#73](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CPP/form1.cpp#73)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples2#73](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CS/form1.cs#73)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples2#73](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/VB/form1.vb#73)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="pen" /> 为 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="DrawPie">
      <MemberSignature Language="C#" Value="public void DrawPie (System.Drawing.Pen pen, System.Drawing.RectangleF rect, float startAngle, float sweepAngle);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawPie(class System.Drawing.Pen pen, valuetype System.Drawing.RectangleF rect, float32 startAngle, float32 sweepAngle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawPie(System.Drawing.Pen,System.Drawing.RectangleF,System.Single,System.Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawPie(System::Drawing::Pen ^ pen, System::Drawing::RectangleF rect, float startAngle, float sweepAngle);" />
      <MemberSignature Language="F#" Value="member this.DrawPie : System.Drawing.Pen * System.Drawing.RectangleF * single * single -&gt; unit" Usage="graphics.DrawPie (pen, rect, startAngle, sweepAngle)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pen" Type="System.Drawing.Pen" />
        <Parameter Name="rect" Type="System.Drawing.RectangleF" />
        <Parameter Name="startAngle" Type="System.Single" />
        <Parameter Name="sweepAngle" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="pen">
          <see cref="T:System.Drawing.Pen" />，它确定扇形的颜色、宽度和样式。</param>
        <param name="rect">
          <see cref="T:System.Drawing.RectangleF" /> 结构，它表示定义该扇形所属的椭圆的边框。</param>
        <param name="startAngle">从 x 轴到扇形的第一条边沿顺时针方向度量的角（以度为单位）。</param>
        <param name="sweepAngle">从 <c>startAngle</c> 参数到扇形的第二条边沿顺时针方向度量的角（以度为单位）。</param>
        <summary>绘制由一个 <see cref="T:System.Drawing.RectangleF" /> 结构和两条射线所指定的椭圆定义的扇形。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法绘制一个椭圆和两条射线相交的一段弧线，弧的终结点与所定义的扇形。该椭圆的边框的定义。 饼图形状包含定义的两条射线`startAngle`和`sweepAngle`参数和之间交集的射线与椭圆弧。  
  
 如果`sweepAngle`参数为大于 360 度或小于-360 度时，它被视为，就好像 360 度或-360 度，分别。  
  
   
  
## Examples  
 下面的代码示例设计为使用 Windows 窗体，并且它需要<xref:System.Windows.Forms.PaintEventArgs> `e`，这是一个参数的<xref:System.Windows.Forms.Control.Paint>事件处理程序。 该代码执行下列操作：  
  
-   创建黑色的笔。  
  
-   创建限定整个椭圆的矩形。  
  
-   定义在开始绘制 （相对于 x 轴） 的角度和用来绘制 （同时处于顺时针方向）。  
  
-   在屏幕上绘制饼图段。  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples2#74](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CPP/form1.cpp#74)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples2#74](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CS/form1.cs#74)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples2#74](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/VB/form1.vb#74)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="pen" /> 为 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="DrawPie">
      <MemberSignature Language="C#" Value="public void DrawPie (System.Drawing.Pen pen, int x, int y, int width, int height, int startAngle, int sweepAngle);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawPie(class System.Drawing.Pen pen, int32 x, int32 y, int32 width, int32 height, int32 startAngle, int32 sweepAngle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawPie(System.Drawing.Pen,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawPie(System::Drawing::Pen ^ pen, int x, int y, int width, int height, int startAngle, int sweepAngle);" />
      <MemberSignature Language="F#" Value="member this.DrawPie : System.Drawing.Pen * int * int * int * int * int * int -&gt; unit" Usage="graphics.DrawPie (pen, x, y, width, height, startAngle, sweepAngle)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pen" Type="System.Drawing.Pen" />
        <Parameter Name="x" Type="System.Int32" />
        <Parameter Name="y" Type="System.Int32" />
        <Parameter Name="width" Type="System.Int32" />
        <Parameter Name="height" Type="System.Int32" />
        <Parameter Name="startAngle" Type="System.Int32" />
        <Parameter Name="sweepAngle" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="pen">
          <see cref="T:System.Drawing.Pen" />，它确定扇形的颜色、宽度和样式。</param>
        <param name="x">边框的左上角的 x 坐标，该边框定义扇形所属的椭圆。</param>
        <param name="y">边框的左上角的 y 坐标，该边框定义扇形所属的椭圆。</param>
        <param name="width">边框的宽度，该边框定义扇形所属的椭圆。</param>
        <param name="height">边框的高度，该边框定义扇形所属的椭圆。</param>
        <param name="startAngle">从 x 轴到扇形的第一条边沿顺时针方向度量的角（以度为单位）。</param>
        <param name="sweepAngle">从 <c>startAngle</c> 参数到扇形的第二条边沿顺时针方向度量的角（以度为单位）。</param>
        <summary>绘制一个扇形，该形状由一个坐标对、宽度、高度以及两条射线所指定的椭圆定义。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法绘制一个椭圆和两条射线相交的一段弧线，弧的终结点与所定义的扇形。该椭圆定义由所描述的边框`x`， `y`， `width`，和`height`参数。 饼图形状包含定义的两条射线`startAngle`和`sweepAngle`参数和之间交集的射线与椭圆弧。  
  
 如果`sweepAngle`参数为大于 360 度或小于-360 度时，它被视为，就好像 360 度或-360 度，分别。  
  
   
  
## Examples  
 下面的代码示例设计为使用 Windows 窗体，并且它需要<xref:System.Windows.Forms.PaintEventArgs> `e`，这是一个参数的<xref:System.Windows.Forms.Control.Paint>事件处理程序。 该代码执行下列操作：  
  
-   创建黑色的笔。  
  
-   创建的位置和限定整个椭圆的矩形的大小。  
  
-   定义在开始绘制 （相对于 x 轴） 的角度和用来绘制 （同时处于顺时针方向）。  
  
-   在屏幕上绘制扇形。  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples2#75](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CPP/form1.cpp#75)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples2#75](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CS/form1.cs#75)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples2#75](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/VB/form1.vb#75)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="pen" /> 为 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="DrawPie">
      <MemberSignature Language="C#" Value="public void DrawPie (System.Drawing.Pen pen, float x, float y, float width, float height, float startAngle, float sweepAngle);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawPie(class System.Drawing.Pen pen, float32 x, float32 y, float32 width, float32 height, float32 startAngle, float32 sweepAngle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawPie(System.Drawing.Pen,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawPie(System::Drawing::Pen ^ pen, float x, float y, float width, float height, float startAngle, float sweepAngle);" />
      <MemberSignature Language="F#" Value="member this.DrawPie : System.Drawing.Pen * single * single * single * single * single * single -&gt; unit" Usage="graphics.DrawPie (pen, x, y, width, height, startAngle, sweepAngle)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pen" Type="System.Drawing.Pen" />
        <Parameter Name="x" Type="System.Single" />
        <Parameter Name="y" Type="System.Single" />
        <Parameter Name="width" Type="System.Single" />
        <Parameter Name="height" Type="System.Single" />
        <Parameter Name="startAngle" Type="System.Single" />
        <Parameter Name="sweepAngle" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="pen">
          <see cref="T:System.Drawing.Pen" />，它确定扇形的颜色、宽度和样式。</param>
        <param name="x">边框的左上角的 x 坐标，该边框定义扇形所属的椭圆。</param>
        <param name="y">边框的左上角的 y 坐标，该边框定义扇形所属的椭圆。</param>
        <param name="width">边框的宽度，该边框定义扇形所属的椭圆。</param>
        <param name="height">边框的高度，该边框定义扇形所属的椭圆。</param>
        <param name="startAngle">从 x 轴到扇形的第一条边沿顺时针方向度量的角（以度为单位）。</param>
        <param name="sweepAngle">从 <c>startAngle</c> 参数到扇形的第二条边沿顺时针方向度量的角（以度为单位）。</param>
        <summary>绘制一个扇形，该形状由一个坐标对、宽度、高度以及两条射线所指定的椭圆定义。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法绘制一个椭圆和两条射线相交的一段弧线，弧的终结点与所定义的扇形。该椭圆定义由所描述的边框`x`， `y`， `width`，和`height`参数。 饼图形状包含定义的两条射线`startAngle`和`sweepAngle`参数和之间交集的射线与椭圆弧。  
  
 如果`sweepAngle`参数为大于 360 度或小于-360 度时，它被视为，就好像 360 度或-360 度，分别。  
  
   
  
## Examples  
 下面的代码示例设计为使用 Windows 窗体，并且它需要<xref:System.Windows.Forms.PaintEventArgs> `e`，这是一个参数的<xref:System.Windows.Forms.Control.Paint>事件处理程序。 该代码执行下列操作：  
  
-   创建黑色的笔。  
  
-   创建的位置和限定整个椭圆的矩形的大小。  
  
-   定义在开始绘制 （相对于 x 轴） 的角度和用来绘制 （同时处于顺时针方向）。  
  
-   在屏幕上绘制饼图段。  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples2#76](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CPP/form1.cpp#76)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples2#76](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CS/form1.cs#76)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples2#76](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/VB/form1.vb#76)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="pen" /> 为 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="DrawPolygon">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>绘制由一组 <see cref="T:System.Drawing.Point" /> 结构定义的多边形。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DrawPolygon">
      <MemberSignature Language="C#" Value="public void DrawPolygon (System.Drawing.Pen pen, System.Drawing.Point[] points);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawPolygon(class System.Drawing.Pen pen, valuetype System.Drawing.Point[] points) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawPolygon(System.Drawing.Pen,System.Drawing.Point[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawPolygon(System::Drawing::Pen ^ pen, cli::array &lt;System::Drawing::Point&gt; ^ points);" />
      <MemberSignature Language="F#" Value="member this.DrawPolygon : System.Drawing.Pen * System.Drawing.Point[] -&gt; unit" Usage="graphics.DrawPolygon (pen, points)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pen" Type="System.Drawing.Pen" />
        <Parameter Name="points" Type="System.Drawing.Point[]" />
      </Parameters>
      <Docs>
        <param name="pen">
          <see cref="T:System.Drawing.Pen" />，它确定多边形的颜色、宽度和样式。</param>
        <param name="points">
          <see cref="T:System.Drawing.Point" /> 结构数组，这些结构表示多边形的顶点。</param>
        <summary>绘制由一组 <see cref="T:System.Drawing.Point" /> 结构定义的多边形。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 数组中的两个连续点的每对指定多边形的边。 此外，如果最后一个点和数组的第一个点不同时发生，它们指定多边形的最后一条边。  
  
   
  
## Examples  
 下面的代码示例设计为使用 Windows 窗体，并且它需要<xref:System.Windows.Forms.PaintEventArgs> `e`，这是一个参数的<xref:System.Windows.Forms.Control.Paint>事件处理程序。 该代码执行下列操作：  
  
-   创建黑色的笔。  
  
-   创建一个数组的七个点的多边形的顶点。  
  
-   在屏幕上绘制多边形。  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples2#78](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CPP/form1.cpp#78)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples2#78](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CS/form1.cs#78)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples2#78](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/VB/form1.vb#78)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="pen" /> 为 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="DrawPolygon">
      <MemberSignature Language="C#" Value="public void DrawPolygon (System.Drawing.Pen pen, System.Drawing.PointF[] points);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawPolygon(class System.Drawing.Pen pen, valuetype System.Drawing.PointF[] points) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawPolygon(System.Drawing.Pen,System.Drawing.PointF[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawPolygon(System::Drawing::Pen ^ pen, cli::array &lt;System::Drawing::PointF&gt; ^ points);" />
      <MemberSignature Language="F#" Value="member this.DrawPolygon : System.Drawing.Pen * System.Drawing.PointF[] -&gt; unit" Usage="graphics.DrawPolygon (pen, points)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pen" Type="System.Drawing.Pen" />
        <Parameter Name="points" Type="System.Drawing.PointF[]" />
      </Parameters>
      <Docs>
        <param name="pen">
          <see cref="T:System.Drawing.Pen" />，它确定多边形的颜色、宽度和样式。</param>
        <param name="points">
          <see cref="T:System.Drawing.PointF" /> 结构数组，这些结构表示多边形的顶点。</param>
        <summary>绘制由一组 <see cref="T:System.Drawing.PointF" /> 结构定义的多边形。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 数组中的两个连续点的每对指定多边形的边。 此外，如果最后一个点和数组点的第一个时间不一致，它们指定多边形的最后一条边。  
  
   
  
## Examples  
 下面的代码示例设计为使用 Windows 窗体，并且它需要<xref:System.Windows.Forms.PaintEventArgs> `e`，这是一个参数的<xref:System.Windows.Forms.Control.Paint>事件处理程序。 该代码执行下列操作：  
  
-   创建黑色的笔。  
  
-   创建一个数组的七个点的多边形的顶点。  
  
-   在屏幕上绘制多边形。  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples2#77](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CPP/form1.cpp#77)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples2#77](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CS/form1.cs#77)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples2#77](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/VB/form1.vb#77)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="pen" /> 为 <see langword="null" />。  
  
或 
 <paramref name="points" /> 为 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="DrawRectangle">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>绘制由坐标对、宽度和高度指定的矩形。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DrawRectangle">
      <MemberSignature Language="C#" Value="public void DrawRectangle (System.Drawing.Pen pen, System.Drawing.Rectangle rect);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawRectangle(class System.Drawing.Pen pen, valuetype System.Drawing.Rectangle rect) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawRectangle(System.Drawing.Pen,System.Drawing.Rectangle)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawRectangle(System::Drawing::Pen ^ pen, System::Drawing::Rectangle rect);" />
      <MemberSignature Language="F#" Value="member this.DrawRectangle : System.Drawing.Pen * System.Drawing.Rectangle -&gt; unit" Usage="graphics.DrawRectangle (pen, rect)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pen" Type="System.Drawing.Pen" />
        <Parameter Name="rect" Type="System.Drawing.Rectangle" />
      </Parameters>
      <Docs>
        <param name="pen">
          <see cref="T:System.Drawing.Pen" />，它确定矩形的颜色、宽度和样式。</param>
        <param name="rect">表示要绘制的矩形的 <see cref="T:System.Drawing.Rectangle" /> 结构。</param>
        <summary>绘制由 <see cref="T:System.Drawing.Rectangle" /> 结构指定的矩形。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 有关如何绘制<xref:System.Drawing.RectangleF>，请参阅<xref:System.Drawing.Graphics.DrawRectangles%28System.Drawing.Pen%2CSystem.Drawing.RectangleF%5B%5D%29>。  
  
   
  
## Examples  
 下面的代码示例设计为使用 Windows 窗体，并且它需要<xref:System.Windows.Forms.PaintEventArgs> `e`，这是一个参数的<xref:System.Windows.Forms.Control.Paint>事件处理程序。 该代码执行下列操作：  
  
-   创建黑色的笔。  
  
-   创建一个矩形。  
  
-   在屏幕上绘制的矩形。  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples2#79](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CPP/form1.cpp#79)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples2#79](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CS/form1.cs#79)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples2#79](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/VB/form1.vb#79)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="pen" /> 为 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="DrawRectangle">
      <MemberSignature Language="C#" Value="public void DrawRectangle (System.Drawing.Pen pen, int x, int y, int width, int height);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawRectangle(class System.Drawing.Pen pen, int32 x, int32 y, int32 width, int32 height) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawRectangle(System.Drawing.Pen,System.Int32,System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawRectangle(System::Drawing::Pen ^ pen, int x, int y, int width, int height);" />
      <MemberSignature Language="F#" Value="member this.DrawRectangle : System.Drawing.Pen * int * int * int * int -&gt; unit" Usage="graphics.DrawRectangle (pen, x, y, width, height)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pen" Type="System.Drawing.Pen" />
        <Parameter Name="x" Type="System.Int32" />
        <Parameter Name="y" Type="System.Int32" />
        <Parameter Name="width" Type="System.Int32" />
        <Parameter Name="height" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="pen">
          <see cref="T:System.Drawing.Pen" />，它确定矩形的颜色、宽度和样式。</param>
        <param name="x">要绘制的矩形的左上角的 x 坐标。</param>
        <param name="y">要绘制的矩形的左上角的 y 坐标。</param>
        <param name="width">要绘制的矩形的宽度。</param>
        <param name="height">要绘制的矩形的高度。</param>
        <summary>绘制由坐标对、宽度和高度指定的矩形。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 有关如何绘制<xref:System.Drawing.RectangleF>，请参阅<xref:System.Drawing.Graphics.DrawRectangles%28System.Drawing.Pen%2CSystem.Drawing.RectangleF%5B%5D%29>。  
  
   
  
## Examples  
 下面的代码示例设计为使用 Windows 窗体，并且它需要<xref:System.Windows.Forms.PaintEventArgs> `e`，这是一个参数的<xref:System.Windows.Forms.Control.Paint>事件处理程序。 该代码执行下列操作：  
  
-   创建黑色的笔。  
  
-   创建的位置和大小的矩形。  
  
-   在屏幕上绘制的矩形。  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples2#80](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CPP/form1.cpp#80)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples2#80](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CS/form1.cs#80)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples2#80](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/VB/form1.vb#80)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="pen" /> 为 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="DrawRectangle">
      <MemberSignature Language="C#" Value="public void DrawRectangle (System.Drawing.Pen pen, float x, float y, float width, float height);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawRectangle(class System.Drawing.Pen pen, float32 x, float32 y, float32 width, float32 height) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawRectangle(System.Drawing.Pen,System.Single,System.Single,System.Single,System.Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawRectangle(System::Drawing::Pen ^ pen, float x, float y, float width, float height);" />
      <MemberSignature Language="F#" Value="member this.DrawRectangle : System.Drawing.Pen * single * single * single * single -&gt; unit" Usage="graphics.DrawRectangle (pen, x, y, width, height)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pen" Type="System.Drawing.Pen" />
        <Parameter Name="x" Type="System.Single" />
        <Parameter Name="y" Type="System.Single" />
        <Parameter Name="width" Type="System.Single" />
        <Parameter Name="height" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="pen">
          <see cref="T:System.Drawing.Pen" />，它确定矩形的颜色、宽度和样式。</param>
        <param name="x">要绘制的矩形的左上角的 x 坐标。</param>
        <param name="y">要绘制的矩形的左上角的 y 坐标。</param>
        <param name="width">要绘制的矩形的宽度。</param>
        <param name="height">要绘制的矩形的高度。</param>
        <summary>绘制由坐标对、宽度和高度指定的矩形。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 有关如何绘制<xref:System.Drawing.RectangleF>，请参阅<xref:System.Drawing.Graphics.DrawRectangles%28System.Drawing.Pen%2CSystem.Drawing.RectangleF%5B%5D%29>。  
  
   
  
## Examples  
 下面的代码示例设计为使用 Windows 窗体，并且它需要<xref:System.Windows.Forms.PaintEventArgs> `e`，这是一个参数的<xref:System.Windows.Forms.Control.Paint>事件处理程序。 该代码执行下列操作：  
  
-   创建黑色的笔。  
  
-   创建的位置和大小的矩形。  
  
-   在屏幕上绘制的矩形。  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples2#81](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CPP/form1.cpp#81)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples2#81](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CS/form1.cs#81)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples2#81](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/VB/form1.vb#81)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="pen" /> 为 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="DrawRectangles">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>绘制一系列由 <see cref="T:System.Drawing.Rectangle" /> 结构指定的矩形。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DrawRectangles">
      <MemberSignature Language="C#" Value="public void DrawRectangles (System.Drawing.Pen pen, System.Drawing.Rectangle[] rects);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawRectangles(class System.Drawing.Pen pen, valuetype System.Drawing.Rectangle[] rects) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawRectangles(System.Drawing.Pen,System.Drawing.Rectangle[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawRectangles(System::Drawing::Pen ^ pen, cli::array &lt;System::Drawing::Rectangle&gt; ^ rects);" />
      <MemberSignature Language="F#" Value="member this.DrawRectangles : System.Drawing.Pen * System.Drawing.Rectangle[] -&gt; unit" Usage="graphics.DrawRectangles (pen, rects)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pen" Type="System.Drawing.Pen" />
        <Parameter Name="rects" Type="System.Drawing.Rectangle[]" />
      </Parameters>
      <Docs>
        <param name="pen">
          <see cref="T:System.Drawing.Pen" />，它确定矩形轮廓线的颜色、宽度和样式。</param>
        <param name="rects">
          <see cref="T:System.Drawing.Rectangle" /> 结构数组，这些结构表示要绘制的矩形。</param>
        <summary>绘制一系列由 <see cref="T:System.Drawing.Rectangle" /> 结构指定的矩形。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下面的代码示例设计为使用 Windows 窗体，并且它需要<xref:System.Windows.Forms.PaintEventArgs> `e`，这是一个参数的<xref:System.Windows.Forms.Control.Paint>事件处理程序。 该代码执行下列操作：  
  
-   创建黑色的笔。  
  
-   创建三个矩形的数组。  
  
-   将矩形绘制到屏幕。  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples2#82](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CPP/form1.cpp#82)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples2#82](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CS/form1.cs#82)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples2#82](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/VB/form1.vb#82)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="pen" /> 为 <see langword="null" />。  
  
或 
 <paramref name="rects" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="rects" /> 是一个长度为零的数组。</exception>
      </Docs>
    </Member>
    <Member MemberName="DrawRectangles">
      <MemberSignature Language="C#" Value="public void DrawRectangles (System.Drawing.Pen pen, System.Drawing.RectangleF[] rects);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawRectangles(class System.Drawing.Pen pen, valuetype System.Drawing.RectangleF[] rects) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawRectangles(System.Drawing.Pen,System.Drawing.RectangleF[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawRectangles(System::Drawing::Pen ^ pen, cli::array &lt;System::Drawing::RectangleF&gt; ^ rects);" />
      <MemberSignature Language="F#" Value="member this.DrawRectangles : System.Drawing.Pen * System.Drawing.RectangleF[] -&gt; unit" Usage="graphics.DrawRectangles (pen, rects)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pen" Type="System.Drawing.Pen" />
        <Parameter Name="rects" Type="System.Drawing.RectangleF[]" />
      </Parameters>
      <Docs>
        <param name="pen">
          <see cref="T:System.Drawing.Pen" />，它确定矩形轮廓线的颜色、宽度和样式。</param>
        <param name="rects">
          <see cref="T:System.Drawing.RectangleF" /> 结构数组，这些结构表示要绘制的矩形。</param>
        <summary>绘制一系列由 <see cref="T:System.Drawing.RectangleF" /> 结构指定的矩形。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下面的代码示例设计为使用 Windows 窗体，并且它需要<xref:System.Windows.Forms.PaintEventArgs> `e`，这是一个参数的<xref:System.Windows.Forms.Control.Paint>事件处理程序。 该代码执行下列操作：  
  
-   创建黑色的笔。  
  
-   创建三个矩形的数组。  
  
-   将矩形绘制到屏幕。  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples2#83](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CPP/form1.cpp#83)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples2#83](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CS/form1.cs#83)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples2#83](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/VB/form1.vb#83)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="pen" /> 为 <see langword="null" />。  
  
或 
 <paramref name="rects" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="rects" /> 是一个长度为零的数组。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="DrawString">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>在指定位置并且用指定的 <see cref="T:System.Drawing.Brush" /> 和 <see cref="T:System.Drawing.Font" /> 对象绘制指定的文本字符串。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DrawString">
      <MemberSignature Language="C#" Value="public void DrawString (string s, System.Drawing.Font font, System.Drawing.Brush brush, System.Drawing.PointF point);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawString(string s, class System.Drawing.Font font, class System.Drawing.Brush brush, valuetype System.Drawing.PointF point) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawString(System.String,System.Drawing.Font,System.Drawing.Brush,System.Drawing.PointF)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawString(System::String ^ s, System::Drawing::Font ^ font, System::Drawing::Brush ^ brush, System::Drawing::PointF point);" />
      <MemberSignature Language="F#" Value="member this.DrawString : string * System.Drawing.Font * System.Drawing.Brush * System.Drawing.PointF -&gt; unit" Usage="graphics.DrawString (s, font, brush, point)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="font" Type="System.Drawing.Font" />
        <Parameter Name="brush" Type="System.Drawing.Brush" />
        <Parameter Name="point" Type="System.Drawing.PointF" />
      </Parameters>
      <Docs>
        <param name="s">要绘制的字符串。</param>
        <param name="font">
          <see cref="T:System.Drawing.Font" />，它定义字符串的文本格式。</param>
        <param name="brush">
          <see cref="T:System.Drawing.Brush" />，它确定所绘制文本的颜色和纹理。</param>
        <param name="point">
          <see cref="T:System.Drawing.PointF" /> 结构，它指定所绘制文本的左上角。</param>
        <summary>在指定位置并且用指定的 <see cref="T:System.Drawing.Brush" /> 和 <see cref="T:System.Drawing.Font" /> 对象绘制指定的文本字符串。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下面的代码示例设计为使用 Windows 窗体，并且它需要<xref:System.Windows.Forms.PaintEventArgs> `e`，这是一个参数的<xref:System.Windows.Forms.Control.Paint>事件处理程序。 该代码执行下列操作：  
  
-   创建要绘制的文本字符串。  
  
-   将字体定义为 Arial (16pt)。  
  
-   创建实心的黑色画笔绘制所使用。  
  
-   创建在其中绘制文本的左上角的点。  
  
-   使用字体、 画笔和目标点向屏幕中绘制的字符串。  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples2#84](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CPP/form1.cpp#84)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples2#84](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CS/form1.cs#84)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples2#84](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/VB/form1.vb#84)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="brush" /> 为 <see langword="null" />。  
  
或 
 <paramref name="s" /> 为 <see langword="null" />。</exception>
        <altmember cref="M:System.Windows.Forms.TextRenderer.DrawText(System.Drawing.IDeviceContext,System.String,System.Drawing.Font,System.Drawing.Point,System.Drawing.Color)" />
        <related type="Article" href="~/docs/framework/winforms/advanced/using-fonts-and-text.md">使用字体和文本</related>
      </Docs>
    </Member>
    <Member MemberName="DrawString">
      <MemberSignature Language="C#" Value="public void DrawString (string s, System.Drawing.Font font, System.Drawing.Brush brush, System.Drawing.RectangleF layoutRectangle);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawString(string s, class System.Drawing.Font font, class System.Drawing.Brush brush, valuetype System.Drawing.RectangleF layoutRectangle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawString(System.String,System.Drawing.Font,System.Drawing.Brush,System.Drawing.RectangleF)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawString(System::String ^ s, System::Drawing::Font ^ font, System::Drawing::Brush ^ brush, System::Drawing::RectangleF layoutRectangle);" />
      <MemberSignature Language="F#" Value="member this.DrawString : string * System.Drawing.Font * System.Drawing.Brush * System.Drawing.RectangleF -&gt; unit" Usage="graphics.DrawString (s, font, brush, layoutRectangle)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="font" Type="System.Drawing.Font" />
        <Parameter Name="brush" Type="System.Drawing.Brush" />
        <Parameter Name="layoutRectangle" Type="System.Drawing.RectangleF" />
      </Parameters>
      <Docs>
        <param name="s">要绘制的字符串。</param>
        <param name="font">
          <see cref="T:System.Drawing.Font" />，它定义字符串的文本格式。</param>
        <param name="brush">
          <see cref="T:System.Drawing.Brush" />，它确定所绘制文本的颜色和纹理。</param>
        <param name="layoutRectangle">
          <see cref="T:System.Drawing.RectangleF" /> 结构，它指定所绘制文本的位置。</param>
        <summary>在指定矩形并且用指定的 <see cref="T:System.Drawing.Brush" /> 和 <see cref="T:System.Drawing.Font" /> 对象绘制指定的文本字符串。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 所表示的文本`s`参数所表示的矩形内绘制`layoutRectangle`参数。 如果文本不适合该矩形内，它是最接近的单词处被截断。 若要进一步操作如何字符串绘制矩形使用内部<xref:System.Drawing.Graphics.DrawString%2A>重载采用<xref:System.Drawing.StringFormat>。  
  
   
  
## Examples  
 下面的代码示例设计为使用 Windows 窗体，并且它需要<xref:System.Windows.Forms.PaintEventArgs> `e`，这是一个参数的<xref:System.Windows.Forms.Control.Paint>事件处理程序。 该代码执行下列操作：  
  
-   创建要绘制的文本字符串。  
  
-   将字体定义为 Arial (16pt)。  
  
-   创建实心的黑色画笔绘制所使用。  
  
-   创建在其中绘制文本的矩形。  
  
-   在屏幕上绘制的矩形。  
  
-   使用字体、 画笔和目标矩形在屏幕上绘制的字符串。  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples2#86](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CPP/form1.cpp#86)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples2#86](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CS/form1.cs#86)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples2#86](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/VB/form1.vb#86)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="brush" /> 为 <see langword="null" />。  
  
或 
 <paramref name="s" /> 为 <see langword="null" />。</exception>
        <altmember cref="M:System.Windows.Forms.TextRenderer.DrawText(System.Drawing.IDeviceContext,System.String,System.Drawing.Font,System.Drawing.Point,System.Drawing.Color)" />
        <related type="Article" href="~/docs/framework/winforms/advanced/using-fonts-and-text.md">使用字体和文本</related>
      </Docs>
    </Member>
    <Member MemberName="DrawString">
      <MemberSignature Language="C#" Value="public void DrawString (string s, System.Drawing.Font font, System.Drawing.Brush brush, System.Drawing.PointF point, System.Drawing.StringFormat format);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawString(string s, class System.Drawing.Font font, class System.Drawing.Brush brush, valuetype System.Drawing.PointF point, class System.Drawing.StringFormat format) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawString(System.String,System.Drawing.Font,System.Drawing.Brush,System.Drawing.PointF,System.Drawing.StringFormat)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawString(System::String ^ s, System::Drawing::Font ^ font, System::Drawing::Brush ^ brush, System::Drawing::PointF point, System::Drawing::StringFormat ^ format);" />
      <MemberSignature Language="F#" Value="member this.DrawString : string * System.Drawing.Font * System.Drawing.Brush * System.Drawing.PointF * System.Drawing.StringFormat -&gt; unit" Usage="graphics.DrawString (s, font, brush, point, format)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="font" Type="System.Drawing.Font" />
        <Parameter Name="brush" Type="System.Drawing.Brush" />
        <Parameter Name="point" Type="System.Drawing.PointF" />
        <Parameter Name="format" Type="System.Drawing.StringFormat" />
      </Parameters>
      <Docs>
        <param name="s">要绘制的字符串。</param>
        <param name="font">
          <see cref="T:System.Drawing.Font" />，它定义字符串的文本格式。</param>
        <param name="brush">
          <see cref="T:System.Drawing.Brush" />，它确定所绘制文本的颜色和纹理。</param>
        <param name="point">
          <see cref="T:System.Drawing.PointF" /> 结构，它指定所绘制文本的左上角。</param>
        <param name="format">
          <see cref="T:System.Drawing.StringFormat" />，它指定应用于所绘制文本的格式化特性（如行距和对齐方式）。</param>
        <summary>使用指定 <see cref="T:System.Drawing.StringFormat" /> 的格式化特性，用指定的 <see cref="T:System.Drawing.Brush" /> 和 <see cref="T:System.Drawing.Font" /> 对象在指定的位置绘制指定的文本字符串。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下面的代码示例设计为使用 Windows 窗体，并且它需要<xref:System.Windows.Forms.PaintEventArgs> `e`，这是一个参数的<xref:System.Windows.Forms.Control.Paint>事件处理程序。 该代码执行下列操作：  
  
-   创建要绘制的文本字符串。  
  
-   将字体定义为 Arial (16pt)。  
  
-   创建实心的黑色画笔绘制所使用。  
  
-   创建在其中绘制文本的左上角的点。  
  
-   设置要垂直绘制的字符串的格式。  
  
-   绘制到屏幕上使用的字体、 画笔、 目标点和格式的字符串。  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples2#85](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CPP/form1.cpp#85)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples2#85](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CS/form1.cs#85)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples2#85](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/VB/form1.vb#85)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="brush" /> 为 <see langword="null" />。  
  
或 
 <paramref name="s" /> 为 <see langword="null" />。</exception>
        <altmember cref="M:System.Windows.Forms.TextRenderer.DrawText(System.Drawing.IDeviceContext,System.String,System.Drawing.Font,System.Drawing.Point,System.Drawing.Color)" />
        <related type="Article" href="~/docs/framework/winforms/advanced/using-fonts-and-text.md">使用字体和文本</related>
      </Docs>
    </Member>
    <Member MemberName="DrawString">
      <MemberSignature Language="C#" Value="public void DrawString (string s, System.Drawing.Font font, System.Drawing.Brush brush, System.Drawing.RectangleF layoutRectangle, System.Drawing.StringFormat format);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawString(string s, class System.Drawing.Font font, class System.Drawing.Brush brush, valuetype System.Drawing.RectangleF layoutRectangle, class System.Drawing.StringFormat format) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawString(System.String,System.Drawing.Font,System.Drawing.Brush,System.Drawing.RectangleF,System.Drawing.StringFormat)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawString(System::String ^ s, System::Drawing::Font ^ font, System::Drawing::Brush ^ brush, System::Drawing::RectangleF layoutRectangle, System::Drawing::StringFormat ^ format);" />
      <MemberSignature Language="F#" Value="member this.DrawString : string * System.Drawing.Font * System.Drawing.Brush * System.Drawing.RectangleF * System.Drawing.StringFormat -&gt; unit" Usage="graphics.DrawString (s, font, brush, layoutRectangle, format)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="font" Type="System.Drawing.Font" />
        <Parameter Name="brush" Type="System.Drawing.Brush" />
        <Parameter Name="layoutRectangle" Type="System.Drawing.RectangleF" />
        <Parameter Name="format" Type="System.Drawing.StringFormat" />
      </Parameters>
      <Docs>
        <param name="s">要绘制的字符串。</param>
        <param name="font">
          <see cref="T:System.Drawing.Font" />，它定义字符串的文本格式。</param>
        <param name="brush">
          <see cref="T:System.Drawing.Brush" />，它确定所绘制文本的颜色和纹理。</param>
        <param name="layoutRectangle">
          <see cref="T:System.Drawing.RectangleF" /> 结构，它指定所绘制文本的位置。</param>
        <param name="format">
          <see cref="T:System.Drawing.StringFormat" />，它指定应用于所绘制文本的格式化特性（如行距和对齐方式）。</param>
        <summary>使用指定 <see cref="T:System.Drawing.StringFormat" /> 的格式化特性，用指定的 <see cref="T:System.Drawing.Brush" /> 和 <see cref="T:System.Drawing.Font" /> 对象在指定的矩形中绘制指定的文本字符串。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 所表示的文本`s`参数所表示的矩形内绘制`layoutRectangle`参数。 如果文本不适合该矩形内，则会被截断在最接近的单词，除非另有指定与`format`参数。  
  
   
  
## Examples  
 下面的代码示例设计为使用 Windows 窗体，并且它需要<xref:System.Windows.Forms.PaintEventArgs> `e`，这是一个参数的<xref:System.Windows.Forms.Control.Paint>事件处理程序。 该代码执行下列操作：  
  
-   创建要绘制的文本字符串。  
  
-   将字体定义为 Arial (16pt)。  
  
-   创建实心的黑色画笔绘制所使用。  
  
-   创建在其中绘制文本的矩形。  
  
-   在屏幕上绘制的矩形。  
  
-   要使其居中的矩形中的字符串的格式设置。  
  
-   使用字体、 画笔和目标矩形在屏幕上绘制的字符串。  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples2#87](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CPP/form1.cpp#87)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples2#87](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CS/form1.cs#87)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples2#87](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/VB/form1.vb#87)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="brush" /> 为 <see langword="null" />。  
  
或 
 <paramref name="s" /> 为 <see langword="null" />。</exception>
        <altmember cref="M:System.Windows.Forms.TextRenderer.DrawText(System.Drawing.IDeviceContext,System.String,System.Drawing.Font,System.Drawing.Point,System.Drawing.Color)" />
        <related type="Article" href="~/docs/framework/winforms/advanced/using-fonts-and-text.md">使用字体和文本</related>
      </Docs>
    </Member>
    <Member MemberName="DrawString">
      <MemberSignature Language="C#" Value="public void DrawString (string s, System.Drawing.Font font, System.Drawing.Brush brush, float x, float y);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawString(string s, class System.Drawing.Font font, class System.Drawing.Brush brush, float32 x, float32 y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawString(System.String,System.Drawing.Font,System.Drawing.Brush,System.Single,System.Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawString(System::String ^ s, System::Drawing::Font ^ font, System::Drawing::Brush ^ brush, float x, float y);" />
      <MemberSignature Language="F#" Value="member this.DrawString : string * System.Drawing.Font * System.Drawing.Brush * single * single -&gt; unit" Usage="graphics.DrawString (s, font, brush, x, y)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="font" Type="System.Drawing.Font" />
        <Parameter Name="brush" Type="System.Drawing.Brush" />
        <Parameter Name="x" Type="System.Single" />
        <Parameter Name="y" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="s">要绘制的字符串。</param>
        <param name="font">
          <see cref="T:System.Drawing.Font" />，它定义字符串的文本格式。</param>
        <param name="brush">
          <see cref="T:System.Drawing.Brush" />，它确定所绘制文本的颜色和纹理。</param>
        <param name="x">所绘制文本的左上角的 x 坐标。</param>
        <param name="y">所绘制文本的左上角的 y 坐标。</param>
        <summary>在指定位置并且用指定的 <see cref="T:System.Drawing.Brush" /> 和 <see cref="T:System.Drawing.Font" /> 对象绘制指定的文本字符串。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下面的代码示例设计为使用 Windows 窗体，并且它需要<xref:System.Windows.Forms.PaintEventArgs> `e`，这是一个参数的<xref:System.Windows.Forms.Control.Paint>事件处理程序。 该代码执行下列操作：  
  
-   创建要绘制的文本字符串。  
  
-   将字体定义为 Arial (16pt)。  
  
-   创建纯黑色画笔绘制所使用。  
  
-   创建在其中绘制文本的左上角的点。  
  
-   使用字体、 画笔和目标点向屏幕中绘制的字符串。  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples2#88](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CPP/form1.cpp#88)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples2#88](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CS/form1.cs#88)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples2#88](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/VB/form1.vb#88)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="brush" /> 为 <see langword="null" />。  
  
或 
 <paramref name="s" /> 为 <see langword="null" />。</exception>
        <altmember cref="M:System.Windows.Forms.TextRenderer.DrawText(System.Drawing.IDeviceContext,System.String,System.Drawing.Font,System.Drawing.Point,System.Drawing.Color)" />
        <related type="Article" href="~/docs/framework/winforms/advanced/using-fonts-and-text.md">使用字体和文本</related>
      </Docs>
    </Member>
    <Member MemberName="DrawString">
      <MemberSignature Language="C#" Value="public void DrawString (string s, System.Drawing.Font font, System.Drawing.Brush brush, float x, float y, System.Drawing.StringFormat format);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawString(string s, class System.Drawing.Font font, class System.Drawing.Brush brush, float32 x, float32 y, class System.Drawing.StringFormat format) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawString(System.String,System.Drawing.Font,System.Drawing.Brush,System.Single,System.Single,System.Drawing.StringFormat)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawString(System::String ^ s, System::Drawing::Font ^ font, System::Drawing::Brush ^ brush, float x, float y, System::Drawing::StringFormat ^ format);" />
      <MemberSignature Language="F#" Value="member this.DrawString : string * System.Drawing.Font * System.Drawing.Brush * single * single * System.Drawing.StringFormat -&gt; unit" Usage="graphics.DrawString (s, font, brush, x, y, format)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="font" Type="System.Drawing.Font" />
        <Parameter Name="brush" Type="System.Drawing.Brush" />
        <Parameter Name="x" Type="System.Single" />
        <Parameter Name="y" Type="System.Single" />
        <Parameter Name="format" Type="System.Drawing.StringFormat" />
      </Parameters>
      <Docs>
        <param name="s">要绘制的字符串。</param>
        <param name="font">
          <see cref="T:System.Drawing.Font" />，它定义字符串的文本格式。</param>
        <param name="brush">
          <see cref="T:System.Drawing.Brush" />，它确定所绘制文本的颜色和纹理。</param>
        <param name="x">所绘制文本的左上角的 x 坐标。</param>
        <param name="y">所绘制文本的左上角的 y 坐标。</param>
        <param name="format">
          <see cref="T:System.Drawing.StringFormat" />，它指定应用于所绘制文本的格式化特性（如行距和对齐方式）。</param>
        <summary>使用指定 <see cref="T:System.Drawing.StringFormat" /> 的格式化特性，用指定的 <see cref="T:System.Drawing.Brush" /> 和 <see cref="T:System.Drawing.Font" /> 对象在指定的位置绘制指定的文本字符串。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下面的代码示例设计为使用 Windows 窗体，并且它需要<xref:System.Windows.Forms.PaintEventArgs> `e`，这是一个参数的<xref:System.Windows.Forms.Control.Paint>事件处理程序。 该代码执行下列操作：  
  
-   创建要绘制的文本字符串。  
  
-   将字体定义为 Arial (16pt)。  
  
-   创建实心的黑色画笔绘制所使用。  
  
-   创建在其中绘制文本的左上角的点的坐标。  
  
-   设置要垂直绘制的字符串的格式  
  
-   绘制到屏幕上使用的字体、 画笔、 目标点和格式的字符串。  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples2#89](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CPP/form1.cpp#89)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples2#89](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CS/form1.cs#89)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples2#89](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/VB/form1.vb#89)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="brush" /> 为 <see langword="null" />。  
  
或 
 <paramref name="s" /> 为 <see langword="null" />。</exception>
        <altmember cref="M:System.Windows.Forms.TextRenderer.DrawText(System.Drawing.IDeviceContext,System.String,System.Drawing.Font,System.Drawing.Point,System.Drawing.Color)" />
        <related type="Article" href="~/docs/framework/winforms/advanced/using-fonts-and-text.md">使用字体和文本</related>
      </Docs>
    </Member>
    <Member MemberName="EndContainer">
      <MemberSignature Language="C#" Value="public void EndContainer (System.Drawing.Drawing2D.GraphicsContainer container);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EndContainer(class System.Drawing.Drawing2D.GraphicsContainer container) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.EndContainer(System.Drawing.Drawing2D.GraphicsContainer)" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndContainer (container As GraphicsContainer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EndContainer(System::Drawing::Drawing2D::GraphicsContainer ^ container);" />
      <MemberSignature Language="F#" Value="member this.EndContainer : System.Drawing.Drawing2D.GraphicsContainer -&gt; unit" Usage="graphics.EndContainer container" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="container" Type="System.Drawing.Drawing2D.GraphicsContainer" />
      </Parameters>
      <Docs>
        <param name="container">
          <see cref="T:System.Drawing.Drawing2D.GraphicsContainer" />，它表示此方法还原的容器。</param>
        <summary>关闭当前图形容器，并将此 <see cref="T:System.Drawing.Graphics" /> 的状态还原到通过调用 <see cref="M:System.Drawing.Graphics.BeginContainer" /> 方法保存的状态。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 将此方法用于<xref:System.Drawing.Graphics.BeginContainer%2A>方法来创建嵌套的图形容器。 图形容器保留的图形状态，例如转换、 剪辑区域和呈现属性。  
  
 当您调用<xref:System.Drawing.Graphics.BeginContainer%2A>方法<xref:System.Drawing.Graphics>，保存的状态信息块<xref:System.Drawing.Graphics>放在堆栈上。 <xref:System.Drawing.Graphics.BeginContainer%2A>方法将返回<xref:System.Drawing.Drawing2D.GraphicsContainer>，用于标识该信息块。 当您标识将对象传递给<xref:System.Drawing.Graphics.EndContainer%2A>方法，该信息块从堆栈中移除并用于还原<xref:System.Drawing.Graphics>时的状态为<xref:System.Drawing.Graphics.BeginContainer%2A>方法调用。  
  
 可以嵌套容器;也就是说，可以调用<xref:System.Drawing.Graphics.BeginContainer%2A>方法在调用之前几次<xref:System.Drawing.Graphics.EndContainer%2A>方法。 每次调用<xref:System.Drawing.Graphics.BeginContainer%2A>方法中，信息块放置在堆栈上，并且您收到<xref:System.Drawing.Drawing2D.GraphicsContainer>信息块。 当传递到这些对象之一<xref:System.Drawing.Graphics.EndContainer%2A>方法，<xref:System.Drawing.Graphics>返回到它所处的时间的状态<xref:System.Drawing.Graphics.BeginContainer%2A>方法调用返回了该特定<xref:System.Drawing.Drawing2D.GraphicsContainer>。 信息块放置在堆栈上的<xref:System.Drawing.Graphics.BeginContainer%2A>方法调用将从堆栈中，删除，所有信息块后，都放置在该堆栈上<xref:System.Drawing.Graphics.BeginContainer%2A>方法调用也将被删除。  
  
 调用<xref:System.Drawing.Graphics.Save%2A>方法相同调用堆栈上的位置信息块<xref:System.Drawing.Graphics.BeginContainer%2A>方法。 就像<xref:System.Drawing.Graphics.EndContainer%2A>方法调用搭配<xref:System.Drawing.Graphics.BeginContainer%2A>方法调用<xref:System.Drawing.Graphics.Restore%2A>方法调用搭配<xref:System.Drawing.Graphics.Save%2A>方法调用。  
  
 当您调用<xref:System.Drawing.Graphics.EndContainer%2A>方法中，所有信息块都放置在堆栈上 (通过<xref:System.Drawing.Graphics.Save%2A>方法或通过<xref:System.Drawing.Graphics.BeginContainer%2A>方法) 后的对应调用<xref:System.Drawing.Graphics.BeginContainer%2A>方法从堆栈中移除。 同样，当您调用<xref:System.Drawing.Graphics.Restore%2A>方法中，所有信息块都放置在堆栈上 (通过<xref:System.Drawing.Graphics.Save%2A>方法或通过<xref:System.Drawing.Graphics.BeginContainer%2A>方法) 后的对应调用<xref:System.Drawing.Graphics.Save%2A>方法从堆栈中移除。  
  
   
  
## Examples  
 下面的代码示例设计为使用 Windows 窗体，并且它需要<xref:System.Windows.Forms.PaintEventArgs> `e`，这是一个参数的<xref:System.Windows.Forms.Control.Paint>事件处理程序。 该代码执行下列操作：  
  
-   打开新的图形容器，并保存旧的容器。  
  
-   将转换的世界坐标以容器。  
  
-   填入一个红色矩形 (转换的坐标) 新的容器。  
  
-   关闭新的容器并将还原已保存的容器。  
  
-   填充已保存容器的绿色矩形 （为未转换的坐标中）。  
  
 结果是覆盖相同大小的红色矩形之上的绿色矩形。  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples2#90](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CPP/form1.cpp#90)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples2#90](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CS/form1.cs#90)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples2#90](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/VB/form1.vb#90)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="EnumerateMetafile">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>将指定 <see cref="T:System.Drawing.Imaging.Metafile" /> 中的记录逐个发送到回调方法以在指定的点处显示。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="EnumerateMetafile">
      <MemberSignature Language="C#" Value="public void EnumerateMetafile (System.Drawing.Imaging.Metafile metafile, System.Drawing.Point destPoint, System.Drawing.Graphics.EnumerateMetafileProc callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EnumerateMetafile(class System.Drawing.Imaging.Metafile metafile, valuetype System.Drawing.Point destPoint, class System.Drawing.Graphics/EnumerateMetafileProc callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.EnumerateMetafile(System.Drawing.Imaging.Metafile,System.Drawing.Point,System.Drawing.Graphics.EnumerateMetafileProc)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EnumerateMetafile(System::Drawing::Imaging::Metafile ^ metafile, System::Drawing::Point destPoint, System::Drawing::Graphics::EnumerateMetafileProc ^ callback);" />
      <MemberSignature Language="F#" Value="member this.EnumerateMetafile : System.Drawing.Imaging.Metafile * System.Drawing.Point * System.Drawing.Graphics.EnumerateMetafileProc -&gt; unit" Usage="graphics.EnumerateMetafile (metafile, destPoint, callback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metafile" Type="System.Drawing.Imaging.Metafile" />
        <Parameter Name="destPoint" Type="System.Drawing.Point" />
        <Parameter Name="callback" Type="System.Drawing.Graphics+EnumerateMetafileProc" />
      </Parameters>
      <Docs>
        <param name="metafile">要枚举的 <see cref="T:System.Drawing.Imaging.Metafile" />。</param>
        <param name="destPoint">
          <see cref="T:System.Drawing.Point" /> 结构，它指定所绘制图元文件的左上角的位置。</param>
        <param name="callback">
          <see cref="T:System.Drawing.Graphics.EnumerateMetafileProc" /> 委托，它指定将图元文件记录发送到的方法。</param>
        <summary>将指定 <see cref="T:System.Drawing.Imaging.Metafile" /> 中的记录逐个发送到回调方法以在指定的点处显示。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法枚举指定图元文件中包含的记录。 每个记录分别发送到回调方法，通过指定`callback`参数。 通常情况下，回调方法调用<xref:System.Drawing.Imaging.Metafile.PlayRecord%2A>"播放"，或绘图、 记录的方法。  
  
 如果回调方法调用<xref:System.Drawing.Imaging.Metafile.PlayRecord%2A>，它必须通过调用实现<xref:System.Drawing.Imaging.Metafile.PlayRecord%2A>方法的特定于<xref:System.Drawing.Imaging.Metafile>正在枚举。  
  
   
  
## Examples  
 下面的代码示例创建具有的窗体<xref:System.Drawing.Imaging.Metafile>作为它的私有成员之一。 <xref:System.Windows.Forms.Control.OnPaint%2A>方法调用<xref:System.Drawing.Graphics.EnumerateMetafile%2A>，它调用窗体的`MetafileCallback`图元文件中每个记录的方法。 `MetafileCallback` 方法调用 <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A> 方法。 请注意，`MetafileCallback`方法接收作为记录数据<xref:System.IntPtr>，但<xref:System.Drawing.Imaging.Metafile.PlayRecord%2A>方法需要记录数据的是字节数组。 在调用<xref:System.Runtime.InteropServices.Marshal.Copy%2A>将记录数据复制到字节数组，以便它可以被传递给<xref:System.Drawing.Imaging.Metafile.PlayRecord%2A>。  
  
 [!code-csharp[System.Drawing.Graphics.EnumerateMetafile#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.Graphics.EnumerateMetafile/CS/Form1.cs#1)]
 [!code-vb[System.Drawing.Graphics.EnumerateMetafile#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.Graphics.EnumerateMetafile/VB/Form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">图像、位图和图元文件</related>
      </Docs>
    </Member>
    <Member MemberName="EnumerateMetafile">
      <MemberSignature Language="C#" Value="public void EnumerateMetafile (System.Drawing.Imaging.Metafile metafile, System.Drawing.Point[] destPoints, System.Drawing.Graphics.EnumerateMetafileProc callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EnumerateMetafile(class System.Drawing.Imaging.Metafile metafile, valuetype System.Drawing.Point[] destPoints, class System.Drawing.Graphics/EnumerateMetafileProc callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.EnumerateMetafile(System.Drawing.Imaging.Metafile,System.Drawing.Point[],System.Drawing.Graphics.EnumerateMetafileProc)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EnumerateMetafile(System::Drawing::Imaging::Metafile ^ metafile, cli::array &lt;System::Drawing::Point&gt; ^ destPoints, System::Drawing::Graphics::EnumerateMetafileProc ^ callback);" />
      <MemberSignature Language="F#" Value="member this.EnumerateMetafile : System.Drawing.Imaging.Metafile * System.Drawing.Point[] * System.Drawing.Graphics.EnumerateMetafileProc -&gt; unit" Usage="graphics.EnumerateMetafile (metafile, destPoints, callback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metafile" Type="System.Drawing.Imaging.Metafile" />
        <Parameter Name="destPoints" Type="System.Drawing.Point[]" />
        <Parameter Name="callback" Type="System.Drawing.Graphics+EnumerateMetafileProc" />
      </Parameters>
      <Docs>
        <param name="metafile">要枚举的 <see cref="T:System.Drawing.Imaging.Metafile" />。</param>
        <param name="destPoints">由三个 <see cref="T:System.Drawing.Point" /> 结构组成的数组，这三个结构定义一个用来确定所绘制图元文件的大小和位置的平行四边形。</param>
        <param name="callback">
          <see cref="T:System.Drawing.Graphics.EnumerateMetafileProc" /> 委托，它指定将图元文件记录发送到的方法。</param>
        <summary>将指定 <see cref="T:System.Drawing.Imaging.Metafile" /> 中的记录逐个发送到回调方法以在指定的平行四边形中显示。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法枚举指定图元文件中包含的记录。 每个记录分别发送到回调方法，通过指定`callback`参数。 通常情况下，回调方法调用<xref:System.Drawing.Imaging.Metafile.PlayRecord%2A>"播放"，或绘图、 记录的方法。  
  
 如果回调方法调用<xref:System.Drawing.Imaging.Metafile.PlayRecord%2A>，它必须通过调用实现<xref:System.Drawing.Imaging.Metafile.PlayRecord%2A>方法的特定于<xref:System.Drawing.Imaging.Metafile>正在枚举。  
  
   
  
## Examples  
 有关代码示例，请参阅 <xref:System.Drawing.Graphics.EnumerateMetafile%28System.Drawing.Imaging.Metafile%2CSystem.Drawing.Point%2CSystem.Drawing.Graphics.EnumerateMetafileProc%29>。  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">图像、位图和图元文件</related>
      </Docs>
    </Member>
    <Member MemberName="EnumerateMetafile">
      <MemberSignature Language="C#" Value="public void EnumerateMetafile (System.Drawing.Imaging.Metafile metafile, System.Drawing.PointF destPoint, System.Drawing.Graphics.EnumerateMetafileProc callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EnumerateMetafile(class System.Drawing.Imaging.Metafile metafile, valuetype System.Drawing.PointF destPoint, class System.Drawing.Graphics/EnumerateMetafileProc callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.EnumerateMetafile(System.Drawing.Imaging.Metafile,System.Drawing.PointF,System.Drawing.Graphics.EnumerateMetafileProc)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EnumerateMetafile(System::Drawing::Imaging::Metafile ^ metafile, System::Drawing::PointF destPoint, System::Drawing::Graphics::EnumerateMetafileProc ^ callback);" />
      <MemberSignature Language="F#" Value="member this.EnumerateMetafile : System.Drawing.Imaging.Metafile * System.Drawing.PointF * System.Drawing.Graphics.EnumerateMetafileProc -&gt; unit" Usage="graphics.EnumerateMetafile (metafile, destPoint, callback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metafile" Type="System.Drawing.Imaging.Metafile" />
        <Parameter Name="destPoint" Type="System.Drawing.PointF" />
        <Parameter Name="callback" Type="System.Drawing.Graphics+EnumerateMetafileProc" />
      </Parameters>
      <Docs>
        <param name="metafile">要枚举的 <see cref="T:System.Drawing.Imaging.Metafile" />。</param>
        <param name="destPoint">
          <see cref="T:System.Drawing.PointF" /> 结构，它指定所绘制图元文件的左上角的位置。</param>
        <param name="callback">
          <see cref="T:System.Drawing.Graphics.EnumerateMetafileProc" /> 委托，它指定将图元文件记录发送到的方法。</param>
        <summary>将指定 <see cref="T:System.Drawing.Imaging.Metafile" /> 中的记录逐个发送到回调方法以在指定的点处显示。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法枚举指定图元文件中包含的记录。 每个记录分别发送到回调方法，通过指定`callback`参数。 通常情况下，回调方法调用<xref:System.Drawing.Imaging.Metafile.PlayRecord%2A>"播放"，或绘图、 记录的方法。  
  
 如果回调方法调用<xref:System.Drawing.Imaging.Metafile.PlayRecord%2A>，它必须通过调用实现<xref:System.Drawing.Imaging.Metafile.PlayRecord%2A>方法的特定于<xref:System.Drawing.Imaging.Metafile>正在枚举。  
  
   
  
## Examples  
 有关代码示例，请参阅 <xref:System.Drawing.Graphics.EnumerateMetafile%28System.Drawing.Imaging.Metafile%2CSystem.Drawing.Point%2CSystem.Drawing.Graphics.EnumerateMetafileProc%29>。  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">图像、位图和图元文件</related>
      </Docs>
    </Member>
    <Member MemberName="EnumerateMetafile">
      <MemberSignature Language="C#" Value="public void EnumerateMetafile (System.Drawing.Imaging.Metafile metafile, System.Drawing.PointF[] destPoints, System.Drawing.Graphics.EnumerateMetafileProc callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EnumerateMetafile(class System.Drawing.Imaging.Metafile metafile, valuetype System.Drawing.PointF[] destPoints, class System.Drawing.Graphics/EnumerateMetafileProc callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.EnumerateMetafile(System.Drawing.Imaging.Metafile,System.Drawing.PointF[],System.Drawing.Graphics.EnumerateMetafileProc)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EnumerateMetafile(System::Drawing::Imaging::Metafile ^ metafile, cli::array &lt;System::Drawing::PointF&gt; ^ destPoints, System::Drawing::Graphics::EnumerateMetafileProc ^ callback);" />
      <MemberSignature Language="F#" Value="member this.EnumerateMetafile : System.Drawing.Imaging.Metafile * System.Drawing.PointF[] * System.Drawing.Graphics.EnumerateMetafileProc -&gt; unit" Usage="graphics.EnumerateMetafile (metafile, destPoints, callback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metafile" Type="System.Drawing.Imaging.Metafile" />
        <Parameter Name="destPoints" Type="System.Drawing.PointF[]" />
        <Parameter Name="callback" Type="System.Drawing.Graphics+EnumerateMetafileProc" />
      </Parameters>
      <Docs>
        <param name="metafile">要枚举的 <see cref="T:System.Drawing.Imaging.Metafile" />。</param>
        <param name="destPoints">由三个 <see cref="T:System.Drawing.PointF" /> 结构组成的数组，这三个结构定义一个用来确定所绘制图元文件的大小和位置的平行四边形。</param>
        <param name="callback">
          <see cref="T:System.Drawing.Graphics.EnumerateMetafileProc" /> 委托，它指定将图元文件记录发送到的方法。</param>
        <summary>将指定 <see cref="T:System.Drawing.Imaging.Metafile" /> 中的记录逐个发送到回调方法以在指定的平行四边形中显示。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法枚举指定图元文件中包含的记录。 每个记录分别发送到回调方法，通过指定`callback`参数。 通常情况下，回调方法调用<xref:System.Drawing.Imaging.Metafile.PlayRecord%2A>"播放"，或绘图、 记录的方法。  
  
 如果回调方法调用<xref:System.Drawing.Imaging.Metafile.PlayRecord%2A>，它必须通过调用实现<xref:System.Drawing.Imaging.Metafile.PlayRecord%2A>方法的特定于<xref:System.Drawing.Imaging.Metafile>正在枚举。  
  
 `destPoints`参数指定的平行四边形的三个点。 这三个<xref:System.Drawing.PointF>结构表示的平行四边形的左上角、 右上方和左下角。 第四个点推断出的前三个以形成一个平行四边形。 缩放和剪切以适合的平行四边形绘制图元文件。  
  
   
  
## Examples  
 有关代码示例，请参阅 <xref:System.Drawing.Graphics.EnumerateMetafile%28System.Drawing.Imaging.Metafile%2CSystem.Drawing.Point%2CSystem.Drawing.Graphics.EnumerateMetafileProc%29>。  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">图像、位图和图元文件</related>
      </Docs>
    </Member>
    <Member MemberName="EnumerateMetafile">
      <MemberSignature Language="C#" Value="public void EnumerateMetafile (System.Drawing.Imaging.Metafile metafile, System.Drawing.Rectangle destRect, System.Drawing.Graphics.EnumerateMetafileProc callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EnumerateMetafile(class System.Drawing.Imaging.Metafile metafile, valuetype System.Drawing.Rectangle destRect, class System.Drawing.Graphics/EnumerateMetafileProc callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.EnumerateMetafile(System.Drawing.Imaging.Metafile,System.Drawing.Rectangle,System.Drawing.Graphics.EnumerateMetafileProc)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EnumerateMetafile(System::Drawing::Imaging::Metafile ^ metafile, System::Drawing::Rectangle destRect, System::Drawing::Graphics::EnumerateMetafileProc ^ callback);" />
      <MemberSignature Language="F#" Value="member this.EnumerateMetafile : System.Drawing.Imaging.Metafile * System.Drawing.Rectangle * System.Drawing.Graphics.EnumerateMetafileProc -&gt; unit" Usage="graphics.EnumerateMetafile (metafile, destRect, callback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metafile" Type="System.Drawing.Imaging.Metafile" />
        <Parameter Name="destRect" Type="System.Drawing.Rectangle" />
        <Parameter Name="callback" Type="System.Drawing.Graphics+EnumerateMetafileProc" />
      </Parameters>
      <Docs>
        <param name="metafile">要枚举的 <see cref="T:System.Drawing.Imaging.Metafile" />。</param>
        <param name="destRect">
          <see cref="T:System.Drawing.Rectangle" /> 结构，它指定所绘制图元文件的位置和大小。</param>
        <param name="callback">
          <see cref="T:System.Drawing.Graphics.EnumerateMetafileProc" /> 委托，它指定将图元文件记录发送到的方法。</param>
        <summary>将指定 <see cref="T:System.Drawing.Imaging.Metafile" /> 中的记录逐个发送到回调方法以在指定的矩形中显示。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法枚举指定图元文件中包含的记录。 每个记录分别发送到回调方法，通过指定`callback`参数。 通常情况下，回调方法调用<xref:System.Drawing.Imaging.Metafile.PlayRecord%2A>"播放"，或绘图、 记录的方法。  
  
 如果回调方法调用<xref:System.Drawing.Imaging.Metafile.PlayRecord%2A>，它必须通过调用实现<xref:System.Drawing.Imaging.Metafile.PlayRecord%2A>方法的特定于<xref:System.Drawing.Imaging.Metafile>正在枚举。  
  
   
  
## Examples  
 有关代码示例，请参阅 <xref:System.Drawing.Graphics.EnumerateMetafile%28System.Drawing.Imaging.Metafile%2CSystem.Drawing.Point%2CSystem.Drawing.Graphics.EnumerateMetafileProc%29>。  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">图像、位图和图元文件</related>
      </Docs>
    </Member>
    <Member MemberName="EnumerateMetafile">
      <MemberSignature Language="C#" Value="public void EnumerateMetafile (System.Drawing.Imaging.Metafile metafile, System.Drawing.RectangleF destRect, System.Drawing.Graphics.EnumerateMetafileProc callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EnumerateMetafile(class System.Drawing.Imaging.Metafile metafile, valuetype System.Drawing.RectangleF destRect, class System.Drawing.Graphics/EnumerateMetafileProc callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.EnumerateMetafile(System.Drawing.Imaging.Metafile,System.Drawing.RectangleF,System.Drawing.Graphics.EnumerateMetafileProc)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EnumerateMetafile(System::Drawing::Imaging::Metafile ^ metafile, System::Drawing::RectangleF destRect, System::Drawing::Graphics::EnumerateMetafileProc ^ callback);" />
      <MemberSignature Language="F#" Value="member this.EnumerateMetafile : System.Drawing.Imaging.Metafile * System.Drawing.RectangleF * System.Drawing.Graphics.EnumerateMetafileProc -&gt; unit" Usage="graphics.EnumerateMetafile (metafile, destRect, callback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metafile" Type="System.Drawing.Imaging.Metafile" />
        <Parameter Name="destRect" Type="System.Drawing.RectangleF" />
        <Parameter Name="callback" Type="System.Drawing.Graphics+EnumerateMetafileProc" />
      </Parameters>
      <Docs>
        <param name="metafile">要枚举的 <see cref="T:System.Drawing.Imaging.Metafile" />。</param>
        <param name="destRect">
          <see cref="T:System.Drawing.RectangleF" /> 结构，它指定所绘制图元文件的位置和大小。</param>
        <param name="callback">
          <see cref="T:System.Drawing.Graphics.EnumerateMetafileProc" /> 委托，它指定将图元文件记录发送到的方法。</param>
        <summary>将指定 <see cref="T:System.Drawing.Imaging.Metafile" /> 中的记录逐个发送到回调方法以在指定的矩形中显示。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法枚举指定图元文件中包含的记录。 每个记录分别发送到回调方法，通过指定`callback`参数。 通常情况下，回调方法调用<xref:System.Drawing.Imaging.Metafile.PlayRecord%2A>"播放"，或绘图、 记录的方法。  
  
 如果回调方法调用<xref:System.Drawing.Imaging.Metafile.PlayRecord%2A>，它必须通过调用实现<xref:System.Drawing.Imaging.Metafile.PlayRecord%2A>方法的特定于<xref:System.Drawing.Imaging.Metafile>正在枚举。  
  
   
  
## Examples  
 有关代码示例，请参阅 <xref:System.Drawing.Graphics.EnumerateMetafile%28System.Drawing.Imaging.Metafile%2CSystem.Drawing.Point%2CSystem.Drawing.Graphics.EnumerateMetafileProc%29>。  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">图像、位图和图元文件</related>
      </Docs>
    </Member>
    <Member MemberName="EnumerateMetafile">
      <MemberSignature Language="C#" Value="public void EnumerateMetafile (System.Drawing.Imaging.Metafile metafile, System.Drawing.Point destPoint, System.Drawing.Graphics.EnumerateMetafileProc callback, IntPtr callbackData);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EnumerateMetafile(class System.Drawing.Imaging.Metafile metafile, valuetype System.Drawing.Point destPoint, class System.Drawing.Graphics/EnumerateMetafileProc callback, native int callbackData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.EnumerateMetafile(System.Drawing.Imaging.Metafile,System.Drawing.Point,System.Drawing.Graphics.EnumerateMetafileProc,System.IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EnumerateMetafile(System::Drawing::Imaging::Metafile ^ metafile, System::Drawing::Point destPoint, System::Drawing::Graphics::EnumerateMetafileProc ^ callback, IntPtr callbackData);" />
      <MemberSignature Language="F#" Value="member this.EnumerateMetafile : System.Drawing.Imaging.Metafile * System.Drawing.Point * System.Drawing.Graphics.EnumerateMetafileProc * nativeint -&gt; unit" Usage="graphics.EnumerateMetafile (metafile, destPoint, callback, callbackData)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metafile" Type="System.Drawing.Imaging.Metafile" />
        <Parameter Name="destPoint" Type="System.Drawing.Point" />
        <Parameter Name="callback" Type="System.Drawing.Graphics+EnumerateMetafileProc" />
        <Parameter Name="callbackData" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="metafile">要枚举的 <see cref="T:System.Drawing.Imaging.Metafile" />。</param>
        <param name="destPoint">
          <see cref="T:System.Drawing.Point" /> 结构，它指定所绘制图元文件的左上角的位置。</param>
        <param name="callback">
          <see cref="T:System.Drawing.Graphics.EnumerateMetafileProc" /> 委托，它指定将图元文件记录发送到的方法。</param>
        <param name="callbackData">必需但被忽略的内部指针。 可以为此参数传递 <see cref="F:System.IntPtr.Zero" />。</param>
        <summary>将指定 <see cref="T:System.Drawing.Imaging.Metafile" /> 中的记录逐个发送到回调方法以在指定的点处显示。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法枚举指定图元文件中包含的记录。 每个记录分别发送到回调方法，通过指定`callback`参数。 通常情况下，回调方法调用<xref:System.Drawing.Imaging.Metafile.PlayRecord%2A>"播放"，或绘图、 记录的方法。  
  
 如果回调方法调用<xref:System.Drawing.Imaging.Metafile.PlayRecord%2A>，它必须通过调用实现<xref:System.Drawing.Imaging.Metafile.PlayRecord%2A>方法的特定于<xref:System.Drawing.Imaging.Metafile>正在枚举。  
  
   
  
## Examples  
 有关代码示例，请参阅 <xref:System.Drawing.Graphics.EnumerateMetafile%2A>。  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">图像、位图和图元文件</related>
      </Docs>
    </Member>
    <Member MemberName="EnumerateMetafile">
      <MemberSignature Language="C#" Value="public void EnumerateMetafile (System.Drawing.Imaging.Metafile metafile, System.Drawing.Point[] destPoints, System.Drawing.Graphics.EnumerateMetafileProc callback, IntPtr callbackData);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EnumerateMetafile(class System.Drawing.Imaging.Metafile metafile, valuetype System.Drawing.Point[] destPoints, class System.Drawing.Graphics/EnumerateMetafileProc callback, native int callbackData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.EnumerateMetafile(System.Drawing.Imaging.Metafile,System.Drawing.Point[],System.Drawing.Graphics.EnumerateMetafileProc,System.IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EnumerateMetafile(System::Drawing::Imaging::Metafile ^ metafile, cli::array &lt;System::Drawing::Point&gt; ^ destPoints, System::Drawing::Graphics::EnumerateMetafileProc ^ callback, IntPtr callbackData);" />
      <MemberSignature Language="F#" Value="member this.EnumerateMetafile : System.Drawing.Imaging.Metafile * System.Drawing.Point[] * System.Drawing.Graphics.EnumerateMetafileProc * nativeint -&gt; unit" Usage="graphics.EnumerateMetafile (metafile, destPoints, callback, callbackData)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metafile" Type="System.Drawing.Imaging.Metafile" />
        <Parameter Name="destPoints" Type="System.Drawing.Point[]" />
        <Parameter Name="callback" Type="System.Drawing.Graphics+EnumerateMetafileProc" />
        <Parameter Name="callbackData" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="metafile">要枚举的 <see cref="T:System.Drawing.Imaging.Metafile" />。</param>
        <param name="destPoints">由三个 <see cref="T:System.Drawing.Point" /> 结构组成的数组，这三个结构定义一个用来确定所绘制图元文件的大小和位置的平行四边形。</param>
        <param name="callback">
          <see cref="T:System.Drawing.Graphics.EnumerateMetafileProc" /> 委托，它指定将图元文件记录发送到的方法。</param>
        <param name="callbackData">必需但被忽略的内部指针。 可以为此参数传递 <see cref="F:System.IntPtr.Zero" />。</param>
        <summary>将指定 <see cref="T:System.Drawing.Imaging.Metafile" /> 中的记录逐个发送到回调方法以在指定的平行四边形中显示。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法枚举指定图元文件中包含的记录。 每个记录分别发送到回调方法，通过指定`callback`参数。 通常情况下，回调方法调用<xref:System.Drawing.Imaging.Metafile.PlayRecord%2A>"播放"，或绘图、 记录的方法。  
  
 如果回调方法调用<xref:System.Drawing.Imaging.Metafile.PlayRecord%2A>，它必须通过调用实现<xref:System.Drawing.Imaging.Metafile.PlayRecord%2A>方法的特定于<xref:System.Drawing.Imaging.Metafile>正在枚举。  
  
   
  
## Examples  
 有关代码示例，请参阅 <xref:System.Drawing.Graphics.EnumerateMetafile%28System.Drawing.Imaging.Metafile%2CSystem.Drawing.Point%2CSystem.Drawing.Graphics.EnumerateMetafileProc%29>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EnumerateMetafile">
      <MemberSignature Language="C#" Value="public void EnumerateMetafile (System.Drawing.Imaging.Metafile metafile, System.Drawing.PointF destPoint, System.Drawing.Graphics.EnumerateMetafileProc callback, IntPtr callbackData);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EnumerateMetafile(class System.Drawing.Imaging.Metafile metafile, valuetype System.Drawing.PointF destPoint, class System.Drawing.Graphics/EnumerateMetafileProc callback, native int callbackData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.EnumerateMetafile(System.Drawing.Imaging.Metafile,System.Drawing.PointF,System.Drawing.Graphics.EnumerateMetafileProc,System.IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EnumerateMetafile(System::Drawing::Imaging::Metafile ^ metafile, System::Drawing::PointF destPoint, System::Drawing::Graphics::EnumerateMetafileProc ^ callback, IntPtr callbackData);" />
      <MemberSignature Language="F#" Value="member this.EnumerateMetafile : System.Drawing.Imaging.Metafile * System.Drawing.PointF * System.Drawing.Graphics.EnumerateMetafileProc * nativeint -&gt; unit" Usage="graphics.EnumerateMetafile (metafile, destPoint, callback, callbackData)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metafile" Type="System.Drawing.Imaging.Metafile" />
        <Parameter Name="destPoint" Type="System.Drawing.PointF" />
        <Parameter Name="callback" Type="System.Drawing.Graphics+EnumerateMetafileProc" />
        <Parameter Name="callbackData" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="metafile">要枚举的 <see cref="T:System.Drawing.Imaging.Metafile" />。</param>
        <param name="destPoint">
          <see cref="T:System.Drawing.PointF" /> 结构，它指定所绘制图元文件的左上角的位置。</param>
        <param name="callback">
          <see cref="T:System.Drawing.Graphics.EnumerateMetafileProc" /> 委托，它指定将图元文件记录发送到的方法。</param>
        <param name="callbackData">必需但被忽略的内部指针。 可以为此参数传递 <see cref="F:System.IntPtr.Zero" />。</param>
        <summary>将指定 <see cref="T:System.Drawing.Imaging.Metafile" /> 中的记录逐个发送到回调方法以在指定的点处显示。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法枚举指定图元文件中包含的记录。 每个记录分别发送到回调方法，通过指定`callback`参数。 通常情况下，回调方法调用<xref:System.Drawing.Imaging.Metafile.PlayRecord%2A>"播放"，或绘图、 记录的方法。  
  
 如果回调方法调用<xref:System.Drawing.Imaging.Metafile.PlayRecord%2A>，它必须通过调用实现<xref:System.Drawing.Imaging.Metafile.PlayRecord%2A>方法的特定于<xref:System.Drawing.Imaging.Metafile>正在枚举。  
  
   
  
## Examples  
 有关代码示例，请参阅 <xref:System.Drawing.Graphics.EnumerateMetafile%28System.Drawing.Imaging.Metafile%2CSystem.Drawing.Point%2CSystem.Drawing.Graphics.EnumerateMetafileProc%29>。  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">图像、位图和图元文件</related>
      </Docs>
    </Member>
    <Member MemberName="EnumerateMetafile">
      <MemberSignature Language="C#" Value="public void EnumerateMetafile (System.Drawing.Imaging.Metafile metafile, System.Drawing.PointF[] destPoints, System.Drawing.Graphics.EnumerateMetafileProc callback, IntPtr callbackData);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EnumerateMetafile(class System.Drawing.Imaging.Metafile metafile, valuetype System.Drawing.PointF[] destPoints, class System.Drawing.Graphics/EnumerateMetafileProc callback, native int callbackData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.EnumerateMetafile(System.Drawing.Imaging.Metafile,System.Drawing.PointF[],System.Drawing.Graphics.EnumerateMetafileProc,System.IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EnumerateMetafile(System::Drawing::Imaging::Metafile ^ metafile, cli::array &lt;System::Drawing::PointF&gt; ^ destPoints, System::Drawing::Graphics::EnumerateMetafileProc ^ callback, IntPtr callbackData);" />
      <MemberSignature Language="F#" Value="member this.EnumerateMetafile : System.Drawing.Imaging.Metafile * System.Drawing.PointF[] * System.Drawing.Graphics.EnumerateMetafileProc * nativeint -&gt; unit" Usage="graphics.EnumerateMetafile (metafile, destPoints, callback, callbackData)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metafile" Type="System.Drawing.Imaging.Metafile" />
        <Parameter Name="destPoints" Type="System.Drawing.PointF[]" />
        <Parameter Name="callback" Type="System.Drawing.Graphics+EnumerateMetafileProc" />
        <Parameter Name="callbackData" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="metafile">要枚举的 <see cref="T:System.Drawing.Imaging.Metafile" />。</param>
        <param name="destPoints">由三个 <see cref="T:System.Drawing.PointF" /> 结构组成的数组，这三个结构定义一个用来确定所绘制图元文件的大小和位置的平行四边形。</param>
        <param name="callback">
          <see cref="T:System.Drawing.Graphics.EnumerateMetafileProc" /> 委托，它指定将图元文件记录发送到的方法。</param>
        <param name="callbackData">必需但被忽略的内部指针。 可以为此参数传递 <see cref="F:System.IntPtr.Zero" />。</param>
        <summary>将指定 <see cref="T:System.Drawing.Imaging.Metafile" /> 中的记录逐个发送到回调方法以在指定的平行四边形中显示。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法枚举指定图元文件中包含的记录。 每个记录分别发送到回调方法，通过指定`callback`参数。 通常情况下，回调方法调用<xref:System.Drawing.Imaging.Metafile.PlayRecord%2A>"播放"，或绘图、 记录的方法。  
  
 如果回调方法调用<xref:System.Drawing.Imaging.Metafile.PlayRecord%2A>，它必须通过调用实现<xref:System.Drawing.Imaging.Metafile.PlayRecord%2A>方法的特定于<xref:System.Drawing.Imaging.Metafile>正在枚举。  
  
 `destPoints`参数指定的平行四边形的三个点。 这三个<xref:System.Drawing.PointF>结构表示的平行四边形的左上角、 右上方和左下角。 第四个点推断出的前三个以形成一个平行四边形。 缩放和剪切以适合的平行四边形绘制图元文件。  
  
   
  
## Examples  
 有关代码示例，请参阅 <xref:System.Drawing.Graphics.EnumerateMetafile%28System.Drawing.Imaging.Metafile%2CSystem.Drawing.Point%2CSystem.Drawing.Graphics.EnumerateMetafileProc%29>。  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">图像、位图和图元文件</related>
      </Docs>
    </Member>
    <Member MemberName="EnumerateMetafile">
      <MemberSignature Language="C#" Value="public void EnumerateMetafile (System.Drawing.Imaging.Metafile metafile, System.Drawing.Rectangle destRect, System.Drawing.Graphics.EnumerateMetafileProc callback, IntPtr callbackData);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EnumerateMetafile(class System.Drawing.Imaging.Metafile metafile, valuetype System.Drawing.Rectangle destRect, class System.Drawing.Graphics/EnumerateMetafileProc callback, native int callbackData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.EnumerateMetafile(System.Drawing.Imaging.Metafile,System.Drawing.Rectangle,System.Drawing.Graphics.EnumerateMetafileProc,System.IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EnumerateMetafile(System::Drawing::Imaging::Metafile ^ metafile, System::Drawing::Rectangle destRect, System::Drawing::Graphics::EnumerateMetafileProc ^ callback, IntPtr callbackData);" />
      <MemberSignature Language="F#" Value="member this.EnumerateMetafile : System.Drawing.Imaging.Metafile * System.Drawing.Rectangle * System.Drawing.Graphics.EnumerateMetafileProc * nativeint -&gt; unit" Usage="graphics.EnumerateMetafile (metafile, destRect, callback, callbackData)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metafile" Type="System.Drawing.Imaging.Metafile" />
        <Parameter Name="destRect" Type="System.Drawing.Rectangle" />
        <Parameter Name="callback" Type="System.Drawing.Graphics+EnumerateMetafileProc" />
        <Parameter Name="callbackData" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="metafile">要枚举的 <see cref="T:System.Drawing.Imaging.Metafile" />。</param>
        <param name="destRect">
          <see cref="T:System.Drawing.Rectangle" /> 结构，它指定所绘制图元文件的位置和大小。</param>
        <param name="callback">
          <see cref="T:System.Drawing.Graphics.EnumerateMetafileProc" /> 委托，它指定将图元文件记录发送到的方法。</param>
        <param name="callbackData">必需但被忽略的内部指针。 可以为此参数传递 <see cref="F:System.IntPtr.Zero" />。</param>
        <summary>将指定 <see cref="T:System.Drawing.Imaging.Metafile" /> 中的记录逐个发送到回调方法以在指定的矩形中显示。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法枚举指定图元文件中包含的记录。 每个记录分别发送到回调方法，通过指定`callback`参数。 通常情况下，回调方法调用<xref:System.Drawing.Imaging.Metafile.PlayRecord%2A>"播放"，或绘图、 记录的方法。  
  
 如果回调方法调用<xref:System.Drawing.Imaging.Metafile.PlayRecord%2A>，它必须通过调用实现<xref:System.Drawing.Imaging.Metafile.PlayRecord%2A>方法的特定于<xref:System.Drawing.Imaging.Metafile>正在枚举。  
  
   
  
## Examples  
 有关代码示例，请参阅 <xref:System.Drawing.Graphics.EnumerateMetafile%28System.Drawing.Imaging.Metafile%2CSystem.Drawing.Point%2CSystem.Drawing.Graphics.EnumerateMetafileProc%29>。  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">图像、位图和图元文件</related>
      </Docs>
    </Member>
    <Member MemberName="EnumerateMetafile">
      <MemberSignature Language="C#" Value="public void EnumerateMetafile (System.Drawing.Imaging.Metafile metafile, System.Drawing.RectangleF destRect, System.Drawing.Graphics.EnumerateMetafileProc callback, IntPtr callbackData);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EnumerateMetafile(class System.Drawing.Imaging.Metafile metafile, valuetype System.Drawing.RectangleF destRect, class System.Drawing.Graphics/EnumerateMetafileProc callback, native int callbackData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.EnumerateMetafile(System.Drawing.Imaging.Metafile,System.Drawing.RectangleF,System.Drawing.Graphics.EnumerateMetafileProc,System.IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EnumerateMetafile(System::Drawing::Imaging::Metafile ^ metafile, System::Drawing::RectangleF destRect, System::Drawing::Graphics::EnumerateMetafileProc ^ callback, IntPtr callbackData);" />
      <MemberSignature Language="F#" Value="member this.EnumerateMetafile : System.Drawing.Imaging.Metafile * System.Drawing.RectangleF * System.Drawing.Graphics.EnumerateMetafileProc * nativeint -&gt; unit" Usage="graphics.EnumerateMetafile (metafile, destRect, callback, callbackData)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metafile" Type="System.Drawing.Imaging.Metafile" />
        <Parameter Name="destRect" Type="System.Drawing.RectangleF" />
        <Parameter Name="callback" Type="System.Drawing.Graphics+EnumerateMetafileProc" />
        <Parameter Name="callbackData" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="metafile">要枚举的 <see cref="T:System.Drawing.Imaging.Metafile" />。</param>
        <param name="destRect">
          <see cref="T:System.Drawing.RectangleF" /> 结构，它指定所绘制图元文件的位置和大小。</param>
        <param name="callback">
          <see cref="T:System.Drawing.Graphics.EnumerateMetafileProc" /> 委托，它指定将图元文件记录发送到的方法。</param>
        <param name="callbackData">必需但被忽略的内部指针。 可以为此参数传递 <see cref="F:System.IntPtr.Zero" />。</param>
        <summary>将指定 <see cref="T:System.Drawing.Imaging.Metafile" /> 中的记录逐个发送到回调方法以在指定的矩形中显示。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法枚举指定图元文件中包含的记录。 每个记录分别发送到回调方法，通过指定`callback`参数。 通常情况下，回调方法调用<xref:System.Drawing.Imaging.Metafile.PlayRecord%2A>"播放"，或绘图、 记录的方法。  
  
 如果回调方法调用<xref:System.Drawing.Imaging.Metafile.PlayRecord%2A>，它必须通过调用实现<xref:System.Drawing.Imaging.Metafile.PlayRecord%2A>方法的特定于<xref:System.Drawing.Imaging.Metafile>正在枚举。  
  
   
  
## Examples  
 有关代码示例，请参阅 <xref:System.Drawing.Graphics.EnumerateMetafile%28System.Drawing.Imaging.Metafile%2CSystem.Drawing.Point%2CSystem.Drawing.Graphics.EnumerateMetafileProc%29>。  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">图像、位图和图元文件</related>
      </Docs>
    </Member>
    <Member MemberName="EnumerateMetafile">
      <MemberSignature Language="C#" Value="public void EnumerateMetafile (System.Drawing.Imaging.Metafile metafile, System.Drawing.Point destPoint, System.Drawing.Graphics.EnumerateMetafileProc callback, IntPtr callbackData, System.Drawing.Imaging.ImageAttributes imageAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EnumerateMetafile(class System.Drawing.Imaging.Metafile metafile, valuetype System.Drawing.Point destPoint, class System.Drawing.Graphics/EnumerateMetafileProc callback, native int callbackData, class System.Drawing.Imaging.ImageAttributes imageAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.EnumerateMetafile(System.Drawing.Imaging.Metafile,System.Drawing.Point,System.Drawing.Graphics.EnumerateMetafileProc,System.IntPtr,System.Drawing.Imaging.ImageAttributes)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EnumerateMetafile(System::Drawing::Imaging::Metafile ^ metafile, System::Drawing::Point destPoint, System::Drawing::Graphics::EnumerateMetafileProc ^ callback, IntPtr callbackData, System::Drawing::Imaging::ImageAttributes ^ imageAttr);" />
      <MemberSignature Language="F#" Value="member this.EnumerateMetafile : System.Drawing.Imaging.Metafile * System.Drawing.Point * System.Drawing.Graphics.EnumerateMetafileProc * nativeint * System.Drawing.Imaging.ImageAttributes -&gt; unit" Usage="graphics.EnumerateMetafile (metafile, destPoint, callback, callbackData, imageAttr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metafile" Type="System.Drawing.Imaging.Metafile" />
        <Parameter Name="destPoint" Type="System.Drawing.Point" />
        <Parameter Name="callback" Type="System.Drawing.Graphics+EnumerateMetafileProc" />
        <Parameter Name="callbackData" Type="System.IntPtr" />
        <Parameter Name="imageAttr" Type="System.Drawing.Imaging.ImageAttributes" />
      </Parameters>
      <Docs>
        <param name="metafile">要枚举的 <see cref="T:System.Drawing.Imaging.Metafile" />。</param>
        <param name="destPoint">
          <see cref="T:System.Drawing.Point" /> 结构，它指定所绘制图元文件的左上角的位置。</param>
        <param name="callback">
          <see cref="T:System.Drawing.Graphics.EnumerateMetafileProc" /> 委托，它指定将图元文件记录发送到的方法。</param>
        <param name="callbackData">必需但被忽略的内部指针。 可以为此参数传递 <see cref="F:System.IntPtr.Zero" />。</param>
        <param name="imageAttr">
          <see cref="T:System.Drawing.Imaging.ImageAttributes" />，它指定所绘制图像的图像特性信息。</param>
        <summary>将指定 <see cref="T:System.Drawing.Imaging.Metafile" /> 中的记录逐个发送到回调方法，以在指定的点处用指定的图像特性显示。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法枚举指定图元文件中包含的记录。 每个记录分别发送到回调方法，通过指定`callback`参数。 通常情况下，回调方法调用<xref:System.Drawing.Imaging.Metafile.PlayRecord%2A>"播放"，或绘图、 记录的方法。  
  
 如果回调方法调用<xref:System.Drawing.Imaging.Metafile.PlayRecord%2A>，它必须通过调用实现<xref:System.Drawing.Imaging.Metafile.PlayRecord%2A>方法的特定于<xref:System.Drawing.Imaging.Metafile>正在枚举。  
  
   
  
## Examples  
 有关代码示例，请参阅 <xref:System.Drawing.Graphics.EnumerateMetafile%28System.Drawing.Imaging.Metafile%2CSystem.Drawing.Point%2CSystem.Drawing.Graphics.EnumerateMetafileProc%29>。  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">图像、位图和图元文件</related>
      </Docs>
    </Member>
    <Member MemberName="EnumerateMetafile">
      <MemberSignature Language="C#" Value="public void EnumerateMetafile (System.Drawing.Imaging.Metafile metafile, System.Drawing.Point destPoint, System.Drawing.Rectangle srcRect, System.Drawing.GraphicsUnit srcUnit, System.Drawing.Graphics.EnumerateMetafileProc callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EnumerateMetafile(class System.Drawing.Imaging.Metafile metafile, valuetype System.Drawing.Point destPoint, valuetype System.Drawing.Rectangle srcRect, valuetype System.Drawing.GraphicsUnit srcUnit, class System.Drawing.Graphics/EnumerateMetafileProc callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.EnumerateMetafile(System.Drawing.Imaging.Metafile,System.Drawing.Point,System.Drawing.Rectangle,System.Drawing.GraphicsUnit,System.Drawing.Graphics.EnumerateMetafileProc)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EnumerateMetafile(System::Drawing::Imaging::Metafile ^ metafile, System::Drawing::Point destPoint, System::Drawing::Rectangle srcRect, System::Drawing::GraphicsUnit srcUnit, System::Drawing::Graphics::EnumerateMetafileProc ^ callback);" />
      <MemberSignature Language="F#" Value="member this.EnumerateMetafile : System.Drawing.Imaging.Metafile * System.Drawing.Point * System.Drawing.Rectangle * System.Drawing.GraphicsUnit * System.Drawing.Graphics.EnumerateMetafileProc -&gt; unit" Usage="graphics.EnumerateMetafile (metafile, destPoint, srcRect, srcUnit, callback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metafile" Type="System.Drawing.Imaging.Metafile" />
        <Parameter Name="destPoint" Type="System.Drawing.Point" />
        <Parameter Name="srcRect" Type="System.Drawing.Rectangle" />
        <Parameter Name="srcUnit" Type="System.Drawing.GraphicsUnit" />
        <Parameter Name="callback" Type="System.Drawing.Graphics+EnumerateMetafileProc" />
      </Parameters>
      <Docs>
        <param name="metafile">要枚举的 <see cref="T:System.Drawing.Imaging.Metafile" />。</param>
        <param name="destPoint">
          <see cref="T:System.Drawing.Point" /> 结构，它指定所绘制图元文件的左上角的位置。</param>
        <param name="srcRect">
          <see cref="T:System.Drawing.Rectangle" /> 结构，它相对于图元文件的左上角指定要绘制的部分图元文件。</param>
        <param name="srcUnit">
          <see cref="T:System.Drawing.GraphicsUnit" /> 枚举的成员，它指定度量单位，该度量单位用于确定 <c>srcRect</c> 参数指定的矩形所包含的部分图元文件。</param>
        <param name="callback">
          <see cref="T:System.Drawing.Graphics.EnumerateMetafileProc" /> 委托，它指定将图元文件记录发送到的方法。</param>
        <summary>将 <see cref="T:System.Drawing.Imaging.Metafile" /> 中选定矩形内的记录逐个发送到回调方法以在指定的点处显示。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法枚举指定图元文件中包含的记录。 每个记录分别发送到回调方法，通过指定`callback`参数。 通常情况下，回调方法调用<xref:System.Drawing.Imaging.Metafile.PlayRecord%2A>"播放"，或绘图、 记录的方法。  
  
 如果回调方法调用<xref:System.Drawing.Imaging.Metafile.PlayRecord%2A>，它必须通过调用实现<xref:System.Drawing.Imaging.Metafile.PlayRecord%2A>方法的特定于<xref:System.Drawing.Imaging.Metafile>正在枚举。  
  
   
  
## Examples  
 有关代码示例，请参阅 <xref:System.Drawing.Graphics.EnumerateMetafile%28System.Drawing.Imaging.Metafile%2CSystem.Drawing.Point%2CSystem.Drawing.Graphics.EnumerateMetafileProc%29>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EnumerateMetafile">
      <MemberSignature Language="C#" Value="public void EnumerateMetafile (System.Drawing.Imaging.Metafile metafile, System.Drawing.Point[] destPoints, System.Drawing.Graphics.EnumerateMetafileProc callback, IntPtr callbackData, System.Drawing.Imaging.ImageAttributes imageAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EnumerateMetafile(class System.Drawing.Imaging.Metafile metafile, valuetype System.Drawing.Point[] destPoints, class System.Drawing.Graphics/EnumerateMetafileProc callback, native int callbackData, class System.Drawing.Imaging.ImageAttributes imageAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.EnumerateMetafile(System.Drawing.Imaging.Metafile,System.Drawing.Point[],System.Drawing.Graphics.EnumerateMetafileProc,System.IntPtr,System.Drawing.Imaging.ImageAttributes)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EnumerateMetafile(System::Drawing::Imaging::Metafile ^ metafile, cli::array &lt;System::Drawing::Point&gt; ^ destPoints, System::Drawing::Graphics::EnumerateMetafileProc ^ callback, IntPtr callbackData, System::Drawing::Imaging::ImageAttributes ^ imageAttr);" />
      <MemberSignature Language="F#" Value="member this.EnumerateMetafile : System.Drawing.Imaging.Metafile * System.Drawing.Point[] * System.Drawing.Graphics.EnumerateMetafileProc * nativeint * System.Drawing.Imaging.ImageAttributes -&gt; unit" Usage="graphics.EnumerateMetafile (metafile, destPoints, callback, callbackData, imageAttr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metafile" Type="System.Drawing.Imaging.Metafile" />
        <Parameter Name="destPoints" Type="System.Drawing.Point[]" />
        <Parameter Name="callback" Type="System.Drawing.Graphics+EnumerateMetafileProc" />
        <Parameter Name="callbackData" Type="System.IntPtr" />
        <Parameter Name="imageAttr" Type="System.Drawing.Imaging.ImageAttributes" />
      </Parameters>
      <Docs>
        <param name="metafile">要枚举的 <see cref="T:System.Drawing.Imaging.Metafile" />。</param>
        <param name="destPoints">由三个 <see cref="T:System.Drawing.Point" /> 结构组成的数组，这三个结构定义一个用来确定所绘制图元文件的大小和位置的平行四边形。</param>
        <param name="callback">
          <see cref="T:System.Drawing.Graphics.EnumerateMetafileProc" /> 委托，它指定将图元文件记录发送到的方法。</param>
        <param name="callbackData">必需但被忽略的内部指针。 可以为此参数传递 <see cref="F:System.IntPtr.Zero" />。</param>
        <param name="imageAttr">
          <see cref="T:System.Drawing.Imaging.ImageAttributes" />，它指定所绘制图像的图像特性信息。</param>
        <summary>将指定 <see cref="T:System.Drawing.Imaging.Metafile" /> 中的记录逐个发送到回调方法，以在指定的平行四边形中用指定的图像特性显示。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法枚举指定图元文件中包含的记录。 每个记录分别发送到回调方法，通过指定`callback`参数。 通常情况下，回调方法调用<xref:System.Drawing.Imaging.Metafile.PlayRecord%2A>"播放"，或绘图、 记录的方法。  
  
 如果回调方法调用<xref:System.Drawing.Imaging.Metafile.PlayRecord%2A>，它必须通过调用实现<xref:System.Drawing.Imaging.Metafile.PlayRecord%2A>方法的特定于<xref:System.Drawing.Imaging.Metafile>正在枚举。  
  
 `destPoints`参数指定的平行四边形的三个点。 这三个<xref:System.Drawing.Point>结构表示的平行四边形的左上角、 右上方和左下角。 第四个点推断出的前三个以形成一个平行四边形。 缩放和剪切以适合的平行四边形绘制图元文件。  
  
 指定的图像特性`imageAttr`指定何时写入图元文件的那些参数替换。  
  
   
  
## Examples  
 有关代码示例，请参阅 <xref:System.Drawing.Graphics.EnumerateMetafile%28System.Drawing.Imaging.Metafile%2CSystem.Drawing.Point%2CSystem.Drawing.Graphics.EnumerateMetafileProc%29>。  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">图像、位图和图元文件</related>
      </Docs>
    </Member>
    <Member MemberName="EnumerateMetafile">
      <MemberSignature Language="C#" Value="public void EnumerateMetafile (System.Drawing.Imaging.Metafile metafile, System.Drawing.Point[] destPoints, System.Drawing.Rectangle srcRect, System.Drawing.GraphicsUnit srcUnit, System.Drawing.Graphics.EnumerateMetafileProc callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EnumerateMetafile(class System.Drawing.Imaging.Metafile metafile, valuetype System.Drawing.Point[] destPoints, valuetype System.Drawing.Rectangle srcRect, valuetype System.Drawing.GraphicsUnit srcUnit, class System.Drawing.Graphics/EnumerateMetafileProc callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.EnumerateMetafile(System.Drawing.Imaging.Metafile,System.Drawing.Point[],System.Drawing.Rectangle,System.Drawing.GraphicsUnit,System.Drawing.Graphics.EnumerateMetafileProc)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EnumerateMetafile(System::Drawing::Imaging::Metafile ^ metafile, cli::array &lt;System::Drawing::Point&gt; ^ destPoints, System::Drawing::Rectangle srcRect, System::Drawing::GraphicsUnit srcUnit, System::Drawing::Graphics::EnumerateMetafileProc ^ callback);" />
      <MemberSignature Language="F#" Value="member this.EnumerateMetafile : System.Drawing.Imaging.Metafile * System.Drawing.Point[] * System.Drawing.Rectangle * System.Drawing.GraphicsUnit * System.Drawing.Graphics.EnumerateMetafileProc -&gt; unit" Usage="graphics.EnumerateMetafile (metafile, destPoints, srcRect, srcUnit, callback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metafile" Type="System.Drawing.Imaging.Metafile" />
        <Parameter Name="destPoints" Type="System.Drawing.Point[]" />
        <Parameter Name="srcRect" Type="System.Drawing.Rectangle" />
        <Parameter Name="srcUnit" Type="System.Drawing.GraphicsUnit" />
        <Parameter Name="callback" Type="System.Drawing.Graphics+EnumerateMetafileProc" />
      </Parameters>
      <Docs>
        <param name="metafile">要枚举的 <see cref="T:System.Drawing.Imaging.Metafile" />。</param>
        <param name="destPoints">由三个 <see cref="T:System.Drawing.Point" /> 结构组成的数组，这三个结构定义一个用来确定所绘制图元文件的大小和位置的平行四边形。</param>
        <param name="srcRect">
          <see cref="T:System.Drawing.Rectangle" /> 结构，它相对于图元文件的左上角指定要绘制的部分图元文件。</param>
        <param name="srcUnit">
          <see cref="T:System.Drawing.GraphicsUnit" /> 枚举的成员，它指定度量单位，该度量单位用于确定 <c>srcRect</c> 参数指定的矩形所包含的部分图元文件。</param>
        <param name="callback">
          <see cref="T:System.Drawing.Graphics.EnumerateMetafileProc" /> 委托，它指定将图元文件记录发送到的方法。</param>
        <summary>将 <see cref="T:System.Drawing.Imaging.Metafile" /> 中选定矩形内的记录逐个发送到回调方法以在指定的平行四边形中显示。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法枚举指定图元文件中包含的记录。 每个记录分别发送到回调方法，通过指定`callback`参数。 通常情况下，回调方法调用<xref:System.Drawing.Imaging.Metafile.PlayRecord%2A>"播放"，或绘图、 记录的方法。  
  
 如果回调方法调用<xref:System.Drawing.Imaging.Metafile.PlayRecord%2A>，它必须通过调用实现<xref:System.Drawing.Imaging.Metafile.PlayRecord%2A>方法的特定于<xref:System.Drawing.Imaging.Metafile>正在枚举。  
  
 `destPoints`参数指定的平行四边形的三个点。 这三个<xref:System.Drawing.Point>结构表示的平行四边形的左上角、 右上方和左下角。 第四个点推断出的前三个以形成一个平行四边形。 缩放和剪切以适合的平行四边形绘制图元文件。  
  
 指定的矩形之外的任何绘制发生`srcRect`参数将被忽略。  
  
   
  
## Examples  
 有关代码示例，请参阅 <xref:System.Drawing.Graphics.EnumerateMetafile%28System.Drawing.Imaging.Metafile%2CSystem.Drawing.Point%2CSystem.Drawing.Graphics.EnumerateMetafileProc%29>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EnumerateMetafile">
      <MemberSignature Language="C#" Value="public void EnumerateMetafile (System.Drawing.Imaging.Metafile metafile, System.Drawing.PointF destPoint, System.Drawing.Graphics.EnumerateMetafileProc callback, IntPtr callbackData, System.Drawing.Imaging.ImageAttributes imageAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EnumerateMetafile(class System.Drawing.Imaging.Metafile metafile, valuetype System.Drawing.PointF destPoint, class System.Drawing.Graphics/EnumerateMetafileProc callback, native int callbackData, class System.Drawing.Imaging.ImageAttributes imageAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.EnumerateMetafile(System.Drawing.Imaging.Metafile,System.Drawing.PointF,System.Drawing.Graphics.EnumerateMetafileProc,System.IntPtr,System.Drawing.Imaging.ImageAttributes)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EnumerateMetafile(System::Drawing::Imaging::Metafile ^ metafile, System::Drawing::PointF destPoint, System::Drawing::Graphics::EnumerateMetafileProc ^ callback, IntPtr callbackData, System::Drawing::Imaging::ImageAttributes ^ imageAttr);" />
      <MemberSignature Language="F#" Value="member this.EnumerateMetafile : System.Drawing.Imaging.Metafile * System.Drawing.PointF * System.Drawing.Graphics.EnumerateMetafileProc * nativeint * System.Drawing.Imaging.ImageAttributes -&gt; unit" Usage="graphics.EnumerateMetafile (metafile, destPoint, callback, callbackData, imageAttr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metafile" Type="System.Drawing.Imaging.Metafile" />
        <Parameter Name="destPoint" Type="System.Drawing.PointF" />
        <Parameter Name="callback" Type="System.Drawing.Graphics+EnumerateMetafileProc" />
        <Parameter Name="callbackData" Type="System.IntPtr" />
        <Parameter Name="imageAttr" Type="System.Drawing.Imaging.ImageAttributes" />
      </Parameters>
      <Docs>
        <param name="metafile">要枚举的 <see cref="T:System.Drawing.Imaging.Metafile" />。</param>
        <param name="destPoint">
          <see cref="T:System.Drawing.PointF" /> 结构，它指定所绘制图元文件的左上角的位置。</param>
        <param name="callback">
          <see cref="T:System.Drawing.Graphics.EnumerateMetafileProc" /> 委托，它指定将图元文件记录发送到的方法。</param>
        <param name="callbackData">必需但被忽略的内部指针。 可以为此参数传递 <see cref="F:System.IntPtr.Zero" />。</param>
        <param name="imageAttr">
          <see cref="T:System.Drawing.Imaging.ImageAttributes" />，它指定所绘制图像的图像特性信息。</param>
        <summary>将指定 <see cref="T:System.Drawing.Imaging.Metafile" /> 中的记录逐个发送到回调方法，以在指定的点处用指定的图像特性显示。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法枚举指定图元文件中包含的记录。 每个记录分别发送到回调方法，通过指定`callback`参数。 通常情况下，回调方法调用<xref:System.Drawing.Imaging.Metafile.PlayRecord%2A>"播放"，或绘图、 记录的方法。  
  
 如果回调方法调用<xref:System.Drawing.Imaging.Metafile.PlayRecord%2A>，它必须通过调用特定的方法来实现<xref:System.Drawing.Imaging.Metafile>正在枚举。  
  
 指定的图像特性`imageAttr`指定何时写入图元文件的那些参数替换。  
  
   
  
## Examples  
 有关代码示例，请参阅 <xref:System.Drawing.Graphics.EnumerateMetafile%28System.Drawing.Imaging.Metafile%2CSystem.Drawing.Point%2CSystem.Drawing.Graphics.EnumerateMetafileProc%29>。  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">图像、位图和图元文件</related>
      </Docs>
    </Member>
    <Member MemberName="EnumerateMetafile">
      <MemberSignature Language="C#" Value="public void EnumerateMetafile (System.Drawing.Imaging.Metafile metafile, System.Drawing.PointF destPoint, System.Drawing.RectangleF srcRect, System.Drawing.GraphicsUnit srcUnit, System.Drawing.Graphics.EnumerateMetafileProc callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EnumerateMetafile(class System.Drawing.Imaging.Metafile metafile, valuetype System.Drawing.PointF destPoint, valuetype System.Drawing.RectangleF srcRect, valuetype System.Drawing.GraphicsUnit srcUnit, class System.Drawing.Graphics/EnumerateMetafileProc callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.EnumerateMetafile(System.Drawing.Imaging.Metafile,System.Drawing.PointF,System.Drawing.RectangleF,System.Drawing.GraphicsUnit,System.Drawing.Graphics.EnumerateMetafileProc)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EnumerateMetafile(System::Drawing::Imaging::Metafile ^ metafile, System::Drawing::PointF destPoint, System::Drawing::RectangleF srcRect, System::Drawing::GraphicsUnit srcUnit, System::Drawing::Graphics::EnumerateMetafileProc ^ callback);" />
      <MemberSignature Language="F#" Value="member this.EnumerateMetafile : System.Drawing.Imaging.Metafile * System.Drawing.PointF * System.Drawing.RectangleF * System.Drawing.GraphicsUnit * System.Drawing.Graphics.EnumerateMetafileProc -&gt; unit" Usage="graphics.EnumerateMetafile (metafile, destPoint, srcRect, srcUnit, callback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metafile" Type="System.Drawing.Imaging.Metafile" />
        <Parameter Name="destPoint" Type="System.Drawing.PointF" />
        <Parameter Name="srcRect" Type="System.Drawing.RectangleF" />
        <Parameter Name="srcUnit" Type="System.Drawing.GraphicsUnit" />
        <Parameter Name="callback" Type="System.Drawing.Graphics+EnumerateMetafileProc" />
      </Parameters>
      <Docs>
        <param name="metafile">要枚举的 <see cref="T:System.Drawing.Imaging.Metafile" />。</param>
        <param name="destPoint">
          <see cref="T:System.Drawing.PointF" /> 结构，它指定所绘制图元文件的左上角的位置。</param>
        <param name="srcRect">
          <see cref="T:System.Drawing.RectangleF" /> 结构，它相对于图元文件的左上角指定要绘制的部分图元文件。</param>
        <param name="srcUnit">
          <see cref="T:System.Drawing.GraphicsUnit" /> 枚举的成员，它指定度量单位，该度量单位用于确定 <c>srcRect</c> 参数指定的矩形所包含的部分图元文件。</param>
        <param name="callback">
          <see cref="T:System.Drawing.Graphics.EnumerateMetafileProc" /> 委托，它指定将图元文件记录发送到的方法。</param>
        <summary>将 <see cref="T:System.Drawing.Imaging.Metafile" /> 中选定矩形内的记录逐个发送到回调方法以在指定的点处显示。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法枚举指定图元文件中包含的记录。 每个记录分别发送到回调方法，通过指定`callback`参数。 通常情况下，回调方法调用<xref:System.Drawing.Imaging.Metafile.PlayRecord%2A>"播放"，或绘图、 记录的方法。  
  
 如果回调方法调用<xref:System.Drawing.Imaging.Metafile.PlayRecord%2A>，它必须通过调用实现<xref:System.Drawing.Imaging.Metafile.PlayRecord%2A>方法的特定于<xref:System.Drawing.Imaging.Metafile>正在枚举。  
  
 指定的矩形之外的任何绘制发生`srcRect`参数将被忽略。  
  
   
  
## Examples  
 有关代码示例，请参阅 <xref:System.Drawing.Graphics.EnumerateMetafile%28System.Drawing.Imaging.Metafile%2CSystem.Drawing.Point%2CSystem.Drawing.Graphics.EnumerateMetafileProc%29>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EnumerateMetafile">
      <MemberSignature Language="C#" Value="public void EnumerateMetafile (System.Drawing.Imaging.Metafile metafile, System.Drawing.PointF[] destPoints, System.Drawing.Graphics.EnumerateMetafileProc callback, IntPtr callbackData, System.Drawing.Imaging.ImageAttributes imageAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EnumerateMetafile(class System.Drawing.Imaging.Metafile metafile, valuetype System.Drawing.PointF[] destPoints, class System.Drawing.Graphics/EnumerateMetafileProc callback, native int callbackData, class System.Drawing.Imaging.ImageAttributes imageAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.EnumerateMetafile(System.Drawing.Imaging.Metafile,System.Drawing.PointF[],System.Drawing.Graphics.EnumerateMetafileProc,System.IntPtr,System.Drawing.Imaging.ImageAttributes)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EnumerateMetafile(System::Drawing::Imaging::Metafile ^ metafile, cli::array &lt;System::Drawing::PointF&gt; ^ destPoints, System::Drawing::Graphics::EnumerateMetafileProc ^ callback, IntPtr callbackData, System::Drawing::Imaging::ImageAttributes ^ imageAttr);" />
      <MemberSignature Language="F#" Value="member this.EnumerateMetafile : System.Drawing.Imaging.Metafile * System.Drawing.PointF[] * System.Drawing.Graphics.EnumerateMetafileProc * nativeint * System.Drawing.Imaging.ImageAttributes -&gt; unit" Usage="graphics.EnumerateMetafile (metafile, destPoints, callback, callbackData, imageAttr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metafile" Type="System.Drawing.Imaging.Metafile" />
        <Parameter Name="destPoints" Type="System.Drawing.PointF[]" />
        <Parameter Name="callback" Type="System.Drawing.Graphics+EnumerateMetafileProc" />
        <Parameter Name="callbackData" Type="System.IntPtr" />
        <Parameter Name="imageAttr" Type="System.Drawing.Imaging.ImageAttributes" />
      </Parameters>
      <Docs>
        <param name="metafile">要枚举的 <see cref="T:System.Drawing.Imaging.Metafile" />。</param>
        <param name="destPoints">由三个 <see cref="T:System.Drawing.PointF" /> 结构组成的数组，这三个结构定义一个用来确定所绘制图元文件的大小和位置的平行四边形。</param>
        <param name="callback">
          <see cref="T:System.Drawing.Graphics.EnumerateMetafileProc" /> 委托，它指定将图元文件记录发送到的方法。</param>
        <param name="callbackData">必需但被忽略的内部指针。 可以为此参数传递 <see cref="F:System.IntPtr.Zero" />。</param>
        <param name="imageAttr">
          <see cref="T:System.Drawing.Imaging.ImageAttributes" />，它指定所绘制图像的图像特性信息。</param>
        <summary>将指定 <see cref="T:System.Drawing.Imaging.Metafile" /> 中的记录逐个发送到回调方法，以在指定的平行四边形中用指定的图像特性显示。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法枚举指定图元文件中包含的记录。 每个记录分别发送到回调方法，通过指定`callback`参数。 通常情况下，回调方法调用<xref:System.Drawing.Imaging.Metafile.PlayRecord%2A>"播放"，或绘图、 记录的方法。  
  
 如果回调方法调用<xref:System.Drawing.Imaging.Metafile.PlayRecord%2A>，它必须通过调用实现<xref:System.Drawing.Imaging.Metafile.PlayRecord%2A>方法的特定于<xref:System.Drawing.Imaging.Metafile>正在枚举。  
  
 `destPoints`参数指定的平行四边形的三个点。 这三个<xref:System.Drawing.PointF>结构表示的平行四边形的左上角、 右上方和左下角。 第四个点推断出的前三个以形成一个平行四边形。 缩放和剪切以适合的平行四边形绘制图元文件。  
  
 指定的图像特性`imageAttr`指定何时写入图元文件的那些参数替换。  
  
   
  
## Examples  
 有关代码示例，请参阅 <xref:System.Drawing.Graphics.EnumerateMetafile%28System.Drawing.Imaging.Metafile%2CSystem.Drawing.Point%2CSystem.Drawing.Graphics.EnumerateMetafileProc%29>。  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">图像、位图和图元文件</related>
      </Docs>
    </Member>
    <Member MemberName="EnumerateMetafile">
      <MemberSignature Language="C#" Value="public void EnumerateMetafile (System.Drawing.Imaging.Metafile metafile, System.Drawing.PointF[] destPoints, System.Drawing.RectangleF srcRect, System.Drawing.GraphicsUnit srcUnit, System.Drawing.Graphics.EnumerateMetafileProc callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EnumerateMetafile(class System.Drawing.Imaging.Metafile metafile, valuetype System.Drawing.PointF[] destPoints, valuetype System.Drawing.RectangleF srcRect, valuetype System.Drawing.GraphicsUnit srcUnit, class System.Drawing.Graphics/EnumerateMetafileProc callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.EnumerateMetafile(System.Drawing.Imaging.Metafile,System.Drawing.PointF[],System.Drawing.RectangleF,System.Drawing.GraphicsUnit,System.Drawing.Graphics.EnumerateMetafileProc)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EnumerateMetafile(System::Drawing::Imaging::Metafile ^ metafile, cli::array &lt;System::Drawing::PointF&gt; ^ destPoints, System::Drawing::RectangleF srcRect, System::Drawing::GraphicsUnit srcUnit, System::Drawing::Graphics::EnumerateMetafileProc ^ callback);" />
      <MemberSignature Language="F#" Value="member this.EnumerateMetafile : System.Drawing.Imaging.Metafile * System.Drawing.PointF[] * System.Drawing.RectangleF * System.Drawing.GraphicsUnit * System.Drawing.Graphics.EnumerateMetafileProc -&gt; unit" Usage="graphics.EnumerateMetafile (metafile, destPoints, srcRect, srcUnit, callback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metafile" Type="System.Drawing.Imaging.Metafile" />
        <Parameter Name="destPoints" Type="System.Drawing.PointF[]" />
        <Parameter Name="srcRect" Type="System.Drawing.RectangleF" />
        <Parameter Name="srcUnit" Type="System.Drawing.GraphicsUnit" />
        <Parameter Name="callback" Type="System.Drawing.Graphics+EnumerateMetafileProc" />
      </Parameters>
      <Docs>
        <param name="metafile">要枚举的 <see cref="T:System.Drawing.Imaging.Metafile" />。</param>
        <param name="destPoints">由三个 <see cref="T:System.Drawing.PointF" /> 结构组成的数组，这三个结构定义一个用来确定所绘制图元文件的大小和位置的平行四边形。</param>
        <param name="srcRect">
          <see cref="T:System.Drawing.RectangleF" /> 结构，它相对于图元文件的左上角指定要绘制的部分图元文件。</param>
        <param name="srcUnit">
          <see cref="T:System.Drawing.GraphicsUnit" /> 枚举的成员，它指定度量单位，该度量单位用于确定 <c>srcRect</c> 参数指定的矩形所包含的部分图元文件。</param>
        <param name="callback">
          <see cref="T:System.Drawing.Graphics.EnumerateMetafileProc" /> 委托，它指定将图元文件记录发送到的方法。</param>
        <summary>将 <see cref="T:System.Drawing.Imaging.Metafile" /> 中选定矩形内的记录逐个发送到回调方法以在指定的平行四边形中显示。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法枚举指定图元文件中包含的记录。 每个记录分别发送到回调方法，通过指定`callback`参数。 通常情况下，回调方法调用<xref:System.Drawing.Imaging.Metafile.PlayRecord%2A>"播放"，或绘图、 记录的方法。  
  
 如果回调方法调用<xref:System.Drawing.Imaging.Metafile.PlayRecord%2A>，它必须通过调用实现<xref:System.Drawing.Imaging.Metafile.PlayRecord%2A>方法的特定于<xref:System.Drawing.Imaging.Metafile>正在枚举。  
  
 `destPoints`参数指定的平行四边形的三个点。 这三个<xref:System.Drawing.Point>结构表示的平行四边形的左上角、 右上方和左下角。 第四个点推断出的前三个以形成一个平行四边形。 缩放和剪切以适合的平行四边形绘制图元文件。  
  
 指定的矩形之外的任何绘制发生`srcRect`参数将被忽略。  
  
   
  
## Examples  
 有关代码示例，请参阅 <xref:System.Drawing.Graphics.EnumerateMetafile%28System.Drawing.Imaging.Metafile%2CSystem.Drawing.Point%2CSystem.Drawing.Graphics.EnumerateMetafileProc%29>。  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">图像、位图和图元文件</related>
      </Docs>
    </Member>
    <Member MemberName="EnumerateMetafile">
      <MemberSignature Language="C#" Value="public void EnumerateMetafile (System.Drawing.Imaging.Metafile metafile, System.Drawing.Rectangle destRect, System.Drawing.Graphics.EnumerateMetafileProc callback, IntPtr callbackData, System.Drawing.Imaging.ImageAttributes imageAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EnumerateMetafile(class System.Drawing.Imaging.Metafile metafile, valuetype System.Drawing.Rectangle destRect, class System.Drawing.Graphics/EnumerateMetafileProc callback, native int callbackData, class System.Drawing.Imaging.ImageAttributes imageAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.EnumerateMetafile(System.Drawing.Imaging.Metafile,System.Drawing.Rectangle,System.Drawing.Graphics.EnumerateMetafileProc,System.IntPtr,System.Drawing.Imaging.ImageAttributes)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EnumerateMetafile(System::Drawing::Imaging::Metafile ^ metafile, System::Drawing::Rectangle destRect, System::Drawing::Graphics::EnumerateMetafileProc ^ callback, IntPtr callbackData, System::Drawing::Imaging::ImageAttributes ^ imageAttr);" />
      <MemberSignature Language="F#" Value="member this.EnumerateMetafile : System.Drawing.Imaging.Metafile * System.Drawing.Rectangle * System.Drawing.Graphics.EnumerateMetafileProc * nativeint * System.Drawing.Imaging.ImageAttributes -&gt; unit" Usage="graphics.EnumerateMetafile (metafile, destRect, callback, callbackData, imageAttr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metafile" Type="System.Drawing.Imaging.Metafile" />
        <Parameter Name="destRect" Type="System.Drawing.Rectangle" />
        <Parameter Name="callback" Type="System.Drawing.Graphics+EnumerateMetafileProc" />
        <Parameter Name="callbackData" Type="System.IntPtr" />
        <Parameter Name="imageAttr" Type="System.Drawing.Imaging.ImageAttributes" />
      </Parameters>
      <Docs>
        <param name="metafile">要枚举的 <see cref="T:System.Drawing.Imaging.Metafile" />。</param>
        <param name="destRect">
          <see cref="T:System.Drawing.Rectangle" /> 结构，它指定所绘制图元文件的位置和大小。</param>
        <param name="callback">
          <see cref="T:System.Drawing.Graphics.EnumerateMetafileProc" /> 委托，它指定将图元文件记录发送到的方法。</param>
        <param name="callbackData">必需但被忽略的内部指针。 可以为此参数传递 <see cref="F:System.IntPtr.Zero" />。</param>
        <param name="imageAttr">
          <see cref="T:System.Drawing.Imaging.ImageAttributes" />，它指定所绘制图像的图像特性信息。</param>
        <summary>将指定 <see cref="T:System.Drawing.Imaging.Metafile" /> 中的记录逐个发送到回调方法，以在指定的矩形中用指定的图像特性显示。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法枚举指定图元文件中包含的记录。 每个记录分别发送到回调方法，通过指定`callback`参数。 通常情况下，回调方法调用<xref:System.Drawing.Imaging.Metafile.PlayRecord%2A>"播放"，或绘图、 记录的方法。  
  
 如果回调方法调用<xref:System.Drawing.Imaging.Metafile.PlayRecord%2A>，它必须通过调用实现<xref:System.Drawing.Imaging.Metafile.PlayRecord%2A>方法的特定于<xref:System.Drawing.Imaging.Metafile>正在枚举。  
  
 指定的图像特性`imageAttr`指定何时写入图元文件的那些参数替换。  
  
   
  
## Examples  
 有关代码示例，请参阅 <xref:System.Drawing.Graphics.EnumerateMetafile%28System.Drawing.Imaging.Metafile%2CSystem.Drawing.Point%2CSystem.Drawing.Graphics.EnumerateMetafileProc%29>。  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">图像、位图和图元文件</related>
      </Docs>
    </Member>
    <Member MemberName="EnumerateMetafile">
      <MemberSignature Language="C#" Value="public void EnumerateMetafile (System.Drawing.Imaging.Metafile metafile, System.Drawing.Rectangle destRect, System.Drawing.Rectangle srcRect, System.Drawing.GraphicsUnit srcUnit, System.Drawing.Graphics.EnumerateMetafileProc callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EnumerateMetafile(class System.Drawing.Imaging.Metafile metafile, valuetype System.Drawing.Rectangle destRect, valuetype System.Drawing.Rectangle srcRect, valuetype System.Drawing.GraphicsUnit srcUnit, class System.Drawing.Graphics/EnumerateMetafileProc callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.EnumerateMetafile(System.Drawing.Imaging.Metafile,System.Drawing.Rectangle,System.Drawing.Rectangle,System.Drawing.GraphicsUnit,System.Drawing.Graphics.EnumerateMetafileProc)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EnumerateMetafile(System::Drawing::Imaging::Metafile ^ metafile, System::Drawing::Rectangle destRect, System::Drawing::Rectangle srcRect, System::Drawing::GraphicsUnit srcUnit, System::Drawing::Graphics::EnumerateMetafileProc ^ callback);" />
      <MemberSignature Language="F#" Value="member this.EnumerateMetafile : System.Drawing.Imaging.Metafile * System.Drawing.Rectangle * System.Drawing.Rectangle * System.Drawing.GraphicsUnit * System.Drawing.Graphics.EnumerateMetafileProc -&gt; unit" Usage="graphics.EnumerateMetafile (metafile, destRect, srcRect, srcUnit, callback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metafile" Type="System.Drawing.Imaging.Metafile" />
        <Parameter Name="destRect" Type="System.Drawing.Rectangle" />
        <Parameter Name="srcRect" Type="System.Drawing.Rectangle" />
        <Parameter Name="srcUnit" Type="System.Drawing.GraphicsUnit" />
        <Parameter Name="callback" Type="System.Drawing.Graphics+EnumerateMetafileProc" />
      </Parameters>
      <Docs>
        <param name="metafile">要枚举的 <see cref="T:System.Drawing.Imaging.Metafile" />。</param>
        <param name="destRect">
          <see cref="T:System.Drawing.Rectangle" /> 结构，它指定所绘制图元文件的位置和大小。</param>
        <param name="srcRect">
          <see cref="T:System.Drawing.Rectangle" /> 结构，它相对于图元文件的左上角指定要绘制的部分图元文件。</param>
        <param name="srcUnit">
          <see cref="T:System.Drawing.GraphicsUnit" /> 枚举的成员，它指定度量单位，该度量单位用于确定 <c>srcRect</c> 参数指定的矩形所包含的部分图元文件。</param>
        <param name="callback">
          <see cref="T:System.Drawing.Graphics.EnumerateMetafileProc" /> 委托，它指定将图元文件记录发送到的方法。</param>
        <summary>将 <see cref="T:System.Drawing.Imaging.Metafile" /> 中选定矩形内的记录逐个发送到回调方法以在指定的矩形中显示。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法枚举指定图元文件中包含的记录。 每个记录分别发送到回调方法，通过指定`callback`参数。 通常情况下，回调方法调用<xref:System.Drawing.Imaging.Metafile.PlayRecord%2A>"播放"，或绘图、 记录的方法。  
  
 如果回调方法调用<xref:System.Drawing.Imaging.Metafile.PlayRecord%2A>，它必须通过调用实现<xref:System.Drawing.Imaging.Metafile.PlayRecord%2A>方法的特定于<xref:System.Drawing.Imaging.Metafile>正在枚举。  
  
 指定的矩形之外的任何绘制发生`srcRect`参数将被忽略。  
  
   
  
## Examples  
 有关代码示例，请参阅 <xref:System.Drawing.Graphics.EnumerateMetafile%28System.Drawing.Imaging.Metafile%2CSystem.Drawing.Point%2CSystem.Drawing.Graphics.EnumerateMetafileProc%29>。  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">图像、位图和图元文件</related>
      </Docs>
    </Member>
    <Member MemberName="EnumerateMetafile">
      <MemberSignature Language="C#" Value="public void EnumerateMetafile (System.Drawing.Imaging.Metafile metafile, System.Drawing.RectangleF destRect, System.Drawing.Graphics.EnumerateMetafileProc callback, IntPtr callbackData, System.Drawing.Imaging.ImageAttributes imageAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EnumerateMetafile(class System.Drawing.Imaging.Metafile metafile, valuetype System.Drawing.RectangleF destRect, class System.Drawing.Graphics/EnumerateMetafileProc callback, native int callbackData, class System.Drawing.Imaging.ImageAttributes imageAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.EnumerateMetafile(System.Drawing.Imaging.Metafile,System.Drawing.RectangleF,System.Drawing.Graphics.EnumerateMetafileProc,System.IntPtr,System.Drawing.Imaging.ImageAttributes)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EnumerateMetafile(System::Drawing::Imaging::Metafile ^ metafile, System::Drawing::RectangleF destRect, System::Drawing::Graphics::EnumerateMetafileProc ^ callback, IntPtr callbackData, System::Drawing::Imaging::ImageAttributes ^ imageAttr);" />
      <MemberSignature Language="F#" Value="member this.EnumerateMetafile : System.Drawing.Imaging.Metafile * System.Drawing.RectangleF * System.Drawing.Graphics.EnumerateMetafileProc * nativeint * System.Drawing.Imaging.ImageAttributes -&gt; unit" Usage="graphics.EnumerateMetafile (metafile, destRect, callback, callbackData, imageAttr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metafile" Type="System.Drawing.Imaging.Metafile" />
        <Parameter Name="destRect" Type="System.Drawing.RectangleF" />
        <Parameter Name="callback" Type="System.Drawing.Graphics+EnumerateMetafileProc" />
        <Parameter Name="callbackData" Type="System.IntPtr" />
        <Parameter Name="imageAttr" Type="System.Drawing.Imaging.ImageAttributes" />
      </Parameters>
      <Docs>
        <param name="metafile">要枚举的 <see cref="T:System.Drawing.Imaging.Metafile" />。</param>
        <param name="destRect">
          <see cref="T:System.Drawing.RectangleF" /> 结构，它指定所绘制图元文件的位置和大小。</param>
        <param name="callback">
          <see cref="T:System.Drawing.Graphics.EnumerateMetafileProc" /> 委托，它指定将图元文件记录发送到的方法。</param>
        <param name="callbackData">必需但被忽略的内部指针。 可以为此参数传递 <see cref="F:System.IntPtr.Zero" />。</param>
        <param name="imageAttr">
          <see cref="T:System.Drawing.Imaging.ImageAttributes" />，它指定所绘制图像的图像特性信息。</param>
        <summary>将指定 <see cref="T:System.Drawing.Imaging.Metafile" /> 中的记录逐个发送到回调方法，以在指定的矩形中用指定的图像特性显示。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法枚举指定图元文件中包含的记录。 每个记录分别发送到回调方法，通过指定`callback`参数。 通常情况下，回调方法调用<xref:System.Drawing.Imaging.Metafile.PlayRecord%2A>"播放"，或绘图、 记录的方法。  
  
 如果回调方法调用<xref:System.Drawing.Imaging.Metafile.PlayRecord%2A>，它必须通过调用实现<xref:System.Drawing.Imaging.Metafile.PlayRecord%2A>方法的特定于<xref:System.Drawing.Imaging.Metafile>正在枚举。  
  
 指定的图像特性`imageAttr`指定何时写入图元文件的那些参数替换。  
  
   
  
## Examples  
 有关代码示例，请参阅 <xref:System.Drawing.Graphics.EnumerateMetafile%28System.Drawing.Imaging.Metafile%2CSystem.Drawing.Point%2CSystem.Drawing.Graphics.EnumerateMetafileProc%29>。  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">图像、位图和图元文件</related>
      </Docs>
    </Member>
    <Member MemberName="EnumerateMetafile">
      <MemberSignature Language="C#" Value="public void EnumerateMetafile (System.Drawing.Imaging.Metafile metafile, System.Drawing.RectangleF destRect, System.Drawing.RectangleF srcRect, System.Drawing.GraphicsUnit srcUnit, System.Drawing.Graphics.EnumerateMetafileProc callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EnumerateMetafile(class System.Drawing.Imaging.Metafile metafile, valuetype System.Drawing.RectangleF destRect, valuetype System.Drawing.RectangleF srcRect, valuetype System.Drawing.GraphicsUnit srcUnit, class System.Drawing.Graphics/EnumerateMetafileProc callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.EnumerateMetafile(System.Drawing.Imaging.Metafile,System.Drawing.RectangleF,System.Drawing.RectangleF,System.Drawing.GraphicsUnit,System.Drawing.Graphics.EnumerateMetafileProc)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EnumerateMetafile(System::Drawing::Imaging::Metafile ^ metafile, System::Drawing::RectangleF destRect, System::Drawing::RectangleF srcRect, System::Drawing::GraphicsUnit srcUnit, System::Drawing::Graphics::EnumerateMetafileProc ^ callback);" />
      <MemberSignature Language="F#" Value="member this.EnumerateMetafile : System.Drawing.Imaging.Metafile * System.Drawing.RectangleF * System.Drawing.RectangleF * System.Drawing.GraphicsUnit * System.Drawing.Graphics.EnumerateMetafileProc -&gt; unit" Usage="graphics.EnumerateMetafile (metafile, destRect, srcRect, srcUnit, callback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metafile" Type="System.Drawing.Imaging.Metafile" />
        <Parameter Name="destRect" Type="System.Drawing.RectangleF" />
        <Parameter Name="srcRect" Type="System.Drawing.RectangleF" />
        <Parameter Name="srcUnit" Type="System.Drawing.GraphicsUnit" />
        <Parameter Name="callback" Type="System.Drawing.Graphics+EnumerateMetafileProc" />
      </Parameters>
      <Docs>
        <param name="metafile">要枚举的 <see cref="T:System.Drawing.Imaging.Metafile" />。</param>
        <param name="destRect">
          <see cref="T:System.Drawing.RectangleF" /> 结构，它指定所绘制图元文件的位置和大小。</param>
        <param name="srcRect">
          <see cref="T:System.Drawing.RectangleF" /> 结构，它相对于图元文件的左上角指定要绘制的部分图元文件。</param>
        <param name="srcUnit">
          <see cref="T:System.Drawing.GraphicsUnit" /> 枚举的成员，它指定度量单位，该度量单位用于确定 <c>srcRect</c> 参数指定的矩形所包含的部分图元文件。</param>
        <param name="callback">
          <see cref="T:System.Drawing.Graphics.EnumerateMetafileProc" /> 委托，它指定将图元文件记录发送到的方法。</param>
        <summary>将 <see cref="T:System.Drawing.Imaging.Metafile" /> 中选定矩形内的记录逐个发送到回调方法以在指定的矩形中显示。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法枚举指定图元文件中包含的记录。 每个记录分别发送到回调方法，通过指定`callback`参数。 通常情况下，回调方法调用<xref:System.Drawing.Imaging.Metafile.PlayRecord%2A>"播放"，或绘图、 记录的方法。  
  
 如果回调方法调用<xref:System.Drawing.Imaging.Metafile.PlayRecord%2A>，它必须通过调用实现<xref:System.Drawing.Imaging.Metafile.PlayRecord%2A>方法的特定于<xref:System.Drawing.Imaging.Metafile>正在枚举。  
  
 指定的矩形之外的任何绘制发生`srcRect`参数将被忽略。  
  
   
  
## Examples  
 有关代码示例，请参阅 <xref:System.Drawing.Graphics.EnumerateMetafile%28System.Drawing.Imaging.Metafile%2CSystem.Drawing.Point%2CSystem.Drawing.Graphics.EnumerateMetafileProc%29>。  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">图像、位图和图元文件</related>
      </Docs>
    </Member>
    <Member MemberName="EnumerateMetafile">
      <MemberSignature Language="C#" Value="public void EnumerateMetafile (System.Drawing.Imaging.Metafile metafile, System.Drawing.Point destPoint, System.Drawing.Rectangle srcRect, System.Drawing.GraphicsUnit srcUnit, System.Drawing.Graphics.EnumerateMetafileProc callback, IntPtr callbackData);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EnumerateMetafile(class System.Drawing.Imaging.Metafile metafile, valuetype System.Drawing.Point destPoint, valuetype System.Drawing.Rectangle srcRect, valuetype System.Drawing.GraphicsUnit srcUnit, class System.Drawing.Graphics/EnumerateMetafileProc callback, native int callbackData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.EnumerateMetafile(System.Drawing.Imaging.Metafile,System.Drawing.Point,System.Drawing.Rectangle,System.Drawing.GraphicsUnit,System.Drawing.Graphics.EnumerateMetafileProc,System.IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EnumerateMetafile(System::Drawing::Imaging::Metafile ^ metafile, System::Drawing::Point destPoint, System::Drawing::Rectangle srcRect, System::Drawing::GraphicsUnit srcUnit, System::Drawing::Graphics::EnumerateMetafileProc ^ callback, IntPtr callbackData);" />
      <MemberSignature Language="F#" Value="member this.EnumerateMetafile : System.Drawing.Imaging.Metafile * System.Drawing.Point * System.Drawing.Rectangle * System.Drawing.GraphicsUnit * System.Drawing.Graphics.EnumerateMetafileProc * nativeint -&gt; unit" Usage="graphics.EnumerateMetafile (metafile, destPoint, srcRect, srcUnit, callback, callbackData)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metafile" Type="System.Drawing.Imaging.Metafile" />
        <Parameter Name="destPoint" Type="System.Drawing.Point" />
        <Parameter Name="srcRect" Type="System.Drawing.Rectangle" />
        <Parameter Name="srcUnit" Type="System.Drawing.GraphicsUnit" />
        <Parameter Name="callback" Type="System.Drawing.Graphics+EnumerateMetafileProc" />
        <Parameter Name="callbackData" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="metafile">要枚举的 <see cref="T:System.Drawing.Imaging.Metafile" />。</param>
        <param name="destPoint">
          <see cref="T:System.Drawing.Point" /> 结构，它指定所绘制图元文件的左上角的位置。</param>
        <param name="srcRect">
          <see cref="T:System.Drawing.Rectangle" /> 结构，它相对于图元文件的左上角指定要绘制的部分图元文件。</param>
        <param name="srcUnit">
          <see cref="T:System.Drawing.GraphicsUnit" /> 枚举的成员，它指定度量单位，该度量单位用于确定 <c>srcRect</c> 参数指定的矩形所包含的部分图元文件。</param>
        <param name="callback">
          <see cref="T:System.Drawing.Graphics.EnumerateMetafileProc" /> 委托，它指定将图元文件记录发送到的方法。</param>
        <param name="callbackData">必需但被忽略的内部指针。 可以为此参数传递 <see cref="F:System.IntPtr.Zero" />。</param>
        <summary>将 <see cref="T:System.Drawing.Imaging.Metafile" /> 中选定矩形内的记录逐个发送到回调方法以在指定的点处显示。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法枚举指定图元文件中包含的记录。 每个记录分别发送到回调方法，通过指定`callback`参数。 通常情况下，回调方法调用<xref:System.Drawing.Imaging.Metafile.PlayRecord%2A>"播放"，或绘图、 记录的方法。  
  
 如果回调方法调用<xref:System.Drawing.Imaging.Metafile.PlayRecord%2A>，它必须通过调用实现<xref:System.Drawing.Imaging.Metafile.PlayRecord%2A>方法的特定于<xref:System.Drawing.Imaging.Metafile>正在枚举。  
  
   
  
## Examples  
 有关代码示例，请参阅 <xref:System.Drawing.Graphics.EnumerateMetafile%28System.Drawing.Imaging.Metafile%2CSystem.Drawing.Point%2CSystem.Drawing.Graphics.EnumerateMetafileProc%29>。  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">图像、位图和图元文件</related>
      </Docs>
    </Member>
    <Member MemberName="EnumerateMetafile">
      <MemberSignature Language="C#" Value="public void EnumerateMetafile (System.Drawing.Imaging.Metafile metafile, System.Drawing.Point[] destPoints, System.Drawing.Rectangle srcRect, System.Drawing.GraphicsUnit srcUnit, System.Drawing.Graphics.EnumerateMetafileProc callback, IntPtr callbackData);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EnumerateMetafile(class System.Drawing.Imaging.Metafile metafile, valuetype System.Drawing.Point[] destPoints, valuetype System.Drawing.Rectangle srcRect, valuetype System.Drawing.GraphicsUnit srcUnit, class System.Drawing.Graphics/EnumerateMetafileProc callback, native int callbackData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.EnumerateMetafile(System.Drawing.Imaging.Metafile,System.Drawing.Point[],System.Drawing.Rectangle,System.Drawing.GraphicsUnit,System.Drawing.Graphics.EnumerateMetafileProc,System.IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EnumerateMetafile(System::Drawing::Imaging::Metafile ^ metafile, cli::array &lt;System::Drawing::Point&gt; ^ destPoints, System::Drawing::Rectangle srcRect, System::Drawing::GraphicsUnit srcUnit, System::Drawing::Graphics::EnumerateMetafileProc ^ callback, IntPtr callbackData);" />
      <MemberSignature Language="F#" Value="member this.EnumerateMetafile : System.Drawing.Imaging.Metafile * System.Drawing.Point[] * System.Drawing.Rectangle * System.Drawing.GraphicsUnit * System.Drawing.Graphics.EnumerateMetafileProc * nativeint -&gt; unit" Usage="graphics.EnumerateMetafile (metafile, destPoints, srcRect, srcUnit, callback, callbackData)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metafile" Type="System.Drawing.Imaging.Metafile" />
        <Parameter Name="destPoints" Type="System.Drawing.Point[]" />
        <Parameter Name="srcRect" Type="System.Drawing.Rectangle" />
        <Parameter Name="srcUnit" Type="System.Drawing.GraphicsUnit" />
        <Parameter Name="callback" Type="System.Drawing.Graphics+EnumerateMetafileProc" />
        <Parameter Name="callbackData" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="metafile">要枚举的 <see cref="T:System.Drawing.Imaging.Metafile" />。</param>
        <param name="destPoints">由三个 <see cref="T:System.Drawing.Point" /> 结构组成的数组，这三个结构定义一个用来确定所绘制图元文件的大小和位置的平行四边形。</param>
        <param name="srcRect">
          <see cref="T:System.Drawing.Rectangle" /> 结构，它相对于图元文件的左上角指定要绘制的部分图元文件。</param>
        <param name="srcUnit">
          <see cref="T:System.Drawing.GraphicsUnit" /> 枚举的成员，它指定度量单位，该度量单位用于确定 <c>srcRect</c> 参数指定的矩形所包含的部分图元文件。</param>
        <param name="callback">
          <see cref="T:System.Drawing.Graphics.EnumerateMetafileProc" /> 委托，它指定将图元文件记录发送到的方法。</param>
        <param name="callbackData">必需但被忽略的内部指针。 可以为此参数传递 <see cref="F:System.IntPtr.Zero" />。</param>
        <summary>将 <see cref="T:System.Drawing.Imaging.Metafile" /> 中选定矩形内的记录逐个发送到回调方法以在指定的平行四边形中显示。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法枚举指定图元文件中包含的记录。 每个记录分别发送到回调方法，通过指定`callback`参数。 通常情况下，回调方法调用<xref:System.Drawing.Imaging.Metafile.PlayRecord%2A>"播放"，或绘图、 记录的方法。  
  
 如果回调方法调用<xref:System.Drawing.Imaging.Metafile.PlayRecord%2A>，它必须通过调用实现<xref:System.Drawing.Imaging.Metafile.PlayRecord%2A>方法的特定于<xref:System.Drawing.Imaging.Metafile>正在枚举。  
  
 `destPoints`参数指定的平行四边形的三个点。 这三个<xref:System.Drawing.Point>结构表示的平行四边形的左上角、 右上方和左下角。 第四个点推断出的前三个以形成一个平行四边形。 缩放和剪切以适合的平行四边形绘制图元文件。  
  
 指定的矩形之外的任何绘制发生`srcRect`参数将被忽略。  
  
   
  
## Examples  
 有关代码示例，请参阅 <xref:System.Drawing.Graphics.EnumerateMetafile%28System.Drawing.Imaging.Metafile%2CSystem.Drawing.Point%2CSystem.Drawing.Graphics.EnumerateMetafileProc%29>。  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">图像、位图和图元文件</related>
      </Docs>
    </Member>
    <Member MemberName="EnumerateMetafile">
      <MemberSignature Language="C#" Value="public void EnumerateMetafile (System.Drawing.Imaging.Metafile metafile, System.Drawing.PointF destPoint, System.Drawing.RectangleF srcRect, System.Drawing.GraphicsUnit srcUnit, System.Drawing.Graphics.EnumerateMetafileProc callback, IntPtr callbackData);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EnumerateMetafile(class System.Drawing.Imaging.Metafile metafile, valuetype System.Drawing.PointF destPoint, valuetype System.Drawing.RectangleF srcRect, valuetype System.Drawing.GraphicsUnit srcUnit, class System.Drawing.Graphics/EnumerateMetafileProc callback, native int callbackData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.EnumerateMetafile(System.Drawing.Imaging.Metafile,System.Drawing.PointF,System.Drawing.RectangleF,System.Drawing.GraphicsUnit,System.Drawing.Graphics.EnumerateMetafileProc,System.IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EnumerateMetafile(System::Drawing::Imaging::Metafile ^ metafile, System::Drawing::PointF destPoint, System::Drawing::RectangleF srcRect, System::Drawing::GraphicsUnit srcUnit, System::Drawing::Graphics::EnumerateMetafileProc ^ callback, IntPtr callbackData);" />
      <MemberSignature Language="F#" Value="member this.EnumerateMetafile : System.Drawing.Imaging.Metafile * System.Drawing.PointF * System.Drawing.RectangleF * System.Drawing.GraphicsUnit * System.Drawing.Graphics.EnumerateMetafileProc * nativeint -&gt; unit" Usage="graphics.EnumerateMetafile (metafile, destPoint, srcRect, srcUnit, callback, callbackData)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metafile" Type="System.Drawing.Imaging.Metafile" />
        <Parameter Name="destPoint" Type="System.Drawing.PointF" />
        <Parameter Name="srcRect" Type="System.Drawing.RectangleF" />
        <Parameter Name="srcUnit" Type="System.Drawing.GraphicsUnit" />
        <Parameter Name="callback" Type="System.Drawing.Graphics+EnumerateMetafileProc" />
        <Parameter Name="callbackData" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="metafile">要枚举的 <see cref="T:System.Drawing.Imaging.Metafile" />。</param>
        <param name="destPoint">
          <see cref="T:System.Drawing.PointF" /> 结构，它指定所绘制图元文件的左上角的位置。</param>
        <param name="srcRect">
          <see cref="T:System.Drawing.RectangleF" /> 结构，它相对于图元文件的左上角指定要绘制的部分图元文件。</param>
        <param name="srcUnit">
          <see cref="T:System.Drawing.GraphicsUnit" /> 枚举的成员，它指定度量单位，该度量单位用于确定 <c>srcRect</c> 参数指定的矩形所包含的部分图元文件。</param>
        <param name="callback">
          <see cref="T:System.Drawing.Graphics.EnumerateMetafileProc" /> 委托，它指定将图元文件记录发送到的方法。</param>
        <param name="callbackData">必需但被忽略的内部指针。 可以为此参数传递 <see cref="F:System.IntPtr.Zero" />。</param>
        <summary>将 <see cref="T:System.Drawing.Imaging.Metafile" /> 中选定矩形内的记录逐个发送到回调方法以在指定的点处显示。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法枚举指定图元文件中包含的记录。 每个记录分别发送到回调方法，通过指定`callback`参数。 通常情况下，回调方法调用<xref:System.Drawing.Imaging.Metafile.PlayRecord%2A>"播放"，或绘图、 记录的方法。  
  
 如果回调方法调用<xref:System.Drawing.Imaging.Metafile.PlayRecord%2A>，它必须通过调用实现<xref:System.Drawing.Imaging.Metafile.PlayRecord%2A>方法的特定于<xref:System.Drawing.Imaging.Metafile>正在枚举。  
  
 指定的矩形之外的任何绘制发生`srcRect`参数将被忽略。  
  
   
  
## Examples  
 有关代码示例，请参阅 <xref:System.Drawing.Graphics.EnumerateMetafile%28System.Drawing.Imaging.Metafile%2CSystem.Drawing.Point%2CSystem.Drawing.Graphics.EnumerateMetafileProc%29>。  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">图像、位图和图元文件</related>
      </Docs>
    </Member>
    <Member MemberName="EnumerateMetafile">
      <MemberSignature Language="C#" Value="public void EnumerateMetafile (System.Drawing.Imaging.Metafile metafile, System.Drawing.PointF[] destPoints, System.Drawing.RectangleF srcRect, System.Drawing.GraphicsUnit srcUnit, System.Drawing.Graphics.EnumerateMetafileProc callback, IntPtr callbackData);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EnumerateMetafile(class System.Drawing.Imaging.Metafile metafile, valuetype System.Drawing.PointF[] destPoints, valuetype System.Drawing.RectangleF srcRect, valuetype System.Drawing.GraphicsUnit srcUnit, class System.Drawing.Graphics/EnumerateMetafileProc callback, native int callbackData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.EnumerateMetafile(System.Drawing.Imaging.Metafile,System.Drawing.PointF[],System.Drawing.RectangleF,System.Drawing.GraphicsUnit,System.Drawing.Graphics.EnumerateMetafileProc,System.IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EnumerateMetafile(System::Drawing::Imaging::Metafile ^ metafile, cli::array &lt;System::Drawing::PointF&gt; ^ destPoints, System::Drawing::RectangleF srcRect, System::Drawing::GraphicsUnit srcUnit, System::Drawing::Graphics::EnumerateMetafileProc ^ callback, IntPtr callbackData);" />
      <MemberSignature Language="F#" Value="member this.EnumerateMetafile : System.Drawing.Imaging.Metafile * System.Drawing.PointF[] * System.Drawing.RectangleF * System.Drawing.GraphicsUnit * System.Drawing.Graphics.EnumerateMetafileProc * nativeint -&gt; unit" Usage="graphics.EnumerateMetafile (metafile, destPoints, srcRect, srcUnit, callback, callbackData)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metafile" Type="System.Drawing.Imaging.Metafile" />
        <Parameter Name="destPoints" Type="System.Drawing.PointF[]" />
        <Parameter Name="srcRect" Type="System.Drawing.RectangleF" />
        <Parameter Name="srcUnit" Type="System.Drawing.GraphicsUnit" />
        <Parameter Name="callback" Type="System.Drawing.Graphics+EnumerateMetafileProc" />
        <Parameter Name="callbackData" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="metafile">要枚举的 <see cref="T:System.Drawing.Imaging.Metafile" />。</param>
        <param name="destPoints">由三个 <see cref="T:System.Drawing.PointF" /> 结构组成的数组，这三个结构定义一个用来确定所绘制图元文件的大小和位置的平行四边形。</param>
        <param name="srcRect">
          <see cref="T:System.Drawing.RectangleF" /> 结构，它相对于图元文件的左上角指定要绘制的部分图元文件。</param>
        <param name="srcUnit">
          <see cref="T:System.Drawing.GraphicsUnit" /> 枚举的成员，它指定度量单位，该度量单位用于确定 <c>srcRect</c> 参数指定的矩形所包含的部分图元文件。</param>
        <param name="callback">
          <see cref="T:System.Drawing.Graphics.EnumerateMetafileProc" /> 委托，它指定将图元文件记录发送到的方法。</param>
        <param name="callbackData">必需但被忽略的内部指针。 可以为此参数传递 <see cref="F:System.IntPtr.Zero" />。</param>
        <summary>将 <see cref="T:System.Drawing.Imaging.Metafile" /> 中选定矩形内的记录逐个发送到回调方法以在指定的平行四边形中显示。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法枚举指定图元文件中包含的记录。 每个记录分别发送到回调方法，通过指定`callback`参数。 通常情况下，回调方法调用<xref:System.Drawing.Imaging.Metafile.PlayRecord%2A>"播放"，或绘图、 记录的方法。  
  
 如果回调方法调用<xref:System.Drawing.Imaging.Metafile.PlayRecord%2A>，它必须通过调用实现<xref:System.Drawing.Imaging.Metafile.PlayRecord%2A>方法的特定于<xref:System.Drawing.Imaging.Metafile>正在枚举。  
  
 `destPoints`参数指定的平行四边形的三个点。 这三个<xref:System.Drawing.PointF>结构表示的平行四边形的左上角、 右上方和左下角。 第四个点推断出的前三个以形成一个平行四边形。 缩放和剪切以适合的平行四边形绘制图元文件。  
  
 指定的矩形之外的任何绘制发生`srcRect`参数将被忽略。  
  
   
  
## Examples  
 有关代码示例，请参阅 <xref:System.Drawing.Graphics.EnumerateMetafile%28System.Drawing.Imaging.Metafile%2CSystem.Drawing.Point%2CSystem.Drawing.Graphics.EnumerateMetafileProc%29>。  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">图像、位图和图元文件</related>
      </Docs>
    </Member>
    <Member MemberName="EnumerateMetafile">
      <MemberSignature Language="C#" Value="public void EnumerateMetafile (System.Drawing.Imaging.Metafile metafile, System.Drawing.Rectangle destRect, System.Drawing.Rectangle srcRect, System.Drawing.GraphicsUnit srcUnit, System.Drawing.Graphics.EnumerateMetafileProc callback, IntPtr callbackData);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EnumerateMetafile(class System.Drawing.Imaging.Metafile metafile, valuetype System.Drawing.Rectangle destRect, valuetype System.Drawing.Rectangle srcRect, valuetype System.Drawing.GraphicsUnit srcUnit, class System.Drawing.Graphics/EnumerateMetafileProc callback, native int callbackData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.EnumerateMetafile(System.Drawing.Imaging.Metafile,System.Drawing.Rectangle,System.Drawing.Rectangle,System.Drawing.GraphicsUnit,System.Drawing.Graphics.EnumerateMetafileProc,System.IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EnumerateMetafile(System::Drawing::Imaging::Metafile ^ metafile, System::Drawing::Rectangle destRect, System::Drawing::Rectangle srcRect, System::Drawing::GraphicsUnit srcUnit, System::Drawing::Graphics::EnumerateMetafileProc ^ callback, IntPtr callbackData);" />
      <MemberSignature Language="F#" Value="member this.EnumerateMetafile : System.Drawing.Imaging.Metafile * System.Drawing.Rectangle * System.Drawing.Rectangle * System.Drawing.GraphicsUnit * System.Drawing.Graphics.EnumerateMetafileProc * nativeint -&gt; unit" Usage="graphics.EnumerateMetafile (metafile, destRect, srcRect, srcUnit, callback, callbackData)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metafile" Type="System.Drawing.Imaging.Metafile" />
        <Parameter Name="destRect" Type="System.Drawing.Rectangle" />
        <Parameter Name="srcRect" Type="System.Drawing.Rectangle" />
        <Parameter Name="srcUnit" Type="System.Drawing.GraphicsUnit" />
        <Parameter Name="callback" Type="System.Drawing.Graphics+EnumerateMetafileProc" />
        <Parameter Name="callbackData" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="metafile">要枚举的 <see cref="T:System.Drawing.Imaging.Metafile" />。</param>
        <param name="destRect">
          <see cref="T:System.Drawing.Rectangle" /> 结构，它指定所绘制图元文件的位置和大小。</param>
        <param name="srcRect">
          <see cref="T:System.Drawing.Rectangle" /> 结构，它相对于图元文件的左上角指定要绘制的部分图元文件。</param>
        <param name="srcUnit">
          <see cref="T:System.Drawing.GraphicsUnit" /> 枚举的成员，它指定度量单位，该度量单位用于确定 <c>srcRect</c> 参数指定的矩形所包含的部分图元文件。</param>
        <param name="callback">
          <see cref="T:System.Drawing.Graphics.EnumerateMetafileProc" /> 委托，它指定将图元文件记录发送到的方法。</param>
        <param name="callbackData">必需但被忽略的内部指针。 可以为此参数传递 <see cref="F:System.IntPtr.Zero" />。</param>
        <summary>将 <see cref="T:System.Drawing.Imaging.Metafile" /> 中选定矩形内的记录逐个发送到回调方法以在指定的矩形中显示。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法枚举指定图元文件中包含的记录。 每个记录分别发送到回调方法，通过指定`callback`参数。 通常情况下，回调方法调用<xref:System.Drawing.Imaging.Metafile.PlayRecord%2A>"播放"，或绘图、 记录的方法。  
  
 如果回调方法调用<xref:System.Drawing.Imaging.Metafile.PlayRecord%2A>，它必须通过调用实现<xref:System.Drawing.Imaging.Metafile.PlayRecord%2A>方法的特定于<xref:System.Drawing.Imaging.Metafile>正在枚举。  
  
 指定的矩形之外的任何绘制发生`srcRect`参数将被忽略。  
  
   
  
## Examples  
 有关代码示例，请参阅 <xref:System.Drawing.Graphics.EnumerateMetafile%28System.Drawing.Imaging.Metafile%2CSystem.Drawing.Point%2CSystem.Drawing.Graphics.EnumerateMetafileProc%29>。  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">图像、位图和图元文件</related>
      </Docs>
    </Member>
    <Member MemberName="EnumerateMetafile">
      <MemberSignature Language="C#" Value="public void EnumerateMetafile (System.Drawing.Imaging.Metafile metafile, System.Drawing.RectangleF destRect, System.Drawing.RectangleF srcRect, System.Drawing.GraphicsUnit srcUnit, System.Drawing.Graphics.EnumerateMetafileProc callback, IntPtr callbackData);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EnumerateMetafile(class System.Drawing.Imaging.Metafile metafile, valuetype System.Drawing.RectangleF destRect, valuetype System.Drawing.RectangleF srcRect, valuetype System.Drawing.GraphicsUnit srcUnit, class System.Drawing.Graphics/EnumerateMetafileProc callback, native int callbackData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.EnumerateMetafile(System.Drawing.Imaging.Metafile,System.Drawing.RectangleF,System.Drawing.RectangleF,System.Drawing.GraphicsUnit,System.Drawing.Graphics.EnumerateMetafileProc,System.IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EnumerateMetafile(System::Drawing::Imaging::Metafile ^ metafile, System::Drawing::RectangleF destRect, System::Drawing::RectangleF srcRect, System::Drawing::GraphicsUnit srcUnit, System::Drawing::Graphics::EnumerateMetafileProc ^ callback, IntPtr callbackData);" />
      <MemberSignature Language="F#" Value="member this.EnumerateMetafile : System.Drawing.Imaging.Metafile * System.Drawing.RectangleF * System.Drawing.RectangleF * System.Drawing.GraphicsUnit * System.Drawing.Graphics.EnumerateMetafileProc * nativeint -&gt; unit" Usage="graphics.EnumerateMetafile (metafile, destRect, srcRect, srcUnit, callback, callbackData)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metafile" Type="System.Drawing.Imaging.Metafile" />
        <Parameter Name="destRect" Type="System.Drawing.RectangleF" />
        <Parameter Name="srcRect" Type="System.Drawing.RectangleF" />
        <Parameter Name="srcUnit" Type="System.Drawing.GraphicsUnit" />
        <Parameter Name="callback" Type="System.Drawing.Graphics+EnumerateMetafileProc" />
        <Parameter Name="callbackData" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="metafile">要枚举的 <see cref="T:System.Drawing.Imaging.Metafile" />。</param>
        <param name="destRect">
          <see cref="T:System.Drawing.RectangleF" /> 结构，它指定所绘制图元文件的位置和大小。</param>
        <param name="srcRect">
          <see cref="T:System.Drawing.RectangleF" /> 结构，它相对于图元文件的左上角指定要绘制的部分图元文件。</param>
        <param name="srcUnit">
          <see cref="T:System.Drawing.GraphicsUnit" /> 枚举的成员，它指定度量单位，该度量单位用于确定 <c>srcRect</c> 参数指定的矩形所包含的部分图元文件。</param>
        <param name="callback">
          <see cref="T:System.Drawing.Graphics.EnumerateMetafileProc" /> 委托，它指定将图元文件记录发送到的方法。</param>
        <param name="callbackData">必需但被忽略的内部指针。 可以为此参数传递 <see cref="F:System.IntPtr.Zero" />。</param>
        <summary>将 <see cref="T:System.Drawing.Imaging.Metafile" /> 中选定矩形内的记录逐个发送到回调方法以在指定的矩形中显示。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法枚举指定图元文件中包含的记录。 每个记录分别发送到回调方法，通过指定`callback`参数。 通常情况下，回调方法调用<xref:System.Drawing.Imaging.Metafile.PlayRecord%2A>"播放"，或绘图、 记录的方法。  
  
 如果回调方法调用<xref:System.Drawing.Imaging.Metafile.PlayRecord%2A>，它必须通过调用实现<xref:System.Drawing.Imaging.Metafile.PlayRecord%2A>方法的特定于<xref:System.Drawing.Imaging.Metafile>正在枚举。  
  
 指定的矩形之外的任何绘制发生`srcRect`参数将被忽略。  
  
   
  
## Examples  
 有关代码示例，请参阅 <xref:System.Drawing.Graphics.EnumerateMetafile%28System.Drawing.Imaging.Metafile%2CSystem.Drawing.Point%2CSystem.Drawing.Graphics.EnumerateMetafileProc%29>。  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">图像、位图和图元文件</related>
      </Docs>
    </Member>
    <Member MemberName="EnumerateMetafile">
      <MemberSignature Language="C#" Value="public void EnumerateMetafile (System.Drawing.Imaging.Metafile metafile, System.Drawing.Point destPoint, System.Drawing.Rectangle srcRect, System.Drawing.GraphicsUnit unit, System.Drawing.Graphics.EnumerateMetafileProc callback, IntPtr callbackData, System.Drawing.Imaging.ImageAttributes imageAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EnumerateMetafile(class System.Drawing.Imaging.Metafile metafile, valuetype System.Drawing.Point destPoint, valuetype System.Drawing.Rectangle srcRect, valuetype System.Drawing.GraphicsUnit unit, class System.Drawing.Graphics/EnumerateMetafileProc callback, native int callbackData, class System.Drawing.Imaging.ImageAttributes imageAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.EnumerateMetafile(System.Drawing.Imaging.Metafile,System.Drawing.Point,System.Drawing.Rectangle,System.Drawing.GraphicsUnit,System.Drawing.Graphics.EnumerateMetafileProc,System.IntPtr,System.Drawing.Imaging.ImageAttributes)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EnumerateMetafile(System::Drawing::Imaging::Metafile ^ metafile, System::Drawing::Point destPoint, System::Drawing::Rectangle srcRect, System::Drawing::GraphicsUnit unit, System::Drawing::Graphics::EnumerateMetafileProc ^ callback, IntPtr callbackData, System::Drawing::Imaging::ImageAttributes ^ imageAttr);" />
      <MemberSignature Language="F#" Value="member this.EnumerateMetafile : System.Drawing.Imaging.Metafile * System.Drawing.Point * System.Drawing.Rectangle * System.Drawing.GraphicsUnit * System.Drawing.Graphics.EnumerateMetafileProc * nativeint * System.Drawing.Imaging.ImageAttributes -&gt; unit" Usage="graphics.EnumerateMetafile (metafile, destPoint, srcRect, unit, callback, callbackData, imageAttr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metafile" Type="System.Drawing.Imaging.Metafile" />
        <Parameter Name="destPoint" Type="System.Drawing.Point" />
        <Parameter Name="srcRect" Type="System.Drawing.Rectangle" />
        <Parameter Name="unit" Type="System.Drawing.GraphicsUnit" />
        <Parameter Name="callback" Type="System.Drawing.Graphics+EnumerateMetafileProc" />
        <Parameter Name="callbackData" Type="System.IntPtr" />
        <Parameter Name="imageAttr" Type="System.Drawing.Imaging.ImageAttributes" />
      </Parameters>
      <Docs>
        <param name="metafile">要枚举的 <see cref="T:System.Drawing.Imaging.Metafile" />。</param>
        <param name="destPoint">
          <see cref="T:System.Drawing.Point" /> 结构，它指定所绘制图元文件的左上角的位置。</param>
        <param name="srcRect">
          <see cref="T:System.Drawing.Rectangle" /> 结构，它相对于图元文件的左上角指定要绘制的部分图元文件。</param>
        <param name="unit">
          <see cref="T:System.Drawing.GraphicsUnit" /> 枚举的成员，它指定度量单位，该度量单位用于确定 <c>srcRect</c> 参数指定的矩形所包含的部分图元文件。</param>
        <param name="callback">
          <see cref="T:System.Drawing.Graphics.EnumerateMetafileProc" /> 委托，它指定将图元文件记录发送到的方法。</param>
        <param name="callbackData">必需但被忽略的内部指针。 可以为此参数传递 <see cref="F:System.IntPtr.Zero" />。</param>
        <param name="imageAttr">
          <see cref="T:System.Drawing.Imaging.ImageAttributes" />，它指定所绘制图像的图像特性信息。</param>
        <summary>将 <see cref="T:System.Drawing.Imaging.Metafile" /> 中选定矩形内的记录逐个发送到回调方法，以在指定的点处用指定的图像特性显示。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法枚举指定图元文件中包含的记录。 每个记录分别发送到回调方法，通过指定`callback`参数。 通常情况下，回调方法调用<xref:System.Drawing.Imaging.Metafile.PlayRecord%2A>"播放"，或绘图、 记录的方法。  
  
 如果回调方法调用<xref:System.Drawing.Imaging.Metafile.PlayRecord%2A>，它必须通过调用实现<xref:System.Drawing.Imaging.Metafile.PlayRecord%2A>方法的特定于<xref:System.Drawing.Imaging.Metafile>正在枚举。  
  
   
  
## Examples  
 有关代码示例，请参阅 <xref:System.Drawing.Graphics.EnumerateMetafile%28System.Drawing.Imaging.Metafile%2CSystem.Drawing.Point%2CSystem.Drawing.Graphics.EnumerateMetafileProc%29>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EnumerateMetafile">
      <MemberSignature Language="C#" Value="public void EnumerateMetafile (System.Drawing.Imaging.Metafile metafile, System.Drawing.Point[] destPoints, System.Drawing.Rectangle srcRect, System.Drawing.GraphicsUnit unit, System.Drawing.Graphics.EnumerateMetafileProc callback, IntPtr callbackData, System.Drawing.Imaging.ImageAttributes imageAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EnumerateMetafile(class System.Drawing.Imaging.Metafile metafile, valuetype System.Drawing.Point[] destPoints, valuetype System.Drawing.Rectangle srcRect, valuetype System.Drawing.GraphicsUnit unit, class System.Drawing.Graphics/EnumerateMetafileProc callback, native int callbackData, class System.Drawing.Imaging.ImageAttributes imageAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.EnumerateMetafile(System.Drawing.Imaging.Metafile,System.Drawing.Point[],System.Drawing.Rectangle,System.Drawing.GraphicsUnit,System.Drawing.Graphics.EnumerateMetafileProc,System.IntPtr,System.Drawing.Imaging.ImageAttributes)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EnumerateMetafile(System::Drawing::Imaging::Metafile ^ metafile, cli::array &lt;System::Drawing::Point&gt; ^ destPoints, System::Drawing::Rectangle srcRect, System::Drawing::GraphicsUnit unit, System::Drawing::Graphics::EnumerateMetafileProc ^ callback, IntPtr callbackData, System::Drawing::Imaging::ImageAttributes ^ imageAttr);" />
      <MemberSignature Language="F#" Value="member this.EnumerateMetafile : System.Drawing.Imaging.Metafile * System.Drawing.Point[] * System.Drawing.Rectangle * System.Drawing.GraphicsUnit * System.Drawing.Graphics.EnumerateMetafileProc * nativeint * System.Drawing.Imaging.ImageAttributes -&gt; unit" Usage="graphics.EnumerateMetafile (metafile, destPoints, srcRect, unit, callback, callbackData, imageAttr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metafile" Type="System.Drawing.Imaging.Metafile" />
        <Parameter Name="destPoints" Type="System.Drawing.Point[]" />
        <Parameter Name="srcRect" Type="System.Drawing.Rectangle" />
        <Parameter Name="unit" Type="System.Drawing.GraphicsUnit" />
        <Parameter Name="callback" Type="System.Drawing.Graphics+EnumerateMetafileProc" />
        <Parameter Name="callbackData" Type="System.IntPtr" />
        <Parameter Name="imageAttr" Type="System.Drawing.Imaging.ImageAttributes" />
      </Parameters>
      <Docs>
        <param name="metafile">要枚举的 <see cref="T:System.Drawing.Imaging.Metafile" />。</param>
        <param name="destPoints">由三个 <see cref="T:System.Drawing.Point" /> 结构组成的数组，这三个结构定义一个用来确定所绘制图元文件的大小和位置的平行四边形。</param>
        <param name="srcRect">
          <see cref="T:System.Drawing.Rectangle" /> 结构，它相对于图元文件的左上角指定要绘制的部分图元文件。</param>
        <param name="unit">
          <see cref="T:System.Drawing.GraphicsUnit" /> 枚举的成员，它指定度量单位，该度量单位用于确定 <c>srcRect</c> 参数指定的矩形所包含的部分图元文件。</param>
        <param name="callback">
          <see cref="T:System.Drawing.Graphics.EnumerateMetafileProc" /> 委托，它指定将图元文件记录发送到的方法。</param>
        <param name="callbackData">必需但被忽略的内部指针。 可以为此参数传递 <see cref="F:System.IntPtr.Zero" />。</param>
        <param name="imageAttr">
          <see cref="T:System.Drawing.Imaging.ImageAttributes" />，它指定所绘制图像的图像特性信息。</param>
        <summary>将 <see cref="T:System.Drawing.Imaging.Metafile" /> 中选定矩形内的记录逐个发送到回调方法，以在指定的平行四边形中用指定的图像特性显示。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法枚举指定图元文件中包含的记录。 每个记录分别发送到回调方法，通过指定`callback`参数。 通常情况下，回调方法调用<xref:System.Drawing.Imaging.Metafile.PlayRecord%2A>"播放"，或绘图、 记录的方法。  
  
 如果回调方法调用<xref:System.Drawing.Imaging.Metafile.PlayRecord%2A>，它必须通过调用实现<xref:System.Drawing.Imaging.Metafile.PlayRecord%2A>方法的特定于<xref:System.Drawing.Imaging.Metafile>正在枚举。  
  
 `destPoints`参数指定的平行四边形的三个点。 这三个<xref:System.Drawing.Point>结构表示的平行四边形的左上角、 右上方和左下角。 第四个点推断出的前三个以形成一个平行四边形。 缩放和剪切以适合的平行四边形绘制图元文件。  
  
 指定的矩形之外的任何绘制发生`srcRect`参数将被忽略。  
  
 指定的图像特性`imageAttr`指定何时写入图元文件的那些参数替换。  
  
   
  
## Examples  
 有关代码示例，请参阅 <xref:System.Drawing.Graphics.EnumerateMetafile%28System.Drawing.Imaging.Metafile%2CSystem.Drawing.Point%2CSystem.Drawing.Graphics.EnumerateMetafileProc%29>。  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">图像、位图和图元文件</related>
      </Docs>
    </Member>
    <Member MemberName="EnumerateMetafile">
      <MemberSignature Language="C#" Value="public void EnumerateMetafile (System.Drawing.Imaging.Metafile metafile, System.Drawing.PointF destPoint, System.Drawing.RectangleF srcRect, System.Drawing.GraphicsUnit unit, System.Drawing.Graphics.EnumerateMetafileProc callback, IntPtr callbackData, System.Drawing.Imaging.ImageAttributes imageAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EnumerateMetafile(class System.Drawing.Imaging.Metafile metafile, valuetype System.Drawing.PointF destPoint, valuetype System.Drawing.RectangleF srcRect, valuetype System.Drawing.GraphicsUnit unit, class System.Drawing.Graphics/EnumerateMetafileProc callback, native int callbackData, class System.Drawing.Imaging.ImageAttributes imageAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.EnumerateMetafile(System.Drawing.Imaging.Metafile,System.Drawing.PointF,System.Drawing.RectangleF,System.Drawing.GraphicsUnit,System.Drawing.Graphics.EnumerateMetafileProc,System.IntPtr,System.Drawing.Imaging.ImageAttributes)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EnumerateMetafile(System::Drawing::Imaging::Metafile ^ metafile, System::Drawing::PointF destPoint, System::Drawing::RectangleF srcRect, System::Drawing::GraphicsUnit unit, System::Drawing::Graphics::EnumerateMetafileProc ^ callback, IntPtr callbackData, System::Drawing::Imaging::ImageAttributes ^ imageAttr);" />
      <MemberSignature Language="F#" Value="member this.EnumerateMetafile : System.Drawing.Imaging.Metafile * System.Drawing.PointF * System.Drawing.RectangleF * System.Drawing.GraphicsUnit * System.Drawing.Graphics.EnumerateMetafileProc * nativeint * System.Drawing.Imaging.ImageAttributes -&gt; unit" Usage="graphics.EnumerateMetafile (metafile, destPoint, srcRect, unit, callback, callbackData, imageAttr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metafile" Type="System.Drawing.Imaging.Metafile" />
        <Parameter Name="destPoint" Type="System.Drawing.PointF" />
        <Parameter Name="srcRect" Type="System.Drawing.RectangleF" />
        <Parameter Name="unit" Type="System.Drawing.GraphicsUnit" />
        <Parameter Name="callback" Type="System.Drawing.Graphics+EnumerateMetafileProc" />
        <Parameter Name="callbackData" Type="System.IntPtr" />
        <Parameter Name="imageAttr" Type="System.Drawing.Imaging.ImageAttributes" />
      </Parameters>
      <Docs>
        <param name="metafile">要枚举的 <see cref="T:System.Drawing.Imaging.Metafile" />。</param>
        <param name="destPoint">
          <see cref="T:System.Drawing.PointF" /> 结构，它指定所绘制图元文件的左上角的位置。</param>
        <param name="srcRect">
          <see cref="T:System.Drawing.RectangleF" /> 结构，它相对于图元文件的左上角指定要绘制的部分图元文件。</param>
        <param name="unit">
          <see cref="T:System.Drawing.GraphicsUnit" /> 枚举的成员，它指定度量单位，该度量单位用于确定 <c>srcRect</c> 参数指定的矩形所包含的部分图元文件。</param>
        <param name="callback">
          <see cref="T:System.Drawing.Graphics.EnumerateMetafileProc" /> 委托，它指定将图元文件记录发送到的方法。</param>
        <param name="callbackData">必需但被忽略的内部指针。 可以为此参数传递 <see cref="F:System.IntPtr.Zero" />。</param>
        <param name="imageAttr">
          <see cref="T:System.Drawing.Imaging.ImageAttributes" />，它指定所绘制图像的图像特性信息。</param>
        <summary>将 <see cref="T:System.Drawing.Imaging.Metafile" /> 中选定矩形内的记录逐个发送到回调方法，以在指定的点处用指定的图像特性显示。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法枚举指定图元文件中包含的记录。 每个记录分别发送到回调方法，通过指定`callback`参数。 通常情况下，回调方法调用<xref:System.Drawing.Imaging.Metafile.PlayRecord%2A>"播放"，或绘图、 记录的方法。  
  
 如果回调方法调用<xref:System.Drawing.Imaging.Metafile.PlayRecord%2A>，它必须通过调用实现<xref:System.Drawing.Imaging.Metafile.PlayRecord%2A>方法的特定于<xref:System.Drawing.Imaging.Metafile>正在枚举。  
  
 指定的矩形之外的任何绘制发生`srcRect`参数将被忽略。  
  
 指定的图像特性`imageAttr`指定何时写入图元文件的那些参数替换。  
  
   
  
## Examples  
 有关代码示例，请参阅 <xref:System.Drawing.Graphics.EnumerateMetafile%28System.Drawing.Imaging.Metafile%2CSystem.Drawing.Point%2CSystem.Drawing.Graphics.EnumerateMetafileProc%29>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EnumerateMetafile">
      <MemberSignature Language="C#" Value="public void EnumerateMetafile (System.Drawing.Imaging.Metafile metafile, System.Drawing.PointF[] destPoints, System.Drawing.RectangleF srcRect, System.Drawing.GraphicsUnit unit, System.Drawing.Graphics.EnumerateMetafileProc callback, IntPtr callbackData, System.Drawing.Imaging.ImageAttributes imageAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EnumerateMetafile(class System.Drawing.Imaging.Metafile metafile, valuetype System.Drawing.PointF[] destPoints, valuetype System.Drawing.RectangleF srcRect, valuetype System.Drawing.GraphicsUnit unit, class System.Drawing.Graphics/EnumerateMetafileProc callback, native int callbackData, class System.Drawing.Imaging.ImageAttributes imageAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.EnumerateMetafile(System.Drawing.Imaging.Metafile,System.Drawing.PointF[],System.Drawing.RectangleF,System.Drawing.GraphicsUnit,System.Drawing.Graphics.EnumerateMetafileProc,System.IntPtr,System.Drawing.Imaging.ImageAttributes)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EnumerateMetafile(System::Drawing::Imaging::Metafile ^ metafile, cli::array &lt;System::Drawing::PointF&gt; ^ destPoints, System::Drawing::RectangleF srcRect, System::Drawing::GraphicsUnit unit, System::Drawing::Graphics::EnumerateMetafileProc ^ callback, IntPtr callbackData, System::Drawing::Imaging::ImageAttributes ^ imageAttr);" />
      <MemberSignature Language="F#" Value="member this.EnumerateMetafile : System.Drawing.Imaging.Metafile * System.Drawing.PointF[] * System.Drawing.RectangleF * System.Drawing.GraphicsUnit * System.Drawing.Graphics.EnumerateMetafileProc * nativeint * System.Drawing.Imaging.ImageAttributes -&gt; unit" Usage="graphics.EnumerateMetafile (metafile, destPoints, srcRect, unit, callback, callbackData, imageAttr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metafile" Type="System.Drawing.Imaging.Metafile" />
        <Parameter Name="destPoints" Type="System.Drawing.PointF[]" />
        <Parameter Name="srcRect" Type="System.Drawing.RectangleF" />
        <Parameter Name="unit" Type="System.Drawing.GraphicsUnit" />
        <Parameter Name="callback" Type="System.Drawing.Graphics+EnumerateMetafileProc" />
        <Parameter Name="callbackData" Type="System.IntPtr" />
        <Parameter Name="imageAttr" Type="System.Drawing.Imaging.ImageAttributes" />
      </Parameters>
      <Docs>
        <param name="metafile">要枚举的 <see cref="T:System.Drawing.Imaging.Metafile" />。</param>
        <param name="destPoints">由三个 <see cref="T:System.Drawing.PointF" /> 结构组成的数组，这三个结构定义一个用来确定所绘制图元文件的大小和位置的平行四边形。</param>
        <param name="srcRect">
          <see cref="T:System.Drawing.RectangleF" /> 结构，它相对于图元文件的左上角指定要绘制的部分图元文件。</param>
        <param name="unit">
          <see cref="T:System.Drawing.GraphicsUnit" /> 枚举的成员，它指定度量单位，该度量单位用于确定 <c>srcRect</c> 参数指定的矩形所包含的部分图元文件。</param>
        <param name="callback">
          <see cref="T:System.Drawing.Graphics.EnumerateMetafileProc" /> 委托，它指定将图元文件记录发送到的方法。</param>
        <param name="callbackData">必需但被忽略的内部指针。 可以为此参数传递 <see cref="F:System.IntPtr.Zero" />。</param>
        <param name="imageAttr">
          <see cref="T:System.Drawing.Imaging.ImageAttributes" />，它指定所绘制图像的图像特性信息。</param>
        <summary>将 <see cref="T:System.Drawing.Imaging.Metafile" /> 中选定矩形内的记录逐个发送到回调方法，以在指定的平行四边形中用指定的图像特性显示。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法枚举指定图元文件中包含的记录。 每个记录分别发送到回调方法，通过指定`callback`参数。 通常情况下，回调方法调用<xref:System.Drawing.Imaging.Metafile.PlayRecord%2A>"播放"，或绘图、 记录的方法。  
  
 如果回调方法调用<xref:System.Drawing.Imaging.Metafile.PlayRecord%2A>，它必须通过调用实现<xref:System.Drawing.Imaging.Metafile.PlayRecord%2A>方法的特定于<xref:System.Drawing.Imaging.Metafile>正在枚举。  
  
 `destPoints`参数指定的平行四边形的三个点。 这三个<xref:System.Drawing.PointF>结构表示的平行四边形的左上角、 右上方和左下角。 第四个点推断出的前三个以形成一个平行四边形。 缩放和剪切以适合的平行四边形绘制图元文件。  
  
 指定的矩形之外的任何绘制发生`srcRect`参数将被忽略。  
  
 指定的图像特性`imageAttr`指定何时写入图元文件的那些参数替换。  
  
   
  
## Examples  
 有关代码示例，请参阅 <xref:System.Drawing.Graphics.EnumerateMetafile%28System.Drawing.Imaging.Metafile%2CSystem.Drawing.Point%2CSystem.Drawing.Graphics.EnumerateMetafileProc%29>。  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">图像、位图和图元文件</related>
      </Docs>
    </Member>
    <Member MemberName="EnumerateMetafile">
      <MemberSignature Language="C#" Value="public void EnumerateMetafile (System.Drawing.Imaging.Metafile metafile, System.Drawing.Rectangle destRect, System.Drawing.Rectangle srcRect, System.Drawing.GraphicsUnit unit, System.Drawing.Graphics.EnumerateMetafileProc callback, IntPtr callbackData, System.Drawing.Imaging.ImageAttributes imageAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EnumerateMetafile(class System.Drawing.Imaging.Metafile metafile, valuetype System.Drawing.Rectangle destRect, valuetype System.Drawing.Rectangle srcRect, valuetype System.Drawing.GraphicsUnit unit, class System.Drawing.Graphics/EnumerateMetafileProc callback, native int callbackData, class System.Drawing.Imaging.ImageAttributes imageAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.EnumerateMetafile(System.Drawing.Imaging.Metafile,System.Drawing.Rectangle,System.Drawing.Rectangle,System.Drawing.GraphicsUnit,System.Drawing.Graphics.EnumerateMetafileProc,System.IntPtr,System.Drawing.Imaging.ImageAttributes)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EnumerateMetafile(System::Drawing::Imaging::Metafile ^ metafile, System::Drawing::Rectangle destRect, System::Drawing::Rectangle srcRect, System::Drawing::GraphicsUnit unit, System::Drawing::Graphics::EnumerateMetafileProc ^ callback, IntPtr callbackData, System::Drawing::Imaging::ImageAttributes ^ imageAttr);" />
      <MemberSignature Language="F#" Value="member this.EnumerateMetafile : System.Drawing.Imaging.Metafile * System.Drawing.Rectangle * System.Drawing.Rectangle * System.Drawing.GraphicsUnit * System.Drawing.Graphics.EnumerateMetafileProc * nativeint * System.Drawing.Imaging.ImageAttributes -&gt; unit" Usage="graphics.EnumerateMetafile (metafile, destRect, srcRect, unit, callback, callbackData, imageAttr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metafile" Type="System.Drawing.Imaging.Metafile" />
        <Parameter Name="destRect" Type="System.Drawing.Rectangle" />
        <Parameter Name="srcRect" Type="System.Drawing.Rectangle" />
        <Parameter Name="unit" Type="System.Drawing.GraphicsUnit" />
        <Parameter Name="callback" Type="System.Drawing.Graphics+EnumerateMetafileProc" />
        <Parameter Name="callbackData" Type="System.IntPtr" />
        <Parameter Name="imageAttr" Type="System.Drawing.Imaging.ImageAttributes" />
      </Parameters>
      <Docs>
        <param name="metafile">要枚举的 <see cref="T:System.Drawing.Imaging.Metafile" />。</param>
        <param name="destRect">
          <see cref="T:System.Drawing.Rectangle" /> 结构，它指定所绘制图元文件的位置和大小。</param>
        <param name="srcRect">
          <see cref="T:System.Drawing.Rectangle" /> 结构，它相对于图元文件的左上角指定要绘制的部分图元文件。</param>
        <param name="unit">
          <see cref="T:System.Drawing.GraphicsUnit" /> 枚举的成员，它指定度量单位，该度量单位用于确定 <c>srcRect</c> 参数指定的矩形所包含的部分图元文件。</param>
        <param name="callback">
          <see cref="T:System.Drawing.Graphics.EnumerateMetafileProc" /> 委托，它指定将图元文件记录发送到的方法。</param>
        <param name="callbackData">必需但被忽略的内部指针。 可以为此参数传递 <see cref="F:System.IntPtr.Zero" />。</param>
        <param name="imageAttr">
          <see cref="T:System.Drawing.Imaging.ImageAttributes" />，它指定所绘制图像的图像特性信息。</param>
        <summary>将 <see cref="T:System.Drawing.Imaging.Metafile" /> 中选定矩形内的记录逐个发送到回调方法，以在指定的矩形中用指定的图像特性显示。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法枚举指定图元文件中包含的记录。 每个记录分别发送到回调方法，通过指定`callback`参数。 通常情况下，回调方法调用<xref:System.Drawing.Imaging.Metafile.PlayRecord%2A>"播放"，或绘图、 记录的方法。  
  
 如果回调方法调用<xref:System.Drawing.Imaging.Metafile.PlayRecord%2A>，它必须通过调用实现<xref:System.Drawing.Imaging.Metafile.PlayRecord%2A>方法的特定于<xref:System.Drawing.Imaging.Metafile>正在枚举。  
  
 指定的矩形之外的任何绘制发生`srcRect`参数将被忽略。  
  
 指定的图像特性`imageAttr`指定何时写入图元文件的那些参数替换。  
  
   
  
## Examples  
 有关代码示例，请参阅 <xref:System.Drawing.Graphics.EnumerateMetafile%28System.Drawing.Imaging.Metafile%2CSystem.Drawing.Point%2CSystem.Drawing.Graphics.EnumerateMetafileProc%29>。  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">图像、位图和图元文件</related>
      </Docs>
    </Member>
    <Member MemberName="EnumerateMetafile">
      <MemberSignature Language="C#" Value="public void EnumerateMetafile (System.Drawing.Imaging.Metafile metafile, System.Drawing.RectangleF destRect, System.Drawing.RectangleF srcRect, System.Drawing.GraphicsUnit unit, System.Drawing.Graphics.EnumerateMetafileProc callback, IntPtr callbackData, System.Drawing.Imaging.ImageAttributes imageAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EnumerateMetafile(class System.Drawing.Imaging.Metafile metafile, valuetype System.Drawing.RectangleF destRect, valuetype System.Drawing.RectangleF srcRect, valuetype System.Drawing.GraphicsUnit unit, class System.Drawing.Graphics/EnumerateMetafileProc callback, native int callbackData, class System.Drawing.Imaging.ImageAttributes imageAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.EnumerateMetafile(System.Drawing.Imaging.Metafile,System.Drawing.RectangleF,System.Drawing.RectangleF,System.Drawing.GraphicsUnit,System.Drawing.Graphics.EnumerateMetafileProc,System.IntPtr,System.Drawing.Imaging.ImageAttributes)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EnumerateMetafile(System::Drawing::Imaging::Metafile ^ metafile, System::Drawing::RectangleF destRect, System::Drawing::RectangleF srcRect, System::Drawing::GraphicsUnit unit, System::Drawing::Graphics::EnumerateMetafileProc ^ callback, IntPtr callbackData, System::Drawing::Imaging::ImageAttributes ^ imageAttr);" />
      <MemberSignature Language="F#" Value="member this.EnumerateMetafile : System.Drawing.Imaging.Metafile * System.Drawing.RectangleF * System.Drawing.RectangleF * System.Drawing.GraphicsUnit * System.Drawing.Graphics.EnumerateMetafileProc * nativeint * System.Drawing.Imaging.ImageAttributes -&gt; unit" Usage="graphics.EnumerateMetafile (metafile, destRect, srcRect, unit, callback, callbackData, imageAttr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metafile" Type="System.Drawing.Imaging.Metafile" />
        <Parameter Name="destRect" Type="System.Drawing.RectangleF" />
        <Parameter Name="srcRect" Type="System.Drawing.RectangleF" />
        <Parameter Name="unit" Type="System.Drawing.GraphicsUnit" />
        <Parameter Name="callback" Type="System.Drawing.Graphics+EnumerateMetafileProc" />
        <Parameter Name="callbackData" Type="System.IntPtr" />
        <Parameter Name="imageAttr" Type="System.Drawing.Imaging.ImageAttributes" />
      </Parameters>
      <Docs>
        <param name="metafile">要枚举的 <see cref="T:System.Drawing.Imaging.Metafile" />。</param>
        <param name="destRect">
          <see cref="T:System.Drawing.RectangleF" /> 结构，它指定所绘制图元文件的位置和大小。</param>
        <param name="srcRect">
          <see cref="T:System.Drawing.RectangleF" /> 结构，它相对于图元文件的左上角指定要绘制的部分图元文件。</param>
        <param name="unit">
          <see cref="T:System.Drawing.GraphicsUnit" /> 枚举的成员，它指定度量单位，该度量单位用于确定 <c>srcRect</c> 参数指定的矩形所包含的部分图元文件。</param>
        <param name="callback">
          <see cref="T:System.Drawing.Graphics.EnumerateMetafileProc" /> 委托，它指定将图元文件记录发送到的方法。</param>
        <param name="callbackData">必需但被忽略的内部指针。 可以为此参数传递 <see cref="F:System.IntPtr.Zero" />。</param>
        <param name="imageAttr">
          <see cref="T:System.Drawing.Imaging.ImageAttributes" />，它指定所绘制图像的图像特性信息。</param>
        <summary>将 <see cref="T:System.Drawing.Imaging.Metafile" /> 中选定矩形内的记录逐个发送到回调方法，以在指定的矩形中用指定的图像特性显示。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法枚举指定图元文件中包含的记录。 每个记录分别发送到回调方法，通过指定`callback`参数。 通常情况下，回调方法调用<xref:System.Drawing.Imaging.Metafile.PlayRecord%2A>"播放"，或绘图、 记录的方法。  
  
 如果回调方法调用<xref:System.Drawing.Imaging.Metafile.PlayRecord%2A>，它必须通过调用实现<xref:System.Drawing.Imaging.Metafile.PlayRecord%2A>方法的特定于<xref:System.Drawing.Imaging.Metafile>正在枚举。  
  
 指定的矩形之外的任何绘制发生`srcRect`参数将被忽略。  
  
 指定的图像特性`imageAttr`指定何时写入图元文件的那些参数替换。  
  
   
  
## Examples  
 有关代码示例，请参阅 <xref:System.Drawing.Graphics.EnumerateMetafile%28System.Drawing.Imaging.Metafile%2CSystem.Drawing.Point%2CSystem.Drawing.Graphics.EnumerateMetafileProc%29>。  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">图像、位图和图元文件</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="ExcludeClip">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>更新此 <see cref="T:System.Drawing.Graphics" /> 的剪辑区域，以排除 <see cref="T:System.Drawing.Rectangle" /> 结构所指定的区域。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ExcludeClip">
      <MemberSignature Language="C#" Value="public void ExcludeClip (System.Drawing.Rectangle rect);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ExcludeClip(valuetype System.Drawing.Rectangle rect) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.ExcludeClip(System.Drawing.Rectangle)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ExcludeClip (rect As Rectangle)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ExcludeClip(System::Drawing::Rectangle rect);" />
      <MemberSignature Language="F#" Value="member this.ExcludeClip : System.Drawing.Rectangle -&gt; unit" Usage="graphics.ExcludeClip rect" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rect" Type="System.Drawing.Rectangle" />
      </Parameters>
      <Docs>
        <param name="rect">
          <see cref="T:System.Drawing.Rectangle" /> 结构，它指定要从剪辑区域排除的矩形。</param>
        <summary>更新此 <see cref="T:System.Drawing.Graphics" /> 的剪辑区域，以排除 <see cref="T:System.Drawing.Rectangle" /> 结构所指定的区域。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法不包括所指定的区域`rect`为当前剪辑区域中的参数，并将分配到结果区域<xref:System.Drawing.Graphics.Clip%2A>属性的<xref:System.Drawing.Graphics>。  
  
   
  
## Examples  
 下面的代码示例设计为使用 Windows 窗体，并且它需要<xref:System.Windows.Forms.PaintEventArgs> `e`，这是一个参数的<xref:System.Windows.Forms.Control.Paint>事件处理程序。 该代码执行下列操作：  
  
-   创建 100 像素 x 100 像素的矩形的左上角位于坐标 （100，100）。  
  
-   创建由矩形来定义一个区域。  
  
-   若要排除的矩形区域的剪辑区域设置。  
  
-   X 300 像素的矩形的左上角位于坐标 （0，0） 用纯色的蓝色画笔填充 300 像素。  
  
 结果是蓝色矩形，其右下角方向缺少一个正方形区域。  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples2#92](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CPP/form1.cpp#92)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples2#92](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CS/form1.cs#92)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples2#92](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/VB/form1.vb#92)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ExcludeClip">
      <MemberSignature Language="C#" Value="public void ExcludeClip (System.Drawing.Region region);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ExcludeClip(class System.Drawing.Region region) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.ExcludeClip(System.Drawing.Region)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ExcludeClip(System::Drawing::Region ^ region);" />
      <MemberSignature Language="F#" Value="member this.ExcludeClip : System.Drawing.Region -&gt; unit" Usage="graphics.ExcludeClip region" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="region" Type="System.Drawing.Region" />
      </Parameters>
      <Docs>
        <param name="region">
          <see cref="T:System.Drawing.Region" />，它指定要从剪辑区域排除的区域。</param>
        <summary>更新此 <see cref="T:System.Drawing.Graphics" /> 的剪辑区域，以排除 <see cref="T:System.Drawing.Region" /> 所指定的区域。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法不包括所指定的区域`region`为当前剪辑区域中的参数，并将分配到结果区域<xref:System.Drawing.Graphics.Clip%2A>属性的<xref:System.Drawing.Graphics>。  
  
   
  
## Examples  
 下面的代码示例设计为使用 Windows 窗体，并且它需要<xref:System.Windows.Forms.PaintEventArgs> `e`，这是一个参数的<xref:System.Windows.Forms.Control.Paint>事件处理程序。 该代码执行下列操作：  
  
-   创建 100 像素 x 100 像素的矩形的左上角位于坐标 （100，100）。  
  
-   若要排除该矩形的剪辑区域设置。  
  
-   X 300 像素的矩形的左上角位于坐标 （0，0） 用纯色的蓝色画笔填充 300 像素。  
  
 结果是其右下角方向缺少一个正方形区域蓝色矩形。  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples2#91](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CPP/form1.cpp#91)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples2#91](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CS/form1.cs#91)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples2#91](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/VB/form1.vb#91)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="FillClosedCurve">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>填充由 <see cref="T:System.Drawing.Point" /> 结构数组定义的闭合基数样条曲线的内部。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FillClosedCurve">
      <MemberSignature Language="C#" Value="public void FillClosedCurve (System.Drawing.Brush brush, System.Drawing.Point[] points);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void FillClosedCurve(class System.Drawing.Brush brush, valuetype System.Drawing.Point[] points) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.FillClosedCurve(System.Drawing.Brush,System.Drawing.Point[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void FillClosedCurve(System::Drawing::Brush ^ brush, cli::array &lt;System::Drawing::Point&gt; ^ points);" />
      <MemberSignature Language="F#" Value="member this.FillClosedCurve : System.Drawing.Brush * System.Drawing.Point[] -&gt; unit" Usage="graphics.FillClosedCurve (brush, points)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="brush" Type="System.Drawing.Brush" />
        <Parameter Name="points" Type="System.Drawing.Point[]" />
      </Parameters>
      <Docs>
        <param name="brush">确定填充特性的 <see cref="T:System.Drawing.Brush" />。</param>
        <param name="points">
          <see cref="T:System.Drawing.Point" /> 结构数组，这些结构定义样条。</param>
        <summary>填充由 <see cref="T:System.Drawing.Point" /> 结构数组定义的闭合基数样条曲线的内部。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法填充的闭合基数样条，通过在数组中每个点的内部。 如果最后一个点不匹配的第一个点，附加曲线段在最后一个点添加到第一个点，以将其关闭。  
  
 点的数组必须包含至少四个<xref:System.Drawing.Point>结构。  
  
 此方法使用默认张力 0.5。  
  
   
  
## Examples  
 下面的代码示例设计为使用 Windows 窗体，并且它需要<xref:System.Windows.Forms.PaintEventArgs> `e`，这是一个参数的<xref:System.Windows.Forms.Control.Paint>事件处理程序。 该代码执行下列操作：  
  
-   创建实心的红色画笔。  
  
-   创建四个点定义样条的数组。  
  
-   填充在屏幕上的曲线。  
  
 曲线具有默认张力 0.5。  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples2#93](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CPP/form1.cpp#93)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples2#93](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CS/form1.cs#93)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples2#93](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/VB/form1.vb#93)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="brush" /> 为 <see langword="null" />。  
  
或 
 <paramref name="points" /> 为 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="FillClosedCurve">
      <MemberSignature Language="C#" Value="public void FillClosedCurve (System.Drawing.Brush brush, System.Drawing.PointF[] points);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void FillClosedCurve(class System.Drawing.Brush brush, valuetype System.Drawing.PointF[] points) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.FillClosedCurve(System.Drawing.Brush,System.Drawing.PointF[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void FillClosedCurve(System::Drawing::Brush ^ brush, cli::array &lt;System::Drawing::PointF&gt; ^ points);" />
      <MemberSignature Language="F#" Value="member this.FillClosedCurve : System.Drawing.Brush * System.Drawing.PointF[] -&gt; unit" Usage="graphics.FillClosedCurve (brush, points)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="brush" Type="System.Drawing.Brush" />
        <Parameter Name="points" Type="System.Drawing.PointF[]" />
      </Parameters>
      <Docs>
        <param name="brush">确定填充特性的 <see cref="T:System.Drawing.Brush" />。</param>
        <param name="points">
          <see cref="T:System.Drawing.PointF" /> 结构数组，这些结构定义样条。</param>
        <summary>填充由 <see cref="T:System.Drawing.PointF" /> 结构数组定义的闭合基数样条曲线的内部。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法填充的闭合基数样条，通过在数组中每个点的内部。 如果最后一个点不匹配的第一个点，附加曲线段在最后一个点添加到第一个点，以将其关闭。  
  
 点的数组必须包含至少四个<xref:System.Drawing.PointF>结构。  
  
 此方法使用默认张力 0.5。  
  
   
  
## Examples  
 下面的代码示例设计为使用 Windows 窗体，并且它需要<xref:System.Windows.Forms.PaintEventArgs> `e`，这是一个参数的<xref:System.Windows.Forms.Control.Paint>事件处理程序。 该代码执行下列操作：  
  
-   创建实心的红色画笔。  
  
-   创建四个点定义样条的数组。  
  
-   填充在屏幕上的曲线。  
  
 曲线具有默认张力 0.5。  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples2#96](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CPP/form1.cpp#96)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples2#96](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CS/form1.cs#96)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples2#96](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/VB/form1.vb#96)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="brush" /> 为 <see langword="null" />。  
  
或 
 <paramref name="points" /> 为 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="FillClosedCurve">
      <MemberSignature Language="C#" Value="public void FillClosedCurve (System.Drawing.Brush brush, System.Drawing.Point[] points, System.Drawing.Drawing2D.FillMode fillmode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void FillClosedCurve(class System.Drawing.Brush brush, valuetype System.Drawing.Point[] points, valuetype System.Drawing.Drawing2D.FillMode fillmode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.FillClosedCurve(System.Drawing.Brush,System.Drawing.Point[],System.Drawing.Drawing2D.FillMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void FillClosedCurve(System::Drawing::Brush ^ brush, cli::array &lt;System::Drawing::Point&gt; ^ points, System::Drawing::Drawing2D::FillMode fillmode);" />
      <MemberSignature Language="F#" Value="member this.FillClosedCurve : System.Drawing.Brush * System.Drawing.Point[] * System.Drawing.Drawing2D.FillMode -&gt; unit" Usage="graphics.FillClosedCurve (brush, points, fillmode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="brush" Type="System.Drawing.Brush" />
        <Parameter Name="points" Type="System.Drawing.Point[]" />
        <Parameter Name="fillmode" Type="System.Drawing.Drawing2D.FillMode" />
      </Parameters>
      <Docs>
        <param name="brush">确定填充特性的 <see cref="T:System.Drawing.Brush" />。</param>
        <param name="points">
          <see cref="T:System.Drawing.Point" /> 结构数组，这些结构定义样条。</param>
        <param name="fillmode">
          <see cref="T:System.Drawing.Drawing2D.FillMode" /> 枚举的成员，它确定填充曲线的方式。</param>
        <summary>使用指定的填充模式填充 <see cref="T:System.Drawing.Point" /> 结构数组定义的闭合基数样条曲线的内部。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法填充的闭合基数样条，通过在数组中每个点的内部。 如果最后一个点不匹配的第一个点，附加曲线段在最后一个点添加到第一个点，以将其关闭。  
  
 点的数组必须包含至少四个<xref:System.Drawing.Point>结构。  
  
 此方法使用默认张力 0.5。  
  
   
  
## Examples  
 下面的代码示例设计为使用 Windows 窗体，并且它需要<xref:System.Windows.Forms.PaintEventArgs> `e`，这是一个参数的<xref:System.Windows.Forms.Control.Paint>事件处理程序。 该代码执行下列操作：  
  
-   创建实心的红色画笔。  
  
-   创建四个点定义样条的数组。  
  
-   填充模式设置为<xref:System.Drawing.Drawing2D.FillMode.Winding>。  
  
-   填充在屏幕上的曲线。  
  
 曲线具有默认张力 0.5。  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples2#94](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CPP/form1.cpp#94)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples2#94](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CS/form1.cs#94)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples2#94](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/VB/form1.vb#94)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="brush" /> 为 <see langword="null" />。  
  
或 
 <paramref name="points" /> 为 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="FillClosedCurve">
      <MemberSignature Language="C#" Value="public void FillClosedCurve (System.Drawing.Brush brush, System.Drawing.PointF[] points, System.Drawing.Drawing2D.FillMode fillmode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void FillClosedCurve(class System.Drawing.Brush brush, valuetype System.Drawing.PointF[] points, valuetype System.Drawing.Drawing2D.FillMode fillmode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.FillClosedCurve(System.Drawing.Brush,System.Drawing.PointF[],System.Drawing.Drawing2D.FillMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void FillClosedCurve(System::Drawing::Brush ^ brush, cli::array &lt;System::Drawing::PointF&gt; ^ points, System::Drawing::Drawing2D::FillMode fillmode);" />
      <MemberSignature Language="F#" Value="member this.FillClosedCurve : System.Drawing.Brush * System.Drawing.PointF[] * System.Drawing.Drawing2D.FillMode -&gt; unit" Usage="graphics.FillClosedCurve (brush, points, fillmode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="brush" Type="System.Drawing.Brush" />
        <Parameter Name="points" Type="System.Drawing.PointF[]" />
        <Parameter Name="fillmode" Type="System.Drawing.Drawing2D.FillMode" />
      </Parameters>
      <Docs>
        <param name="brush">确定填充特性的 <see cref="T:System.Drawing.Brush" />。</param>
        <param name="points">
          <see cref="T:System.Drawing.PointF" /> 结构数组，这些结构定义样条。</param>
        <param name="fillmode">
          <see cref="T:System.Drawing.Drawing2D.FillMode" /> 枚举的成员，它确定填充曲线的方式。</param>
        <summary>使用指定的填充模式填充 <see cref="T:System.Drawing.PointF" /> 结构数组定义的闭合基数样条曲线的内部。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法填充的闭合基数样条，通过在数组中每个点的内部。 如果最后一个点不匹配的第一个点，附加曲线段在最后一个点添加到第一个点，以将其关闭。  
  
 点的数组必须包含至少四个<xref:System.Drawing.Point>结构。  
  
 此方法使用默认张力 0.5。  
  
   
  
## Examples  
 下面的代码示例设计为使用 Windows 窗体，并且它需要<xref:System.Windows.Forms.PaintEventArgs> `e`，这是一个参数的<xref:System.Windows.Forms.Control.Paint>事件处理程序。 该代码执行下列操作：  
  
-   创建实心的红色画笔。  
  
-   创建四个点定义样条的数组。  
  
-   填充模式设置为<xref:System.Drawing.Drawing2D.FillMode.Winding>。  
  
-   填充在屏幕上的曲线。  
  
 曲线具有默认张力 0.5。  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples2#97](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CPP/form1.cpp#97)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples2#97](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CS/form1.cs#97)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples2#97](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/VB/form1.vb#97)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="brush" /> 为 <see langword="null" />。  
  
或 
 <paramref name="points" /> 为 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="FillClosedCurve">
      <MemberSignature Language="C#" Value="public void FillClosedCurve (System.Drawing.Brush brush, System.Drawing.Point[] points, System.Drawing.Drawing2D.FillMode fillmode, float tension);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void FillClosedCurve(class System.Drawing.Brush brush, valuetype System.Drawing.Point[] points, valuetype System.Drawing.Drawing2D.FillMode fillmode, float32 tension) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.FillClosedCurve(System.Drawing.Brush,System.Drawing.Point[],System.Drawing.Drawing2D.FillMode,System.Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void FillClosedCurve(System::Drawing::Brush ^ brush, cli::array &lt;System::Drawing::Point&gt; ^ points, System::Drawing::Drawing2D::FillMode fillmode, float tension);" />
      <MemberSignature Language="F#" Value="member this.FillClosedCurve : System.Drawing.Brush * System.Drawing.Point[] * System.Drawing.Drawing2D.FillMode * single -&gt; unit" Usage="graphics.FillClosedCurve (brush, points, fillmode, tension)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="brush" Type="System.Drawing.Brush" />
        <Parameter Name="points" Type="System.Drawing.Point[]" />
        <Parameter Name="fillmode" Type="System.Drawing.Drawing2D.FillMode" />
        <Parameter Name="tension" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="brush">确定填充特性的 <see cref="T:System.Drawing.Brush" />。</param>
        <param name="points">
          <see cref="T:System.Drawing.Point" /> 结构数组，这些结构定义样条。</param>
        <param name="fillmode">
          <see cref="T:System.Drawing.Drawing2D.FillMode" /> 枚举的成员，它确定填充曲线的方式。</param>
        <param name="tension">大于或等于 0.0F 的值，该值指定曲线的张力。</param>
        <summary>使用指定的填充模式和张力填充 <see cref="T:System.Drawing.Point" /> 结构数组定义的闭合基数样条曲线的内部。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法填充的闭合基数样条，通过在数组中每个点的内部。 如果最后一个点不匹配的第一个点，附加曲线段在最后一个点添加到第一个点，以将其关闭。  
  
 点的数组必须包含至少四个<xref:System.Drawing.Point>结构。  
  
 `tension`参数确定的自由绘制曲线形状。 如果的值`tension`参数为 0.0F 时，此方法绘制直线段连接的点。 通常情况下，`tension`参数小于或等于 1.0 f。 超过 1.0 f 的值将产生不正常的结果。  
  
   
  
## Examples  
 下面的代码示例设计为使用 Windows 窗体，并且它需要<xref:System.Windows.Forms.PaintEventArgs> `e`，这是一个参数的<xref:System.Windows.Forms.Control.Paint>事件处理程序。 该代码执行下列操作：  
  
-   创建实心的红色画笔。  
  
-   创建四个点定义样条的数组。  
  
-   填充模式设置为<xref:System.Drawing.Drawing2D.FillMode.Winding>。  
  
-   设置为 1.0 的张力。  
  
-   填充在屏幕上的曲线。  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples2#95](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CPP/form1.cpp#95)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples2#95](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CS/form1.cs#95)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples2#95](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/VB/form1.vb#95)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="brush" /> 为 <see langword="null" />。  
  
或 
 <paramref name="points" /> 为 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="FillClosedCurve">
      <MemberSignature Language="C#" Value="public void FillClosedCurve (System.Drawing.Brush brush, System.Drawing.PointF[] points, System.Drawing.Drawing2D.FillMode fillmode, float tension);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void FillClosedCurve(class System.Drawing.Brush brush, valuetype System.Drawing.PointF[] points, valuetype System.Drawing.Drawing2D.FillMode fillmode, float32 tension) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.FillClosedCurve(System.Drawing.Brush,System.Drawing.PointF[],System.Drawing.Drawing2D.FillMode,System.Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void FillClosedCurve(System::Drawing::Brush ^ brush, cli::array &lt;System::Drawing::PointF&gt; ^ points, System::Drawing::Drawing2D::FillMode fillmode, float tension);" />
      <MemberSignature Language="F#" Value="member this.FillClosedCurve : System.Drawing.Brush * System.Drawing.PointF[] * System.Drawing.Drawing2D.FillMode * single -&gt; unit" Usage="graphics.FillClosedCurve (brush, points, fillmode, tension)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="brush" Type="System.Drawing.Brush" />
        <Parameter Name="points" Type="System.Drawing.PointF[]" />
        <Parameter Name="fillmode" Type="System.Drawing.Drawing2D.FillMode" />
        <Parameter Name="tension" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="brush">确定填充特性的 <see cref="T:System.Drawing.Brush" />。</param>
        <param name="points">
          <see cref="T:System.Drawing.PointF" /> 结构数组，这些结构定义样条。</param>
        <param name="fillmode">
          <see cref="T:System.Drawing.Drawing2D.FillMode" /> 枚举的成员，它确定填充曲线的方式。</param>
        <param name="tension">大于或等于 0.0F 的值，该值指定曲线的张力。</param>
        <summary>使用指定的填充模式和张力填充 <see cref="T:System.Drawing.PointF" /> 结构数组定义的闭合基数样条曲线的内部。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法填充的闭合基数样条，通过在数组中每个点的内部。 如果最后一个点不匹配的第一个点，附加曲线段在最后一个点添加到第一个点，以将其关闭。  
  
 点的数组必须包含至少四个<xref:System.Drawing.Point>结构。  
  
 `tension`参数确定的自由绘制曲线形状。 如果的值`tension`参数为 0.0F 时，此方法绘制直线段连接的点。 通常情况下，`tension`参数小于或等于 1.0 f。 超过 1.0 f 的值将产生不正常的结果。  
  
   
  
## Examples  
 下面的代码示例设计为使用 Windows 窗体，并且它需要<xref:System.Windows.Forms.PaintEventArgs> `e`，这是一个参数的<xref:System.Windows.Forms.Control.Paint>事件处理程序。 该代码执行下列操作：  
  
-   创建实心的红色画笔。  
  
-   创建四个点定义样条的数组。  
  
-   填充模式设置为<xref:System.Drawing.Drawing2D.FillMode.Winding>。  
  
-   设置为 1.0 的张力。  
  
-   填充在屏幕上的曲线。  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples2#98](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CPP/form1.cpp#98)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples2#98](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CS/form1.cs#98)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples2#98](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/VB/form1.vb#98)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="brush" /> 为 <see langword="null" />。  
  
或 
 <paramref name="points" /> 为 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="FillEllipse">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>填充边框所定义的椭圆的内部，该边框由一对坐标、一个宽度和一个高度指定。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FillEllipse">
      <MemberSignature Language="C#" Value="public void FillEllipse (System.Drawing.Brush brush, System.Drawing.Rectangle rect);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void FillEllipse(class System.Drawing.Brush brush, valuetype System.Drawing.Rectangle rect) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.FillEllipse(System.Drawing.Brush,System.Drawing.Rectangle)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void FillEllipse(System::Drawing::Brush ^ brush, System::Drawing::Rectangle rect);" />
      <MemberSignature Language="F#" Value="member this.FillEllipse : System.Drawing.Brush * System.Drawing.Rectangle -&gt; unit" Usage="graphics.FillEllipse (brush, rect)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="brush" Type="System.Drawing.Brush" />
        <Parameter Name="rect" Type="System.Drawing.Rectangle" />
      </Parameters>
      <Docs>
        <param name="brush">确定填充特性的 <see cref="T:System.Drawing.Brush" />。</param>
        <param name="rect">
          <see cref="T:System.Drawing.Rectangle" /> 结构，它表示定义椭圆的边框。</param>
        <summary>填充 <see cref="T:System.Drawing.Rectangle" /> 结构指定的边框所定义的椭圆的内部。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法将填充与的椭圆的内部<xref:System.Drawing.Brush>。 椭圆定义所表示的边框的`rect`参数。  
  
   
  
## Examples  
 下面的代码示例设计为使用 Windows 窗体，并且它需要<xref:System.Windows.Forms.PaintEventArgs> `e`，这是一个参数的<xref:System.Windows.Forms.Control.Paint>事件处理程序。 该代码执行下列操作：  
  
-   创建实心的红色画笔。  
  
-   创建限定椭圆的矩形。  
  
-   填充椭圆在屏幕上。  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples2#99](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CPP/form1.cpp#99)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples2#99](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CS/form1.cs#99)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples2#99](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/VB/form1.vb#99)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="brush" /> 为 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="FillEllipse">
      <MemberSignature Language="C#" Value="public void FillEllipse (System.Drawing.Brush brush, System.Drawing.RectangleF rect);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void FillEllipse(class System.Drawing.Brush brush, valuetype System.Drawing.RectangleF rect) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.FillEllipse(System.Drawing.Brush,System.Drawing.RectangleF)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void FillEllipse(System::Drawing::Brush ^ brush, System::Drawing::RectangleF rect);" />
      <MemberSignature Language="F#" Value="member this.FillEllipse : System.Drawing.Brush * System.Drawing.RectangleF -&gt; unit" Usage="graphics.FillEllipse (brush, rect)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="brush" Type="System.Drawing.Brush" />
        <Parameter Name="rect" Type="System.Drawing.RectangleF" />
      </Parameters>
      <Docs>
        <param name="brush">确定填充特性的 <see cref="T:System.Drawing.Brush" />。</param>
        <param name="rect">
          <see cref="T:System.Drawing.RectangleF" /> 结构，它表示定义椭圆的边框。</param>
        <summary>填充 <see cref="T:System.Drawing.RectangleF" /> 结构指定的边框所定义的椭圆的内部。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法将填充与的椭圆的内部<xref:System.Drawing.Brush>。 椭圆定义所表示的边框的`rect`参数。  
  
   
  
## Examples  
 下面的代码示例设计为使用 Windows 窗体，并且它需要<xref:System.Windows.Forms.PaintEventArgs> `e`，这是一个参数的<xref:System.Windows.Forms.Control.Paint>事件处理程序。 该代码执行下列操作：  
  
-   创建实心的红色画笔。  
  
-   创建限定椭圆的矩形。  
  
-   填充椭圆在屏幕上。  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples2#100](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CPP/form1.cpp#100)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples2#100](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CS/form1.cs#100)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples2#100](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/VB/form1.vb#100)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="brush" /> 为 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="FillEllipse">
      <MemberSignature Language="C#" Value="public void FillEllipse (System.Drawing.Brush brush, int x, int y, int width, int height);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void FillEllipse(class System.Drawing.Brush brush, int32 x, int32 y, int32 width, int32 height) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.FillEllipse(System.Drawing.Brush,System.Int32,System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void FillEllipse(System::Drawing::Brush ^ brush, int x, int y, int width, int height);" />
      <MemberSignature Language="F#" Value="member this.FillEllipse : System.Drawing.Brush * int * int * int * int -&gt; unit" Usage="graphics.FillEllipse (brush, x, y, width, height)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="brush" Type="System.Drawing.Brush" />
        <Parameter Name="x" Type="System.Int32" />
        <Parameter Name="y" Type="System.Int32" />
        <Parameter Name="width" Type="System.Int32" />
        <Parameter Name="height" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="brush">确定填充特性的 <see cref="T:System.Drawing.Brush" />。</param>
        <param name="x">定义椭圆的边框的左上角的 X 坐标。</param>
        <param name="y">定义椭圆的边框的左上角的 Y 坐标。</param>
        <param name="width">定义椭圆的边框的宽度。</param>
        <param name="height">定义椭圆的边框的高度。</param>
        <summary>填充边框所定义的椭圆的内部，该边框由一对坐标、一个宽度和一个高度指定。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法将填充与的椭圆的内部<xref:System.Drawing.Brush>。 该椭圆定义由所表示的边框`x`， `y`， `width`，和`height`参数。  
  
   
  
## Examples  
 下面的代码示例设计为使用 Windows 窗体，并且它需要<xref:System.Windows.Forms.PaintEventArgs> `e`，这是一个参数的<xref:System.Windows.Forms.Control.Paint>事件处理程序。 该代码执行下列操作：  
  
-   创建实心的红色画笔。  
  
-   创建的位置和限定椭圆的矩形的大小。  
  
-   填充椭圆在屏幕上。  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples2#101](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CPP/form1.cpp#101)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples2#101](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CS/form1.cs#101)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples2#101](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/VB/form1.vb#101)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="brush" /> 为 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="FillEllipse">
      <MemberSignature Language="C#" Value="public void FillEllipse (System.Drawing.Brush brush, float x, float y, float width, float height);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void FillEllipse(class System.Drawing.Brush brush, float32 x, float32 y, float32 width, float32 height) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.FillEllipse(System.Drawing.Brush,System.Single,System.Single,System.Single,System.Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void FillEllipse(System::Drawing::Brush ^ brush, float x, float y, float width, float height);" />
      <MemberSignature Language="F#" Value="member this.FillEllipse : System.Drawing.Brush * single * single * single * single -&gt; unit" Usage="graphics.FillEllipse (brush, x, y, width, height)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="brush" Type="System.Drawing.Brush" />
        <Parameter Name="x" Type="System.Single" />
        <Parameter Name="y" Type="System.Single" />
        <Parameter Name="width" Type="System.Single" />
        <Parameter Name="height" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="brush">确定填充特性的 <see cref="T:System.Drawing.Brush" />。</param>
        <param name="x">定义椭圆的边框的左上角的 X 坐标。</param>
        <param name="y">定义椭圆的边框的左上角的 Y 坐标。</param>
        <param name="width">定义椭圆的边框的宽度。</param>
        <param name="height">定义椭圆的边框的高度。</param>
        <summary>填充边框所定义的椭圆的内部，该边框由一对坐标、一个宽度和一个高度指定。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法将填充与的椭圆的内部<xref:System.Drawing.Brush>。 该椭圆定义由所表示的边框`x`， `y`， `width`，和`height`参数。  
  
   
  
## Examples  
 下面的代码示例设计为使用 Windows 窗体，并且它需要<xref:System.Windows.Forms.PaintEventArgs> `e`，这是一个参数的<xref:System.Windows.Forms.Control.Paint>事件处理程序。 该代码执行下列操作：  
  
-   创建实心的红色画笔。  
  
-   创建的位置和限定椭圆的矩形的大小。  
  
-   填充椭圆在屏幕上。  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples2#102](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CPP/form1.cpp#102)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples2#102](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CS/form1.cs#102)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples2#102](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/VB/form1.vb#102)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="brush" /> 为 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="FillPath">
      <MemberSignature Language="C#" Value="public void FillPath (System.Drawing.Brush brush, System.Drawing.Drawing2D.GraphicsPath path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void FillPath(class System.Drawing.Brush brush, class System.Drawing.Drawing2D.GraphicsPath path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.FillPath(System.Drawing.Brush,System.Drawing.Drawing2D.GraphicsPath)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void FillPath(System::Drawing::Brush ^ brush, System::Drawing::Drawing2D::GraphicsPath ^ path);" />
      <MemberSignature Language="F#" Value="member this.FillPath : System.Drawing.Brush * System.Drawing.Drawing2D.GraphicsPath -&gt; unit" Usage="graphics.FillPath (brush, path)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="brush" Type="System.Drawing.Brush" />
        <Parameter Name="path" Type="System.Drawing.Drawing2D.GraphicsPath" />
      </Parameters>
      <Docs>
        <param name="brush">确定填充特性的 <see cref="T:System.Drawing.Brush" />。</param>
        <param name="path">
          <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />，它表示要填充的路径。</param>
        <summary>填充 <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> 的内部。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 一个<xref:System.Drawing.Drawing2D.GraphicsPath>包含一系列直线和曲线的段。 如果使用路径表示`path`参数未闭合，添加额外的线段在最后一个点来闭合该路径的第一个点。  
  
   
  
## Examples  
 下面的代码示例设计为使用 Windows 窗体，并且它需要<xref:System.Windows.Forms.PaintEventArgs> `e`，这是一个参数的<xref:System.Windows.Forms.Control.Paint>事件处理程序。 该代码执行下列操作：  
  
-   创建实心的红色画笔。  
  
-   创建图形路径对象。  
  
-   向图形路径添加一个椭圆。  
  
-   填充在屏幕上的路径。  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples2#103](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CPP/form1.cpp#103)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples2#103](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CS/form1.cs#103)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples2#103](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/VB/form1.vb#103)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="brush" /> 为 <see langword="null" />。  
  
或 
 <paramref name="path" /> 为 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="FillPie">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>填充由一对坐标、一个宽度、一个高度以及两条射线指定的椭圆所定义的扇形区的内部。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FillPie">
      <MemberSignature Language="C#" Value="public void FillPie (System.Drawing.Brush brush, System.Drawing.Rectangle rect, float startAngle, float sweepAngle);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void FillPie(class System.Drawing.Brush brush, valuetype System.Drawing.Rectangle rect, float32 startAngle, float32 sweepAngle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.FillPie(System.Drawing.Brush,System.Drawing.Rectangle,System.Single,System.Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void FillPie(System::Drawing::Brush ^ brush, System::Drawing::Rectangle rect, float startAngle, float sweepAngle);" />
      <MemberSignature Language="F#" Value="member this.FillPie : System.Drawing.Brush * System.Drawing.Rectangle * single * single -&gt; unit" Usage="graphics.FillPie (brush, rect, startAngle, sweepAngle)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="brush" Type="System.Drawing.Brush" />
        <Parameter Name="rect" Type="System.Drawing.Rectangle" />
        <Parameter Name="startAngle" Type="System.Single" />
        <Parameter Name="sweepAngle" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="brush">确定填充特性的 <see cref="T:System.Drawing.Brush" />。</param>
        <param name="rect">
          <see cref="T:System.Drawing.Rectangle" /> 结构，它表示定义该扇形区所属的椭圆的边框。</param>
        <param name="startAngle">从 x 轴沿顺时针方向旋转到扇形区第一个边所测得的角度（以度为单位）。</param>
        <param name="sweepAngle">从 <c>startAngle</c> 参数沿顺时针方向旋转到扇形区第二个边所测得的角度（以度为单位）。</param>
        <summary>填充椭圆所定义的扇形区的内部，该椭圆由 <see cref="T:System.Drawing.RectangleF" /> 结构和两条射线指定。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法填充由一段弧线的椭圆和两条射线相交的与弧的终结点定义的扇形区的内部。该椭圆的边框的定义。 扇形区包含定义的两条射线`startAngle`和`sweepAngle`参数和之间交集的射线与椭圆弧。  
  
 如果`sweepAngle`参数为大于 360 度或小于-360 度时，它被视为，就好像 360 度或-360 度，分别。  
  
   
  
## Examples  
 下面的代码示例设计为使用 Windows 窗体，并且它需要<xref:System.Windows.Forms.PaintEventArgs> `e`，这是一个参数的<xref:System.Windows.Forms.Control.Paint>事件处理程序。 该代码执行下列操作：  
  
-   创建实心的红色画笔。  
  
-   创建限定椭圆的矩形。  
  
-   定义 （相对于 x 轴） 的开始角度和扫描角度 （同时处于顺时针方向）。  
  
-   填充椭圆在屏幕上的饼形区域。  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples2#104](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CPP/form1.cpp#104)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples2#104](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CS/form1.cs#104)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples2#104](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/VB/form1.vb#104)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="brush" /> 为 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="FillPie">
      <MemberSignature Language="C#" Value="public void FillPie (System.Drawing.Brush brush, int x, int y, int width, int height, int startAngle, int sweepAngle);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void FillPie(class System.Drawing.Brush brush, int32 x, int32 y, int32 width, int32 height, int32 startAngle, int32 sweepAngle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.FillPie(System.Drawing.Brush,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void FillPie(System::Drawing::Brush ^ brush, int x, int y, int width, int height, int startAngle, int sweepAngle);" />
      <MemberSignature Language="F#" Value="member this.FillPie : System.Drawing.Brush * int * int * int * int * int * int -&gt; unit" Usage="graphics.FillPie (brush, x, y, width, height, startAngle, sweepAngle)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="brush" Type="System.Drawing.Brush" />
        <Parameter Name="x" Type="System.Int32" />
        <Parameter Name="y" Type="System.Int32" />
        <Parameter Name="width" Type="System.Int32" />
        <Parameter Name="height" Type="System.Int32" />
        <Parameter Name="startAngle" Type="System.Int32" />
        <Parameter Name="sweepAngle" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="brush">确定填充特性的 <see cref="T:System.Drawing.Brush" />。</param>
        <param name="x">边框左上角的 x 坐标，该边框定义扇形区所属的椭圆。</param>
        <param name="y">边框左上角的 y 坐标，该边框定义扇形区所属的椭圆。</param>
        <param name="width">边框的宽度，该边框定义扇形区所属的椭圆。</param>
        <param name="height">边框的高度，该边框定义扇形区所属的椭圆。</param>
        <param name="startAngle">从 x 轴沿顺时针方向旋转到扇形区第一个边所测得的角度（以度为单位）。</param>
        <param name="sweepAngle">从 <c>startAngle</c> 参数沿顺时针方向旋转到扇形区第二个边所测得的角度（以度为单位）。</param>
        <summary>填充由一对坐标、一个宽度、一个高度以及两条射线指定的椭圆所定义的扇形区的内部。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法填充由一段弧线的椭圆和两条射线相交的与弧的终结点定义的扇形区的内部。该椭圆的边框的定义。 扇形区包含定义的两条射线`startAngle`和`sweepAngle`参数和之间交集的射线与椭圆弧。  
  
 如果`sweepAngle`参数为大于 360 度或小于-360 度时，它被视为，就好像 360 度或-360 度，分别。  
  
   
  
## Examples  
 下面的代码示例设计为使用 Windows 窗体，并且它需要<xref:System.Windows.Forms.PaintEventArgs> `e`，这是一个参数的<xref:System.Windows.Forms.Control.Paint>事件处理程序。 该代码执行下列操作：  
  
-   创建实心的红色画笔。  
  
-   创建的位置和限定椭圆的矩形的大小。  
  
-   定义 （相对于 x 轴） 的开始角度和扫描角度 （同时处于顺时针方向）。  
  
-   填充椭圆在屏幕上的饼形区域。  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples2#105](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CPP/form1.cpp#105)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples2#105](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CS/form1.cs#105)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples2#105](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/VB/form1.vb#105)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="brush" /> 为 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="FillPie">
      <MemberSignature Language="C#" Value="public void FillPie (System.Drawing.Brush brush, float x, float y, float width, float height, float startAngle, float sweepAngle);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void FillPie(class System.Drawing.Brush brush, float32 x, float32 y, float32 width, float32 height, float32 startAngle, float32 sweepAngle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.FillPie(System.Drawing.Brush,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void FillPie(System::Drawing::Brush ^ brush, float x, float y, float width, float height, float startAngle, float sweepAngle);" />
      <MemberSignature Language="F#" Value="member this.FillPie : System.Drawing.Brush * single * single * single * single * single * single -&gt; unit" Usage="graphics.FillPie (brush, x, y, width, height, startAngle, sweepAngle)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="brush" Type="System.Drawing.Brush" />
        <Parameter Name="x" Type="System.Single" />
        <Parameter Name="y" Type="System.Single" />
        <Parameter Name="width" Type="System.Single" />
        <Parameter Name="height" Type="System.Single" />
        <Parameter Name="startAngle" Type="System.Single" />
        <Parameter Name="sweepAngle" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="brush">确定填充特性的 <see cref="T:System.Drawing.Brush" />。</param>
        <param name="x">边框左上角的 x 坐标，该边框定义扇形区所属的椭圆。</param>
        <param name="y">边框左上角的 y 坐标，该边框定义扇形区所属的椭圆。</param>
        <param name="width">边框的宽度，该边框定义扇形区所属的椭圆。</param>
        <param name="height">边框的高度，该边框定义扇形区所属的椭圆。</param>
        <param name="startAngle">从 x 轴沿顺时针方向旋转到扇形区第一个边所测得的角度（以度为单位）。</param>
        <param name="sweepAngle">从 <c>startAngle</c> 参数沿顺时针方向旋转到扇形区第二个边所测得的角度（以度为单位）。</param>
        <summary>填充由一对坐标、一个宽度、一个高度以及两条射线指定的椭圆所定义的扇形区的内部。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法填充由一段弧线的椭圆和两条射线相交的与弧的终结点定义的扇形区的内部。该椭圆的边框的定义。 扇形区包含定义的两条射线`startAngle`和`sweepAngle`参数和之间交集的射线与椭圆弧。  
  
 如果`sweepAngle`参数为大于 360 度或小于-360 度时，它被视为，就好像 360 度或-360 度，分别。  
  
   
  
## Examples  
 下面的代码示例设计为使用 Windows 窗体，并且它需要<xref:System.Windows.Forms.PaintEventArgs> `e`，这是一个参数的<xref:System.Windows.Forms.Control.Paint>事件处理程序。 该代码执行下列操作：  
  
-   创建实心的红色画笔。  
  
-   创建的位置和限定椭圆的矩形的大小。  
  
-   定义 （相对于 x 轴） 的开始角度和扫描角度 （同时处于顺时针方向）。  
  
-   填充椭圆在屏幕上的饼形区域。  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples2#106](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CPP/form1.cpp#106)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples2#106](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CS/form1.cs#106)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples2#106](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/VB/form1.vb#106)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="brush" /> 为 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="FillPolygon">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>填充 <see cref="T:System.Drawing.Point" /> 结构指定的点数组所定义的多边形的内部。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FillPolygon">
      <MemberSignature Language="C#" Value="public void FillPolygon (System.Drawing.Brush brush, System.Drawing.Point[] points);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void FillPolygon(class System.Drawing.Brush brush, valuetype System.Drawing.Point[] points) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.FillPolygon(System.Drawing.Brush,System.Drawing.Point[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void FillPolygon(System::Drawing::Brush ^ brush, cli::array &lt;System::Drawing::Point&gt; ^ points);" />
      <MemberSignature Language="F#" Value="member this.FillPolygon : System.Drawing.Brush * System.Drawing.Point[] -&gt; unit" Usage="graphics.FillPolygon (brush, points)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="brush" Type="System.Drawing.Brush" />
        <Parameter Name="points" Type="System.Drawing.Point[]" />
      </Parameters>
      <Docs>
        <param name="brush">确定填充特性的 <see cref="T:System.Drawing.Brush" />。</param>
        <param name="points">
          <see cref="T:System.Drawing.Point" /> 结构数组，这些结构表示要填充的多边形的顶点。</param>
        <summary>填充 <see cref="T:System.Drawing.Point" /> 结构指定的点数组所定义的多边形的内部。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 每个数组中的两个连续点指定多边形的边。 此外，如果最后一个点和第一个点不同时发生，它们指定多边形的右端。  
  
   
  
## Examples  
 下面的代码示例设计为使用 Windows 窗体，并且它需要<xref:System.Windows.Forms.PaintEventArgs> `e`，这是一个参数的<xref:System.Windows.Forms.Control.Paint>事件处理程序。 该代码执行下列操作：  
  
-   创建纯蓝色画笔。  
  
-   创建七个点来定义多边形的数组。  
  
-   填充屏幕上的多边形区域。  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples2#107](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CPP/form1.cpp#107)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples2#107](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CS/form1.cs#107)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples2#107](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/VB/form1.vb#107)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="brush" /> 为 <see langword="null" />。  
  
或 
 <paramref name="points" /> 为 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="FillPolygon">
      <MemberSignature Language="C#" Value="public void FillPolygon (System.Drawing.Brush brush, System.Drawing.PointF[] points);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void FillPolygon(class System.Drawing.Brush brush, valuetype System.Drawing.PointF[] points) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.FillPolygon(System.Drawing.Brush,System.Drawing.PointF[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void FillPolygon(System::Drawing::Brush ^ brush, cli::array &lt;System::Drawing::PointF&gt; ^ points);" />
      <MemberSignature Language="F#" Value="member this.FillPolygon : System.Drawing.Brush * System.Drawing.PointF[] -&gt; unit" Usage="graphics.FillPolygon (brush, points)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="brush" Type="System.Drawing.Brush" />
        <Parameter Name="points" Type="System.Drawing.PointF[]" />
      </Parameters>
      <Docs>
        <param name="brush">确定填充特性的 <see cref="T:System.Drawing.Brush" />。</param>
        <param name="points">
          <see cref="T:System.Drawing.PointF" /> 结构数组，这些结构表示要填充的多边形的顶点。</param>
        <summary>填充 <see cref="T:System.Drawing.PointF" /> 结构指定的点数组所定义的多边形的内部。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 每个数组中的两个连续点指定多边形的边。 此外，如果最后一个点和第一个点不同时发生，它们指定多边形的右端。  
  
   
  
## Examples  
 下面的代码示例设计为使用 Windows 窗体，并且它需要<xref:System.Windows.Forms.PaintEventArgs> `e`，这是一个参数的<xref:System.Windows.Forms.Control.Paint>事件处理程序。 该代码执行下列操作：  
  
-   创建纯蓝色画笔。  
  
-   创建七个点来定义多边形的数组。  
  
-   填充屏幕上的多边形区域。  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples2#109](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CPP/form1.cpp#109)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples2#109](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CS/form1.cs#109)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples2#109](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/VB/form1.vb#109)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="brush" /> 为 <see langword="null" />。  
  
或 
 <paramref name="points" /> 为 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="FillPolygon">
      <MemberSignature Language="C#" Value="public void FillPolygon (System.Drawing.Brush brush, System.Drawing.Point[] points, System.Drawing.Drawing2D.FillMode fillMode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void FillPolygon(class System.Drawing.Brush brush, valuetype System.Drawing.Point[] points, valuetype System.Drawing.Drawing2D.FillMode fillMode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.FillPolygon(System.Drawing.Brush,System.Drawing.Point[],System.Drawing.Drawing2D.FillMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void FillPolygon(System::Drawing::Brush ^ brush, cli::array &lt;System::Drawing::Point&gt; ^ points, System::Drawing::Drawing2D::FillMode fillMode);" />
      <MemberSignature Language="F#" Value="member this.FillPolygon : System.Drawing.Brush * System.Drawing.Point[] * System.Drawing.Drawing2D.FillMode -&gt; unit" Usage="graphics.FillPolygon (brush, points, fillMode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="brush" Type="System.Drawing.Brush" />
        <Parameter Name="points" Type="System.Drawing.Point[]" />
        <Parameter Name="fillMode" Type="System.Drawing.Drawing2D.FillMode" />
      </Parameters>
      <Docs>
        <param name="brush">确定填充特性的 <see cref="T:System.Drawing.Brush" />。</param>
        <param name="points">
          <see cref="T:System.Drawing.Point" /> 结构数组，这些结构表示要填充的多边形的顶点。</param>
        <param name="fillMode">确定填充样式的 <see cref="T:System.Drawing.Drawing2D.FillMode" /> 枚举的成员。</param>
        <summary>使用指定的填充模式填充 <see cref="T:System.Drawing.Point" /> 结构指定的点数组所定义的多边形的内部。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 每个数组中的两个连续点指定多边形的边。 此外，如果最后一个点和第一个点不同时发生，它们指定多边形的右端。  
  
   
  
## Examples  
 下面的代码示例设计为使用 Windows 窗体，并且它需要<xref:System.Windows.Forms.PaintEventArgs> `e`，这是一个参数的<xref:System.Windows.Forms.Control.Paint>事件处理程序。 该代码执行下列操作：  
  
-   创建纯蓝色画笔。  
  
-   创建七个点来定义多边形的数组。  
  
-   填充模式设置为<xref:System.Drawing.Drawing2D.FillMode.Winding>。  
  
-   填充屏幕上的多边形区域。  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples2#108](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CPP/form1.cpp#108)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples2#108](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CS/form1.cs#108)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples2#108](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/VB/form1.vb#108)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="brush" /> 为 <see langword="null" />。  
  
或 
 <paramref name="points" /> 为 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="FillPolygon">
      <MemberSignature Language="C#" Value="public void FillPolygon (System.Drawing.Brush brush, System.Drawing.PointF[] points, System.Drawing.Drawing2D.FillMode fillMode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void FillPolygon(class System.Drawing.Brush brush, valuetype System.Drawing.PointF[] points, valuetype System.Drawing.Drawing2D.FillMode fillMode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.FillPolygon(System.Drawing.Brush,System.Drawing.PointF[],System.Drawing.Drawing2D.FillMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void FillPolygon(System::Drawing::Brush ^ brush, cli::array &lt;System::Drawing::PointF&gt; ^ points, System::Drawing::Drawing2D::FillMode fillMode);" />
      <MemberSignature Language="F#" Value="member this.FillPolygon : System.Drawing.Brush * System.Drawing.PointF[] * System.Drawing.Drawing2D.FillMode -&gt; unit" Usage="graphics.FillPolygon (brush, points, fillMode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="brush" Type="System.Drawing.Brush" />
        <Parameter Name="points" Type="System.Drawing.PointF[]" />
        <Parameter Name="fillMode" Type="System.Drawing.Drawing2D.FillMode" />
      </Parameters>
      <Docs>
        <param name="brush">确定填充特性的 <see cref="T:System.Drawing.Brush" />。</param>
        <param name="points">
          <see cref="T:System.Drawing.PointF" /> 结构数组，这些结构表示要填充的多边形的顶点。</param>
        <param name="fillMode">确定填充样式的 <see cref="T:System.Drawing.Drawing2D.FillMode" /> 枚举的成员。</param>
        <summary>使用指定的填充模式填充 <see cref="T:System.Drawing.PointF" /> 结构指定的点数组所定义的多边形的内部。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 每个数组中的两个连续点指定多边形的边。 此外，如果最后一个点和第一个点不同时发生，它们指定多边形的右端。  
  
   
  
## Examples  
 下面的代码示例设计为使用 Windows 窗体，并且它需要<xref:System.Windows.Forms.PaintEventArgs> `e`，这是一个参数的<xref:System.Windows.Forms.Control.Paint>事件处理程序。 该代码执行以下操作：  
  
-   创建纯蓝色画笔。  
  
-   创建七个点来定义多边形的数组。  
  
-   填充模式设置为<xref:System.Drawing.Drawing2D.FillMode.Winding>。  
  
-   填充屏幕上的多边形区域。  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples2#110](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CPP/form1.cpp#110)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples2#110](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CS/form1.cs#110)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples2#110](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/VB/form1.vb#110)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="brush" /> 为 <see langword="null" />。  
  
或 
 <paramref name="points" /> 为 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="FillRectangle">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>填充由一对坐标、一个宽度和一个高度指定的矩形的内部。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FillRectangle">
      <MemberSignature Language="C#" Value="public void FillRectangle (System.Drawing.Brush brush, System.Drawing.Rectangle rect);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void FillRectangle(class System.Drawing.Brush brush, valuetype System.Drawing.Rectangle rect) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.FillRectangle(System.Drawing.Brush,System.Drawing.Rectangle)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void FillRectangle(System::Drawing::Brush ^ brush, System::Drawing::Rectangle rect);" />
      <MemberSignature Language="F#" Value="member this.FillRectangle : System.Drawing.Brush * System.Drawing.Rectangle -&gt; unit" Usage="graphics.FillRectangle (brush, rect)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="brush" Type="System.Drawing.Brush" />
        <Parameter Name="rect" Type="System.Drawing.Rectangle" />
      </Parameters>
      <Docs>
        <param name="brush">确定填充特性的 <see cref="T:System.Drawing.Brush" />。</param>
        <param name="rect">
          <see cref="T:System.Drawing.Rectangle" /> 结构，它表示要填充的矩形。</param>
        <summary>填充 <see cref="T:System.Drawing.Rectangle" /> 结构指定的矩形的内部。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法填充定义的矩形的内部`rect`参数，包括指定的左上角直到计算出的下边缘和右边缘。  
  
   
  
## Examples  
 下面的代码示例设计为使用 Windows 窗体，并且它需要<xref:System.Windows.Forms.PaintEventArgs> `e`，这是一个参数的<xref:System.Windows.Forms.Control.Paint>事件处理程序。 该代码执行以下操作：  
  
-   创建纯蓝色画笔。  
  
-   创建一个矩形。  
  
-   填充在屏幕上的矩形区域。  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples3#111](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CPP/form1.cpp#111)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples3#111](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CS/form1.cs#111)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples3#111](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/VB/form1.vb#111)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="brush" /> 为 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="FillRectangle">
      <MemberSignature Language="C#" Value="public void FillRectangle (System.Drawing.Brush brush, System.Drawing.RectangleF rect);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void FillRectangle(class System.Drawing.Brush brush, valuetype System.Drawing.RectangleF rect) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.FillRectangle(System.Drawing.Brush,System.Drawing.RectangleF)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void FillRectangle(System::Drawing::Brush ^ brush, System::Drawing::RectangleF rect);" />
      <MemberSignature Language="F#" Value="member this.FillRectangle : System.Drawing.Brush * System.Drawing.RectangleF -&gt; unit" Usage="graphics.FillRectangle (brush, rect)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="brush" Type="System.Drawing.Brush" />
        <Parameter Name="rect" Type="System.Drawing.RectangleF" />
      </Parameters>
      <Docs>
        <param name="brush">确定填充特性的 <see cref="T:System.Drawing.Brush" />。</param>
        <param name="rect">
          <see cref="T:System.Drawing.RectangleF" /> 结构，它表示要填充的矩形。</param>
        <summary>填充 <see cref="T:System.Drawing.RectangleF" /> 结构指定的矩形的内部。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法填充定义的矩形的内部`rect`参数，包括指定的左上角直到计算出的下边缘和右边缘。  
  
   
  
## Examples  
 下面的代码示例设计为使用 Windows 窗体，并且它需要<xref:System.Windows.Forms.PaintEventArgs> `e`，这是一个参数的<xref:System.Windows.Forms.Control.Paint>事件处理程序。 该代码执行以下操作：  
  
-   创建纯蓝色画笔。  
  
-   创建一个矩形。  
  
-   填充在屏幕上的矩形区域。  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples3#112](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CPP/form1.cpp#112)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples3#112](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CS/form1.cs#112)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples3#112](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/VB/form1.vb#112)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="brush" /> 为 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="FillRectangle">
      <MemberSignature Language="C#" Value="public void FillRectangle (System.Drawing.Brush brush, int x, int y, int width, int height);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void FillRectangle(class System.Drawing.Brush brush, int32 x, int32 y, int32 width, int32 height) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.FillRectangle(System.Drawing.Brush,System.Int32,System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void FillRectangle(System::Drawing::Brush ^ brush, int x, int y, int width, int height);" />
      <MemberSignature Language="F#" Value="member this.FillRectangle : System.Drawing.Brush * int * int * int * int -&gt; unit" Usage="graphics.FillRectangle (brush, x, y, width, height)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="brush" Type="System.Drawing.Brush" />
        <Parameter Name="x" Type="System.Int32" />
        <Parameter Name="y" Type="System.Int32" />
        <Parameter Name="width" Type="System.Int32" />
        <Parameter Name="height" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="brush">确定填充特性的 <see cref="T:System.Drawing.Brush" />。</param>
        <param name="x">要填充的矩形的左上角的 x 坐标。</param>
        <param name="y">要填充的矩形的左上角的 y 坐标。</param>
        <param name="width">要填充的矩形的宽度。</param>
        <param name="height">要填充的矩形的高度。</param>
        <summary>填充由一对坐标、一个宽度和一个高度指定的矩形的内部。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法填充定义的矩形的内部`x`， `y`， `width`，和`height`参数，包括指定的左上角直到计算出的下边缘和右边缘。  
  
   
  
## Examples  
 下面的代码示例设计为使用 Windows 窗体，并且它需要<xref:System.Windows.Forms.PaintEventArgs> `e`，这是一个参数的<xref:System.Windows.Forms.Control.Paint>事件处理程序。 该代码执行以下操作：  
  
-   创建纯蓝色画笔。  
  
-   创建的位置和大小的矩形。  
  
-   填充在屏幕上的矩形区域。  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples3#113](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CPP/form1.cpp#113)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples3#113](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CS/form1.cs#113)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples3#113](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/VB/form1.vb#113)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="brush" /> 为 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="FillRectangle">
      <MemberSignature Language="C#" Value="public void FillRectangle (System.Drawing.Brush brush, float x, float y, float width, float height);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void FillRectangle(class System.Drawing.Brush brush, float32 x, float32 y, float32 width, float32 height) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.FillRectangle(System.Drawing.Brush,System.Single,System.Single,System.Single,System.Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void FillRectangle(System::Drawing::Brush ^ brush, float x, float y, float width, float height);" />
      <MemberSignature Language="F#" Value="member this.FillRectangle : System.Drawing.Brush * single * single * single * single -&gt; unit" Usage="graphics.FillRectangle (brush, x, y, width, height)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="brush" Type="System.Drawing.Brush" />
        <Parameter Name="x" Type="System.Single" />
        <Parameter Name="y" Type="System.Single" />
        <Parameter Name="width" Type="System.Single" />
        <Parameter Name="height" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="brush">确定填充特性的 <see cref="T:System.Drawing.Brush" />。</param>
        <param name="x">要填充的矩形的左上角的 x 坐标。</param>
        <param name="y">要填充的矩形的左上角的 y 坐标。</param>
        <param name="width">要填充的矩形的宽度。</param>
        <param name="height">要填充的矩形的高度。</param>
        <summary>填充由一对坐标、一个宽度和一个高度指定的矩形的内部。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法填充定义的矩形的内部`x`， `y`， `width`，和`height`参数，包括指定的左上角直到计算出的下边缘和右边缘。  
  
   
  
## Examples  
 下面的代码示例设计为使用 Windows 窗体，并且它需要<xref:System.Windows.Forms.PaintEventArgs> `e`，这是一个参数的<xref:System.Windows.Forms.Control.Paint>事件处理程序。 该代码执行以下操作：  
  
-   创建纯蓝色画笔。  
  
-   创建的位置和大小的矩形。  
  
-   填充在屏幕上的矩形区域。  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples3#114](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CPP/form1.cpp#114)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples3#114](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CS/form1.cs#114)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples3#114](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/VB/form1.vb#114)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="brush" /> 为 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="FillRectangles">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>填充由 <see cref="T:System.Drawing.Rectangle" /> 结构指定的一系列矩形的内部。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FillRectangles">
      <MemberSignature Language="C#" Value="public void FillRectangles (System.Drawing.Brush brush, System.Drawing.Rectangle[] rects);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void FillRectangles(class System.Drawing.Brush brush, valuetype System.Drawing.Rectangle[] rects) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.FillRectangles(System.Drawing.Brush,System.Drawing.Rectangle[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void FillRectangles(System::Drawing::Brush ^ brush, cli::array &lt;System::Drawing::Rectangle&gt; ^ rects);" />
      <MemberSignature Language="F#" Value="member this.FillRectangles : System.Drawing.Brush * System.Drawing.Rectangle[] -&gt; unit" Usage="graphics.FillRectangles (brush, rects)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="brush" Type="System.Drawing.Brush" />
        <Parameter Name="rects" Type="System.Drawing.Rectangle[]" />
      </Parameters>
      <Docs>
        <param name="brush">确定填充特性的 <see cref="T:System.Drawing.Brush" />。</param>
        <param name="rects">
          <see cref="T:System.Drawing.Rectangle" /> 结构数组，这些结构表示要填充的矩形。</param>
        <summary>填充由 <see cref="T:System.Drawing.Rectangle" /> 结构指定的一系列矩形的内部。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下面的代码示例设计为使用 Windows 窗体，并且它需要<xref:System.Windows.Forms.PaintEventArgs> `e`，这是一个参数的<xref:System.Windows.Forms.Control.Paint>事件处理程序。 该代码执行以下操作：  
  
-   创建纯蓝色画笔。  
  
-   创建三个矩形的数组。  
  
-   填充在屏幕上的三个矩形区域。  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples3#115](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CPP/form1.cpp#115)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples3#115](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CS/form1.cs#115)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples3#115](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/VB/form1.vb#115)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="brush" /> 为 <see langword="null" />。  
  
或 
 <paramref name="rects" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="rects" /> 是一个长度为零的数组。</exception>
      </Docs>
    </Member>
    <Member MemberName="FillRectangles">
      <MemberSignature Language="C#" Value="public void FillRectangles (System.Drawing.Brush brush, System.Drawing.RectangleF[] rects);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void FillRectangles(class System.Drawing.Brush brush, valuetype System.Drawing.RectangleF[] rects) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.FillRectangles(System.Drawing.Brush,System.Drawing.RectangleF[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void FillRectangles(System::Drawing::Brush ^ brush, cli::array &lt;System::Drawing::RectangleF&gt; ^ rects);" />
      <MemberSignature Language="F#" Value="member this.FillRectangles : System.Drawing.Brush * System.Drawing.RectangleF[] -&gt; unit" Usage="graphics.FillRectangles (brush, rects)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="brush" Type="System.Drawing.Brush" />
        <Parameter Name="rects" Type="System.Drawing.RectangleF[]" />
      </Parameters>
      <Docs>
        <param name="brush">确定填充特性的 <see cref="T:System.Drawing.Brush" />。</param>
        <param name="rects">
          <see cref="T:System.Drawing.RectangleF" /> 结构数组，这些结构表示要填充的矩形。</param>
        <summary>填充由 <see cref="T:System.Drawing.RectangleF" /> 结构指定的一系列矩形的内部。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下面的代码示例设计为使用 Windows 窗体，并且它需要<xref:System.Windows.Forms.PaintEventArgs> `e`，这是一个参数的<xref:System.Windows.Forms.Control.Paint>事件处理程序。 该代码执行以下操作：  
  
-   创建纯蓝色画笔。  
  
-   创建三个矩形的数组。  
  
-   填充在屏幕上的三个矩形区域。  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples3#116](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CPP/form1.cpp#116)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples3#116](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CS/form1.cs#116)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples3#116](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/VB/form1.vb#116)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="brush" /> 为 <see langword="null" />。  
  
或 
 <paramref name="rects" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="Rects" /> 是一个长度为零的数组。</exception>
      </Docs>
    </Member>
    <Member MemberName="FillRegion">
      <MemberSignature Language="C#" Value="public void FillRegion (System.Drawing.Brush brush, System.Drawing.Region region);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void FillRegion(class System.Drawing.Brush brush, class System.Drawing.Region region) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.FillRegion(System.Drawing.Brush,System.Drawing.Region)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void FillRegion(System::Drawing::Brush ^ brush, System::Drawing::Region ^ region);" />
      <MemberSignature Language="F#" Value="member this.FillRegion : System.Drawing.Brush * System.Drawing.Region -&gt; unit" Usage="graphics.FillRegion (brush, region)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="brush" Type="System.Drawing.Brush" />
        <Parameter Name="region" Type="System.Drawing.Region" />
      </Parameters>
      <Docs>
        <param name="brush">确定填充特性的 <see cref="T:System.Drawing.Brush" />。</param>
        <param name="region">
          <see cref="T:System.Drawing.Region" />，它表示要填充的区域。</param>
        <summary>填充 <see cref="T:System.Drawing.Region" /> 的内部。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 一个<xref:System.Drawing.Region>由矩形和路径组成。 如果区域未关闭，其他段在最后一个点添加到第一个点，以将其关闭。  
  
   
  
## Examples  
 下面的代码示例设计为使用 Windows 窗体，并且它需要<xref:System.Windows.Forms.PaintEventArgs> `e`，这是一个参数的<xref:System.Windows.Forms.Control.Paint>事件处理程序。 该代码执行以下操作：  
  
-   创建纯蓝色画笔。  
  
-   创建一个矩形。  
  
-   创建一个矩形区域。  
  
-   填充在屏幕上的矩形区域。  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples3#117](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CPP/form1.cpp#117)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples3#117](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CS/form1.cs#117)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples3#117](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/VB/form1.vb#117)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="brush" /> 为 <see langword="null" />。  
  
或 
 <paramref name="region" /> 为 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~Graphics ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!Graphics ()" />
      <MemberSignature Language="F#" Value="override this.Finalize : unit -&gt; unit" Usage="graphics.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>在垃圾回收将某一对象回收前允许该对象尝试释放资源并执行其他清理操作。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Flush">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>强制执行所有挂起的图形操作并立即返回而不等待操作完成。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Flush">
      <MemberSignature Language="C#" Value="public void Flush ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Flush() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.Flush" />
      <MemberSignature Language="VB.NET" Value="Public Sub Flush ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Flush();" />
      <MemberSignature Language="F#" Value="member this.Flush : unit -&gt; unit" Usage="graphics.Flush " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>强制执行所有挂起的图形操作并立即返回而不等待操作完成。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法启动刷新，而无需等待任何当前正在执行图形操作完成时立即返回。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Flush">
      <MemberSignature Language="C#" Value="public void Flush (System.Drawing.Drawing2D.FlushIntention intention);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Flush(valuetype System.Drawing.Drawing2D.FlushIntention intention) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.Flush(System.Drawing.Drawing2D.FlushIntention)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Flush (intention As FlushIntention)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Flush(System::Drawing::Drawing2D::FlushIntention intention);" />
      <MemberSignature Language="F#" Value="member this.Flush : System.Drawing.Drawing2D.FlushIntention -&gt; unit" Usage="graphics.Flush intention" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="intention" Type="System.Drawing.Drawing2D.FlushIntention" />
      </Parameters>
      <Docs>
        <param name="intention">
          <see cref="T:System.Drawing.Drawing2D.FlushIntention" /> 枚举的成员，它指定该方法是立即返回还是等待所有现有的操作都完成。</param>
        <summary>用此方法强制执行所有挂起的图形操作，按照指定，等待或者不等待，在操作完成之前返回。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 值为<xref:System.Drawing.Drawing2D.FlushIntention.Flush>有关`intention`参数指定该方法返回从开始时的值在刷新后立即<xref:System.Drawing.Drawing2D.FlushIntention.Sync>指定返回前等待该方法，直到所有现有的操作完成。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="FromHdc">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>从设备上下文的指定句柄创建新的 <see cref="T:System.Drawing.Graphics" />。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FromHdc">
      <MemberSignature Language="C#" Value="public static System.Drawing.Graphics FromHdc (IntPtr hdc);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Drawing.Graphics FromHdc(native int hdc) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.FromHdc(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FromHdc (hdc As IntPtr) As Graphics" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Drawing::Graphics ^ FromHdc(IntPtr hdc);" />
      <MemberSignature Language="F#" Value="static member FromHdc : nativeint -&gt; System.Drawing.Graphics" Usage="System.Drawing.Graphics.FromHdc hdc" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netcore-2.1;dotnet-plat-ext-2.1">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Graphics</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="hdc" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="hdc">设备上下文的句柄。</param>
        <summary>从设备上下文的指定句柄创建新的 <see cref="T:System.Drawing.Graphics" />。</summary>
        <returns>此方法为指定的设备上下文返回新的 <see cref="T:System.Drawing.Graphics" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 应始终调用<xref:System.Drawing.Graphics.Dispose%2A>方法，以释放<xref:System.Drawing.Graphics>和相关的资源创建的<xref:System.Drawing.Graphics.FromHdc%2A>方法。  
  
 即使显示设备的关联的 ICM 颜色配置文件，[!INCLUDE[ndptecgdiplus](~/includes/ndptecgdiplus-md.md)]不会默认情况下使用该配置文件。 若要启用的 ICM <xref:System.Drawing.Graphics>，构造<xref:System.Drawing.Graphics>HDC 后 HDC （和 ICM_ON） 传递给从`SetICMMode`函数。 然后通过任何绘图<xref:System.Drawing.Graphics>将根据关联的显示设备的 ICM 配置文件进行调整。 启用 ICM 将导致性能下降。  
  
 调用时的设备上下文 （映射模式、 逻辑单元等） 的状态<xref:System.Drawing.Graphics.FromHdc%2A>可能会影响呈现通过<xref:System.Drawing.Graphics>。  
  
   
  
## Examples  
 下面的代码示例设计为使用 Windows 窗体，并且它需要<xref:System.Windows.Forms.PaintEventArgs> `e`，这是一个参数的<xref:System.Windows.Forms.Control.Paint>事件处理程序。 该代码执行以下操作：  
  
-   创建一个内部指针类型变量`hdc`并将其设置为窗体的图形对象的设备上下文的句柄。  
  
-   创建一个新的图形对象使用`hdc`。  
  
-   （屏幕） 上绘制一个具有新的图形对象的矩形。  
  
-   释放新图形对象使用`hdc`。  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples3#118](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CPP/form1.cpp#118)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples3#118](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CS/form1.cs#118)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples3#118](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/VB/form1.vb#118)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FromHdc">
      <MemberSignature Language="C#" Value="public static System.Drawing.Graphics FromHdc (IntPtr hdc, IntPtr hdevice);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Drawing.Graphics FromHdc(native int hdc, native int hdevice) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.FromHdc(System.IntPtr,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FromHdc (hdc As IntPtr, hdevice As IntPtr) As Graphics" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Drawing::Graphics ^ FromHdc(IntPtr hdc, IntPtr hdevice);" />
      <MemberSignature Language="F#" Value="static member FromHdc : nativeint * nativeint -&gt; System.Drawing.Graphics" Usage="System.Drawing.Graphics.FromHdc (hdc, hdevice)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netcore-2.1;dotnet-plat-ext-2.1">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Graphics</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="hdc" Type="System.IntPtr" />
        <Parameter Name="hdevice" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="hdc">设备上下文的句柄。</param>
        <param name="hdevice">设备的句柄。</param>
        <summary>从设备上下文的指定句柄和设备的句柄创建新的 <see cref="T:System.Drawing.Graphics" />。</summary>
        <returns>此方法为指定的设备上下文和设备返回新的 <see cref="T:System.Drawing.Graphics" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 应始终调用<xref:System.Drawing.Graphics.Dispose%2A>方法，以释放<xref:System.Drawing.Graphics>和相关的资源创建的<xref:System.Drawing.Graphics.FromHdc%2A>方法。  
  
 即使显示设备的关联的 ICM 颜色配置文件，[!INCLUDE[ndptecgdiplus](~/includes/ndptecgdiplus-md.md)]不会默认情况下使用该配置文件。 若要启用的 ICM <xref:System.Drawing.Graphics>，构造<xref:System.Drawing.Graphics>HDC 后 HDC （和 ICM_ON） 传递给从`SetICMMode`函数。 然后通过任何绘图<xref:System.Drawing.Graphics>将根据关联的显示设备的 ICM 配置文件进行调整。 启用 ICM 将导致性能下降。  
  
 调用时的设备上下文 （映射模式、 逻辑单元等） 的状态<xref:System.Drawing.Graphics.FromHdc%2A>可能会影响呈现通过<xref:System.Drawing.Graphics>。  
  
 查询特定的打印机功能通常用于设备句柄。  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">用于访问非托管代码。 相关的枚举： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />。</permission>
      </Docs>
    </Member>
    <Member MemberName="FromHdcInternal">
      <MemberSignature Language="C#" Value="public static System.Drawing.Graphics FromHdcInternal (IntPtr hdc);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Drawing.Graphics FromHdcInternal(native int hdc) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.FromHdcInternal(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FromHdcInternal (hdc As IntPtr) As Graphics" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Drawing::Graphics ^ FromHdcInternal(IntPtr hdc);" />
      <MemberSignature Language="F#" Value="static member FromHdcInternal : nativeint -&gt; System.Drawing.Graphics" Usage="System.Drawing.Graphics.FromHdcInternal hdc" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netcore-2.1;dotnet-plat-ext-2.1">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Graphics</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="hdc" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="hdc">设备上下文的句柄。</param>
        <summary>返回指定设备上下文的 <see cref="T:System.Drawing.Graphics" />。</summary>
        <returns>指定设备上下文的 <see cref="T:System.Drawing.Graphics" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 不应使用此方法。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FromHwnd">
      <MemberSignature Language="C#" Value="public static System.Drawing.Graphics FromHwnd (IntPtr hwnd);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Drawing.Graphics FromHwnd(native int hwnd) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.FromHwnd(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FromHwnd (hwnd As IntPtr) As Graphics" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Drawing::Graphics ^ FromHwnd(IntPtr hwnd);" />
      <MemberSignature Language="F#" Value="static member FromHwnd : nativeint -&gt; System.Drawing.Graphics" Usage="System.Drawing.Graphics.FromHwnd hwnd" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netcore-2.1;dotnet-plat-ext-2.1">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Graphics</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="hwnd" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="hwnd">窗口的句柄。</param>
        <summary>从窗口的指定句柄创建新的 <see cref="T:System.Drawing.Graphics" />。</summary>
        <returns>此方法为指定的窗口句柄返回新的 <see cref="T:System.Drawing.Graphics" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 应始终调用<xref:System.Drawing.Graphics.Dispose%2A>方法，以释放<xref:System.Drawing.Graphics>和相关的资源创建的<xref:System.Drawing.Graphics.FromHwnd%2A>方法。  
  
   
  
## Examples  
 下面的代码示例设计为使用 Windows 窗体，并且它需要<xref:System.Windows.Forms.PaintEventArgs> `e`，这是一个参数的<xref:System.Windows.Forms.Control.Paint>事件处理程序，以及`thisForm`，则<xref:System.Windows.Forms.Form>的示例。 该代码执行下列操作：  
  
-   创建一个新的内部指针变量`hwnd`并将其设置为该示例的窗体的句柄。  
  
-   创建一个新<xref:System.Drawing.Graphics>从句柄。  
  
-   向新绘制一个矩形<xref:System.Drawing.Graphics>使用红色笔。  
  
-   释放新<xref:System.Drawing.Graphics>。  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples3#119](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CPP/form1.cpp#119)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples3#119](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CS/form1.cs#119)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples3#119](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/VB/form1.vb#119)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">用于访问非托管代码。 相关的枚举： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />。</permission>
      </Docs>
    </Member>
    <Member MemberName="FromHwndInternal">
      <MemberSignature Language="C#" Value="public static System.Drawing.Graphics FromHwndInternal (IntPtr hwnd);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Drawing.Graphics FromHwndInternal(native int hwnd) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.FromHwndInternal(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FromHwndInternal (hwnd As IntPtr) As Graphics" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Drawing::Graphics ^ FromHwndInternal(IntPtr hwnd);" />
      <MemberSignature Language="F#" Value="static member FromHwndInternal : nativeint -&gt; System.Drawing.Graphics" Usage="System.Drawing.Graphics.FromHwndInternal hwnd" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netcore-2.1;dotnet-plat-ext-2.1">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Graphics</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="hwnd" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="hwnd">窗口的句柄。</param>
        <summary>创建指定 Windows 句柄的新 <see cref="T:System.Drawing.Graphics" />。</summary>
        <returns>指定窗口句柄的 <see cref="T:System.Drawing.Graphics" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 不应使用此方法。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FromImage">
      <MemberSignature Language="C#" Value="public static System.Drawing.Graphics FromImage (System.Drawing.Image image);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Drawing.Graphics FromImage(class System.Drawing.Image image) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.FromImage(System.Drawing.Image)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Drawing::Graphics ^ FromImage(System::Drawing::Image ^ image);" />
      <MemberSignature Language="F#" Value="static member FromImage : System.Drawing.Image -&gt; System.Drawing.Graphics" Usage="System.Drawing.Graphics.FromImage image" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Graphics</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="image" Type="System.Drawing.Image" />
      </Parameters>
      <Docs>
        <param name="image">从中创建新 <see cref="T:System.Drawing.Graphics" /> 的 <see cref="T:System.Drawing.Image" />。</param>
        <summary>从指定的 <see cref="T:System.Drawing.Image" /> 创建新的 <see cref="T:System.Drawing.Graphics" />。</summary>
        <returns>此方法为指定的 <see cref="T:System.Drawing.Image" /> 返回一个新的 <see cref="T:System.Drawing.Graphics" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果图像具有索引的像素格式，此方法将引发异常并显示消息，"图形对象不能从映像创建具有索引的像素格式。" 以下列表中显示索引的像素格式。  
  
-   <xref:System.Drawing.Imaging.PixelFormat.Format1bppIndexed>  
  
-   <xref:System.Drawing.Imaging.PixelFormat.Format4bppIndexed>  
  
-   <xref:System.Drawing.Imaging.PixelFormat.Format8bppIndexed>  
  
 您可以将索引的图像保存为另一种格式中使用<xref:System.Drawing.Image.Save%28System.String%2CSystem.Drawing.Imaging.ImageFormat%29>方法，然后检索<xref:System.Drawing.Graphics>对象为新映像。  
  
 如果该图像具有任一以下的像素格式，则此方法还会引发异常。  
  
-   <xref:System.Drawing.Imaging.PixelFormat.Undefined>  
  
-   <xref:System.Drawing.Imaging.PixelFormat.DontCare>  
  
-   <xref:System.Drawing.Imaging.PixelFormat.Format16bppArgb1555>  
  
-   <xref:System.Drawing.Imaging.PixelFormat.Format16bppGrayScale>  
  
 应始终调用<xref:System.Drawing.Graphics.Dispose%2A>方法，以释放<xref:System.Drawing.Graphics>和相关的资源创建的<xref:System.Drawing.Graphics.FromImage%2A>方法。  
  
   
  
## Examples  
 下面的代码示例设计为使用 Windows 窗体，并且它需要<xref:System.Windows.Forms.PaintEventArgs> `e`，这是一个参数的<xref:System.Windows.Forms.Control.Paint>事件处理程序。 该代码执行以下操作：  
  
-   创建<xref:System.Drawing.Image>从一种图形文件 sampimag.jpg 位于同示例文件夹中。  
  
-   创建<xref:System.Drawing.Graphics>从<xref:System.Drawing.Image>。  
  
-   通过填充在其中一个矩形来改变该图像。  
  
-   绘制<xref:System.Drawing.Image>到屏幕。  
  
-   释放所创建<xref:System.Drawing.Graphics>。  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples3#120](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CPP/form1.cpp#120)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples3#120](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CS/form1.cs#120)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples3#120](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/VB/form1.vb#120)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="image" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.Exception">
          <paramref name="image" /> 具有索引像素格式，或者格式未定义。</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/737bae30-e599-4e1d-bf30-bab8280b32be">如何：在运行时创建位图</related>
        <related type="Article" href="https://msdn.microsoft.com/library/a626d701-bd99-4fd8-b92f-7b8f794e042b">使用图像、位图、图标和图元文件</related>
        <related type="Article" href="https://msdn.microsoft.com/library/162861f9-f050-445e-8abb-b2c43a918b8b">如何：创建用于绘制的 Graphics 对象</related>
      </Docs>
    </Member>
    <Member MemberName="GetContextInfo">
      <MemberSignature Language="C#" Value="public object GetContextInfo ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetContextInfo() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.GetContextInfo" />
      <MemberSignature Language="VB.NET" Value="Public Function GetContextInfo () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetContextInfo();" />
      <MemberSignature Language="F#" Value="member this.GetContextInfo : unit -&gt; obj" Usage="graphics.GetContextInfo " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netcore-2.1;dotnet-plat-ext-2.1">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>获取累积的图形上下文。</summary>
        <returns>一个 <see cref="T:System.Object" />，表示累积的图形上下文。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 返回值是一个对象数组，其中第一个元素包含累积的剪辑区域，第二个元素包含累积/转换转换矩阵。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHalftonePalette">
      <MemberSignature Language="C#" Value="public static IntPtr GetHalftonePalette ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int GetHalftonePalette() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.GetHalftonePalette" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetHalftonePalette () As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr GetHalftonePalette();" />
      <MemberSignature Language="F#" Value="static member GetHalftonePalette : unit -&gt; nativeint" Usage="System.Drawing.Graphics.GetHalftonePalette " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>获取当前 Windows 的半色调调色板的句柄。</summary>
        <returns>指定调色板的句柄的内部指针。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 目的<xref:System.Drawing.Graphics.GetHalftonePalette%2A>方法是启用[!INCLUDE[ndptecgdiplus](~/includes/ndptecgdiplus-md.md)]时可生成更好的质量半色调显示使用每像素 8 位。 若要显示的图像使用半色调调色板，请使用以下过程。  
  
   
  
## Examples  
 下面的代码示例设计为使用 Windows 窗体，并且它需要<xref:System.Windows.Forms.PaintEventArgs> `e`，这是一个参数的<xref:System.Windows.Forms.Control.Paint>事件处理程序。 该代码执行下列操作：  
  
-   定义的互操作性<xref:System.Runtime.InteropServices.DllImportAttribute>属性包含所需的 Windows DLL 文件 gdi32.dll[!INCLUDE[ndptecgdi](~/includes/ndptecgdi-md.md)]函数。  
  
-   定义`SelectPalette`和`RealizePalette`为外部该 DLL 中的函数。  
  
-   从 sampimag.jpg （它必须在示例代码文件所在的同一文件夹中） 位于同一个现有图像文件创建映像并将图像绘制到屏幕。  
  
-   创建内部指针类型的变量并将其值分别设置为图形对象和当前 Windows 半色调调色板的句柄。  
  
-   选择和实现半色调调色板。  
  
-   创建一个新的图形对象使用`hdc`参数。  
  
-   再次绘制的图像。  
  
-   释放设备上下文的句柄。  
  
 结果是两个呈现的示例图像： 一种具有 16 位调色板，另一个使用 8 位调色板。  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples3#121](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CPP/form1.cpp#121)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples3#121](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CS/form1.cs#121)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples3#121](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/VB/form1.vb#121)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHdc">
      <MemberSignature Language="C#" Value="public IntPtr GetHdc ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance native int GetHdc() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.GetHdc" />
      <MemberSignature Language="VB.NET" Value="Public Function GetHdc () As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IntPtr GetHdc();" />
      <MemberSignature Language="F#" Value="abstract member GetHdc : unit -&gt; nativeint&#xA;override this.GetHdc : unit -&gt; nativeint" Usage="graphics.GetHdc " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Drawing.IDeviceContext.GetHdc</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>获取与此 <see cref="T:System.Drawing.Graphics" /> 关联的设备上下文的句柄。</summary>
        <returns>与此 <see cref="T:System.Drawing.Graphics" /> 关联的设备上下文的句柄。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 设备上下文是一种 Windows 结构基于[!INCLUDE[ndptecgdi](~/includes/ndptecgdi-md.md)]，它定义一组图形对象和其关联的属性，以及影响输出的图形模式。 此方法返回一种字体除了该设备上下文。 由于未选择一种字体，调用<xref:System.Drawing.Font.FromHdc%2A>方法使用从返回的句柄<xref:System.Drawing.Graphics.GetHdc%2A>方法将失败。  
  
 调用<xref:System.Drawing.Graphics.GetHdc%2A>和<xref:System.Drawing.Graphics.ReleaseHdc%2A>方法必须成对出现。 期间的作用域<xref:System.Drawing.Graphics.GetHdc%2A>并<xref:System.Drawing.Graphics.ReleaseHdc%2A>方法对您通常仅对进行调用[!INCLUDE[ndptecgdi](~/includes/ndptecgdi-md.md)]函数。 在该作用域对[!INCLUDE[ndptecgdiplus](~/includes/ndptecgdiplus-md.md)]的方法<xref:System.Drawing.Graphics>生成`hdc`参数因`ObjectBusy`错误。 此外，[!INCLUDE[ndptecgdiplus](~/includes/ndptecgdiplus-md.md)]将忽略进行的任何状态更改<xref:System.Drawing.Graphics>的`hdc`后续操作中的参数。  
  
   
  
## Examples  
 下面的代码示例设计为使用 Windows 窗体，并且它需要<xref:System.Windows.Forms.PaintEventArgs> `e`，这是一个参数的<xref:System.Windows.Forms.Control.Paint>事件处理程序。 该示例演示如何调用 Windows[!INCLUDE[ndptecgdi](~/includes/ndptecgdi-md.md)]函数来执行相同的任务[!INCLUDE[ndptecgdiplus](~/includes/ndptecgdiplus-md.md)]<xref:System.Drawing.Graphics>方法。 该代码执行下列操作：  
  
-   定义互操作性<xref:System.Runtime.InteropServices.DllImportAttribute>Windows DLL 文件 gdi32.dll 的属性。 此 DLL 包含所需[!INCLUDE[ndptecgdi](~/includes/ndptecgdi-md.md)]函数。  
  
-   定义<xref:System.Drawing.Rectangle>为外部该 DLL 中的函数。  
  
-   创建红色笔。  
  
-   使用笔，向屏幕使用绘制一个矩形[!INCLUDE[ndptecgdiplus](~/includes/ndptecgdiplus-md.md)]<xref:System.Drawing.Graphics.DrawRectangle%2A>方法。  
  
-   定义一个内部指针类型变量`hdc`并将其值设置为窗体的设备上下文的句柄。  
  
-   向屏幕使用绘制一个矩形[!INCLUDE[ndptecgdi](~/includes/ndptecgdi-md.md)]<xref:System.Drawing.Rectangle>函数。  
  
-   释放所表示的设备上下文`hdc`参数。  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples3#122](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CPP/form1.cpp#122)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples3#122](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CS/form1.cs#122)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples3#122](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/VB/form1.vb#122)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">用于访问非托管代码。 相关的枚举： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />。</permission>
      </Docs>
    </Member>
    <Member MemberName="GetNearestColor">
      <MemberSignature Language="C#" Value="public System.Drawing.Color GetNearestColor (System.Drawing.Color color);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Drawing.Color GetNearestColor(valuetype System.Drawing.Color color) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.GetNearestColor(System.Drawing.Color)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Drawing::Color GetNearestColor(System::Drawing::Color color);" />
      <MemberSignature Language="F#" Value="member this.GetNearestColor : System.Drawing.Color -&gt; System.Drawing.Color" Usage="graphics.GetNearestColor color" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Color</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="color" Type="System.Drawing.Color" />
      </Parameters>
      <Docs>
        <param name="color">
          <see cref="T:System.Drawing.Color" /> 结构，为其查找匹配项。</param>
        <summary>获取与指定的 <see cref="T:System.Drawing.Color" /> 结构最接近的颜色。</summary>
        <returns>一个 <see cref="T:System.Drawing.Color" /> 结构，它表示与 <paramref name="color" /> 参数指定的颜色最接近的颜色。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下面的代码示例设计为使用 Windows 窗体，并且它需要<xref:System.Windows.Forms.PaintEventArgs> `e`，这是一个参数的<xref:System.Windows.Forms.Control.Paint>事件处理程序。 该代码执行下列操作：  
  
-   使用 ARGB 坐标 （255，165，63，第 136） 创建随机的颜色。  
  
-   创建实心画笔，并将其颜色设置为指定的颜色。  
  
-   填充椭圆使用随机的颜色。  
  
-   创建第二种颜色，并将其设置为最接近的系统 ARGB 颜色。  
  
-   使用此颜色填充第二个椭圆。  
  
 结果是两个椭圆组成： 第一个使用任意指定的颜色和第二个使用最近的指定颜色的系统颜色绘制绘制。  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples3#123](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CPP/form1.cpp#123)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples3#123](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CS/form1.cs#123)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples3#123](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/VB/form1.vb#123)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InterpolationMode">
      <MemberSignature Language="C#" Value="public System.Drawing.Drawing2D.InterpolationMode InterpolationMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Drawing2D.InterpolationMode InterpolationMode" />
      <MemberSignature Language="DocId" Value="P:System.Drawing.Graphics.InterpolationMode" />
      <MemberSignature Language="VB.NET" Value="Public Property InterpolationMode As InterpolationMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::Drawing2D::InterpolationMode InterpolationMode { System::Drawing::Drawing2D::InterpolationMode get(); void set(System::Drawing::Drawing2D::InterpolationMode value); };" />
      <MemberSignature Language="F#" Value="member this.InterpolationMode : System.Drawing.Drawing2D.InterpolationMode with get, set" Usage="System.Drawing.Graphics.InterpolationMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Drawing2D.InterpolationMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置与此 <see cref="T:System.Drawing.Graphics" /> 关联的插补模式。</summary>
        <value>
          <see cref="T:System.Drawing.Drawing2D.InterpolationMode" /> 值之一。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 内插模式确定如何中间值两个终结点进行计算。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="IntersectClip">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>将此 <see cref="T:System.Drawing.Graphics" /> 的剪辑区域更新为当前剪辑区域与指定 <see cref="T:System.Drawing.Rectangle" /> 结构的交集。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IntersectClip">
      <MemberSignature Language="C#" Value="public void IntersectClip (System.Drawing.Rectangle rect);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void IntersectClip(valuetype System.Drawing.Rectangle rect) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.IntersectClip(System.Drawing.Rectangle)" />
      <MemberSignature Language="VB.NET" Value="Public Sub IntersectClip (rect As Rectangle)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void IntersectClip(System::Drawing::Rectangle rect);" />
      <MemberSignature Language="F#" Value="member this.IntersectClip : System.Drawing.Rectangle -&gt; unit" Usage="graphics.IntersectClip rect" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rect" Type="System.Drawing.Rectangle" />
      </Parameters>
      <Docs>
        <param name="rect">与当前剪辑区域相交的 <see cref="T:System.Drawing.Rectangle" /> 结构。</param>
        <summary>将此 <see cref="T:System.Drawing.Graphics" /> 的剪辑区域更新为当前剪辑区域与指定 <see cref="T:System.Drawing.Rectangle" /> 结构的交集。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法将分配给<xref:System.Drawing.Graphics.Clip%2A>属性的这<xref:System.Drawing.Graphics>所表示为当前剪辑区域和指定的矩形的交集的区域`rect`参数。  
  
   
  
## Examples  
 下面的代码示例设计为使用 Windows 窗体，并且它需要<xref:System.Windows.Forms.PaintEventArgs> `e`，这是一个参数的<xref:System.Windows.Forms.Control.Paint>事件处理程序。 该代码执行下列操作：  
  
-   创建一个矩形左上角位于 （0，0） 和剪辑区域设置与此矩形。  
  
-   创建其左上角位于第二个矩形 （100，100），并设置为当前剪辑区域 （第一个矩形） 此矩形的交集的剪辑区域。  
  
-   填充一个大的矩形包含用纯色的蓝色画笔前两个矩形。  
  
-   将剪辑区域重置为无限。  
  
-   在两个剪辑区域周围绘制矩形。 它使用黑色笔的第一个剪辑矩形和红色钢笔的第二个剪辑区域。  
  
 结果是只有两个矩形的交集用蓝色填充。  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples3#124](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CPP/form1.cpp#124)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples3#124](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CS/form1.cs#124)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples3#124](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/VB/form1.vb#124)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IntersectClip">
      <MemberSignature Language="C#" Value="public void IntersectClip (System.Drawing.RectangleF rect);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void IntersectClip(valuetype System.Drawing.RectangleF rect) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.IntersectClip(System.Drawing.RectangleF)" />
      <MemberSignature Language="VB.NET" Value="Public Sub IntersectClip (rect As RectangleF)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void IntersectClip(System::Drawing::RectangleF rect);" />
      <MemberSignature Language="F#" Value="member this.IntersectClip : System.Drawing.RectangleF -&gt; unit" Usage="graphics.IntersectClip rect" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rect" Type="System.Drawing.RectangleF" />
      </Parameters>
      <Docs>
        <param name="rect">与当前剪辑区域相交的 <see cref="T:System.Drawing.RectangleF" /> 结构。</param>
        <summary>将此 <see cref="T:System.Drawing.Graphics" /> 的剪辑区域更新为当前剪辑区域与指定 <see cref="T:System.Drawing.RectangleF" /> 结构的交集。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法将分配给<xref:System.Drawing.Graphics.Clip%2A>属性的这<xref:System.Drawing.Graphics>所表示为当前剪辑区域和指定的矩形的交集的区域`rect`参数。  
  
   
  
## Examples  
 下面的代码示例设计为使用 Windows 窗体，并且它需要<xref:System.Windows.Forms.PaintEventArgs> `e`，这是一个参数的<xref:System.Windows.Forms.Control.Paint>事件处理程序。 该代码执行下列操作：  
  
-   创建一个矩形左上角位于 （0，0） 和剪辑区域设置与此矩形。  
  
-   创建其左上角位于第二个矩形 （100，100），并设置为当前剪辑区域 （第一个矩形） 此矩形的交集的剪辑区域。  
  
-   填充一个大的矩形包含用纯色的蓝色画笔前两个矩形。  
  
-   将剪辑区域重置为无限。  
  
-   在两个剪辑区域周围绘制矩形。 它使用黑色笔的第一个剪辑矩形和红色钢笔的第二个剪辑区域。  
  
 结果是只有两个矩形的交集用蓝色填充。  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples3#125](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CPP/form1.cpp#125)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples3#125](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CS/form1.cs#125)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples3#125](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/VB/form1.vb#125)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IntersectClip">
      <MemberSignature Language="C#" Value="public void IntersectClip (System.Drawing.Region region);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void IntersectClip(class System.Drawing.Region region) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.IntersectClip(System.Drawing.Region)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void IntersectClip(System::Drawing::Region ^ region);" />
      <MemberSignature Language="F#" Value="member this.IntersectClip : System.Drawing.Region -&gt; unit" Usage="graphics.IntersectClip region" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="region" Type="System.Drawing.Region" />
      </Parameters>
      <Docs>
        <param name="region">要与当前区域交叉的 <see cref="T:System.Drawing.Region" />。</param>
        <summary>将此 <see cref="T:System.Drawing.Graphics" /> 对象的剪辑区域更新为当前剪辑区域与指定 <see cref="T:System.Drawing.Region" /> 的交集。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法将分配给<xref:System.Drawing.Graphics.Clip%2A>属性的这<xref:System.Drawing.Graphics>所表示为当前剪辑区域和指定的区域的交集的区域`region`参数。  
  
   
  
## Examples  
 下面的代码示例设计为使用 Windows 窗体，并且它需要<xref:System.Windows.Forms.PaintEventArgs> `e`，这是一个参数的<xref:System.Windows.Forms.Control.Paint>事件处理程序。 该代码执行下列操作：  
  
-   创建一个矩形左上角位于 （0，0）。  
  
-   创建区域并将其设置为矩形，并到此区域设置的剪辑区域。  
  
-   创建其左上角位于第二个矩形 （100，100）。  
  
-   创建区域并将其设置为第二个矩形，并的剪辑区域设置使用的合并模式的此区域与当前剪辑区域 （第一个矩形） 交集<xref:System.Drawing.Drawing2D.CombineMode.Replace>。  
  
-   填充包含前两个用纯色的蓝色画笔的大矩形。  
  
-   将剪辑区域重置为无限。  
  
-   在两个剪辑区域周围绘制矩形。 它使用黑色笔的第一个剪辑区域和红色钢笔的第二个剪辑区域。  
  
 结果是仅在两个区域的交集用蓝色填充。  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples3#126](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CPP/form1.cpp#126)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples3#126](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CS/form1.cs#126)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples3#126](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/VB/form1.vb#126)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsClipEmpty">
      <MemberSignature Language="C#" Value="public bool IsClipEmpty { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsClipEmpty" />
      <MemberSignature Language="DocId" Value="P:System.Drawing.Graphics.IsClipEmpty" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsClipEmpty As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsClipEmpty { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsClipEmpty : bool" Usage="System.Drawing.Graphics.IsClipEmpty" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示此 <see cref="T:System.Drawing.Graphics" /> 的剪辑区域是否为空。</summary>
        <value>如果此 <see cref="T:System.Drawing.Graphics" /> 的剪辑区域为空，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="IsVisible">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>指示由一对坐标指定的点是否包含在此 <see cref="T:System.Drawing.Graphics" /> 的可见剪辑区域内。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsVisible">
      <MemberSignature Language="C#" Value="public bool IsVisible (System.Drawing.Point point);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsVisible(valuetype System.Drawing.Point point) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.IsVisible(System.Drawing.Point)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsVisible(System::Drawing::Point point);" />
      <MemberSignature Language="F#" Value="member this.IsVisible : System.Drawing.Point -&gt; bool" Usage="graphics.IsVisible point" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="point" Type="System.Drawing.Point" />
      </Parameters>
      <Docs>
        <param name="point">要测试其可见性的 <see cref="T:System.Drawing.Point" /> 结构。</param>
        <summary>指示指定的 <see cref="T:System.Drawing.Point" /> 结构是否包含在此 <see cref="T:System.Drawing.Graphics" /> 的可见剪辑区域内。</summary>
        <returns>如果 <paramref name="point" /> 参数指定的点包含在此 <see cref="T:System.Drawing.Graphics" /> 的可见剪辑区域内，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下面的代码示例设计为使用 Windows 窗体，并且它需要<xref:System.Windows.Forms.PaintEventArgs> `e`，这是一个参数的<xref:System.Windows.Forms.Control.Paint>事件处理程序。 该代码执行下列操作：  
  
-   创建矩形的剪辑区域，并将其设置为窗体使用的图形对象的剪辑区域<xref:System.Drawing.Drawing2D.CombineMode.Replace>。  
  
-   创建两个点，一个剪辑区域内，一个外部。  
  
-   测试每个可见性的点，并绘制只可见一个。  
  
 结果是一个小红色圆圈，剪辑区域内。  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples3#127](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CPP/form1.cpp#127)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples3#127](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CS/form1.cs#127)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples3#127](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/VB/form1.vb#127)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsVisible">
      <MemberSignature Language="C#" Value="public bool IsVisible (System.Drawing.PointF point);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsVisible(valuetype System.Drawing.PointF point) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.IsVisible(System.Drawing.PointF)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsVisible (point As PointF) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsVisible(System::Drawing::PointF point);" />
      <MemberSignature Language="F#" Value="member this.IsVisible : System.Drawing.PointF -&gt; bool" Usage="graphics.IsVisible point" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="point" Type="System.Drawing.PointF" />
      </Parameters>
      <Docs>
        <param name="point">要测试其可见性的 <see cref="T:System.Drawing.PointF" /> 结构。</param>
        <summary>指示指定的 <see cref="T:System.Drawing.PointF" /> 结构是否包含在此 <see cref="T:System.Drawing.Graphics" /> 的可见剪辑区域内。</summary>
        <returns>如果 <paramref name="point" /> 参数指定的点包含在此 <see cref="T:System.Drawing.Graphics" /> 的可见剪辑区域内，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下面的代码示例设计为使用 Windows 窗体，并且它需要<xref:System.Windows.Forms.PaintEventArgs> `e`，这是一个参数的<xref:System.Windows.Forms.Control.Paint>事件处理程序。 该代码执行下列操作：  
  
-   创建矩形的剪辑区域，并将其设置为窗体使用的图形的剪辑区域<xref:System.Drawing.Drawing2D.CombineMode.Replace>。  
  
-   创建两个点，一个剪辑区域内，一个外部。  
  
-   测试每个可见性的点，并绘制只可见一个。  
  
 结果是一个小红色圆圈，剪辑区域内。  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples3#128](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CPP/form1.cpp#128)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples3#128](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CS/form1.cs#128)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples3#128](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/VB/form1.vb#128)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsVisible">
      <MemberSignature Language="C#" Value="public bool IsVisible (System.Drawing.Rectangle rect);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsVisible(valuetype System.Drawing.Rectangle rect) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.IsVisible(System.Drawing.Rectangle)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsVisible (rect As Rectangle) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsVisible(System::Drawing::Rectangle rect);" />
      <MemberSignature Language="F#" Value="member this.IsVisible : System.Drawing.Rectangle -&gt; bool" Usage="graphics.IsVisible rect" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rect" Type="System.Drawing.Rectangle" />
      </Parameters>
      <Docs>
        <param name="rect">要测试其可见性的 <see cref="T:System.Drawing.Rectangle" /> 结构。</param>
        <summary>指示 <see cref="T:System.Drawing.Rectangle" /> 结构指定的矩形是否包含在此 <see cref="T:System.Drawing.Graphics" /> 的可见剪辑区域内。</summary>
        <returns>如果 <paramref name="rect" /> 参数指定的矩形包含在此 <see cref="T:System.Drawing.Graphics" /> 的可见剪辑区域内，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下面的代码示例设计为使用 Windows 窗体，并且它需要<xref:System.Windows.Forms.PaintEventArgs> `e`，这是一个参数的<xref:System.Windows.Forms.Control.Paint>事件处理程序。 该代码执行下列操作：  
  
-   创建矩形的剪辑区域，并将其设置为窗体使用的图形对象的剪辑区域<xref:System.Drawing.Drawing2D.CombineMode.Replace>。  
  
-   创建位置和大小的两个矩形，一个剪辑区域内，一个外部。  
  
-   测试每个矩形的可见性并绘制只可见一个。  
  
 结果是一个小红色矩形，剪辑区域内。  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples3#129](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CPP/form1.cpp#129)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples3#129](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CS/form1.cs#129)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples3#129](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/VB/form1.vb#129)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsVisible">
      <MemberSignature Language="C#" Value="public bool IsVisible (System.Drawing.RectangleF rect);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsVisible(valuetype System.Drawing.RectangleF rect) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.IsVisible(System.Drawing.RectangleF)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsVisible (rect As RectangleF) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsVisible(System::Drawing::RectangleF rect);" />
      <MemberSignature Language="F#" Value="member this.IsVisible : System.Drawing.RectangleF -&gt; bool" Usage="graphics.IsVisible rect" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rect" Type="System.Drawing.RectangleF" />
      </Parameters>
      <Docs>
        <param name="rect">要测试其可见性的 <see cref="T:System.Drawing.RectangleF" /> 结构。</param>
        <summary>指示 <see cref="T:System.Drawing.RectangleF" /> 结构指定的矩形是否包含在此 <see cref="T:System.Drawing.Graphics" /> 的可见剪辑区域内。</summary>
        <returns>如果 <paramref name="rect" /> 参数指定的矩形包含在此 <see cref="T:System.Drawing.Graphics" /> 的可见剪辑区域内，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下面的代码示例设计为使用 Windows 窗体，并且它需要<xref:System.Windows.Forms.PaintEventArgs> `e`，这是一个参数的<xref:System.Windows.Forms.Control.Paint>事件处理程序。 该代码执行下列操作：  
  
-   创建矩形的剪辑区域，并将其设置为窗体使用的图形对象的剪辑区域<xref:System.Drawing.Drawing2D.CombineMode.Replace>。  
  
-   创建两个矩形，一个剪辑区域内，一个外部。  
  
-   测试每个矩形的可见性并绘制只可见一个。  
  
 结果是一个小红色矩形，剪辑区域内。  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples3#130](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CPP/form1.cpp#130)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples3#130](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CS/form1.cs#130)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples3#130](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/VB/form1.vb#130)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsVisible">
      <MemberSignature Language="C#" Value="public bool IsVisible (int x, int y);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsVisible(int32 x, int32 y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.IsVisible(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsVisible (x As Integer, y As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsVisible(int x, int y);" />
      <MemberSignature Language="F#" Value="member this.IsVisible : int * int -&gt; bool" Usage="graphics.IsVisible (x, y)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Int32" />
        <Parameter Name="y" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="x">要测试其可见性的点的 x 坐标。</param>
        <param name="y">要测试其可见性的点的 y 坐标。</param>
        <summary>指示由一对坐标指定的点是否包含在此 <see cref="T:System.Drawing.Graphics" /> 的可见剪辑区域内。</summary>
        <returns>如果由 <paramref name="x" /> 和 <paramref name="y" /> 参数定义的点包含在此 <see cref="T:System.Drawing.Graphics" /> 的可见剪辑区域内，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下面的代码示例设计为使用 Windows 窗体，并且它需要<xref:System.Windows.Forms.PaintEventArgs> `e`，这是一个参数的<xref:System.Windows.Forms.Control.Paint>事件处理程序。 该代码执行下列操作：  
  
-   创建矩形的剪辑区域，并将其设置为窗体使用的图形对象的剪辑区域<xref:System.Drawing.Drawing2D.CombineMode.Replace>。  
  
-   创建两个点，一个剪辑区域内，一个外部。  
  
-   测试每个可见性的点，并绘制只可见一个。  
  
 结果是一个小红色圆圈，剪辑区域内。  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples3#131](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CPP/form1.cpp#131)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples3#131](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CS/form1.cs#131)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples3#131](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/VB/form1.vb#131)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsVisible">
      <MemberSignature Language="C#" Value="public bool IsVisible (float x, float y);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsVisible(float32 x, float32 y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.IsVisible(System.Single,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsVisible (x As Single, y As Single) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsVisible(float x, float y);" />
      <MemberSignature Language="F#" Value="member this.IsVisible : single * single -&gt; bool" Usage="graphics.IsVisible (x, y)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Single" />
        <Parameter Name="y" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="x">要测试其可见性的点的 x 坐标。</param>
        <param name="y">要测试其可见性的点的 y 坐标。</param>
        <summary>指示由一对坐标指定的点是否包含在此 <see cref="T:System.Drawing.Graphics" /> 的可见剪辑区域内。</summary>
        <returns>如果由 <paramref name="x" /> 和 <paramref name="y" /> 参数定义的点包含在此 <see cref="T:System.Drawing.Graphics" /> 的可见剪辑区域内，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下面的代码示例设计为使用 Windows 窗体，并且它需要<xref:System.Windows.Forms.PaintEventArgs> `e`，这是一个参数的<xref:System.Windows.Forms.Control.Paint>事件处理程序。 该代码执行下列操作：  
  
-   创建矩形的剪辑区域，并将其设置为窗体使用的图形对象的剪辑区域<xref:System.Drawing.Drawing2D.CombineMode.Replace>。  
  
-   创建两个点，一个剪辑区域内，一个外部。  
  
-   测试每个可见性的点，并绘制只可见一个。  
  
 结果是一个小红色圆圈，剪辑区域内。  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples3#133](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CPP/form1.cpp#133)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples3#133](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CS/form1.cs#133)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples3#133](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/VB/form1.vb#133)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsVisible">
      <MemberSignature Language="C#" Value="public bool IsVisible (int x, int y, int width, int height);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsVisible(int32 x, int32 y, int32 width, int32 height) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.IsVisible(System.Int32,System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsVisible (x As Integer, y As Integer, width As Integer, height As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsVisible(int x, int y, int width, int height);" />
      <MemberSignature Language="F#" Value="member this.IsVisible : int * int * int * int -&gt; bool" Usage="graphics.IsVisible (x, y, width, height)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Int32" />
        <Parameter Name="y" Type="System.Int32" />
        <Parameter Name="width" Type="System.Int32" />
        <Parameter Name="height" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="x">要测试其可见性的矩形的左上角的 x 坐标。</param>
        <param name="y">要测试其可见性的矩形的左上角的 y 坐标。</param>
        <param name="width">要测试其可见性的矩形的宽度。</param>
        <param name="height">要测试其可见性的矩形的高度。</param>
        <summary>指示由一对坐标、一个宽度和一个高度指定的矩形是否包含在此 <see cref="T:System.Drawing.Graphics" /> 的可见剪辑区域内。</summary>
        <returns>如果 <paramref name="x" />、<paramref name="y" />、<paramref name="width" /> 和 <paramref name="height" /> 参数定义的矩形包含在此 <see cref="T:System.Drawing.Graphics" /> 的可见剪辑区域内，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下面的代码示例设计为使用 Windows 窗体，并且它需要<xref:System.Windows.Forms.PaintEventArgs> `e`，这是一个参数的<xref:System.Windows.Forms.Control.Paint>事件处理程序。 该代码执行下列操作：  
  
-   创建矩形的剪辑区域，并将其设置为窗体使用的图形对象的剪辑区域<xref:System.Drawing.Drawing2D.CombineMode.Replace>。  
  
-   创建位置和大小的两个矩形，一个剪辑区域内，一个外部。  
  
-   测试每个矩形的可见性并绘制只可见一个。  
  
 结果是一个小红色矩形，剪辑区域内。  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples3#132](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CPP/form1.cpp#132)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples3#132](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CS/form1.cs#132)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples3#132](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/VB/form1.vb#132)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsVisible">
      <MemberSignature Language="C#" Value="public bool IsVisible (float x, float y, float width, float height);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsVisible(float32 x, float32 y, float32 width, float32 height) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.IsVisible(System.Single,System.Single,System.Single,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsVisible (x As Single, y As Single, width As Single, height As Single) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsVisible(float x, float y, float width, float height);" />
      <MemberSignature Language="F#" Value="member this.IsVisible : single * single * single * single -&gt; bool" Usage="graphics.IsVisible (x, y, width, height)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Single" />
        <Parameter Name="y" Type="System.Single" />
        <Parameter Name="width" Type="System.Single" />
        <Parameter Name="height" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="x">要测试其可见性的矩形的左上角的 x 坐标。</param>
        <param name="y">要测试其可见性的矩形的左上角的 y 坐标。</param>
        <param name="width">要测试其可见性的矩形的宽度。</param>
        <param name="height">要测试其可见性的矩形的高度。</param>
        <summary>指示由一对坐标、一个宽度和一个高度指定的矩形是否包含在此 <see cref="T:System.Drawing.Graphics" /> 的可见剪辑区域内。</summary>
        <returns>如果 <paramref name="x" />、<paramref name="y" />、<paramref name="width" /> 和 <paramref name="height" /> 参数定义的矩形包含在此 <see cref="T:System.Drawing.Graphics" /> 的可见剪辑区域内，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下面的代码示例设计为使用 Windows 窗体，并且它需要<xref:System.Windows.Forms.PaintEventArgs> `e`，这是一个参数的<xref:System.Windows.Forms.Control.Paint>事件处理程序。 该代码执行下列操作：  
  
-   创建矩形的剪辑区域，并将其设置为窗体使用的图形对象的剪辑区域<xref:System.Drawing.Drawing2D.CombineMode.Replace>。  
  
-   创建位置和大小的两个矩形，一个剪辑区域内，一个外部。  
  
-   测试每个矩形的可见性并绘制只可见一个。  
  
 结果是一个小红色矩形，剪辑区域内。  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples3#134](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CPP/form1.cpp#134)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples3#134](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CS/form1.cs#134)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples3#134](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/VB/form1.vb#134)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsVisibleClipEmpty">
      <MemberSignature Language="C#" Value="public bool IsVisibleClipEmpty { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsVisibleClipEmpty" />
      <MemberSignature Language="DocId" Value="P:System.Drawing.Graphics.IsVisibleClipEmpty" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsVisibleClipEmpty As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsVisibleClipEmpty { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsVisibleClipEmpty : bool" Usage="System.Drawing.Graphics.IsVisibleClipEmpty" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示此 <see cref="T:System.Drawing.Graphics" /> 的可见剪辑区域是否为空。</summary>
        <value>如果此 <see cref="T:System.Drawing.Graphics" /> 的剪辑区域的可见部分为空，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 可见剪辑区域是这样的剪辑区域的交集`Graphics`和窗口的剪辑区域。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MeasureCharacterRanges">
      <MemberSignature Language="C#" Value="public System.Drawing.Region[] MeasureCharacterRanges (string text, System.Drawing.Font font, System.Drawing.RectangleF layoutRect, System.Drawing.StringFormat stringFormat);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Drawing.Region[] MeasureCharacterRanges(string text, class System.Drawing.Font font, valuetype System.Drawing.RectangleF layoutRect, class System.Drawing.StringFormat stringFormat) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.MeasureCharacterRanges(System.String,System.Drawing.Font,System.Drawing.RectangleF,System.Drawing.StringFormat)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Drawing::Region ^&gt; ^ MeasureCharacterRanges(System::String ^ text, System::Drawing::Font ^ font, System::Drawing::RectangleF layoutRect, System::Drawing::StringFormat ^ stringFormat);" />
      <MemberSignature Language="F#" Value="member this.MeasureCharacterRanges : string * System.Drawing.Font * System.Drawing.RectangleF * System.Drawing.StringFormat -&gt; System.Drawing.Region[]" Usage="graphics.MeasureCharacterRanges (text, font, layoutRect, stringFormat)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Region[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="text" Type="System.String" />
        <Parameter Name="font" Type="System.Drawing.Font" />
        <Parameter Name="layoutRect" Type="System.Drawing.RectangleF" />
        <Parameter Name="stringFormat" Type="System.Drawing.StringFormat" />
      </Parameters>
      <Docs>
        <param name="text">要测量的字符串。</param>
        <param name="font">
          <see cref="T:System.Drawing.Font" />，它定义字符串的文本格式。</param>
        <param name="layoutRect">
          <see cref="T:System.Drawing.RectangleF" /> 结构，它指定字符串的布局矩形。</param>
        <param name="stringFormat">
          <see cref="T:System.Drawing.StringFormat" />，它表示字符串的格式化信息（如行距）。</param>
        <summary>获取 <see cref="T:System.Drawing.Region" /> 对象的数组，其中每个对象将字符位置的范围限定在指定字符串内。</summary>
        <returns>此方法返回 <see cref="T:System.Drawing.Region" /> 对象的数组，其中每个对象将字符位置的范围限定在指定字符串内。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法返回的区域是准确性的依赖于分辨率的因此如果字符串是准确性的一种解决方法在图元文件中记录和更高版本播放在不同的解决方法可能会略有下降。  
  
   
  
## Examples  
 下面的代码示例设计为使用 Windows 窗体，并且它需要<xref:System.Windows.Forms.PaintEventArgs> `e`，这是一个参数的<xref:System.Windows.Forms.Control.Paint>事件处理程序。 该代码执行下列操作：  
  
-   设置一个字符串，"第一个和第二个范围"和字符串 ("Times New Roman"，16 点) 的显示字体。  
  
-   设置两个字符的字符串中的范围 （分别对应的词"First"和"第二个"）。  
  
-   创建要在其中显示字符串的矩形。  
  
-   设置格式的字符串包括两个字符范围。  
  
-   在屏幕上绘制的字符串。  
  
-   度量值的字符范围，将确定绑定两个指定的范围的矩形。  
  
-   将两个矩形绘制到屏幕。  
  
 结果是与第一个范围 ("First") 受一个红色矩形和第二个范围 （"第二个"） 受蓝色矩形显示的字符串。  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples3#135](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CPP/form1.cpp#135)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples3#135](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CS/form1.cs#135)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples3#135](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/VB/form1.vb#135)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Drawing.Graphics.MeasureString(System.String,System.Drawing.Font)" />
        <altmember cref="M:System.Windows.Forms.TextRenderer.MeasureText(System.Drawing.IDeviceContext,System.String,System.Drawing.Font,System.Drawing.Size,System.Windows.Forms.TextFormatFlags)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="MeasureString">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>测量用指定的 <see cref="T:System.Drawing.Font" /> 绘制的指定字符串。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="MeasureString">
      <MemberSignature Language="C#" Value="public System.Drawing.SizeF MeasureString (string text, System.Drawing.Font font);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Drawing.SizeF MeasureString(string text, class System.Drawing.Font font) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.MeasureString(System.String,System.Drawing.Font)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Drawing::SizeF MeasureString(System::String ^ text, System::Drawing::Font ^ font);" />
      <MemberSignature Language="F#" Value="member this.MeasureString : string * System.Drawing.Font -&gt; System.Drawing.SizeF" Usage="graphics.MeasureString (text, font)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.SizeF</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="text" Type="System.String" />
        <Parameter Name="font" Type="System.Drawing.Font" />
      </Parameters>
      <Docs>
        <param name="text">要测量的字符串。</param>
        <param name="font">
          <see cref="T:System.Drawing.Font" />，它定义字符串的文本格式。</param>
        <summary>测量用指定的 <see cref="T:System.Drawing.Font" /> 绘制的指定字符串。</summary>
        <returns>此方法返回 <see cref="T:System.Drawing.SizeF" /> 结构，该结构表示 <paramref name="text" /> 参数指定的、使用 <paramref name="font" /> 参数绘制的字符串的大小，单位由 <see cref="P:System.Drawing.Graphics.PageUnit" /> 属性指定。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Drawing.Graphics.MeasureString%2A>方法旨在用于使用包含单个字符串，并包括少量的额外空间之前和之后要允许突出的标志符号的字符串。 此外，<xref:System.Drawing.Graphics.DrawString%2A>方法调整标志符号点以优化显示质量，并可能会显示一个字符串，窄于报告的<xref:System.Drawing.Graphics.MeasureString%2A>。 若要获取适用于布局 （例如，实现格式化文本时） 中的相邻字符串的指标，请使用<xref:System.Drawing.Graphics.MeasureCharacterRanges%2A>方法或之一<xref:System.Drawing.Graphics.MeasureString%2A>方法采用<xref:System.Drawing.StringFormat>，并将传递<xref:System.Drawing.StringFormat.GenericTypographic%2A>。 另外，请确保<xref:System.Drawing.Graphics.TextRenderingHint%2A>有关<xref:System.Drawing.Graphics>是<xref:System.Drawing.Text.TextRenderingHint.AntiAlias>。  
  
   
  
## Examples  
 下面的代码示例设计为使用 Windows 窗体，并且它需要<xref:System.Windows.Forms.PaintEventArgs> `e`，这是一个参数的<xref:System.Windows.Forms.Control.Paint>事件处理程序。 该代码执行下列操作：  
  
-   创建要测量的字符串。  
  
-   创建一个 font 对象并将其设置为 Arial （16 磅）。  
  
-   创建大小对象并使用它和字体对象来度量的字符串的大小。  
  
-   使用绘制一个红色矩形所测得的字符串的大小。  
  
-   绘制绘制的矩形内的字符串。  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples3#136](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CPP/form1.cpp#136)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples3#136](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CS/form1.cs#136)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples3#136](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/VB/form1.vb#136)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="font" /> 为 <see langword="null" />。</exception>
        <altmember cref="M:System.Windows.Forms.TextRenderer.MeasureText(System.Drawing.IDeviceContext,System.String,System.Drawing.Font,System.Drawing.Size,System.Windows.Forms.TextFormatFlags)" />
        <altmember cref="M:System.Drawing.Graphics.MeasureCharacterRanges(System.String,System.Drawing.Font,System.Drawing.RectangleF,System.Drawing.StringFormat)" />
        <related type="Article" href="~/docs/framework/winforms/advanced/using-fonts-and-text.md">使用字体和文本</related>
      </Docs>
    </Member>
    <Member MemberName="MeasureString">
      <MemberSignature Language="C#" Value="public System.Drawing.SizeF MeasureString (string text, System.Drawing.Font font, System.Drawing.SizeF layoutArea);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Drawing.SizeF MeasureString(string text, class System.Drawing.Font font, valuetype System.Drawing.SizeF layoutArea) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.MeasureString(System.String,System.Drawing.Font,System.Drawing.SizeF)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Drawing::SizeF MeasureString(System::String ^ text, System::Drawing::Font ^ font, System::Drawing::SizeF layoutArea);" />
      <MemberSignature Language="F#" Value="member this.MeasureString : string * System.Drawing.Font * System.Drawing.SizeF -&gt; System.Drawing.SizeF" Usage="graphics.MeasureString (text, font, layoutArea)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.SizeF</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="text" Type="System.String" />
        <Parameter Name="font" Type="System.Drawing.Font" />
        <Parameter Name="layoutArea" Type="System.Drawing.SizeF" />
      </Parameters>
      <Docs>
        <param name="text">要测量的字符串。</param>
        <param name="font">
          <see cref="T:System.Drawing.Font" /> 定义字符串的文本格式。</param>
        <param name="layoutArea">
          <see cref="T:System.Drawing.SizeF" /> 结构，它指定文本的最大布局区域。</param>
        <summary>当在指定的布局区域内以指定的 <see cref="T:System.Drawing.Font" /> 绘制时，测量指定的字符串。</summary>
        <returns>此方法返回 <see cref="T:System.Drawing.SizeF" /> 结构，该结构表示 <paramref name="text" /> 参数指定的、使用 <paramref name="font" /> 参数绘制的字符串的大小，单位由 <see cref="P:System.Drawing.Graphics.PageUnit" /> 属性指定。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Drawing.Graphics.MeasureString%2A>方法旨在用于使用包含单个字符串，并包括少量的额外空间之前和之后要允许突出的标志符号的字符串。 此外，<xref:System.Drawing.Graphics.DrawString%2A>方法调整标志符号点以优化显示质量，并可能会显示一个字符串，窄于报告的<xref:System.Drawing.Graphics.MeasureString%2A>。 若要获取适用于布局 （例如，实现格式化文本时） 中的相邻字符串的指标，请使用<xref:System.Drawing.Graphics.MeasureCharacterRanges%2A>方法或之一<xref:System.Drawing.Graphics.MeasureString%2A>方法采用<xref:System.Drawing.StringFormat>，并将传递<xref:System.Drawing.StringFormat.GenericTypographic%2A>。 另外，请确保<xref:System.Drawing.Graphics.TextRenderingHint%2A>有关<xref:System.Drawing.Graphics>是<xref:System.Drawing.Text.TextRenderingHint.AntiAlias>。  
  
   
  
## Examples  
 下面的代码示例设计为使用 Windows 窗体，并且它需要<xref:System.Windows.Forms.PaintEventArgs> `e`，这是一个参数的<xref:System.Windows.Forms.Control.Paint>事件处理程序。 该代码执行下列操作：  
  
-   创建要测量的字符串和字体对象设置为 Arial （16 点）。  
  
-   设置字符串的最大布局大小。  
  
-   创建一个大小对象并使用它、 字体对象和最大布局大小度量值的字符串的大小。  
  
-   使用绘制一个红色矩形所测得的字符串的大小。  
  
-   绘制绘制的矩形内的字符串。  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples3#138](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CPP/form1.cpp#138)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples3#138](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CS/form1.cs#138)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples3#138](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/VB/form1.vb#138)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="font" /> 为 <see langword="null" />。</exception>
        <altmember cref="M:System.Windows.Forms.TextRenderer.MeasureText(System.Drawing.IDeviceContext,System.String,System.Drawing.Font,System.Drawing.Size,System.Windows.Forms.TextFormatFlags)" />
        <altmember cref="M:System.Drawing.Graphics.MeasureCharacterRanges(System.String,System.Drawing.Font,System.Drawing.RectangleF,System.Drawing.StringFormat)" />
        <related type="Article" href="~/docs/framework/winforms/advanced/using-fonts-and-text.md">使用字体和文本</related>
      </Docs>
    </Member>
    <Member MemberName="MeasureString">
      <MemberSignature Language="C#" Value="public System.Drawing.SizeF MeasureString (string text, System.Drawing.Font font, int width);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Drawing.SizeF MeasureString(string text, class System.Drawing.Font font, int32 width) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.MeasureString(System.String,System.Drawing.Font,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Drawing::SizeF MeasureString(System::String ^ text, System::Drawing::Font ^ font, int width);" />
      <MemberSignature Language="F#" Value="member this.MeasureString : string * System.Drawing.Font * int -&gt; System.Drawing.SizeF" Usage="graphics.MeasureString (text, font, width)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.SizeF</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="text" Type="System.String" />
        <Parameter Name="font" Type="System.Drawing.Font" />
        <Parameter Name="width" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="text">要测量的字符串。</param>
        <param name="font">
          <see cref="T:System.Drawing.Font" />，它定义字符串的格式。</param>
        <param name="width">字符串的最大宽度（以像素为单位）。</param>
        <summary>测量用指定的 <see cref="T:System.Drawing.Font" /> 绘制的指定字符串。</summary>
        <returns>此方法返回 <see cref="T:System.Drawing.SizeF" /> 结构，该结构表示在 <paramref name="text" /> 参数中指定的、使用 <paramref name="font" /> 参数绘制的字符串的大小，单位由 <see cref="P:System.Drawing.Graphics.PageUnit" /> 属性指定。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `width`参数指定返回的宽度分量的最大值<xref:System.Drawing.SizeF>结构 (<xref:System.Drawing.SizeF.Width%2A>)。 如果`width`参数是字符串，将返回的实际宽度小于<xref:System.Drawing.SizeF.Width%2A>组件将被截断为一个值，表示的最大适合指定的宽度的字符数。 可容纳整个字符串，返回的<xref:System.Drawing.SizeF.Height%2A>组件将会调整为允许显示使用字符换行字符串的值。  
  
 <xref:System.Drawing.Graphics.MeasureString%2A>方法旨在用于使用包含单个字符串，并包括少量的额外空间之前和之后要允许突出的标志符号的字符串。 此外，<xref:System.Drawing.Graphics.DrawString%2A>方法调整标志符号点以优化显示质量，并可能会显示一个字符串，窄于报告的<xref:System.Drawing.Graphics.MeasureString%2A>。 若要获取适用于布局 （例如，实现格式化文本时） 中的相邻字符串的指标，请使用<xref:System.Drawing.Graphics.MeasureCharacterRanges%2A>方法或之一<xref:System.Drawing.Graphics.MeasureString%2A>方法采用<xref:System.Drawing.StringFormat>，并将传递<xref:System.Drawing.StringFormat.GenericTypographic%2A>。 另外，请确保<xref:System.Drawing.Graphics.TextRenderingHint%2A>有关<xref:System.Drawing.Graphics>是<xref:System.Drawing.Text.TextRenderingHint.AntiAlias>。  
  
   
  
## Examples  
 下面的代码示例设计为使用 Windows 窗体，并且它需要<xref:System.Windows.Forms.PaintEventArgs> `e`，这是一个参数的<xref:System.Windows.Forms.Control.Paint>事件处理程序。 该代码执行下列操作：  
  
-   创建要测量的字符串和字体对象设置为 Arial （16 点）。  
  
-   设置字符串的最大宽度。  
  
-   创建一个大小对象并使用它、 字体对象和字符串最大宽度来测量的字符串的大小。  
  
-   使用绘制一个红色矩形所测得的字符串的大小。  
  
-   绘制绘制的矩形内的字符串。  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples3#141](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CPP/form1.cpp#141)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples3#141](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CS/form1.cs#141)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples3#141](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/VB/form1.vb#141)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="font" /> 为 <see langword="null" />。</exception>
        <altmember cref="M:System.Windows.Forms.TextRenderer.MeasureText(System.Drawing.IDeviceContext,System.String,System.Drawing.Font,System.Drawing.Size,System.Windows.Forms.TextFormatFlags)" />
        <altmember cref="M:System.Drawing.Graphics.MeasureCharacterRanges(System.String,System.Drawing.Font,System.Drawing.RectangleF,System.Drawing.StringFormat)" />
        <related type="Article" href="~/docs/framework/winforms/advanced/using-fonts-and-text.md">使用字体和文本</related>
      </Docs>
    </Member>
    <Member MemberName="MeasureString">
      <MemberSignature Language="C#" Value="public System.Drawing.SizeF MeasureString (string text, System.Drawing.Font font, System.Drawing.PointF origin, System.Drawing.StringFormat stringFormat);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Drawing.SizeF MeasureString(string text, class System.Drawing.Font font, valuetype System.Drawing.PointF origin, class System.Drawing.StringFormat stringFormat) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.MeasureString(System.String,System.Drawing.Font,System.Drawing.PointF,System.Drawing.StringFormat)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Drawing::SizeF MeasureString(System::String ^ text, System::Drawing::Font ^ font, System::Drawing::PointF origin, System::Drawing::StringFormat ^ stringFormat);" />
      <MemberSignature Language="F#" Value="member this.MeasureString : string * System.Drawing.Font * System.Drawing.PointF * System.Drawing.StringFormat -&gt; System.Drawing.SizeF" Usage="graphics.MeasureString (text, font, origin, stringFormat)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.SizeF</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="text" Type="System.String" />
        <Parameter Name="font" Type="System.Drawing.Font" />
        <Parameter Name="origin" Type="System.Drawing.PointF" />
        <Parameter Name="stringFormat" Type="System.Drawing.StringFormat" />
      </Parameters>
      <Docs>
        <param name="text">要测量的字符串。</param>
        <param name="font">
          <see cref="T:System.Drawing.Font" /> 定义字符串的文本格式。</param>
        <param name="origin">
          <see cref="T:System.Drawing.PointF" /> 结构，它表示字符串的左上角。</param>
        <param name="stringFormat">
          <see cref="T:System.Drawing.StringFormat" />，它表示字符串的格式化信息（如行距）。</param>
        <summary>测量用指定的 <see cref="T:System.Drawing.Font" /> 绘制并用指定的 <see cref="T:System.Drawing.StringFormat" /> 格式化的指定字符串。</summary>
        <returns>此方法返回 <see cref="T:System.Drawing.SizeF" /> 结构，该结构表示 <paramref name="text" /> 参数指定的、使用 <paramref name="font" /> 参数和 <paramref name="stringFormat" /> 参数绘制的字符串的大小，单位由 <see cref="P:System.Drawing.Graphics.PageUnit" /> 属性指定。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Drawing.Graphics.MeasureString%2A>方法旨在用于使用包含单个字符串，并包括少量的额外空间之前和之后要允许突出的标志符号的字符串。 此外，<xref:System.Drawing.Graphics.DrawString%2A>方法调整标志符号点以优化显示质量，并可能会显示一个字符串，窄于报告的<xref:System.Drawing.Graphics.MeasureString%2A>。 若要获取适用于布局 （例如，实现格式化文本时） 中的相邻字符串的指标，请使用<xref:System.Drawing.Graphics.MeasureCharacterRanges%2A>方法或之一<xref:System.Drawing.Graphics.MeasureString%2A>方法采用<xref:System.Drawing.StringFormat>，并将传递<xref:System.Drawing.StringFormat.GenericTypographic%2A>。 另外，请确保<xref:System.Drawing.Graphics.TextRenderingHint%2A>有关<xref:System.Drawing.Graphics>是<xref:System.Drawing.Text.TextRenderingHint.AntiAlias>。  
  
   
  
## Examples  
 下面的代码示例设计为使用 Windows 窗体，并且它需要<xref:System.Windows.Forms.PaintEventArgs> `e`，这是一个参数的<xref:System.Windows.Forms.Control.Paint>事件处理程序。 该代码执行下列操作：  
  
-   创建要测量的字符串和字体对象设置为 Arial （16 点）  
  
-   创建一个点来查找字符串的左上角。  
  
-   创建的字符串格式对象并将它的格式标志设置为<xref:System.Drawing.StringFormatFlags.DirectionVertical>。  
  
-   创建一个大小对象来测量字符串。  
  
-   度量值使用字符串、 字体对象、 定位点和字符串格式的字符串的大小。  
  
-   绘制红色矩形使用定位点和所测得的字符串的大小。  
  
-   绘制绘制的矩形内的字符串。  
  
 结果是一个垂直矩形围垂直的字符串。  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples3#137](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CPP/form1.cpp#137)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples3#137](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CS/form1.cs#137)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples3#137](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/VB/form1.vb#137)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="font" /> 为 <see langword="null" />。</exception>
        <altmember cref="M:System.Windows.Forms.TextRenderer.MeasureText(System.Drawing.IDeviceContext,System.String,System.Drawing.Font,System.Drawing.Size,System.Windows.Forms.TextFormatFlags)" />
        <altmember cref="M:System.Drawing.Graphics.MeasureCharacterRanges(System.String,System.Drawing.Font,System.Drawing.RectangleF,System.Drawing.StringFormat)" />
        <related type="Article" href="~/docs/framework/winforms/advanced/using-fonts-and-text.md">使用字体和文本</related>
      </Docs>
    </Member>
    <Member MemberName="MeasureString">
      <MemberSignature Language="C#" Value="public System.Drawing.SizeF MeasureString (string text, System.Drawing.Font font, System.Drawing.SizeF layoutArea, System.Drawing.StringFormat stringFormat);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Drawing.SizeF MeasureString(string text, class System.Drawing.Font font, valuetype System.Drawing.SizeF layoutArea, class System.Drawing.StringFormat stringFormat) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.MeasureString(System.String,System.Drawing.Font,System.Drawing.SizeF,System.Drawing.StringFormat)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Drawing::SizeF MeasureString(System::String ^ text, System::Drawing::Font ^ font, System::Drawing::SizeF layoutArea, System::Drawing::StringFormat ^ stringFormat);" />
      <MemberSignature Language="F#" Value="member this.MeasureString : string * System.Drawing.Font * System.Drawing.SizeF * System.Drawing.StringFormat -&gt; System.Drawing.SizeF" Usage="graphics.MeasureString (text, font, layoutArea, stringFormat)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.SizeF</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="text" Type="System.String" />
        <Parameter Name="font" Type="System.Drawing.Font" />
        <Parameter Name="layoutArea" Type="System.Drawing.SizeF" />
        <Parameter Name="stringFormat" Type="System.Drawing.StringFormat" />
      </Parameters>
      <Docs>
        <param name="text">要测量的字符串。</param>
        <param name="font">
          <see cref="T:System.Drawing.Font" /> 定义字符串的文本格式。</param>
        <param name="layoutArea">
          <see cref="T:System.Drawing.SizeF" /> 结构，它指定文本的最大布局区域。</param>
        <param name="stringFormat">
          <see cref="T:System.Drawing.StringFormat" />，它表示字符串的格式化信息（如行距）。</param>
        <summary>测量用指定的 <see cref="T:System.Drawing.Font" /> 绘制并用指定的 <see cref="T:System.Drawing.StringFormat" /> 格式化的指定字符串。</summary>
        <returns>此方法返回 <see cref="T:System.Drawing.SizeF" /> 结构，该结构表示在 <paramref name="text" /> 参数中指定的、用 <paramref name="font" /> 参数和 <paramref name="stringFormat" /> 参数绘制的字符串的大小，单位由 <see cref="P:System.Drawing.Graphics.PageUnit" /> 属性指定。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Drawing.Graphics.MeasureString%2A>方法旨在用于使用包含单个字符串，并包括少量的额外空间之前和之后要允许突出的标志符号的字符串。 此外，<xref:System.Drawing.Graphics.DrawString%2A>方法调整标志符号点以优化显示质量，并可能会显示一个字符串，窄于报告的<xref:System.Drawing.Graphics.MeasureString%2A>。 若要获取适用于布局 （例如，实现格式化文本时） 中的相邻字符串的指标，请使用<xref:System.Drawing.Graphics.MeasureCharacterRanges%2A>方法或之一<xref:System.Drawing.Graphics.MeasureString%2A>方法采用<xref:System.Drawing.StringFormat>，并将传递<xref:System.Drawing.StringFormat.GenericTypographic%2A>。 另外，请确保<xref:System.Drawing.Graphics.TextRenderingHint%2A>有关<xref:System.Drawing.Graphics>是<xref:System.Drawing.Text.TextRenderingHint.AntiAlias>。  
  
   
  
## Examples  
 下面的代码示例设计为使用 Windows 窗体，并且它需要<xref:System.Windows.Forms.PaintEventArgs> `e`，这是一个参数的<xref:System.Windows.Forms.Control.Paint>事件处理程序。 该代码执行下列操作：  
  
-   创建要测量的字符串和字体对象设置为 Arial （16 点）。  
  
-   设置创建用来测量字符串大小对象的字符串的最大布局大小。  
  
-   创建的字符串格式对象并将它的格式标志设置为<xref:System.Drawing.StringFormatFlags.DirectionVertical>。  
  
-   度量值使用字符串、 字体对象、 最大布局大小和字符串格式的字符串的大小。  
  
-   使用绘制一个红色矩形所测得的字符串的大小。  
  
-   绘制绘制的矩形内的字符串。  
  
 结果是一个垂直矩形围垂直的字符串。  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples3#139](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CPP/form1.cpp#139)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples3#139](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CS/form1.cs#139)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples3#139](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/VB/form1.vb#139)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="font" /> 为 <see langword="null" />。</exception>
        <altmember cref="M:System.Windows.Forms.TextRenderer.MeasureText(System.Drawing.IDeviceContext,System.String,System.Drawing.Font,System.Drawing.Size,System.Windows.Forms.TextFormatFlags)" />
        <altmember cref="M:System.Drawing.Graphics.MeasureCharacterRanges(System.String,System.Drawing.Font,System.Drawing.RectangleF,System.Drawing.StringFormat)" />
        <related type="Article" href="~/docs/framework/winforms/advanced/using-fonts-and-text.md">使用字体和文本</related>
      </Docs>
    </Member>
    <Member MemberName="MeasureString">
      <MemberSignature Language="C#" Value="public System.Drawing.SizeF MeasureString (string text, System.Drawing.Font font, int width, System.Drawing.StringFormat format);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Drawing.SizeF MeasureString(string text, class System.Drawing.Font font, int32 width, class System.Drawing.StringFormat format) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.MeasureString(System.String,System.Drawing.Font,System.Int32,System.Drawing.StringFormat)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Drawing::SizeF MeasureString(System::String ^ text, System::Drawing::Font ^ font, int width, System::Drawing::StringFormat ^ format);" />
      <MemberSignature Language="F#" Value="member this.MeasureString : string * System.Drawing.Font * int * System.Drawing.StringFormat -&gt; System.Drawing.SizeF" Usage="graphics.MeasureString (text, font, width, format)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.SizeF</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="text" Type="System.String" />
        <Parameter Name="font" Type="System.Drawing.Font" />
        <Parameter Name="width" Type="System.Int32" />
        <Parameter Name="format" Type="System.Drawing.StringFormat" />
      </Parameters>
      <Docs>
        <param name="text">要测量的字符串。</param>
        <param name="font">
          <see cref="T:System.Drawing.Font" />，它定义字符串的文本格式。</param>
        <param name="width">字符串的最大宽度。</param>
        <param name="format">
          <see cref="T:System.Drawing.StringFormat" />，它表示字符串的格式化信息（如行距）。</param>
        <summary>测量用指定的 <see cref="T:System.Drawing.Font" /> 绘制并用指定的 <see cref="T:System.Drawing.StringFormat" /> 格式化的指定字符串。</summary>
        <returns>此方法返回 <see cref="T:System.Drawing.SizeF" /> 结构，该结构表示在 <paramref name="text" /> 参数中指定的、用 <paramref name="font" /> 参数和 <paramref name="stringFormat" /> 参数绘制的字符串的大小，单位由 <see cref="P:System.Drawing.Graphics.PageUnit" /> 属性指定。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Drawing.Graphics.MeasureString%2A>方法旨在用于使用包含单个字符串，并包括少量的额外空间之前和之后要允许突出的标志符号的字符串。 此外，<xref:System.Drawing.Graphics.DrawString%2A>方法调整标志符号点以优化显示质量，并可能会显示一个字符串，窄于报告的<xref:System.Drawing.Graphics.MeasureString%2A>。 若要获取适用于布局 （例如，实现格式化文本时） 中的相邻字符串的指标，请使用<xref:System.Drawing.Graphics.MeasureCharacterRanges%2A>方法或之一<xref:System.Drawing.Graphics.MeasureString%2A>方法采用<xref:System.Drawing.StringFormat>，并将传递<xref:System.Drawing.StringFormat.GenericTypographic%2A>。 另外，请确保<xref:System.Drawing.Graphics.TextRenderingHint%2A>有关<xref:System.Drawing.Graphics>是<xref:System.Drawing.Text.TextRenderingHint.AntiAlias>。  
  
   
  
## Examples  
 下面的代码示例设计为使用 Windows 窗体，并且它需要<xref:System.Windows.Forms.PaintEventArgs> `e`，这是一个参数的<xref:System.Windows.Forms.Control.Paint>事件处理程序。 该代码执行下列操作：  
  
-   创建度量值和一种字体的字符串对象将其设置为 Arial （16 点）。  
  
-   设置字符串的最大宽度。  
  
-   创建的字符串格式对象并将它的格式标志设置为<xref:System.Drawing.StringFormatFlags.DirectionVertical>。  
  
-   创建一个大小对象来测量字符串。  
  
-   度量值使用字符串、 字体对象、 最大宽度和字符串格式的字符串的大小。  
  
-   使用绘制一个红色矩形所测得的字符串的大小。  
  
-   绘制绘制的矩形内的字符串。  
  
 结果是一个垂直矩形围垂直的字符串。  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples3#142](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CPP/form1.cpp#142)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples3#142](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CS/form1.cs#142)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples3#142](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/VB/form1.vb#142)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="font" /> 为 <see langword="null" />。</exception>
        <altmember cref="M:System.Windows.Forms.TextRenderer.MeasureText(System.Drawing.IDeviceContext,System.String,System.Drawing.Font,System.Drawing.Size,System.Windows.Forms.TextFormatFlags)" />
        <altmember cref="M:System.Drawing.Graphics.MeasureCharacterRanges(System.String,System.Drawing.Font,System.Drawing.RectangleF,System.Drawing.StringFormat)" />
        <related type="Article" href="~/docs/framework/winforms/advanced/using-fonts-and-text.md">使用字体和文本</related>
      </Docs>
    </Member>
    <Member MemberName="MeasureString">
      <MemberSignature Language="C#" Value="public System.Drawing.SizeF MeasureString (string text, System.Drawing.Font font, System.Drawing.SizeF layoutArea, System.Drawing.StringFormat stringFormat, out int charactersFitted, out int linesFilled);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Drawing.SizeF MeasureString(string text, class System.Drawing.Font font, valuetype System.Drawing.SizeF layoutArea, class System.Drawing.StringFormat stringFormat, [out] int32&amp; charactersFitted, [out] int32&amp; linesFilled) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.MeasureString(System.String,System.Drawing.Font,System.Drawing.SizeF,System.Drawing.StringFormat,System.Int32@,System.Int32@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Drawing::SizeF MeasureString(System::String ^ text, System::Drawing::Font ^ font, System::Drawing::SizeF layoutArea, System::Drawing::StringFormat ^ stringFormat, [Runtime::InteropServices::Out] int % charactersFitted, [Runtime::InteropServices::Out] int % linesFilled);" />
      <MemberSignature Language="F#" Value="member this.MeasureString : string * System.Drawing.Font * System.Drawing.SizeF * System.Drawing.StringFormat *  *  -&gt; System.Drawing.SizeF" Usage="graphics.MeasureString (text, font, layoutArea, stringFormat, charactersFitted, linesFilled)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.SizeF</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="text" Type="System.String" />
        <Parameter Name="font" Type="System.Drawing.Font" />
        <Parameter Name="layoutArea" Type="System.Drawing.SizeF" />
        <Parameter Name="stringFormat" Type="System.Drawing.StringFormat" />
        <Parameter Name="charactersFitted" Type="System.Int32" RefType="out" />
        <Parameter Name="linesFilled" Type="System.Int32" RefType="out" />
      </Parameters>
      <Docs>
        <param name="text">要测量的字符串。</param>
        <param name="font">
          <see cref="T:System.Drawing.Font" />，它定义字符串的文本格式。</param>
        <param name="layoutArea">
          <see cref="T:System.Drawing.SizeF" /> 结构，它指定文本的最大布局区域。</param>
        <param name="stringFormat">
          <see cref="T:System.Drawing.StringFormat" />，它表示字符串的格式化信息（如行距）。</param>
        <param name="charactersFitted">字符串中的字符数。</param>
        <param name="linesFilled">字符串中的文本行数。</param>
        <summary>测量用指定的 <see cref="T:System.Drawing.Font" /> 绘制并用指定的 <see cref="T:System.Drawing.StringFormat" /> 格式化的指定字符串。</summary>
        <returns>此方法返回 <see cref="T:System.Drawing.SizeF" /> 结构，该结构表示 <paramref name="text" /> 参数指定的、使用 <paramref name="font" /> 参数和 <paramref name="stringFormat" /> 参数绘制的字符串的大小，单位由 <see cref="P:System.Drawing.Graphics.PageUnit" /> 属性指定。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Drawing.Graphics.MeasureString%2A>方法旨在用于使用包含单个字符串，并包括少量的额外空间之前和之后要允许突出的标志符号的字符串。 此外，<xref:System.Drawing.Graphics.DrawString%2A>方法调整标志符号点以优化显示质量，并可能会显示一个字符串，窄于报告的<xref:System.Drawing.Graphics.MeasureString%2A>。 若要获取适用于布局 （例如，实现格式化文本时） 中的相邻字符串的指标，请使用<xref:System.Drawing.Graphics.MeasureCharacterRanges%2A>方法或之一<xref:System.Drawing.Graphics.MeasureString%2A>方法采用<xref:System.Drawing.StringFormat>，并将传递<xref:System.Drawing.StringFormat.GenericTypographic%2A>。 此外请确保<xref:System.Drawing.Graphics.TextRenderingHint%2A>有关<xref:System.Drawing.Graphics>是<xref:System.Drawing.Text.TextRenderingHint.AntiAlias>。  
  
   
  
## Examples  
 下面的代码示例设计为使用 Windows 窗体，并且它需要<xref:System.Windows.Forms.PaintEventArgs> `e`，这是一个参数的<xref:System.Windows.Forms.Control.Paint>事件处理程序。 该代码执行下列操作：  
  
-   创建要测量的字符串和字体对象设置为 Arial （16 点）  
  
-   设置字符串的最大布局大小。  
  
-   创建的字符串格式对象并将它的格式标志设置为<xref:System.Drawing.StringFormatFlags.DirectionVertical>。  
  
-   创建整数变量`charactersFitted`和`linesFilled`和一个用于度量值的字符串的大小对象。  
  
-   测量的字符串的大小，并确定的字符拟合和使用字符串、 字体对象、 最大布局大小和字符串格式的填充的行数。  
  
-   使用绘制一个红色矩形所测得的字符串的大小。  
  
-   绘制绘制的矩形内的字符串。  
  
-   绘制拟合字符和填充的行数的值。  
  
 结果是一个垂直矩形围垂直的字符串。  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples3#140](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CPP/form1.cpp#140)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples3#140](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CS/form1.cs#140)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples3#140](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/VB/form1.vb#140)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="font" /> 为 <see langword="null" />。</exception>
        <altmember cref="M:System.Windows.Forms.TextRenderer.MeasureText(System.Drawing.IDeviceContext,System.String,System.Drawing.Font,System.Drawing.Size,System.Windows.Forms.TextFormatFlags)" />
        <altmember cref="M:System.Drawing.Graphics.MeasureCharacterRanges(System.String,System.Drawing.Font,System.Drawing.RectangleF,System.Drawing.StringFormat)" />
        <related type="Article" href="~/docs/framework/winforms/advanced/using-fonts-and-text.md">使用字体和文本</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="MultiplyTransform">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>将此 <see cref="T:System.Drawing.Graphics" /> 的世界转换乘以指定的 <see cref="T:System.Drawing.Drawing2D.Matrix" />。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="MultiplyTransform">
      <MemberSignature Language="C#" Value="public void MultiplyTransform (System.Drawing.Drawing2D.Matrix matrix);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void MultiplyTransform(class System.Drawing.Drawing2D.Matrix matrix) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.MultiplyTransform(System.Drawing.Drawing2D.Matrix)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void MultiplyTransform(System::Drawing::Drawing2D::Matrix ^ matrix);" />
      <MemberSignature Language="F#" Value="member this.MultiplyTransform : System.Drawing.Drawing2D.Matrix -&gt; unit" Usage="graphics.MultiplyTransform matrix" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="matrix" Type="System.Drawing.Drawing2D.Matrix" />
      </Parameters>
      <Docs>
        <param name="matrix">乘以世界转换的 4x4 <see cref="T:System.Drawing.Drawing2D.Matrix" />。</param>
        <summary>将此 <see cref="T:System.Drawing.Graphics" /> 的世界转换乘以指定的 <see cref="T:System.Drawing.Drawing2D.Matrix" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法预先计算指定的矩阵`matrix`参数，以使结果`matrix`x 世界转换。  
  
   
  
## Examples  
 下面的代码示例设计为使用 Windows 窗体，并且它需要<xref:System.Windows.Forms.PaintEventArgs> `e`，这是一个参数的<xref:System.Windows.Forms.Control.Paint>事件处理程序。 该代码执行下列操作：  
  
-   创建`transformMatrix`矩阵 （由两个单位矩阵加上零转换向量）。  
  
-   平移矢量 （200，100） 的转换矩阵。  
  
-   Windows 窗体的世界转换矩阵旋转 30 度，前面添加到窗体的变换矩阵的 30 度的旋转矩阵。  
  
-   旋转的世界转换矩阵乘以已翻译`transformMatrix`，并将前面添加`transformMatrix`到世界转换矩阵。  
  
-   绘制旋转、 平移的椭圆。  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples3#143](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CPP/form1.cpp#143)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples3#143](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CS/form1.cs#143)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples3#143](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/VB/form1.vb#143)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/0659fe00-9e0c-41c4-9118-016f2404c905">转换的矩阵表示形式</related>
      </Docs>
    </Member>
    <Member MemberName="MultiplyTransform">
      <MemberSignature Language="C#" Value="public void MultiplyTransform (System.Drawing.Drawing2D.Matrix matrix, System.Drawing.Drawing2D.MatrixOrder order);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void MultiplyTransform(class System.Drawing.Drawing2D.Matrix matrix, valuetype System.Drawing.Drawing2D.MatrixOrder order) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.MultiplyTransform(System.Drawing.Drawing2D.Matrix,System.Drawing.Drawing2D.MatrixOrder)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void MultiplyTransform(System::Drawing::Drawing2D::Matrix ^ matrix, System::Drawing::Drawing2D::MatrixOrder order);" />
      <MemberSignature Language="F#" Value="member this.MultiplyTransform : System.Drawing.Drawing2D.Matrix * System.Drawing.Drawing2D.MatrixOrder -&gt; unit" Usage="graphics.MultiplyTransform (matrix, order)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="matrix" Type="System.Drawing.Drawing2D.Matrix" />
        <Parameter Name="order" Type="System.Drawing.Drawing2D.MatrixOrder" />
      </Parameters>
      <Docs>
        <param name="matrix">乘以世界转换的 4x4 <see cref="T:System.Drawing.Drawing2D.Matrix" />。</param>
        <param name="order">
          <see cref="T:System.Drawing.Drawing2D.MatrixOrder" /> 枚举的成员，它确定乘法的顺序。</param>
        <summary>以指定顺序将此 <see cref="T:System.Drawing.Graphics" /> 的世界转换乘以指定的 <see cref="T:System.Drawing.Drawing2D.Matrix" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 值为<xref:System.Drawing.Drawing2D.MatrixOrder.Prepend>有关`order`参数指定乘法的顺序是`matrix`x 世界转换。 值为<xref:System.Drawing.Drawing2D.MatrixOrder.Append>有关`order`指定乘法的顺序是世界转换 x `matrix`。  
  
   
  
## Examples  
 下面的代码示例设计为使用 Windows 窗体，并且它需要<xref:System.Windows.Forms.PaintEventArgs> `e`，这是一个参数的<xref:System.Windows.Forms.Control.Paint>事件处理程序。 该代码执行下列操作：  
  
-   创建`transformMatrix`矩阵 （由两个单位矩阵加上零转换向量）。  
  
-   平移矢量 （200，100） 的转换矩阵。  
  
-   Windows 窗体的世界转换矩阵旋转 30 度，前面添加到窗体的变换矩阵的 30 度的旋转矩阵。  
  
-   旋转的世界转换矩阵乘以经过平移`transformMatrix`中，追加`transformMatrix`到世界转换矩阵。  
  
-   绘制旋转、 平移的椭圆。  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples3#144](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CPP/form1.cpp#144)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples3#144](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CS/form1.cs#144)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples3#144](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/VB/form1.vb#144)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/0659fe00-9e0c-41c4-9118-016f2404c905">转换的矩阵表示形式</related>
      </Docs>
    </Member>
    <Member MemberName="PageScale">
      <MemberSignature Language="C#" Value="public float PageScale { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float32 PageScale" />
      <MemberSignature Language="DocId" Value="P:System.Drawing.Graphics.PageScale" />
      <MemberSignature Language="VB.NET" Value="Public Property PageScale As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property float PageScale { float get(); void set(float value); };" />
      <MemberSignature Language="F#" Value="member this.PageScale : single with get, set" Usage="System.Drawing.Graphics.PageScale" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置此 <see cref="T:System.Drawing.Graphics" /> 的世界单位和页单位之间的比例。</summary>
        <value>此属性指定此 <see cref="T:System.Drawing.Graphics" /> 的世界单位和页单位之间的比例值。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下面的代码示例演示如何使用<xref:System.Drawing.Graphics.PageScale%2A>和<xref:System.Drawing.Graphics.TranslateTransform%2A>成员可以更改的规模和来源时绘制一个矩形。  
  
 此示例旨在与 Windows 窗体一起使用。 将代码粘贴到窗体并调用`ChangePageScaleAndTranslateTransform`方法时处理该窗体<xref:System.Windows.Forms.Control.Paint>事件，并传递`e`作为<xref:System.Windows.Forms.PaintEventArgs>。  
  
 [!code-cpp[System.Drawing.GraphicsProperties#2](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.GraphicsProperties/CPP/form1.cpp#2)]
 [!code-csharp[System.Drawing.GraphicsProperties#2](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.GraphicsProperties/CS/form1.cs#2)]
 [!code-vb[System.Drawing.GraphicsProperties#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.GraphicsProperties/VB/form1.vb#2)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/c61ff50a-eb1d-4e6c-83cd-f7e9764cfa9f">坐标系类型</related>
      </Docs>
    </Member>
    <Member MemberName="PageUnit">
      <MemberSignature Language="C#" Value="public System.Drawing.GraphicsUnit PageUnit { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.GraphicsUnit PageUnit" />
      <MemberSignature Language="DocId" Value="P:System.Drawing.Graphics.PageUnit" />
      <MemberSignature Language="VB.NET" Value="Public Property PageUnit As GraphicsUnit" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::GraphicsUnit PageUnit { System::Drawing::GraphicsUnit get(); void set(System::Drawing::GraphicsUnit value); };" />
      <MemberSignature Language="F#" Value="member this.PageUnit : System.Drawing.GraphicsUnit with get, set" Usage="System.Drawing.Graphics.PageUnit" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.GraphicsUnit</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置用于此 <see cref="T:System.Drawing.Graphics" /> 中的页坐标的度量单位。</summary>
        <value>除 <see cref="F:System.Drawing.GraphicsUnit.World" /> 以外的 <see cref="T:System.Drawing.GraphicsUnit" /> 值之一。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 图形单元是用于在此页坐标的度量单位<xref:System.Drawing.Graphics>。  
  
   
  
## Examples  
 下面的代码示例演示了更改的效果<xref:System.Drawing.Graphics.PageUnit%2A>属性。  
  
 此示例旨在与 Windows 窗体一起使用。 将代码粘贴到窗体并调用`ChangePageUnit`方法时处理该窗体<xref:System.Windows.Forms.Control.Paint>事件，并传递`e`作为<xref:System.Windows.Forms.PaintEventArgs>。  
  
 [!code-cpp[System.Drawing.GraphicsProperties#3](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.GraphicsProperties/CPP/form1.cpp#3)]
 [!code-csharp[System.Drawing.GraphicsProperties#3](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.GraphicsProperties/CS/form1.cs#3)]
 [!code-vb[System.Drawing.GraphicsProperties#3](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.GraphicsProperties/VB/form1.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <see cref="P:System.Drawing.Graphics.PageUnit" /> 设置为 <see cref="F:System.Drawing.GraphicsUnit.World" />，此值不是物理单位。</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/c61ff50a-eb1d-4e6c-83cd-f7e9764cfa9f">坐标系类型</related>
      </Docs>
    </Member>
    <Member MemberName="PixelOffsetMode">
      <MemberSignature Language="C#" Value="public System.Drawing.Drawing2D.PixelOffsetMode PixelOffsetMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Drawing2D.PixelOffsetMode PixelOffsetMode" />
      <MemberSignature Language="DocId" Value="P:System.Drawing.Graphics.PixelOffsetMode" />
      <MemberSignature Language="VB.NET" Value="Public Property PixelOffsetMode As PixelOffsetMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::Drawing2D::PixelOffsetMode PixelOffsetMode { System::Drawing::Drawing2D::PixelOffsetMode get(); void set(System::Drawing::Drawing2D::PixelOffsetMode value); };" />
      <MemberSignature Language="F#" Value="member this.PixelOffsetMode : System.Drawing.Drawing2D.PixelOffsetMode with get, set" Usage="System.Drawing.Graphics.PixelOffsetMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Drawing2D.PixelOffsetMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值指定在呈现此 <see cref="T:System.Drawing.Graphics" /> 的过程中像素如何偏移。</summary>
        <value>此属性指定 <see cref="T:System.Drawing.Drawing2D.PixelOffsetMode" /> 枚举的成员。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此属性用于指定此内容的任一更高质量、 速度较慢呈现或较低质量更快呈现<xref:System.Drawing.Graphics>对象。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReleaseHdc">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>释放通过以前对此 <see cref="T:System.Drawing.Graphics" /> 的 <see cref="M:System.Drawing.Graphics.GetHdc" /> 方法的调用获得的设备上下文句柄。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReleaseHdc">
      <MemberSignature Language="C#" Value="public void ReleaseHdc ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ReleaseHdc() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.ReleaseHdc" />
      <MemberSignature Language="VB.NET" Value="Public Sub ReleaseHdc ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ReleaseHdc();" />
      <MemberSignature Language="F#" Value="abstract member ReleaseHdc : unit -&gt; unit&#xA;override this.ReleaseHdc : unit -&gt; unit" Usage="graphics.ReleaseHdc " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Drawing.IDeviceContext.ReleaseHdc</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>释放通过以前对此 <see cref="T:System.Drawing.Graphics" /> 的 <see cref="M:System.Drawing.Graphics.GetHdc" /> 方法的调用获得的设备上下文句柄。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Drawing.Graphics.GetHdc%2A> 和<xref:System.Drawing.Graphics.ReleaseHdc%2A>两种方法，可用于获取并释放 Windows 设备的句柄。 应始终遵循对的调用<xref:System.Drawing.Graphics.GetHdc%2A>通过调用<xref:System.Drawing.Graphics.ReleaseHdc%2A>当您使用完 Windows 句柄。  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">用于访问非托管代码。 相关的枚举： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />。</permission>
        <altmember cref="T:System.Drawing.IDeviceContext" />
      </Docs>
    </Member>
    <Member MemberName="ReleaseHdc">
      <MemberSignature Language="C#" Value="public void ReleaseHdc (IntPtr hdc);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ReleaseHdc(native int hdc) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.ReleaseHdc(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ReleaseHdc (hdc As IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ReleaseHdc(IntPtr hdc);" />
      <MemberSignature Language="F#" Value="member this.ReleaseHdc : nativeint -&gt; unit" Usage="graphics.ReleaseHdc hdc" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netcore-2.1;dotnet-plat-ext-2.1">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="hdc" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="hdc">通过以前对此 <see cref="T:System.Drawing.Graphics" /> 的 <see cref="M:System.Drawing.Graphics.GetHdc" /> 方法的调用获得的设备上下文句柄。</param>
        <summary>释放通过以前对此 <see cref="T:System.Drawing.Graphics" /> 的 <see cref="M:System.Drawing.Graphics.GetHdc" /> 方法的调用获得的设备上下文句柄。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 设备上下文是一种 Windows 结构基于[!INCLUDE[ndptecgdi](~/includes/ndptecgdi-md.md)]，它定义一组图形对象和其关联的属性，以及影响输出的图形模式。  
  
 调用<xref:System.Drawing.Graphics.GetHdc%2A>和<xref:System.Drawing.Graphics.ReleaseHdc%2A>方法必须成对出现。 期间的作用域<xref:System.Drawing.Graphics.GetHdc%2A>并<xref:System.Drawing.Graphics.ReleaseHdc%2A>方法对您通常进行调用只能与[!INCLUDE[ndptecgdi](~/includes/ndptecgdi-md.md)]函数。 在该作用域对[!INCLUDE[ndptecgdiplus](~/includes/ndptecgdiplus-md.md)]的方法<xref:System.Drawing.Graphics>生成`hdc`参数因`ObjectBusy`错误。 此外，[!INCLUDE[ndptecgdiplus](~/includes/ndptecgdiplus-md.md)]将忽略进行的任何状态更改<xref:System.Drawing.Graphics>的`hdc`后续操作中的参数。  
  
   
  
## Examples  
 下面的代码示例设计为使用 Windows 窗体，并且它需要<xref:System.Windows.Forms.PaintEventArgs> `e`，这是一个参数的<xref:System.Windows.Forms.Control.Paint>事件处理程序。 该示例演示如何调用 Windows[!INCLUDE[ndptecgdi](~/includes/ndptecgdi-md.md)]函数来执行相同的任务[!INCLUDE[ndptecgdiplus](~/includes/ndptecgdiplus-md.md)]<xref:System.Drawing.Graphics>方法。 该代码执行下列操作：  
  
-   定义互操作性<xref:System.Runtime.InteropServices.DllImportAttribute>Windows DLL 文件 gdi32.dll 的属性。 此 DLL 包含所需[!INCLUDE[ndptecgdi](~/includes/ndptecgdi-md.md)]函数，并且它定义<xref:System.Drawing.Rectangle>为外部该 DLL 中的函数。  
  
-   创建红色笔。  
  
-   使用笔，向屏幕使用绘制一个矩形[!INCLUDE[ndptecgdiplus](~/includes/ndptecgdiplus-md.md)]<xref:System.Drawing.Graphics.DrawRectangle%2A>方法。  
  
-   定义一个内部指针类型变量`hdc`并将其值设置为窗体的设备上下文的句柄。  
  
-   向屏幕使用绘制一个矩形[!INCLUDE[ndptecgdi](~/includes/ndptecgdi-md.md)]<xref:System.Drawing.Rectangle>函数。  
  
-   释放所表示的设备上下文`hdc`参数。  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples3#145](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CPP/form1.cpp#145)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples3#145](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CS/form1.cs#145)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples3#145](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/VB/form1.vb#145)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">用于访问非托管代码。 相关的枚举： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />。</permission>
      </Docs>
    </Member>
    <Member MemberName="ReleaseHdcInternal">
      <MemberSignature Language="C#" Value="public void ReleaseHdcInternal (IntPtr hdc);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ReleaseHdcInternal(native int hdc) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.ReleaseHdcInternal(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ReleaseHdcInternal (hdc As IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ReleaseHdcInternal(IntPtr hdc);" />
      <MemberSignature Language="F#" Value="member this.ReleaseHdcInternal : nativeint -&gt; unit" Usage="graphics.ReleaseHdcInternal hdc" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netcore-2.1;dotnet-plat-ext-2.1">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="hdc" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="hdc">设备上下文的句柄。</param>
        <summary>释放设备上下文的句柄。</summary>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">用于访问非托管代码。 相关的枚举： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />。</permission>
      </Docs>
    </Member>
    <Member MemberName="RenderingOrigin">
      <MemberSignature Language="C#" Value="public System.Drawing.Point RenderingOrigin { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Point RenderingOrigin" />
      <MemberSignature Language="DocId" Value="P:System.Drawing.Graphics.RenderingOrigin" />
      <MemberSignature Language="VB.NET" Value="Public Property RenderingOrigin As Point" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::Point RenderingOrigin { System::Drawing::Point get(); void set(System::Drawing::Point value); };" />
      <MemberSignature Language="F#" Value="member this.RenderingOrigin : System.Drawing.Point with get, set" Usage="System.Drawing.Graphics.RenderingOrigin" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Point</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>为抵色处理和阴影画笔获取或设置此 <see cref="T:System.Drawing.Graphics" /> 的呈现原点。</summary>
        <value>一个 <see cref="T:System.Drawing.Point" /> 结构，它表示 8 位/像素和 16 位/像素抖色处理的抖色原点，还用于设置阴影画笔的原点。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ResetClip">
      <MemberSignature Language="C#" Value="public void ResetClip ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ResetClip() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.ResetClip" />
      <MemberSignature Language="VB.NET" Value="Public Sub ResetClip ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ResetClip();" />
      <MemberSignature Language="F#" Value="member this.ResetClip : unit -&gt; unit" Usage="graphics.ResetClip " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>将此 <see cref="T:System.Drawing.Graphics" /> 的剪辑区域重置为无限区域。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 时的剪辑区域<xref:System.Drawing.Graphics>为无限制，此项<xref:System.Drawing.Graphics>绘制不被剪辑。  
  
   
  
## Examples  
 下面的代码示例设计为使用 Windows 窗体，并且它需要<xref:System.Windows.Forms.PaintEventArgs> `e`，这是一个参数的<xref:System.Windows.Forms.Control.Paint>事件处理程序。 该代码执行下列操作：  
  
-   创建一个矩形左上角位于 （0，0） 和剪辑区域设置与此矩形。  
  
-   创建其左上角位于第二个矩形 （100，100），并设置为当前剪辑区域 （第一个矩形） 此矩形的交集的剪辑区域。  
  
-   填充一个大的矩形包含用纯色的蓝色画笔前两个矩形。  
  
-   将剪辑区域重置为无限。  
  
-   在两个剪辑区域中; 周围绘制矩形它使用黑色笔的第一个剪辑矩形和红色钢笔的第二个剪辑区域。  
  
 结果是只有两个矩形的交集用蓝色填充。  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples3#146](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CPP/form1.cpp#146)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples3#146](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CS/form1.cs#146)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples3#146](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/VB/form1.vb#146)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ResetTransform">
      <MemberSignature Language="C#" Value="public void ResetTransform ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ResetTransform() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.ResetTransform" />
      <MemberSignature Language="VB.NET" Value="Public Sub ResetTransform ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ResetTransform();" />
      <MemberSignature Language="F#" Value="member this.ResetTransform : unit -&gt; unit" Usage="graphics.ResetTransform " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>将此 <see cref="T:System.Drawing.Graphics" /> 的世界转换矩阵重置为单位矩阵。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 恒等矩阵表示无缩放、 旋转或平移转换。 重置此世界转换<xref:System.Drawing.Graphics>恒等矩阵意味着其世界转换不会更改的已转换项目的几何。  
  
   
  
## Examples  
 下面的代码示例设计为使用 Windows 窗体，并且它需要<xref:System.Windows.Forms.PaintEventArgs> `e`，这是一个参数的<xref:System.Windows.Forms.Control.Paint>事件处理程序。 该代码执行下列操作：  
  
-   Windows 窗体的世界转换平移矢量 （100，0）。  
  
-   保存窗体的图形状态。  
  
-   将窗体的世界转换重置为标识，并使用实心的红色画笔填充矩形。  
  
-   还原已翻译的图形状态，并使用纯色的蓝色画笔填充的矩形。  
  
 结果是一个未转换的红色填充的矩形和已翻译的蓝色填充的矩形。  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples3#147](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CPP/form1.cpp#147)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples3#147](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CS/form1.cs#147)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples3#147](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/VB/form1.vb#147)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Restore">
      <MemberSignature Language="C#" Value="public void Restore (System.Drawing.Drawing2D.GraphicsState gstate);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Restore(class System.Drawing.Drawing2D.GraphicsState gstate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.Restore(System.Drawing.Drawing2D.GraphicsState)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Restore (gstate As GraphicsState)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Restore(System::Drawing::Drawing2D::GraphicsState ^ gstate);" />
      <MemberSignature Language="F#" Value="member this.Restore : System.Drawing.Drawing2D.GraphicsState -&gt; unit" Usage="graphics.Restore gstate" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="gstate" Type="System.Drawing.Drawing2D.GraphicsState" />
      </Parameters>
      <Docs>
        <param name="gstate">
          <see cref="T:System.Drawing.Drawing2D.GraphicsState" />，它表示要将此 <see cref="T:System.Drawing.Graphics" /> 还原到的状态。</param>
        <summary>将此 <see cref="T:System.Drawing.Graphics" /> 的状态还原到 <see cref="T:System.Drawing.Drawing2D.GraphicsState" /> 表示的状态。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当您调用<xref:System.Drawing.Graphics.Save%2A>方法<xref:System.Drawing.Graphics>，保存的状态信息块<xref:System.Drawing.Graphics>放在堆栈上。 <xref:System.Drawing.Graphics.Save%2A>方法将返回<xref:System.Drawing.Drawing2D.GraphicsState>，用于标识该信息块。 传递标识<xref:System.Drawing.Drawing2D.GraphicsState>到<xref:System.Drawing.Graphics.Restore%2A>方法，从堆栈中移除和用于还原信息块<xref:System.Drawing.Graphics>时的状态为<xref:System.Drawing.Graphics.Save%2A>方法调用。 请注意，<xref:System.Drawing.Drawing2D.GraphicsState>对给定调用返回<xref:System.Drawing.Graphics.Save%2A>方法可以一次传递给`Restore`方法。  
  
 调用<xref:System.Drawing.Graphics.Save%2A>方法可以嵌套; 也就是说，可以调用<xref:System.Drawing.Graphics.Save%2A>方法在调用之前几次<xref:System.Drawing.Graphics.Restore%2A>方法。 每次调用<xref:System.Drawing.Graphics.Save%2A>方法中，信息块放置在堆栈上，并且您收到<xref:System.Drawing.Drawing2D.GraphicsState>信息块。 当传递到这些对象之一<xref:System.Drawing.Graphics.Restore%2A>方法，<xref:System.Drawing.Graphics>返回到它所处的时间的状态<xref:System.Drawing.Graphics.Save%2A>方法调用返回了该特定<xref:System.Drawing.Drawing2D.GraphicsState>。 信息块放置在堆栈上的<xref:System.Drawing.Graphics.Save%2A>方法调用将从堆栈中，删除，所有信息块后，都放置在该堆栈上<xref:System.Drawing.Graphics.Save%2A>方法调用也将被删除。  
  
 调用<xref:System.Drawing.Graphics.BeginContainer%2A>方法相同调用堆栈上的位置信息块<xref:System.Drawing.Graphics.Save%2A>方法。 就像<xref:System.Drawing.Graphics.Restore%2A>调用搭配<xref:System.Drawing.Graphics.Save%2A>调用，请<xref:System.Drawing.Graphics.EndContainer%2A>方法调用搭配<xref:System.Drawing.Graphics.BeginContainer%2A>方法调用。  
  
 当您调用<xref:System.Drawing.Graphics.Restore%2A>方法中，所有信息块都放置在堆栈上 (通过<xref:System.Drawing.Graphics.Save%2A>方法或通过<xref:System.Drawing.Graphics.BeginContainer%2A>方法) 后的对应调用<xref:System.Drawing.Graphics.Save%2A>方法从堆栈中移除。 同样，当您调用<xref:System.Drawing.Graphics.EndContainer%2A>方法中，所有信息块都放置在堆栈上 (通过<xref:System.Drawing.Graphics.Save%2A>方法或通过<xref:System.Drawing.Graphics.BeginContainer%2A>方法) 后的对应调用<xref:System.Drawing.Graphics.BeginContainer%2A>方法从堆栈中移除。  
  
   
  
## Examples  
 下面的代码示例设计为使用 Windows 窗体，并且它需要<xref:System.Windows.Forms.PaintEventArgs> `e`，这是一个参数的<xref:System.Windows.Forms.Control.Paint>事件处理程序。 该代码执行下列操作：  
  
-   Windows 窗体的世界转换平移矢量 （100，0）。  
  
-   保存窗体的图形状态。  
  
-   将窗体的世界转换重置为标识，并使用实心的红色画笔填充矩形。  
  
-   还原已翻译的图形状态，并使用纯色的蓝色画笔填充第二个矩形。  
  
 结果是一个未转换的红色填充的矩形和已翻译的蓝色填充的矩形。  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples3#148](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CPP/form1.cpp#148)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples3#148](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CS/form1.cs#148)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples3#148](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/VB/form1.vb#148)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="RotateTransform">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>将指定旋转应用于此 <see cref="T:System.Drawing.Graphics" /> 的转换矩阵。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RotateTransform">
      <MemberSignature Language="C#" Value="public void RotateTransform (float angle);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RotateTransform(float32 angle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.RotateTransform(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RotateTransform (angle As Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RotateTransform(float angle);" />
      <MemberSignature Language="F#" Value="member this.RotateTransform : single -&gt; unit" Usage="graphics.RotateTransform angle" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="angle" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="angle">旋转角度（以度为单位）。</param>
        <summary>将指定旋转应用于此 <see cref="T:System.Drawing.Graphics" /> 的转换矩阵。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 旋转操作包括将其元素派生自的矩阵转换矩阵乘以`angle`参数。 此方法通过预置到转换矩阵应用旋转。  
  
   
  
## Examples  
 下面的代码示例设计为使用 Windows 窗体，并且它需要<xref:System.Windows.Forms.PaintEventArgs> `e`，这是一个参数的<xref:System.Windows.Forms.Control.Paint>事件处理程序。 该代码执行下列操作：  
  
-   Windows 窗体的世界转换矩阵平移矢量 （100，0）。  
  
-   旋转 30 度，前面添加旋转矩阵到世界转换矩阵的角度的世界转换。  
  
-   使用蓝色笔绘制旋转、 平移的椭圆。  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples3#149](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CPP/form1.cpp#149)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples3#149](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CS/form1.cs#149)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples3#149](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/VB/form1.vb#149)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RotateTransform">
      <MemberSignature Language="C#" Value="public void RotateTransform (float angle, System.Drawing.Drawing2D.MatrixOrder order);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RotateTransform(float32 angle, valuetype System.Drawing.Drawing2D.MatrixOrder order) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.RotateTransform(System.Single,System.Drawing.Drawing2D.MatrixOrder)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RotateTransform (angle As Single, order As MatrixOrder)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RotateTransform(float angle, System::Drawing::Drawing2D::MatrixOrder order);" />
      <MemberSignature Language="F#" Value="member this.RotateTransform : single * System.Drawing.Drawing2D.MatrixOrder -&gt; unit" Usage="graphics.RotateTransform (angle, order)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="angle" Type="System.Single" />
        <Parameter Name="order" Type="System.Drawing.Drawing2D.MatrixOrder" />
      </Parameters>
      <Docs>
        <param name="angle">旋转角度（以度为单位）。</param>
        <param name="order">
          <see cref="T:System.Drawing.Drawing2D.MatrixOrder" /> 枚举的成员，它指定是将旋转追加到矩阵转换之后还是添加到矩阵转换之前。</param>
        <summary>以指定顺序将指定旋转应用到此 <see cref="T:System.Drawing.Graphics" /> 的转换矩阵。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 旋转操作包括将其元素派生自的矩阵转换矩阵乘以`angle`参数。 此方法前面添加或追加的转换矩阵<xref:System.Drawing.Graphics>通过根据旋转矩阵`order`参数。  
  
   
  
## Examples  
 下面的代码示例设计为使用 Windows 窗体，并且它需要<xref:System.Windows.Forms.PaintEventArgs> `e`，这是一个参数的<xref:System.Windows.Forms.Control.Paint>事件处理程序。 该代码执行下列操作：  
  
-   Windows 窗体的世界转换矩阵平移矢量 （100，0）。  
  
-   旋转角度为 30 度，追加到使用世界转换矩阵的旋转矩阵世界变换<xref:System.Drawing.Drawing2D.MatrixOrder.Append>。  
  
-   使用蓝色笔绘制平移、 旋转椭圆。  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples3#150](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CPP/form1.cpp#150)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples3#150](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CS/form1.cs#150)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples3#150](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/VB/form1.vb#150)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Save">
      <MemberSignature Language="C#" Value="public System.Drawing.Drawing2D.GraphicsState Save ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Drawing.Drawing2D.GraphicsState Save() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.Save" />
      <MemberSignature Language="VB.NET" Value="Public Function Save () As GraphicsState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Drawing::Drawing2D::GraphicsState ^ Save();" />
      <MemberSignature Language="F#" Value="member this.Save : unit -&gt; System.Drawing.Drawing2D.GraphicsState" Usage="graphics.Save " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Drawing2D.GraphicsState</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>保存此 <see cref="T:System.Drawing.Graphics" /> 的当前状态，并用 <see cref="T:System.Drawing.Drawing2D.GraphicsState" /> 标识保存的状态。</summary>
        <returns>此方法返回 <see cref="T:System.Drawing.Drawing2D.GraphicsState" />，该对象表示此 <see cref="T:System.Drawing.Graphics" /> 的保存状态。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当您调用<xref:System.Drawing.Graphics.Save%2A>方法<xref:System.Drawing.Graphics>，保存的状态信息块<xref:System.Drawing.Graphics>放在堆栈上。 <xref:System.Drawing.Graphics.Save%2A>方法将返回<xref:System.Drawing.Drawing2D.GraphicsState>，用于标识该信息块。 传递标识<xref:System.Drawing.Drawing2D.GraphicsState>到<xref:System.Drawing.Graphics.Restore%2A>方法，从堆栈中移除和用于还原信息块<xref:System.Drawing.Graphics>时的状态为<xref:System.Drawing.Graphics.Save%2A>方法调用。 请注意，<xref:System.Drawing.Drawing2D.GraphicsState>对给定调用返回<xref:System.Drawing.Graphics.Save%2A>方法可以一次传递给<xref:System.Drawing.Graphics.Restore%2A>方法。  
  
 调用<xref:System.Drawing.Graphics.Save%2A>方法可以嵌套; 也就是说，可以调用<xref:System.Drawing.Graphics.Save%2A>方法在调用之前几次<xref:System.Drawing.Graphics.Restore%2A>方法。 每次调用<xref:System.Drawing.Graphics.Save%2A>方法中，信息块放置在堆栈上，并且您收到<xref:System.Drawing.Drawing2D.GraphicsState>信息块。 当传递到这些对象之一<xref:System.Drawing.Graphics.Restore%2A>方法，<xref:System.Drawing.Graphics>返回到它所处的时间的状态<xref:System.Drawing.Graphics.Save%2A>方法调用返回了该特定<xref:System.Drawing.Drawing2D.GraphicsState>。 信息块放置在堆栈上的<xref:System.Drawing.Graphics.Save%2A>方法调用将从堆栈中，删除，所有信息块后，都放置在该堆栈上<xref:System.Drawing.Graphics.Save%2A>方法调用也将被删除。  
  
 调用<xref:System.Drawing.Graphics.BeginContainer%2A>方法相同调用堆栈上的位置信息块<xref:System.Drawing.Graphics.Save%2A>方法。 就像<xref:System.Drawing.Graphics.Restore%2A>调用搭配<xref:System.Drawing.Graphics.Save%2A>调用，请<xref:System.Drawing.Graphics.EndContainer%2A>方法调用搭配<xref:System.Drawing.Graphics.BeginContainer%2A>方法调用。  
  
 当您调用<xref:System.Drawing.Graphics.Restore%2A>方法中，所有信息块都放置在堆栈上 (通过<xref:System.Drawing.Graphics.Save%2A>方法或通过<xref:System.Drawing.Graphics.BeginContainer%2A>方法) 后的对应调用<xref:System.Drawing.Graphics.Save%2A>方法从堆栈中移除。 同样，当您调用<xref:System.Drawing.Graphics.EndContainer%2A>方法中，所有信息块都放置在堆栈上 (通过<xref:System.Drawing.Graphics.Save%2A>方法或通过<xref:System.Drawing.Graphics.BeginContainer%2A>方法) 后的对应调用<xref:System.Drawing.Graphics.BeginContainer%2A>方法从堆栈中移除。  
  
   
  
## Examples  
 下面的代码示例设计为使用 Windows 窗体，并且它需要<xref:System.Windows.Forms.PaintEventArgs> `e`，这是一个参数的<xref:System.Windows.Forms.Control.Paint>事件处理程序。 该代码执行下列操作：  
  
-   Windows 窗体的世界转换平移矢量 （100，0）。  
  
-   保存窗体的图形状态。  
  
-   将窗体的世界转换重置为标识 （2 x 2 恒等矩阵加上零向量转换），并使用实心的红色画笔填充矩形。  
  
-   还原已翻译的图形状态，并使用纯色的蓝色画笔填充的矩形。  
  
 结果是一个未转换的红色填充的矩形在左边和已翻译的蓝色填充矩形在窗体的右侧。  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples3#151](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CPP/form1.cpp#151)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples3#151](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CS/form1.cs#151)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples3#151](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/VB/form1.vb#151)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ScaleTransform">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>将指定的缩放操作应用于此 <see cref="T:System.Drawing.Graphics" /> 的转换矩阵，方法是将该对象的转换矩阵左乘该缩放矩阵。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ScaleTransform">
      <MemberSignature Language="C#" Value="public void ScaleTransform (float sx, float sy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ScaleTransform(float32 sx, float32 sy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.ScaleTransform(System.Single,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ScaleTransform (sx As Single, sy As Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ScaleTransform(float sx, float sy);" />
      <MemberSignature Language="F#" Value="member this.ScaleTransform : single * single -&gt; unit" Usage="graphics.ScaleTransform (sx, sy)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sx" Type="System.Single" />
        <Parameter Name="sy" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="sx">x 方向的缩放比例。</param>
        <param name="sy">y 方向的缩放比例。</param>
        <summary>将指定的缩放操作应用于此 <see cref="T:System.Drawing.Graphics" /> 的转换矩阵，方法是将该对象的转换矩阵左乘该缩放矩阵。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在缩放操作包括将它的元素的对角矩阵转换矩阵乘以 (`sx`， `sy`，1)。 此方法预先计算的转换矩阵<xref:System.Drawing.Graphics>的缩放矩阵。  
  
   
  
## Examples  
 下面的代码示例设计为使用 Windows 窗体，并且它需要<xref:System.Windows.Forms.PaintEventArgs> `e`，这是一个参数的<xref:System.Windows.Forms.Control.Paint>事件处理程序。 该代码执行下列操作：  
  
-   旋转 30 度的 Windows 窗体的世界转换矩阵。  
  
-   通过预先计算的缩放转换按沿 x 方向的 3 倍和因子为 1 沿 y 方向缩放该矩阵。  
  
-   使用蓝色笔绘制缩放、 旋转矩形。  
  
 结果仍是一个矩形。  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples3#152](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CPP/form1.cpp#152)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples3#152](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CS/form1.cs#152)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples3#152](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/VB/form1.vb#152)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ScaleTransform">
      <MemberSignature Language="C#" Value="public void ScaleTransform (float sx, float sy, System.Drawing.Drawing2D.MatrixOrder order);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ScaleTransform(float32 sx, float32 sy, valuetype System.Drawing.Drawing2D.MatrixOrder order) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.ScaleTransform(System.Single,System.Single,System.Drawing.Drawing2D.MatrixOrder)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ScaleTransform (sx As Single, sy As Single, order As MatrixOrder)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ScaleTransform(float sx, float sy, System::Drawing::Drawing2D::MatrixOrder order);" />
      <MemberSignature Language="F#" Value="member this.ScaleTransform : single * single * System.Drawing.Drawing2D.MatrixOrder -&gt; unit" Usage="graphics.ScaleTransform (sx, sy, order)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sx" Type="System.Single" />
        <Parameter Name="sy" Type="System.Single" />
        <Parameter Name="order" Type="System.Drawing.Drawing2D.MatrixOrder" />
      </Parameters>
      <Docs>
        <param name="sx">x 方向的缩放比例。</param>
        <param name="sy">y 方向的缩放比例。</param>
        <param name="order">
          <see cref="T:System.Drawing.Drawing2D.MatrixOrder" /> 枚举的成员，它指定是将缩放操作添加到转换矩阵前还是追加到转换矩阵后。</param>
        <summary>以指定顺序将指定的缩放操作应用到此 <see cref="T:System.Drawing.Graphics" /> 的转换矩阵。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在缩放操作包括将它的元素的对角矩阵转换矩阵乘以 (`sx`， `sy`，1)。 此方法前面添加或追加的转换矩阵<xref:System.Drawing.Graphics>通过根据缩放矩阵`order`参数。  
  
   
  
## Examples  
 下面的代码示例设计为使用 Windows 窗体，并且它需要<xref:System.Windows.Forms.PaintEventArgs> `e`，这是一个参数的<xref:System.Windows.Forms.Control.Paint>事件处理程序。 该代码执行下列操作：  
  
-   旋转 30 度的 Windows 窗体的世界转换矩阵。  
  
-   追加的缩放转换使用通过沿 x 方向的 3 倍并因子为 1 沿 y 方向缩放该矩阵<xref:System.Drawing.Drawing2D.MatrixOrder.Append>成员。  
  
-   使用蓝色笔绘制旋转、 缩放矩形。  
  
 结果是一个平行四边形。  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples3#153](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CPP/form1.cpp#153)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples3#153](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CS/form1.cs#153)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples3#153](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/VB/form1.vb#153)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="SetClip">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>将此 <see cref="T:System.Drawing.Graphics" /> 的剪辑区域设置为指定 <see cref="T:System.Drawing.Graphics" /> 的 <see langword="Clip" /> 属性。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetClip">
      <MemberSignature Language="C#" Value="public void SetClip (System.Drawing.Drawing2D.GraphicsPath path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetClip(class System.Drawing.Drawing2D.GraphicsPath path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.SetClip(System.Drawing.Drawing2D.GraphicsPath)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetClip (path As GraphicsPath)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetClip(System::Drawing::Drawing2D::GraphicsPath ^ path);" />
      <MemberSignature Language="F#" Value="member this.SetClip : System.Drawing.Drawing2D.GraphicsPath -&gt; unit" Usage="graphics.SetClip path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.Drawing.Drawing2D.GraphicsPath" />
      </Parameters>
      <Docs>
        <param name="path">
          <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />，它表示新的剪辑区域。</param>
        <summary>将此 <see cref="T:System.Drawing.Graphics" /> 的剪辑区域设置为指定的 <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果使用的图形路径表示`path`参数未闭合，添加额外的线段在最后一个点来闭合该路径的第一个点。  
  
   
  
## Examples  
 下面的代码示例设计为使用 Windows 窗体，并且它需要<xref:System.Windows.Forms.PaintEventArgs> `e`，这是一个参数的<xref:System.Windows.Forms.Control.Paint>事件处理程序。 该代码执行下列操作：  
  
-   创建图形路径并向该路径添加一个椭圆。  
  
-   剪辑区域设置为椭圆路径。  
  
-   使用纯黑色画笔填充一个大的矩形。  
  
 结果是黑色的实心椭圆。  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples3#154](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CPP/form1.cpp#154)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples3#154](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CS/form1.cs#154)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples3#154](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/VB/form1.vb#154)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetClip">
      <MemberSignature Language="C#" Value="public void SetClip (System.Drawing.Graphics g);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetClip(class System.Drawing.Graphics g) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.SetClip(System.Drawing.Graphics)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetClip (g As Graphics)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetClip(System::Drawing::Graphics ^ g);" />
      <MemberSignature Language="F#" Value="member this.SetClip : System.Drawing.Graphics -&gt; unit" Usage="graphics.SetClip g" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="g" Type="System.Drawing.Graphics" />
      </Parameters>
      <Docs>
        <param name="g">
          <see cref="T:System.Drawing.Graphics" />，从该对象中获取新剪辑区域。</param>
        <summary>将此 <see cref="T:System.Drawing.Graphics" /> 的剪辑区域设置为指定 <see cref="T:System.Drawing.Graphics" /> 的 <see langword="Clip" /> 属性。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下面的代码示例设计为使用 Windows 窗体，并且它需要<xref:System.Windows.Forms.PaintEventArgs> `e`，这是一个参数的<xref:System.Windows.Forms.Control.Paint>事件处理程序，以及`thisForm`，则<xref:System.Windows.Forms.Form>的示例。 该代码执行下列操作：  
  
-   创建一个临时<xref:System.Drawing.Graphics>从`thisForm`<xref:System.Windows.Forms.Form>的示例。  
  
-   临时的剪辑区域设置<xref:System.Drawing.Graphics>为一个小正方形。  
  
-   窗体的图形对象的剪辑区域更新的临时<xref:System.Drawing.Graphics>。  
  
-   使用纯黑色画笔填充一个大的矩形。  
  
 结果是一个小型、 填充、 黑色方形。  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples3#156](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CPP/form1.cpp#156)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples3#156](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CS/form1.cs#156)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples3#156](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/VB/form1.vb#156)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetClip">
      <MemberSignature Language="C#" Value="public void SetClip (System.Drawing.Rectangle rect);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetClip(valuetype System.Drawing.Rectangle rect) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.SetClip(System.Drawing.Rectangle)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetClip (rect As Rectangle)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetClip(System::Drawing::Rectangle rect);" />
      <MemberSignature Language="F#" Value="member this.SetClip : System.Drawing.Rectangle -&gt; unit" Usage="graphics.SetClip rect" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rect" Type="System.Drawing.Rectangle" />
      </Parameters>
      <Docs>
        <param name="rect">
          <see cref="T:System.Drawing.Rectangle" /> 结构，它表示新的剪辑区域。</param>
        <summary>将此 <see cref="T:System.Drawing.Graphics" /> 的剪辑区域设置为 <see cref="T:System.Drawing.Rectangle" /> 结构指定的矩形。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下面的代码示例设计为使用 Windows 窗体，并且它需要<xref:System.Windows.Forms.PaintEventArgs> `e`，这是一个参数的<xref:System.Windows.Forms.Control.Paint>事件处理程序。 该代码执行下列操作：  
  
-   创建一个小的矩形的剪辑区域。  
  
-   向该矩形的剪辑区域设置。  
  
-   使用纯黑色画笔填充一个大的矩形。  
  
 结果是一个小型、 填充、 黑色的矩形。  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples3#158](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CPP/form1.cpp#158)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples3#158](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CS/form1.cs#158)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples3#158](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/VB/form1.vb#158)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetClip">
      <MemberSignature Language="C#" Value="public void SetClip (System.Drawing.RectangleF rect);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetClip(valuetype System.Drawing.RectangleF rect) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.SetClip(System.Drawing.RectangleF)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetClip (rect As RectangleF)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetClip(System::Drawing::RectangleF rect);" />
      <MemberSignature Language="F#" Value="member this.SetClip : System.Drawing.RectangleF -&gt; unit" Usage="graphics.SetClip rect" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rect" Type="System.Drawing.RectangleF" />
      </Parameters>
      <Docs>
        <param name="rect">
          <see cref="T:System.Drawing.RectangleF" /> 结构，它表示新的剪辑区域。</param>
        <summary>将此 <see cref="T:System.Drawing.Graphics" /> 的剪辑区域设置为 <see cref="T:System.Drawing.RectangleF" /> 结构指定的矩形。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下面的代码示例设计为使用 Windows 窗体，并且它需要<xref:System.Windows.Forms.PaintEventArgs> `e`，这是一个参数的<xref:System.Windows.Forms.Control.Paint>事件处理程序。 该代码执行下列操作：  
  
-   创建一个小的矩形的剪辑区域。  
  
-   向该矩形的剪辑区域设置。  
  
-   使用纯黑色画笔填充一个大的矩形。  
  
 结果是一个小型、 填充、 黑色的矩形。  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples3#160](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CPP/form1.cpp#160)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples3#160](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CS/form1.cs#160)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples3#160](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/VB/form1.vb#160)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetClip">
      <MemberSignature Language="C#" Value="public void SetClip (System.Drawing.Drawing2D.GraphicsPath path, System.Drawing.Drawing2D.CombineMode combineMode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetClip(class System.Drawing.Drawing2D.GraphicsPath path, valuetype System.Drawing.Drawing2D.CombineMode combineMode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.SetClip(System.Drawing.Drawing2D.GraphicsPath,System.Drawing.Drawing2D.CombineMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetClip(System::Drawing::Drawing2D::GraphicsPath ^ path, System::Drawing::Drawing2D::CombineMode combineMode);" />
      <MemberSignature Language="F#" Value="member this.SetClip : System.Drawing.Drawing2D.GraphicsPath * System.Drawing.Drawing2D.CombineMode -&gt; unit" Usage="graphics.SetClip (path, combineMode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.Drawing.Drawing2D.GraphicsPath" />
        <Parameter Name="combineMode" Type="System.Drawing.Drawing2D.CombineMode" />
      </Parameters>
      <Docs>
        <param name="path">要组合的 <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />。</param>
        <param name="combineMode">
          <see cref="T:System.Drawing.Drawing2D.CombineMode" /> 枚举的成员，它指定要使用的组合操作。</param>
        <summary>将此 <see cref="T:System.Drawing.Graphics" /> 的剪辑区域设置为当前剪辑区域与指定 <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> 的组合结果。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果使用的图形路径表示`path`参数未闭合，添加额外的线段在最后一个点来闭合该路径的第一个点。  
  
   
  
## Examples  
 下面的代码示例设计为使用 Windows 窗体，并且它需要<xref:System.Windows.Forms.PaintEventArgs> `e`，这是一个参数的<xref:System.Windows.Forms.Control.Paint>事件处理程序。 该代码执行下列操作：  
  
-   创建图形路径并向该路径添加一个椭圆。  
  
-   剪辑区域设置为椭圆路径与<xref:System.Drawing.Drawing2D.CombineMode.Replace>成员。  
  
-   使用纯黑色画笔填充一个大的矩形。  
  
 结果是黑色的实心椭圆。  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples3#155](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CPP/form1.cpp#155)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples3#155](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CS/form1.cs#155)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples3#155](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/VB/form1.vb#155)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetClip">
      <MemberSignature Language="C#" Value="public void SetClip (System.Drawing.Graphics g, System.Drawing.Drawing2D.CombineMode combineMode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetClip(class System.Drawing.Graphics g, valuetype System.Drawing.Drawing2D.CombineMode combineMode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.SetClip(System.Drawing.Graphics,System.Drawing.Drawing2D.CombineMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetClip(System::Drawing::Graphics ^ g, System::Drawing::Drawing2D::CombineMode combineMode);" />
      <MemberSignature Language="F#" Value="member this.SetClip : System.Drawing.Graphics * System.Drawing.Drawing2D.CombineMode -&gt; unit" Usage="graphics.SetClip (g, combineMode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="g" Type="System.Drawing.Graphics" />
        <Parameter Name="combineMode" Type="System.Drawing.Drawing2D.CombineMode" />
      </Parameters>
      <Docs>
        <param name="g">
          <see cref="T:System.Drawing.Graphics" />，它指定要组合的剪辑区域。</param>
        <param name="combineMode">
          <see cref="T:System.Drawing.Drawing2D.CombineMode" /> 枚举的成员，它指定要使用的组合操作。</param>
        <summary>将此 <see cref="T:System.Drawing.Graphics" /> 的剪辑区域设置为当前剪辑区域和指定的 <see cref="T:System.Drawing.Graphics" /> 的 <see cref="P:System.Drawing.Graphics.Clip" /> 属性指定的组合操作的结果。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下面的代码示例设计为使用 Windows 窗体，并且它需要<xref:System.Windows.Forms.PaintEventArgs> `e`，这是一个参数的<xref:System.Windows.Forms.Control.Paint>事件处理程序，以及`thisForm`，则<xref:System.Windows.Forms.Form>的示例。 该代码执行下列操作：  
  
-   创建一个临时<xref:System.Drawing.Graphics>从`thisForm`<xref:System.Windows.Forms.Form>的示例。  
  
-   临时的剪辑区域设置<xref:System.Drawing.Graphics>为一个小正方形。  
  
-   窗体的图形对象的剪辑区域更新的新<xref:System.Drawing.Graphics>与<xref:System.Drawing.Drawing2D.CombineMode.Replace>成员。  
  
-   使用纯黑色画笔填充一个大的矩形。  
  
 结果是一个小型、 填充、 黑色方形。  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples3#157](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CPP/form1.cpp#157)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples3#157](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CS/form1.cs#157)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples3#157](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/VB/form1.vb#157)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetClip">
      <MemberSignature Language="C#" Value="public void SetClip (System.Drawing.Rectangle rect, System.Drawing.Drawing2D.CombineMode combineMode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetClip(valuetype System.Drawing.Rectangle rect, valuetype System.Drawing.Drawing2D.CombineMode combineMode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.SetClip(System.Drawing.Rectangle,System.Drawing.Drawing2D.CombineMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetClip(System::Drawing::Rectangle rect, System::Drawing::Drawing2D::CombineMode combineMode);" />
      <MemberSignature Language="F#" Value="member this.SetClip : System.Drawing.Rectangle * System.Drawing.Drawing2D.CombineMode -&gt; unit" Usage="graphics.SetClip (rect, combineMode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rect" Type="System.Drawing.Rectangle" />
        <Parameter Name="combineMode" Type="System.Drawing.Drawing2D.CombineMode" />
      </Parameters>
      <Docs>
        <param name="rect">要组合的 <see cref="T:System.Drawing.Rectangle" /> 结构。</param>
        <param name="combineMode">
          <see cref="T:System.Drawing.Drawing2D.CombineMode" /> 枚举的成员，它指定要使用的组合操作。</param>
        <summary>将此 <see cref="T:System.Drawing.Graphics" /> 的剪辑区域设置为当前剪辑区域与 <see cref="T:System.Drawing.Rectangle" /> 结构所指定矩形的组合结果。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下面的代码示例设计为使用 Windows 窗体，并且它需要<xref:System.Windows.Forms.PaintEventArgs> `e`，这是一个参数的<xref:System.Windows.Forms.Control.Paint>事件处理程序。 该代码执行下列操作：  
  
-   创建一个小的矩形的剪辑区域。  
  
-   将剪辑区域设置为与矩形<xref:System.Drawing.Drawing2D.CombineMode.Replace>成员。  
  
-   使用纯黑色画笔填充一个大的矩形。  
  
 结果是一个小型、 填充、 黑色的矩形。  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples3#159](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CPP/form1.cpp#159)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples3#159](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CS/form1.cs#159)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples3#159](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/VB/form1.vb#159)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetClip">
      <MemberSignature Language="C#" Value="public void SetClip (System.Drawing.RectangleF rect, System.Drawing.Drawing2D.CombineMode combineMode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetClip(valuetype System.Drawing.RectangleF rect, valuetype System.Drawing.Drawing2D.CombineMode combineMode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.SetClip(System.Drawing.RectangleF,System.Drawing.Drawing2D.CombineMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetClip(System::Drawing::RectangleF rect, System::Drawing::Drawing2D::CombineMode combineMode);" />
      <MemberSignature Language="F#" Value="member this.SetClip : System.Drawing.RectangleF * System.Drawing.Drawing2D.CombineMode -&gt; unit" Usage="graphics.SetClip (rect, combineMode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rect" Type="System.Drawing.RectangleF" />
        <Parameter Name="combineMode" Type="System.Drawing.Drawing2D.CombineMode" />
      </Parameters>
      <Docs>
        <param name="rect">要组合的 <see cref="T:System.Drawing.RectangleF" /> 结构。</param>
        <param name="combineMode">
          <see cref="T:System.Drawing.Drawing2D.CombineMode" /> 枚举的成员，它指定要使用的组合操作。</param>
        <summary>将此 <see cref="T:System.Drawing.Graphics" /> 的剪辑区域设置为当前剪辑区域与 <see cref="T:System.Drawing.RectangleF" /> 结构所指定矩形的组合结果。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下面的代码示例设计为使用 Windows 窗体，并且它需要<xref:System.Windows.Forms.PaintEventArgs> `e`，这是一个参数的<xref:System.Windows.Forms.Control.Paint>事件处理程序。 该代码执行下列操作：  
  
-   创建一个小的矩形的剪辑区域。  
  
-   将剪辑区域设置为与矩形<xref:System.Drawing.Drawing2D.CombineMode.Replace>成员。  
  
-   使用纯黑色画笔填充一个大的矩形。  
  
 结果是一个小型、 填充、 黑色的矩形。  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples3#161](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CPP/form1.cpp#161)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples3#161](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CS/form1.cs#161)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples3#161](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/VB/form1.vb#161)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetClip">
      <MemberSignature Language="C#" Value="public void SetClip (System.Drawing.Region region, System.Drawing.Drawing2D.CombineMode combineMode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetClip(class System.Drawing.Region region, valuetype System.Drawing.Drawing2D.CombineMode combineMode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.SetClip(System.Drawing.Region,System.Drawing.Drawing2D.CombineMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetClip(System::Drawing::Region ^ region, System::Drawing::Drawing2D::CombineMode combineMode);" />
      <MemberSignature Language="F#" Value="member this.SetClip : System.Drawing.Region * System.Drawing.Drawing2D.CombineMode -&gt; unit" Usage="graphics.SetClip (region, combineMode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="region" Type="System.Drawing.Region" />
        <Parameter Name="combineMode" Type="System.Drawing.Drawing2D.CombineMode" />
      </Parameters>
      <Docs>
        <param name="region">要组合的 <see cref="T:System.Drawing.Region" />。</param>
        <param name="combineMode">
          <see cref="T:System.Drawing.Drawing2D.CombineMode" /> 枚举的成员，它指定要使用的组合操作。</param>
        <summary>将此 <see cref="T:System.Drawing.Graphics" /> 的剪辑区域设置为当前剪辑区域与指定 <see cref="T:System.Drawing.Region" /> 的组合结果。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下面的代码示例设计为使用 Windows 窗体，并且它需要<xref:System.Windows.Forms.PaintEventArgs> `e`，这是一个参数的<xref:System.Windows.Forms.Control.Paint>事件处理程序。 该代码执行下列操作：  
  
-   创建一个小的矩形的剪辑区域。  
  
-   将剪辑区域设置为与矩形<xref:System.Drawing.Drawing2D.CombineMode.Replace>成员。  
  
-   使用纯黑色画笔填充一个大的矩形。  
  
 结果是一个小型、 填充、 黑色的矩形。  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples3#162](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CPP/form1.cpp#162)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples3#162](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CS/form1.cs#162)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples3#162](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/VB/form1.vb#162)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SmoothingMode">
      <MemberSignature Language="C#" Value="public System.Drawing.Drawing2D.SmoothingMode SmoothingMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Drawing2D.SmoothingMode SmoothingMode" />
      <MemberSignature Language="DocId" Value="P:System.Drawing.Graphics.SmoothingMode" />
      <MemberSignature Language="VB.NET" Value="Public Property SmoothingMode As SmoothingMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::Drawing2D::SmoothingMode SmoothingMode { System::Drawing::Drawing2D::SmoothingMode get(); void set(System::Drawing::Drawing2D::SmoothingMode value); };" />
      <MemberSignature Language="F#" Value="member this.SmoothingMode : System.Drawing.Drawing2D.SmoothingMode with get, set" Usage="System.Drawing.Graphics.SmoothingMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Drawing2D.SmoothingMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置此 <see cref="T:System.Drawing.Graphics" /> 的呈现质量。</summary>
        <value>
          <see cref="T:System.Drawing.Drawing2D.SmoothingMode" /> 值之一。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 平滑模式指定直线、 曲线和已填充区域的边缘是否使用平滑处理 （也称为抗锯齿）。 一个例外是路径渐变画笔不遵守平滑模式。 使用填充的区域<xref:System.Drawing.Drawing2D.PathGradientBrush>呈现相同的方式 （别名） 而不考虑<xref:System.Drawing.Graphics.SmoothingMode%2A>属性。  
  
   
  
## Examples  
 以下方法演示了设置的效果<xref:System.Drawing.Pen.DashCap%2A>， <xref:System.Drawing.Pen.DashPattern%2A>，和<xref:System.Drawing.Graphics.SmoothingMode%2A>属性。 该示例的输出如下图所示。  
  
 ![具有和没有应用平滑处理的行。](~/add/media/gdi-smoothingmode.png "具有和没有应用平滑处理的行。")  
  
 此示例旨在与 Windows 窗体一起使用。 将代码粘贴到窗体并调用`ShowPensAndSmoothingMode`方法时处理该窗体<xref:System.Windows.Forms.Control.Paint>事件，并传递`e`作为<xref:System.Windows.Forms.PaintEventArgs>。  
  
 [!code-cpp[System.Drawing.PensExample#3](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.PensExample/CPP/form1.cpp#3)]
 [!code-csharp[System.Drawing.PensExample#3](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.PensExample/CS/form1.cs#3)]
 [!code-vb[System.Drawing.PensExample#3](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.PensExample/VB/form1.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TextContrast">
      <MemberSignature Language="C#" Value="public int TextContrast { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 TextContrast" />
      <MemberSignature Language="DocId" Value="P:System.Drawing.Graphics.TextContrast" />
      <MemberSignature Language="VB.NET" Value="Public Property TextContrast As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int TextContrast { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.TextContrast : int with get, set" Usage="System.Drawing.Graphics.TextContrast" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置呈现文本的灰度校正值。</summary>
        <value>用于呈现抗锯齿和 ClearType 文本的伽玛校正值。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 灰度校正值必须介于 0 和 12 之间。 默认值为 4。  
  
   
  
## Examples  
 下面的代码示例演示如何将<xref:System.Drawing.Graphics.TextRenderingHint%2A>和<xref:System.Drawing.Graphics.TextContrast%2A>属性。  
  
 此示例旨在与 Windows 窗体一起使用。 将代码粘贴到窗体并调用`ChangeTextRenderingHintAndTextContrast`方法时处理该窗体<xref:System.Windows.Forms.Control.Paint>事件，并传递`e`作为<xref:System.Windows.Forms.PaintEventArgs>。  
  
 [!code-cpp[System.Drawing.GraphicsProperties#5](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.GraphicsProperties/CPP/form1.cpp#5)]
 [!code-csharp[System.Drawing.GraphicsProperties#5](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.GraphicsProperties/CS/form1.cs#5)]
 [!code-vb[System.Drawing.GraphicsProperties#5](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.GraphicsProperties/VB/form1.vb#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TextRenderingHint">
      <MemberSignature Language="C#" Value="public System.Drawing.Text.TextRenderingHint TextRenderingHint { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Text.TextRenderingHint TextRenderingHint" />
      <MemberSignature Language="DocId" Value="P:System.Drawing.Graphics.TextRenderingHint" />
      <MemberSignature Language="VB.NET" Value="Public Property TextRenderingHint As TextRenderingHint" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::Text::TextRenderingHint TextRenderingHint { System::Drawing::Text::TextRenderingHint get(); void set(System::Drawing::Text::TextRenderingHint value); };" />
      <MemberSignature Language="F#" Value="member this.TextRenderingHint : System.Drawing.Text.TextRenderingHint with get, set" Usage="System.Drawing.Graphics.TextRenderingHint" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Text.TextRenderingHint</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置与此 <see cref="T:System.Drawing.Graphics" /> 关联的文本的呈现模式。</summary>
        <value>
          <see cref="T:System.Drawing.Text.TextRenderingHint" /> 值之一。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 文本呈现提示指定是否使用抗锯齿功能呈现文本。  
  
> [!NOTE]
>  不应使用<xref:System.Drawing.Graphics.CompositingMode%2A>属性值为<xref:System.Drawing.Drawing2D.CompositingMode.SourceCopy>时<xref:System.Drawing.Graphics.TextRenderingHint%2A>属性设置为<xref:System.Drawing.Text.TextRenderingHint.ClearTypeGridFit>。 可能会发生异常或图像可能无法正确呈现。  
  
   
  
## Examples  
 下面的代码示例演示如何将<xref:System.Drawing.Graphics.TextRenderingHint%2A>和<xref:System.Drawing.Graphics.TextContrast%2A>属性。  
  
 此示例旨在与 Windows 窗体一起使用。 将代码粘贴到窗体并调用`ChangeTextRenderingHintAndTextContrast`方法时处理该窗体<xref:System.Windows.Forms.Control.Paint>事件，并传递`e`作为<xref:System.Windows.Forms.PaintEventArgs>。  
  
 [!code-cpp[System.Drawing.GraphicsProperties#5](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.GraphicsProperties/CPP/form1.cpp#5)]
 [!code-csharp[System.Drawing.GraphicsProperties#5](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.GraphicsProperties/CS/form1.cs#5)]
 [!code-vb[System.Drawing.GraphicsProperties#5](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.GraphicsProperties/VB/form1.vb#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Transform">
      <MemberSignature Language="C#" Value="public System.Drawing.Drawing2D.Matrix Transform { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Drawing.Drawing2D.Matrix Transform" />
      <MemberSignature Language="DocId" Value="P:System.Drawing.Graphics.Transform" />
      <MemberSignature Language="VB.NET" Value="Public Property Transform As Matrix" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::Drawing2D::Matrix ^ Transform { System::Drawing::Drawing2D::Matrix ^ get(); void set(System::Drawing::Drawing2D::Matrix ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Transform : System.Drawing.Drawing2D.Matrix with get, set" Usage="System.Drawing.Graphics.Transform" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Drawing2D.Matrix</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置此 <see cref="T:System.Drawing.Graphics" /> 的几何世界转换的副本。</summary>
        <value>一个 <see cref="T:System.Drawing.Drawing2D.Matrix" /> 副本，表示此 <see cref="T:System.Drawing.Graphics" /> 的几何世界转换。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 GDI + 使用三个坐标空间： 世界、 页和设备。 用于建模对特定图形世界坐标世界坐标，将传递给.NET Framework 中的方法的坐标。 页坐标是指由绘图图面，如窗体或控件使用的坐标系统。 设备坐标是由进行绘制，如屏幕或打印机的物理设备的坐标。 <xref:System.Drawing.Graphics.Transform%2A>属性表示的世界转换，将世界坐标映射到页坐标。  
  
 因为返回的矩阵和通过<xref:System.Drawing.Graphics.Transform%2A>属性是几何转换的副本，所以不再需要时应释放的矩阵。  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/c61ff50a-eb1d-4e6c-83cd-f7e9764cfa9f">坐标系类型</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="TransformPoints">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>使用此 <see cref="T:System.Drawing.Graphics" /> 的当前世界转换和页转换，将点数组从一个坐标空间转换到另一个坐标空间。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TransformPoints">
      <MemberSignature Language="C#" Value="public void TransformPoints (System.Drawing.Drawing2D.CoordinateSpace destSpace, System.Drawing.Drawing2D.CoordinateSpace srcSpace, System.Drawing.Point[] pts);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void TransformPoints(valuetype System.Drawing.Drawing2D.CoordinateSpace destSpace, valuetype System.Drawing.Drawing2D.CoordinateSpace srcSpace, valuetype System.Drawing.Point[] pts) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.TransformPoints(System.Drawing.Drawing2D.CoordinateSpace,System.Drawing.Drawing2D.CoordinateSpace,System.Drawing.Point[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub TransformPoints (destSpace As CoordinateSpace, srcSpace As CoordinateSpace, pts As Point())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void TransformPoints(System::Drawing::Drawing2D::CoordinateSpace destSpace, System::Drawing::Drawing2D::CoordinateSpace srcSpace, cli::array &lt;System::Drawing::Point&gt; ^ pts);" />
      <MemberSignature Language="F#" Value="member this.TransformPoints : System.Drawing.Drawing2D.CoordinateSpace * System.Drawing.Drawing2D.CoordinateSpace * System.Drawing.Point[] -&gt; unit" Usage="graphics.TransformPoints (destSpace, srcSpace, pts)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destSpace" Type="System.Drawing.Drawing2D.CoordinateSpace" />
        <Parameter Name="srcSpace" Type="System.Drawing.Drawing2D.CoordinateSpace" />
        <Parameter Name="pts" Type="System.Drawing.Point[]" />
      </Parameters>
      <Docs>
        <param name="destSpace">
          <see cref="T:System.Drawing.Drawing2D.CoordinateSpace" /> 枚举成员，它指定目标坐标空间。</param>
        <param name="srcSpace">
          <see cref="T:System.Drawing.Drawing2D.CoordinateSpace" /> 枚举成员，它指定源坐标空间。</param>
        <param name="pts">
          <see cref="T:System.Drawing.Point" /> 结构数组，这些结构表示要转换的点。</param>
        <summary>使用此 <see cref="T:System.Drawing.Graphics" /> 的当前世界转换和页转换，将点数组从一个坐标空间转换到另一个坐标空间。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下面的代码示例设计为使用 Windows 窗体，并且它需要<xref:System.Windows.Forms.PaintEventArgs> `e`，这是一个参数的<xref:System.Windows.Forms.Control.Paint>事件处理程序。 该代码执行下列操作：  
  
-   创建两个点，它们之间绘制一条蓝线。  
  
-   设置要转换的量 40 沿 x 方向和 30 沿 y 方向的世界转换。  
  
-   转换从世界坐标点 (<xref:System.Drawing.Drawing2D.CoordinateSpace.World>) 为页面坐标 (<xref:System.Drawing.Drawing2D.CoordinateSpace.Page>)。  
  
-   将世界转换重置为标识。  
  
-   已转换的点之间绘制一条红线。  
  
 结果是一条蓝线和下方它已翻译的红色行。  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples3#163](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CPP/form1.cpp#163)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples3#163](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CS/form1.cs#163)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples3#163](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/VB/form1.vb#163)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TransformPoints">
      <MemberSignature Language="C#" Value="public void TransformPoints (System.Drawing.Drawing2D.CoordinateSpace destSpace, System.Drawing.Drawing2D.CoordinateSpace srcSpace, System.Drawing.PointF[] pts);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void TransformPoints(valuetype System.Drawing.Drawing2D.CoordinateSpace destSpace, valuetype System.Drawing.Drawing2D.CoordinateSpace srcSpace, valuetype System.Drawing.PointF[] pts) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.TransformPoints(System.Drawing.Drawing2D.CoordinateSpace,System.Drawing.Drawing2D.CoordinateSpace,System.Drawing.PointF[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub TransformPoints (destSpace As CoordinateSpace, srcSpace As CoordinateSpace, pts As PointF())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void TransformPoints(System::Drawing::Drawing2D::CoordinateSpace destSpace, System::Drawing::Drawing2D::CoordinateSpace srcSpace, cli::array &lt;System::Drawing::PointF&gt; ^ pts);" />
      <MemberSignature Language="F#" Value="member this.TransformPoints : System.Drawing.Drawing2D.CoordinateSpace * System.Drawing.Drawing2D.CoordinateSpace * System.Drawing.PointF[] -&gt; unit" Usage="graphics.TransformPoints (destSpace, srcSpace, pts)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destSpace" Type="System.Drawing.Drawing2D.CoordinateSpace" />
        <Parameter Name="srcSpace" Type="System.Drawing.Drawing2D.CoordinateSpace" />
        <Parameter Name="pts" Type="System.Drawing.PointF[]" />
      </Parameters>
      <Docs>
        <param name="destSpace">
          <see cref="T:System.Drawing.Drawing2D.CoordinateSpace" /> 枚举成员，它指定目标坐标空间。</param>
        <param name="srcSpace">
          <see cref="T:System.Drawing.Drawing2D.CoordinateSpace" /> 枚举成员，它指定源坐标空间。</param>
        <param name="pts">
          <see cref="T:System.Drawing.PointF" /> 结构数组，这些结构表示要转换的点。</param>
        <summary>使用此 <see cref="T:System.Drawing.Graphics" /> 的当前世界转换和页转换，将点数组从一个坐标空间转换到另一个坐标空间。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下面的代码示例设计为使用 Windows 窗体，并且它需要<xref:System.Windows.Forms.PaintEventArgs> `e`，这是一个参数的<xref:System.Windows.Forms.Control.Paint>事件处理程序。 该代码执行下列操作：  
  
-   创建两个点，它们之间绘制一条蓝线。  
  
-   设置要转换的量 40 沿 x 方向和 30 沿 y 方向的世界转换。  
  
-   转换从世界坐标点 (<xref:System.Drawing.Drawing2D.CoordinateSpace.World>) 为页面坐标 (<xref:System.Drawing.Drawing2D.CoordinateSpace.Page>)。  
  
-   将世界转换重置为标识和已转换的点之间绘制一条红线。  
  
 结果是一条蓝线和下方它已翻译的红色行。  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples3#164](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CPP/form1.cpp#164)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples3#164](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CS/form1.cs#164)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples3#164](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/VB/form1.vb#164)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="TranslateClip">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>将此 <see cref="T:System.Drawing.Graphics" /> 的剪辑区域沿水平方向和垂直方向平移指定的量。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TranslateClip">
      <MemberSignature Language="C#" Value="public void TranslateClip (int dx, int dy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void TranslateClip(int32 dx, int32 dy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.TranslateClip(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub TranslateClip (dx As Integer, dy As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void TranslateClip(int dx, int dy);" />
      <MemberSignature Language="F#" Value="member this.TranslateClip : int * int -&gt; unit" Usage="graphics.TranslateClip (dx, dy)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dx" Type="System.Int32" />
        <Parameter Name="dy" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="dx">平移的 x 坐标。</param>
        <param name="dy">平移的 y 坐标。</param>
        <summary>将此 <see cref="T:System.Drawing.Graphics" /> 的剪辑区域沿水平方向和垂直方向平移指定的量。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下面的代码示例设计为使用 Windows 窗体，并且它需要<xref:System.Windows.Forms.PaintEventArgs> `e`，这是一个参数的<xref:System.Windows.Forms.Control.Paint>事件处理程序。 该代码执行下列操作：  
  
-   创建的剪辑区域的矩形。  
  
-   向该矩形的剪辑区域设置。  
  
-   平移矢量 （50，50） 的剪辑区域。  
  
-   使用纯黑色画笔填充一个大的矩形。  
  
 结果是一个已翻译、 小、 黑色的矩形。  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples3#165](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CPP/form1.cpp#165)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples3#165](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CS/form1.cs#165)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples3#165](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/VB/form1.vb#165)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TranslateClip">
      <MemberSignature Language="C#" Value="public void TranslateClip (float dx, float dy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void TranslateClip(float32 dx, float32 dy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.TranslateClip(System.Single,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Sub TranslateClip (dx As Single, dy As Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void TranslateClip(float dx, float dy);" />
      <MemberSignature Language="F#" Value="member this.TranslateClip : single * single -&gt; unit" Usage="graphics.TranslateClip (dx, dy)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dx" Type="System.Single" />
        <Parameter Name="dy" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="dx">平移的 x 坐标。</param>
        <param name="dy">平移的 y 坐标。</param>
        <summary>将此 <see cref="T:System.Drawing.Graphics" /> 的剪辑区域沿水平方向和垂直方向平移指定的量。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下面的代码示例设计为使用 Windows 窗体，并且它需要<xref:System.Windows.Forms.PaintEventArgs> `e`，这是一个参数的<xref:System.Windows.Forms.Control.Paint>事件处理程序。 该代码执行下列操作：  
  
-   创建的剪辑区域的矩形。  
  
-   向该矩形的剪辑区域设置。  
  
-   平移矢量 （50.0 f，50.0 f） 的剪辑区域。  
  
-   使用纯黑色画笔填充一个大的矩形。  
  
 结果是一个已翻译、 小、 黑色的矩形。  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples3#166](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CPP/form1.cpp#166)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples3#166](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CS/form1.cs#166)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples3#166](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/VB/form1.vb#166)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="TranslateTransform">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>通过使此 <see cref="T:System.Drawing.Graphics" /> 的转换矩阵左乘指定的平移来更改坐标系统的原点。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TranslateTransform">
      <MemberSignature Language="C#" Value="public void TranslateTransform (float dx, float dy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void TranslateTransform(float32 dx, float32 dy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.TranslateTransform(System.Single,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Sub TranslateTransform (dx As Single, dy As Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void TranslateTransform(float dx, float dy);" />
      <MemberSignature Language="F#" Value="member this.TranslateTransform : single * single -&gt; unit" Usage="graphics.TranslateTransform (dx, dy)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dx" Type="System.Single" />
        <Parameter Name="dy" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="dx">平移的 x 坐标。</param>
        <param name="dy">平移的 y 坐标。</param>
        <summary>通过使此 <see cref="T:System.Drawing.Graphics" /> 的转换矩阵左乘指定的平移来更改坐标系统的原点。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 源通常是绘图图面右上左下角。  转换操作包括将通过其翻译部分是的矩阵转换矩阵乘以`dx`和`dy`参数。 此方法通过预先计算转换矩阵变换矩阵应用转换。  
  
   
  
## Examples  
 下面的代码示例设计为使用 Windows 窗体，并且它需要<xref:System.Windows.Forms.PaintEventArgs> `e`，这是一个参数的<xref:System.Windows.Forms.Control.Paint>事件处理程序。 该代码执行下列操作：  
  
-   Windows 窗体的世界转换矩阵旋转 30.0F 度。  
  
-   将图形对象的源移动通过调用<xref:System.Drawing.Graphics.TranslateTransform%2A>，预置到转换矩阵的转换。  
  
-   使用蓝色笔绘制平移、 旋转椭圆。  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples3#167](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CPP/form1.cpp#167)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples3#167](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CS/form1.cs#167)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples3#167](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/VB/form1.vb#167)]  
  
 下图显示运行上一代码示例的输出。  
  
 ![经过翻译和转换后的 ellipse](~/add/media/ndp-tranlatetransform.png "经过翻译和转换后的椭圆")  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/9fef7451-bddf-4c68-9350-400d1f1f25a3">坐标系和坐标转换</related>
        <related type="Article" href="https://msdn.microsoft.com/library/1f8e18d3-d2f5-460e-a8e3-2da891c301de">在托管 GDI+ 中使用转换</related>
      </Docs>
    </Member>
    <Member MemberName="TranslateTransform">
      <MemberSignature Language="C#" Value="public void TranslateTransform (float dx, float dy, System.Drawing.Drawing2D.MatrixOrder order);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void TranslateTransform(float32 dx, float32 dy, valuetype System.Drawing.Drawing2D.MatrixOrder order) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.TranslateTransform(System.Single,System.Single,System.Drawing.Drawing2D.MatrixOrder)" />
      <MemberSignature Language="VB.NET" Value="Public Sub TranslateTransform (dx As Single, dy As Single, order As MatrixOrder)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void TranslateTransform(float dx, float dy, System::Drawing::Drawing2D::MatrixOrder order);" />
      <MemberSignature Language="F#" Value="member this.TranslateTransform : single * single * System.Drawing.Drawing2D.MatrixOrder -&gt; unit" Usage="graphics.TranslateTransform (dx, dy, order)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dx" Type="System.Single" />
        <Parameter Name="dy" Type="System.Single" />
        <Parameter Name="order" Type="System.Drawing.Drawing2D.MatrixOrder" />
      </Parameters>
      <Docs>
        <param name="dx">平移的 x 坐标。</param>
        <param name="dy">平移的 y 坐标。</param>
        <param name="order">
          <see cref="T:System.Drawing.Drawing2D.MatrixOrder" /> 枚举的成员，它指定是将平移添加到转换矩阵前还是追加到转换矩阵后。</param>
        <summary>通过以指定顺序将指定平移应用于此 <see cref="T:System.Drawing.Graphics" /> 的转换矩阵来更改坐标系统的原点。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 转换操作包括将通过其翻译部分是的矩阵转换矩阵乘以`dx`和`dy`参数。 此方法前面添加或追加的转换矩阵<xref:System.Drawing.Graphics>通过根据转换矩阵`order`参数。  
  
   
  
## Examples  
 下面的代码示例设计为使用 Windows 窗体，并且它需要<xref:System.Windows.Forms.PaintEventArgs> `e`，这是一个参数的<xref:System.Windows.Forms.Control.Paint>事件处理程序。 该代码执行下列操作：  
  
-   Windows 窗体的世界转换矩阵旋转 30.0F 度。  
  
-   将图形对象的源移动通过调用<xref:System.Drawing.Graphics.TranslateTransform%2A>，追加到的世界转换矩阵的平移。  
  
-   使用蓝色笔绘制旋转、 平移的椭圆。  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples3#168](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CPP/form1.cpp#168)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples3#168](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CS/form1.cs#168)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples3#168](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/VB/form1.vb#168)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/9fef7451-bddf-4c68-9350-400d1f1f25a3">坐标系和坐标转换</related>
        <related type="Article" href="https://msdn.microsoft.com/library/1f8e18d3-d2f5-460e-a8e3-2da891c301de">在托管 GDI+ 中使用转换</related>
      </Docs>
    </Member>
    <Member MemberName="VisibleClipBounds">
      <MemberSignature Language="C#" Value="public System.Drawing.RectangleF VisibleClipBounds { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.RectangleF VisibleClipBounds" />
      <MemberSignature Language="DocId" Value="P:System.Drawing.Graphics.VisibleClipBounds" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property VisibleClipBounds As RectangleF" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::RectangleF VisibleClipBounds { System::Drawing::RectangleF get(); };" />
      <MemberSignature Language="F#" Value="member this.VisibleClipBounds : System.Drawing.RectangleF" Usage="System.Drawing.Graphics.VisibleClipBounds" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.RectangleF</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取此 <see cref="T:System.Drawing.Graphics" /> 的可见剪辑区域的边框。</summary>
        <value>一个 <see cref="T:System.Drawing.RectangleF" /> 结构，它表示此 <see cref="T:System.Drawing.Graphics" /> 的可见剪辑区域的边框。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 所得矩形的大小的单位由<xref:System.Drawing.Graphics.PageUnit%2A>属性。 默认单位为像素。 一个<xref:System.Drawing.Graphics>通常与控件相关联，该矩形的原点将相对于该控件的客户端区域。  
  
 可见剪辑区域是这样的剪辑区域的交集<xref:System.Drawing.Graphics>和窗口的剪辑区域。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>