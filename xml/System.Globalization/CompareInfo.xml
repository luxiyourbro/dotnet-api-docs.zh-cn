<Type Name="CompareInfo" FullName="System.Globalization.CompareInfo">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="6f5e17729a6d1ad7dd917d80c08e149234819b84" />
    <Meta Name="ms.sourcegitcommit" Value="9e06b87bcfa4347dbbaaa4b3cc36b43b93b5badb" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-CN" />
    <Meta Name="ms.lasthandoff" Value="11/20/2018" />
    <Meta Name="ms.locfileid" Value="52251527" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class CompareInfo : System.Runtime.Serialization.IDeserializationCallback" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit CompareInfo extends System.Object implements class System.Runtime.Serialization.IDeserializationCallback" />
  <TypeSignature Language="DocId" Value="T:System.Globalization.CompareInfo" />
  <TypeSignature Language="VB.NET" Value="Public Class CompareInfo&#xA;Implements IDeserializationCallback" />
  <TypeSignature Language="C++ CLI" Value="public ref class CompareInfo : System::Runtime::Serialization::IDeserializationCallback" />
  <TypeSignature Language="F#" Value="type CompareInfo = class&#xA;    interface IDeserializationCallback" />
  <AssemblyInfo>
    <AssemblyName>System.Globalization</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.IDeserializationCallback</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>实现用于区分区域性的字符串的一组方法。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 用于比较和排序数据的约定因区域性而异。 例如，排序顺序可能基于拼音或基于字符的可视表示形式。 在东亚语言中，按文字的笔画和部首对字符进行排序。 排序也取决于字母表使用的排序语言和区域性。 例如，丹麦语中有“Æ”字符，它在字母表中排在“Z”之后。 此外，比较可以区分大小写或不区分大小写，并且大小写规则也可能因区域性而异。 <xref:System.Globalization.CompareInfo> 类负责维护此区分区域性的字符串比较数据并执行区分区域性的字符串运算。  
  
 通常，您不必直接实例化 <xref:System.Globalization.CompareInfo> 对象，因为所有非序号字符串比较运算会隐式使用一个此对象，包括对 <xref:System.String.Compare%2A?displayProperty=nameWithType> 方法的调用。 但是，若要检索 <xref:System.Globalization.CompareInfo> 对象，您可通过下列方法之一执行此操作：  
  
-   通过检索特定区域性的 <xref:System.Globalization.CultureInfo.CompareInfo%2A?displayProperty=nameWithType> 属性的值。  
  
-   通过使用区域性名称调用静态 <xref:System.Globalization.CompareInfo.GetCompareInfo%2A> 方法。 这允许对 <xref:System.Globalization.CompareInfo> 对象进行后期绑定访问。  
  
## <a name="ignored-search-values"></a>已忽略的搜索值  
 字符集包括可忽略字符，在执行语言性的或区分区域性的比较时该字符不被考虑。 当比较方法（如 <xref:System.Globalization.CompareInfo.IndexOf%2A> 和 <xref:System.Globalization.CompareInfo.LastIndexOf%2A>）执行区分区域性的比较时，它们不会考虑此类字符。 可忽略的字符包括：  
  
-   <xref:System.String.Empty?displayProperty=nameWithType>。 区分区域性的比较方法将始终在要搜索的字符串的开头（索引为零）查找空字符串。  
  
-   字符或由多个字符和运算中未考虑的码位（因为比较选项）构成的字符串，具体而言，<xref:System.Globalization.CompareOptions.IgnoreNonSpace?displayProperty=nameWithType> 和 <xref:System.Globalization.CompareOptions.IgnoreSymbols?displayProperty=nameWithType> 选项生成忽略符号和非间距组合字符的搜索。  
  
-   带没有语义的码位的字符串。 例如，始终在区分区域性的字符串比较中忽略软连字符 (U+00AD)。  
  
## <a name="security-considerations"></a>安全注意事项  
 如果安全决策取决于字符串比较或大小写更改，则您应使用 <xref:System.Globalization.CultureInfo.InvariantCulture%2A> 属性来确保行为一致，无论操作系统的区域性设置如何。  
  
> [!NOTE]
>  如果可能，应使用具有的类型参数的字符串比较方法<xref:System.Globalization.CompareOptions>指定的预期的比较类型。 作为一般规则，用来进行比较用户界面中显示的字符串 （使用当前区域性） 的语言选项并指定<xref:System.Globalization.CompareOptions.Ordinal>或<xref:System.Globalization.CompareOptions.OrdinalIgnoreCase>安全比较。  
  
   
  
## Examples  
 下面的示例演示如何<xref:System.Globalization.CompareInfo>对象与关联<xref:System.Globalization.CultureInfo>对象会影响字符串比较。  
  
 [!code-cpp[CompareInfo#1](~/samples/snippets/cpp/VS_Snippets_CLR/CompareInfo/cpp/CompareInfo.cpp#1)]
 [!code-csharp[CompareInfo#1](~/samples/snippets/csharp/VS_Snippets_CLR/CompareInfo/CS/CompareInfo.cs#1)]
 [!code-vb[CompareInfo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/CompareInfo/VB/CompareInfo.vb#1)]  

 ]]></format>
    </remarks>
    <related type="ExternalDocumentation" href="https://www.microsoft.com/en-us/download/details.aspx?id=10921">排序权重表为 Windows 操作系统</related>
    <related type="ExternalDocumentation" href="https://www.unicode.org/Public/UCA/latest/allkeys.txt">默认 Unicode 排序规则 Elemeent 表，适用于 Linux 和 macOS</related>
  </Docs>
  <Members>
    <MemberGroup MemberName="Compare">
      <AssemblyInfo>
        <AssemblyName>System.Globalization</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>比较两个字符串。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public virtual int Compare (string string1, string string2);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 Compare(string string1, string string2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Globalization.CompareInfo.Compare(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Compare (string1 As String, string2 As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int Compare(System::String ^ string1, System::String ^ string2);" />
      <MemberSignature Language="F#" Value="abstract member Compare : string * string -&gt; int&#xA;override this.Compare : string * string -&gt; int" Usage="compareInfo.Compare (string1, string2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Globalization</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="string1" Type="System.String" />
        <Parameter Name="string2" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="string1">要比较的第一个字符串。</param>
        <param name="string2">要比较的第二个字符串。</param>
        <summary>比较两个字符串。</summary>
        <returns>一个 32 位有符号整数，指示两个比较数之间的词法关系。  
  
 <list type="table"><listheader><term> “值” 
 </term><description> 条件 
 </description></listheader><item><term> 零 
 </term><description> 这两个字符串相等。  
  
 </description></item><item><term> 小于零 
 </term><description><paramref name="string1" /> 小于 <paramref name="string2" />。  
  
 </description></item><item><term> 大于零 
 </term><description><paramref name="string1" /> 大于 <paramref name="string2" />。  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 默认情况下，通过使用执行比较<xref:System.Globalization.CompareOptions.None?displayProperty=nameWithType>。 如果安全决策取决于字符串比较或大小写更改，则应使用<xref:System.Globalization.CultureInfo.InvariantCulture%2A>属性以确保行为一致而不考虑操作系统的区域性设置。  
  
> [!NOTE]
>  如果可能，应调用字符串比较方法具有的类型参数的<xref:System.Globalization.CompareOptions>指定的预期的比较类型。 作为一般规则，用来进行比较用户界面中显示的字符串 （使用当前区域性） 的语言选项并指定<xref:System.Globalization.CompareOptions.Ordinal>或<xref:System.Globalization.CompareOptions.OrdinalIgnoreCase>安全比较。  
  
   
  
## Examples  
 下面的示例比较两个字符串使用不同的部分<xref:System.Globalization.CompareInfo>对象：  
  
-   <xref:System.Globalization.CompareInfo> 与使用国际排序的西班牙语 （西班牙） 区域性关联的对象  
  
-   <xref:System.Globalization.CompareInfo> 与使用传统排序的西班牙语 （西班牙） 区域性关联的对象  
  
-   <xref:System.Globalization.CompareInfo> 与关联的对象 <xref:System.Globalization.CultureInfo.InvariantCulture%2A>  
  
 [!code-cpp[System.Globalization.CompareInfo.CompareStrStr#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Globalization.CompareInfo.CompareStrStr/CPP/comparestrstr.cpp#1)]
 [!code-csharp[System.Globalization.CompareInfo.CompareStrStr#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Globalization.CompareInfo.CompareStrStr/CS/comparestrstr.cs#1)]
 [!code-vb[System.Globalization.CompareInfo.CompareStrStr#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Globalization.CompareInfo.CompareStrStr/VB/comparestrstr.vb#1)]  
  
 下面的示例演示如何调用 <xref:System.Globalization.CompareInfo.Compare%2A> 方法。  
  
 [!code-cpp[CompareInfo#1](~/samples/snippets/cpp/VS_Snippets_CLR/CompareInfo/cpp/CompareInfo.cpp#1)]
 [!code-csharp[CompareInfo#1](~/samples/snippets/csharp/VS_Snippets_CLR/CompareInfo/CS/CompareInfo.cs#1)]
 [!code-vb[CompareInfo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/CompareInfo/VB/CompareInfo.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>字符集包括可忽略字符，在执行语言性的或区分区域性的比较时该字符不被考虑。 <see cref="M:System.Globalization.CompareInfo.Compare(System.String,System.String)" />方法执行区分区域性的比较时不考虑此类字符。 例如，"动物"与"ani 邮件"（使用软连字符或 U + 00AD） 的区分区域性的比较指示两个字符串是等效的如以下示例所示。  
  
[！ 代码 vb[System.Globalization.CompareInfo.Compare#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.globalization.compareinfo.compare/vb/compare1.vb#1)] 
若要识别的字符串比较中的可忽略字符，调用<see cref="M:System.Globalization.CompareInfo.Compare(System.String,System.String,System.Globalization.CompareOptions)" />方法并提供的值<see cref="F:System.Globalization.CompareOptions.Ordinal" />或<see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" />为<paramref name="options" />参数。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public virtual int Compare (string string1, string string2, System.Globalization.CompareOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 Compare(string string1, string string2, valuetype System.Globalization.CompareOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Globalization.CompareInfo.Compare(System.String,System.String,System.Globalization.CompareOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Compare (string1 As String, string2 As String, options As CompareOptions) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int Compare(System::String ^ string1, System::String ^ string2, System::Globalization::CompareOptions options);" />
      <MemberSignature Language="F#" Value="abstract member Compare : string * string * System.Globalization.CompareOptions -&gt; int&#xA;override this.Compare : string * string * System.Globalization.CompareOptions -&gt; int" Usage="compareInfo.Compare (string1, string2, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Globalization</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="string1" Type="System.String" />
        <Parameter Name="string2" Type="System.String" />
        <Parameter Name="options" Type="System.Globalization.CompareOptions" />
      </Parameters>
      <Docs>
        <param name="string1">要比较的第一个字符串。</param>
        <param name="string2">要比较的第二个字符串。</param>
        <param name="options">一个值，用于定义应如何比较 <paramref name="string1" /> 和 <paramref name="string2" />。 <paramref name="options" /> 可以为枚举值 <see cref="F:System.Globalization.CompareOptions.Ordinal" />，或为以下一个或多个值的按位组合：<see cref="F:System.Globalization.CompareOptions.IgnoreCase" />、<see cref="F:System.Globalization.CompareOptions.IgnoreSymbols" />、<see cref="F:System.Globalization.CompareOptions.IgnoreNonSpace" />、<see cref="F:System.Globalization.CompareOptions.IgnoreWidth" />、<see cref="F:System.Globalization.CompareOptions.IgnoreKanaType" /> 和 <see cref="F:System.Globalization.CompareOptions.StringSort" />。</param>
        <summary>使用指定的 <see cref="T:System.Globalization.CompareOptions" /> 值比较两个字符串。</summary>
        <returns>一个 32 位有符号整数，指示两个比较数之间的词法关系。  
  
 <list type="table"><listheader><term> “值” 
 </term><description> 条件 
 </description></listheader><item><term> 零 
 </term><description> 这两个字符串相等。  
  
 </description></item><item><term> 小于零 
 </term><description><paramref name="string1" /> 小于 <paramref name="string2" />。  
  
 </description></item><item><term> 大于零 
 </term><description><paramref name="string1" /> 大于 <paramref name="string2" />。  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果安全决策取决于字符串比较或大小写更改，则应使用<xref:System.Globalization.CultureInfo.InvariantCulture%2A>属性以确保行为一致而不考虑操作系统的区域性设置。  
  
> [!NOTE]
>  如果可能，应调用字符串比较方法具有的类型参数的<xref:System.Globalization.CompareOptions>指定的预期的比较类型。 作为一般规则，用来进行比较用户界面中显示的字符串 （使用当前区域性） 的语言选项并指定<xref:System.Globalization.CompareOptions.Ordinal>或<xref:System.Globalization.CompareOptions.OrdinalIgnoreCase>安全比较。  
  
   
  
## Examples  
 下面的示例比较使用不同的两个字符串<xref:System.Globalization.CompareOptions>设置。  
  
 [!code-cpp[System.Globalization.CompareInfo.CompareStrStrOpt#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Globalization.CompareInfo.CompareStrStrOpt/CPP/comparestrstropt.cpp#1)]
 [!code-csharp[System.Globalization.CompareInfo.CompareStrStrOpt#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Globalization.CompareInfo.CompareStrStrOpt/CS/comparestrstropt.cs#1)]
 [!code-vb[System.Globalization.CompareInfo.CompareStrStrOpt#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Globalization.CompareInfo.CompareStrStrOpt/VB/comparestrstropt.vb#1)]  
  
 下面的示例演示如何调用 <xref:System.Globalization.CompareInfo.Compare%2A> 方法。  
  
 [!code-cpp[CompareInfo#1](~/samples/snippets/cpp/VS_Snippets_CLR/CompareInfo/cpp/CompareInfo.cpp#1)]
 [!code-csharp[CompareInfo#1](~/samples/snippets/csharp/VS_Snippets_CLR/CompareInfo/CS/CompareInfo.cs#1)]
 [!code-vb[CompareInfo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/CompareInfo/VB/CompareInfo.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="options" /> 包含无效的 <see cref="T:System.Globalization.CompareOptions" /> 值。</exception>
        <block subset="none" type="usage">
          <para>字符集包括可忽略字符，在执行语言性的或区分区域性的比较时该字符不被考虑。 <see cref="M:System.Globalization.CompareInfo.Compare(System.String,System.String,System.Globalization.CompareOptions)" />方法执行区分区域性的比较时不考虑此类字符。 若要识别您的比较中的可忽略字符，提供的值<see cref="F:System.Globalization.CompareOptions.Ordinal" />或<see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" />为<paramref name="options" />参数。</para>
        </block>
        <altmember cref="T:System.Globalization.CompareOptions" />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public virtual int Compare (string string1, int offset1, string string2, int offset2);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 Compare(string string1, int32 offset1, string string2, int32 offset2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Globalization.CompareInfo.Compare(System.String,System.Int32,System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Compare (string1 As String, offset1 As Integer, string2 As String, offset2 As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int Compare(System::String ^ string1, int offset1, System::String ^ string2, int offset2);" />
      <MemberSignature Language="F#" Value="abstract member Compare : string * int * string * int -&gt; int&#xA;override this.Compare : string * int * string * int -&gt; int" Usage="compareInfo.Compare (string1, offset1, string2, offset2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Globalization</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="string1" Type="System.String" />
        <Parameter Name="offset1" Type="System.Int32" />
        <Parameter Name="string2" Type="System.String" />
        <Parameter Name="offset2" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="string1">要比较的第一个字符串。</param>
        <param name="offset1">
          <paramref name="string1" /> 中的字符从零开始的索引，将从此位置开始比较。</param>
        <param name="string2">要比较的第二个字符串。</param>
        <param name="offset2">
          <paramref name="string2" /> 中的字符从零开始的索引，将从此位置开始比较。</param>
        <summary>将一个字符串的结尾部分与另一个字符串的结尾部分相比较。</summary>
        <returns>一个 32 位有符号整数，指示两个比较数之间的词法关系。  
  
 <list type="table"><listheader><term> “值” 
 </term><description> 条件 
 </description></listheader><item><term> 零 
 </term><description> 这两个字符串相等。  
  
 </description></item><item><term> 小于零 
 </term><description><paramref name="string1" /> 的指定部分小于 <paramref name="string2" /> 的指定部分。  
  
 </description></item><item><term> 大于零 
 </term><description><paramref name="string1" /> 的指定部分大于 <paramref name="string2" /> 的指定部分。  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果安全决策取决于字符串比较或大小写更改，则应使用<xref:System.Globalization.CultureInfo.InvariantCulture%2A>属性以确保行为一致而不考虑操作系统的区域性设置。  
  
> [!NOTE]
>  如果可能，应调用字符串比较方法具有的类型参数的<xref:System.Globalization.CompareOptions>指定的预期的比较类型。 作为一般规则，用来进行比较用户界面中显示的字符串 （使用当前区域性） 的语言选项并指定<xref:System.Globalization.CompareOptions.Ordinal>或<xref:System.Globalization.CompareOptions.OrdinalIgnoreCase>安全比较。  
  
   
  
## Examples  
 下面的示例比较两个字符串使用不同的部分<xref:System.Globalization.CompareInfo>对象：  
  
-   <xref:System.Globalization.CompareInfo> 与使用国际排序的西班牙语 （西班牙） 区域性关联的对象  
  
-   <xref:System.Globalization.CompareInfo> 与使用传统排序的西班牙语 （西班牙） 区域性关联的对象  
  
-   <xref:System.Globalization.CompareInfo> 与关联的对象 <xref:System.Globalization.CultureInfo.InvariantCulture%2A>  
  
 [!code-cpp[System.Globalization.CompareInfo.CompareStrIntStrInt#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Globalization.CompareInfo.CompareStrIntStrInt/CPP/comparestrintstrint.cpp#1)]
 [!code-csharp[System.Globalization.CompareInfo.CompareStrIntStrInt#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Globalization.CompareInfo.CompareStrIntStrInt/CS/comparestrintstrint.cs#1)]
 [!code-vb[System.Globalization.CompareInfo.CompareStrIntStrInt#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Globalization.CompareInfo.CompareStrIntStrInt/VB/comparestrintstrint.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="offset1" /> 或 <paramref name="offset2" /> 小于零。  
  
或 
 <paramref name="offset1" /> 大于或等于 <paramref name="string1" /> 中的字符数。  
  
或 
 <paramref name="offset2" /> 大于或等于 <paramref name="string2" /> 中的字符数。</exception>
        <block subset="none" type="usage">
          <para>字符集包括可忽略字符。 <see cref="M:System.Globalization.CompareInfo.Compare(System.String,System.Int32,System.String,System.Int32)" />方法执行语言性的或区分区域性的比较时不考虑这些字符。 若要识别您的比较中的可忽略字符，调用<see cref="M:System.Globalization.CompareInfo.Compare(System.String,System.Int32,System.String,System.Int32,System.Globalization.CompareOptions)" />方法并提供的值<see cref="F:System.Globalization.CompareOptions.Ordinal" />或<see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" />为<paramref name="options" />参数。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public virtual int Compare (string string1, int offset1, string string2, int offset2, System.Globalization.CompareOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 Compare(string string1, int32 offset1, string string2, int32 offset2, valuetype System.Globalization.CompareOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Globalization.CompareInfo.Compare(System.String,System.Int32,System.String,System.Int32,System.Globalization.CompareOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Compare (string1 As String, offset1 As Integer, string2 As String, offset2 As Integer, options As CompareOptions) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int Compare(System::String ^ string1, int offset1, System::String ^ string2, int offset2, System::Globalization::CompareOptions options);" />
      <MemberSignature Language="F#" Value="abstract member Compare : string * int * string * int * System.Globalization.CompareOptions -&gt; int&#xA;override this.Compare : string * int * string * int * System.Globalization.CompareOptions -&gt; int" Usage="compareInfo.Compare (string1, offset1, string2, offset2, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Globalization</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="string1" Type="System.String" />
        <Parameter Name="offset1" Type="System.Int32" />
        <Parameter Name="string2" Type="System.String" />
        <Parameter Name="offset2" Type="System.Int32" />
        <Parameter Name="options" Type="System.Globalization.CompareOptions" />
      </Parameters>
      <Docs>
        <param name="string1">要比较的第一个字符串。</param>
        <param name="offset1">
          <paramref name="string1" /> 中的字符从零开始的索引，将从此位置开始比较。</param>
        <param name="string2">要比较的第二个字符串。</param>
        <param name="offset2">
          <paramref name="string2" /> 中的字符从零开始的索引，将从此位置开始比较。</param>
        <param name="options">一个值，用于定义应如何比较 <paramref name="string1" /> 和 <paramref name="string2" />。 <paramref name="options" /> 可以为枚举值 <see cref="F:System.Globalization.CompareOptions.Ordinal" />，或为以下一个或多个值的按位组合：<see cref="F:System.Globalization.CompareOptions.IgnoreCase" />、<see cref="F:System.Globalization.CompareOptions.IgnoreSymbols" />、<see cref="F:System.Globalization.CompareOptions.IgnoreNonSpace" />、<see cref="F:System.Globalization.CompareOptions.IgnoreWidth" />、<see cref="F:System.Globalization.CompareOptions.IgnoreKanaType" /> 和 <see cref="F:System.Globalization.CompareOptions.StringSort" />。</param>
        <summary>使用指定的 <see cref="T:System.Globalization.CompareOptions" /> 值将一个字符串的结尾部分与另一个字符串的结尾部分相比较。</summary>
        <returns>一个 32 位有符号整数，指示两个比较数之间的词法关系。  
  
 <list type="table"><listheader><term> “值” 
 </term><description> 条件 
 </description></listheader><item><term> 零 
 </term><description> 这两个字符串相等。  
  
 </description></item><item><term> 小于零 
 </term><description><paramref name="string1" /> 的指定部分小于 <paramref name="string2" /> 的指定部分。  
  
 </description></item><item><term> 大于零 
 </term><description><paramref name="string1" /> 的指定部分大于 <paramref name="string2" /> 的指定部分。  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果安全决策取决于字符串比较或大小写更改，则应使用<xref:System.Globalization.CultureInfo.InvariantCulture%2A>属性以确保行为一致而不考虑操作系统的区域性设置。  
  
> [!NOTE]
>  如果可能，应调用字符串比较方法具有的类型参数的<xref:System.Globalization.CompareOptions>指定的预期的比较类型。 作为一般规则，用来进行比较用户界面中显示的字符串 （使用当前区域性） 的语言选项并指定<xref:System.Globalization.CompareOptions.Ordinal>或<xref:System.Globalization.CompareOptions.OrdinalIgnoreCase>安全比较。  
  
   
  
## Examples  
 下面的示例比较两个字符串使用不同的部分<xref:System.Globalization.CompareOptions>设置。  
  
 [!code-cpp[System.Globalization.CompareInfo.CompareStrIntStrIntOpt#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Globalization.CompareInfo.CompareStrIntStrIntOpt/CPP/comparestrintstrintopt.cpp#1)]
 [!code-csharp[System.Globalization.CompareInfo.CompareStrIntStrIntOpt#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Globalization.CompareInfo.CompareStrIntStrIntOpt/CS/comparestrintstrintopt.cs#1)]
 [!code-vb[System.Globalization.CompareInfo.CompareStrIntStrIntOpt#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Globalization.CompareInfo.CompareStrIntStrIntOpt/VB/comparestrintstrintopt.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="offset1" /> 或 <paramref name="offset2" /> 小于零。  
  
或 
 <paramref name="offset1" /> 大于或等于 <paramref name="string1" /> 中的字符数。  
  
或 
 <paramref name="offset2" /> 大于或等于 <paramref name="string2" /> 中的字符数。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="options" /> 包含无效的 <see cref="T:System.Globalization.CompareOptions" /> 值。</exception>
        <block subset="none" type="usage">
          <para>字符集包括可忽略字符，在执行语言性的或区分区域性的比较时该字符不被考虑。 <see cref="M:System.Globalization.CompareInfo.Compare(System.String,System.Int32,System.String,System.Int32,System.Globalization.CompareOptions)" />方法执行区分区域性的比较时不考虑此类字符。 若要识别您的比较中的可忽略字符，提供的值<see cref="F:System.Globalization.CompareOptions.Ordinal" />或<see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" />为<paramref name="options" />参数。</para>
        </block>
        <altmember cref="T:System.Globalization.CompareOptions" />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public virtual int Compare (string string1, int offset1, int length1, string string2, int offset2, int length2);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 Compare(string string1, int32 offset1, int32 length1, string string2, int32 offset2, int32 length2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Globalization.CompareInfo.Compare(System.String,System.Int32,System.Int32,System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Compare (string1 As String, offset1 As Integer, length1 As Integer, string2 As String, offset2 As Integer, length2 As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int Compare(System::String ^ string1, int offset1, int length1, System::String ^ string2, int offset2, int length2);" />
      <MemberSignature Language="F#" Value="abstract member Compare : string * int * int * string * int * int -&gt; int&#xA;override this.Compare : string * int * int * string * int * int -&gt; int" Usage="compareInfo.Compare (string1, offset1, length1, string2, offset2, length2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Globalization</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="string1" Type="System.String" />
        <Parameter Name="offset1" Type="System.Int32" />
        <Parameter Name="length1" Type="System.Int32" />
        <Parameter Name="string2" Type="System.String" />
        <Parameter Name="offset2" Type="System.Int32" />
        <Parameter Name="length2" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="string1">要比较的第一个字符串。</param>
        <param name="offset1">
          <paramref name="string1" /> 中的字符从零开始的索引，将从此位置开始比较。</param>
        <param name="length1">
          <paramref name="string1" /> 中要比较的连续字符数。</param>
        <param name="string2">要比较的第二个字符串。</param>
        <param name="offset2">
          <paramref name="string2" /> 中的字符从零开始的索引，将从此位置开始比较。</param>
        <param name="length2">
          <paramref name="string2" /> 中要比较的连续字符数。</param>
        <summary>将一个字符串的一部分与另一个字符串的一部分相比较。</summary>
        <returns>一个 32 位有符号整数，指示两个比较数之间的词法关系。  
  
 <list type="table"><listheader><term> “值” 
 </term><description> 条件 
 </description></listheader><item><term> 零 
 </term><description> 这两个字符串相等。  
  
 </description></item><item><term> 小于零 
 </term><description><paramref name="string1" /> 的指定部分小于 <paramref name="string2" /> 的指定部分。  
  
 </description></item><item><term> 大于零 
 </term><description><paramref name="string1" /> 的指定部分大于 <paramref name="string2" /> 的指定部分。  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果安全决策取决于字符串比较或大小写更改，则应使用<xref:System.Globalization.CultureInfo.InvariantCulture%2A>属性以确保行为一致而不考虑操作系统的区域性设置。  
  
> [!NOTE]
>  如果可能，应使用具有的类型参数的字符串比较方法<xref:System.Globalization.CompareOptions>指定的预期的比较类型。 作为一般规则，用来进行比较用户界面中显示的字符串 （使用当前区域性） 的语言选项并指定<xref:System.Globalization.CompareOptions.Ordinal>或<xref:System.Globalization.CompareOptions.OrdinalIgnoreCase>安全比较。  
  
   
  
## Examples  
 下面的示例比较两个字符串使用不同的部分<xref:System.Globalization.CompareInfo>对象：  
  
-   <xref:System.Globalization.CompareInfo> 与使用国际排序的西班牙语 （西班牙） 区域性关联的对象  
  
-   <xref:System.Globalization.CompareInfo> 与使用传统排序的西班牙语 （西班牙） 区域性关联的对象  
  
-   <xref:System.Globalization.CompareInfo> 与关联的对象 <xref:System.Globalization.CultureInfo.InvariantCulture%2A>  
  
 [!code-cpp[System.Globalization.CompareInfo.CompareStrIntIntStrIntInt#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Globalization.CompareInfo.CompareStrIntIntStrIntInt/CPP/comparestrintintstrintint.cpp#1)]
 [!code-csharp[System.Globalization.CompareInfo.CompareStrIntIntStrIntInt#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Globalization.CompareInfo.CompareStrIntIntStrIntInt/CS/comparestrintintstrintint.cs#1)]
 [!code-vb[System.Globalization.CompareInfo.CompareStrIntIntStrIntInt#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Globalization.CompareInfo.CompareStrIntIntStrIntInt/VB/comparestrintintstrintint.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="offset1" />、<paramref name="length1" />、<paramref name="offset2" /> 或 <paramref name="length2" /> 小于零。  
  
或 
 <paramref name="offset1" /> 大于或等于 <paramref name="string1" /> 中的字符数。  
  
或 
 <paramref name="offset2" /> 大于或等于 <paramref name="string2" /> 中的字符数。  
  
或 
 <paramref name="length1" /> 大于从 <paramref name="offset1" /> 到 <paramref name="string1" /> 末尾的字符数。  
  
或 
 <paramref name="length2" /> 大于从 <paramref name="offset2" /> 到 <paramref name="string2" /> 末尾的字符数。</exception>
        <block subset="none" type="usage">
          <para>字符集包括可忽略字符。 <see cref="M:System.Globalization.CompareInfo.Compare(System.String,System.Int32,System.Int32,System.String,System.Int32,System.Int32)" />方法执行语言性的或区分区域性的比较时不考虑这些字符。 若要识别您的比较中的可忽略字符，调用<see cref="M:System.Globalization.CompareInfo.Compare(System.String,System.Int32,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CompareOptions)" />方法并提供的值<see cref="F:System.Globalization.CompareOptions.Ordinal" />或<see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" />为<paramref name="options" />参数。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public virtual int Compare (string string1, int offset1, int length1, string string2, int offset2, int length2, System.Globalization.CompareOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 Compare(string string1, int32 offset1, int32 length1, string string2, int32 offset2, int32 length2, valuetype System.Globalization.CompareOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Globalization.CompareInfo.Compare(System.String,System.Int32,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CompareOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Compare (string1 As String, offset1 As Integer, length1 As Integer, string2 As String, offset2 As Integer, length2 As Integer, options As CompareOptions) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int Compare(System::String ^ string1, int offset1, int length1, System::String ^ string2, int offset2, int length2, System::Globalization::CompareOptions options);" />
      <MemberSignature Language="F#" Value="abstract member Compare : string * int * int * string * int * int * System.Globalization.CompareOptions -&gt; int&#xA;override this.Compare : string * int * int * string * int * int * System.Globalization.CompareOptions -&gt; int" Usage="compareInfo.Compare (string1, offset1, length1, string2, offset2, length2, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Globalization</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="string1" Type="System.String" />
        <Parameter Name="offset1" Type="System.Int32" />
        <Parameter Name="length1" Type="System.Int32" />
        <Parameter Name="string2" Type="System.String" />
        <Parameter Name="offset2" Type="System.Int32" />
        <Parameter Name="length2" Type="System.Int32" />
        <Parameter Name="options" Type="System.Globalization.CompareOptions" />
      </Parameters>
      <Docs>
        <param name="string1">要比较的第一个字符串。</param>
        <param name="offset1">
          <paramref name="string1" /> 中的字符从零开始的索引，将从此位置开始比较。</param>
        <param name="length1">
          <paramref name="string1" /> 中要比较的连续字符数。</param>
        <param name="string2">要比较的第二个字符串。</param>
        <param name="offset2">
          <paramref name="string2" /> 中的字符从零开始的索引，将从此位置开始比较。</param>
        <param name="length2">
          <paramref name="string2" /> 中要比较的连续字符数。</param>
        <param name="options">一个值，用于定义应如何比较 <paramref name="string1" /> 和 <paramref name="string2" />。 <paramref name="options" /> 可以为枚举值 <see cref="F:System.Globalization.CompareOptions.Ordinal" />，或为以下一个或多个值的按位组合：<see cref="F:System.Globalization.CompareOptions.IgnoreCase" />、<see cref="F:System.Globalization.CompareOptions.IgnoreSymbols" />、<see cref="F:System.Globalization.CompareOptions.IgnoreNonSpace" />、<see cref="F:System.Globalization.CompareOptions.IgnoreWidth" />、<see cref="F:System.Globalization.CompareOptions.IgnoreKanaType" /> 和 <see cref="F:System.Globalization.CompareOptions.StringSort" />。</param>
        <summary>使用指定的 <see cref="T:System.Globalization.CompareOptions" /> 值将一个字符串的一部分与另一个字符串的一部分相比较。</summary>
        <returns>一个 32 位有符号整数，指示两个比较数之间的词法关系。  
  
 <list type="table"><listheader><term> “值” 
 </term><description> 条件 
 </description></listheader><item><term> 零 
 </term><description> 这两个字符串相等。  
  
 </description></item><item><term> 小于零 
 </term><description><paramref name="string1" /> 的指定部分小于 <paramref name="string2" /> 的指定部分。  
  
 </description></item><item><term> 大于零 
 </term><description><paramref name="string1" /> 的指定部分大于 <paramref name="string2" /> 的指定部分。  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果安全决策取决于字符串比较或大小写更改，则应使用<xref:System.Globalization.CultureInfo.InvariantCulture%2A>属性以确保行为一致而不考虑操作系统的区域性设置。  
  
> [!NOTE]
>  如果可能，应调用字符串比较方法具有的类型参数的<xref:System.Globalization.CompareOptions>指定的预期的比较类型。 作为一般规则，用来进行比较用户界面中显示的字符串 （使用当前区域性） 的语言选项并指定<xref:System.Globalization.CompareOptions.Ordinal>或<xref:System.Globalization.CompareOptions.OrdinalIgnoreCase>安全比较。  
  
   
  
## Examples  
 下面的示例比较两个字符串使用不同的部分<xref:System.Globalization.CompareOptions>设置。  
  
 [!code-cpp[System.Globalization.CompareInfo.CompareStrIntIntStrIntIntOpt#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Globalization.CompareInfo.CompareStrIntIntStrIntIntOpt/CPP/comparestrintintstrintintopt.cpp#1)]
 [!code-csharp[System.Globalization.CompareInfo.CompareStrIntIntStrIntIntOpt#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Globalization.CompareInfo.CompareStrIntIntStrIntIntOpt/CS/comparestrintintstrintintopt.cs#1)]
 [!code-vb[System.Globalization.CompareInfo.CompareStrIntIntStrIntIntOpt#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Globalization.CompareInfo.CompareStrIntIntStrIntIntOpt/VB/comparestrintintstrintintopt.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="offset1" />、<paramref name="length1" />、<paramref name="offset2" /> 或 <paramref name="length2" /> 小于零。  
  
或 
 <paramref name="offset1" /> 大于或等于 <paramref name="string1" /> 中的字符数。  
  
或 
 <paramref name="offset2" /> 大于或等于 <paramref name="string2" /> 中的字符数。  
  
或 
 <paramref name="length1" /> 大于从 <paramref name="offset1" /> 到 <paramref name="string1" /> 末尾的字符数。  
  
或 
 <paramref name="length2" /> 大于从 <paramref name="offset2" /> 到 <paramref name="string2" /> 末尾的字符数。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="options" /> 包含无效的 <see cref="T:System.Globalization.CompareOptions" /> 值。</exception>
        <block subset="none" type="usage">
          <para>字符集包括可忽略字符。 <see cref="M:System.Globalization.CompareInfo.Compare(System.String,System.Int32,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CompareOptions)" />方法执行区分区域性的比较时不考虑这些字符。 若要识别您的比较中的可忽略字符，提供的值<see cref="F:System.Globalization.CompareOptions.Ordinal" />或<see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" />为<paramref name="options" />参数。</para>
        </block>
        <altmember cref="T:System.Globalization.CompareOptions" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Globalization.CompareInfo.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (value As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="compareInfo.Equals value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Globalization</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">将与当前 <see cref="T:System.Globalization.CompareInfo" /> 进行比较的对象。</param>
        <summary>确定指定的对象是否等于当前 <see cref="T:System.Globalization.CompareInfo" /> 对象。</summary>
        <returns>如果指定的对象等于当前的 <see cref="T:System.Globalization.CompareInfo" />，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 两个<xref:System.Globalization.CompareInfo>对象相等，如果他们<xref:System.Globalization.CompareInfo.LCID%2A>和<xref:System.Globalization.CompareInfo.Name%2A>属性相等。  
  
 此方法重写 <xref:System.Object.Equals%2A?displayProperty=nameWithType>。  
  
 如果安全决策取决于字符串比较或大小写更改，则应使用<xref:System.Globalization.CultureInfo.InvariantCulture%2A>属性以确保行为一致而不考虑操作系统的区域性设置。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Object.Equals(System.Object)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetCompareInfo">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>初始化新的 <see cref="T:System.Globalization.CompareInfo" /> 对象。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetCompareInfo">
      <MemberSignature Language="C#" Value="public static System.Globalization.CompareInfo GetCompareInfo (int culture);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Globalization.CompareInfo GetCompareInfo(int32 culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Globalization.CompareInfo.GetCompareInfo(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetCompareInfo (culture As Integer) As CompareInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Globalization::CompareInfo ^ GetCompareInfo(int culture);" />
      <MemberSignature Language="F#" Value="static member GetCompareInfo : int -&gt; System.Globalization.CompareInfo" Usage="System.Globalization.CompareInfo.GetCompareInfo culture" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Globalization</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Globalization.CompareInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="culture" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="culture">一个表示区域性标识符的整数。</param>
        <summary>初始化与具有指定标识符的区域性关联的新 <see cref="T:System.Globalization.CompareInfo" /> 对象。</summary>
        <returns>一个新 <see cref="T:System.Globalization.CompareInfo" /> 对象，它与具有指定标识符的区域性关联，并使用当前 <see cref="T:System.Reflection.Assembly" /> 中的字符串比较方法。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下面的示例比较两个字符串使用不同的部分<xref:System.Globalization.CompareInfo>对象：  
  
-   <xref:System.Globalization.CompareInfo> 与使用国际排序的西班牙语 （西班牙） 区域性关联的对象  
  
-   <xref:System.Globalization.CompareInfo> 与使用传统排序的西班牙语 （西班牙） 区域性关联的对象  
  
-   <xref:System.Globalization.CompareInfo> 与关联的对象 <xref:System.Globalization.CultureInfo.InvariantCulture%2A>  
  
 [!code-cpp[System.Globalization.CompareInfo.CompareStrStr#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Globalization.CompareInfo.CompareStrStr/CPP/comparestrstr.cpp#1)]
 [!code-csharp[System.Globalization.CompareInfo.CompareStrStr#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Globalization.CompareInfo.CompareStrStr/CS/comparestrstr.cs#1)]
 [!code-vb[System.Globalization.CompareInfo.CompareStrStr#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Globalization.CompareInfo.CompareStrStr/VB/comparestrstr.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetCompareInfo">
      <MemberSignature Language="C#" Value="public static System.Globalization.CompareInfo GetCompareInfo (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Globalization.CompareInfo GetCompareInfo(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Globalization.CompareInfo.GetCompareInfo(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetCompareInfo (name As String) As CompareInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Globalization::CompareInfo ^ GetCompareInfo(System::String ^ name);" />
      <MemberSignature Language="F#" Value="static member GetCompareInfo : string -&gt; System.Globalization.CompareInfo" Usage="System.Globalization.CompareInfo.GetCompareInfo name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Globalization</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Globalization.CompareInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">表示区域性名称的字符串。</param>
        <summary>初始化与具有指定名称的区域性关联的新 <see cref="T:System.Globalization.CompareInfo" /> 对象。</summary>
        <returns>一个新 <see cref="T:System.Globalization.CompareInfo" /> 对象，它与具有指定标识符的区域性关联，并使用当前 <see cref="T:System.Reflection.Assembly" /> 中的字符串比较方法。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下面的示例比较两个字符串使用不同的部分<xref:System.Globalization.CompareInfo>对象：  
  
-   <xref:System.Globalization.CompareInfo> 与使用国际排序的西班牙语 （西班牙） 区域性关联的对象  
  
-   <xref:System.Globalization.CompareInfo> 与使用传统排序的西班牙语 （西班牙） 区域性关联的对象  
  
-   <xref:System.Globalization.CompareInfo> 与关联的对象 <xref:System.Globalization.CultureInfo.InvariantCulture%2A>  
  
 [!code-cpp[System.Globalization.CompareInfo.CompareStrStr#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Globalization.CompareInfo.CompareStrStr/CPP/comparestrstr.cpp#1)]
 [!code-csharp[System.Globalization.CompareInfo.CompareStrStr#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Globalization.CompareInfo.CompareStrStr/CS/comparestrstr.cs#1)]
 [!code-vb[System.Globalization.CompareInfo.CompareStrStr#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Globalization.CompareInfo.CompareStrStr/VB/comparestrstr.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> 是无效的区域性名称。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetCompareInfo">
      <MemberSignature Language="C#" Value="public static System.Globalization.CompareInfo GetCompareInfo (int culture, System.Reflection.Assembly assembly);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Globalization.CompareInfo GetCompareInfo(int32 culture, class System.Reflection.Assembly assembly) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Globalization.CompareInfo.GetCompareInfo(System.Int32,System.Reflection.Assembly)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Globalization::CompareInfo ^ GetCompareInfo(int culture, System::Reflection::Assembly ^ assembly);" />
      <MemberSignature Language="F#" Value="static member GetCompareInfo : int * System.Reflection.Assembly -&gt; System.Globalization.CompareInfo" Usage="System.Globalization.CompareInfo.GetCompareInfo (culture, assembly)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Globalization</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Globalization.CompareInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="culture" Type="System.Int32" />
        <Parameter Name="assembly" Type="System.Reflection.Assembly" />
      </Parameters>
      <Docs>
        <param name="culture">一个表示区域性标识符的整数。</param>
        <param name="assembly">一个 <see cref="T:System.Reflection.Assembly" />，它包含将使用的字符串比较方法。</param>
        <summary>初始化一个新的 <see cref="T:System.Globalization.CompareInfo" /> 对象，该对象与指定区域性关联，并使用指定 <see cref="T:System.Reflection.Assembly" /> 中的字符串比较方法。</summary>
        <returns>一个新 <see cref="T:System.Globalization.CompareInfo" /> 对象，它与具有指定标识符的区域性关联，并使用当前 <see cref="T:System.Reflection.Assembly" /> 中的字符串比较方法。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  此方法的行为不可预测。 建议的应用程序以使用此方法不采用程序集输入的版本。  
  
 `assembly`参数必须与相同类型的<xref:System.Reflection.Module.Assembly%2A?displayProperty=nameWithType>。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assembly" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="assembly" /> 属于无效类型。</exception>
        <altmember cref="P:System.Reflection.Module.Assembly" />
      </Docs>
    </Member>
    <Member MemberName="GetCompareInfo">
      <MemberSignature Language="C#" Value="public static System.Globalization.CompareInfo GetCompareInfo (string name, System.Reflection.Assembly assembly);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Globalization.CompareInfo GetCompareInfo(string name, class System.Reflection.Assembly assembly) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Globalization.CompareInfo.GetCompareInfo(System.String,System.Reflection.Assembly)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Globalization::CompareInfo ^ GetCompareInfo(System::String ^ name, System::Reflection::Assembly ^ assembly);" />
      <MemberSignature Language="F#" Value="static member GetCompareInfo : string * System.Reflection.Assembly -&gt; System.Globalization.CompareInfo" Usage="System.Globalization.CompareInfo.GetCompareInfo (name, assembly)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Globalization</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Globalization.CompareInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="assembly" Type="System.Reflection.Assembly" />
      </Parameters>
      <Docs>
        <param name="name">表示区域性名称的字符串。</param>
        <param name="assembly">一个 <see cref="T:System.Reflection.Assembly" />，它包含将使用的字符串比较方法。</param>
        <summary>初始化一个新的 <see cref="T:System.Globalization.CompareInfo" /> 对象，该对象与指定区域性关联，并使用指定 <see cref="T:System.Reflection.Assembly" /> 中的字符串比较方法。</summary>
        <returns>一个新 <see cref="T:System.Globalization.CompareInfo" /> 对象，它与具有指定标识符的区域性关联，并使用当前 <see cref="T:System.Reflection.Assembly" /> 中的字符串比较方法。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  此方法的行为不可预测。 我们建议使用此方法不采用程序集输入的版本。  
  
 `assembly`参数必须与相同类型的<xref:System.Reflection.Module.Assembly%2A?displayProperty=nameWithType>。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> 为 <see langword="null" />。  
  
或 
 <paramref name="assembly" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> 是无效的区域性名称。  
  
或 
 <paramref name="assembly" /> 属于无效类型。</exception>
        <altmember cref="P:System.Reflection.Module.Assembly" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetHashCode">
      <AssemblyInfo>
        <AssemblyName>System.Globalization</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>返回此 <see cref="T:System.Globalization.CompareInfo" /> 实例或特定字符串的哈希代码。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Globalization.CompareInfo.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="compareInfo.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Globalization</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>用作当前 <see cref="T:System.Globalization.CompareInfo" /> 的哈希函数，适合在哈希算法和数据结构（如哈希表）中使用。</summary>
        <returns>当前 <see cref="T:System.Globalization.CompareInfo" /> 的哈希代码。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法重写 <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType>。  
  
 此方法为根据 <xref:System.Globalization.CompareInfo.Equals%2A> 方法视为相等的两个对象生成相同的哈希代码。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Object.GetHashCode" />
        <altmember cref="T:System.Collections.Hashtable" />
        <altmember cref="M:System.Globalization.CompareInfo.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public virtual int GetHashCode (string source, System.Globalization.CompareOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetHashCode(string source, valuetype System.Globalization.CompareOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Globalization.CompareInfo.GetHashCode(System.String,System.Globalization.CompareOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetHashCode (source As String, options As CompareOptions) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetHashCode(System::String ^ source, System::Globalization::CompareOptions options);" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : string * System.Globalization.CompareOptions -&gt; int" Usage="compareInfo.GetHashCode (source, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Globalization</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="options" Type="System.Globalization.CompareOptions" />
      </Parameters>
      <Docs>
        <param name="source">要返回其哈希代码的字符串。</param>
        <param name="options">确定如何比较字符串的值。</param>
        <summary>根据指定的比较选项获取字符串的哈希代码。</summary>
        <returns>32 位有符号整数哈希代码。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 行为<xref:System.Globalization.CompareInfo.GetHashCode%2A>取决于其实现，它可能从一个版本到另一个，公共语言运行时或从一个.NET Framework 平台更改为另一个。  
  
> [!IMPORTANT]
>  如果两个字符串对象是否相等，<xref:System.Globalization.CompareInfo.GetHashCode%2A>方法返回完全相同的值。 但是，没有每个唯一字符串值的唯一哈希代码值。 不同的字符串可能会返回相同的哈希代码。  
>   
>  不保证本身的哈希代码以保持不变。 跨平台 （如 32 位和 64 位） 的单个版本的.NET framework 和.NET Framework 的版本可以不同于相同字符串的哈希代码。 在某些情况下，它们可能甚至不同的应用程序域。  
>   
>  因此，哈希代码应永远不会在其中创建了它们，应用程序域之外使用它们永远不应使用的键域中的一个集合，并应永远不会保留它们。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> 为 <see langword="null" />。</exception>
        <altmember cref="M:System.Object.GetHashCode" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetSortKey">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>获取字符串的 <see cref="T:System.Globalization.SortKey" /> 对象。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetSortKey">
      <MemberSignature Language="C#" Value="public virtual System.Globalization.SortKey GetSortKey (string source);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Globalization.SortKey GetSortKey(string source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Globalization.CompareInfo.GetSortKey(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetSortKey (source As String) As SortKey" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Globalization::SortKey ^ GetSortKey(System::String ^ source);" />
      <MemberSignature Language="F#" Value="abstract member GetSortKey : string -&gt; System.Globalization.SortKey&#xA;override this.GetSortKey : string -&gt; System.Globalization.SortKey" Usage="compareInfo.GetSortKey source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Globalization</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Globalization.SortKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="source">获取其 <see cref="T:System.Globalization.SortKey" /> 对象的字符串。</param>
        <summary>获取指定字符串的排序关键字。</summary>
        <returns>包含指定字符串的排序关键字的 <see cref="T:System.Globalization.SortKey" /> 对象。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在字符串中的每个字符都赋予若干类排序权重，包括脚本、 字母、 大小写和音调符号权重。 排序关键字是特定字符串这些权重的存储库。 例如，排序键可能包含一串字母权重、 一串大小写权重等等。 <xref:System.Globalization.CompareInfo.GetSortKey%2A>方法等效于 Windows API 方法`LCMapString`LCMAP_SORTKEY 标志。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Globalization.SortKey" />
      </Docs>
    </Member>
    <Member MemberName="GetSortKey">
      <MemberSignature Language="C#" Value="public virtual System.Globalization.SortKey GetSortKey (string source, System.Globalization.CompareOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Globalization.SortKey GetSortKey(string source, valuetype System.Globalization.CompareOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Globalization.CompareInfo.GetSortKey(System.String,System.Globalization.CompareOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetSortKey (source As String, options As CompareOptions) As SortKey" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Globalization::SortKey ^ GetSortKey(System::String ^ source, System::Globalization::CompareOptions options);" />
      <MemberSignature Language="F#" Value="abstract member GetSortKey : string * System.Globalization.CompareOptions -&gt; System.Globalization.SortKey&#xA;override this.GetSortKey : string * System.Globalization.CompareOptions -&gt; System.Globalization.SortKey" Usage="compareInfo.GetSortKey (source, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Globalization</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Globalization.SortKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="options" Type="System.Globalization.CompareOptions" />
      </Parameters>
      <Docs>
        <param name="source">获取其 <see cref="T:System.Globalization.SortKey" /> 对象的字符串。</param>
        <param name="options">以下一个或多个定义该排序关键字如何计算的枚举值的按位组合: <see cref="F:System.Globalization.CompareOptions.IgnoreCase" />、 <see cref="F:System.Globalization.CompareOptions.IgnoreSymbols" />、 <see cref="F:System.Globalization.CompareOptions.IgnoreNonSpace" />、 <see cref="F:System.Globalization.CompareOptions.IgnoreWidth" />、 <see cref="F:System.Globalization.CompareOptions.IgnoreKanaType" />和 <see cref="F:System.Globalization.CompareOptions.StringSort" />。</param>
        <summary>使用指定的 <see cref="T:System.Globalization.SortKey" /> 值获取指定字符串的 <see cref="T:System.Globalization.CompareOptions" /> 对象。</summary>
        <returns>包含指定字符串的排序关键字的 <see cref="T:System.Globalization.SortKey" /> 对象。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在字符串中的每个字符都赋予若干类排序权重，包括脚本、 字母、 大小写和音调符号权重。 排序关键字是特定字符串这些权重的存储库。 例如，排序键可能包含一串字母权重、 一串大小写权重等等。 <xref:System.Globalization.CompareInfo.GetSortKey%2A>方法等效于 Windows API 方法`LCMapString`LCMAP_SORTKEY 标志。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="options" /> 包含无效的 <see cref="T:System.Globalization.CompareOptions" /> 值。</exception>
        <altmember cref="T:System.Globalization.SortKey" />
        <altmember cref="T:System.Globalization.CompareOptions" />
      </Docs>
    </Member>
    <MemberGroup MemberName="IndexOf">
      <AssemblyInfo>
        <AssemblyName>System.Globalization</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>返回某个值在一个字符串内或该字符串的一部分中第一个匹配项的从零开始的索引。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public virtual int IndexOf (string source, char value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 IndexOf(string source, char value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Globalization.CompareInfo.IndexOf(System.String,System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IndexOf (source As String, value As Char) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int IndexOf(System::String ^ source, char value);" />
      <MemberSignature Language="F#" Value="abstract member IndexOf : string * char -&gt; int&#xA;override this.IndexOf : string * char -&gt; int" Usage="compareInfo.IndexOf (source, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Globalization</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="value" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="source">要搜索的字符串。</param>
        <param name="value">要在 <paramref name="source" /> 中定位的字符。</param>
        <summary>搜索指定的字符并返回整个源字符串内第一个匹配项的从零开始的索引。</summary>
        <returns>如果找到，则为 <paramref name="value" /> 在 <paramref name="source" /> 内的第一个匹配项从零开始的索引；否则为 -1。 如果 <paramref name="value" /> 为可忽略字符，则将返回 0（零）。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法搜索字符串末尾的源字符串从字符串的开头。  
  
 此重载执行区分区域性的搜索。 如果`value`表示一个预构成的 Unicode 字符，例如连字"存储"(U + 00 C 6)，它可能被视为等效于正确的顺序，如 AE 及其组件的任何匹配项 (u+0041，U + 0045)，则根据区域性。 若要执行序号 （不区分区域性） 搜索，其中一个字符被视为等效于另一个字符只当其 Unicode 码位是相同的则应调用重载方法，具有类型参数<xref:System.Globalization.CompareOptions>，并使用<xref:System.Globalization.CompareOptions.Ordinal?displayProperty=nameWithType>值。 与不同<xref:System.Globalization.CompareInfo.IndexOf%2A?displayProperty=nameWithType>，该文件将执行区分区域性的比较，重载的<xref:System.String.IndexOf%2A?displayProperty=nameWithType>方法搜索字符执行序号比较，并搜索字符串的重载执行区分区域性的比较。  
  
> [!NOTE]
>  如果可能，应使用具有的类型参数的字符串比较方法<xref:System.Globalization.CompareOptions>指定的预期的比较类型。 作为一般规则，用来进行比较用户界面中显示的字符串 （使用当前区域性） 的语言选项并指定<xref:System.Globalization.CompareOptions.Ordinal?displayProperty=nameWithType>或<xref:System.Globalization.CompareOptions.OrdinalIgnoreCase?displayProperty=nameWithType>安全比较。  
  
   
  
## Examples  
 下面的示例确定一个字符或字符串中的子字符串的第一个和最后一个匹配项的索引。  
  
 [!code-cpp[System.Globalization.CompareInfo.IndexOf#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Globalization.CompareInfo.IndexOf/CPP/indexof.cpp#1)]
 [!code-csharp[System.Globalization.CompareInfo.IndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Globalization.CompareInfo.IndexOf/CS/indexof.cs#1)]
 [!code-vb[System.Globalization.CompareInfo.IndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Globalization.CompareInfo.IndexOf/VB/indexof.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> 为 <see langword="null" />。</exception>
        <block subset="none" type="usage">
          <para>字符集包括可忽略字符，不考虑执行语言性的或区分区域性的排序时的字符。 在区分区域性的搜索中，如果<paramref name="value" />是可忽略字符，结果与移除了该字符的搜索等效。 在这种情况下，<see cref="M:System.Globalization.CompareInfo.IndexOf(System.String,System.Char)" />方法始终返回 0 （零） 以指示，开头处找到的匹配项<paramref name="source" />。 在以下示例中，<see cref="M:System.Globalization.CompareInfo.IndexOf(System.String,System.Char)" />方法用于在两个字符串中查找软连字符 (U + 00AD)。 只有一个字符串包含软连字符。 在这两种情况下，因为软连字符是可忽略字符，方法将返回 0 （零） 以指示它已找到匹配项的字符串的开头。  
  
[！ 代码 csharp[System.Globalization.CompareInfo.IndexOf#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Globalization.CompareInfo.IndexOf/CS/ignorable2.cs#3)] [！ 代码 vb[System.Globalization.CompareInfo.IndexOf#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Globalization.CompareInfo.IndexOf/VB/ignorable2.vb#3)]</para>
        </block>
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.Globalization.CompareInfo.LastIndexOf(System.String,System.Char)" />
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public virtual int IndexOf (string source, string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 IndexOf(string source, string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Globalization.CompareInfo.IndexOf(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IndexOf (source As String, value As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int IndexOf(System::String ^ source, System::String ^ value);" />
      <MemberSignature Language="F#" Value="abstract member IndexOf : string * string -&gt; int&#xA;override this.IndexOf : string * string -&gt; int" Usage="compareInfo.IndexOf (source, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Globalization</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="source">要搜索的字符串。</param>
        <param name="value">要在 <paramref name="source" /> 中定位的字符串。</param>
        <summary>搜索指定的子字符串并返回整个源字符串内第一个匹配项的从零开始的索引。</summary>
        <returns>如果找到，则为 <paramref name="value" /> 在 <paramref name="source" /> 内的第一个匹配项从零开始的索引；否则为 -1。 如果 <paramref name="value" /> 为可忽略字符，则将返回 0（零）。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 向前从字符串的开头处开始和结束时间字符串的末尾搜索的源字符串。  
  
 此重载执行区分区域性的搜索。 一个 Unicode 值，表示一个预构成的字符，例如连字"存储"(U + 00 C 6)，可能会被视为等效于正确的顺序，如 AE 字符的组件的任何匹配项 (u+0041，U + 0045)，则根据区域性。 若要执行序号 （不区分区域性） 搜索，其中的 Unicode 值进行比较，应使用具有类型参数的重载之一<xref:System.Globalization.CompareOptions>，并使用<xref:System.Globalization.CompareOptions.Ordinal>值。  
  
> [!NOTE]
>  如果可能，应调用字符串比较方法具有的类型参数的<xref:System.Globalization.CompareOptions>指定的预期的比较类型。 作为一般规则，用来进行比较用户界面中显示的字符串 （使用当前区域性） 的语言选项并指定<xref:System.Globalization.CompareOptions.Ordinal?displayProperty=nameWithType>或<xref:System.Globalization.CompareOptions.OrdinalIgnoreCase?displayProperty=nameWithType>安全比较。  
  
   
  
## Examples  
 下面的示例确定一个字符或字符串中的子字符串的第一个和最后一个匹配项的索引。  
  
 [!code-cpp[System.Globalization.CompareInfo.IndexOf#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Globalization.CompareInfo.IndexOf/CPP/indexof.cpp#1)]
 [!code-csharp[System.Globalization.CompareInfo.IndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Globalization.CompareInfo.IndexOf/CS/indexof.cs#1)]
 [!code-vb[System.Globalization.CompareInfo.IndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Globalization.CompareInfo.IndexOf/VB/indexof.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> 为 <see langword="null" />。  
  
或 
 <paramref name="value" /> 为 <see langword="null" />。</exception>
        <block subset="none" type="usage">
          <para>字符集包括可忽略字符，不考虑执行语言性的或区分区域性的排序时的字符。 在区分区域性的搜索中，如果 <paramref name="value" /> 包含一个可忽略字符，则结果与移除了该字符的搜索等效。 如果<paramref name="value" />仅包含一个或多个可忽略字符，<see cref="M:System.Globalization.CompareInfo.IndexOf(System.String,System.String)" />方法始终返回 0 （零） 以指示，开头处找到的匹配项<paramref name="source" />。 在以下示例中，<see cref="M:System.Globalization.CompareInfo.IndexOf(System.String,System.String)" />方法用于在两个字符串中查找三个子字符串 （软连字符 (U + 00AD)、 软连字符后跟"n"和软连字符后跟"m"）。 只有一个字符串包含软连字符。 每种情况下，因为软连字符是可忽略字符，因此结果是相同像软连字符不包含在<paramref name="value" />。 搜索的软连字符时，该方法将返回 0 （零） 以指示它已在字符串的开头找到匹配项。  
  
[！ 代码 csharp[System.Globalization.CompareInfo.IndexOf#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Globalization.CompareInfo.IndexOf/CS/ignorable1.cs#2)] [！ 代码 vb[System.Globalization.CompareInfo.IndexOf#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Globalization.CompareInfo.IndexOf/VB/ignorable1.vb#2)]</para>
        </block>
        <altmember cref="M:System.Globalization.CompareInfo.LastIndexOf(System.String,System.Char)" />
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public virtual int IndexOf (string source, char value, System.Globalization.CompareOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 IndexOf(string source, char value, valuetype System.Globalization.CompareOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Globalization.CompareInfo.IndexOf(System.String,System.Char,System.Globalization.CompareOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IndexOf (source As String, value As Char, options As CompareOptions) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int IndexOf(System::String ^ source, char value, System::Globalization::CompareOptions options);" />
      <MemberSignature Language="F#" Value="abstract member IndexOf : string * char * System.Globalization.CompareOptions -&gt; int&#xA;override this.IndexOf : string * char * System.Globalization.CompareOptions -&gt; int" Usage="compareInfo.IndexOf (source, value, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Globalization</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="value" Type="System.Char" />
        <Parameter Name="options" Type="System.Globalization.CompareOptions" />
      </Parameters>
      <Docs>
        <param name="source">要搜索的字符串。</param>
        <param name="value">要在 <paramref name="source" /> 中定位的字符。</param>
        <param name="options">一个值，用于定义应如何比较这些字符串。 <paramref name="options" /> 可以为枚举值 <see cref="F:System.Globalization.CompareOptions.Ordinal" />，或为以下一个或多个值的按位组合：<see cref="F:System.Globalization.CompareOptions.IgnoreCase" />、<see cref="F:System.Globalization.CompareOptions.IgnoreSymbols" />、<see cref="F:System.Globalization.CompareOptions.IgnoreNonSpace" />、<see cref="F:System.Globalization.CompareOptions.IgnoreWidth" /> 和 <see cref="F:System.Globalization.CompareOptions.IgnoreKanaType" />。</param>
        <summary>使用指定的 <see cref="T:System.Globalization.CompareOptions" /> 值，搜索指定的字符，并返回整个源字符串内第一个匹配项的从零开始的索引。</summary>
        <returns>如果在 <paramref name="value" /> 中找到 <paramref name="source" /> 的第一个匹配项的从零开始的索引，使用指定的比较选项；否则为 -1。 如果 <paramref name="value" /> 为可忽略字符，则将返回 0（零）。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 向前从字符串的开头处开始和结束时间字符串的末尾搜索的源字符串。  
  
 <xref:System.Globalization.CompareOptions.StringSort?displayProperty=nameWithType>值不能用于此方法。  
  
 如果`options`不包括<xref:System.Globalization.CompareOptions.Ordinal>值，此重载执行区分区域性的搜索。 如果字符是表示预构成的字符的 Unicode 值，例如连字"存储"(U + 00 C 6)，它可能被视为等效于正确的顺序，如 AE 及其组件的任何匹配项 (u+0041，U + 0045)，则根据区域性。 如果`options`包括<xref:System.Globalization.CompareOptions.Ordinal>值，此重载将执行序号 （不区分区域性） 搜索。 仅当 Unicode 值是相同的一个字符被视为等效于另一个字符。 重载的<xref:System.String.IndexOf%2A?displayProperty=nameWithType>该搜索的字符执行序号搜索，而这些搜索的字符串执行区分区域性的搜索。  
  
> [!NOTE]
>  如果可能，应使用具有的类型参数的字符串比较方法<xref:System.Globalization.CompareOptions>指定的预期的比较类型。 作为一般规则，用来进行比较用户界面中显示的字符串 （使用当前区域性） 的语言选项并指定<xref:System.Globalization.CompareOptions.Ordinal?displayProperty=nameWithType>或<xref:System.Globalization.CompareOptions.OrdinalIgnoreCase?displayProperty=nameWithType>安全比较。  
  
   
  
## Examples  
 下面的示例确定一个字符或字符串中的子字符串的第一个和最后一个匹配项的索引。  
  
 [!code-cpp[System.Globalization.CompareInfo.IndexOf#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Globalization.CompareInfo.IndexOf/CPP/indexof.cpp#1)]
 [!code-csharp[System.Globalization.CompareInfo.IndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Globalization.CompareInfo.IndexOf/CS/indexof.cs#1)]
 [!code-vb[System.Globalization.CompareInfo.IndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Globalization.CompareInfo.IndexOf/VB/indexof.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="options" /> 包含无效的 <see cref="T:System.Globalization.CompareOptions" /> 值。</exception>
        <block subset="none" type="usage">
          <para>字符集包括可忽略字符，不考虑执行语言性的或区分区域性的排序时的字符。 在区分区域性的搜索中，如果<paramref name="value" />是可忽略字符，结果与移除了该字符的搜索等效。 在这种情况下，<see cref="M:System.Globalization.CompareInfo.IndexOf(System.String,System.Char,System.Globalization.CompareOptions)" />方法始终返回 0 （零） 以指示，开头处找到的匹配项<paramref name="source" />。 在以下示例中，<see cref="M:System.Globalization.CompareInfo.IndexOf(System.String,System.Char,System.Globalization.CompareOptions)" />方法用于搜索的两个字符串的软连字符 (U + 00AD)。 只有一个字符串包含软连字符。 在这两种情况下，因为软连字符是可忽略字符，区分区域性的搜索将返回 0 （零） 以指示它已找到匹配项的字符串的开头。 序号搜索，但是，成功地在一个字符串中查找软连字符，并报告它不存在从第二个字符串。  
  
[！ 代码 csharp[System.Globalization.CompareInfo.IndexOf#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Globalization.CompareInfo.IndexOf/CS/ignorable3.cs#4)] [！ 代码 vb[System.Globalization.CompareInfo.IndexOf#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Globalization.CompareInfo.IndexOf/VB/ignorable3.vb#4)]</para>
        </block>
        <altmember cref="M:System.Globalization.CompareInfo.LastIndexOf(System.String,System.Char)" />
        <altmember cref="T:System.Globalization.CompareOptions" />
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public virtual int IndexOf (string source, char value, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 IndexOf(string source, char value, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Globalization.CompareInfo.IndexOf(System.String,System.Char,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IndexOf (source As String, value As Char, startIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int IndexOf(System::String ^ source, char value, int startIndex);" />
      <MemberSignature Language="F#" Value="abstract member IndexOf : string * char * int -&gt; int&#xA;override this.IndexOf : string * char * int -&gt; int" Usage="compareInfo.IndexOf (source, value, startIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Globalization</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="value" Type="System.Char" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="source">要搜索的字符串。</param>
        <param name="value">要在 <paramref name="source" /> 中定位的字符。</param>
        <param name="startIndex">从零开始的搜索的起始索引。</param>
        <summary>搜索指定的字符，并返回源字符串内从指定的索引位置到字符串结尾这一部分中第一个匹配项的从零开始的索引。</summary>
        <returns>如果在部分 <paramref name="value" />（从 <paramref name="source" /> 到 <paramref name="startIndex" /> 的结尾这一部分）中找到 <paramref name="source" /> 的第一个匹配项，则为该项的从零开始的索引；否则为 -1。 如果 <paramref name="startIndex" /> 为可忽略字符，则将返回 <paramref name="value" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在源字符串中搜索处开始向前`startIndex`和结束时间字符串的末尾。  
  
 此重载执行区分区域性的搜索。 如果字符是表示预构成的字符的 Unicode 值，例如连字"存储"(U + 00 C 6)，它可能被视为等效于正确的顺序，如 AE 及其组件的任何匹配项 (u+0041，U + 0045)，则根据区域性。 若要执行序号 （不区分区域性） 搜索，其中一个字符被视为等效于另一个字符，仅当 Unicode 值是相同的应调用具有类型参数的重载之一<xref:System.Globalization.CompareOptions>，并使用<xref:System.Globalization.CompareOptions.Ordinal>值。 重载的<xref:System.String.IndexOf%2A?displayProperty=nameWithType>该搜索的字符执行序号搜索，而这些搜索的字符串执行区分区域性的搜索。  
  
> [!NOTE]
>  如果可能，应调用字符串比较方法具有的类型参数的<xref:System.Globalization.CompareOptions>指定的预期的比较类型。 作为一般规则，用来进行比较用户界面中显示的字符串 （使用当前区域性） 的语言选项并指定<xref:System.Globalization.CompareOptions.Ordinal?displayProperty=nameWithType>或<xref:System.Globalization.CompareOptions.OrdinalIgnoreCase?displayProperty=nameWithType>安全比较。  
  
   
  
## Examples  
 下面的示例确定一个字符或字符串的一部分中的子字符串的第一个和最后一个匹配项的索引。 请注意，<xref:System.Globalization.CompareInfo.IndexOf%2A>并<xref:System.Globalization.CompareInfo.LastIndexOf%2A>中的字符串，即使使用相同的不同部分搜索`startIndex`参数。  
  
 [!code-cpp[System.Globalization.CompareInfo.IndexOfInt#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Globalization.CompareInfo.IndexOfInt/CPP/indexofint.cpp#1)]
 [!code-csharp[System.Globalization.CompareInfo.IndexOfInt#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Globalization.CompareInfo.IndexOfInt/CS/indexofint.cs#1)]
 [!code-vb[System.Globalization.CompareInfo.IndexOfInt#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Globalization.CompareInfo.IndexOfInt/VB/indexofint.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> 超出了 <paramref name="source" /> 的有效索引范围。</exception>
        <block subset="none" type="usage">
          <para>字符集包括可忽略字符，不考虑执行语言性的或区分区域性的排序时的字符。 在区分区域性的搜索中，如果<paramref name="value" />是可忽略字符，结果与移除了该字符的搜索等效。 在这种情况下，<see cref="M:System.Globalization.CompareInfo.IndexOf(System.String,System.Char,System.Int32)" />方法始终返回<paramref name="startIndex" />，即搜索开始处的字符位置。 在以下示例中，<see cref="M:System.Globalization.CompareInfo.IndexOf(System.String,System.Char,System.Int32)" />方法用于在两个字符串中查找后"n"的软连字符 (U + 00AD)。 只有一个字符串包含软连字符。 在这两种情况下，因为软连字符是可忽略字符，该方法将返回 1，表示它找到了匹配项中的"n"的位置。  
  
[！ 代码 csharp[System.Globalization.CompareInfo.IndexOf#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Globalization.CompareInfo.IndexOf/CS/ignorable4.cs#5)] [！ 代码 vb[System.Globalization.CompareInfo.IndexOf#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Globalization.CompareInfo.IndexOf/VB/ignorable4.vb#5)]</para>
        </block>
        <altmember cref="M:System.Globalization.CompareInfo.LastIndexOf(System.String,System.Char)" />
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public virtual int IndexOf (string source, string value, System.Globalization.CompareOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 IndexOf(string source, string value, valuetype System.Globalization.CompareOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Globalization.CompareInfo.IndexOf(System.String,System.String,System.Globalization.CompareOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IndexOf (source As String, value As String, options As CompareOptions) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int IndexOf(System::String ^ source, System::String ^ value, System::Globalization::CompareOptions options);" />
      <MemberSignature Language="F#" Value="abstract member IndexOf : string * string * System.Globalization.CompareOptions -&gt; int&#xA;override this.IndexOf : string * string * System.Globalization.CompareOptions -&gt; int" Usage="compareInfo.IndexOf (source, value, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Globalization</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="options" Type="System.Globalization.CompareOptions" />
      </Parameters>
      <Docs>
        <param name="source">要搜索的字符串。</param>
        <param name="value">要在 <paramref name="source" /> 中定位的字符串。</param>
        <param name="options">一个值，用于定义应如何比较 <paramref name="source" /> 和 <paramref name="value" />。 <paramref name="options" /> 可以为枚举值 <see cref="F:System.Globalization.CompareOptions.Ordinal" />，或为以下一个或多个值的按位组合：<see cref="F:System.Globalization.CompareOptions.IgnoreCase" />、<see cref="F:System.Globalization.CompareOptions.IgnoreSymbols" />、<see cref="F:System.Globalization.CompareOptions.IgnoreNonSpace" />、<see cref="F:System.Globalization.CompareOptions.IgnoreWidth" /> 和 <see cref="F:System.Globalization.CompareOptions.IgnoreKanaType" />。</param>
        <summary>使用指定的 <see cref="T:System.Globalization.CompareOptions" /> 值，搜索指定的子字符串，并返回整个源字符串内第一个匹配项的从零开始的索引。</summary>
        <returns>如果在 <paramref name="value" /> 中找到 <paramref name="source" /> 的第一个匹配项的从零开始的索引，使用指定的比较选项；否则为 -1。 如果 <paramref name="value" /> 为可忽略字符，则将返回 0（零）。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 向前从字符串的开头处开始和结束时间字符串的末尾搜索的源字符串。  
  
 <xref:System.Globalization.CompareOptions.StringSort?displayProperty=nameWithType>值不能用于此方法。  
  
 如果`options`不包括<xref:System.Globalization.CompareOptions.Ordinal>值，此重载执行区分区域性的搜索。 一个 Unicode 值，表示一个预构成的字符，例如连字"存储"(U + 00 C 6)，可能会被视为等效于正确的顺序，如 AE 字符的组件的任何匹配项 (u+0041，U + 0045)，则根据区域性。 如果`options`包括<xref:System.Globalization.CompareOptions.Ordinal>值，此重载将执行序号 （不区分区域性） 搜索，其中的 Unicode 值进行比较。  
  
> [!NOTE]
>  如果可能，应调用字符串比较方法具有的类型参数的<xref:System.Globalization.CompareOptions>指定的预期的比较类型。 作为一般规则，用来进行比较用户界面中显示的字符串 （使用当前区域性） 的语言选项并指定<xref:System.Globalization.CompareOptions.Ordinal?displayProperty=nameWithType>或<xref:System.Globalization.CompareOptions.OrdinalIgnoreCase?displayProperty=nameWithType>安全比较。  
  
   
  
## Examples  
 下面的示例确定一个字符或字符串中的子字符串的第一个和最后一个匹配项的索引。  
  
 [!code-cpp[System.Globalization.CompareInfo.IndexOf#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Globalization.CompareInfo.IndexOf/CPP/indexof.cpp#1)]
 [!code-csharp[System.Globalization.CompareInfo.IndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Globalization.CompareInfo.IndexOf/CS/indexof.cs#1)]
 [!code-vb[System.Globalization.CompareInfo.IndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Globalization.CompareInfo.IndexOf/VB/indexof.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> 为 <see langword="null" />。  
  
或 
 <paramref name="value" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="options" /> 包含无效的 <see cref="T:System.Globalization.CompareOptions" /> 值。</exception>
        <block subset="none" type="usage">
          <para>字符集包括可忽略字符，不考虑执行语言性的或区分区域性的排序时的字符。 在区分区域性的搜索 (即，如果 <paramref name="options" /> 不是 <see cref="F:System.Globalization.CompareOptions.Ordinal" /> 或 <see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" />) 中，如果 <paramref name="value" /> 包含一个可忽略字符，则结果与移除了该字符的搜索等效。 如果<paramref name="value" />仅包含一个或多个可忽略字符，<see cref="M:System.Globalization.CompareInfo.IndexOf(System.String,System.String,System.Globalization.CompareOptions)" />方法始终返回 0 （零） 以指示，开头处找到的匹配项<paramref name="source" />。 在以下示例中，<see cref="M:System.Globalization.CompareInfo.IndexOf(System.String,System.String,System.Globalization.CompareOptions)" />方法用于在两个字符串中查找三个子字符串 （软连字符 (U + 00AD)、 软连字符后跟"n"和软连字符后跟"m"）。 只有一个字符串包含软连字符。 由于软连字符是一个可忽略字符，区分区域性的搜索将返回相同的值，它将返回如果搜索字符串中未包含软连字符。 序号搜索，但是，成功地在一个字符串中查找软连字符，并报告它不存在从第二个字符串。  
  
[！ 代码 csharp[System.Globalization.CompareInfo.IndexOf#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Globalization.CompareInfo.IndexOf/CS/ignorable5.cs#6)] [！ 代码 vb[System.Globalization.CompareInfo.IndexOf#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Globalization.CompareInfo.IndexOf/VB/ignorable5.vb#6)]</para>
        </block>
        <altmember cref="M:System.Globalization.CompareInfo.LastIndexOf(System.String,System.Char)" />
        <altmember cref="T:System.Globalization.CompareOptions" />
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public virtual int IndexOf (string source, string value, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 IndexOf(string source, string value, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Globalization.CompareInfo.IndexOf(System.String,System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IndexOf (source As String, value As String, startIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int IndexOf(System::String ^ source, System::String ^ value, int startIndex);" />
      <MemberSignature Language="F#" Value="abstract member IndexOf : string * string * int -&gt; int&#xA;override this.IndexOf : string * string * int -&gt; int" Usage="compareInfo.IndexOf (source, value, startIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Globalization</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="source">要搜索的字符串。</param>
        <param name="value">要在 <paramref name="source" /> 中定位的字符串。</param>
        <param name="startIndex">从零开始的搜索的起始索引。</param>
        <summary>搜索指定的子字符串，并返回源字符串内从指定的索引位置到字符串结尾这一部分中第一个匹配项的从零开始的索引。</summary>
        <returns>如果在部分 <paramref name="value" />（从 <paramref name="source" /> 到 <paramref name="startIndex" /> 的结尾这一部分）中找到 <paramref name="source" /> 的第一个匹配项，则为该项的从零开始的索引；否则为 -1。 如果 <paramref name="startIndex" /> 为可忽略字符，则将返回 <paramref name="value" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在源字符串中搜索处开始向前`startIndex`和结束时间字符串的末尾。  
  
 此重载执行区分区域性的搜索。 一个 Unicode 值，表示一个预构成的字符，例如连字"存储"(U + 00 C 6)，可能会被视为等效于正确的顺序，如 AE 字符的组件的任何匹配项 (u+0041，U + 0045)，则根据区域性。 若要执行序号 （不区分区域性） 搜索，其中的 Unicode 值进行比较，应调用具有类型参数的重载之一<xref:System.Globalization.CompareOptions>，并使用<xref:System.Globalization.CompareOptions.Ordinal>值。  
  
> [!NOTE]
>  如果可能，应调用字符串比较方法具有的类型参数的<xref:System.Globalization.CompareOptions>指定的预期的比较类型。 作为一般规则，用来进行比较用户界面中显示的字符串 （使用当前区域性） 的语言选项并指定<xref:System.Globalization.CompareOptions.Ordinal?displayProperty=nameWithType>或<xref:System.Globalization.CompareOptions.OrdinalIgnoreCase?displayProperty=nameWithType>安全比较。  
  
   
  
## Examples  
 下面的示例确定一个字符或字符串的一部分中的子字符串的第一个和最后一个匹配项的索引。 请注意，<xref:System.Globalization.CompareInfo.IndexOf%2A>并<xref:System.Globalization.CompareInfo.LastIndexOf%2A>中的字符串，即使使用相同的不同部分搜索`startIndex`参数。  
  
 [!code-cpp[System.Globalization.CompareInfo.IndexOfInt#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Globalization.CompareInfo.IndexOfInt/CPP/indexofint.cpp#1)]
 [!code-csharp[System.Globalization.CompareInfo.IndexOfInt#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Globalization.CompareInfo.IndexOfInt/CS/indexofint.cs#1)]
 [!code-vb[System.Globalization.CompareInfo.IndexOfInt#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Globalization.CompareInfo.IndexOfInt/VB/indexofint.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> 为 <see langword="null" />。  
  
或 
 <paramref name="value" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> 超出了 <paramref name="source" /> 的有效索引范围。</exception>
        <block subset="none" type="usage">
          <para>字符集包括可忽略字符，不考虑执行语言性的或区分区域性的排序时的字符。 在区分区域性的搜索中，如果 <paramref name="value" /> 包含一个可忽略字符，则结果与移除了该字符的搜索等效。 如果<paramref name="value" />仅包含一个或多个可忽略字符，<see cref="M:System.Globalization.CompareInfo.IndexOf(System.String,System.String,System.Int32)" />方法始终返回<paramref name="startIndex" />，即搜索开始处的字符位置。  
  
在以下示例中，<see cref="M:System.Globalization.CompareInfo.IndexOf(System.String,System.String,System.Int32)" />方法用于查找的软连字符 (U + 00AD) 后, 跟"m"两个字符串中的位置。 只有一个字符串包含必需的子字符串。 在这两种情况下，因为软连字符是可忽略字符，该方法将返回字符串中的"m"的索引。 注意对于第一个字符串，包含软连字符后跟“m”，该方法无法返回该软连字符的索引，而是返回“m”的索引。  
  
[！ 代码 csharp[System.Globalization.CompareInfo.IndexOf#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Globalization.CompareInfo.IndexOf/CS/ignorable13.cs#14)] [！ 代码 vb[System.Globalization.CompareInfo.IndexOf#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Globalization.CompareInfo.IndexOf/VB/ignorable13.vb#14)]</para>
        </block>
        <altmember cref="M:System.Globalization.CompareInfo.LastIndexOf(System.String,System.Char)" />
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public virtual int IndexOf (string source, char value, int startIndex, System.Globalization.CompareOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 IndexOf(string source, char value, int32 startIndex, valuetype System.Globalization.CompareOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Globalization.CompareInfo.IndexOf(System.String,System.Char,System.Int32,System.Globalization.CompareOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IndexOf (source As String, value As Char, startIndex As Integer, options As CompareOptions) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int IndexOf(System::String ^ source, char value, int startIndex, System::Globalization::CompareOptions options);" />
      <MemberSignature Language="F#" Value="abstract member IndexOf : string * char * int * System.Globalization.CompareOptions -&gt; int&#xA;override this.IndexOf : string * char * int * System.Globalization.CompareOptions -&gt; int" Usage="compareInfo.IndexOf (source, value, startIndex, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Globalization</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="value" Type="System.Char" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="options" Type="System.Globalization.CompareOptions" />
      </Parameters>
      <Docs>
        <param name="source">要搜索的字符串。</param>
        <param name="value">要在 <paramref name="source" /> 中定位的字符。</param>
        <param name="startIndex">从零开始的搜索的起始索引。</param>
        <param name="options">一个值，用于定义应如何比较 <paramref name="source" /> 和 <paramref name="value" />。 <paramref name="options" /> 可以为枚举值 <see cref="F:System.Globalization.CompareOptions.Ordinal" />，或为以下一个或多个值的按位组合：<see cref="F:System.Globalization.CompareOptions.IgnoreCase" />、<see cref="F:System.Globalization.CompareOptions.IgnoreSymbols" />、<see cref="F:System.Globalization.CompareOptions.IgnoreNonSpace" />、<see cref="F:System.Globalization.CompareOptions.IgnoreWidth" /> 和 <see cref="F:System.Globalization.CompareOptions.IgnoreKanaType" />。</param>
        <summary>使用指定的 <see cref="T:System.Globalization.CompareOptions" /> 值，搜索指定的字符，并返回源字符串中从指定的索引位置到字符串结尾这一部分中第一个匹配项的从零开始的索引。</summary>
        <returns>使用指定的比较选项，如果在 <paramref name="value" /> 中从 <paramref name="source" /> 一直到 <paramref name="startIndex" /> 的结尾这部分找到 <paramref name="source" /> 的第一个匹配项，则为该项的从零开始的索引；否则为 -1。 如果 <paramref name="startIndex" /> 为可忽略字符，则将返回 <paramref name="value" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在源字符串中搜索处开始向前`startIndex`和结束时间字符串的末尾。  
  
 <xref:System.Globalization.CompareOptions.StringSort?displayProperty=nameWithType>值不能用于此方法。  
  
 如果`options`不包括<xref:System.Globalization.CompareOptions.Ordinal>值，此重载执行区分区域性的搜索。 如果字符是表示预构成的字符的 Unicode 值，例如连字"存储"(U + 00 C 6)，它可能被视为等效于正确的顺序，如 AE 及其组件的任何匹配项 (u+0041，U + 0045)，则根据区域性。 如果`options`包括<xref:System.Globalization.CompareOptions.Ordinal>值，此重载将执行序号 （不区分区域性） 搜索。 仅当 Unicode 值是相同的一个字符被视为等效于另一个字符。 重载的<xref:System.String.IndexOf%2A?displayProperty=nameWithType>该搜索的字符执行序号搜索，而这些搜索的字符串执行区分区域性的搜索。  
  
> [!NOTE]
>  如果可能，应调用字符串比较方法具有的类型参数的<xref:System.Globalization.CompareOptions>指定的预期的比较类型。 作为一般规则，用来进行比较用户界面中显示的字符串 （使用当前区域性） 的语言选项并指定<xref:System.Globalization.CompareOptions.Ordinal?displayProperty=nameWithType>或<xref:System.Globalization.CompareOptions.OrdinalIgnoreCase?displayProperty=nameWithType>安全比较。  
  
   
  
## Examples  
 下面的示例确定一个字符或字符串的一部分中的子字符串的第一个和最后一个匹配项的索引。 请注意，<xref:System.Globalization.CompareInfo.IndexOf%2A>并<xref:System.Globalization.CompareInfo.LastIndexOf%2A>中的字符串，即使使用相同的不同部分搜索`startIndex`参数。  
  
 [!code-cpp[System.Globalization.CompareInfo.IndexOfInt#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Globalization.CompareInfo.IndexOfInt/CPP/indexofint.cpp#1)]
 [!code-csharp[System.Globalization.CompareInfo.IndexOfInt#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Globalization.CompareInfo.IndexOfInt/CS/indexofint.cs#1)]
 [!code-vb[System.Globalization.CompareInfo.IndexOfInt#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Globalization.CompareInfo.IndexOfInt/VB/indexofint.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> 超出了 <paramref name="source" /> 的有效索引范围。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="options" /> 包含无效的 <see cref="T:System.Globalization.CompareOptions" /> 值。</exception>
        <block subset="none" type="usage">
          <para>字符集包括可忽略字符，不考虑执行语言性的或区分区域性的排序时的字符。 在区分区域性的搜索中，如果<paramref name="value" />是可忽略字符，结果与移除了该字符的搜索等效。 在这种情况下，<see cref="M:System.Globalization.CompareInfo.IndexOf(System.String,System.Char,System.Int32,System.Globalization.CompareOptions)" />方法始终返回<paramref name="startIndex" />，从该处首先开始搜索的字符位置。 在以下示例中，<see cref="M:System.Globalization.CompareInfo.IndexOf(System.String,System.Char,System.Int32,System.Globalization.CompareOptions)" />方法用于在两个字符串中查找后"n"的软连字符 (U + 00AD)。 只有一个字符串包含软连字符。 在这两种情况下，因为软连字符是可忽略字符，区分区域性的搜索将返回 1，表示它找到了匹配项中的"n"的位置。 序号搜索，但是，成功地在一个字符串中查找软连字符，并报告它不存在从第二个字符串。  
  
[！ 代码 csharp[System.Globalization.CompareInfo.IndexOf#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Globalization.CompareInfo.IndexOf/CS/ignorable7.cs#8)] [！ 代码 vb[System.Globalization.CompareInfo.IndexOf#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Globalization.CompareInfo.IndexOf/VB/ignorable7.vb#8)]</para>
        </block>
        <altmember cref="M:System.Globalization.CompareInfo.LastIndexOf(System.String,System.Char)" />
        <altmember cref="T:System.Globalization.CompareOptions" />
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public virtual int IndexOf (string source, char value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 IndexOf(string source, char value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Globalization.CompareInfo.IndexOf(System.String,System.Char,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IndexOf (source As String, value As Char, startIndex As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int IndexOf(System::String ^ source, char value, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="abstract member IndexOf : string * char * int * int -&gt; int&#xA;override this.IndexOf : string * char * int * int -&gt; int" Usage="compareInfo.IndexOf (source, value, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Globalization</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="value" Type="System.Char" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="source">要搜索的字符串。</param>
        <param name="value">要在 <paramref name="source" /> 中定位的字符。</param>
        <param name="startIndex">从零开始的搜索的起始索引。</param>
        <param name="count">要搜索的部分中的元素数。</param>
        <summary>搜索指定的字符，并返回源字符串内从指定的索引位置开始、包含指定的元素数的部分中第一个匹配项的从零开始的索引。</summary>
        <returns>如果在 <paramref name="value" /> 的从 <paramref name="source" /> 开始、包含 <paramref name="startIndex" /> 所指定的元素数的部分中，找到 <paramref name="count" /> 的第一个匹配项，则为该项的从零开始的索引；否则为 -1。 如果 <paramref name="startIndex" /> 为可忽略字符，则将返回 <paramref name="value" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在源字符串中搜索处开始向前`startIndex`结束时间`startIndex`  +  `count` -1。  
  
 此重载执行区分区域性的搜索。 如果字符是表示预构成的字符的 Unicode 值，例如连字"存储"(U + 00 C 6)，它可能被视为等效于正确的顺序，如 AE 及其组件的任何匹配项 (u+0041，U + 0045)，则根据区域性。 若要执行序号 （不区分区域性） 搜索，其中一个字符被视为等效于另一个字符，仅当 Unicode 值是相同的应调用具有类型参数的重载之一<xref:System.Globalization.CompareOptions>，并使用<xref:System.Globalization.CompareOptions.Ordinal>值。 重载的<xref:System.String.IndexOf%2A?displayProperty=nameWithType>该搜索的字符执行序号搜索，而这些搜索的字符串执行区分区域性的搜索。  
  
> [!NOTE]
>  如果可能，应调用字符串比较方法具有的类型参数的<xref:System.Globalization.CompareOptions>指定的预期的比较类型。 作为一般规则，用来进行比较用户界面中显示的字符串 （使用当前区域性） 的语言选项并指定<xref:System.Globalization.CompareOptions.Ordinal?displayProperty=nameWithType>或<xref:System.Globalization.CompareOptions.OrdinalIgnoreCase?displayProperty=nameWithType>安全比较。  
  
   
  
## Examples  
 下面的示例确定一个字符或字符串的一部分中的子字符串的第一个和最后一个匹配项的索引。  
  
 [!code-cpp[System.Globalization.CompareInfo.IndexOfIntInt#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Globalization.CompareInfo.IndexOfIntInt/CPP/indexofintint.cpp#1)]
 [!code-csharp[System.Globalization.CompareInfo.IndexOfIntInt#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Globalization.CompareInfo.IndexOfIntInt/CS/indexofintint.cs#1)]
 [!code-vb[System.Globalization.CompareInfo.IndexOfIntInt#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Globalization.CompareInfo.IndexOfIntInt/VB/indexofintint.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> 超出了 <paramref name="source" /> 的有效索引范围。  
  
或 
 <paramref name="count" /> 小于零。  
  
或 
 <paramref name="startIndex" /> 和 <paramref name="count" /> 未在 <paramref name="source" /> 中指定有效部分。</exception>
        <block subset="none" type="usage">
          <para>字符集包括可忽略字符，不考虑执行语言性的或区分区域性的排序时的字符。 在区分区域性的搜索中，如果<paramref name="value" />是可忽略字符，结果与移除了该字符的搜索等效。 在这种情况下，<see cref="M:System.Globalization.CompareInfo.IndexOf(System.String,System.Char,System.Int32,System.Int32)" />方法始终返回<paramref name="startIndex" />，这是在其中搜索第一次出现的字符位置。 在以下示例中，<see cref="M:System.Globalization.CompareInfo.IndexOf(System.String,System.Char,System.Int32,System.Int32)" />方法用于在两个字符串中查找后"n"的软连字符 (U + 00AD)。 只有一个字符串包含软连字符。 在这两种情况下，因为软连字符是可忽略字符，该方法将返回 1，表示它找到了匹配项中的"n"的位置。  
  
[！ 代码 csharp[System.Globalization.CompareInfo.IndexOf#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Globalization.CompareInfo.IndexOf/CS/ignorable8.cs#9)] [！ 代码 vb[System.Globalization.CompareInfo.IndexOf#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Globalization.CompareInfo.IndexOf/VB/ignorable8.vb#9)]</para>
        </block>
        <altmember cref="M:System.Globalization.CompareInfo.LastIndexOf(System.String,System.Char)" />
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public virtual int IndexOf (string source, string value, int startIndex, System.Globalization.CompareOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 IndexOf(string source, string value, int32 startIndex, valuetype System.Globalization.CompareOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Globalization.CompareInfo.IndexOf(System.String,System.String,System.Int32,System.Globalization.CompareOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IndexOf (source As String, value As String, startIndex As Integer, options As CompareOptions) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int IndexOf(System::String ^ source, System::String ^ value, int startIndex, System::Globalization::CompareOptions options);" />
      <MemberSignature Language="F#" Value="abstract member IndexOf : string * string * int * System.Globalization.CompareOptions -&gt; int&#xA;override this.IndexOf : string * string * int * System.Globalization.CompareOptions -&gt; int" Usage="compareInfo.IndexOf (source, value, startIndex, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Globalization</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="options" Type="System.Globalization.CompareOptions" />
      </Parameters>
      <Docs>
        <param name="source">要搜索的字符串。</param>
        <param name="value">要在 <paramref name="source" /> 中定位的字符串。</param>
        <param name="startIndex">从零开始的搜索的起始索引。</param>
        <param name="options">一个值，用于定义应如何比较 <paramref name="source" /> 和 <paramref name="value" />。 <paramref name="options" /> 可以为枚举值 <see cref="F:System.Globalization.CompareOptions.Ordinal" />，或为以下一个或多个值的按位组合：<see cref="F:System.Globalization.CompareOptions.IgnoreCase" />、<see cref="F:System.Globalization.CompareOptions.IgnoreSymbols" />、<see cref="F:System.Globalization.CompareOptions.IgnoreNonSpace" />、<see cref="F:System.Globalization.CompareOptions.IgnoreWidth" /> 和 <see cref="F:System.Globalization.CompareOptions.IgnoreKanaType" />。</param>
        <summary>使用指定的 <see cref="T:System.Globalization.CompareOptions" /> 值，搜索指定的子字符串，并返回源字符串内从指定的索引位置到字符串结尾这一部分中第一个匹配项的从零开始的索引。</summary>
        <returns>使用指定的比较选项，如果在 <paramref name="value" /> 中从 <paramref name="source" /> 一直到 <paramref name="startIndex" /> 的结尾这部分找到 <paramref name="source" /> 的第一个匹配项，则为该项的从零开始的索引；否则为 -1。 如果 <paramref name="startIndex" /> 为可忽略字符，则将返回 <paramref name="value" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在源字符串中搜索处开始向前`startIndex`和结束时间字符串的末尾。  
  
 <xref:System.Globalization.CompareOptions.StringSort?displayProperty=nameWithType>值不能用于此方法。  
  
 如果`options`不包括<xref:System.Globalization.CompareOptions.Ordinal>值，此重载执行区分区域性的搜索。 一个 Unicode 值，表示一个预构成的字符，例如连字"存储"(U + 00 C 6)，可能会被视为等效于正确的顺序，如 AE 字符的组件的任何匹配项 (u+0041，U + 0045)，则根据区域性。 如果`options`包括<xref:System.Globalization.CompareOptions.Ordinal>值，此重载将执行序号 （不区分区域性） 搜索，其中的 Unicode 值进行比较。  
  
> [!NOTE]
>  如果可能，应调用字符串比较方法具有的类型参数的<xref:System.Globalization.CompareOptions>指定的预期的比较类型。 作为一般规则，用来进行比较用户界面中显示的字符串 （使用当前区域性） 的语言选项并指定<xref:System.Globalization.CompareOptions.Ordinal?displayProperty=nameWithType>或<xref:System.Globalization.CompareOptions.OrdinalIgnoreCase?displayProperty=nameWithType>安全比较。  
  
   
  
## Examples  
 下面的示例确定一个字符或字符串的一部分中的子字符串的第一个和最后一个匹配项的索引。 请注意，<xref:System.Globalization.CompareInfo.IndexOf%2A>并<xref:System.Globalization.CompareInfo.LastIndexOf%2A>中的字符串，即使使用相同的不同部分搜索`startIndex`参数。  
  
 [!code-cpp[System.Globalization.CompareInfo.IndexOfInt#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Globalization.CompareInfo.IndexOfInt/CPP/indexofint.cpp#1)]
 [!code-csharp[System.Globalization.CompareInfo.IndexOfInt#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Globalization.CompareInfo.IndexOfInt/CS/indexofint.cs#1)]
 [!code-vb[System.Globalization.CompareInfo.IndexOfInt#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Globalization.CompareInfo.IndexOfInt/VB/indexofint.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> 为 <see langword="null" />。  
  
或 
 <paramref name="value" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> 超出了 <paramref name="source" /> 的有效索引范围。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="options" /> 包含无效的 <see cref="T:System.Globalization.CompareOptions" /> 值。</exception>
        <block subset="none" type="usage">
          <para>字符集包括可忽略字符，不考虑执行语言性的或区分区域性的排序时的字符。 在区分区域性的搜索 (即，如果 <paramref name="options" /> 不是 <see cref="F:System.Globalization.CompareOptions.Ordinal" /> 或 <see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" />) 中，如果 <paramref name="value" /> 包含一个可忽略字符，则结果与移除了该字符的搜索等效。 如果<paramref name="value" />仅包含一个或多个可忽略字符，<see cref="M:System.Globalization.CompareInfo.IndexOf(System.String,System.String,System.Int32,System.Globalization.CompareOptions)" />方法始终返回<paramref name="startIndex" />，即搜索开始处的字符位置。  
  
在以下示例中，<see cref="M:System.Globalization.CompareInfo.IndexOf(System.String,System.String,System.Int32,System.Globalization.CompareOptions)" />方法用于查找的软连字符 (U + 00AD) 后, 跟"m"从两个字符串中的第三个字符位置开始的位置。 只有一个字符串包含必需的子字符串。 在这两种情况下，因为软连字符是可忽略字符，因此，在执行区分区域性的比较时，该方法在字符串中返回索引“m”。 注意对于第一个字符串，包含软连字符后跟“m”，该方法无法返回该软连字符的索引，而是返回“m”的索引。 只有当此方法执行序号比较时，它才会在第一个字符串中返回软连字符的索引。  
  
[！ 代码 csharp[System.Globalization.CompareInfo.IndexOf#15](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Globalization.CompareInfo.IndexOf/CS/ignorable14.cs#15)] [！ 代码 vb[System.Globalization.CompareInfo.IndexOf#15](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Globalization.CompareInfo.IndexOf/VB/ignorable14.vb#15)]</para>
        </block>
        <altmember cref="M:System.Globalization.CompareInfo.LastIndexOf(System.String,System.Char)" />
        <altmember cref="T:System.Globalization.CompareOptions" />
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public virtual int IndexOf (string source, string value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 IndexOf(string source, string value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Globalization.CompareInfo.IndexOf(System.String,System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IndexOf (source As String, value As String, startIndex As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int IndexOf(System::String ^ source, System::String ^ value, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="abstract member IndexOf : string * string * int * int -&gt; int&#xA;override this.IndexOf : string * string * int * int -&gt; int" Usage="compareInfo.IndexOf (source, value, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Globalization</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="source">要搜索的字符串。</param>
        <param name="value">要在 <paramref name="source" /> 中定位的字符串。</param>
        <param name="startIndex">从零开始的搜索的起始索引。</param>
        <param name="count">要搜索的部分中的元素数。</param>
        <summary>搜索指定的子字符串，并返回源字符串内从指定的索引位置开始、包含指定的元素数的部分中第一个匹配项的从零开始的索引。</summary>
        <returns>如果在 <paramref name="value" /> 的从 <paramref name="source" /> 开始、包含 <paramref name="startIndex" /> 所指定的元素数的部分中，找到 <paramref name="count" /> 的第一个匹配项，则为该项的从零开始的索引；否则为 -1。 如果 <paramref name="startIndex" /> 为可忽略字符，则将返回 <paramref name="value" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在源字符串中搜索处开始向前`startIndex`结束时间`startIndex`  +  `count` -1。  
  
 此重载执行区分区域性的搜索。 一个 Unicode 值，表示一个预构成的字符，例如连字"存储"(U + 00 C 6)，可能会被视为等效于正确的顺序，如 AE 字符的组件的任何匹配项 (u+0041，U + 0045)，则根据区域性。 若要执行序号 （不区分区域性） 搜索，其中的 Unicode 值进行比较，应调用具有类型参数的重载之一<xref:System.Globalization.CompareOptions>，并使用<xref:System.Globalization.CompareOptions.Ordinal>值。  
  
> [!NOTE]
>  如果可能，应调用字符串比较方法具有的类型参数的<xref:System.Globalization.CompareOptions>指定的预期的比较类型。 作为一般规则，用来进行比较用户界面中显示的字符串 （使用当前区域性） 的语言选项并指定<xref:System.Globalization.CompareOptions.Ordinal?displayProperty=nameWithType>或<xref:System.Globalization.CompareOptions.OrdinalIgnoreCase?displayProperty=nameWithType>安全比较。  
  
   
  
## Examples  
 下面的示例确定一个字符或字符串的一部分中的子字符串的第一个和最后一个匹配项的索引。  
  
 [!code-cpp[System.Globalization.CompareInfo.IndexOfIntInt#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Globalization.CompareInfo.IndexOfIntInt/CPP/indexofintint.cpp#1)]
 [!code-csharp[System.Globalization.CompareInfo.IndexOfIntInt#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Globalization.CompareInfo.IndexOfIntInt/CS/indexofintint.cs#1)]
 [!code-vb[System.Globalization.CompareInfo.IndexOfIntInt#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Globalization.CompareInfo.IndexOfIntInt/VB/indexofintint.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> 为 <see langword="null" />。  
  
或 
 <paramref name="value" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> 超出了 <paramref name="source" /> 的有效索引范围。  
  
或 
 <paramref name="count" /> 小于零。  
  
或 
 <paramref name="startIndex" /> 和 <paramref name="count" /> 未在 <paramref name="source" /> 中指定有效部分。</exception>
        <block subset="none" type="usage">
          <para>字符集包括可忽略字符，不考虑执行语言性的或区分区域性的排序时的字符。 在区分区域性的搜索中，如果 <paramref name="value" /> 包含一个可忽略字符，则结果与移除了该字符的搜索等效。 如果<paramref name="value" />仅包含一个或多个可忽略字符，<see cref="M:System.Globalization.CompareInfo.IndexOf(System.String,System.String,System.Int32,System.Int32)" />方法始终返回<paramref name="startIndex" />，即搜索开始处的字符位置。  
  
在以下示例中，<see cref="M:System.Globalization.CompareInfo.IndexOf(System.String,System.String,System.Int32,System.Int32)" />方法用于查找的软连字符 (U + 00AD) 后, 跟"m"中第三到两个字符串中的第六个字符位置开始的位置。 只有一个字符串包含必需的子字符串。 在这两种情况下，因为软连字符是可忽略字符，因此，在执行区分区域性的比较时，该方法在字符串中返回索引“m”。 注意对于第一个字符串，包含软连字符后跟“m”，该方法无法返回该软连字符的索引，而是返回“m”的索引。  
  
[！ 代码 csharp[System.Globalization.CompareInfo.IndexOf#17](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Globalization.CompareInfo.IndexOf/CS/ignorable16.cs#17)] [！ 代码 vb[System.Globalization.CompareInfo.IndexOf#17](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Globalization.CompareInfo.IndexOf/VB/ignorable16.vb#17)]</para>
        </block>
        <altmember cref="M:System.Globalization.CompareInfo.LastIndexOf(System.String,System.Char)" />
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public virtual int IndexOf (string source, char value, int startIndex, int count, System.Globalization.CompareOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 IndexOf(string source, char value, int32 startIndex, int32 count, valuetype System.Globalization.CompareOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Globalization.CompareInfo.IndexOf(System.String,System.Char,System.Int32,System.Int32,System.Globalization.CompareOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IndexOf (source As String, value As Char, startIndex As Integer, count As Integer, options As CompareOptions) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int IndexOf(System::String ^ source, char value, int startIndex, int count, System::Globalization::CompareOptions options);" />
      <MemberSignature Language="F#" Value="abstract member IndexOf : string * char * int * int * System.Globalization.CompareOptions -&gt; int&#xA;override this.IndexOf : string * char * int * int * System.Globalization.CompareOptions -&gt; int" Usage="compareInfo.IndexOf (source, value, startIndex, count, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Globalization</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="value" Type="System.Char" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="options" Type="System.Globalization.CompareOptions" />
      </Parameters>
      <Docs>
        <param name="source">要搜索的字符串。</param>
        <param name="value">要在 <paramref name="source" /> 中定位的字符。</param>
        <param name="startIndex">从零开始的搜索的起始索引。</param>
        <param name="count">要搜索的部分中的元素数。</param>
        <param name="options">一个值，用于定义应如何比较 <paramref name="source" /> 和 <paramref name="value" />。 <paramref name="options" /> 可以为枚举值 <see cref="F:System.Globalization.CompareOptions.Ordinal" />，或为以下一个或多个值的按位组合：<see cref="F:System.Globalization.CompareOptions.IgnoreCase" />、<see cref="F:System.Globalization.CompareOptions.IgnoreSymbols" />、<see cref="F:System.Globalization.CompareOptions.IgnoreNonSpace" />、<see cref="F:System.Globalization.CompareOptions.IgnoreWidth" /> 和 <see cref="F:System.Globalization.CompareOptions.IgnoreKanaType" />。</param>
        <summary>使用指定的 <see cref="T:System.Globalization.CompareOptions" /> 值，搜索指定的字符，并返回源字符串内从指定的索引位置开始、包含所指定元素数的部分中第一个匹配项的从零开始的索引。</summary>
        <returns>使用指定的比较选项，如果在 <paramref name="value" /> 中从 <paramref name="source" /> 开始、包含 <paramref name="startIndex" /> 指定的元素数的部分找到 <paramref name="count" /> 的第一个匹配项，则为该项的从零开始的索引；否则为 -1。 如果 <paramref name="startIndex" /> 为可忽略字符，则将返回 <paramref name="value" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在源字符串中搜索处开始向前`startIndex`结束时间`startIndex`  +  `count` -1。  
  
 <xref:System.Globalization.CompareOptions.StringSort?displayProperty=nameWithType>值不能用于此方法。  
  
 如果`options`不包括<xref:System.Globalization.CompareOptions.Ordinal>值，此重载执行区分区域性的搜索。 如果字符是表示预构成的字符的 Unicode 值，例如连字"存储"(U + 00 C 6)，它可能被视为等效于正确的顺序，如 AE 及其组件的任何匹配项 (u+0041，U + 0045)，则根据区域性。 如果`options`包括<xref:System.Globalization.CompareOptions.Ordinal>值，此重载将执行序号 （不区分区域性） 搜索。 仅当 Unicode 值是相同的一个字符被视为等效于另一个字符。 重载的<xref:System.String.IndexOf%2A?displayProperty=nameWithType>该搜索的字符执行序号搜索，而这些搜索的字符串执行区分区域性的搜索。  
  
> [!NOTE]
>  如果可能，应调用字符串比较方法具有的类型参数的<xref:System.Globalization.CompareOptions>指定的预期的比较类型。 作为一般规则，用来进行比较用户界面中显示的字符串 （使用当前区域性） 的语言选项并指定<xref:System.Globalization.CompareOptions.Ordinal?displayProperty=nameWithType>或<xref:System.Globalization.CompareOptions.OrdinalIgnoreCase?displayProperty=nameWithType>安全比较。  
  
   
  
## Examples  
 下面的示例确定一个字符或字符串的一部分中的子字符串的第一个和最后一个匹配项的索引。  
  
 [!code-cpp[System.Globalization.CompareInfo.IndexOfIntInt#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Globalization.CompareInfo.IndexOfIntInt/CPP/indexofintint.cpp#1)]
 [!code-csharp[System.Globalization.CompareInfo.IndexOfIntInt#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Globalization.CompareInfo.IndexOfIntInt/CS/indexofintint.cs#1)]
 [!code-vb[System.Globalization.CompareInfo.IndexOfIntInt#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Globalization.CompareInfo.IndexOfIntInt/VB/indexofintint.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> 超出了 <paramref name="source" /> 的有效索引范围。  
  
或 
 <paramref name="count" /> 小于零。  
  
或 
 <paramref name="startIndex" /> 和 <paramref name="count" /> 未在 <paramref name="source" /> 中指定有效部分。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="options" /> 包含无效的 <see cref="T:System.Globalization.CompareOptions" /> 值。</exception>
        <block subset="none" type="usage">
          <para>字符集包括可忽略字符，不考虑执行语言性的或区分区域性的排序时的字符。 在区分区域性的搜索中，如果<paramref name="value" />是可忽略字符，结果与移除了该字符的搜索等效。 在这种情况下，<see cref="M:System.Globalization.CompareInfo.IndexOf(System.String,System.Char,System.Int32,System.Int32,System.Globalization.CompareOptions)" />方法始终返回<paramref name="startIndex" />，这是在其中搜索第一次出现的字符位置。 在以下示例中，<see cref="M:System.Globalization.CompareInfo.IndexOf(System.String,System.Char,System.Int32,System.Int32,System.Globalization.CompareOptions)" />方法用于在两个字符串中查找后"n"的软连字符 (U + 00AD)。 只有一个字符串包含软连字符。 在这两种情况下，因为软连字符是可忽略字符，区分区域性的搜索将返回 1，表示它找到了匹配项中的"n"的位置。 序号搜索，但是，成功地在一个字符串中查找软连字符，并报告它不存在从第二个字符串。  
  
[！ 代码 csharp[System.Globalization.CompareInfo.IndexOf#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Globalization.CompareInfo.IndexOf/CS/ignorable11.cs#12)] [！ 代码 vb[System.Globalization.CompareInfo.IndexOf#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Globalization.CompareInfo.IndexOf/VB/ignorable11.vb#12)]</para>
        </block>
        <altmember cref="M:System.Globalization.CompareInfo.LastIndexOf(System.String,System.Char)" />
        <altmember cref="T:System.Globalization.CompareOptions" />
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public virtual int IndexOf (string source, string value, int startIndex, int count, System.Globalization.CompareOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 IndexOf(string source, string value, int32 startIndex, int32 count, valuetype System.Globalization.CompareOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Globalization.CompareInfo.IndexOf(System.String,System.String,System.Int32,System.Int32,System.Globalization.CompareOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IndexOf (source As String, value As String, startIndex As Integer, count As Integer, options As CompareOptions) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int IndexOf(System::String ^ source, System::String ^ value, int startIndex, int count, System::Globalization::CompareOptions options);" />
      <MemberSignature Language="F#" Value="abstract member IndexOf : string * string * int * int * System.Globalization.CompareOptions -&gt; int&#xA;override this.IndexOf : string * string * int * int * System.Globalization.CompareOptions -&gt; int" Usage="compareInfo.IndexOf (source, value, startIndex, count, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Globalization</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="options" Type="System.Globalization.CompareOptions" />
      </Parameters>
      <Docs>
        <param name="source">要搜索的字符串。</param>
        <param name="value">要在 <paramref name="source" /> 中定位的字符串。</param>
        <param name="startIndex">从零开始的搜索的起始索引。</param>
        <param name="count">要搜索的部分中的元素数。</param>
        <param name="options">一个值，用于定义应如何比较 <paramref name="source" /> 和 <paramref name="value" />。 <paramref name="options" /> 可以为枚举值 <see cref="F:System.Globalization.CompareOptions.Ordinal" />，或为以下一个或多个值的按位组合：<see cref="F:System.Globalization.CompareOptions.IgnoreCase" />、<see cref="F:System.Globalization.CompareOptions.IgnoreSymbols" />、<see cref="F:System.Globalization.CompareOptions.IgnoreNonSpace" />、<see cref="F:System.Globalization.CompareOptions.IgnoreWidth" /> 和 <see cref="F:System.Globalization.CompareOptions.IgnoreKanaType" />。</param>
        <summary>使用指定的 <see cref="T:System.Globalization.CompareOptions" /> 值，搜索指定的子字符串，并返回源字符串内从指定的索引位置开始、包含所指定元素数的部分中第一个匹配项的从零开始的索引。</summary>
        <returns>使用指定的比较选项，如果在 <paramref name="value" /> 中从 <paramref name="source" /> 开始、包含 <paramref name="startIndex" /> 指定的元素数的部分找到 <paramref name="count" /> 的第一个匹配项，则为该项的从零开始的索引；否则为 -1。 如果 <paramref name="startIndex" /> 为可忽略字符，则将返回 <paramref name="value" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在源字符串中搜索处开始向前`startIndex`结束时间`startIndex`  +  `count` -1。  
  
 <xref:System.Globalization.CompareOptions.StringSort?displayProperty=nameWithType>值不能用于此方法。  
  
 如果`options`不包括<xref:System.Globalization.CompareOptions.Ordinal>值，此重载执行区分区域性的搜索。 一个 Unicode 值，表示一个预构成的字符，例如连字"存储"(U + 00 C 6)，可能会被视为等效于正确的顺序，如 AE 字符的组件的任何匹配项 (u+0041，U + 0045)，则根据区域性。 如果`options`包括<xref:System.Globalization.CompareOptions.Ordinal>值，此重载将执行序号 （不区分区域性） 搜索，其中的 Unicode 值进行比较。  
  
> [!NOTE]
>  如果可能，应调用字符串比较方法具有的类型参数的<xref:System.Globalization.CompareOptions>指定的预期的比较类型。 作为一般规则，用来进行比较用户界面中显示的字符串 （使用当前区域性） 的语言选项并指定<xref:System.Globalization.CompareOptions.Ordinal?displayProperty=nameWithType>或<xref:System.Globalization.CompareOptions.OrdinalIgnoreCase?displayProperty=nameWithType>安全比较。  
  
   
  
## Examples  
 下面的示例确定一个字符或字符串的一部分中的子字符串的第一个和最后一个匹配项的索引。  
  
 [!code-cpp[System.Globalization.CompareInfo.IndexOfIntInt#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Globalization.CompareInfo.IndexOfIntInt/CPP/indexofintint.cpp#1)]
 [!code-csharp[System.Globalization.CompareInfo.IndexOfIntInt#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Globalization.CompareInfo.IndexOfIntInt/CS/indexofintint.cs#1)]
 [!code-vb[System.Globalization.CompareInfo.IndexOfIntInt#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Globalization.CompareInfo.IndexOfIntInt/VB/indexofintint.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> 为 <see langword="null" />。  
  
或 
 <paramref name="value" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> 超出了 <paramref name="source" /> 的有效索引范围。  
  
或 
 <paramref name="count" /> 小于零。  
  
或 
 <paramref name="startIndex" /> 和 <paramref name="count" /> 未在 <paramref name="source" /> 中指定有效部分。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="options" /> 包含无效的 <see cref="T:System.Globalization.CompareOptions" /> 值。</exception>
        <block subset="none" type="usage">
          <para>字符集包括可忽略字符，不考虑执行语言性的或区分区域性的排序时的字符。 在区分区域性的搜索 (即，如果 <paramref name="options" /> 不是 <see cref="F:System.Globalization.CompareOptions.Ordinal" /> 或 <see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" />) 中，如果 <paramref name="value" /> 包含一个可忽略字符，则结果与移除了该字符的搜索等效。 如果<paramref name="value" />仅包含一个或多个可忽略字符，<see cref="M:System.Globalization.CompareInfo.IndexOf(System.String,System.String,System.Int32,System.Int32,System.Globalization.CompareOptions)" />方法始终返回<paramref name="startIndex" />，即搜索开始处的字符位置。  
  
在以下示例中，<see cref="M:System.Globalization.CompareInfo.IndexOf(System.String,System.String,System.Int32,System.Int32,System.Globalization.CompareOptions)" />方法用于查找的软连字符 (U + 00AD) 后, 跟"m"中第三到两个字符串中的第六个字符位置开始的位置。 只有一个字符串包含必需的子字符串。 在这两种情况下，因为软连字符是可忽略字符，因此，在执行区分区域性的比较时，该方法在字符串中返回索引“m”。 当它执行序号比较时，但是，它找到的子字符串仅在第一个字符串中。 请注意，对于第一个字符串，包含软连字符后跟"m"，该方法无法返回软连字符的索引而是返回"m"的索引执行区分区域性的比较时。 只有当此方法执行序号比较时，它才会在第一个字符串中返回软连字符的索引。  
  
[！ 代码 csharp[System.Globalization.CompareInfo.IndexOf#16](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Globalization.CompareInfo.IndexOf/CS/ignorable15.cs#16)] [！ 代码 vb[System.Globalization.CompareInfo.IndexOf#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Globalization.CompareInfo.IndexOf/VB/ignorable15.vb#16)]</para>
        </block>
        <altmember cref="M:System.Globalization.CompareInfo.LastIndexOf(System.String,System.Char)" />
        <altmember cref="T:System.Globalization.CompareOptions" />
      </Docs>
    </Member>
    <MemberGroup MemberName="IsPrefix">
      <AssemblyInfo>
        <AssemblyName>System.Globalization</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>确定字符串是否以指定的前缀开头。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsPrefix">
      <MemberSignature Language="C#" Value="public virtual bool IsPrefix (string source, string prefix);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsPrefix(string source, string prefix) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Globalization.CompareInfo.IsPrefix(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsPrefix (source As String, prefix As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsPrefix(System::String ^ source, System::String ^ prefix);" />
      <MemberSignature Language="F#" Value="abstract member IsPrefix : string * string -&gt; bool&#xA;override this.IsPrefix : string * string -&gt; bool" Usage="compareInfo.IsPrefix (source, prefix)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Globalization</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="prefix" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="source">要在其中搜索的字符串。</param>
        <param name="prefix">要与 <paramref name="source" /> 的开头进行比较的字符串。</param>
        <summary>确定指定的源字符串是否以指定的前缀开头。</summary>
        <returns>如果 <paramref name="prefix" /> 的长度小于或等于 <paramref name="source" /> 的长度，并且 <paramref name="source" /> 以 <paramref name="prefix" /> 开始，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 每个字符串的开头和结尾空的子字符串 ("");因此，如果`prefix`是空字符串，此方法返回`true`。  
  
> [!NOTE]
>  如果可能，应调用字符串比较方法具有的类型参数的<xref:System.Globalization.CompareOptions>指定的预期的比较类型。 作为一般规则，用来进行比较用户界面中显示的字符串 （使用当前区域性） 的语言选项并指定<xref:System.Globalization.CompareOptions.Ordinal?displayProperty=nameWithType>或<xref:System.Globalization.CompareOptions.OrdinalIgnoreCase?displayProperty=nameWithType>安全比较。  
  
   
  
## Examples  
 下面的示例确定字符串是否是前缀或后缀的另一个字符串。  
  
 [!code-cpp[System.Globalization.CompareInfo.IsPrefixSuffix#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Globalization.CompareInfo.IsPrefixSuffix/CPP/isprefixsuffix.cpp#1)]
 [!code-csharp[System.Globalization.CompareInfo.IsPrefixSuffix#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Globalization.CompareInfo.IsPrefixSuffix/CS/isprefixsuffix.cs#1)]
 [!code-vb[System.Globalization.CompareInfo.IsPrefixSuffix#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Globalization.CompareInfo.IsPrefixSuffix/VB/isprefixsuffix.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> 为 <see langword="null" />。  
  
或 
 <paramref name="prefix" /> 为 <see langword="null" />。</exception>
        <altmember cref="M:System.Globalization.CompareInfo.IsSuffix(System.String,System.String,System.Globalization.CompareOptions)" />
      </Docs>
    </Member>
    <Member MemberName="IsPrefix">
      <MemberSignature Language="C#" Value="public virtual bool IsPrefix (string source, string prefix, System.Globalization.CompareOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsPrefix(string source, string prefix, valuetype System.Globalization.CompareOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Globalization.CompareInfo.IsPrefix(System.String,System.String,System.Globalization.CompareOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsPrefix (source As String, prefix As String, options As CompareOptions) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsPrefix(System::String ^ source, System::String ^ prefix, System::Globalization::CompareOptions options);" />
      <MemberSignature Language="F#" Value="abstract member IsPrefix : string * string * System.Globalization.CompareOptions -&gt; bool&#xA;override this.IsPrefix : string * string * System.Globalization.CompareOptions -&gt; bool" Usage="compareInfo.IsPrefix (source, prefix, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Globalization</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="prefix" Type="System.String" />
        <Parameter Name="options" Type="System.Globalization.CompareOptions" />
      </Parameters>
      <Docs>
        <param name="source">要在其中搜索的字符串。</param>
        <param name="prefix">要与 <paramref name="source" /> 的开头进行比较的字符串。</param>
        <param name="options">一个值，用于定义应如何比较 <paramref name="source" /> 和 <paramref name="prefix" />。 <paramref name="options" /> 可以为枚举值 <see cref="F:System.Globalization.CompareOptions.Ordinal" />，或为以下一个或多个值的按位组合：<see cref="F:System.Globalization.CompareOptions.IgnoreCase" />、<see cref="F:System.Globalization.CompareOptions.IgnoreSymbols" />、<see cref="F:System.Globalization.CompareOptions.IgnoreNonSpace" />、<see cref="F:System.Globalization.CompareOptions.IgnoreWidth" /> 和 <see cref="F:System.Globalization.CompareOptions.IgnoreKanaType" />。</param>
        <summary>使用指定的 <see cref="T:System.Globalization.CompareOptions" /> 值确定指定的源字符串是否以指定的前缀开头。</summary>
        <returns>如果 <paramref name="prefix" /> 的长度小于或等于 <paramref name="source" /> 的长度，并且 <paramref name="source" /> 以 <paramref name="prefix" /> 开始，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 每个字符串的开头和结尾空的子字符串 ("");因此，如果`prefix`是空字符串，此方法返回`true`。  
  
 <xref:System.Globalization.CompareOptions.StringSort?displayProperty=nameWithType>值不能用于此方法。  
  
> [!NOTE]
>  如果可能，应调用字符串比较方法具有的类型参数的<xref:System.Globalization.CompareOptions>指定的预期的比较类型。 作为一般规则，用来进行比较用户界面中显示的字符串 （使用当前区域性） 的语言选项并指定<xref:System.Globalization.CompareOptions.Ordinal?displayProperty=nameWithType>或<xref:System.Globalization.CompareOptions.OrdinalIgnoreCase?displayProperty=nameWithType>安全比较。  
  
   
  
## Examples  
 下面的示例确定字符串是否是前缀或后缀的另一个字符串使用<xref:System.Globalization.CompareOptions>。  
  
 [!code-cpp[System.Globalization.CompareInfo.IsPrefixSuffixOpt#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Globalization.CompareInfo.IsPrefixSuffixOpt/CPP/isprefixsuffixopt.cpp#1)]
 [!code-csharp[System.Globalization.CompareInfo.IsPrefixSuffixOpt#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Globalization.CompareInfo.IsPrefixSuffixOpt/CS/isprefixsuffixopt.cs#1)]
 [!code-vb[System.Globalization.CompareInfo.IsPrefixSuffixOpt#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Globalization.CompareInfo.IsPrefixSuffixOpt/VB/isprefixsuffixopt.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> 为 <see langword="null" />。  
  
或 
 <paramref name="prefix" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="options" /> 包含无效的 <see cref="T:System.Globalization.CompareOptions" /> 值。</exception>
        <altmember cref="M:System.Globalization.CompareInfo.IsSuffix(System.String,System.String,System.Globalization.CompareOptions)" />
        <altmember cref="T:System.Globalization.CompareOptions" />
      </Docs>
    </Member>
    <MemberGroup MemberName="IsSortable">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>指示指定的 Unicode 字符或字符串是否可排序。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsSortable">
      <MemberSignature Language="C#" Value="public static bool IsSortable (char ch);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsSortable(char ch) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Globalization.CompareInfo.IsSortable(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsSortable (ch As Char) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsSortable(char ch);" />
      <MemberSignature Language="F#" Value="static member IsSortable : char -&gt; bool" Usage="System.Globalization.CompareInfo.IsSortable ch" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Globalization</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ch" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="ch">一个 Unicode 字符。</param>
        <summary>指示指定的 Unicode 字符是否可排序。</summary>
        <returns>如果 <paramref name="ch" /> 参数可排序，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `ch`参数是在内部定义的 Unicode 字符是否可排序<xref:System.Globalization.CompareInfo>类排序表，并不是专用的使用或不成对的高或低代理项字符。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsSortable">
      <MemberSignature Language="C#" Value="public static bool IsSortable (string text);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsSortable(string text) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Globalization.CompareInfo.IsSortable(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsSortable (text As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsSortable(System::String ^ text);" />
      <MemberSignature Language="F#" Value="static member IsSortable : string -&gt; bool" Usage="System.Globalization.CompareInfo.IsSortable text" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Globalization</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="text" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="text">由 0 或更多 Unicode 字符组成的字符串。</param>
        <summary>指示指定的 Unicode 字符串是否可排序。</summary>
        <returns>如果 <paramref name="str" /> 参数不是空字符串 ("") 且 <paramref name="str" /> 中的所有 Unicode 字符都是可排序的，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在每个 Unicode 字符`str`参数由一个或多个 UTF 16 编码<xref:System.Char>对象。 `str`参数是在内部定义的每个 Unicode 字符的情况下可排序<xref:System.Globalization.CompareInfo>类排序表，并不是专用的使用或不成对的高或低代理项字符。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="str" /> 为 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="IsSuffix">
      <AssemblyInfo>
        <AssemblyName>System.Globalization</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>确定字符串是否以特定的后缀结尾。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsSuffix">
      <MemberSignature Language="C#" Value="public virtual bool IsSuffix (string source, string suffix);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsSuffix(string source, string suffix) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Globalization.CompareInfo.IsSuffix(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsSuffix (source As String, suffix As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsSuffix(System::String ^ source, System::String ^ suffix);" />
      <MemberSignature Language="F#" Value="abstract member IsSuffix : string * string -&gt; bool&#xA;override this.IsSuffix : string * string -&gt; bool" Usage="compareInfo.IsSuffix (source, suffix)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Globalization</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="suffix" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="source">要在其中搜索的字符串。</param>
        <param name="suffix">要与 <paramref name="source" /> 的结尾进行比较的字符串。</param>
        <summary>确定指定的源字符串是否以指定的后缀结尾。</summary>
        <returns>如果 <paramref name="suffix" /> 的长度小于或等于 <paramref name="source" /> 的长度，并且 <paramref name="source" /> 以 <paramref name="suffix" /> 结尾，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 每个字符串的开头和结尾空的子字符串 ("");因此，如果`suffix`是空字符串，此方法返回`true`。  
  
> [!NOTE]
>  如果可能，应调用字符串比较方法具有的类型参数的<xref:System.Globalization.CompareOptions>指定的预期的比较类型。 作为一般规则，用来进行比较用户界面中显示的字符串 （使用当前区域性） 的语言选项并指定<xref:System.Globalization.CompareOptions.Ordinal?displayProperty=nameWithType>或<xref:System.Globalization.CompareOptions.OrdinalIgnoreCase?displayProperty=nameWithType>安全比较。  
  
   
  
## Examples  
 下面的示例确定字符串是否是前缀或后缀的另一个字符串。  
  
 [!code-cpp[System.Globalization.CompareInfo.IsPrefixSuffix#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Globalization.CompareInfo.IsPrefixSuffix/CPP/isprefixsuffix.cpp#1)]
 [!code-csharp[System.Globalization.CompareInfo.IsPrefixSuffix#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Globalization.CompareInfo.IsPrefixSuffix/CS/isprefixsuffix.cs#1)]
 [!code-vb[System.Globalization.CompareInfo.IsPrefixSuffix#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Globalization.CompareInfo.IsPrefixSuffix/VB/isprefixsuffix.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> 为 <see langword="null" />。  
  
或 
 <paramref name="suffix" /> 为 <see langword="null" />。</exception>
        <altmember cref="M:System.Globalization.CompareInfo.IsPrefix(System.String,System.String,System.Globalization.CompareOptions)" />
      </Docs>
    </Member>
    <Member MemberName="IsSuffix">
      <MemberSignature Language="C#" Value="public virtual bool IsSuffix (string source, string suffix, System.Globalization.CompareOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsSuffix(string source, string suffix, valuetype System.Globalization.CompareOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Globalization.CompareInfo.IsSuffix(System.String,System.String,System.Globalization.CompareOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsSuffix (source As String, suffix As String, options As CompareOptions) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsSuffix(System::String ^ source, System::String ^ suffix, System::Globalization::CompareOptions options);" />
      <MemberSignature Language="F#" Value="abstract member IsSuffix : string * string * System.Globalization.CompareOptions -&gt; bool&#xA;override this.IsSuffix : string * string * System.Globalization.CompareOptions -&gt; bool" Usage="compareInfo.IsSuffix (source, suffix, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Globalization</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="suffix" Type="System.String" />
        <Parameter Name="options" Type="System.Globalization.CompareOptions" />
      </Parameters>
      <Docs>
        <param name="source">要在其中搜索的字符串。</param>
        <param name="suffix">要与 <paramref name="source" /> 的结尾进行比较的字符串。</param>
        <param name="options">一个值，用于定义应如何比较 <paramref name="source" /> 和 <paramref name="suffix" />。 <paramref name="options" /> 可以为其自身使用的枚举值 <see cref="F:System.Globalization.CompareOptions.Ordinal" />，或为以下一个或多个值的按位组合：<see cref="F:System.Globalization.CompareOptions.IgnoreCase" />、<see cref="F:System.Globalization.CompareOptions.IgnoreSymbols" />、<see cref="F:System.Globalization.CompareOptions.IgnoreNonSpace" />、<see cref="F:System.Globalization.CompareOptions.IgnoreWidth" /> 和 <see cref="F:System.Globalization.CompareOptions.IgnoreKanaType" />。</param>
        <summary>使用指定的 <see cref="T:System.Globalization.CompareOptions" /> 值确定指定的源字符串是否以指定的后缀结尾。</summary>
        <returns>如果 <paramref name="suffix" /> 的长度小于或等于 <paramref name="source" /> 的长度，并且 <paramref name="source" /> 以 <paramref name="suffix" /> 结尾，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 每个字符串的开头和结尾空的子字符串 ("");因此，如果`suffix`是空字符串，此方法返回`true`。  
  
 <xref:System.Globalization.CompareOptions.StringSort?displayProperty=nameWithType>值不能用于此方法。  
  
> [!NOTE]
>  如果可能，应调用字符串比较方法具有的类型参数的<xref:System.Globalization.CompareOptions>指定的预期的比较类型。 作为一般规则，用来进行比较用户界面中显示的字符串 （使用当前区域性） 的语言选项并指定<xref:System.Globalization.CompareOptions.Ordinal?displayProperty=nameWithType>或<xref:System.Globalization.CompareOptions.OrdinalIgnoreCase?displayProperty=nameWithType>安全比较。  
  
   
  
## Examples  
 下面的示例确定字符串是否是前缀或后缀的另一个字符串使用<xref:System.Globalization.CompareOptions>。  
  
 [!code-cpp[System.Globalization.CompareInfo.IsPrefixSuffixOpt#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Globalization.CompareInfo.IsPrefixSuffixOpt/CPP/isprefixsuffixopt.cpp#1)]
 [!code-csharp[System.Globalization.CompareInfo.IsPrefixSuffixOpt#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Globalization.CompareInfo.IsPrefixSuffixOpt/CS/isprefixsuffixopt.cs#1)]
 [!code-vb[System.Globalization.CompareInfo.IsPrefixSuffixOpt#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Globalization.CompareInfo.IsPrefixSuffixOpt/VB/isprefixsuffixopt.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> 为 <see langword="null" />。  
  
或 
 <paramref name="suffix" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="options" /> 包含无效的 <see cref="T:System.Globalization.CompareOptions" /> 值。</exception>
        <altmember cref="M:System.Globalization.CompareInfo.IsPrefix(System.String,System.String,System.Globalization.CompareOptions)" />
        <altmember cref="T:System.Globalization.CompareOptions" />
      </Docs>
    </Member>
    <MemberGroup MemberName="LastIndexOf">
      <AssemblyInfo>
        <AssemblyName>System.Globalization</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>返回某个值在一个字符串内或该字符串的一部分中最后一个匹配项的从零开始的索引。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public virtual int LastIndexOf (string source, char value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 LastIndexOf(string source, char value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Globalization.CompareInfo.LastIndexOf(System.String,System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function LastIndexOf (source As String, value As Char) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int LastIndexOf(System::String ^ source, char value);" />
      <MemberSignature Language="F#" Value="abstract member LastIndexOf : string * char -&gt; int&#xA;override this.LastIndexOf : string * char -&gt; int" Usage="compareInfo.LastIndexOf (source, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Globalization</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="value" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="source">要搜索的字符串。</param>
        <param name="value">要在 <paramref name="source" /> 中定位的字符。</param>
        <summary>搜索指定的字符，并返回整个源字符串内最后一个匹配项的从零开始的索引。</summary>
        <returns>如果找到，则为 <paramref name="value" /> 在 <paramref name="source" /> 内的最后一个匹配项从零开始的索引；否则为 -1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 向后从字符串的末尾处开始和结束时间字符串的开头搜索的源字符串。  
  
 此重载执行区分区域性的搜索。 如果字符是表示预构成的字符的 Unicode 值，例如连字"存储"(U + 00 C 6)，它可能被视为等效于正确的顺序，如 AE 及其组件的任何匹配项 (u+0041，U + 0045)，则根据区域性。 若要执行序号 （不区分区域性） 搜索，其中一个字符被视为等效于另一个字符，仅当 Unicode 值是相同的应调用具有类型参数的重载之一<xref:System.Globalization.CompareOptions>，并使用<xref:System.Globalization.CompareOptions.Ordinal>值。 重载的<xref:System.String.LastIndexOf%2A?displayProperty=nameWithType>该搜索的字符执行序号搜索，而这些搜索的字符串执行区分区域性的搜索。  
  
> [!NOTE]
>  如果可能，应调用字符串比较方法具有的类型参数的<xref:System.Globalization.CompareOptions>指定的预期的比较类型。 作为一般规则，用来进行比较用户界面中显示的字符串 （使用当前区域性） 的语言选项并指定<xref:System.Globalization.CompareOptions.Ordinal?displayProperty=nameWithType>或<xref:System.Globalization.CompareOptions.OrdinalIgnoreCase?displayProperty=nameWithType>安全比较。  
  
   
  
## Examples  
 下面的示例确定一个字符或字符串中的子字符串的第一个和最后一个匹配项的索引。  
  
 [!code-cpp[System.Globalization.CompareInfo.IndexOf#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Globalization.CompareInfo.IndexOf/CPP/indexof.cpp#1)]
 [!code-csharp[System.Globalization.CompareInfo.IndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Globalization.CompareInfo.IndexOf/CS/indexof.cs#1)]
 [!code-vb[System.Globalization.CompareInfo.IndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Globalization.CompareInfo.IndexOf/VB/indexof.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> 为 <see langword="null" />。</exception>
        <block subset="none" type="usage">
          <para>字符集包括可忽略字符，不考虑执行语言性的或区分区域性的排序时的字符。 在区分区域性的搜索中，如果<paramref name="value" />是可忽略字符，结果与移除了该字符的搜索等效。 在这种情况下，<see cref="M:System.Globalization.CompareInfo.LastIndexOf(System.String,System.Char)" />方法始终返回中的最后一个索引位置<paramref name="source" />以指示，结尾处找到的匹配项<paramref name="source" />。 在以下示例中，<see cref="M:System.Globalization.CompareInfo.LastIndexOf(System.String,System.Char)" />方法用于在两个字符串中查找软连字符 (U + 00AD)。 只有一个字符串包含软连字符。 在这两种情况下，因为软连字符是可忽略字符，该方法将返回以指示它已找到字符串的末尾匹配的字符串中的最后一个索引位置。  
  
[！ 代码 csharp[System.Globalization.CompareInfo.LastIndexOf#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.globalization.compareinfo.lastindexof/cs/lastignorable2.cs#3)] [！ 代码 vb[System.Globalization.CompareInfo.LastIndexOf#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.globalization.compareinfo.lastindexof/vb/lastignorable2.vb#3)]</para>
        </block>
        <altmember cref="M:System.Globalization.CompareInfo.IndexOf(System.String,System.Char)" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public virtual int LastIndexOf (string source, string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 LastIndexOf(string source, string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Globalization.CompareInfo.LastIndexOf(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function LastIndexOf (source As String, value As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int LastIndexOf(System::String ^ source, System::String ^ value);" />
      <MemberSignature Language="F#" Value="abstract member LastIndexOf : string * string -&gt; int&#xA;override this.LastIndexOf : string * string -&gt; int" Usage="compareInfo.LastIndexOf (source, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Globalization</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="source">要搜索的字符串。</param>
        <param name="value">要在 <paramref name="source" /> 中定位的字符串。</param>
        <summary>搜索指定的子字符串，并返回整个源字符串内最后一个匹配项的从零开始的索引。</summary>
        <returns>如果找到，则为 <paramref name="value" /> 在 <paramref name="source" /> 内的最后一个匹配项从零开始的索引；否则为 -1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 向后从字符串的末尾处开始和结束时间字符串的开头搜索的源字符串。  
  
 此重载执行区分区域性的搜索。 一个 Unicode 值，表示一个预构成的字符，例如连字"存储"(U + 00 C 6)，可能会被视为等效于正确的顺序，如 AE 字符的组件的任何匹配项 (u+0041，U + 0045)，则根据区域性。 若要执行序号 （不区分区域性） 搜索，其中的 Unicode 值进行比较，应调用具有类型参数的重载之一<xref:System.Globalization.CompareOptions>，并使用<xref:System.Globalization.CompareOptions.Ordinal?displayProperty=nameWithType>值。  
  
> [!NOTE]
>  如果可能，应调用字符串比较方法具有的类型参数的<xref:System.Globalization.CompareOptions>指定的预期的比较类型。 作为一般规则，用来进行比较用户界面中显示的字符串 （使用当前区域性） 的语言选项并指定<xref:System.Globalization.CompareOptions.Ordinal?displayProperty=nameWithType>或<xref:System.Globalization.CompareOptions.OrdinalIgnoreCase?displayProperty=nameWithType>安全比较。  
  
   
  
## Examples  
 下面的示例确定一个字符或字符串中的子字符串的第一个和最后一个匹配项的索引。  
  
 [!code-cpp[System.Globalization.CompareInfo.IndexOf#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Globalization.CompareInfo.IndexOf/CPP/indexof.cpp#1)]
 [!code-csharp[System.Globalization.CompareInfo.IndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Globalization.CompareInfo.IndexOf/CS/indexof.cs#1)]
 [!code-vb[System.Globalization.CompareInfo.IndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Globalization.CompareInfo.IndexOf/VB/indexof.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> 为 <see langword="null" />。  
  
或 
 <paramref name="value" /> 为 <see langword="null" />。</exception>
        <block subset="none" type="usage">
          <para>字符集包括可忽略字符，不考虑执行语言性的或区分区域性的排序时的字符。 在区分区域性的搜索中，如果 <paramref name="value" /> 包含一个可忽略字符，则结果与移除了该字符的搜索等效。 如果<paramref name="value" />仅包含一个或多个可忽略字符，<see cref="M:System.Globalization.CompareInfo.LastIndexOf(System.String,System.String)" />方法始终返回<paramref name="source" />。<see cref="P:System.String.Length" /> – 1，这表示中的最后一个索引位置<paramref name="source" />。 在以下示例中，<see cref="M:System.Globalization.CompareInfo.LastIndexOf(System.String,System.String)" />方法用于在两个字符串中查找三个子字符串 （软连字符 (U + 00AD)、 软连字符后跟"n"和软连字符后跟"m"）。 只有一个字符串包含软连字符。 每种情况下，因为软连字符是可忽略字符，因此结果是相同像软连字符不包含在<paramref name="value" />。 搜索的软连字符时，该方法将返回 6 和 5。 这些值对应于两个字符串中的最后一个字符的索引。  
  
[！ 代码 csharp[System.Globalization.CompareInfo.LastIndexOf#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.globalization.compareinfo.lastindexof/cs/lastignorable1.cs#2)] [！ 代码 vb[System.Globalization.CompareInfo.LastIndexOf#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.globalization.compareinfo.lastindexof/vb/lastignorable1.vb#2)]</para>
        </block>
        <altmember cref="M:System.Globalization.CompareInfo.IndexOf(System.String,System.Char)" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public virtual int LastIndexOf (string source, char value, System.Globalization.CompareOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 LastIndexOf(string source, char value, valuetype System.Globalization.CompareOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Globalization.CompareInfo.LastIndexOf(System.String,System.Char,System.Globalization.CompareOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function LastIndexOf (source As String, value As Char, options As CompareOptions) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int LastIndexOf(System::String ^ source, char value, System::Globalization::CompareOptions options);" />
      <MemberSignature Language="F#" Value="abstract member LastIndexOf : string * char * System.Globalization.CompareOptions -&gt; int&#xA;override this.LastIndexOf : string * char * System.Globalization.CompareOptions -&gt; int" Usage="compareInfo.LastIndexOf (source, value, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Globalization</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="value" Type="System.Char" />
        <Parameter Name="options" Type="System.Globalization.CompareOptions" />
      </Parameters>
      <Docs>
        <param name="source">要搜索的字符串。</param>
        <param name="value">要在 <paramref name="source" /> 中定位的字符。</param>
        <param name="options">一个值，用于定义应如何比较 <paramref name="source" /> 和 <paramref name="value" />。 <paramref name="options" /> 可以为枚举值 <see cref="F:System.Globalization.CompareOptions.Ordinal" />，或为以下一个或多个值的按位组合：<see cref="F:System.Globalization.CompareOptions.IgnoreCase" />、<see cref="F:System.Globalization.CompareOptions.IgnoreSymbols" />、<see cref="F:System.Globalization.CompareOptions.IgnoreNonSpace" />、<see cref="F:System.Globalization.CompareOptions.IgnoreWidth" /> 和 <see cref="F:System.Globalization.CompareOptions.IgnoreKanaType" />。</param>
        <summary>使用指定的 <see cref="T:System.Globalization.CompareOptions" /> 值，搜索指定的字符，并返回整个源字符串内最后一个匹配项的从零开始的索引。</summary>
        <returns>使用指定的比较选项，如果在<paramref name="value" /> 中找到 <paramref name="source" /> 的最后一个匹配项，则为从零开始的索引；否则为 -1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 向后从字符串的末尾处开始和结束时间字符串的开头搜索的源字符串。  
  
 <xref:System.Globalization.CompareOptions.StringSort?displayProperty=nameWithType>值不能用于此方法。  
  
 如果`options`不包括<xref:System.Globalization.CompareOptions.Ordinal>值，此重载执行区分区域性的搜索。 如果字符是表示预构成的字符的 Unicode 值，例如连字"存储"(U + 00 C 6)，它可能被视为等效于正确的顺序，如 AE 及其组件的任何匹配项 (u+0041，U + 0045)，则根据区域性。 如果`options`包括<xref:System.Globalization.CompareOptions.Ordinal>值，此重载将执行序号 （不区分区域性） 搜索。 仅当 Unicode 值是相同的一个字符被视为等效于另一个字符。 重载的<xref:System.String.LastIndexOf%2A?displayProperty=nameWithType>该搜索的字符执行序号搜索，而这些搜索的字符串执行区分区域性的搜索。  
  
> [!NOTE]
>  如果可能，应调用字符串比较方法具有的类型参数的<xref:System.Globalization.CompareOptions>指定的预期的比较类型。 作为一般规则，用来进行比较用户界面中显示的字符串 （使用当前区域性） 的语言选项并指定<xref:System.Globalization.CompareOptions.Ordinal?displayProperty=nameWithType>或<xref:System.Globalization.CompareOptions.OrdinalIgnoreCase?displayProperty=nameWithType>安全比较。  
  
   
  
## Examples  
 下面的示例确定一个字符或字符串中的子字符串的第一个和最后一个匹配项的索引。  
  
 [!code-cpp[System.Globalization.CompareInfo.IndexOf#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Globalization.CompareInfo.IndexOf/CPP/indexof.cpp#1)]
 [!code-csharp[System.Globalization.CompareInfo.IndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Globalization.CompareInfo.IndexOf/CS/indexof.cs#1)]
 [!code-vb[System.Globalization.CompareInfo.IndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Globalization.CompareInfo.IndexOf/VB/indexof.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="options" /> 包含无效的 <see cref="T:System.Globalization.CompareOptions" /> 值。</exception>
        <block subset="none" type="usage">
          <para>字符集包括可忽略字符，不考虑执行语言性的或区分区域性的排序时的字符。 在区分区域性的搜索中，如果<paramref name="value" />是可忽略字符，结果与移除了该字符的搜索等效。 在这种情况下，<see cref="M:System.Globalization.CompareInfo.LastIndexOf(System.String,System.Char,System.Globalization.CompareOptions)" />方法始终返回中的最后一个字符位置<paramref name="source" />以指示，结尾处找到的匹配项<paramref name="source" />。 在以下示例中，<see cref="M:System.Globalization.CompareInfo.LastIndexOf(System.String,System.Char,System.Globalization.CompareOptions)" />方法用于搜索的两个字符串的软连字符 (U + 00AD)。 只有一个字符串包含软连字符。 在这两种情况下，因为软连字符是可忽略字符，区分区域性的搜索将返回源字符串中的最后一个索引位置。 与此相反，序号搜索成功查找一个字符串中的软连字符和报告它不存在从第二个字符串。  
  
[！ 代码 csharp[System.Globalization.CompareInfo.LastIndexOf#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.globalization.compareinfo.lastindexof/cs/lastignorable3.cs#4)] [！ 代码 vb[System.Globalization.CompareInfo.LastIndexOf#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.globalization.compareinfo.lastindexof/vb/lastignorable3.vb#4)]</para>
        </block>
        <altmember cref="M:System.Globalization.CompareInfo.IndexOf(System.String,System.Char)" />
        <altmember cref="T:System.Globalization.CompareOptions" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public virtual int LastIndexOf (string source, char value, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 LastIndexOf(string source, char value, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Globalization.CompareInfo.LastIndexOf(System.String,System.Char,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function LastIndexOf (source As String, value As Char, startIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int LastIndexOf(System::String ^ source, char value, int startIndex);" />
      <MemberSignature Language="F#" Value="abstract member LastIndexOf : string * char * int -&gt; int&#xA;override this.LastIndexOf : string * char * int -&gt; int" Usage="compareInfo.LastIndexOf (source, value, startIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Globalization</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="value" Type="System.Char" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="source">要搜索的字符串。</param>
        <param name="value">要在 <paramref name="source" /> 中定位的字符。</param>
        <param name="startIndex">向后搜索的从零开始的起始索引。</param>
        <summary>搜索指定的字符，并返回源字符串内从字符串开头到指定的索引位置这一部分中最后一个匹配项的从零开始的索引。</summary>
        <returns>如果在部分 <paramref name="value" />（从 <paramref name="source" /> 的开头到 <paramref name="source" /> 这一部分）中找到 <paramref name="startIndex" /> 的最后一个匹配项，则为该项的从零开始的索引；否则为 -1。 如果 <paramref name="startIndex" /> 为可忽略字符，则将返回 <paramref name="value" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 源字符串是搜索处开始向后`startIndex`和结束时间字符串的开头。  
  
 此重载执行区分区域性的搜索。 如果字符是表示预构成的字符的 Unicode 值，例如连字"存储"(U + 00 C 6)，它可能被视为等效于正确的顺序，如 AE 及其组件的任何匹配项 (u+0041，U + 0045)，则根据区域性。 若要执行序号 （不区分区域性） 搜索，其中一个字符被视为等效于另一个字符，仅当 Unicode 值是相同的应调用具有类型参数的重载之一<xref:System.Globalization.CompareOptions>，并使用<xref:System.Globalization.CompareOptions.Ordinal>值。 重载的<xref:System.String.LastIndexOf%2A?displayProperty=nameWithType>该搜索的字符执行序号搜索，而这些搜索的字符串执行区分区域性的搜索。  
  
> [!NOTE]
>  如果可能，应调用字符串比较方法具有的类型参数的<xref:System.Globalization.CompareOptions>指定的预期的比较类型。 作为一般规则，用来进行比较用户界面中显示的字符串 （使用当前区域性） 的语言选项并指定<xref:System.Globalization.CompareOptions.Ordinal?displayProperty=nameWithType>或<xref:System.Globalization.CompareOptions.OrdinalIgnoreCase?displayProperty=nameWithType>安全比较。  
  
   
  
## Examples  
 下面的示例确定一个字符或字符串的一部分中的子字符串的第一个和最后一个匹配项的索引。 请注意，<xref:System.Globalization.CompareInfo.IndexOf%2A>并<xref:System.Globalization.CompareInfo.LastIndexOf%2A>中的字符串，即使使用相同的不同部分搜索`startIndex`参数。  
  
 [!code-cpp[System.Globalization.CompareInfo.IndexOfInt#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Globalization.CompareInfo.IndexOfInt/CPP/indexofint.cpp#1)]
 [!code-csharp[System.Globalization.CompareInfo.IndexOfInt#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Globalization.CompareInfo.IndexOfInt/CS/indexofint.cs#1)]
 [!code-vb[System.Globalization.CompareInfo.IndexOfInt#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Globalization.CompareInfo.IndexOfInt/VB/indexofint.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> 超出了 <paramref name="source" /> 的有效索引范围。</exception>
        <block subset="none" type="usage">
          <para>字符集包括可忽略字符，不考虑执行语言性的或区分区域性的排序时的字符。 在区分区域性的搜索中，如果<paramref name="value" />是可忽略字符，结果与移除了该字符的搜索等效。 在这种情况下，<see cref="M:System.Globalization.CompareInfo.LastIndexOf(System.String,System.Char,System.Int32)" />方法始终返回<paramref name="startIndex" />，即搜索开始处的字符位置。 在以下示例中，<see cref="M:System.Globalization.CompareInfo.LastIndexOf(System.String,System.Char,System.Int32)" />方法用于在两个字符串中查找软连字符 (U + 00AD) 之前最后一个"m"。 只有一个字符串包含软连字符。 在这两种情况下，因为软连字符是可忽略字符，该方法返回的"m"，即值的索引位置的<paramref name="startIndex" />。  
  
[！ 代码 csharp[System.Globalization.CompareInfo.LastIndexOf#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.globalization.compareinfo.lastindexof/cs/lastignorable4.cs#5)] [！ 代码 vb[System.Globalization.CompareInfo.LastIndexOf#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.globalization.compareinfo.lastindexof/vb/lastignorable4.vb#5)]</para>
        </block>
        <altmember cref="M:System.Globalization.CompareInfo.IndexOf(System.String,System.Char)" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public virtual int LastIndexOf (string source, string value, System.Globalization.CompareOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 LastIndexOf(string source, string value, valuetype System.Globalization.CompareOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Globalization.CompareInfo.LastIndexOf(System.String,System.String,System.Globalization.CompareOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function LastIndexOf (source As String, value As String, options As CompareOptions) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int LastIndexOf(System::String ^ source, System::String ^ value, System::Globalization::CompareOptions options);" />
      <MemberSignature Language="F#" Value="abstract member LastIndexOf : string * string * System.Globalization.CompareOptions -&gt; int&#xA;override this.LastIndexOf : string * string * System.Globalization.CompareOptions -&gt; int" Usage="compareInfo.LastIndexOf (source, value, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Globalization</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="options" Type="System.Globalization.CompareOptions" />
      </Parameters>
      <Docs>
        <param name="source">要搜索的字符串。</param>
        <param name="value">要在 <paramref name="source" /> 中定位的字符串。</param>
        <param name="options">一个值，用于定义应如何比较 <paramref name="source" /> 和 <paramref name="value" />。 <paramref name="options" /> 可以为枚举值 <see cref="F:System.Globalization.CompareOptions.Ordinal" />，或为以下一个或多个值的按位组合：<see cref="F:System.Globalization.CompareOptions.IgnoreCase" />、<see cref="F:System.Globalization.CompareOptions.IgnoreSymbols" />、<see cref="F:System.Globalization.CompareOptions.IgnoreNonSpace" />、<see cref="F:System.Globalization.CompareOptions.IgnoreWidth" /> 和 <see cref="F:System.Globalization.CompareOptions.IgnoreKanaType" />。</param>
        <summary>使用指定的 <see cref="T:System.Globalization.CompareOptions" /> 值，搜索指定的子字符串，并返回整个源字符串内最后一个匹配项的从零开始的索引。</summary>
        <returns>使用指定的比较选项，如果在<paramref name="value" /> 中找到 <paramref name="source" /> 的最后一个匹配项，则为从零开始的索引；否则为 -1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 向后从字符串的末尾处开始和结束时间字符串的开头搜索的源字符串。  
  
 <xref:System.Globalization.CompareOptions.StringSort?displayProperty=nameWithType>值不能用于此方法。  
  
 如果`options`不包括<xref:System.Globalization.CompareOptions.Ordinal>值，此重载执行区分区域性的搜索。 一个 Unicode 值，表示一个预构成的字符，例如连字"存储"(U + 00 C 6)，可能会被视为等效于正确的顺序，如 AE 字符的组件的任何匹配项 (u+0041，U + 0045)，则根据区域性。 如果`options`包括<xref:System.Globalization.CompareOptions.Ordinal>值，此重载将执行序号 （不区分区域性） 搜索，其中的 Unicode 值进行比较。  
  
> [!NOTE]
>  如果可能，应调用字符串比较方法具有的类型参数的<xref:System.Globalization.CompareOptions>指定的预期的比较类型。 作为一般规则，用来进行比较用户界面中显示的字符串 （使用当前区域性） 的语言选项并指定<xref:System.Globalization.CompareOptions.Ordinal?displayProperty=nameWithType>或<xref:System.Globalization.CompareOptions.OrdinalIgnoreCase?displayProperty=nameWithType>安全比较。  
  
   
  
## Examples  
 下面的示例确定一个字符或字符串中的子字符串的第一个和最后一个匹配项的索引。  
  
 [!code-cpp[System.Globalization.CompareInfo.IndexOf#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Globalization.CompareInfo.IndexOf/CPP/indexof.cpp#1)]
 [!code-csharp[System.Globalization.CompareInfo.IndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Globalization.CompareInfo.IndexOf/CS/indexof.cs#1)]
 [!code-vb[System.Globalization.CompareInfo.IndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Globalization.CompareInfo.IndexOf/VB/indexof.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> 为 <see langword="null" />。  
  
或 
 <paramref name="value" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="options" /> 包含无效的 <see cref="T:System.Globalization.CompareOptions" /> 值。</exception>
        <block subset="none" type="usage">
          <para>字符集包括可忽略字符，不考虑执行语言性的或区分区域性的排序时的字符。 在区分区域性的搜索 (即，如果 <paramref name="options" /> 不是 <see cref="F:System.Globalization.CompareOptions.Ordinal" /> 或 <see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" />) 中，如果 <paramref name="value" /> 包含一个可忽略字符，则结果与移除了该字符的搜索等效。 如果<paramref name="value" />仅包含一个或多个可忽略字符，<see cref="M:System.Globalization.CompareInfo.LastIndexOf(System.String,System.String,System.Globalization.CompareOptions)" />方法始终返回<paramref name="source" />。<see cref="P:System.String.Length" /> – 1，这表示中的最后一个索引位置<paramref name="source" />。 在以下示例中，<see cref="M:System.Globalization.CompareInfo.LastIndexOf(System.String,System.String,System.Globalization.CompareOptions)" />方法用于在两个字符串中查找三个子字符串 （软连字符 (U + 00AD)、 软连字符后跟"n"和软连字符后跟"m"）。 只有一个字符串包含软连字符。 由于软连字符是一个可忽略字符，区分区域性的搜索将返回相同的值，它将返回如果搜索字符串中未包含软连字符。 序号搜索，但是，成功地在一个字符串中查找软连字符，并报告它不存在从第二个字符串。  
  
[！ 代码 csharp[System.Globalization.CompareInfo.LastIndexOf#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.globalization.compareinfo.lastindexof/cs/lastignorable5.cs#6)] [！ 代码 vb[System.Globalization.CompareInfo.LastIndexOf#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.globalization.compareinfo.lastindexof/vb/lastignorable5.vb#6)]</para>
        </block>
        <altmember cref="M:System.Globalization.CompareInfo.IndexOf(System.String,System.Char)" />
        <altmember cref="T:System.Globalization.CompareOptions" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public virtual int LastIndexOf (string source, string value, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 LastIndexOf(string source, string value, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Globalization.CompareInfo.LastIndexOf(System.String,System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function LastIndexOf (source As String, value As String, startIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int LastIndexOf(System::String ^ source, System::String ^ value, int startIndex);" />
      <MemberSignature Language="F#" Value="abstract member LastIndexOf : string * string * int -&gt; int&#xA;override this.LastIndexOf : string * string * int -&gt; int" Usage="compareInfo.LastIndexOf (source, value, startIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Globalization</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="source">要搜索的字符串。</param>
        <param name="value">要在 <paramref name="source" /> 中定位的字符串。</param>
        <param name="startIndex">向后搜索的从零开始的起始索引。</param>
        <summary>搜索指定的子字符串，并返回源字符串内从字符串开头到指定的索引位置这一部分中最后一个匹配项的从零开始的索引。</summary>
        <returns>如果在部分 <paramref name="value" />（从 <paramref name="source" /> 的开头到 <paramref name="source" /> 这一部分）中找到 <paramref name="startIndex" /> 的最后一个匹配项，则为该项的从零开始的索引；否则为 -1。 如果 <paramref name="startIndex" /> 为可忽略字符，则将返回 <paramref name="value" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 源字符串是搜索处开始向后`startIndex`和结束时间字符串的开头。  
  
 此重载执行区分区域性的搜索。 一个 Unicode 值，表示一个预构成的字符，例如连字"存储"(U + 00 C 6)，可能会被视为等效于正确的顺序，如 AE 字符的组件的任何匹配项 (u+0041，U + 0045)，则根据区域性。 若要执行序号 （不区分区域性） 搜索，其中的 Unicode 值进行比较，应调用具有类型参数的重载之一<xref:System.Globalization.CompareOptions>，并使用<xref:System.Globalization.CompareOptions.Ordinal?displayProperty=nameWithType>值。  
  
> [!NOTE]
>  如果可能，应调用字符串比较方法具有的类型参数的<xref:System.Globalization.CompareOptions>指定的预期的比较类型。 作为一般规则，用来进行比较用户界面中显示的字符串 （使用当前区域性） 的语言选项并指定<xref:System.Globalization.CompareOptions.Ordinal?displayProperty=nameWithType>或<xref:System.Globalization.CompareOptions.OrdinalIgnoreCase?displayProperty=nameWithType>安全比较。  
  
   
  
## Examples  
 下面的示例确定一个字符或字符串的一部分中的子字符串的第一个和最后一个匹配项的索引。 请注意，<xref:System.Globalization.CompareInfo.IndexOf%2A>并<xref:System.Globalization.CompareInfo.LastIndexOf%2A>中的字符串，即使使用相同的不同部分搜索`startIndex`参数。  
  
 [!code-cpp[System.Globalization.CompareInfo.IndexOfInt#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Globalization.CompareInfo.IndexOfInt/CPP/indexofint.cpp#1)]
 [!code-csharp[System.Globalization.CompareInfo.IndexOfInt#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Globalization.CompareInfo.IndexOfInt/CS/indexofint.cs#1)]
 [!code-vb[System.Globalization.CompareInfo.IndexOfInt#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Globalization.CompareInfo.IndexOfInt/VB/indexofint.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> 为 <see langword="null" />。  
  
或 
 <paramref name="value" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> 超出了 <paramref name="source" /> 的有效索引范围。</exception>
        <block subset="none" type="usage">
          <para>字符集包括可忽略字符，不考虑执行语言性的或区分区域性的排序时的字符。 在区分区域性的搜索中，如果 <paramref name="value" /> 包含一个可忽略字符，则结果与移除了该字符的搜索等效。 如果<paramref name="value" />仅包含一个或多个可忽略字符，<see cref="M:System.Globalization.CompareInfo.LastIndexOf(System.String,System.String,System.Int32)" />方法始终返回<paramref name="startIndex" />，即搜索开始处的字符位置。 在以下示例中，<see cref="M:System.Globalization.CompareInfo.LastIndexOf(System.String,System.String,System.Int32)" />方法用于查找子字符串，其中包含软连字符 (U + 00AD) 并且之前或在字符串中包含的最后一个"m"。 搜索字符串中的软连字符将被忽略，因为调用要查找的子字符串，包含软连字符和"m"返回"m"的位置在字符串中，而调用它以查找的子字符串，包含软连字符和"n"返回的方法 "n"的位置。 当搜索字符串中包含仅软连字符时，方法会返回"m"，它表示的值的索引<paramref name="startIndex" />。  
  
[！ 代码 csharp[System.Globalization.CompareInfo.LastIndexOf#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.globalization.compareinfo.lastindexof/cs/lastignorable6.cs#7)] [！ 代码 vb[System.Globalization.CompareInfo.LastIndexOf#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.globalization.compareinfo.lastindexof/vb/lastignorable6.vb#7)]</para>
        </block>
        <altmember cref="M:System.Globalization.CompareInfo.IndexOf(System.String,System.Char)" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public virtual int LastIndexOf (string source, char value, int startIndex, System.Globalization.CompareOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 LastIndexOf(string source, char value, int32 startIndex, valuetype System.Globalization.CompareOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Globalization.CompareInfo.LastIndexOf(System.String,System.Char,System.Int32,System.Globalization.CompareOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function LastIndexOf (source As String, value As Char, startIndex As Integer, options As CompareOptions) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int LastIndexOf(System::String ^ source, char value, int startIndex, System::Globalization::CompareOptions options);" />
      <MemberSignature Language="F#" Value="abstract member LastIndexOf : string * char * int * System.Globalization.CompareOptions -&gt; int&#xA;override this.LastIndexOf : string * char * int * System.Globalization.CompareOptions -&gt; int" Usage="compareInfo.LastIndexOf (source, value, startIndex, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Globalization</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="value" Type="System.Char" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="options" Type="System.Globalization.CompareOptions" />
      </Parameters>
      <Docs>
        <param name="source">要搜索的字符串。</param>
        <param name="value">要在 <paramref name="source" /> 中定位的字符。</param>
        <param name="startIndex">向后搜索的从零开始的起始索引。</param>
        <param name="options">一个值，用于定义应如何比较 <paramref name="source" /> 和 <paramref name="value" />。 <paramref name="options" /> 可以为枚举值 <see cref="F:System.Globalization.CompareOptions.Ordinal" />，或为以下一个或多个值的按位组合：<see cref="F:System.Globalization.CompareOptions.IgnoreCase" />、<see cref="F:System.Globalization.CompareOptions.IgnoreSymbols" />、<see cref="F:System.Globalization.CompareOptions.IgnoreNonSpace" />、<see cref="F:System.Globalization.CompareOptions.IgnoreWidth" /> 和 <see cref="F:System.Globalization.CompareOptions.IgnoreKanaType" />。</param>
        <summary>使用指定的 <see cref="T:System.Globalization.CompareOptions" /> 值，搜索指定的字符，并返回源字符串内从字符串开头到指定的索引位置这一部分中最后一个匹配项的从零开始的索引。</summary>
        <returns>使用指定的比较选项，如果在 <paramref name="value" /> 中从 <paramref name="source" /> 一直到 <paramref name="source" /> 的开始这部分找到 <paramref name="startIndex" /> 的最后一个匹配项，则为该项的从零开始的索引；否则为 -1。 如果 <paramref name="startIndex" /> 为可忽略字符，则将返回 <paramref name="value" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 源字符串是搜索处开始向后`startIndex`和结束时间字符串的开头。  
  
 <xref:System.Globalization.CompareOptions.StringSort?displayProperty=nameWithType>值不能用于此方法。  
  
 如果`options`不包括<xref:System.Globalization.CompareOptions.Ordinal>值，此重载执行区分区域性的搜索。 如果字符是表示预构成的字符的 Unicode 值，例如连字"存储"(U + 00 C 6)，它可能被视为等效于正确的顺序，如 AE 及其组件的任何匹配项 (u+0041，U + 0045)，则根据区域性。 如果`options`包括<xref:System.Globalization.CompareOptions.Ordinal>值，此重载将执行序号 （不区分区域性） 搜索。 仅当 Unicode 值是相同的一个字符被视为等效于另一个字符。 重载的<xref:System.String.LastIndexOf%2A?displayProperty=nameWithType>该搜索的字符执行序号搜索，而这些搜索的字符串执行区分区域性的搜索。  
  
> [!NOTE]
>  如果可能，应调用字符串比较方法具有的类型参数的<xref:System.Globalization.CompareOptions>指定的预期的比较类型。 作为一般规则，用来进行比较用户界面中显示的字符串 （使用当前区域性） 的语言选项并指定<xref:System.Globalization.CompareOptions.Ordinal?displayProperty=nameWithType>或<xref:System.Globalization.CompareOptions.OrdinalIgnoreCase?displayProperty=nameWithType>安全比较。  
  
   
  
## Examples  
 下面的示例确定一个字符或字符串的一部分中的子字符串的第一个和最后一个匹配项的索引。 请注意，<xref:System.Globalization.CompareInfo.IndexOf%2A>并<xref:System.Globalization.CompareInfo.LastIndexOf%2A>中的字符串，即使使用相同的不同部分搜索`startIndex`参数。  
  
 [!code-cpp[System.Globalization.CompareInfo.IndexOfInt#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Globalization.CompareInfo.IndexOfInt/CPP/indexofint.cpp#1)]
 [!code-csharp[System.Globalization.CompareInfo.IndexOfInt#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Globalization.CompareInfo.IndexOfInt/CS/indexofint.cs#1)]
 [!code-vb[System.Globalization.CompareInfo.IndexOfInt#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Globalization.CompareInfo.IndexOfInt/VB/indexofint.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> 超出了 <paramref name="source" /> 的有效索引范围。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="options" /> 包含无效的 <see cref="T:System.Globalization.CompareOptions" /> 值。</exception>
        <block subset="none" type="usage">
          <para>字符集包括可忽略字符，不考虑执行语言性的或区分区域性的排序时的字符。 在区分区域性的搜索中，如果<paramref name="value" />是可忽略字符，结果与移除了该字符的搜索等效。 在这种情况下，<see cref="M:System.Globalization.CompareInfo.LastIndexOf(System.String,System.Char,System.Int32,System.Globalization.CompareOptions)" />方法始终返回<paramref name="startIndex" />，即搜索开始处的字符位置。 在以下示例中，<see cref="M:System.Globalization.CompareInfo.LastIndexOf(System.String,System.Char,System.Int32,System.Globalization.CompareOptions)" />方法用于在两个字符串中查找软连字符 (U + 00AD) 之前最后一个"m"。 只有一个字符串包含软连字符。 在这两种情况下，因为软连字符是可忽略字符，区分区域性的搜索将返回"m"的索引位置。 序号搜索，但是，成功地在一个字符串中查找软连字符，并报告它不存在从第二个字符串。  
  
[！ 代码 csharp[System.Globalization.CompareInfo.LastIndexOf#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.globalization.compareinfo.lastindexof/cs/lastignorable7.cs#8)] [！ 代码 vb[System.Globalization.CompareInfo.LastIndexOf#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.globalization.compareinfo.lastindexof/vb/lastignorable7.vb#8)]</para>
        </block>
        <altmember cref="M:System.Globalization.CompareInfo.IndexOf(System.String,System.Char)" />
        <altmember cref="T:System.Globalization.CompareOptions" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public virtual int LastIndexOf (string source, char value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 LastIndexOf(string source, char value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Globalization.CompareInfo.LastIndexOf(System.String,System.Char,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function LastIndexOf (source As String, value As Char, startIndex As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int LastIndexOf(System::String ^ source, char value, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="abstract member LastIndexOf : string * char * int * int -&gt; int&#xA;override this.LastIndexOf : string * char * int * int -&gt; int" Usage="compareInfo.LastIndexOf (source, value, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Globalization</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="value" Type="System.Char" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="source">要搜索的字符串。</param>
        <param name="value">要在 <paramref name="source" /> 中定位的字符。</param>
        <param name="startIndex">向后搜索的从零开始的起始索引。</param>
        <param name="count">要搜索的部分中的元素数。</param>
        <summary>搜索指定的字符，并返回源字符串内包含指定的元素数、以指定的索引位置结尾的部分中最后一个匹配项的从零开始的索引。</summary>
        <returns>在包含 <paramref name="value" /> 所指定的元素数并以 <paramref name="source" /> 结尾的这部分 <paramref name="count" /> 中，如果找到 <paramref name="startIndex" /> 的最后一个匹配项，则为该项的从零开始的索引；否则为 -1。 如果 <paramref name="startIndex" /> 为可忽略字符，则将返回 <paramref name="value" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 源字符串是搜索处开始向后`startIndex`结束时间`startIndex`  -  `count` + 1。  
  
 此重载执行区分区域性的搜索。 如果字符是表示预构成的字符的 Unicode 值，例如连字"存储"(U + 00 C 6)，它可能被视为等效于正确的顺序，如 AE 及其组件的任何匹配项 (u+0041，U + 0045)，则根据区域性。 若要执行序号 （不区分区域性） 搜索，其中一个字符被视为等效于另一个字符，仅当 Unicode 值是相同的应调用具有类型参数的重载之一<xref:System.Globalization.CompareOptions>，并使用<xref:System.Globalization.CompareOptions.Ordinal>值。 重载的<xref:System.String.LastIndexOf%2A?displayProperty=nameWithType>该搜索的字符执行序号搜索，而这些搜索的字符串执行区分区域性的搜索。  
  
> [!NOTE]
>  如果可能，应调用字符串比较方法具有的类型参数的<xref:System.Globalization.CompareOptions>指定的预期的比较类型。 作为一般规则，用来进行比较用户界面中显示的字符串 （使用当前区域性） 的语言选项并指定<xref:System.Globalization.CompareOptions.Ordinal?displayProperty=nameWithType>或<xref:System.Globalization.CompareOptions.OrdinalIgnoreCase?displayProperty=nameWithType>安全比较。  
  
   
  
## Examples  
 下面的示例确定一个字符或字符串的一部分中的子字符串的第一个和最后一个匹配项的索引。  
  
 [!code-cpp[System.Globalization.CompareInfo.IndexOfIntInt#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Globalization.CompareInfo.IndexOfIntInt/CPP/indexofintint.cpp#1)]
 [!code-csharp[System.Globalization.CompareInfo.IndexOfIntInt#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Globalization.CompareInfo.IndexOfIntInt/CS/indexofintint.cs#1)]
 [!code-vb[System.Globalization.CompareInfo.IndexOfIntInt#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Globalization.CompareInfo.IndexOfIntInt/VB/indexofintint.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> 超出了 <paramref name="source" /> 的有效索引范围。  
  
或 
 <paramref name="count" /> 小于零。  
  
或 
 <paramref name="startIndex" /> 和 <paramref name="count" /> 未在 <paramref name="source" /> 中指定有效部分。</exception>
        <block subset="none" type="usage">
          <para>字符集包括可忽略字符，不考虑执行语言性的或区分区域性的排序时的字符。 在区分区域性的搜索中，如果<paramref name="value" />是可忽略字符，结果与移除了该字符的搜索等效。 在这种情况下，<see cref="M:System.Globalization.CompareInfo.LastIndexOf(System.String,System.Char,System.Int32,System.Int32)" />方法始终返回<paramref name="startIndex" />，即搜索开始处的字符位置。 在以下示例中，<see cref="M:System.Globalization.CompareInfo.LastIndexOf(System.String,System.Char,System.Int32,System.Int32)" />方法用于在两个字符串中查找软连字符 (U + 00AD) 之前最后一个"m"。 只有一个字符串包含软连字符。 在这两种情况下，因为软连字符是可忽略字符，该方法返回的"m"，即值的索引位置的<paramref name="startIndex" />。  
  
[！ 代码 csharp[System.Globalization.CompareInfo.LastIndexOf#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.globalization.compareinfo.lastindexof/cs/lastignorable8.cs#9)] [！ 代码 vb[System.Globalization.CompareInfo.LastIndexOf#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.globalization.compareinfo.lastindexof/vb/lastignorable8.vb#9)]</para>
        </block>
        <altmember cref="M:System.Globalization.CompareInfo.IndexOf(System.String,System.Char)" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public virtual int LastIndexOf (string source, string value, int startIndex, System.Globalization.CompareOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 LastIndexOf(string source, string value, int32 startIndex, valuetype System.Globalization.CompareOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Globalization.CompareInfo.LastIndexOf(System.String,System.String,System.Int32,System.Globalization.CompareOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function LastIndexOf (source As String, value As String, startIndex As Integer, options As CompareOptions) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int LastIndexOf(System::String ^ source, System::String ^ value, int startIndex, System::Globalization::CompareOptions options);" />
      <MemberSignature Language="F#" Value="abstract member LastIndexOf : string * string * int * System.Globalization.CompareOptions -&gt; int&#xA;override this.LastIndexOf : string * string * int * System.Globalization.CompareOptions -&gt; int" Usage="compareInfo.LastIndexOf (source, value, startIndex, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Globalization</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="options" Type="System.Globalization.CompareOptions" />
      </Parameters>
      <Docs>
        <param name="source">要搜索的字符串。</param>
        <param name="value">要在 <paramref name="source" /> 中定位的字符串。</param>
        <param name="startIndex">向后搜索的从零开始的起始索引。</param>
        <param name="options">一个值，用于定义应如何比较 <paramref name="source" /> 和 <paramref name="value" />。 <paramref name="options" /> 可以为枚举值 <see cref="F:System.Globalization.CompareOptions.Ordinal" />，或为以下一个或多个值的按位组合：<see cref="F:System.Globalization.CompareOptions.IgnoreCase" />、<see cref="F:System.Globalization.CompareOptions.IgnoreSymbols" />、<see cref="F:System.Globalization.CompareOptions.IgnoreNonSpace" />、<see cref="F:System.Globalization.CompareOptions.IgnoreWidth" /> 和 <see cref="F:System.Globalization.CompareOptions.IgnoreKanaType" />。</param>
        <summary>使用指定的 <see cref="T:System.Globalization.CompareOptions" /> 值，搜索指定的子字符串，并返回源字符串内从字符串开头到指定的索引位置这一部分中最后一个匹配项的从零开始的索引。</summary>
        <returns>使用指定的比较选项，如果在 <paramref name="value" /> 中从 <paramref name="source" /> 一直到 <paramref name="source" /> 的开始这部分找到 <paramref name="startIndex" /> 的最后一个匹配项，则为该项的从零开始的索引；否则为 -1。 如果 <paramref name="startIndex" /> 为可忽略字符，则将返回 <paramref name="value" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 源字符串是搜索处开始向后`startIndex`和结束时间字符串的开头。  
  
 <xref:System.Globalization.CompareOptions.StringSort?displayProperty=nameWithType>值不能用于此方法。  
  
 如果`options`不包括<xref:System.Globalization.CompareOptions.Ordinal>值，此重载执行区分区域性的搜索。 一个 Unicode 值，表示一个预构成的字符，例如连字"存储"(U + 00 C 6)，可能会被视为等效于正确的顺序，如 AE 字符的组件的任何匹配项 (u+0041，U + 0045)，则根据区域性。 如果`options`包括<xref:System.Globalization.CompareOptions.Ordinal>值，此重载将执行序号 （不区分区域性） 搜索，其中的 Unicode 值进行比较。  
  
> [!NOTE]
>  如果可能，应调用字符串比较方法具有的类型参数的<xref:System.Globalization.CompareOptions>指定的预期的比较类型。 作为一般规则，用来进行比较用户界面中显示的字符串 （使用当前区域性） 的语言选项并指定<xref:System.Globalization.CompareOptions.Ordinal?displayProperty=nameWithType>或<xref:System.Globalization.CompareOptions.OrdinalIgnoreCase?displayProperty=nameWithType>安全比较。  
  
   
  
## Examples  
 下面的示例确定一个字符或字符串的一部分中的子字符串的第一个和最后一个匹配项的索引。 请注意，<xref:System.Globalization.CompareInfo.IndexOf%2A>并<xref:System.Globalization.CompareInfo.LastIndexOf%2A>中的字符串，即使使用相同的不同部分搜索`startIndex`参数。  
  
 [!code-cpp[System.Globalization.CompareInfo.IndexOfInt#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Globalization.CompareInfo.IndexOfInt/CPP/indexofint.cpp#1)]
 [!code-csharp[System.Globalization.CompareInfo.IndexOfInt#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Globalization.CompareInfo.IndexOfInt/CS/indexofint.cs#1)]
 [!code-vb[System.Globalization.CompareInfo.IndexOfInt#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Globalization.CompareInfo.IndexOfInt/VB/indexofint.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> 为 <see langword="null" />。  
  
或 
 <paramref name="value" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> 超出了 <paramref name="source" /> 的有效索引范围。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="options" /> 包含无效的 <see cref="T:System.Globalization.CompareOptions" /> 值。</exception>
        <block subset="none" type="usage">
          <para>字符集包括可忽略字符，不考虑执行语言性的或区分区域性的排序时的字符。 在区分区域性的搜索 (即，如果 <paramref name="options" /> 不是 <see cref="F:System.Globalization.CompareOptions.Ordinal" /> 或 <see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" />) 中，如果 <paramref name="value" /> 包含一个可忽略字符，则结果与移除了该字符的搜索等效。 如果<paramref name="value" />仅包含一个或多个可忽略字符，<see cref="M:System.Globalization.CompareInfo.LastIndexOf(System.String,System.String,System.Int32,System.Globalization.CompareOptions)" />方法始终返回<paramref name="startIndex" />，即搜索开始处的字符位置。  
  
在以下示例中，<see cref="M:System.Globalization.CompareInfo.LastIndexOf(System.String,System.String,System.Int32,System.Globalization.CompareOptions)" />方法用于查找的软连字符 (U + 00AD) 后, 跟"m"，从最后一个"m"两个字符串中开始的位置。 只有一个字符串包含必需的子字符串。 在这两种情况下，因为软连字符是可忽略字符，因此，在执行区分区域性的比较时，该方法在字符串中返回索引“m”。 注意对于第一个字符串，包含软连字符后跟“m”，该方法无法返回该软连字符的索引，而是返回“m”的索引。 只有当此方法执行序号比较时，它才会在第一个字符串中返回软连字符的索引。  
  
[！ 代码 csharp[System.Globalization.CompareInfo.LastIndexOf#15](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.globalization.compareinfo.lastindexof/cs/lastignorable14.cs#15)] [！ 代码 vb[System.Globalization.CompareInfo.LastIndexOf#15](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.globalization.compareinfo.lastindexof/vb/lastignorable14.vb#15)]</para>
        </block>
        <altmember cref="M:System.Globalization.CompareInfo.IndexOf(System.String,System.Char)" />
        <altmember cref="T:System.Globalization.CompareOptions" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public virtual int LastIndexOf (string source, string value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 LastIndexOf(string source, string value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Globalization.CompareInfo.LastIndexOf(System.String,System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function LastIndexOf (source As String, value As String, startIndex As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int LastIndexOf(System::String ^ source, System::String ^ value, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="abstract member LastIndexOf : string * string * int * int -&gt; int&#xA;override this.LastIndexOf : string * string * int * int -&gt; int" Usage="compareInfo.LastIndexOf (source, value, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Globalization</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="source">要搜索的字符串。</param>
        <param name="value">要在 <paramref name="source" /> 中定位的字符串。</param>
        <param name="startIndex">向后搜索的从零开始的起始索引。</param>
        <param name="count">要搜索的部分中的元素数。</param>
        <summary>搜索指定的子字符串，并返回源字符串内包含指定的元素数、以指定的索引位置结尾的部分中最后一个匹配项的从零开始的索引。</summary>
        <returns>在包含 <paramref name="value" /> 所指定的元素数并以 <paramref name="source" /> 结尾的这部分 <paramref name="count" /> 中，如果找到 <paramref name="startIndex" /> 的最后一个匹配项，则为该项的从零开始的索引；否则为 -1。 如果 <paramref name="startIndex" /> 为可忽略字符，则将返回 <paramref name="value" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 源字符串是搜索处开始向后`startIndex`结束时间`startIndex`  -  `count` + 1。  
  
 此重载执行区分区域性的搜索。 一个 Unicode 值，表示一个预构成的字符，例如连字"存储"(U + 00 C 6)，可能会被视为等效于正确的顺序，如 AE 字符的组件的任何匹配项 (u+0041，U + 0045)，则根据区域性。 若要执行序号 （不区分区域性） 搜索，其中的 Unicode 值进行比较，应调用具有类型参数的重载之一<xref:System.Globalization.CompareOptions>，并使用<xref:System.Globalization.CompareOptions.Ordinal>值。  
  
> [!NOTE]
>  如果可能，应调用字符串比较方法具有的类型参数的<xref:System.Globalization.CompareOptions>指定的预期的比较类型。 作为一般规则，用来进行比较用户界面中显示的字符串 （使用当前区域性） 的语言选项并指定<xref:System.Globalization.CompareOptions.Ordinal?displayProperty=nameWithType>或<xref:System.Globalization.CompareOptions.OrdinalIgnoreCase?displayProperty=nameWithType>安全比较。  
  
   
  
## Examples  
 下面的示例确定一个字符或字符串的一部分中的子字符串的第一个和最后一个匹配项的索引。  
  
 [!code-cpp[System.Globalization.CompareInfo.IndexOfIntInt#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Globalization.CompareInfo.IndexOfIntInt/CPP/indexofintint.cpp#1)]
 [!code-csharp[System.Globalization.CompareInfo.IndexOfIntInt#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Globalization.CompareInfo.IndexOfIntInt/CS/indexofintint.cs#1)]
 [!code-vb[System.Globalization.CompareInfo.IndexOfIntInt#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Globalization.CompareInfo.IndexOfIntInt/VB/indexofintint.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> 为 <see langword="null" />。  
  
或 
 <paramref name="value" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> 超出了 <paramref name="source" /> 的有效索引范围。  
  
或 
 <paramref name="count" /> 小于零。  
  
或 
 <paramref name="startIndex" /> 和 <paramref name="count" /> 未在 <paramref name="source" /> 中指定有效部分。</exception>
        <block subset="none" type="usage">
          <para>字符集包括可忽略字符，不考虑执行语言性的或区分区域性的排序时的字符。 在区分区域性的搜索中，如果 <paramref name="value" /> 包含一个可忽略字符，则结果与移除了该字符的搜索等效。 如果<paramref name="value" />仅包含一个或多个可忽略字符，<see cref="M:System.Globalization.CompareInfo.LastIndexOf(System.String,System.String,System.Int32,System.Int32)" />方法始终返回<paramref name="startIndex" />，即搜索开始处的字符位置。  
  
在以下示例中，<see cref="M:System.Globalization.CompareInfo.LastIndexOf(System.String,System.String,System.Int32,System.Int32)" />方法用于查找软连字符 (U + 00AD) 的位置后, 跟"m"中前两个字符串的最后一个"m"的三个字符。 只有一个字符串包含必需的子字符串。 在这两种情况下，因为软连字符是可忽略字符，因此，在执行区分区域性的比较时，该方法在字符串中返回索引“m”。 注意对于第一个字符串，包含软连字符后跟“m”，该方法无法返回该软连字符的索引，而是返回“m”的索引。  
  
[！ 代码 csharp[System.Globalization.CompareInfo.LastIndexOf#17](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.globalization.compareinfo.lastindexof/cs/lastignorable16.cs#17)] [！ 代码 vb[System.Globalization.CompareInfo.LastIndexOf#17](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.globalization.compareinfo.lastindexof/vb/lastignorable16.vb#17)]</para>
        </block>
        <altmember cref="M:System.Globalization.CompareInfo.IndexOf(System.String,System.Char)" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public virtual int LastIndexOf (string source, char value, int startIndex, int count, System.Globalization.CompareOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 LastIndexOf(string source, char value, int32 startIndex, int32 count, valuetype System.Globalization.CompareOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Globalization.CompareInfo.LastIndexOf(System.String,System.Char,System.Int32,System.Int32,System.Globalization.CompareOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function LastIndexOf (source As String, value As Char, startIndex As Integer, count As Integer, options As CompareOptions) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int LastIndexOf(System::String ^ source, char value, int startIndex, int count, System::Globalization::CompareOptions options);" />
      <MemberSignature Language="F#" Value="abstract member LastIndexOf : string * char * int * int * System.Globalization.CompareOptions -&gt; int&#xA;override this.LastIndexOf : string * char * int * int * System.Globalization.CompareOptions -&gt; int" Usage="compareInfo.LastIndexOf (source, value, startIndex, count, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Globalization</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="value" Type="System.Char" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="options" Type="System.Globalization.CompareOptions" />
      </Parameters>
      <Docs>
        <param name="source">要搜索的字符串。</param>
        <param name="value">要在 <paramref name="source" /> 中定位的字符。</param>
        <param name="startIndex">向后搜索的从零开始的起始索引。</param>
        <param name="count">要搜索的部分中的元素数。</param>
        <param name="options">一个值，用于定义应如何比较 <paramref name="source" /> 和 <paramref name="value" />。 <paramref name="options" /> 可以为枚举值 <see cref="F:System.Globalization.CompareOptions.Ordinal" />，或为以下一个或多个值的按位组合：<see cref="F:System.Globalization.CompareOptions.IgnoreCase" />、<see cref="F:System.Globalization.CompareOptions.IgnoreSymbols" />、<see cref="F:System.Globalization.CompareOptions.IgnoreNonSpace" />、<see cref="F:System.Globalization.CompareOptions.IgnoreWidth" /> 和 <see cref="F:System.Globalization.CompareOptions.IgnoreKanaType" />。</param>
        <summary>使用指定的 <see cref="T:System.Globalization.CompareOptions" /> 值，搜索指定的字符，并返回源字符串内包含所指定元素数、以指定的索引位置结尾的部分中最后一个匹配项的从零开始的索引。</summary>
        <returns>使用指定的比较选项，如果在 <paramref name="value" /> 中结束于 <paramref name="source" /> 、包含 <paramref name="count" /> 指定的元素数的部分找到 <paramref name="startIndex" /> 的最后一个匹配项，则为该项的从零开始的索引；否则为 -1。 如果 <paramref name="startIndex" /> 为可忽略字符，则将返回 <paramref name="value" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 源字符串是搜索处开始向后`startIndex`结束时间`startIndex`  -  `count` + 1。  
  
 <xref:System.Globalization.CompareOptions.StringSort?displayProperty=nameWithType>值不能用于此方法。  
  
 如果`options`不包括<xref:System.Globalization.CompareOptions.Ordinal>值，此重载执行区分区域性的搜索。 如果字符是表示预构成的字符的 Unicode 值，例如连字"存储"(U + 00 C 6)，它可能被视为等效于正确的顺序，如 AE 及其组件的任何匹配项 (u+0041，U + 0045)，则根据区域性。 如果`options`包括<xref:System.Globalization.CompareOptions.Ordinal>值，此重载将执行序号 （不区分区域性） 搜索。 仅当 Unicode 值是相同的一个字符被视为等效于另一个字符。 重载的<xref:System.String.LastIndexOf%2A?displayProperty=nameWithType>该搜索的字符执行序号搜索，而这些搜索的字符串执行区分区域性的搜索。  
  
> [!NOTE]
>  如果可能，应调用字符串比较方法具有的类型参数的<xref:System.Globalization.CompareOptions>指定的预期的比较类型。 作为一般规则，用来进行比较用户界面中显示的字符串 （使用当前区域性） 的语言选项并指定<xref:System.Globalization.CompareOptions.Ordinal?displayProperty=nameWithType>或<xref:System.Globalization.CompareOptions.OrdinalIgnoreCase?displayProperty=nameWithType>安全比较。  
  
   
  
## Examples  
 下面的示例确定一个字符或字符串的一部分中的子字符串的第一个和最后一个匹配项的索引。  
  
 [!code-cpp[System.Globalization.CompareInfo.IndexOfIntInt#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Globalization.CompareInfo.IndexOfIntInt/CPP/indexofintint.cpp#1)]
 [!code-csharp[System.Globalization.CompareInfo.IndexOfIntInt#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Globalization.CompareInfo.IndexOfIntInt/CS/indexofintint.cs#1)]
 [!code-vb[System.Globalization.CompareInfo.IndexOfIntInt#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Globalization.CompareInfo.IndexOfIntInt/VB/indexofintint.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> 超出了 <paramref name="source" /> 的有效索引范围。  
  
或 
 <paramref name="count" /> 小于零。  
  
或 
 <paramref name="startIndex" /> 和 <paramref name="count" /> 未在 <paramref name="source" /> 中指定有效部分。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="options" /> 包含无效的 <see cref="T:System.Globalization.CompareOptions" /> 值。</exception>
        <block subset="none" type="usage">
          <para>字符集包括可忽略字符，不考虑执行语言性的或区分区域性的排序时的字符。 在区分区域性的搜索中，如果<paramref name="value" />是可忽略字符，结果与移除了该字符的搜索等效。 在这种情况下，<see cref="M:System.Globalization.CompareInfo.LastIndexOf(System.String,System.Char,System.Int32,System.Int32,System.Globalization.CompareOptions)" />方法始终返回<paramref name="startIndex" />，即搜索开始处的字符位置。 在以下示例中，<see cref="M:System.Globalization.CompareInfo.LastIndexOf(System.String,System.Char,System.Int32,System.Int32,System.Globalization.CompareOptions)" />方法用于在两个字符串中查找软连字符 (U + 00AD) 之前最后一个"m"。 只有一个字符串包含软连字符。 在这两种情况下，因为软连字符是可忽略字符，区分区域性的搜索返回"m"，即值的索引位置的<paramref name="startIndex" />。 序号搜索，但是，成功地在一个字符串中查找软连字符，并报告它不存在从第二个字符串。  
  
[！ 代码 csharp[System.Globalization.CompareInfo.LastIndexOf#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.globalization.compareinfo.lastindexof/cs/lastignorable11.cs#12)] [！ 代码 vb[System.Globalization.CompareInfo.LastIndexOf#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.globalization.compareinfo.lastindexof/vb/lastignorable11.vb#12)]</para>
        </block>
        <altmember cref="M:System.Globalization.CompareInfo.IndexOf(System.String,System.Char)" />
        <altmember cref="T:System.Globalization.CompareOptions" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public virtual int LastIndexOf (string source, string value, int startIndex, int count, System.Globalization.CompareOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 LastIndexOf(string source, string value, int32 startIndex, int32 count, valuetype System.Globalization.CompareOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Globalization.CompareInfo.LastIndexOf(System.String,System.String,System.Int32,System.Int32,System.Globalization.CompareOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function LastIndexOf (source As String, value As String, startIndex As Integer, count As Integer, options As CompareOptions) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int LastIndexOf(System::String ^ source, System::String ^ value, int startIndex, int count, System::Globalization::CompareOptions options);" />
      <MemberSignature Language="F#" Value="abstract member LastIndexOf : string * string * int * int * System.Globalization.CompareOptions -&gt; int&#xA;override this.LastIndexOf : string * string * int * int * System.Globalization.CompareOptions -&gt; int" Usage="compareInfo.LastIndexOf (source, value, startIndex, count, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Globalization</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="options" Type="System.Globalization.CompareOptions" />
      </Parameters>
      <Docs>
        <param name="source">要搜索的字符串。</param>
        <param name="value">要在 <paramref name="source" /> 中定位的字符串。</param>
        <param name="startIndex">向后搜索的从零开始的起始索引。</param>
        <param name="count">要搜索的部分中的元素数。</param>
        <param name="options">一个值，用于定义应如何比较 <paramref name="source" /> 和 <paramref name="value" />。 <paramref name="options" /> 可以为枚举值 <see cref="F:System.Globalization.CompareOptions.Ordinal" />，或为以下一个或多个值的按位组合：<see cref="F:System.Globalization.CompareOptions.IgnoreCase" />、<see cref="F:System.Globalization.CompareOptions.IgnoreSymbols" />、<see cref="F:System.Globalization.CompareOptions.IgnoreNonSpace" />、<see cref="F:System.Globalization.CompareOptions.IgnoreWidth" /> 和 <see cref="F:System.Globalization.CompareOptions.IgnoreKanaType" />。</param>
        <summary>使用指定的 <see cref="T:System.Globalization.CompareOptions" /> 值，搜索指定的子字符串，并返回源字符串内包含所指定元素数、以指定的索引位置结尾的部分中最后一个匹配项的从零开始的索引。</summary>
        <returns>使用指定的比较选项，如果在 <paramref name="value" /> 中结束于 <paramref name="source" /> 、包含 <paramref name="count" /> 指定的元素数的部分找到 <paramref name="startIndex" /> 的最后一个匹配项，则为该项的从零开始的索引；否则为 -1。 如果 <paramref name="startIndex" /> 为可忽略字符，则将返回 <paramref name="value" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 源字符串是搜索处开始向后`startIndex`结束时间`startIndex`  -  `count` + 1。  
  
 <xref:System.Globalization.CompareOptions.StringSort?displayProperty=nameWithType>值不能用于此方法。  
  
 如果`options`不包括<xref:System.Globalization.CompareOptions.Ordinal>值，此重载执行区分区域性的搜索。 一个 Unicode 值，表示一个预构成的字符，例如连字"存储"(U + 00 C 6)，可能会被视为等效于正确的顺序，如 AE 字符的组件的任何匹配项 (u+0041，U + 0045)，则根据区域性。 如果`options`包括<xref:System.Globalization.CompareOptions.Ordinal>值，此重载将执行序号 （不区分区域性） 搜索，其中的 Unicode 值进行比较。  
  
> [!NOTE]
>  如果可能，应调用字符串比较方法具有的类型参数的<xref:System.Globalization.CompareOptions>指定的预期的比较类型。 作为一般规则，用来进行比较用户界面中显示的字符串 （使用当前区域性） 的语言选项并指定<xref:System.Globalization.CompareOptions.Ordinal?displayProperty=nameWithType>或<xref:System.Globalization.CompareOptions.OrdinalIgnoreCase?displayProperty=nameWithType>安全比较。  
  
   
  
## Examples  
 下面的示例确定一个字符或字符串的一部分中的子字符串的第一个和最后一个匹配项的索引。  
  
 [!code-cpp[System.Globalization.CompareInfo.IndexOfIntInt#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Globalization.CompareInfo.IndexOfIntInt/CPP/indexofintint.cpp#1)]
 [!code-csharp[System.Globalization.CompareInfo.IndexOfIntInt#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Globalization.CompareInfo.IndexOfIntInt/CS/indexofintint.cs#1)]
 [!code-vb[System.Globalization.CompareInfo.IndexOfIntInt#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Globalization.CompareInfo.IndexOfIntInt/VB/indexofintint.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> 为 <see langword="null" />。  
  
或 
 <paramref name="value" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> 超出了 <paramref name="source" /> 的有效索引范围。  
  
或 
 <paramref name="count" /> 小于零。  
  
或 
 <paramref name="startIndex" /> 和 <paramref name="count" /> 未在 <paramref name="source" /> 中指定有效部分。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="options" /> 包含无效的 <see cref="T:System.Globalization.CompareOptions" /> 值。</exception>
        <block subset="none" type="usage">
          <para>字符集包括可忽略字符，不考虑执行语言性的或区分区域性的排序时的字符。 在区分区域性的搜索 (即，如果 <paramref name="options" /> 不是 <see cref="F:System.Globalization.CompareOptions.Ordinal" /> 或 <see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" />) 中，如果 <paramref name="value" /> 包含一个可忽略字符，则结果与移除了该字符的搜索等效。 如果<paramref name="value" />仅包含一个或多个可忽略字符，<see cref="M:System.Globalization.CompareInfo.LastIndexOf(System.String,System.String,System.Int32,System.Int32,System.Globalization.CompareOptions)" />方法始终返回<paramref name="startIndex" />，即搜索开始处的字符位置。  
  
在以下示例中，<see cref="M:System.Globalization.CompareInfo.LastIndexOf(System.String,System.String,System.Int32,System.Int32,System.Globalization.CompareOptions)" />方法用于在两个字符串中查找所有中后, 跟"m"的软连字符 (U + 00AD) 位置，但之前最后一个"m"的第一个字符位置。 只有一个字符串包含必需的子字符串。 在这两种情况下，因为软连字符是可忽略字符，因此，在执行区分区域性的比较时，该方法在字符串中返回索引“m”。 当它执行序号比较时，但是，它找到的子字符串仅在第一个字符串中。 请注意，对于第一个字符串，包含软连字符后跟"m"，该方法无法返回软连字符的索引而是返回"m"的索引执行区分区域性的比较时。 只有当此方法执行序号比较时，它才会在第一个字符串中返回软连字符的索引。  
  
[！ 代码 vb[System.Globalization.CompareInfo.LastIndexOf#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.globalization.compareinfo.lastindexof/vb/lastignorable15.vb#16)]</para>
        </block>
        <altmember cref="M:System.Globalization.CompareInfo.IndexOf(System.String,System.Char)" />
        <altmember cref="T:System.Globalization.CompareOptions" />
      </Docs>
    </Member>
    <Member MemberName="LCID">
      <MemberSignature Language="C#" Value="public int LCID { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 LCID" />
      <MemberSignature Language="DocId" Value="P:System.Globalization.CompareInfo.LCID" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LCID As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int LCID { int get(); };" />
      <MemberSignature Language="F#" Value="member this.LCID : int" Usage="System.Globalization.CompareInfo.LCID" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Globalization</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取当前 <see cref="T:System.Globalization.CompareInfo" /> 的格式正确的区域性标识符。</summary>
        <value>当前 <see cref="T:System.Globalization.CompareInfo" /> 的格式正确的区域性标识符。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下面的示例演示<xref:System.Globalization.CompareInfo.LCID%2A>属性。  
  
 [!code-cpp[CompareInfo#1](~/samples/snippets/cpp/VS_Snippets_CLR/CompareInfo/cpp/CompareInfo.cpp#1)]
 [!code-csharp[CompareInfo#1](~/samples/snippets/csharp/VS_Snippets_CLR/CompareInfo/CS/CompareInfo.cs#1)]
 [!code-vb[CompareInfo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/CompareInfo/VB/CompareInfo.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public virtual string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Globalization.CompareInfo.Name" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Name { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Name : string" Usage="System.Globalization.CompareInfo.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Globalization</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取用于通过 <see cref="T:System.Globalization.CompareInfo" /> 对象执行排序操作的区域性的名称。</summary>
        <value>区域性的名称。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Globalization.CompareInfo.Name%2A>和<xref:System.Globalization.CultureInfo.Name?displayProperty=nameWithType>属性可以具有不同的值。 例如，<xref:System.Globalization.CompareInfo.LCID%2A>属性值的十六进制 0x10407 标识可能出现在德语电话簿排序名称替换排序区域性。 <xref:System.Globalization.CompareInfo.Name%2A>属性的值为"de-de_phoneb"，而<xref:System.Globalization.CultureInfo.Name?displayProperty=nameWithType>相关联的德语 （德国） 区域性属性的值为"DE-DE"。  
  
   
  
## Examples  
 下面的示例将使用 FR-FR 和 JA-JP 区域性的三个字符串进行比较。 <xref:System.Globalization.CultureInfo.Name%2A>属性用于显示每个区域性的名称。  
  
 [!code-cpp[CompareInfo#1](~/samples/snippets/cpp/VS_Snippets_CLR/CompareInfo/cpp/CompareInfo.cpp#1)]
 [!code-csharp[CompareInfo#1](~/samples/snippets/csharp/VS_Snippets_CLR/CompareInfo/CS/CompareInfo.cs#1)]
 [!code-vb[CompareInfo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/CompareInfo/VB/CompareInfo.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.Serialization.IDeserializationCallback.OnDeserialization">
      <MemberSignature Language="C#" Value="void IDeserializationCallback.OnDeserialization (object sender);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.Serialization.IDeserializationCallback.OnDeserialization(object sender) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Globalization.CompareInfo.System#Runtime#Serialization#IDeserializationCallback#OnDeserialization(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Sub OnDeserialization (sender As Object) Implements IDeserializationCallback.OnDeserialization" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.Serialization.IDeserializationCallback.OnDeserialization(System::Object ^ sender) = System::Runtime::Serialization::IDeserializationCallback::OnDeserialization;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.IDeserializationCallback.OnDeserialization(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Globalization</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sender" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="sender">启动回调的对象。</param>
        <summary>在整个对象图形已经反序列化时运行。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此成员是显式接口成员实现，可仅当当前<xref:System.Globalization.CompareInfo>对象被强制转换为<xref:System.Runtime.Serialization.IDeserializationCallback>接口。 有关更多信息，请参见 <xref:System.Runtime.Serialization.IDeserializationCallback.OnDeserialization%2A> 方法。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Runtime.Serialization.IDeserializationCallback" />
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Globalization.CompareInfo.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="compareInfo.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Globalization</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回表示当前 <see cref="T:System.Globalization.CompareInfo" /> 对象的字符串。</summary>
        <returns>表示当前 <see cref="T:System.Globalization.CompareInfo" /> 对象的字符串。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法重写<xref:System.Object.ToString%2A?displayProperty=nameWithType>方法。 它将返回类名称和实例的值组成的字符串<xref:System.Globalization.CompareInfo.Name%2A>属性，连字符分隔。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>从 .NET Framework 4 开始，<see cref="M:System.Globalization.CompareInfo.ToString" /> 方法返回类名，后跟空格、连字符、空格和 <see cref="P:System.Globalization.CompareInfo.Name" /> 属性的值。 例如，对于表示 en-US 区域性的 <see cref="T:System.Globalization.CompareInfo" /> 对象，<see cref="M:System.Globalization.CompareInfo.ToString" /> 方法返回“CompareInfo - en-US”。 在 .NET Framework 的早期版本中，它返回后跟空格、连字符、空格和 <see cref="P:System.Globalization.CompareInfo.LCID" /> 属性的值的类名。 例如，对于表示 en-US 区域性的 <see cref="T:System.Globalization.CompareInfo" /> 对象，<see cref="M:System.Globalization.CompareInfo.ToString" /> 方法返回“CompareInfo - 1033”。</para>
        </block>
        <altmember cref="M:System.Object.ToString" />
      </Docs>
    </Member>
    <Member MemberName="Version">
      <MemberSignature Language="C#" Value="public System.Globalization.SortVersion Version { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Globalization.SortVersion Version" />
      <MemberSignature Language="DocId" Value="P:System.Globalization.CompareInfo.Version" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Version As SortVersion" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Globalization::SortVersion ^ Version { System::Globalization::SortVersion ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Version : System.Globalization.SortVersion" Usage="System.Globalization.CompareInfo.Version" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Globalization</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Globalization.SortVersion</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取用于比较和排序字符串的 Unicode 版本的相关信息。</summary>
        <value>包含用于比较和排序字符串的 Unicode 版本的相关信息的对象。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 单个字符的权重，因此中比较或排序，特定字符串的方式取决于特定版本的.NET framework 实现 Unicode 规范的版本。 在 [!INCLUDE[net_v45](~/includes/net-v45-md.md)] 中，这也取决于主机操作系统，如下表所示。 请注意，受支持的 Unicode 版本的列表仅适用于字符比较和排序；不适用于 Unicode 字符串按类别分类。  
  
|.NET Framework 版本|操作系统|Unicode 版本|  
|----------------------------|----------------------|---------------------|  
|[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]|所有操作系统|Unicode 5.0|  
|[!INCLUDE[net_v45](~/includes/net-v45-md.md)] 及更高版本|[!INCLUDE[win7](~/includes/win7-md.md)]|Unicode 5.0|  
|[!INCLUDE[net_v45](~/includes/net-v45-md.md)] 及更高版本|[!INCLUDE[win8](~/includes/win8-md.md)] 和更高版本的 Windows 操作系统版本|Unicode 6.3|  
  
 由 <xref:System.Globalization.SortVersion> 属性返回的 <xref:System.Globalization.CompareInfo.Version%2A> 对象不标识用于比较字符串的准确 Unicode 版本。 仅在比较两个 <xref:System.Globalization.SortVersion> 对象来确定它们是否使用相同版本的 Unicode 版本和区域性来比较字符串时很有用。 有关详细信息和示例，请参见 <xref:System.Globalization.SortVersion> 引用页。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Globalization.SortVersion" />
      </Docs>
    </Member>
  </Members>
</Type>