<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="LogRecordSequence.xml" source-language="en-US" target-language="zh-CN">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-15c36f0" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">02cd5861-7ce2-4a82-b358-31f8435a0ac5330d85d921807042238a6dbb6d100c3f96cc1899.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">330d85d921807042238a6dbb6d100c3f96cc1899</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/03/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.IO.Log.LogRecordSequence">
          <source>Represents a record sequence stored in a <ph id="ph1">&lt;see cref="T:System.IO.Log.LogStore" /&gt;</ph>.</source>
          <target state="translated">表示存储在 <ph id="ph1">&lt;see cref="T:System.IO.Log.LogStore" /&gt;</ph> 中的记录序列。</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.Log.LogRecordSequence">
          <source>The <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence&gt;</ph> class provides an implementation of the record sequence interface on top of a Common Log File System (CLFS) log.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence&gt;</ph> 类提供记录序列接口在公用日志文件系统 (CLFS) 日志之上的实现。</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.Log.LogRecordSequence">
          <source>In addition to the standard record-oriented features, it provides a policy model for avoiding log-full conditions, and multiplexing of clients on the same physical file.</source>
          <target state="translated">除了标准的面向记录的功能外，该类还提供了一个策略模型，用于避免出现日志已满的情况并对同一个物理文件上的客户端进行多路复用。</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.Log.LogRecordSequence">
          <source>It works with the <ph id="ph1">&lt;xref:System.IO.Log.LogStore&gt;</ph> class, which provides an interface for directly manipulating and managing a CLFS log file.</source>
          <target state="translated">它与 <ph id="ph1">&lt;xref:System.IO.Log.LogStore&gt;</ph> 类一起使用，该类提供了直接操作和管理 CLFS 日志文件的接口。</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.Log.LogRecordSequence">
          <source>The relationship between the <ph id="ph1">&lt;xref:System.IO.Log.LogStore&gt;</ph> class and the <ph id="ph2">&lt;xref:System.IO.Log.LogRecordSequence&gt;</ph> class is similar to the relationship between a disk file and a <ph id="ph3">&lt;xref:System.IO.FileStream&gt;</ph> object.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.IO.Log.LogStore&gt;</ph> 类和 <ph id="ph2">&lt;xref:System.IO.Log.LogRecordSequence&gt;</ph> 类之间的关系类似于磁盘文件和 <ph id="ph3">&lt;xref:System.IO.FileStream&gt;</ph> 对象之间的关系。</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.Log.LogRecordSequence">
          <source>The disk file provides the concrete storage, and has attributes such as length and last access time; while the <ph id="ph1">&lt;xref:System.IO.FileStream&gt;</ph> object provides a view on the file that can be used to read from it and write to it.</source>
          <target state="translated">磁盘文件提供实际存储区，并具有长度和上次访问时间等属性，而 <ph id="ph1">&lt;xref:System.IO.FileStream&gt;</ph> 对象提供文件的视图，利用该视图可以从实际存储区中读取以及向其中写入数据。</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.Log.LogRecordSequence">
          <source>Similarly, the <ph id="ph1">&lt;xref:System.IO.Log.LogStore&gt;</ph> class has attributes like a policy and a collection of disk extents; and the <ph id="ph2">&lt;xref:System.IO.Log.LogRecordSequence&gt;</ph> class provides a record-oriented mechanism for reading and writing data.</source>
          <target state="translated">与之类似，<ph id="ph1">&lt;xref:System.IO.Log.LogStore&gt;</ph> 类具有策略和磁盘范围集合等属性；而 <ph id="ph2">&lt;xref:System.IO.Log.LogRecordSequence&gt;</ph> 类提供面向记录的数据读取和写入机制。</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.Log.LogRecordSequence">
          <source>This example shows how to use the <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence&gt;</ph> class:</source>
          <target state="translated">此示例演示如何使用 <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence&gt;</ph> 类：</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" uid="T:System.IO.Log.LogRecordSequence">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.IO.Log.LogRecordSequence" /&gt;</ph> class.</source>
          <target state="translated">初始化 <ph id="ph1">&lt;see cref="T:System.IO.Log.LogRecordSequence" /&gt;</ph> 类的新实例。</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.IO.Log.LogStore)">
          <source>The <ph id="ph1">&lt;see cref="T:System.IO.Log.LogStore" /&gt;</ph> that this record sequence should use.</source>
          <target state="translated">此记录序列应使用的 <ph id="ph1">&lt;see cref="T:System.IO.Log.LogStore" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.IO.Log.LogStore)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.IO.Log.LogRecordSequence" /&gt;</ph> class with the specified log store.</source>
          <target state="translated">使用指定的日志存储区初始化 <ph id="ph1">&lt;see cref="T:System.IO.Log.LogRecordSequence" /&gt;</ph> 类的新实例。</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.IO.Log.LogStore)">
          <source>The buffer size determines the maximum size of the record that can be appended or read.</source>
          <target state="translated">缓冲区大小确定了可追加或读取的记录的最大大小。</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.IO.Log.LogStore)">
          <source>In this constructor, a default value of 64 is set.</source>
          <target state="translated">在此构造函数中，将默认值设置为 64。</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.IO.Log.LogStore)">
          <source>The desired number of buffers is set to 10.</source>
          <target state="translated">将所需的缓冲区数量设置为 10。</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.IO.Log.LogStore)">
          <source><ph id="ph1">&lt;paramref name="logStore" /&gt;</ph> is invalid.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="logStore" /&gt;</ph> 无效。</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode)">
          <source>A relative or absolute path for the base file of the log store to open.</source>
          <target state="translated">要打开的日志存储区的基文件的相对或绝对路径。</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode)">
          <source>One of the <ph id="ph1">&lt;see cref="T:System.IO.FileMode" /&gt;</ph> values that determines how to open or create the store.</source>
          <target state="translated">用于确定如何打开或创建存储区的 <ph id="ph1">&lt;see cref="T:System.IO.FileMode" /&gt;</ph> 值之一。</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.IO.Log.LogRecordSequence" /&gt;</ph> class with a specified path to the log store and the access mode.</source>
          <target state="translated">使用指定的日志存储区路径和访问模式初始化 <ph id="ph1">&lt;see cref="T:System.IO.Log.LogRecordSequence" /&gt;</ph> 类的新实例。</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode)">
          <source>This constructor initializes a new <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence&gt;</ph> on a new <ph id="ph2">&lt;xref:System.IO.Log.LogStore&gt;</ph> object that it opens with the specified path and mode.</source>
          <target state="translated">此构造函数使用指定的路径和模式初始化它打开的新 <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence&gt;</ph> 对象上的新 <ph id="ph2">&lt;xref:System.IO.Log.LogStore&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode)">
          <source>It is given read/write access to the store, and the store is opened sharing Read access.</source>
          <target state="translated">为其指定了存储区的读/写访问权限，并打开了存储区以共享读访问权限。</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode)">
          <source><ph id="ph1">&lt;paramref name="path" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="path" /&gt;</ph> 为 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode)">
          <source><ph id="ph1">&lt;paramref name="path" /&gt;</ph> is an empty string ("").</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="path" /&gt;</ph> 为空字符串 ("")。</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode)">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode)">
          <source><ph id="ph1">&lt;paramref name="path" /&gt;</ph> contains only white space.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="path" /&gt;</ph> 仅包含空白。</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode)">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode)">
          <source><ph id="ph1">&lt;paramref name="path" /&gt;</ph> contains one or more invalid characters.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="path" /&gt;</ph> 包含一个或多个无效字符。</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode)">
          <source><ph id="ph1">&lt;paramref name="mode" /&gt;</ph> contains an invalid value.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="mode" /&gt;</ph> 包含无效值。</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode)">
          <source>The file cannot be found.</source>
          <target state="translated">无法找到该文件。</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode)">
          <source>An I/O error occurs when opening the log store.</source>
          <target state="translated">打开日志存储区时发生了 I/O 错误。</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode)">
          <source>Access for the specified log sequence is denied by the operating system.</source>
          <target state="translated">操作系统拒绝了对指定的日志序列的访问。</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode)">
          <source>This operation is not supported.</source>
          <target state="translated">不支持此操作。</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode)">
          <source>There is not enough memory to continue the execution of the program.</source>
          <target state="translated">没有足够的内存来继续执行该程序。</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode)">
          <source><ph id="ph1">&lt;see cref="T:System.IO.Log.LogRecordSequence" /&gt;</ph> cannot be used because the required Common Log File System (CLFS) component is not installed.</source>
          <target state="translated">无法使用 <ph id="ph1">&lt;see cref="T:System.IO.Log.LogRecordSequence" /&gt;</ph>，因为没有安装所需的公用日志文件系统 (CLFS) 组件。</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode)">
          <source>Install the CLFS component if it is available for your platform, or use the <ph id="ph1">&lt;see cref="T:System.IO.Log.FileRecordSequence" /&gt;</ph> class.</source>
          <target state="translated">如果可行，请为您的平台安装 CLFS 组件，或使用 <ph id="ph1">&lt;see cref="T:System.IO.Log.FileRecordSequence" /&gt;</ph> 类。</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.IO.Log.LogStore,System.Int32,System.Int32)">
          <source>The <ph id="ph1">&lt;see cref="T:System.IO.Log.LogStore" /&gt;</ph> that this record sequence should use.</source>
          <target state="translated">此记录序列应使用的 <ph id="ph1">&lt;see cref="T:System.IO.Log.LogStore" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.IO.Log.LogStore,System.Int32,System.Int32)">
          <source>The desired buffer size in bytes.</source>
          <target state="translated">所需的缓冲区大小（以字节为单位）。</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.IO.Log.LogStore,System.Int32,System.Int32)">
          <source>The buffer size determines the maximum size of the record that can be appended or read.</source>
          <target state="translated">缓冲区大小确定了可追加或读取的记录的最大大小。</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.IO.Log.LogStore,System.Int32,System.Int32)">
          <source>The desired number of buffers.</source>
          <target state="translated">所需的缓冲区数量。</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.IO.Log.LogStore,System.Int32,System.Int32)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.IO.Log.LogRecordSequence" /&gt;</ph> class with the specified log store, buffer size for each record, and buffer number.</source>
          <target state="translated">使用指定的日志存储区、每个记录的缓冲区大小以及缓冲区数量来初始化 <ph id="ph1">&lt;see cref="T:System.IO.Log.LogRecordSequence" /&gt;</ph> 类的新实例。</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.IO.Log.LogStore,System.Int32,System.Int32)">
          <source>Use this constructor if you want to specify values for <ph id="ph1">`bufferSize`</ph> and <ph id="ph2">`bufferCount`</ph> and do not want to use the default value of 64 for <ph id="ph3">`bufferSize`</ph> and 10 for <ph id="ph4">`bufferCount`</ph>.</source>
          <target state="translated">如果要指定 <ph id="ph1">`bufferSize`</ph> 和 <ph id="ph2">`bufferCount`</ph> 值，而不是使用 <ph id="ph3">`bufferSize`</ph> 的默认值 64 以及 <ph id="ph4">`bufferCount`</ph> 的默认值 10，则可以使用此构造函数。</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.IO.Log.LogStore,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="logStore" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="logStore" /&gt;</ph> 为 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.IO.Log.LogStore,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="bufferSize" /&gt;</ph> is negative or zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="bufferSize" /&gt;</ph> 为负数或零。</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.IO.Log.LogStore,System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.IO.Log.LogStore,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="bufferCount" /&gt;</ph> is negative or zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="bufferCount" /&gt;</ph> 为负数或零。</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)">
          <source>A relative or absolute path for the base file of the log store to open.</source>
          <target state="translated">要打开的日志存储区的基文件的相对或绝对路径。</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)">
          <source>One of the <ph id="ph1">&lt;see cref="T:System.IO.FileMode" /&gt;</ph> values that determines how to open or create the store.</source>
          <target state="translated">用于确定如何打开或创建存储区的 <ph id="ph1">&lt;see cref="T:System.IO.FileMode" /&gt;</ph> 值之一。</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)">
          <source>One of the <ph id="ph1">&lt;see cref="T:System.IO.FileAccess" /&gt;</ph> values that determines how the file can be accessed by the <ph id="ph2">&lt;see cref="T:System.IO.Log.LogStore" /&gt;</ph>.</source>
          <target state="translated">用于确定 <ph id="ph1">&lt;see cref="T:System.IO.FileAccess" /&gt;</ph> 可以如何访问文件的 <ph id="ph2">&lt;see cref="T:System.IO.Log.LogStore" /&gt;</ph> 值之一。</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.IO.Log.LogRecordSequence" /&gt;</ph> class with a specified path to the log store and the access and share modes.</source>
          <target state="translated">使用指定的日志存储区路径以及访问和共享模式来初始化 <ph id="ph1">&lt;see cref="T:System.IO.Log.LogRecordSequence" /&gt;</ph> 类的新实例。</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)">
          <source>This constructor initializes a new <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence&gt;</ph> on a new <ph id="ph2">&lt;xref:System.IO.Log.LogStore&gt;</ph> object that it opens with the specified path, mode, and access.</source>
          <target state="translated">此构造函数使用指定的路径、模式和访问权限来初始化它打开的新 <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence&gt;</ph> 对象上的新 <ph id="ph2">&lt;xref:System.IO.Log.LogStore&gt;</ph>，</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)">
          <source>The store is opened sharing Read access.</source>
          <target state="translated">并打开了存储区以共享读访问权限。</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)">
          <source><ph id="ph1">&lt;paramref name="path" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="path" /&gt;</ph> 为 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)">
          <source><ph id="ph1">&lt;paramref name="path" /&gt;</ph> is an empty string ("").</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="path" /&gt;</ph> 为空字符串 ("")。</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)">
          <source><ph id="ph1">&lt;paramref name="path" /&gt;</ph> contains only white space.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="path" /&gt;</ph> 仅包含空白。</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)">
          <source><ph id="ph1">&lt;paramref name="path" /&gt;</ph> contains one or more invalid characters.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="path" /&gt;</ph> 包含一个或多个无效字符。</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)">
          <source><ph id="ph1">&lt;paramref name="mode" /&gt;</ph> contains an invalid value.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="mode" /&gt;</ph> 包含无效值。</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)">
          <source>The file cannot be found.</source>
          <target state="translated">无法找到该文件。</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)">
          <source>An I/O error occurs when opening the log store.</source>
          <target state="translated">打开日志存储区时发生了 I/O 错误。</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)">
          <source>Access for the specified log sequence is denied by the operating system.</source>
          <target state="translated">操作系统拒绝了对指定的日志序列的访问。</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)">
          <source>This operation is not supported.</source>
          <target state="translated">不支持此操作。</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)">
          <source>There is not enough memory to continue the execution of the program.</source>
          <target state="translated">没有足够的内存来继续执行该程序。</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)">
          <source><ph id="ph1">&lt;see cref="T:System.IO.Log.LogRecordSequence" /&gt;</ph> cannot be used because the required Common Log File System (CLFS) component is not installed.</source>
          <target state="translated">无法使用 <ph id="ph1">&lt;see cref="T:System.IO.Log.LogRecordSequence" /&gt;</ph>，因为没有安装所需的公用日志文件系统 (CLFS) 组件。</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)">
          <source>Install the CLFS component if it is available for your platform, or use the <ph id="ph1">&lt;see cref="T:System.IO.Log.FileRecordSequence" /&gt;</ph> class.</source>
          <target state="translated">如果可行，请为您的平台安装 CLFS 组件，或使用 <ph id="ph1">&lt;see cref="T:System.IO.Log.FileRecordSequence" /&gt;</ph> 类。</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)">
          <source>A relative or absolute path for the base file of the log store to open.</source>
          <target state="translated">要打开的日志存储区的基文件的相对或绝对路径。</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)">
          <source>One of the <ph id="ph1">&lt;see cref="T:System.IO.FileMode" /&gt;</ph> values that determines how to open or create the store.</source>
          <target state="translated">用于确定如何打开或创建存储区的 <ph id="ph1">&lt;see cref="T:System.IO.FileMode" /&gt;</ph> 值之一。</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)">
          <source>One of the <ph id="ph1">&lt;see cref="T:System.IO.FileAccess" /&gt;</ph> values that determines how the file can be accessed by the <ph id="ph2">&lt;see cref="T:System.IO.Log.LogStore" /&gt;</ph>.</source>
          <target state="translated">用于确定 <ph id="ph1">&lt;see cref="T:System.IO.FileAccess" /&gt;</ph> 可以如何访问文件的 <ph id="ph2">&lt;see cref="T:System.IO.Log.LogStore" /&gt;</ph> 值之一。</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)">
          <source>One of the <ph id="ph1">&lt;see cref="T:System.IO.FileShare" /&gt;</ph> values that determines how the log store will be shared among processes.</source>
          <target state="translated">用于确定日志存储区将如何在进程之间共享的 <ph id="ph1">&lt;see cref="T:System.IO.FileShare" /&gt;</ph> 值之一。</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.IO.Log.LogRecordSequence" /&gt;</ph> class with a specified path to the log store and the access mode.</source>
          <target state="translated">使用指定的日志存储区路径和访问模式初始化 <ph id="ph1">&lt;see cref="T:System.IO.Log.LogRecordSequence" /&gt;</ph> 类的新实例。</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)">
          <source>This constructor initializes a new <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence&gt;</ph> on a new <ph id="ph2">&lt;xref:System.IO.Log.LogStore&gt;</ph> object that it opens with the specified path, mode, and access.</source>
          <target state="translated">此构造函数使用指定的路径、模式和访问权限来初始化它打开的新 <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence&gt;</ph> 对象上的新 <ph id="ph2">&lt;xref:System.IO.Log.LogStore&gt;</ph>，</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)">
          <source>The store is opened sharing the specified access.</source>
          <target state="translated">并打开了存储区以共享指定的访问权限。</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)">
          <source>This example shows how to use this <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence&gt;</ph> constructor:</source>
          <target state="translated">此示例演示如何使用此 <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence&gt;</ph> 构造函数：</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)">
          <source><ph id="ph1">&lt;paramref name="path" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="path" /&gt;</ph> 为 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)">
          <source><ph id="ph1">&lt;paramref name="path" /&gt;</ph> is an empty string ("").</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="path" /&gt;</ph> 为空字符串 ("")。</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)">
          <source><ph id="ph1">&lt;paramref name="path" /&gt;</ph> contains only white space.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="path" /&gt;</ph> 仅包含空白。</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)">
          <source><ph id="ph1">&lt;paramref name="path" /&gt;</ph> contains one or more invalid characters.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="path" /&gt;</ph> 包含一个或多个无效字符。</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)">
          <source><ph id="ph1">&lt;paramref name="mode" /&gt;</ph> contains an invalid value.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="mode" /&gt;</ph> 包含无效值。</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)">
          <source>The file cannot be found.</source>
          <target state="translated">无法找到该文件。</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)">
          <source>An I/O error occurs when opening the log store.</source>
          <target state="translated">打开日志存储区时发生了 I/O 错误。</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)">
          <source>Access for the specified log sequence is denied by the operating system.</source>
          <target state="translated">操作系统拒绝了对指定的日志序列的访问。</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)">
          <source>This operation is not supported.</source>
          <target state="translated">不支持此操作。</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)">
          <source>There is not enough memory to continue the execution of the program.</source>
          <target state="translated">没有足够的内存来继续执行该程序。</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)">
          <source><ph id="ph1">&lt;see cref="T:System.IO.Log.LogRecordSequence" /&gt;</ph> cannot be used because the required Common Log File System (CLFS) component is not installed.</source>
          <target state="translated">无法使用 <ph id="ph1">&lt;see cref="T:System.IO.Log.LogRecordSequence" /&gt;</ph>，因为没有安装所需的公用日志文件系统 (CLFS) 组件。</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)">
          <source>Install the CLFS component if it is available for your platform, or use the <ph id="ph1">&lt;see cref="T:System.IO.Log.FileRecordSequence" /&gt;</ph> class.</source>
          <target state="translated">如果可行，请为您的平台安装 CLFS 组件，或使用 <ph id="ph1">&lt;see cref="T:System.IO.Log.FileRecordSequence" /&gt;</ph> 类。</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Int32)">
          <source>A relative or absolute path for the base file of the log store to open.</source>
          <target state="translated">要打开的日志存储区的基文件的相对或绝对路径。</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Int32)">
          <source>One of the <ph id="ph1">&lt;see cref="T:System.IO.FileMode" /&gt;</ph> values that determines how to open or create the store.</source>
          <target state="translated">用于确定如何打开或创建存储区的 <ph id="ph1">&lt;see cref="T:System.IO.FileMode" /&gt;</ph> 值之一。</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Int32)">
          <source>One of the <ph id="ph1">&lt;see cref="T:System.IO.FileAccess" /&gt;</ph> values that determines how the file can be accessed by the <ph id="ph2">&lt;see cref="T:System.IO.Log.LogStore" /&gt;</ph>.</source>
          <target state="translated">用于确定 <ph id="ph1">&lt;see cref="T:System.IO.FileAccess" /&gt;</ph> 可以如何访问文件的 <ph id="ph2">&lt;see cref="T:System.IO.Log.LogStore" /&gt;</ph> 值之一。</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Int32)">
          <source>One of the <ph id="ph1">&lt;see cref="T:System.IO.FileShare" /&gt;</ph> values that determines how the log store will be shared among processes.</source>
          <target state="translated">用于确定日志存储区将如何在进程之间共享的 <ph id="ph1">&lt;see cref="T:System.IO.FileShare" /&gt;</ph> 值之一。</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Int32)">
          <source>The desired buffer size in bytes.</source>
          <target state="translated">所需的缓冲区大小（以字节为单位）。</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Int32)">
          <source>The buffer size determines the maximum size of the record that can be appended or read.</source>
          <target state="translated">缓冲区大小确定了可追加或读取的记录的最大大小。</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Int32)">
          <source>The desired number of buffers.</source>
          <target state="translated">所需的缓冲区数量。</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Int32)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.IO.Log.LogRecordSequence" /&gt;</ph> class with a specified path to the log store, file permission, access and share modes, and the buffer size and count for records.</source>
          <target state="translated">使用指定的日志存储区路径、文件权限、访问和共享模式以及记录的缓冲区大小和计数来初始化 <ph id="ph1">&lt;see cref="T:System.IO.Log.LogRecordSequence" /&gt;</ph> 类的新实例。</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Int32)">
          <source>This constructor initializes a new <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence&gt;</ph> on a new <ph id="ph2">&lt;xref:System.IO.Log.LogStore&gt;</ph> object that it opens with the specified path, mode, and access.</source>
          <target state="translated">此构造函数使用指定的路径、模式和访问权限来初始化它打开的新 <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence&gt;</ph> 对象上的新 <ph id="ph2">&lt;xref:System.IO.Log.LogStore&gt;</ph>，</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Int32)">
          <source>The store is opened sharing the specified access.</source>
          <target state="translated">并打开了存储区以共享指定的访问权限。</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="path" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="path" /&gt;</ph> 为 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="path" /&gt;</ph> is an empty string ("").</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="path" /&gt;</ph> 为空字符串 ("")。</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="path" /&gt;</ph> contains only white space.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="path" /&gt;</ph> 仅包含空白。</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="path" /&gt;</ph> contains one or more invalid characters.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="path" /&gt;</ph> 包含一个或多个无效字符。</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="mode" /&gt;</ph> contains an invalid value.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="mode" /&gt;</ph> 包含无效值。</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Int32)">
          <source>The file cannot be found.</source>
          <target state="translated">无法找到该文件。</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Int32)">
          <source>An I/O error occurs when opening the log store.</source>
          <target state="translated">打开日志存储区时发生了 I/O 错误。</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Int32)">
          <source>Access for the specified log sequence is denied by the operating system.</source>
          <target state="translated">操作系统拒绝了对指定的日志序列的访问。</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Int32)">
          <source>This operation is not supported.</source>
          <target state="translated">不支持此操作。</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Int32)">
          <source>There is not enough memory to continue the execution of the program.</source>
          <target state="translated">没有足够的内存来继续执行该程序。</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;see cref="T:System.IO.Log.LogRecordSequence" /&gt;</ph> cannot be used because the required Common Log File System (CLFS) component is not installed.</source>
          <target state="translated">无法使用 <ph id="ph1">&lt;see cref="T:System.IO.Log.LogRecordSequence" /&gt;</ph>，因为没有安装所需的公用日志文件系统 (CLFS) 组件。</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Int32)">
          <source>Install the CLFS component if it is available for your platform, or use the <ph id="ph1">&lt;see cref="T:System.IO.Log.FileRecordSequence" /&gt;</ph> class.</source>
          <target state="translated">如果可行，请为您的平台安装 CLFS 组件，或使用 <ph id="ph1">&lt;see cref="T:System.IO.Log.FileRecordSequence" /&gt;</ph> 类。</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Int32,System.Security.AccessControl.FileSecurity)">
          <source>A relative or absolute path for the base file of the log store to open.</source>
          <target state="translated">要打开的日志存储区的基文件的相对或绝对路径。</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Int32,System.Security.AccessControl.FileSecurity)">
          <source>A valid <ph id="ph1">&lt;see cref="T:System.IO.FileMode" /&gt;</ph> value that determines how to open or create the store.</source>
          <target state="translated">一个有效的 <ph id="ph1">&lt;see cref="T:System.IO.FileMode" /&gt;</ph> 值，用于确定如何打开或创建存储区。</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Int32,System.Security.AccessControl.FileSecurity)">
          <source>A valid <ph id="ph1">&lt;see cref="T:System.IO.FileAccess" /&gt;</ph> value that determines how the log store can be accessed.</source>
          <target state="translated">一个有效的 <ph id="ph1">&lt;see cref="T:System.IO.FileAccess" /&gt;</ph> 值，用于确定如何访问日志存储区。</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Int32,System.Security.AccessControl.FileSecurity)">
          <source>A valid <ph id="ph1">&lt;see cref="T:System.IO.FileShare" /&gt;</ph> value that determines how the log store will be shared among processes.</source>
          <target state="translated">一个有效的 <ph id="ph1">&lt;see cref="T:System.IO.FileShare" /&gt;</ph> 值，用于确定日志存储区将如何在进程之间共享。</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Int32,System.Security.AccessControl.FileSecurity)">
          <source>The desired buffer size in bytes.</source>
          <target state="translated">所需的缓冲区大小（以字节为单位）。</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Int32,System.Security.AccessControl.FileSecurity)">
          <source>The buffer size determines the maximum size of the record that can be appended or read.</source>
          <target state="translated">缓冲区大小确定了可追加或读取的记录的最大大小。</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Int32,System.Security.AccessControl.FileSecurity)">
          <source>The desired number of buffers.</source>
          <target state="translated">所需的缓冲区数量。</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Int32,System.Security.AccessControl.FileSecurity)">
          <source>A valid <ph id="ph1">&lt;see cref="T:System.Security.AccessControl.FileSecurity" /&gt;</ph> value that specifies the security to set on the newly created store if the store must be created.</source>
          <target state="translated">一个有效的 <ph id="ph1">&lt;see cref="T:System.Security.AccessControl.FileSecurity" /&gt;</ph> 值，指定在必须创建存储区的情况下，要为新创建的存储区设置的安全性。</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Int32,System.Security.AccessControl.FileSecurity)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.IO.Log.LogRecordSequence" /&gt;</ph> class.</source>
          <target state="translated">初始化 <ph id="ph1">&lt;see cref="T:System.IO.Log.LogRecordSequence" /&gt;</ph> 类的新实例。</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Int32,System.Security.AccessControl.FileSecurity)">
          <source>The file specified by <ph id="ph1">&lt;paramref name="path" /&gt;</ph> is not valid.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="path" /&gt;</ph> 指定的文件无效。</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Int32,System.Security.AccessControl.FileSecurity)">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Int32,System.Security.AccessControl.FileSecurity)">
          <source>The specified log store file name is not valid.</source>
          <target state="translated">指定的日志存储区文件名无效。</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Int32,System.Security.AccessControl.FileSecurity)">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Int32,System.Security.AccessControl.FileSecurity)">
          <source><ph id="ph1">&lt;paramref name="mode" /&gt;</ph> has a value of <ph id="ph2">&lt;see cref="F:System.IO.FileMode.CreateNew" /&gt;</ph>, and cannot be used without write access.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="mode" /&gt;</ph> 的值为 <ph id="ph2">&lt;see cref="F:System.IO.FileMode.CreateNew" /&gt;</ph>，在没有写访问权限的情况下无法使用它。</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Int32,System.Security.AccessControl.FileSecurity)">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Int32,System.Security.AccessControl.FileSecurity)">
          <source><ph id="ph1">&lt;paramref name="mode" /&gt;</ph> has a value of <ph id="ph2">&lt;see cref="F:System.IO.FileMode.OpenOrCreate" /&gt;</ph>, and cannot be used without write access.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="mode" /&gt;</ph> 的值为 <ph id="ph2">&lt;see cref="F:System.IO.FileMode.OpenOrCreate" /&gt;</ph>，在没有写访问权限的情况下无法使用它。</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Int32,System.Security.AccessControl.FileSecurity)">
          <source>One or more of the arguments are <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">一个或多个参数为 <ph id="ph1">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Int32,System.Security.AccessControl.FileSecurity)">
          <source>One or more of the arguments are out of range.</source>
          <target state="translated">一个或多个自变量超出范围。</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Int32,System.Security.AccessControl.FileSecurity)">
          <source>The file specified by <ph id="ph1">&lt;paramref name="path" /&gt;</ph> cannot be found.</source>
          <target state="translated">找不到 <ph id="ph1">&lt;paramref name="path" /&gt;</ph> 指定的文件。</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Int32,System.Security.AccessControl.FileSecurity)">
          <source>The request could not be performed because of an unexpected I/O exception.</source>
          <target state="translated">由于出现意外的 I/O 异常，因此无法执行该请求。</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Int32,System.Security.AccessControl.FileSecurity)">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Int32,System.Security.AccessControl.FileSecurity)">
          <source>The file specified by <ph id="ph1">&lt;paramref name="path" /&gt;</ph> cannot be accessed because it is in use by another process.</source>
          <target state="translated">无法访问 <ph id="ph1">&lt;paramref name="path" /&gt;</ph> 指定的文件，因为另一个进程正在使用该文件。</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Int32,System.Security.AccessControl.FileSecurity)">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Int32,System.Security.AccessControl.FileSecurity)">
          <source>The file specified by <ph id="ph1">&lt;paramref name="path" /&gt;</ph> cannot be created because the file or directory already exists.</source>
          <target state="translated">无法创建 <ph id="ph1">&lt;paramref name="path" /&gt;</ph> 指定的文件，因为该文件或目录已存在。</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Int32,System.Security.AccessControl.FileSecurity)">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Int32,System.Security.AccessControl.FileSecurity)">
          <source>The log handle could not be bound to the thread pool.</source>
          <target state="translated">日志句柄无法绑定到线程池。</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Int32,System.Security.AccessControl.FileSecurity)">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Int32,System.Security.AccessControl.FileSecurity)">
          <source>The specified log file format or version is invalid.</source>
          <target state="translated">指定的日志文件格式或版本无效。</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Int32,System.Security.AccessControl.FileSecurity)">
          <source>This operation is not supported.</source>
          <target state="translated">不支持此操作。</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Int32,System.Security.AccessControl.FileSecurity)">
          <source>The method was called after the sequence has been disposed of.</source>
          <target state="translated">该方法是在序列已释放之后调用的。</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Int32,System.Security.AccessControl.FileSecurity)">
          <source>There is not enough memory to continue the execution of the program.</source>
          <target state="translated">没有足够的内存来继续执行该程序。</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Int32,System.Security.AccessControl.FileSecurity)">
          <source><ph id="ph1">&lt;see cref="T:System.IO.Log.LogRecordSequence" /&gt;</ph> cannot be used because the required Common Log File System (CLFS) component is not installed.</source>
          <target state="translated">无法使用 <ph id="ph1">&lt;see cref="T:System.IO.Log.LogRecordSequence" /&gt;</ph>，因为没有安装所需的公用日志文件系统 (CLFS) 组件。</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Int32,System.Security.AccessControl.FileSecurity)">
          <source>Install the CLFS component if it is available for your platform, or use the <ph id="ph1">&lt;see cref="T:System.IO.Log.FileRecordSequence" /&gt;</ph> class.</source>
          <target state="translated">如果可行，请为您的平台安装 CLFS 组件，或使用 <ph id="ph1">&lt;see cref="T:System.IO.Log.FileRecordSequence" /&gt;</ph> 类。</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Int32,System.Security.AccessControl.FileSecurity)">
          <source>The record sequence is full.</source>
          <target state="translated">记录序列已满。</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Int32,System.Security.AccessControl.FileSecurity)">
          <source>Access for the specified log sequence is denied by the operating system.</source>
          <target state="translated">操作系统拒绝了对指定的日志序列的访问。</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.AdvanceBaseSequenceNumber(System.IO.Log.SequenceNumber)">
          <source>Specifies the new base <ph id="ph1">&lt;see cref="T:System.IO.Log.SequenceNumber" /&gt;</ph> for the log.</source>
          <target state="translated">为日志指定新的基 <ph id="ph1">&lt;see cref="T:System.IO.Log.SequenceNumber" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.AdvanceBaseSequenceNumber(System.IO.Log.SequenceNumber)">
          <source>This must lie in the range between the current base sequence number and the last sequence number of the log inclusively.</source>
          <target state="translated">这必须介于日志的当前基序列号和最后一个序列号之间（包括这两个序列号）。</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.AdvanceBaseSequenceNumber(System.IO.Log.SequenceNumber)">
          <source>Moves the base sequence number of the log forward.</source>
          <target state="translated">前移日志的基序列号。</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.AdvanceBaseSequenceNumber(System.IO.Log.SequenceNumber)">
          <source>This method cannot be inherited.</source>
          <target state="translated">不能继承此方法。</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.AdvanceBaseSequenceNumber(System.IO.Log.SequenceNumber)">
          <source>This method is often used with the <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence.TailPinned&gt;</ph> event to free up space in a record.</source>
          <target state="translated">此方法通常与 <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence.TailPinned&gt;</ph> 事件一起使用来释放记录中的空间。</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.AdvanceBaseSequenceNumber(System.IO.Log.SequenceNumber)">
          <source>The <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence.TailPinned&gt;</ph> event indicates that the tail of the sequence (that is, the base sequence number) needs to be moved forward to free up space.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence.TailPinned&gt;</ph> 事件指示，需要将序列的尾数据（即基序列号）前移以释放空间。</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.AdvanceBaseSequenceNumber(System.IO.Log.SequenceNumber)">
          <source>Freeing space can be done by either writing restart areas using the <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence.WriteRestartArea%2A&gt;</ph> method, or truncating the log and using the <ph id="ph2">&lt;xref:System.IO.Log.LogRecordSequence.AdvanceBaseSequenceNumber%2A&gt;</ph> method to advance the base sequence number of a log to the one specified by the <ph id="ph3">`newBaseSequenceNumber`</ph> parameter.</source>
          <target state="translated">可以使用以下两种方式来释放空间：使用 <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence.WriteRestartArea%2A&gt;</ph> 方法写入重新开始区域，或者截断日志并使用 <ph id="ph2">&lt;xref:System.IO.Log.LogRecordSequence.AdvanceBaseSequenceNumber%2A&gt;</ph> 方法将日志的基序列号前移到 <ph id="ph3">`newBaseSequenceNumber`</ph> 参数指定的序列号。</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.AdvanceBaseSequenceNumber(System.IO.Log.SequenceNumber)">
          <source>The code sample in the Example section demonstrates the second approach.</source>
          <target state="translated">“示例”部分的代码示例演示了第二种方式。</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.AdvanceBaseSequenceNumber(System.IO.Log.SequenceNumber)">
          <source>Note that calling this method is the same as setting a new base sequence number using the <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence.WriteRestartArea%2A&gt;</ph> method, except that no restart record is written to the log.</source>
          <target state="translated">请注意，调用此方法与使用 <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence.WriteRestartArea%2A&gt;</ph> 方法设置新的基序列号相同，只是没有将重新开始记录写入日志中。</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.AdvanceBaseSequenceNumber(System.IO.Log.SequenceNumber)">
          <source>This example shows how to use the <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence.AdvanceBaseSequenceNumber%2A&gt;</ph> method with the <ph id="ph2">&lt;xref:System.IO.Log.LogRecordSequence.TailPinned&gt;</ph> event to free up space in a log sequence.</source>
          <target state="translated">此示例演示如何将 <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence.AdvanceBaseSequenceNumber%2A&gt;</ph> 方法与 <ph id="ph2">&lt;xref:System.IO.Log.LogRecordSequence.TailPinned&gt;</ph> 事件一起使用来释放日志序列中的空间。</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.AdvanceBaseSequenceNumber(System.IO.Log.SequenceNumber)">
          <source><ph id="ph1">&lt;paramref name="newBaseSequenceNumber" /&gt;</ph> is not valid for this sequence.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="newBaseSequenceNumber" /&gt;</ph> 对此序列无效。</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.AdvanceBaseSequenceNumber(System.IO.Log.SequenceNumber)">
          <source>A new or existing archive tail or base of the active log is invalid.</source>
          <target state="translated">活动日志新存档或现有存档的尾数据或基数据无效。</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.AdvanceBaseSequenceNumber(System.IO.Log.SequenceNumber)">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.AdvanceBaseSequenceNumber(System.IO.Log.SequenceNumber)">
          <source><ph id="ph1">&lt;paramref name="newBaseSequenceNumber" /&gt;</ph> is not between the base and last sequence numbers of this sequence.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="newBaseSequenceNumber" /&gt;</ph> 不在此序列的基序列号和最后一个序列号之间。</target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.AdvanceBaseSequenceNumber(System.IO.Log.SequenceNumber)">
          <source>The request could not be performed because of an unexpected I/O exception.</source>
          <target state="translated">由于出现意外的 I/O 异常，因此无法执行该请求。</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.AdvanceBaseSequenceNumber(System.IO.Log.SequenceNumber)">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.AdvanceBaseSequenceNumber(System.IO.Log.SequenceNumber)">
          <source>The request could not be performed because of an I/O device error.</source>
          <target state="translated">由于出现 I/O 设备错误，因此无法执行该请求。</target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.AdvanceBaseSequenceNumber(System.IO.Log.SequenceNumber)">
          <source>The specified log does not have any extents.</source>
          <target state="translated">指定的日志没有任何范围。</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.AdvanceBaseSequenceNumber(System.IO.Log.SequenceNumber)">
          <source>One or more extents must be created before a record sequence may be used.</source>
          <target state="translated">必须创建一个或多个范围，然后才能使用记录序列。</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.AdvanceBaseSequenceNumber(System.IO.Log.SequenceNumber)">
          <source>The method was called after the sequence has been disposed of.</source>
          <target state="translated">该方法是在序列已释放之后调用的。</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.AdvanceBaseSequenceNumber(System.IO.Log.SequenceNumber)">
          <source>There is not enough memory to continue the execution of the program.</source>
          <target state="translated">没有足够的内存来继续执行该程序。</target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.AdvanceBaseSequenceNumber(System.IO.Log.SequenceNumber)">
          <source>Access for the specified log sequence is denied by the operating system.</source>
          <target state="translated">操作系统拒绝了对指定的日志序列的访问。</target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.AdvanceBaseSequenceNumber(System.IO.Log.SequenceNumber)">
          <source>The record sequence is full.</source>
          <target state="translated">记录序列已满。</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve" uid="T:System.IO.Log.LogRecordSequence">
          <source>Writes a log record to the <ph id="ph1">&lt;see cref="T:System.IO.Log.IRecordSequence" /&gt;</ph>.</source>
          <target state="translated">将日志记录写入 <ph id="ph1">&lt;see cref="T:System.IO.Log.IRecordSequence" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.Log.LogRecordSequence">
          <source>This example shows how to use the <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence.Append%2A&gt;</ph> member</source>
          <target state="translated">此示例演示如何使用 <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence.Append%2A&gt;</ph> 成员。</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)">
          <source>A list of byte array segments that will be concatenated and appended as the record.</source>
          <target state="translated">将连接在一起并以记录形式追加的字节数组段的列表。</target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)">
          <source>The sequence number of the next record in the user-specified order.</source>
          <target state="translated">用户指定顺序中下一条记录的序列号。</target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)">
          <source>The sequence number of the next record in Previous order.</source>
          <target state="translated">“上一个”顺序中下一条记录的序列号。</target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)">
          <source>A valid value of <ph id="ph1">&lt;see cref="T:System.IO.Log.RecordAppendOptions" /&gt;</ph> that specifies how the data should be written.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.IO.Log.RecordAppendOptions" /&gt;</ph> 的一个有效值，用于指定应如何写入数据。</target>       </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)">
          <source>Writes a log record to the <ph id="ph1">&lt;see cref="T:System.IO.Log.LogRecordSequence" /&gt;</ph>.</source>
          <target state="translated">将日志记录写入 <ph id="ph1">&lt;see cref="T:System.IO.Log.LogRecordSequence" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)">
          <source>This method cannot be inherited.</source>
          <target state="translated">不能继承此方法。</target>       </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)">
          <source>The sequence number of the appended log record.</source>
          <target state="translated">追加的日志记录的序列号。</target>       </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)">
          <source>Data contained in the <ph id="ph1">`data`</ph> parameter will be concatenated into a single byte array for appending as the record.</source>
          <target state="translated">包含在 <ph id="ph1">`data`</ph> 参数中的数据将连接成单个字节数组，以便以记录形式追加。</target>       </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)">
          <source>However, no provision is made for splitting data back into array segments when the record is read.</source>
          <target state="translated">但在读取记录时，无法将数据重新拆分为数组段。</target>       </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)">
          <source>Normally, this method completes before the record has been written.</source>
          <target state="translated">通常，此方法在写入记录之前完成。</target>       </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)">
          <source>To ensure that a record has been written, either specify the <ph id="ph1">&lt;xref:System.IO.Log.RecordAppendOptions.ForceFlush&gt;</ph> flag using the <ph id="ph2">`recordAppendOptions`</ph> parameter, or call the <ph id="ph3">&lt;xref:System.IO.Log.LogRecordSequence.Flush%2A&gt;</ph> method.</source>
          <target state="translated">若要确保记录已写入，请使用 <ph id="ph1">&lt;xref:System.IO.Log.RecordAppendOptions.ForceFlush&gt;</ph> 参数指定 <ph id="ph2">`recordAppendOptions`</ph> 标志，或者调用 <ph id="ph3">&lt;xref:System.IO.Log.LogRecordSequence.Flush%2A&gt;</ph> 方法。</target>       </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)">
          <source>The following example demonstrates how to use this method to append a log record to the sequence.</source>
          <target state="translated">下面的示例演示如何使用此方法向序列中追加日志记录。</target>       </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)">
          <source><ph id="ph1">&lt;paramref name="userRecord" /&gt;</ph> or <ph id="ph2">&lt;paramref name="previousRecord" /&gt;</ph> is not valid for this sequence.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="userRecord" /&gt;</ph> 或 <ph id="ph2">&lt;paramref name="previousRecord" /&gt;</ph> 对此序列无效。</target>       </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)">
          <source><ph id="ph1">&lt;paramref name="data" /&gt;</ph> cannot be appended because it is larger than the maximum record size.</source>
          <target state="translated">无法追加 <ph id="ph1">&lt;paramref name="data" /&gt;</ph>，原因是它比最大记录大小要大。</target>       </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)">
          <source><ph id="ph1">&lt;paramref name="reservations" /&gt;</ph> was not created by this record sequence.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="reservations" /&gt;</ph> 不是由此记录序列创建的。</target>       </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)">
          <source>One or more of the arguments are <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">一个或多个参数为 <ph id="ph1">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)">
          <source><ph id="ph1">&lt;paramref name="userRecord" /&gt;</ph> or <ph id="ph2">&lt;paramref name="previousRecord" /&gt;</ph> is not between the base and last sequence numbers of this sequence.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="userRecord" /&gt;</ph> 或 <ph id="ph2">&lt;paramref name="previousRecord" /&gt;</ph> 不在此序列的基序列号和最新序列号之间。</target>       </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)">
          <source>The request could not be performed because of an unexpected I/O exception.</source>
          <target state="translated">由于出现意外的 I/O 异常，因此无法执行该请求。</target>       </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)">
          <source>The request could not be performed because of an I/O device error.</source>
          <target state="translated">由于出现 I/O 设备错误，因此无法执行该请求。</target>       </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)">
          <source>The operation cannot be performed because the record sequence was opened with read-only access.</source>
          <target state="translated">由于记录序列是通过只读访问权限打开的，因此无法执行该操作。</target>       </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)">
          <source>The method was called after the sequence has been disposed of.</source>
          <target state="translated">该方法是在序列已释放之后调用的。</target>       </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)">
          <source>There is not enough memory to continue the execution of the program.</source>
          <target state="translated">没有足够的内存来继续执行该程序。</target>       </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)">
          <source>The record sequence is full.</source>
          <target state="translated">记录序列已满。</target>       </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)">
          <source>Access for the specified log sequence is denied by the operating system.</source>
          <target state="translated">操作系统拒绝了对指定的日志序列的访问。</target>       </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)">
          <source>A list of byte array segments that will be concatenated and appended as the record.</source>
          <target state="translated">将连接在一起并以记录形式追加的字节数组段的列表。</target>       </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)">
          <source>The sequence number of the next record in the user-specified order.</source>
          <target state="translated">用户指定顺序中下一条记录的序列号。</target>       </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)">
          <source>The sequence number of the next record in Previous order.</source>
          <target state="translated">“上一个”顺序中下一条记录的序列号。</target>       </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)">
          <source>A valid value of <ph id="ph1">&lt;see cref="T:System.IO.Log.RecordAppendOptions" /&gt;</ph> that specifies how the data should be written.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.IO.Log.RecordAppendOptions" /&gt;</ph> 的一个有效值，用于指定应如何写入数据。</target>       </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)">
          <source>Appends a log record to the <ph id="ph1">&lt;see cref="T:System.IO.Log.IRecordSequence" /&gt;</ph>.</source>
          <target state="translated">向 <ph id="ph1">&lt;see cref="T:System.IO.Log.IRecordSequence" /&gt;</ph> 中追加日志记录。</target>       </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)">
          <source>This method cannot be inherited.</source>
          <target state="translated">不能继承此方法。</target>       </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)">
          <source>The sequence number of the appended log record.</source>
          <target state="translated">追加的日志记录的序列号。</target>       </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)">
          <source>Data contained in the <ph id="ph1">`data`</ph> parameter will be concatenated into a single byte array for appending as the record.</source>
          <target state="translated">包含在 <ph id="ph1">`data`</ph> 参数中的数据将连接成单个字节数组，以便以记录形式追加。</target>       </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)">
          <source>However, no provision is made for splitting data back into array segments when the record is read.</source>
          <target state="translated">但在读取记录时，无法将数据重新拆分为数组段。</target>       </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)">
          <source>Normally, this method completes before the record has been written.</source>
          <target state="translated">通常，此方法在写入记录之前完成。</target>       </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)">
          <source>To ensure that a record has been written, either specify the <ph id="ph1">&lt;xref:System.IO.Log.RecordAppendOptions.ForceFlush&gt;</ph> flag using the <ph id="ph2">`recordAppendOptions`</ph> parameter, or call the <ph id="ph3">&lt;xref:System.IO.Log.LogRecordSequence.Flush%2A&gt;</ph> method.</source>
          <target state="translated">若要确保记录已写入，请使用 <ph id="ph1">&lt;xref:System.IO.Log.RecordAppendOptions.ForceFlush&gt;</ph> 参数指定 <ph id="ph2">`recordAppendOptions`</ph> 标志，或者调用 <ph id="ph3">&lt;xref:System.IO.Log.LogRecordSequence.Flush%2A&gt;</ph> 方法。</target>       </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)">
          <source><ph id="ph1">&lt;paramref name="userRecord" /&gt;</ph> or <ph id="ph2">&lt;paramref name="previousRecord" /&gt;</ph> is not valid for this sequence.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="userRecord" /&gt;</ph> 或 <ph id="ph2">&lt;paramref name="previousRecord" /&gt;</ph> 对此序列无效。</target>       </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)">
          <source><ph id="ph1">&lt;paramref name="data" /&gt;</ph> cannot be appended because it is larger than the maximum record size.</source>
          <target state="translated">无法追加 <ph id="ph1">&lt;paramref name="data" /&gt;</ph>，原因是它比最大记录大小要大。</target>       </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)">
          <source><ph id="ph1">&lt;paramref name="reservations" /&gt;</ph> was not created by this record sequence.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="reservations" /&gt;</ph> 不是由此记录序列创建的。</target>       </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)">
          <source>One or more of the arguments are <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">一个或多个参数为 <ph id="ph1">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)">
          <source><ph id="ph1">&lt;paramref name="userRecord" /&gt;</ph> or <ph id="ph2">&lt;paramref name="previousRecord" /&gt;</ph> is not between the base and last sequence numbers of this sequence.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="userRecord" /&gt;</ph> 或 <ph id="ph2">&lt;paramref name="previousRecord" /&gt;</ph> 不在此序列的基序列号和最新序列号之间。</target>       </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)">
          <source>The request could not be performed because of an unexpected I/O exception.</source>
          <target state="translated">由于出现意外的 I/O 异常，因此无法执行该请求。</target>       </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)">
          <source>The request could not be performed because of an I/O device error.</source>
          <target state="translated">由于出现 I/O 设备错误，因此无法执行该请求。</target>       </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)">
          <source>The operation cannot be performed because the record sequence was opened with read-only access.</source>
          <target state="translated">由于记录序列是通过只读访问权限打开的，因此无法执行该操作。</target>       </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)">
          <source>The method was called after the sequence has been disposed of.</source>
          <target state="translated">该方法是在序列已释放之后调用的。</target>       </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)">
          <source>There is not enough memory to continue the execution of the program.</source>
          <target state="translated">没有足够的内存来继续执行该程序。</target>       </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)">
          <source>The record sequence is full.</source>
          <target state="translated">记录序列已满。</target>       </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)">
          <source>Access for the specified log sequence is denied by the operating system.</source>
          <target state="translated">操作系统拒绝了对指定的日志序列的访问。</target>       </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)">
          <source>A list of byte array segments that will be concatenated and appended as the record.</source>
          <target state="translated">将连接在一起并以记录形式追加的字节数组段的列表。</target>       </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)">
          <source>The sequence number of the next record in the user-specified order.</source>
          <target state="translated">用户指定顺序中下一条记录的序列号。</target>       </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)">
          <source>The sequence number of the next record in Previous order.</source>
          <target state="translated">“上一个”顺序中下一条记录的序列号。</target>       </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)">
          <source>A valid value of <ph id="ph1">&lt;see cref="T:System.IO.Log.RecordAppendOptions" /&gt;</ph> that specifies how the data should be written.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.IO.Log.RecordAppendOptions" /&gt;</ph> 的一个有效值，用于指定应如何写入数据。</target>       </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)">
          <source>A <ph id="ph1">&lt;see cref="T:System.IO.Log.ReservationCollection" /&gt;</ph> that contains the reservation that should be used for this record.</source>
          <target state="translated">一个 <ph id="ph1">&lt;see cref="T:System.IO.Log.ReservationCollection" /&gt;</ph>，它包含应当用于此记录的保留。</target>       </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)">
          <source>Appends a log record to the <ph id="ph1">&lt;see cref="T:System.IO.Log.IRecordSequence" /&gt;</ph>, using space previously reserved in the sequence.</source>
          <target state="translated">使用序列中先前保留的空间向 <ph id="ph1">&lt;see cref="T:System.IO.Log.IRecordSequence" /&gt;</ph> 中追加日志记录。</target>       </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)">
          <source>This method cannot be inherited.</source>
          <target state="translated">不能继承此方法。</target>       </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)">
          <source>The sequence number of the appended log record.</source>
          <target state="translated">追加的日志记录的序列号。</target>       </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)">
          <source>Data contained in the <ph id="ph1">`data`</ph> parameter will be concatenated into a single byte array for appending as the record.</source>
          <target state="translated">包含在 <ph id="ph1">`data`</ph> 参数中的数据将连接成单个字节数组，以便以记录形式追加。</target>       </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)">
          <source>However, no provision is made for splitting data back into array segments when the record is read.</source>
          <target state="translated">但在读取记录时，无法将数据重新拆分为数组段。</target>       </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)">
          <source>The appended record will consume space that has been previously reserved, using a reservation specified by the <ph id="ph1">`reservations`</ph> parameter.</source>
          <target state="translated">追加的记录将使用 <ph id="ph1">`reservations`</ph> 参数指定的保留来占用先前已保留的空间。</target>       </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)">
          <source>If the append succeeds, it will consume the smallest reservation area that can hold the data, and that reservation area will be removed from the collection.</source>
          <target state="translated">如果追加成功，它将占用能容纳数据的最小保留区域，而该保留区域将从集合中移除。</target>       </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)">
          <source>Normally, this method completes before the record has been written.</source>
          <target state="translated">通常，此方法在写入记录之前完成。</target>       </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)">
          <source>To ensure that a record has been written, either specify the <ph id="ph1">&lt;xref:System.IO.Log.RecordAppendOptions.ForceFlush&gt;</ph> flag using the <ph id="ph2">`recordAppendOptions`</ph> parameter, or call the <ph id="ph3">&lt;xref:System.IO.Log.LogRecordSequence.Flush%2A&gt;</ph> method.</source>
          <target state="translated">若要确保记录已写入，请使用 <ph id="ph1">&lt;xref:System.IO.Log.RecordAppendOptions.ForceFlush&gt;</ph> 参数指定 <ph id="ph2">`recordAppendOptions`</ph> 标志，或者调用 <ph id="ph3">&lt;xref:System.IO.Log.LogRecordSequence.Flush%2A&gt;</ph> 方法。</target>       </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)">
          <source><ph id="ph1">&lt;paramref name="userRecord" /&gt;</ph> or <ph id="ph2">&lt;paramref name="previousRecord" /&gt;</ph> is not valid for this sequence.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="userRecord" /&gt;</ph> 或 <ph id="ph2">&lt;paramref name="previousRecord" /&gt;</ph> 对此序列无效。</target>       </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)">
          <source><ph id="ph1">&lt;paramref name="data" /&gt;</ph> cannot be appended because it is larger than the maximum record size.</source>
          <target state="translated">无法追加 <ph id="ph1">&lt;paramref name="data" /&gt;</ph>，原因是它比最大记录大小要大。</target>       </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)">
          <source><ph id="ph1">&lt;paramref name="reservations" /&gt;</ph> was not created by this record sequence.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="reservations" /&gt;</ph> 不是由此记录序列创建的。</target>       </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)">
          <source>One or more of the arguments are <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">一个或多个参数为 <ph id="ph1">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)">
          <source><ph id="ph1">&lt;paramref name="userRecord" /&gt;</ph> or <ph id="ph2">&lt;paramref name="previousRecord" /&gt;</ph> is not between the base and last sequence numbers of this sequence.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="userRecord" /&gt;</ph> 或 <ph id="ph2">&lt;paramref name="previousRecord" /&gt;</ph> 不在此序列的基序列号和最新序列号之间。</target>       </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)">
          <source>The request could not be performed because of an unexpected I/O exception.</source>
          <target state="translated">由于出现意外的 I/O 异常，因此无法执行该请求。</target>       </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)">
          <source>The request could not be performed because of an I/O device error.</source>
          <target state="translated">由于出现 I/O 设备错误，因此无法执行该请求。</target>       </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)">
          <source>The operation cannot be performed because the record sequence was opened with read-only access.</source>
          <target state="translated">由于记录序列是通过只读访问权限打开的，因此无法执行该操作。</target>       </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)">
          <source>The method was called after the sequence has been disposed of.</source>
          <target state="translated">该方法是在序列已释放之后调用的。</target>       </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)">
          <source>There is not enough memory to continue the execution of the program.</source>
          <target state="translated">没有足够的内存来继续执行该程序。</target>       </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)">
          <source>The record sequence is full.</source>
          <target state="translated">记录序列已满。</target>       </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)">
          <source>Access for the specified log sequence is denied by the operating system.</source>
          <target state="translated">操作系统拒绝了对指定的日志序列的访问。</target>       </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)">
          <source>No reservation large enough to fit <ph id="ph1">&lt;paramref name="data" /&gt;</ph> can be found in <ph id="ph2">&lt;paramref name="reservations" /&gt;</ph>.</source>
          <target state="translated">在 <ph id="ph1">&lt;paramref name="data" /&gt;</ph> 中找不到足以容纳 <ph id="ph2">&lt;paramref name="reservations" /&gt;</ph> 的保留。</target>       </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)">
          <source>A list of byte array segments that will be concatenated and appended as the record.</source>
          <target state="translated">将连接在一起并以记录形式追加的字节数组段的列表。</target>       </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)">
          <source>The sequence number of the next record in the user-specified order.</source>
          <target state="translated">用户指定顺序中下一条记录的序列号。</target>       </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)">
          <source>The sequence number of the next record in Previous order.</source>
          <target state="translated">“上一个”顺序中下一条记录的序列号。</target>       </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)">
          <source>A valid value of <ph id="ph1">&lt;see cref="T:System.IO.Log.RecordAppendOptions" /&gt;</ph> that specifies how the data should be written.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.IO.Log.RecordAppendOptions" /&gt;</ph> 的一个有效值，用于指定应如何写入数据。</target>       </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)">
          <source>A <ph id="ph1">&lt;see cref="T:System.IO.Log.ReservationCollection" /&gt;</ph> that contains the reservation that should be used for this record.</source>
          <target state="translated">一个 <ph id="ph1">&lt;see cref="T:System.IO.Log.ReservationCollection" /&gt;</ph>，它包含应当用于此记录的保留。</target>       </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)">
          <source>Appends a log record to the <ph id="ph1">&lt;see cref="T:System.IO.Log.IRecordSequence" /&gt;</ph>, using space previously reserved in the sequence.</source>
          <target state="translated">使用序列中先前保留的空间向 <ph id="ph1">&lt;see cref="T:System.IO.Log.IRecordSequence" /&gt;</ph> 中追加日志记录。</target>       </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)">
          <source>This method cannot be inherited.</source>
          <target state="translated">不能继承此方法。</target>       </trans-unit>
        <trans-unit id="361" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)">
          <source>The sequence number of the appended log record.</source>
          <target state="translated">追加的日志记录的序列号。</target>       </trans-unit>
        <trans-unit id="362" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)">
          <source>Data contained in the <ph id="ph1">`data`</ph> parameter will be concatenated into a single byte array for appending as the record.</source>
          <target state="translated">包含在 <ph id="ph1">`data`</ph> 参数中的数据将连接成单个字节数组，以便以记录形式追加。</target>       </trans-unit>
        <trans-unit id="363" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)">
          <source>However, no provision is made for splitting data back into array segments when the record is read.</source>
          <target state="translated">但在读取记录时，无法将数据重新拆分为数组段。</target>       </trans-unit>
        <trans-unit id="364" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)">
          <source>The appended record will consume space that has been previously reserved, using a reservation specified by the <ph id="ph1">`reservations`</ph> parameter.</source>
          <target state="translated">追加的记录将使用 <ph id="ph1">`reservations`</ph> 参数指定的保留来占用先前已保留的空间。</target>       </trans-unit>
        <trans-unit id="365" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)">
          <source>If the append succeeds, it will consume the smallest reservation area that can hold the data, and that reservation area will be removed from the collection.</source>
          <target state="translated">如果追加成功，它将占用能容纳数据的最小保留区域，而该保留区域将从集合中移除。</target>       </trans-unit>
        <trans-unit id="366" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)">
          <source>Normally, this method completes before the record has been written.</source>
          <target state="translated">通常，此方法在写入记录之前完成。</target>       </trans-unit>
        <trans-unit id="367" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)">
          <source>To ensure that a record has been written, either specify the <ph id="ph1">&lt;xref:System.IO.Log.RecordAppendOptions.ForceFlush&gt;</ph> flag using the <ph id="ph2">`recordAppendOptions`</ph> parameter, or call the <ph id="ph3">&lt;xref:System.IO.Log.IRecordSequence.Flush%2A&gt;</ph> method.</source>
          <target state="translated">若要确保记录已写入，请使用 <ph id="ph1">&lt;xref:System.IO.Log.RecordAppendOptions.ForceFlush&gt;</ph> 参数指定 <ph id="ph2">`recordAppendOptions`</ph> 标志，或者调用 <ph id="ph3">&lt;xref:System.IO.Log.IRecordSequence.Flush%2A&gt;</ph> 方法。</target>       </trans-unit>
        <trans-unit id="368" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)">
          <source><ph id="ph1">&lt;paramref name="userRecord" /&gt;</ph> or <ph id="ph2">&lt;paramref name="previousRecord" /&gt;</ph> is not valid for this sequence.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="userRecord" /&gt;</ph> 或 <ph id="ph2">&lt;paramref name="previousRecord" /&gt;</ph> 对此序列无效。</target>       </trans-unit>
        <trans-unit id="369" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="370" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)">
          <source><ph id="ph1">&lt;paramref name="data" /&gt;</ph> cannot be appended because it is larger than the maximum record size.</source>
          <target state="translated">无法追加 <ph id="ph1">&lt;paramref name="data" /&gt;</ph>，原因是它比最大记录大小要大。</target>       </trans-unit>
        <trans-unit id="371" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="372" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)">
          <source><ph id="ph1">&lt;paramref name="reservations" /&gt;</ph> was not created by this record sequence.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="reservations" /&gt;</ph> 不是由此记录序列创建的。</target>       </trans-unit>
        <trans-unit id="373" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)">
          <source>One or more of the arguments are <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">一个或多个参数为 <ph id="ph1">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="374" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)">
          <source><ph id="ph1">&lt;paramref name="userRecord" /&gt;</ph> or <ph id="ph2">&lt;paramref name="previousRecord" /&gt;</ph> is not between the base and last sequence numbers of this sequence.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="userRecord" /&gt;</ph> 或 <ph id="ph2">&lt;paramref name="previousRecord" /&gt;</ph> 不在此序列的基序列号和最新序列号之间。</target>       </trans-unit>
        <trans-unit id="375" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)">
          <source>The request could not be performed because of an unexpected I/O exception.</source>
          <target state="translated">由于出现意外的 I/O 异常，因此无法执行该请求。</target>       </trans-unit>
        <trans-unit id="376" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="377" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)">
          <source>The request could not be performed because of an I/O device error.</source>
          <target state="translated">由于出现 I/O 设备错误，因此无法执行该请求。</target>       </trans-unit>
        <trans-unit id="378" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)">
          <source>The operation cannot be performed because the record sequence was opened with read-only access.</source>
          <target state="translated">由于记录序列是通过只读访问权限打开的，因此无法执行该操作。</target>       </trans-unit>
        <trans-unit id="379" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)">
          <source>The method was called after the sequence has been disposed of.</source>
          <target state="translated">该方法是在序列已释放之后调用的。</target>       </trans-unit>
        <trans-unit id="380" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)">
          <source>There is not enough memory to continue the execution of the program.</source>
          <target state="translated">没有足够的内存来继续执行该程序。</target>       </trans-unit>
        <trans-unit id="381" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)">
          <source>The record sequence is full.</source>
          <target state="translated">记录序列已满。</target>       </trans-unit>
        <trans-unit id="382" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)">
          <source>Access for the specified log sequence is denied by the operating system.</source>
          <target state="translated">操作系统拒绝了对指定的日志序列的访问。</target>       </trans-unit>
        <trans-unit id="383" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)">
          <source>No reservation large enough to fit <ph id="ph1">&lt;paramref name="data" /&gt;</ph> can be found in <ph id="ph2">&lt;paramref name="reservations" /&gt;</ph>.</source>
          <target state="translated">在 <ph id="ph1">&lt;paramref name="data" /&gt;</ph> 中找不到足以容纳 <ph id="ph2">&lt;paramref name="reservations" /&gt;</ph> 的保留。</target>       </trans-unit>
        <trans-unit id="384" translate="yes" xml:space="preserve" uid="P:System.IO.Log.LogRecordSequence.BaseSequenceNumber">
          <source>Gets the sequence number of the first valid record in the current <ph id="ph1">&lt;see cref="T:System.IO.Log.LogRecordSequence" /&gt;</ph>.</source>
          <target state="translated">获取当前 <ph id="ph1">&lt;see cref="T:System.IO.Log.LogRecordSequence" /&gt;</ph> 中第一条有效记录的序列号。</target>       </trans-unit>
        <trans-unit id="385" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.Log.LogRecordSequence.BaseSequenceNumber">
          <source>The lowest sequence number that corresponds to a valid record in the <ph id="ph1">&lt;see cref="T:System.IO.Log.LogRecordSequence" /&gt;</ph>.</source>
          <target state="translated">与 <ph id="ph1">&lt;see cref="T:System.IO.Log.LogRecordSequence" /&gt;</ph> 中的有效记录对应的最低序列号。</target>       </trans-unit>
        <trans-unit id="386" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.Log.LogRecordSequence.BaseSequenceNumber">
          <source>Valid sequence numbers are greater than or equal to <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence.BaseSequenceNumber%2A&gt;</ph> and less than <ph id="ph2">&lt;xref:System.IO.Log.LogRecordSequence.LastSequenceNumber%2A&gt;</ph>.</source>
          <target state="translated">有效序列号大于或等于 <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence.BaseSequenceNumber%2A&gt;</ph> 且小于 <ph id="ph2">&lt;xref:System.IO.Log.LogRecordSequence.LastSequenceNumber%2A&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="387" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.Log.LogRecordSequence.BaseSequenceNumber">
          <source>The value of this property can be changed by calling the <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence.WriteRestartArea%2A&gt;</ph> method or <ph id="ph2">&lt;xref:System.IO.Log.LogRecordSequence.AdvanceBaseSequenceNumber%2A&gt;</ph> method.</source>
          <target state="translated">可通过调用 <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence.WriteRestartArea%2A&gt;</ph> 方法或 <ph id="ph2">&lt;xref:System.IO.Log.LogRecordSequence.AdvanceBaseSequenceNumber%2A&gt;</ph> 方法来更改此属性的值。</target>       </trans-unit>
        <trans-unit id="388" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.Log.LogRecordSequence.BaseSequenceNumber">
          <source>This example shows how to use the <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence.BaseSequenceNumber%2A&gt;</ph> member in a loop.</source>
          <target state="translated">此示例演示如何在循环中使用 <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence.BaseSequenceNumber%2A&gt;</ph> 成员。</target>       </trans-unit>
        <trans-unit id="389" translate="yes" xml:space="preserve" uid="P:System.IO.Log.LogRecordSequence.BaseSequenceNumber">
          <source>The property was accessed after the sequence has been disposed of.</source>
          <target state="translated">该属性是在序列已释放之后访问的。</target>       </trans-unit>
        <trans-unit id="390" translate="yes" xml:space="preserve" uid="T:System.IO.Log.LogRecordSequence">
          <source>Begins an asynchronous append operation.</source>
          <target state="translated">开始异步追加操作。</target>       </trans-unit>
        <trans-unit id="391" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)">
          <source>A list of byte array segments that will be concatenated and appended as the record.</source>
          <target state="translated">将连接在一起并以记录形式追加的字节数组段的列表。</target>       </trans-unit>
        <trans-unit id="392" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)">
          <source>The sequence number of the next record in the user-specified order.</source>
          <target state="translated">用户指定顺序中下一条记录的序列号。</target>       </trans-unit>
        <trans-unit id="393" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)">
          <source>The sequence number of the next record in Previous order.</source>
          <target state="translated">“上一个”顺序中下一条记录的序列号。</target>       </trans-unit>
        <trans-unit id="394" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)">
          <source>A valid value of <ph id="ph1">&lt;see cref="T:System.IO.Log.RecordAppendOptions" /&gt;</ph> that specifies how the data should be written.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.IO.Log.RecordAppendOptions" /&gt;</ph> 的一个有效值，用于指定应如何写入数据。</target>       </trans-unit>
        <trans-unit id="395" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)">
          <source>An optional asynchronous callback, to be called when the append is complete.</source>
          <target state="translated">可选的异步回调，在追加完成时调用。</target>       </trans-unit>
        <trans-unit id="396" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)">
          <source>A user-provided object that distinguishes this particular asynchronous append request from other requests.</source>
          <target state="translated">用户提供的对象，用于将此特定异步追加请求与其他请求区别开来。</target>       </trans-unit>
        <trans-unit id="397" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)">
          <source>Begins an asynchronous append operation.</source>
          <target state="translated">开始异步追加操作。</target>       </trans-unit>
        <trans-unit id="398" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)">
          <source>This method cannot be inherited.</source>
          <target state="translated">不能继承此方法。</target>       </trans-unit>
        <trans-unit id="399" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)">
          <source>An <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph> that represents the asynchronous append, which could still be pending.</source>
          <target state="translated">一个 <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph>，它表示可能仍处于挂起状态的异步追加。</target>       </trans-unit>
        <trans-unit id="400" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)">
          <source>You should pass the <ph id="ph1">&lt;xref:System.IAsyncResult&gt;</ph> returned by this method to the <ph id="ph2">&lt;xref:System.IO.Log.LogRecordSequence.EndAppend%2A&gt;</ph> method to ensure that the append operation has completed and resources can be freed appropriately.</source>
          <target state="translated">应将此方法返回的 <ph id="ph1">&lt;xref:System.IAsyncResult&gt;</ph> 传递给 <ph id="ph2">&lt;xref:System.IO.Log.LogRecordSequence.EndAppend%2A&gt;</ph> 方法，以确保追加操作完成并能够适当释放资源。</target>       </trans-unit>
        <trans-unit id="401" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)">
          <source>If an error has occurred during an asynchronous append, an exception is not thrown until the <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence.EndAppend%2A&gt;</ph> method is called with the <ph id="ph2">&lt;xref:System.IAsyncResult&gt;</ph> returned by this method.</source>
          <target state="translated">如果在异步追加过程中发生错误，则在使用此方法返回的 <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence.EndAppend%2A&gt;</ph> 调用 <ph id="ph2">&lt;xref:System.IAsyncResult&gt;</ph> 方法之前，不会引发异常。</target>       </trans-unit>
        <trans-unit id="402" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)">
          <source>Data contained in the <ph id="ph1">`data`</ph> parameter will be concatenated into a single byte array for appending as the record.</source>
          <target state="translated">包含在 <ph id="ph1">`data`</ph> 参数中的数据将连接成单个字节数组，以便以记录形式追加。</target>       </trans-unit>
        <trans-unit id="403" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)">
          <source>However, no provision is made for splitting data back into array segments when the record is read.</source>
          <target state="translated">但在读取记录时，无法将数据重新拆分为数组段。</target>       </trans-unit>
        <trans-unit id="404" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)">
          <source>Normally, this method completes before the record has been written.</source>
          <target state="translated">通常，此方法在写入记录之前完成。</target>       </trans-unit>
        <trans-unit id="405" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)">
          <source>To ensure that a record has been written, either specify the <ph id="ph1">&lt;xref:System.IO.Log.RecordAppendOptions.ForceFlush&gt;</ph> flag using the <ph id="ph2">`recordAppendOptions`</ph> parameter, or call the <ph id="ph3">&lt;xref:System.IO.Log.LogRecordSequence.Flush%2A&gt;</ph> method.</source>
          <target state="translated">若要确保记录已写入，请使用 <ph id="ph1">&lt;xref:System.IO.Log.RecordAppendOptions.ForceFlush&gt;</ph> 参数指定 <ph id="ph2">`recordAppendOptions`</ph> 标志，或者调用 <ph id="ph3">&lt;xref:System.IO.Log.LogRecordSequence.Flush%2A&gt;</ph> 方法。</target>       </trans-unit>
        <trans-unit id="406" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="nextUndoRecord" /&gt;</ph> or <ph id="ph2">&lt;paramref name="previousRecord" /&gt;</ph> is not valid for this sequence.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="nextUndoRecord" /&gt;</ph> 或 <ph id="ph2">&lt;paramref name="previousRecord" /&gt;</ph> 对此序列无效。</target>       </trans-unit>
        <trans-unit id="407" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="408" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="data" /&gt;</ph> cannot be appended because it is larger than the maximum record size.</source>
          <target state="translated">无法追加 <ph id="ph1">&lt;paramref name="data" /&gt;</ph>，原因是它比最大记录大小要大。</target>       </trans-unit>
        <trans-unit id="409" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="410" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="reservations" /&gt;</ph> was not created by this record sequence.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="reservations" /&gt;</ph> 不是由此记录序列创建的。</target>       </trans-unit>
        <trans-unit id="411" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)">
          <source>One or more of the arguments are <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">一个或多个参数为 <ph id="ph1">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="412" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="nextUndoRecord" /&gt;</ph> or <ph id="ph2">&lt;paramref name="previousRecord" /&gt;</ph> is not between the base and last sequence numbers of this sequence.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="nextUndoRecord" /&gt;</ph> 或 <ph id="ph2">&lt;paramref name="previousRecord" /&gt;</ph> 不在此序列的基序列号和最新序列号之间。</target>       </trans-unit>
        <trans-unit id="413" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)">
          <source>The request could not be performed because of an unexpected I/O exception.</source>
          <target state="translated">由于出现意外的 I/O 异常，因此无法执行该请求。</target>       </trans-unit>
        <trans-unit id="414" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="415" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)">
          <source>The request could not be performed because of an I/O device error.</source>
          <target state="translated">由于出现 I/O 设备错误，因此无法执行该请求。</target>       </trans-unit>
        <trans-unit id="416" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)">
          <source>The operation cannot be performed because the record sequence was opened with read-only access.</source>
          <target state="translated">由于记录序列是通过只读访问权限打开的，因此无法执行该操作。</target>       </trans-unit>
        <trans-unit id="417" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)">
          <source>The method was called after the sequence has been disposed of.</source>
          <target state="translated">该方法是在序列已释放之后调用的。</target>       </trans-unit>
        <trans-unit id="418" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)">
          <source>There is not enough memory to continue the execution of the program.</source>
          <target state="translated">没有足够的内存来继续执行该程序。</target>       </trans-unit>
        <trans-unit id="419" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)">
          <source>The record sequence is full.</source>
          <target state="translated">记录序列已满。</target>       </trans-unit>
        <trans-unit id="420" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)">
          <source>Access for the specified log sequence is denied by the operating system.</source>
          <target state="translated">操作系统拒绝了对指定的日志序列的访问。</target>       </trans-unit>
        <trans-unit id="421" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)">
          <source>A list of byte array segments that will be concatenated and appended as the record.</source>
          <target state="translated">将连接在一起并以记录形式追加的字节数组段的列表。</target>       </trans-unit>
        <trans-unit id="422" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)">
          <source>The sequence number of the next record in the user-specified order.</source>
          <target state="translated">用户指定顺序中下一条记录的序列号。</target>       </trans-unit>
        <trans-unit id="423" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)">
          <source>The sequence number of the next record in Previous order.</source>
          <target state="translated">“上一个”顺序中下一条记录的序列号。</target>       </trans-unit>
        <trans-unit id="424" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)">
          <source>A valid value of <ph id="ph1">&lt;see cref="T:System.IO.Log.RecordAppendOptions" /&gt;</ph> that specifies how the data should be written.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.IO.Log.RecordAppendOptions" /&gt;</ph> 的一个有效值，用于指定应如何写入数据。</target>       </trans-unit>
        <trans-unit id="425" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)">
          <source>An optional asynchronous callback, to be called when the append is complete.</source>
          <target state="translated">可选的异步回调，在追加完成时调用。</target>       </trans-unit>
        <trans-unit id="426" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)">
          <source>A user-provided object that distinguishes this particular asynchronous append request from other requests.</source>
          <target state="translated">用户提供的对象，用于将此特定异步追加请求与其他请求区别开来。</target>       </trans-unit>
        <trans-unit id="427" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)">
          <source>Begins an asynchronous append operation.</source>
          <target state="translated">开始异步追加操作。</target>       </trans-unit>
        <trans-unit id="428" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)">
          <source>This method cannot be inherited.</source>
          <target state="translated">不能继承此方法。</target>       </trans-unit>
        <trans-unit id="429" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)">
          <source>An <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph> that represents the asynchronous append, which could still be pending.</source>
          <target state="translated">一个 <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph>，它表示可能仍处于挂起状态的异步追加。</target>       </trans-unit>
        <trans-unit id="430" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)">
          <source>You should pass the <ph id="ph1">&lt;xref:System.IAsyncResult&gt;</ph> returned by this method to the <ph id="ph2">&lt;xref:System.IO.Log.LogRecordSequence.EndAppend%2A&gt;</ph> method to ensure that the append operation has completed and resources can be freed appropriately.</source>
          <target state="translated">应将此方法返回的 <ph id="ph1">&lt;xref:System.IAsyncResult&gt;</ph> 传递给 <ph id="ph2">&lt;xref:System.IO.Log.LogRecordSequence.EndAppend%2A&gt;</ph> 方法，以确保追加操作完成并能够适当释放资源。</target>       </trans-unit>
        <trans-unit id="431" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)">
          <source>If an error has occurred during an asynchronous append, an exception is not thrown until the <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence.EndAppend%2A&gt;</ph> method is called with the <ph id="ph2">&lt;xref:System.IAsyncResult&gt;</ph> returned by this method.</source>
          <target state="translated">如果在异步追加过程中发生错误，则在使用此方法返回的 <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence.EndAppend%2A&gt;</ph> 调用 <ph id="ph2">&lt;xref:System.IAsyncResult&gt;</ph> 方法之前，不会引发异常。</target>       </trans-unit>
        <trans-unit id="432" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)">
          <source>Data contained in the <ph id="ph1">`data`</ph> parameter will be concatenated into a single byte array for appending as the record.</source>
          <target state="translated">包含在 <ph id="ph1">`data`</ph> 参数中的数据将连接成单个字节数组，以便以记录形式追加。</target>       </trans-unit>
        <trans-unit id="433" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)">
          <source>However, no provision is made for splitting data back into array segments when the record is read.</source>
          <target state="translated">但在读取记录时，无法将数据重新拆分为数组段。</target>       </trans-unit>
        <trans-unit id="434" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)">
          <source>Normally, this method completes before the record has been written.</source>
          <target state="translated">通常，此方法在写入记录之前完成。</target>       </trans-unit>
        <trans-unit id="435" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)">
          <source>To ensure that a record has been written, either specify the <ph id="ph1">&lt;xref:System.IO.Log.RecordAppendOptions.ForceFlush&gt;</ph> flag using the <ph id="ph2">`recordAppendOptions`</ph> parameter, or call the <ph id="ph3">&lt;xref:System.IO.Log.LogRecordSequence.Flush%2A&gt;</ph> method.</source>
          <target state="translated">若要确保记录已写入，请使用 <ph id="ph1">&lt;xref:System.IO.Log.RecordAppendOptions.ForceFlush&gt;</ph> 参数指定 <ph id="ph2">`recordAppendOptions`</ph> 标志，或者调用 <ph id="ph3">&lt;xref:System.IO.Log.LogRecordSequence.Flush%2A&gt;</ph> 方法。</target>       </trans-unit>
        <trans-unit id="436" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="userRecord" /&gt;</ph> or <ph id="ph2">&lt;paramref name="previousRecord" /&gt;</ph> is not valid for this sequence.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="userRecord" /&gt;</ph> 或 <ph id="ph2">&lt;paramref name="previousRecord" /&gt;</ph> 对此序列无效。</target>       </trans-unit>
        <trans-unit id="437" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="438" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="data" /&gt;</ph> cannot be appended because it is larger than the maximum record size.</source>
          <target state="translated">无法追加 <ph id="ph1">&lt;paramref name="data" /&gt;</ph>，原因是它比最大记录大小要大。</target>       </trans-unit>
        <trans-unit id="439" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="440" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="reservations" /&gt;</ph> was not created by this record sequence.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="reservations" /&gt;</ph> 不是由此记录序列创建的。</target>       </trans-unit>
        <trans-unit id="441" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)">
          <source>One or more of the arguments are <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">一个或多个参数为 <ph id="ph1">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="442" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="userRecord" /&gt;</ph> or <ph id="ph2">&lt;paramref name="previousRecord" /&gt;</ph> is not between the base and last sequence numbers of this sequence.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="userRecord" /&gt;</ph> 或 <ph id="ph2">&lt;paramref name="previousRecord" /&gt;</ph> 不在此序列的基序列号和最新序列号之间。</target>       </trans-unit>
        <trans-unit id="443" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)">
          <source>The request could not be performed because of an unexpected I/O exception.</source>
          <target state="translated">由于出现意外的 I/O 异常，因此无法执行该请求。</target>       </trans-unit>
        <trans-unit id="444" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="445" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)">
          <source>The request could not be performed because of an I/O device error.</source>
          <target state="translated">由于出现 I/O 设备错误，因此无法执行该请求。</target>       </trans-unit>
        <trans-unit id="446" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)">
          <source>The operation cannot be performed because the record sequence was opened with read-only access.</source>
          <target state="translated">由于记录序列是通过只读访问权限打开的，因此无法执行该操作。</target>       </trans-unit>
        <trans-unit id="447" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)">
          <source>The method was called after the sequence has been disposed of.</source>
          <target state="translated">该方法是在序列已释放之后调用的。</target>       </trans-unit>
        <trans-unit id="448" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)">
          <source>There is not enough memory to continue the execution of the program.</source>
          <target state="translated">没有足够的内存来继续执行该程序。</target>       </trans-unit>
        <trans-unit id="449" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)">
          <source>The record sequence is full.</source>
          <target state="translated">记录序列已满。</target>       </trans-unit>
        <trans-unit id="450" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)">
          <source>Access for the specified log sequence is denied by the operating system.</source>
          <target state="translated">操作系统拒绝了对指定的日志序列的访问。</target>       </trans-unit>
        <trans-unit id="451" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>A list of byte array segments that will be concatenated and appended as the record.</source>
          <target state="translated">将连接在一起并以记录形式追加的字节数组段的列表。</target>       </trans-unit>
        <trans-unit id="452" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>The sequence number of the next record in the user-specified order.</source>
          <target state="translated">用户指定顺序中下一条记录的序列号。</target>       </trans-unit>
        <trans-unit id="453" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>The sequence number of the next record in Previous order.</source>
          <target state="translated">“上一个”顺序中下一条记录的序列号。</target>       </trans-unit>
        <trans-unit id="454" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>A valid value of <ph id="ph1">&lt;see cref="T:System.IO.Log.RecordAppendOptions" /&gt;</ph> that specifies how the data should be written.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.IO.Log.RecordAppendOptions" /&gt;</ph> 的一个有效值，用于指定应如何写入数据。</target>       </trans-unit>
        <trans-unit id="455" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>A <ph id="ph1">&lt;see cref="T:System.IO.Log.ReservationCollection" /&gt;</ph> that contains the reservation that should be used for this record.</source>
          <target state="translated">一个 <ph id="ph1">&lt;see cref="T:System.IO.Log.ReservationCollection" /&gt;</ph>，它包含应当用于此记录的保留。</target>       </trans-unit>
        <trans-unit id="456" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>An optional asynchronous callback, to be called when the append is complete.</source>
          <target state="translated">可选的异步回调，在追加完成时调用。</target>       </trans-unit>
        <trans-unit id="457" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>A user-provided object that distinguishes this particular asynchronous append request from other requests.</source>
          <target state="translated">用户提供的对象，用于将此特定异步追加请求与其他请求区别开来。</target>       </trans-unit>
        <trans-unit id="458" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>Begins an asynchronous append operation.</source>
          <target state="translated">开始异步追加操作。</target>       </trans-unit>
        <trans-unit id="459" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>This method cannot be inherited.</source>
          <target state="translated">不能继承此方法。</target>       </trans-unit>
        <trans-unit id="460" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>An <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph> that represents the asynchronous append, which could still be pending.</source>
          <target state="translated">一个 <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph>，它表示可能仍处于挂起状态的异步追加。</target>       </trans-unit>
        <trans-unit id="461" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>You should pass the <ph id="ph1">&lt;xref:System.IAsyncResult&gt;</ph> returned by this method to the <ph id="ph2">&lt;xref:System.IO.Log.LogRecordSequence.EndAppend%2A&gt;</ph> method to ensure that the append operation has completed and resources can be freed appropriately.</source>
          <target state="translated">应将此方法返回的 <ph id="ph1">&lt;xref:System.IAsyncResult&gt;</ph> 传递给 <ph id="ph2">&lt;xref:System.IO.Log.LogRecordSequence.EndAppend%2A&gt;</ph> 方法，以确保追加操作完成并能够适当释放资源。</target>       </trans-unit>
        <trans-unit id="462" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>If an error has occurred during an asynchronous append, an exception is not thrown until the <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence.EndAppend%2A&gt;</ph> method is called with the <ph id="ph2">&lt;xref:System.IAsyncResult&gt;</ph> returned by this method.</source>
          <target state="translated">如果在异步追加过程中发生错误，则在使用此方法返回的 <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence.EndAppend%2A&gt;</ph> 调用 <ph id="ph2">&lt;xref:System.IAsyncResult&gt;</ph> 方法之前，不会引发异常。</target>       </trans-unit>
        <trans-unit id="463" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>Data contained in the <ph id="ph1">`data`</ph> parameter will be concatenated into a single byte array for appending as the record.</source>
          <target state="translated">包含在 <ph id="ph1">`data`</ph> 参数中的数据将连接成单个字节数组，以便以记录形式追加。</target>       </trans-unit>
        <trans-unit id="464" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>However, no provision is made for splitting data back into array segments when the record is read.</source>
          <target state="translated">但在读取记录时，无法将数据重新拆分为数组段。</target>       </trans-unit>
        <trans-unit id="465" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>The appended record will consume space that has been previously reserved, using a reservation specified by the <ph id="ph1">`reservations`</ph> parameter.</source>
          <target state="translated">追加的记录将使用 <ph id="ph1">`reservations`</ph> 参数指定的保留来占用先前已保留的空间。</target>       </trans-unit>
        <trans-unit id="466" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>If the append succeeds, it will consume the smallest reservation area that can hold the data, and that reservation area will be removed from the collection.</source>
          <target state="translated">如果追加成功，它将占用能容纳数据的最小保留区域，而该保留区域将从集合中移除。</target>       </trans-unit>
        <trans-unit id="467" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>Normally, this method completes before the record has been written.</source>
          <target state="translated">通常，此方法在写入记录之前完成。</target>       </trans-unit>
        <trans-unit id="468" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>To ensure that a record has been written, either specify the <ph id="ph1">&lt;xref:System.IO.Log.RecordAppendOptions.ForceFlush&gt;</ph> flag using the <ph id="ph2">`recordAppendOptions`</ph> parameter, or call the <ph id="ph3">&lt;xref:System.IO.Log.LogRecordSequence.Flush%2A&gt;</ph> method.</source>
          <target state="translated">若要确保记录已写入，请使用 <ph id="ph1">&lt;xref:System.IO.Log.RecordAppendOptions.ForceFlush&gt;</ph> 参数指定 <ph id="ph2">`recordAppendOptions`</ph> 标志，或者调用 <ph id="ph3">&lt;xref:System.IO.Log.LogRecordSequence.Flush%2A&gt;</ph> 方法。</target>       </trans-unit>
        <trans-unit id="469" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="userRecord" /&gt;</ph> or <ph id="ph2">&lt;paramref name="previousRecord" /&gt;</ph> is not valid for this sequence.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="userRecord" /&gt;</ph> 或 <ph id="ph2">&lt;paramref name="previousRecord" /&gt;</ph> 对此序列无效。</target>       </trans-unit>
        <trans-unit id="470" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="471" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="data" /&gt;</ph> cannot be appended because it is larger than the maximum record size.</source>
          <target state="translated">无法追加 <ph id="ph1">&lt;paramref name="data" /&gt;</ph>，原因是它比最大记录大小要大。</target>       </trans-unit>
        <trans-unit id="472" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="473" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="reservations" /&gt;</ph> was not created by this record sequence.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="reservations" /&gt;</ph> 不是由此记录序列创建的。</target>       </trans-unit>
        <trans-unit id="474" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>One or more of the arguments are <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">一个或多个参数为 <ph id="ph1">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="475" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="userRecord" /&gt;</ph> or <ph id="ph2">&lt;paramref name="previousRecord" /&gt;</ph> is not between the base and last sequence numbers of this sequence.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="userRecord" /&gt;</ph> 或 <ph id="ph2">&lt;paramref name="previousRecord" /&gt;</ph> 不在此序列的基序列号和最新序列号之间。</target>       </trans-unit>
        <trans-unit id="476" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>The request could not be performed because of an unexpected I/O exception.</source>
          <target state="translated">由于出现意外的 I/O 异常，因此无法执行该请求。</target>       </trans-unit>
        <trans-unit id="477" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="478" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>The request could not be performed because of an I/O device error.</source>
          <target state="translated">由于出现 I/O 设备错误，因此无法执行该请求。</target>       </trans-unit>
        <trans-unit id="479" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>The operation cannot be performed because the record sequence was opened with read-only access.</source>
          <target state="translated">由于记录序列是通过只读访问权限打开的，因此无法执行该操作。</target>       </trans-unit>
        <trans-unit id="480" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>The method was called after the sequence has been disposed of.</source>
          <target state="translated">该方法是在序列已释放之后调用的。</target>       </trans-unit>
        <trans-unit id="481" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>There is not enough memory to continue the execution of the program.</source>
          <target state="translated">没有足够的内存来继续执行该程序。</target>       </trans-unit>
        <trans-unit id="482" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>The record sequence is full.</source>
          <target state="translated">记录序列已满。</target>       </trans-unit>
        <trans-unit id="483" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>Access for the specified log sequence is denied by the operating system.</source>
          <target state="translated">操作系统拒绝了对指定的日志序列的访问。</target>       </trans-unit>
        <trans-unit id="484" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>No reservation large enough to fit <ph id="ph1">&lt;paramref name="data" /&gt;</ph> can be found in <ph id="ph2">&lt;paramref name="reservations" /&gt;</ph>.</source>
          <target state="translated">在 <ph id="ph1">&lt;paramref name="data" /&gt;</ph> 中找不到足以容纳 <ph id="ph2">&lt;paramref name="reservations" /&gt;</ph> 的保留。</target>       </trans-unit>
        <trans-unit id="485" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>A list of byte array segments that will be concatenated and appended as the record.</source>
          <target state="translated">将连接在一起并以记录形式追加的字节数组段的列表。</target>       </trans-unit>
        <trans-unit id="486" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>The sequence number of the next record in the user-specified order.</source>
          <target state="translated">用户指定顺序中下一条记录的序列号。</target>       </trans-unit>
        <trans-unit id="487" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>The sequence number of the next record in Previous order.</source>
          <target state="translated">“上一个”顺序中下一条记录的序列号。</target>       </trans-unit>
        <trans-unit id="488" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>A valid value of <ph id="ph1">&lt;see cref="T:System.IO.Log.RecordAppendOptions" /&gt;</ph> that specifies how the data should be written.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.IO.Log.RecordAppendOptions" /&gt;</ph> 的一个有效值，用于指定应如何写入数据。</target>       </trans-unit>
        <trans-unit id="489" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>A <ph id="ph1">&lt;see cref="T:System.IO.Log.ReservationCollection" /&gt;</ph> that contains the reservation that should be used for this record.</source>
          <target state="translated">一个 <ph id="ph1">&lt;see cref="T:System.IO.Log.ReservationCollection" /&gt;</ph>，它包含应当用于此记录的保留。</target>       </trans-unit>
        <trans-unit id="490" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>An optional asynchronous callback, to be called when the append is complete.</source>
          <target state="translated">可选的异步回调，在追加完成时调用。</target>       </trans-unit>
        <trans-unit id="491" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>A user-provided object that distinguishes this particular asynchronous append request from other requests.</source>
          <target state="translated">用户提供的对象，用于将此特定异步追加请求与其他请求区别开来。</target>       </trans-unit>
        <trans-unit id="492" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>Begins an asynchronous append operation.</source>
          <target state="translated">开始异步追加操作。</target>       </trans-unit>
        <trans-unit id="493" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>This method cannot be inherited.</source>
          <target state="translated">不能继承此方法。</target>       </trans-unit>
        <trans-unit id="494" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>An <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph> that represents the asynchronous append, which could still be pending.</source>
          <target state="translated">一个 <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph>，它表示可能仍处于挂起状态的异步追加。</target>       </trans-unit>
        <trans-unit id="495" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>You should pass the <ph id="ph1">&lt;xref:System.IAsyncResult&gt;</ph> returned by this method to the <ph id="ph2">&lt;xref:System.IO.Log.LogRecordSequence.EndAppend%2A&gt;</ph> method to ensure that the append operation has completed and resources can be freed appropriately.</source>
          <target state="translated">应将此方法返回的 <ph id="ph1">&lt;xref:System.IAsyncResult&gt;</ph> 传递给 <ph id="ph2">&lt;xref:System.IO.Log.LogRecordSequence.EndAppend%2A&gt;</ph> 方法，以确保追加操作完成并能够适当释放资源。</target>       </trans-unit>
        <trans-unit id="496" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>If an error has occurred during an asynchronous append, an exception is not thrown until the <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence.EndAppend%2A&gt;</ph> method is called with the <ph id="ph2">&lt;xref:System.IAsyncResult&gt;</ph> returned by this method.</source>
          <target state="translated">如果在异步追加过程中发生错误，则在使用此方法返回的 <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence.EndAppend%2A&gt;</ph> 调用 <ph id="ph2">&lt;xref:System.IAsyncResult&gt;</ph> 方法之前，不会引发异常。</target>       </trans-unit>
        <trans-unit id="497" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>Data contained in the <ph id="ph1">`data`</ph> parameter will be concatenated into a single byte array for appending as the record.</source>
          <target state="translated">包含在 <ph id="ph1">`data`</ph> 参数中的数据将连接成单个字节数组，以便以记录形式追加。</target>       </trans-unit>
        <trans-unit id="498" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>However, no provision is made for splitting data back into array segments when the record is read.</source>
          <target state="translated">但在读取记录时，无法将数据重新拆分为数组段。</target>       </trans-unit>
        <trans-unit id="499" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>The appended record will consume space that has been previously reserved, using a reservation specified by the <ph id="ph1">`reservations`</ph> parameter.</source>
          <target state="translated">追加的记录将使用 <ph id="ph1">`reservations`</ph> 参数指定的保留来占用先前已保留的空间。</target>       </trans-unit>
        <trans-unit id="500" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>If the append succeeds, it will consume the smallest reservation area that can hold the data, and that reservation area will be removed from the collection.</source>
          <target state="translated">如果追加成功，它将占用能容纳数据的最小保留区域，而该保留区域将从集合中移除。</target>       </trans-unit>
        <trans-unit id="501" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>Normally, this method completes before the record has been written.</source>
          <target state="translated">通常，此方法在写入记录之前完成。</target>       </trans-unit>
        <trans-unit id="502" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>To ensure that a record has been written, either specify the <ph id="ph1">&lt;xref:System.IO.Log.RecordAppendOptions.ForceFlush&gt;</ph> flag using the <ph id="ph2">`recordAppendOptions`</ph> parameter, or call the <ph id="ph3">&lt;xref:System.IO.Log.LogRecordSequence.Flush%2A&gt;</ph> method.</source>
          <target state="translated">若要确保记录已写入，请使用 <ph id="ph1">&lt;xref:System.IO.Log.RecordAppendOptions.ForceFlush&gt;</ph> 参数指定 <ph id="ph2">`recordAppendOptions`</ph> 标志，或者调用 <ph id="ph3">&lt;xref:System.IO.Log.LogRecordSequence.Flush%2A&gt;</ph> 方法。</target>       </trans-unit>
        <trans-unit id="503" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="userRecord" /&gt;</ph> or <ph id="ph2">&lt;paramref name="previousRecord" /&gt;</ph> is not valid for this sequence.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="userRecord" /&gt;</ph> 或 <ph id="ph2">&lt;paramref name="previousRecord" /&gt;</ph> 对此序列无效。</target>       </trans-unit>
        <trans-unit id="504" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="505" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="data" /&gt;</ph> cannot be appended because it is larger than the maximum record size.</source>
          <target state="translated">无法追加 <ph id="ph1">&lt;paramref name="data" /&gt;</ph>，原因是它比最大记录大小要大。</target>       </trans-unit>
        <trans-unit id="506" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="507" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="reservations" /&gt;</ph> was not created by this record sequence.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="reservations" /&gt;</ph> 不是由此记录序列创建的。</target>       </trans-unit>
        <trans-unit id="508" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>One or more of the arguments are <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">一个或多个参数为 <ph id="ph1">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="509" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="userRecord" /&gt;</ph> or <ph id="ph2">&lt;paramref name="previousRecord" /&gt;</ph> is not between the base and last sequence numbers of this sequence.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="userRecord" /&gt;</ph> 或 <ph id="ph2">&lt;paramref name="previousRecord" /&gt;</ph> 不在此序列的基序列号和最新序列号之间。</target>       </trans-unit>
        <trans-unit id="510" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>The request could not be performed because of an unexpected I/O exception.</source>
          <target state="translated">由于出现意外的 I/O 异常，因此无法执行该请求。</target>       </trans-unit>
        <trans-unit id="511" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="512" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>The request could not be performed because of an I/O device error.</source>
          <target state="translated">由于出现 I/O 设备错误，因此无法执行该请求。</target>       </trans-unit>
        <trans-unit id="513" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>The operation cannot be performed because the record sequence was opened with read-only access.</source>
          <target state="translated">由于记录序列是通过只读访问权限打开的，因此无法执行该操作。</target>       </trans-unit>
        <trans-unit id="514" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>The method was called after the sequence has been disposed of.</source>
          <target state="translated">该方法是在序列已释放之后调用的。</target>       </trans-unit>
        <trans-unit id="515" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>There is not enough memory to continue the execution of the program.</source>
          <target state="translated">没有足够的内存来继续执行该程序。</target>       </trans-unit>
        <trans-unit id="516" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>The record sequence is full.</source>
          <target state="translated">记录序列已满。</target>       </trans-unit>
        <trans-unit id="517" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>Access for the specified log sequence is denied by the operating system.</source>
          <target state="translated">操作系统拒绝了对指定的日志序列的访问。</target>       </trans-unit>
        <trans-unit id="518" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>No reservation large enough to fit <ph id="ph1">&lt;paramref name="data" /&gt;</ph> can be found in <ph id="ph2">&lt;paramref name="reservations" /&gt;</ph>.</source>
          <target state="translated">在 <ph id="ph1">&lt;paramref name="data" /&gt;</ph> 中找不到足以容纳 <ph id="ph2">&lt;paramref name="reservations" /&gt;</ph> 的保留。</target>       </trans-unit>
        <trans-unit id="519" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginFlush(System.IO.Log.SequenceNumber,System.AsyncCallback,System.Object)">
          <source>The sequence number of the latest record that must be written.</source>
          <target state="translated">必须写入的最新记录的序列号。</target>       </trans-unit>
        <trans-unit id="520" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginFlush(System.IO.Log.SequenceNumber,System.AsyncCallback,System.Object)">
          <source>If this <ph id="ph1">&lt;see cref="T:System.IO.Log.SequenceNumber" /&gt;</ph> is invalid, then all records must be written.</source>
          <target state="translated">如果此 <ph id="ph1">&lt;see cref="T:System.IO.Log.SequenceNumber" /&gt;</ph> 无效，则必须写入所有记录。</target>       </trans-unit>
        <trans-unit id="521" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginFlush(System.IO.Log.SequenceNumber,System.AsyncCallback,System.Object)">
          <source>An optional asynchronous callback, to be called when the flush is complete.</source>
          <target state="translated">可选的异步回调，在刷新完成时调用。</target>       </trans-unit>
        <trans-unit id="522" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginFlush(System.IO.Log.SequenceNumber,System.AsyncCallback,System.Object)">
          <source>A user-provided object that distinguishes this particular asynchronous flush request from other requests.</source>
          <target state="translated">用户提供的对象，用于将此特定异步刷新请求与其他请求区别开来。</target>       </trans-unit>
        <trans-unit id="523" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginFlush(System.IO.Log.SequenceNumber,System.AsyncCallback,System.Object)">
          <source>Begins an asynchronous flush operation, using space previously reserved in the sequence.</source>
          <target state="translated">使用序列中先前保留的空间开始异步刷新操作。</target>       </trans-unit>
        <trans-unit id="524" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginFlush(System.IO.Log.SequenceNumber,System.AsyncCallback,System.Object)">
          <source>This method cannot be inherited.</source>
          <target state="translated">不能继承此方法。</target>       </trans-unit>
        <trans-unit id="525" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginFlush(System.IO.Log.SequenceNumber,System.AsyncCallback,System.Object)">
          <source>An <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph> that represents the asynchronous flush operation, which could still be pending.</source>
          <target state="translated">一个 <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph>，表示可能仍处于挂起状态的异步刷新操作。</target>       </trans-unit>
        <trans-unit id="526" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.BeginFlush(System.IO.Log.SequenceNumber,System.AsyncCallback,System.Object)">
          <source>You should pass the <ph id="ph1">&lt;xref:System.IAsyncResult&gt;</ph> returned by the current method to the <ph id="ph2">&lt;xref:System.IO.Log.LogRecordSequence.EndFlush%2A&gt;</ph> method to ensure that the flush completes and resources are freed appropriately.</source>
          <target state="translated">应将当前方法返回的 <ph id="ph1">&lt;xref:System.IAsyncResult&gt;</ph> 传递给 <ph id="ph2">&lt;xref:System.IO.Log.LogRecordSequence.EndFlush%2A&gt;</ph> 方法，以确保刷新完成并适当释放资源。</target>       </trans-unit>
        <trans-unit id="527" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.BeginFlush(System.IO.Log.SequenceNumber,System.AsyncCallback,System.Object)">
          <source>If an error occurs during an asynchronous flush, an exception is not thrown until the <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence.EndFlush%2A&gt;</ph> method is called with the <ph id="ph2">&lt;xref:System.IAsyncResult&gt;</ph> returned by this method.</source>
          <target state="translated">如果在异步刷新过程中发生错误，则在使用此方法返回的 <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence.EndFlush%2A&gt;</ph> 调用 <ph id="ph2">&lt;xref:System.IAsyncResult&gt;</ph> 方法之前，不会引发异常。</target>       </trans-unit>
        <trans-unit id="528" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.BeginFlush(System.IO.Log.SequenceNumber,System.AsyncCallback,System.Object)">
          <source>Calling this method ensures that all records that have been appended to the <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence&gt;</ph> are durably written.</source>
          <target state="translated">调用此方法可以确保已追加到 <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence&gt;</ph> 的所有记录都是持久写入的。</target>       </trans-unit>
        <trans-unit id="529" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.BeginFlush(System.IO.Log.SequenceNumber,System.AsyncCallback,System.Object)">
          <source>If a record sequence has been disposed of, or if you pass an invalid argument, exceptions are thrown immediately within this operation.</source>
          <target state="translated">如果记录序列已经释放，或者如果传递了无效自变量，此操作内将立即引发异常。</target>       </trans-unit>
        <trans-unit id="530" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.BeginFlush(System.IO.Log.SequenceNumber,System.AsyncCallback,System.Object)">
          <source>Errors that occurred during an asynchronous flush request, for example, a disk failure during the I/O request, will result in exceptions being thrown when the <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence.EndFlush%2A&gt;</ph> method is called.</source>
          <target state="translated">异步刷新请求过程中发生的错误（例如，I/O 请求过程中的磁盘故障）将导致在调用 <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence.EndFlush%2A&gt;</ph> 方法时引发异常。</target>       </trans-unit>
        <trans-unit id="531" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginFlush(System.IO.Log.SequenceNumber,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="sequenceNumber" /&gt;</ph> is not valid for this sequence.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="sequenceNumber" /&gt;</ph> 对此序列无效。</target>       </trans-unit>
        <trans-unit id="532" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginFlush(System.IO.Log.SequenceNumber,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="sequenceNumber" /&gt;</ph> is not between the base and last sequence numbers of this sequence.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="sequenceNumber" /&gt;</ph> 不在此序列的基序列号和最后一个序列号之间。</target>       </trans-unit>
        <trans-unit id="533" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginFlush(System.IO.Log.SequenceNumber,System.AsyncCallback,System.Object)">
          <source>The request could not be performed because of an unexpected I/O exception.</source>
          <target state="translated">由于出现意外的 I/O 异常，因此无法执行该请求。</target>       </trans-unit>
        <trans-unit id="534" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginFlush(System.IO.Log.SequenceNumber,System.AsyncCallback,System.Object)">
          <source>The specified log does not have any extents.</source>
          <target state="translated">指定的日志没有任何范围。</target>       </trans-unit>
        <trans-unit id="535" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginFlush(System.IO.Log.SequenceNumber,System.AsyncCallback,System.Object)">
          <source>One or more extents must be created before a record sequence can be used.</source>
          <target state="translated">必须创建一个或多个范围，然后才能使用记录序列。</target>       </trans-unit>
        <trans-unit id="536" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginFlush(System.IO.Log.SequenceNumber,System.AsyncCallback,System.Object)">
          <source>The operation cannot be performed because the record sequence was opened with read-only access.</source>
          <target state="translated">由于记录序列是通过只读访问权限打开的，因此无法执行该操作。</target>       </trans-unit>
        <trans-unit id="537" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginFlush(System.IO.Log.SequenceNumber,System.AsyncCallback,System.Object)">
          <source>The method was called after the sequence has been disposed of.</source>
          <target state="translated">该方法是在序列已释放之后调用的。</target>       </trans-unit>
        <trans-unit id="538" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginFlush(System.IO.Log.SequenceNumber,System.AsyncCallback,System.Object)">
          <source>There is not enough memory to continue the execution of the program.</source>
          <target state="translated">没有足够的内存来继续执行该程序。</target>       </trans-unit>
        <trans-unit id="539" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginFlush(System.IO.Log.SequenceNumber,System.AsyncCallback,System.Object)">
          <source>The record sequence is full.</source>
          <target state="translated">记录序列已满。</target>       </trans-unit>
        <trans-unit id="540" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginFlush(System.IO.Log.SequenceNumber,System.AsyncCallback,System.Object)">
          <source>Access for the specified log sequence is denied by the operating system.</source>
          <target state="translated">操作系统拒绝了对指定的日志序列的访问。</target>       </trans-unit>
        <trans-unit id="541" translate="yes" xml:space="preserve" uid="T:System.IO.Log.LogRecordSequence">
          <source>Begins an asynchronous reserve and append operation.</source>
          <target state="translated">开始异步保留和追加操作。</target>       </trans-unit>
        <trans-unit id="542" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)">
          <source>A list of byte array segments that will be concatenated and appended as the record.</source>
          <target state="translated">将连接在一起并以记录形式追加的字节数组段的列表。</target>       </trans-unit>
        <trans-unit id="543" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)">
          <source>The sequence number of the next record in the user-specified order.</source>
          <target state="translated">用户指定顺序中下一条记录的序列号。</target>       </trans-unit>
        <trans-unit id="544" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)">
          <source>The sequence number of the next record in Previous order.</source>
          <target state="translated">“上一个”顺序中下一条记录的序列号。</target>       </trans-unit>
        <trans-unit id="545" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)">
          <source>A valid value of <ph id="ph1">&lt;see cref="T:System.IO.Log.RecordAppendOptions" /&gt;</ph> that specifies how the data should be written.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.IO.Log.RecordAppendOptions" /&gt;</ph> 的一个有效值，用于指定应如何写入数据。</target>       </trans-unit>
        <trans-unit id="546" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)">
          <source>The reservation collection to make reservations in.</source>
          <target state="translated">要在其中生成保留的保留集合。</target>       </trans-unit>
        <trans-unit id="547" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)">
          <source>The reservations to make, in bytes.</source>
          <target state="translated">要生成的保留（以字节为单位）。</target>       </trans-unit>
        <trans-unit id="548" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)">
          <source>An optional asynchronous callback, to be called when the append is complete.</source>
          <target state="translated">可选的异步回调，在追加完成时调用。</target>       </trans-unit>
        <trans-unit id="549" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)">
          <source>A user-provided object that distinguishes this particular asynchronous append request from other requests.</source>
          <target state="translated">用户提供的对象，用于将此特定异步追加请求与其他请求区别开来。</target>       </trans-unit>
        <trans-unit id="550" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)">
          <source>Begins an asynchronous reserve and append operation.</source>
          <target state="translated">开始异步保留和追加操作。</target>       </trans-unit>
        <trans-unit id="551" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)">
          <source>This method cannot be inherited.</source>
          <target state="translated">不能继承此方法。</target>       </trans-unit>
        <trans-unit id="552" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)">
          <source>An <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph> that represents this asynchronous operation, which could still be pending.</source>
          <target state="translated">一个 <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph>，它表示可能仍处于挂起状态的当前异步操作。</target>       </trans-unit>
        <trans-unit id="553" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.BeginReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)">
          <source>You should pass the <ph id="ph1">&lt;xref:System.IAsyncResult&gt;</ph> returned by this method to the <ph id="ph2">&lt;xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A&gt;</ph> method to ensure that the append operation has completed and resources can be freed appropriately.</source>
          <target state="translated">应将此方法返回的 <ph id="ph1">&lt;xref:System.IAsyncResult&gt;</ph> 传递给 <ph id="ph2">&lt;xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A&gt;</ph> 方法，以确保追加操作完成并能够适当释放资源。</target>       </trans-unit>
        <trans-unit id="554" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.BeginReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)">
          <source>If an error has occurred during an asynchronous append, an exception is not thrown until the <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A&gt;</ph> method is called with the <ph id="ph2">&lt;xref:System.IAsyncResult&gt;</ph> returned by this method.</source>
          <target state="translated">如果在异步追加过程中发生错误，则在使用此方法返回的 <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A&gt;</ph> 调用 <ph id="ph2">&lt;xref:System.IAsyncResult&gt;</ph> 方法之前，不会引发异常。</target>       </trans-unit>
        <trans-unit id="555" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.BeginReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)">
          <source>Data contained in the <ph id="ph1">`data`</ph> parameter will be concatenated into a single byte array for appending as the record.</source>
          <target state="translated">包含在 <ph id="ph1">`data`</ph> 参数中的数据将连接成单个字节数组，以便以记录形式追加。</target>       </trans-unit>
        <trans-unit id="556" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.BeginReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)">
          <source>However, no provision is made for splitting data back into array segments when the record is read.</source>
          <target state="translated">但在读取记录时，无法将数据重新拆分为数组段。</target>       </trans-unit>
        <trans-unit id="557" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.BeginReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)">
          <source>The specified reservations are added to the provided reservation collection in an atomic operation with a record append operation.</source>
          <target state="translated">在原子操作中，使用记录追加操作将指定的保留添加到所提供的保留集合。</target>       </trans-unit>
        <trans-unit id="558" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.BeginReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)">
          <source>If the append fails, no space is reserved.</source>
          <target state="translated">如果追加失败，将不保留任何空间。</target>       </trans-unit>
        <trans-unit id="559" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.BeginReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)">
          <source>Normally, this method may complete before the record has been written.</source>
          <target state="translated">通常，此方法可以在写入记录之前完成。</target>       </trans-unit>
        <trans-unit id="560" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.BeginReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)">
          <source>To ensure that a record has been written, either specify the <ph id="ph1">&lt;xref:System.IO.Log.RecordAppendOptions.ForceFlush&gt;</ph> flag using the <ph id="ph2">`recordAppendOptions`</ph> parameter, or call the <ph id="ph3">&lt;xref:System.IO.Log.LogRecordSequence.Flush%2A&gt;</ph> method.</source>
          <target state="translated">若要确保记录已写入，请使用 <ph id="ph1">&lt;xref:System.IO.Log.RecordAppendOptions.ForceFlush&gt;</ph> 参数指定 <ph id="ph2">`recordAppendOptions`</ph> 标志，或者调用 <ph id="ph3">&lt;xref:System.IO.Log.LogRecordSequence.Flush%2A&gt;</ph> 方法。</target>       </trans-unit>
        <trans-unit id="561" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.BeginReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)">
          <source>If a record sequence has been disposed of, or if you pass an invalid argument, exceptions are thrown immediately within this operation.</source>
          <target state="translated">如果记录序列已经释放，或者如果传递了无效自变量，此操作内将立即引发异常。</target>       </trans-unit>
        <trans-unit id="562" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.BeginReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)">
          <source>Errors that occurred during an asynchronous append request, for example, a disk failure during the I/O request, will result in exceptions being thrown when the <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A&gt;</ph> method is called.</source>
          <target state="translated">异步追加请求过程中发生的错误（例如，I/O 请求过程中的磁盘故障）将导致在调用 <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A&gt;</ph> 方法时引发异常。</target>       </trans-unit>
        <trans-unit id="563" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="userRecord" /&gt;</ph> or <ph id="ph2">&lt;paramref name="previousRecord" /&gt;</ph> is not valid for this sequence.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="userRecord" /&gt;</ph> 或 <ph id="ph2">&lt;paramref name="previousRecord" /&gt;</ph> 对此序列无效。</target>       </trans-unit>
        <trans-unit id="564" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="565" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="data" /&gt;</ph> cannot be appended because it is larger than the maximum record size.</source>
          <target state="translated">无法追加 <ph id="ph1">&lt;paramref name="data" /&gt;</ph>，原因是它比最大记录大小要大。</target>       </trans-unit>
        <trans-unit id="566" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="567" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="reservations" /&gt;</ph> was not created by this record sequence.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="reservations" /&gt;</ph> 不是由此记录序列创建的。</target>       </trans-unit>
        <trans-unit id="568" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)">
          <source>One or more of the arguments are <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">一个或多个参数为 <ph id="ph1">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="569" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="userRecord" /&gt;</ph> or <ph id="ph2">&lt;paramref name="previousRecord" /&gt;</ph> is not between the base and last sequence numbers of this sequence.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="userRecord" /&gt;</ph> 或 <ph id="ph2">&lt;paramref name="previousRecord" /&gt;</ph> 不在此序列的基序列号和最新序列号之间。</target>       </trans-unit>
        <trans-unit id="570" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)">
          <source>The request could not be performed because of an unexpected I/O exception.</source>
          <target state="translated">由于出现意外的 I/O 异常，因此无法执行该请求。</target>       </trans-unit>
        <trans-unit id="571" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="572" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)">
          <source>The request could not be performed because of an I/O device error.</source>
          <target state="translated">由于出现 I/O 设备错误，因此无法执行该请求。</target>       </trans-unit>
        <trans-unit id="573" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)">
          <source>The operation cannot be performed because the record sequence was opened with read-only access.</source>
          <target state="translated">由于记录序列是通过只读访问权限打开的，因此无法执行该操作。</target>       </trans-unit>
        <trans-unit id="574" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)">
          <source>The method was called after the sequence has been disposed of.</source>
          <target state="translated">该方法是在序列已释放之后调用的。</target>       </trans-unit>
        <trans-unit id="575" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)">
          <source>There is not enough memory to continue the execution of the program.</source>
          <target state="translated">没有足够的内存来继续执行该程序。</target>       </trans-unit>
        <trans-unit id="576" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)">
          <source>The record sequence is full.</source>
          <target state="translated">记录序列已满。</target>       </trans-unit>
        <trans-unit id="577" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)">
          <source>Access for the specified log sequence is denied by the operating system.</source>
          <target state="translated">操作系统拒绝了对指定的日志序列的访问。</target>       </trans-unit>
        <trans-unit id="578" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)">
          <source>No reservation large enough to fit <ph id="ph1">&lt;paramref name="data" /&gt;</ph> can be found in <ph id="ph2">&lt;paramref name="reservations" /&gt;</ph>.</source>
          <target state="translated">在 <ph id="ph1">&lt;paramref name="data" /&gt;</ph> 中找不到足以容纳 <ph id="ph2">&lt;paramref name="reservations" /&gt;</ph> 的保留。</target>       </trans-unit>
        <trans-unit id="579" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)">
          <source>A list of byte array segments that will be concatenated and appended as the record.</source>
          <target state="translated">将连接在一起并以记录形式追加的字节数组段的列表。</target>       </trans-unit>
        <trans-unit id="580" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)">
          <source>The sequence number of the next record in the user-specified order.</source>
          <target state="translated">用户指定顺序中下一条记录的序列号。</target>       </trans-unit>
        <trans-unit id="581" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)">
          <source>The sequence number of the next record in Previous order.</source>
          <target state="translated">“上一个”顺序中下一条记录的序列号。</target>       </trans-unit>
        <trans-unit id="582" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)">
          <source>A valid value of <ph id="ph1">&lt;see cref="T:System.IO.Log.RecordAppendOptions" /&gt;</ph> that specifies how the data should be written.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.IO.Log.RecordAppendOptions" /&gt;</ph> 的一个有效值，用于指定应如何写入数据。</target>       </trans-unit>
        <trans-unit id="583" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)">
          <source>The reservation collection to make reservations in.</source>
          <target state="translated">要在其中生成保留的保留集合。</target>       </trans-unit>
        <trans-unit id="584" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)">
          <source>The reservations to make, in bytes.</source>
          <target state="translated">要生成的保留（以字节为单位）。</target>       </trans-unit>
        <trans-unit id="585" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)">
          <source>An optional asynchronous callback, to be called when the append is complete.</source>
          <target state="translated">可选的异步回调，在追加完成时调用。</target>       </trans-unit>
        <trans-unit id="586" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)">
          <source>A user-provided object that distinguishes this particular asynchronous append request from other requests.</source>
          <target state="translated">用户提供的对象，用于将此特定异步追加请求与其他请求区别开来。</target>       </trans-unit>
        <trans-unit id="587" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)">
          <source>Begins an asynchronous reserve and append operation.</source>
          <target state="translated">开始异步保留和追加操作。</target>       </trans-unit>
        <trans-unit id="588" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)">
          <source>This method cannot be inherited.</source>
          <target state="translated">不能继承此方法。</target>       </trans-unit>
        <trans-unit id="589" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)">
          <source>An <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph> that represents this asynchronous operation, which could still be pending.</source>
          <target state="translated">一个 <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph>，它表示可能仍处于挂起状态的当前异步操作。</target>       </trans-unit>
        <trans-unit id="590" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.BeginReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)">
          <source>You should pass the <ph id="ph1">&lt;xref:System.IAsyncResult&gt;</ph> returned by this method to the <ph id="ph2">&lt;xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A&gt;</ph> method to ensure that the append operation has completed and resources can be freed appropriately.</source>
          <target state="translated">应将此方法返回的 <ph id="ph1">&lt;xref:System.IAsyncResult&gt;</ph> 传递给 <ph id="ph2">&lt;xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A&gt;</ph> 方法，以确保追加操作完成并能够适当释放资源。</target>       </trans-unit>
        <trans-unit id="591" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.BeginReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)">
          <source>If an error has occurred during an asynchronous append, an exception is not thrown until the <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A&gt;</ph> method is called with the <ph id="ph2">&lt;xref:System.IAsyncResult&gt;</ph> returned by this method.</source>
          <target state="translated">如果在异步追加过程中发生错误，则在使用此方法返回的 <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A&gt;</ph> 调用 <ph id="ph2">&lt;xref:System.IAsyncResult&gt;</ph> 方法之前，不会引发异常。</target>       </trans-unit>
        <trans-unit id="592" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.BeginReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)">
          <source>Data contained in the <ph id="ph1">`data`</ph> parameter will be concatenated into a single byte array for appending as the record.</source>
          <target state="translated">包含在 <ph id="ph1">`data`</ph> 参数中的数据将连接成单个字节数组，以便以记录形式追加。</target>       </trans-unit>
        <trans-unit id="593" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.BeginReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)">
          <source>However, no provision is made for splitting data back into array segments when the record is read.</source>
          <target state="translated">但在读取记录时，无法将数据重新拆分为数组段。</target>       </trans-unit>
        <trans-unit id="594" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.BeginReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)">
          <source>The specified reservations are added to the provided reservation collection in an atomic operation with a record append operation.</source>
          <target state="translated">在原子操作中，使用记录追加操作将指定的保留添加到所提供的保留集合。</target>       </trans-unit>
        <trans-unit id="595" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.BeginReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)">
          <source>If the append fails, no space is reserved.</source>
          <target state="translated">如果追加失败，将不保留任何空间。</target>       </trans-unit>
        <trans-unit id="596" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.BeginReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)">
          <source>Normally, this method may complete before the record has been written.</source>
          <target state="translated">通常，此方法可以在写入记录之前完成。</target>       </trans-unit>
        <trans-unit id="597" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.BeginReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)">
          <source>To ensure that a record has been written, either specify the <ph id="ph1">&lt;xref:System.IO.Log.RecordAppendOptions.ForceFlush&gt;</ph> flag using the <ph id="ph2">`recordAppendOptions`</ph> parameter, or call the <ph id="ph3">&lt;xref:System.IO.Log.LogRecordSequence.Flush%2A&gt;</ph> method.</source>
          <target state="translated">若要确保记录已写入，请使用 <ph id="ph1">&lt;xref:System.IO.Log.RecordAppendOptions.ForceFlush&gt;</ph> 参数指定 <ph id="ph2">`recordAppendOptions`</ph> 标志，或者调用 <ph id="ph3">&lt;xref:System.IO.Log.LogRecordSequence.Flush%2A&gt;</ph> 方法。</target>       </trans-unit>
        <trans-unit id="598" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.BeginReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)">
          <source>If a record sequence has been disposed of, or if you pass an invalid argument, exceptions are thrown immediately within this operation.</source>
          <target state="translated">如果记录序列已经释放，或者如果传递了无效自变量，此操作内将立即引发异常。</target>       </trans-unit>
        <trans-unit id="599" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.BeginReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)">
          <source>Errors that occurred during an asynchronous append request, for example, a disk failure during the I/O request, will result in exceptions being thrown when the <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A&gt;</ph> method is called.</source>
          <target state="translated">异步追加请求过程中发生的错误（例如，I/O 请求过程中的磁盘故障）将导致在调用 <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A&gt;</ph> 方法时引发异常。</target>       </trans-unit>
        <trans-unit id="600" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)">
          <source>One or more of the arguments is invalid.</source>
          <target state="translated">一个或多个自变量无效。</target>       </trans-unit>
        <trans-unit id="601" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)">
          <source>An I/O error occurred while appending the record.</source>
          <target state="translated">追加记录时，发生了 I/O 错误。</target>       </trans-unit>
        <trans-unit id="602" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)">
          <source>The record sequence could not make enough free space to contain the new record, or to make the reservation.</source>
          <target state="translated">记录序列无法获得足够的可用空间来容纳新记录或生成保留。</target>       </trans-unit>
        <trans-unit id="603" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)">
          <source>The method was called after the sequence has been disposed of.</source>
          <target state="translated">该方法是在序列已释放之后调用的。</target>       </trans-unit>
        <trans-unit id="604" translate="yes" xml:space="preserve" uid="T:System.IO.Log.LogRecordSequence">
          <source>Begins an asynchronous restart area write operation.</source>
          <target state="translated">开始异步重新开始区域写入操作。</target>       </trans-unit>
        <trans-unit id="605" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>Byte array segments that will be concatenated and appended as the record.</source>
          <target state="translated">将连接在一起并以记录形式追加的字节数组段。</target>       </trans-unit>
        <trans-unit id="606" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>The new base sequence number.</source>
          <target state="translated">新的基序列号。</target>       </trans-unit>
        <trans-unit id="607" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>The specified sequence number must be greater than or equal to the current base sequence number.</source>
          <target state="translated">指定的序列号必须大于或等于当前基序列号。</target>       </trans-unit>
        <trans-unit id="608" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>A <ph id="ph1">&lt;see cref="T:System.IO.Log.ReservationCollection" /&gt;</ph> that contains the reservation that should be used for this restart area.</source>
          <target state="translated">一个 <ph id="ph1">&lt;see cref="T:System.IO.Log.ReservationCollection" /&gt;</ph>，它包含应当用于此重新开始区域的保留。</target>       </trans-unit>
        <trans-unit id="609" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>An optional asynchronous callback, to be called when the restart area write is complete.</source>
          <target state="translated">可选的异步回调，在重新开始区域写入完成时调用。</target>       </trans-unit>
        <trans-unit id="610" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>A user-provided object that distinguishes this particular asynchronous restart area write request from other requests.</source>
          <target state="translated">用户提供的对象，用于将此特定异步重新开始区域写入请求与其他请求区别开来。</target>       </trans-unit>
        <trans-unit id="611" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>Begins an asynchronous restart area write operation, using space previously reserved in the sequence.</source>
          <target state="translated">使用序列中先前保留的空间开始异步重新开始区域写入操作。</target>       </trans-unit>
        <trans-unit id="612" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>This method cannot be inherited.</source>
          <target state="translated">不能继承此方法。</target>       </trans-unit>
        <trans-unit id="613" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>An <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph> that represents the asynchronous restart area write operation, which could still be pending.</source>
          <target state="translated">一个 <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph>，它表示可能仍处于挂起状态的异步重新开始区域写入操作。</target>       </trans-unit>
        <trans-unit id="614" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>You should pass the <ph id="ph1">&lt;xref:System.IAsyncResult&gt;</ph> returned by this method to the <ph id="ph2">&lt;xref:System.IO.Log.LogRecordSequence.EndWriteRestartArea%2A&gt;</ph> method to ensure that the restart area write operation has completed and resources can be freed appropriately.</source>
          <target state="translated">应将此方法返回的 <ph id="ph1">&lt;xref:System.IAsyncResult&gt;</ph> 传递给 <ph id="ph2">&lt;xref:System.IO.Log.LogRecordSequence.EndWriteRestartArea%2A&gt;</ph> 方法，以确保重新开始区域写入操作完成并能够适当释放资源。</target>       </trans-unit>
        <trans-unit id="615" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>If an error has occurred during an asynchronous restart area write operation, an exception is not thrown until the <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence.EndWriteRestartArea%2A&gt;</ph> method is called with the <ph id="ph2">&lt;xref:System.IAsyncResult&gt;</ph> returned by this method.</source>
          <target state="translated">如果在异步重新开始区域写入操作过程中发生错误，则在使用此方法返回的 <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence.EndWriteRestartArea%2A&gt;</ph> 调用 <ph id="ph2">&lt;xref:System.IAsyncResult&gt;</ph> 方法之前，不会引发异常。</target>       </trans-unit>
        <trans-unit id="616" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>Data contained in the <ph id="ph1">`data`</ph> parameter will be concatenated into a single byte array for appending as the record.</source>
          <target state="translated">包含在 <ph id="ph1">`data`</ph> 参数中的数据将连接成单个字节数组，以便以记录形式追加。</target>       </trans-unit>
        <trans-unit id="617" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>However, no provision is made for splitting data back into array segments when the record is read.</source>
          <target state="translated">但在读取记录时，无法将数据重新拆分为数组段。</target>       </trans-unit>
        <trans-unit id="618" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>When the operation successfully completes, the base sequence number has been updated.</source>
          <target state="translated">操作成功完成时，基序列号已更新。</target>       </trans-unit>
        <trans-unit id="619" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>All log records with sequence numbers less than the new base sequence number are inaccessible.</source>
          <target state="translated">其序列号小于新的基序列号的所有日志记录都不可访问。</target>       </trans-unit>
        <trans-unit id="620" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>If a <ph id="ph1">&lt;xref:System.IO.Log.ReservationCollection&gt;</ph> is specified, the written restart area will consume space that has been previously reserved, using a reservation contained in the collection.</source>
          <target state="translated">如果指定了 <ph id="ph1">&lt;xref:System.IO.Log.ReservationCollection&gt;</ph>，写入的重新开始区域将使用集合中包含的保留来占用先前已保留的空间。</target>       </trans-unit>
        <trans-unit id="621" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>If the method succeeds, it will consume the smallest reservation that can hold the data, and that reservation will be removed from the collection.</source>
          <target state="translated">如果该方法成功，它将占用能容纳数据的最小保留，而该保留将从集合中移除。</target>       </trans-unit>
        <trans-unit id="622" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>If a record sequence has been disposed of, or if you pass an invalid argument, exceptions are thrown immediately within this operation.</source>
          <target state="translated">如果记录序列已经释放，或者如果传递了无效自变量，此操作内将立即引发异常。</target>       </trans-unit>
        <trans-unit id="623" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>Errors that occurred during an asynchronous append request, for example, a disk failure during the I/O request, will result in exceptions being thrown when the <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence.EndWriteRestartArea%2A&gt;</ph> method is called.</source>
          <target state="translated">异步追加请求过程中发生的错误（例如，I/O 请求过程中的磁盘故障）将导致在调用 <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence.EndWriteRestartArea%2A&gt;</ph> 方法时引发异常。</target>       </trans-unit>
        <trans-unit id="624" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="newBaseSeqNum" /&gt;</ph> is not valid for this sequence.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="newBaseSeqNum" /&gt;</ph> 对此序列无效。</target>       </trans-unit>
        <trans-unit id="625" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="626" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>The specified log enumeration start sequence number is invalid.</source>
          <target state="translated">指定的日志枚举开始序列号无效。</target>       </trans-unit>
        <trans-unit id="627" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="628" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="data" /&gt;</ph> cannot be appended because it is larger than the maximum record size.</source>
          <target state="translated">无法追加 <ph id="ph1">&lt;paramref name="data" /&gt;</ph>，原因是它比最大记录大小要大。</target>       </trans-unit>
        <trans-unit id="629" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="630" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="reservation" /&gt;</ph> was not created by this record sequence.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="reservation" /&gt;</ph> 不是由此记录序列创建的。</target>       </trans-unit>
        <trans-unit id="631" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>One or more of the parameters is <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">一个或多个参数为 <ph id="ph1">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="632" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>A new or existing archive tail or base of the active log is invalid.</source>
          <target state="translated">活动日志新存档或现有存档的尾数据或基数据无效。</target>       </trans-unit>
        <trans-unit id="633" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="634" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="newBaseSeqNum" /&gt;</ph> is not between the base and last sequence numbers of this sequence.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="newBaseSeqNum" /&gt;</ph> 不在此序列的基序列号和最后一个序列号之间。</target>       </trans-unit>
        <trans-unit id="635" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>The request could not be performed because of an unexpected I/O exception.</source>
          <target state="translated">由于出现意外的 I/O 异常，因此无法执行该请求。</target>       </trans-unit>
        <trans-unit id="636" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="637" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>The request could not be performed because of an I/O device error.</source>
          <target state="translated">由于出现 I/O 设备错误，因此无法执行该请求。</target>       </trans-unit>
        <trans-unit id="638" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>The method was called after the sequence has been disposed of.</source>
          <target state="translated">该方法是在序列已释放之后调用的。</target>       </trans-unit>
        <trans-unit id="639" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>There is not enough memory to continue the execution of the program.</source>
          <target state="translated">没有足够的内存来继续执行该程序。</target>       </trans-unit>
        <trans-unit id="640" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>Access for the specified log sequence is denied by the operating system.</source>
          <target state="translated">操作系统拒绝了对指定的日志序列的访问。</target>       </trans-unit>
        <trans-unit id="641" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>The record sequence is full.</source>
          <target state="translated">记录序列已满。</target>       </trans-unit>
        <trans-unit id="642" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>A list of byte array segments that will be concatenated and appended as the record.</source>
          <target state="translated">将连接在一起并以记录形式追加的字节数组段的列表。</target>       </trans-unit>
        <trans-unit id="643" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>The new base sequence number.</source>
          <target state="translated">新的基序列号。</target>       </trans-unit>
        <trans-unit id="644" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>The specified sequence number must be greater than or equal to the current base sequence number.</source>
          <target state="translated">指定的序列号必须大于或等于当前基序列号。</target>       </trans-unit>
        <trans-unit id="645" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>A <ph id="ph1">&lt;see cref="T:System.IO.Log.ReservationCollection" /&gt;</ph> that contains the reservation that should be used for this restart area.</source>
          <target state="translated">一个 <ph id="ph1">&lt;see cref="T:System.IO.Log.ReservationCollection" /&gt;</ph>，它包含应当用于此重新开始区域的保留。</target>       </trans-unit>
        <trans-unit id="646" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>An optional asynchronous callback, to be called when the restart area write is complete.</source>
          <target state="translated">可选的异步回调，在重新开始区域写入完成时调用。</target>       </trans-unit>
        <trans-unit id="647" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>A user-provided object that distinguishes this particular asynchronous restart area write request from other requests.</source>
          <target state="translated">用户提供的对象，用于将此特定异步重新开始区域写入请求与其他请求区别开来。</target>       </trans-unit>
        <trans-unit id="648" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>Begins an asynchronous restart area write operation, using space previously reserved in the sequence.</source>
          <target state="translated">使用序列中先前保留的空间开始异步重新开始区域写入操作。</target>       </trans-unit>
        <trans-unit id="649" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>This method cannot be inherited.</source>
          <target state="translated">不能继承此方法。</target>       </trans-unit>
        <trans-unit id="650" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>An <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph> that represents the asynchronous restart area write operation, which could still be pending.</source>
          <target state="translated">一个 <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph>，它表示可能仍处于挂起状态的异步重新开始区域写入操作。</target>       </trans-unit>
        <trans-unit id="651" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>You should pass the <ph id="ph1">&lt;xref:System.IAsyncResult&gt;</ph> returned by this method to the <ph id="ph2">&lt;xref:System.IO.Log.LogRecordSequence.EndWriteRestartArea%2A&gt;</ph> method to ensure that the restart area write operation has completed and resources can be freed appropriately.</source>
          <target state="translated">应将此方法返回的 <ph id="ph1">&lt;xref:System.IAsyncResult&gt;</ph> 传递给 <ph id="ph2">&lt;xref:System.IO.Log.LogRecordSequence.EndWriteRestartArea%2A&gt;</ph> 方法，以确保重新开始区域写入操作完成并能够适当释放资源。</target>       </trans-unit>
        <trans-unit id="652" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>If an error has occurred during an asynchronous restart area write operation, an exception is not thrown until the <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence.EndWriteRestartArea%2A&gt;</ph> method is called with the <ph id="ph2">&lt;xref:System.IAsyncResult&gt;</ph> returned by this method.</source>
          <target state="translated">如果在异步重新开始区域写入操作过程中发生错误，则在使用此方法返回的 <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence.EndWriteRestartArea%2A&gt;</ph> 调用 <ph id="ph2">&lt;xref:System.IAsyncResult&gt;</ph> 方法之前，不会引发异常。</target>       </trans-unit>
        <trans-unit id="653" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>Data contained in the <ph id="ph1">`data`</ph> parameter will be concatenated into a single byte array for appending as the record.</source>
          <target state="translated">包含在 <ph id="ph1">`data`</ph> 参数中的数据将连接成单个字节数组，以便以记录形式追加。</target>       </trans-unit>
        <trans-unit id="654" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>However, no provision is made for splitting data back into array segments when the record is read.</source>
          <target state="translated">但在读取记录时，无法将数据重新拆分为数组段。</target>       </trans-unit>
        <trans-unit id="655" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>When the operation successfully completes, the base sequence number has been updated.</source>
          <target state="translated">操作成功完成时，基序列号已更新。</target>       </trans-unit>
        <trans-unit id="656" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>All log records with sequence numbers less than the new base sequence number are inaccessible.</source>
          <target state="translated">其序列号小于新的基序列号的所有日志记录都不可访问。</target>       </trans-unit>
        <trans-unit id="657" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>If a <ph id="ph1">&lt;xref:System.IO.Log.ReservationCollection&gt;</ph> is specified, the written restart area will consume space that has been previously reserved, using a reservation contained in the collection.</source>
          <target state="translated">如果指定了 <ph id="ph1">&lt;xref:System.IO.Log.ReservationCollection&gt;</ph>，写入的重新开始区域将使用集合中包含的保留来占用先前已保留的空间。</target>       </trans-unit>
        <trans-unit id="658" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>If the method succeeds, it will consume the smallest reservation that can hold the data, and that reservation will be removed from the collection.</source>
          <target state="translated">如果该方法成功，它将占用能容纳数据的最小保留，而该保留将从集合中移除。</target>       </trans-unit>
        <trans-unit id="659" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>If a record sequence has been disposed of, or if you pass an invalid argument, exceptions are thrown immediately within this operation.</source>
          <target state="translated">如果记录序列已经释放，或者如果传递了无效自变量，此操作内将立即引发异常。</target>       </trans-unit>
        <trans-unit id="660" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>Errors that occurred during an asynchronous append request, for example, a disk failure during the I/O request, will result in exceptions being thrown when the <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence.EndWriteRestartArea%2A&gt;</ph> method is called.</source>
          <target state="translated">异步追加请求过程中发生的错误（例如，I/O 请求过程中的磁盘故障）将导致在调用 <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence.EndWriteRestartArea%2A&gt;</ph> 方法时引发异常。</target>       </trans-unit>
        <trans-unit id="661" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="newBaseSeqNum" /&gt;</ph> is not valid for this sequence.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="newBaseSeqNum" /&gt;</ph> 对此序列无效。</target>       </trans-unit>
        <trans-unit id="662" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="663" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>The specified log enumeration start sequence number is invalid.</source>
          <target state="translated">指定的日志枚举开始序列号无效。</target>       </trans-unit>
        <trans-unit id="664" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="665" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="data" /&gt;</ph> cannot be appended because it is larger than the maximum record size.</source>
          <target state="translated">无法追加 <ph id="ph1">&lt;paramref name="data" /&gt;</ph>，原因是它比最大记录大小要大。</target>       </trans-unit>
        <trans-unit id="666" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="667" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="reservationCollection" /&gt;</ph> was not created by this record sequence.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="reservationCollection" /&gt;</ph> 不是由此记录序列创建的。</target>       </trans-unit>
        <trans-unit id="668" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>One or more of the parameters is <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">一个或多个参数为 <ph id="ph1">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="669" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>A new or existing archive tail or base of the active log is invalid.</source>
          <target state="translated">活动日志新存档或现有存档的尾数据或基数据无效。</target>       </trans-unit>
        <trans-unit id="670" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="671" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="newBaseSeqNum" /&gt;</ph> is not between the base and last sequence numbers of this sequence.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="newBaseSeqNum" /&gt;</ph> 不在此序列的基序列号和最后一个序列号之间。</target>       </trans-unit>
        <trans-unit id="672" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>The request could not be performed because of an unexpected I/O exception.</source>
          <target state="translated">由于出现意外的 I/O 异常，因此无法执行该请求。</target>       </trans-unit>
        <trans-unit id="673" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="674" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>The request could not be performed because of an I/O device error.</source>
          <target state="translated">由于出现 I/O 设备错误，因此无法执行该请求。</target>       </trans-unit>
        <trans-unit id="675" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>The method was called after the sequence has been disposed of.</source>
          <target state="translated">该方法是在序列已释放之后调用的。</target>       </trans-unit>
        <trans-unit id="676" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>There is not enough memory to continue the execution of the program.</source>
          <target state="translated">没有足够的内存来继续执行该程序。</target>       </trans-unit>
        <trans-unit id="677" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>Access for the specified log sequence is denied by the operating system.</source>
          <target state="translated">操作系统拒绝了对指定的日志序列的访问。</target>       </trans-unit>
        <trans-unit id="678" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>The record sequence is full.</source>
          <target state="translated">记录序列已满。</target>       </trans-unit>
        <trans-unit id="679" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.CreateReservationCollection">
          <source>Creates a new <ph id="ph1">&lt;see cref="T:System.IO.Log.ReservationCollection" /&gt;</ph>.</source>
          <target state="translated">创建一个新的 <ph id="ph1">&lt;see cref="T:System.IO.Log.ReservationCollection" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="680" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.CreateReservationCollection">
          <source>This method cannot be inherited.</source>
          <target state="translated">不能继承此方法。</target>       </trans-unit>
        <trans-unit id="681" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.CreateReservationCollection">
          <source>The newly created <ph id="ph1">&lt;see cref="T:System.IO.Log.ReservationCollection" /&gt;</ph>.</source>
          <target state="translated">新创建的 <ph id="ph1">&lt;see cref="T:System.IO.Log.ReservationCollection" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="682" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.CreateReservationCollection">
          <source>Reservations can be performed in two ways as shown in the following examples.</source>
          <target state="translated">如下面的示例所示，可以通过两种方式执行保留。</target>       </trans-unit>
        <trans-unit id="683" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.CreateReservationCollection">
          <source>You can adopt the practices in the samples for robust processing.</source>
          <target state="translated">您可以采用示例中的做法可靠地进行处理。</target>       </trans-unit>
        <trans-unit id="684" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.CreateReservationCollection">
          <source>Notice that this task can only be performed when using the CLFS-based <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence&gt;</ph> class.</source>
          <target state="translated">请注意，只有在使用基于 CLFS 的 <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence&gt;</ph> 类时才能执行此任务。</target>       </trans-unit>
        <trans-unit id="685" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.CreateReservationCollection">
          <source>There is not enough memory to continue the execution of the program.</source>
          <target state="translated">没有足够的内存来继续执行该程序。</target>       </trans-unit>
        <trans-unit id="686" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Dispose">
          <source>Releases the resources used by the component.</source>
          <target state="translated">释放组件使用的资源。</target>       </trans-unit>
        <trans-unit id="687" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.Dispose">
          <source>This example shows how to use <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence.Dispose%2A&gt;</ph> to release resources:</source>
          <target state="translated">此示例演示如何使用<ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence.Dispose%2A&gt;</ph>释放资源：</target>       </trans-unit>
        <trans-unit id="688" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Dispose">
          <source>The method was called after the sequence has been disposed of.</source>
          <target state="translated">该方法是在序列已释放之后调用的。</target>       </trans-unit>
        <trans-unit id="689" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Dispose">
          <source>There is not enough memory to continue the execution of the program.</source>
          <target state="translated">没有足够的内存来继续执行该程序。</target>       </trans-unit>
        <trans-unit id="690" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.EndAppend(System.IAsyncResult)">
          <source>A reference to the outstanding asynchronous I/O request.</source>
          <target state="translated">对未完成的异步 I/O 请求的引用。</target>       </trans-unit>
        <trans-unit id="691" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.EndAppend(System.IAsyncResult)">
          <source>Ends an asynchronous append operation.</source>
          <target state="translated">结束异步追加操作。</target>       </trans-unit>
        <trans-unit id="692" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.EndAppend(System.IAsyncResult)">
          <source>This method cannot be inherited.</source>
          <target state="translated">不能继承此方法。</target>       </trans-unit>
        <trans-unit id="693" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.EndAppend(System.IAsyncResult)">
          <source>The sequence number of the appended log record.</source>
          <target state="translated">追加的日志记录的序列号。</target>       </trans-unit>
        <trans-unit id="694" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.EndAppend(System.IAsyncResult)">
          <source>This method blocks until the I/O operation has completed.</source>
          <target state="translated">此方法将一直阻塞，直到 I/O 操作已完成。</target>       </trans-unit>
        <trans-unit id="695" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.EndAppend(System.IAsyncResult)">
          <source>Errors that occur during an asynchronous write request, such as a disk failure during the I/O request, become visible when <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence.EndAppend%2A&gt;</ph> is called.</source>
          <target state="translated">调用 <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence.EndAppend%2A&gt;</ph> 时，异步写入请求过程中发生的错误（例如，I/O 请求过程中的磁盘故障）将变得可见。</target>       </trans-unit>
        <trans-unit id="696" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.EndAppend(System.IAsyncResult)">
          <source>This method must be called exactly once on every <ph id="ph1">&lt;xref:System.IAsyncResult&gt;</ph> returned by the <ph id="ph2">&lt;xref:System.IO.Log.LogRecordSequence.BeginAppend%2A&gt;</ph> method.</source>
          <target state="translated">必须对 <ph id="ph1">&lt;xref:System.IAsyncResult&gt;</ph> 方法返回的每个 <ph id="ph2">&lt;xref:System.IO.Log.LogRecordSequence.BeginAppend%2A&gt;</ph> 调用此方法且只能调用一次。</target>       </trans-unit>
        <trans-unit id="697" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.EndAppend(System.IAsyncResult)">
          <source><ph id="ph1">&lt;paramref name="result" /&gt;</ph> is invalid.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="result" /&gt;</ph> 无效。</target>       </trans-unit>
        <trans-unit id="698" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.EndAppend(System.IAsyncResult)">
          <source>The request could not be performed because of an unexpected I/O exception.</source>
          <target state="translated">由于出现意外的 I/O 异常，因此无法执行该请求。</target>       </trans-unit>
        <trans-unit id="699" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.EndAppend(System.IAsyncResult)">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="700" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.EndAppend(System.IAsyncResult)">
          <source>The request could not be performed because of an I/O device error.</source>
          <target state="translated">由于出现 I/O 设备错误，因此无法执行该请求。</target>       </trans-unit>
        <trans-unit id="701" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.EndAppend(System.IAsyncResult)">
          <source><ph id="ph1">&lt;see langword="End" /&gt;</ph> has already been called for this asynchronous operation.</source>
          <target state="translated">已对此异步操作调用了 <ph id="ph1">&lt;see langword="End" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="702" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.EndAppend(System.IAsyncResult)">
          <source>The operation cannot be performed because the record sequence was opened with read-only access.</source>
          <target state="translated">由于记录序列是通过只读访问权限打开的，因此无法执行该操作。</target>       </trans-unit>
        <trans-unit id="703" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.EndAppend(System.IAsyncResult)">
          <source>The method was called after the sequence has been disposed of.</source>
          <target state="translated">该方法是在序列已释放之后调用的。</target>       </trans-unit>
        <trans-unit id="704" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.EndAppend(System.IAsyncResult)">
          <source>There is not enough memory to continue the execution of the program.</source>
          <target state="translated">没有足够的内存来继续执行该程序。</target>       </trans-unit>
        <trans-unit id="705" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.EndAppend(System.IAsyncResult)">
          <source>The record sequence is full.</source>
          <target state="translated">记录序列已满。</target>       </trans-unit>
        <trans-unit id="706" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.EndAppend(System.IAsyncResult)">
          <source>Access for the specified log sequence is denied by the operating system.</source>
          <target state="translated">操作系统拒绝了对指定的日志序列的访问。</target>       </trans-unit>
        <trans-unit id="707" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.EndFlush(System.IAsyncResult)">
          <source>A reference to the outstanding asynchronous I/O request.</source>
          <target state="translated">对未完成的异步 I/O 请求的引用。</target>       </trans-unit>
        <trans-unit id="708" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.EndFlush(System.IAsyncResult)">
          <source>Ends an asynchronous flush operation.</source>
          <target state="translated">结束异步刷新操作。</target>       </trans-unit>
        <trans-unit id="709" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.EndFlush(System.IAsyncResult)">
          <source>This method cannot be inherited.</source>
          <target state="translated">不能继承此方法。</target>       </trans-unit>
        <trans-unit id="710" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.EndFlush(System.IAsyncResult)">
          <source>The sequence number of the last record written.</source>
          <target state="translated">写入的最新记录的序列号。</target>       </trans-unit>
        <trans-unit id="711" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.EndFlush(System.IAsyncResult)">
          <source>This method blocks until the I/O operation has completed.</source>
          <target state="translated">此方法将一直阻塞，直到 I/O 操作已完成。</target>       </trans-unit>
        <trans-unit id="712" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.EndFlush(System.IAsyncResult)">
          <source>Errors that occur during an asynchronous flush request, such as a disk failure during the I/O request, become visible when <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence.EndFlush%2A&gt;</ph> is called.</source>
          <target state="translated">调用 <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence.EndFlush%2A&gt;</ph> 时，异步刷新请求过程中发生的错误（例如，I/O 请求过程中的磁盘故障）将变得可见。</target>       </trans-unit>
        <trans-unit id="713" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.EndFlush(System.IAsyncResult)">
          <source>This method must be called exactly once on every <ph id="ph1">&lt;xref:System.IAsyncResult&gt;</ph> returned by the <ph id="ph2">&lt;xref:System.IO.Log.LogRecordSequence.BeginFlush%2A&gt;</ph> method.</source>
          <target state="translated">必须对 <ph id="ph1">&lt;xref:System.IAsyncResult&gt;</ph> 方法返回的每个 <ph id="ph2">&lt;xref:System.IO.Log.LogRecordSequence.BeginFlush%2A&gt;</ph> 调用此方法且只能调用一次。</target>       </trans-unit>
        <trans-unit id="714" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.EndFlush(System.IAsyncResult)">
          <source><ph id="ph1">&lt;paramref name="result" /&gt;</ph> is invalid.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="result" /&gt;</ph> 无效。</target>       </trans-unit>
        <trans-unit id="715" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.EndFlush(System.IAsyncResult)">
          <source>The request could not be performed because of an unexpected I/O exception.</source>
          <target state="translated">由于出现意外的 I/O 异常，因此无法执行该请求。</target>       </trans-unit>
        <trans-unit id="716" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.EndFlush(System.IAsyncResult)">
          <source><ph id="ph1">&lt;see langword="End" /&gt;</ph> has already been called for this asynchronous operation.</source>
          <target state="translated">已对此异步操作调用了 <ph id="ph1">&lt;see langword="End" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="717" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.EndFlush(System.IAsyncResult)">
          <source>The operation cannot be performed because the record sequence was opened with read-only access.</source>
          <target state="translated">由于记录序列是通过只读访问权限打开的，因此无法执行该操作。</target>       </trans-unit>
        <trans-unit id="718" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.EndFlush(System.IAsyncResult)">
          <source>The method was called after the sequence has been disposed of.</source>
          <target state="translated">该方法是在序列已释放之后调用的。</target>       </trans-unit>
        <trans-unit id="719" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.EndFlush(System.IAsyncResult)">
          <source>There is not enough memory to continue the execution of the program.</source>
          <target state="translated">没有足够的内存来继续执行该程序。</target>       </trans-unit>
        <trans-unit id="720" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.EndFlush(System.IAsyncResult)">
          <source>The record sequence is full.</source>
          <target state="translated">记录序列已满。</target>       </trans-unit>
        <trans-unit id="721" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.EndFlush(System.IAsyncResult)">
          <source>Access for the specified log sequence is denied by the operating system.</source>
          <target state="translated">操作系统拒绝了对指定的日志序列的访问。</target>       </trans-unit>
        <trans-unit id="722" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.EndReserveAndAppend(System.IAsyncResult)">
          <source>A reference to the outstanding asynchronous I/O request.</source>
          <target state="translated">对未完成的异步 I/O 请求的引用。</target>       </trans-unit>
        <trans-unit id="723" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.EndReserveAndAppend(System.IAsyncResult)">
          <source>Ends an asynchronous reserve and append operation.</source>
          <target state="translated">结束异步保留和追加操作。</target>       </trans-unit>
        <trans-unit id="724" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.EndReserveAndAppend(System.IAsyncResult)">
          <source>This method cannot be inherited.</source>
          <target state="translated">不能继承此方法。</target>       </trans-unit>
        <trans-unit id="725" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.EndReserveAndAppend(System.IAsyncResult)">
          <source>The sequence number of the appended log record.</source>
          <target state="translated">追加的日志记录的序列号。</target>       </trans-unit>
        <trans-unit id="726" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.EndReserveAndAppend(System.IAsyncResult)">
          <source>This method blocks until the I/O operation has completed.</source>
          <target state="translated">此方法将一直阻塞，直到 I/O 操作已完成。</target>       </trans-unit>
        <trans-unit id="727" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.EndReserveAndAppend(System.IAsyncResult)">
          <source>Errors that occur during an asynchronous write request, such as a disk failure during the I/O request, become visible when <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A&gt;</ph> is called.</source>
          <target state="translated">调用 <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A&gt;</ph> 时，异步写入请求过程中发生的错误（例如，I/O 请求过程中的磁盘故障）将变得可见。</target>       </trans-unit>
        <trans-unit id="728" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.EndReserveAndAppend(System.IAsyncResult)">
          <source>This method must be called exactly once on every <ph id="ph1">&lt;xref:System.IAsyncResult&gt;</ph> returned by the <ph id="ph2">&lt;xref:System.IO.Log.LogRecordSequence.BeginReserveAndAppend%2A&gt;</ph> method.</source>
          <target state="translated">必须对 <ph id="ph1">&lt;xref:System.IAsyncResult&gt;</ph> 方法返回的每个 <ph id="ph2">&lt;xref:System.IO.Log.LogRecordSequence.BeginReserveAndAppend%2A&gt;</ph> 调用此方法且只能调用一次。</target>       </trans-unit>
        <trans-unit id="729" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.EndReserveAndAppend(System.IAsyncResult)">
          <source><ph id="ph1">&lt;paramref name="result" /&gt;</ph> is invalid.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="result" /&gt;</ph> 无效。</target>       </trans-unit>
        <trans-unit id="730" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.EndReserveAndAppend(System.IAsyncResult)">
          <source>The request could not be performed because of an unexpected I/O exception.</source>
          <target state="translated">由于出现意外的 I/O 异常，因此无法执行该请求。</target>       </trans-unit>
        <trans-unit id="731" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.EndReserveAndAppend(System.IAsyncResult)">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="732" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.EndReserveAndAppend(System.IAsyncResult)">
          <source>The request could not be performed because of an I/O device error.</source>
          <target state="translated">由于出现 I/O 设备错误，因此无法执行该请求。</target>       </trans-unit>
        <trans-unit id="733" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.EndReserveAndAppend(System.IAsyncResult)">
          <source><ph id="ph1">&lt;see langword="End" /&gt;</ph> has already been called for this asynchronous operation.</source>
          <target state="translated">已对此异步操作调用了 <ph id="ph1">&lt;see langword="End" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="734" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.EndReserveAndAppend(System.IAsyncResult)">
          <source>The operation cannot be performed because the record sequence was opened with read-only access.</source>
          <target state="translated">由于记录序列是通过只读访问权限打开的，因此无法执行该操作。</target>       </trans-unit>
        <trans-unit id="735" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.EndReserveAndAppend(System.IAsyncResult)">
          <source>The method was called after the sequence has been disposed of.</source>
          <target state="translated">该方法是在序列已释放之后调用的。</target>       </trans-unit>
        <trans-unit id="736" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.EndReserveAndAppend(System.IAsyncResult)">
          <source>There is not enough memory to continue the execution of the program.</source>
          <target state="translated">没有足够的内存来继续执行该程序。</target>       </trans-unit>
        <trans-unit id="737" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.EndReserveAndAppend(System.IAsyncResult)">
          <source>The record sequence is full.</source>
          <target state="translated">记录序列已满。</target>       </trans-unit>
        <trans-unit id="738" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.EndReserveAndAppend(System.IAsyncResult)">
          <source>Access for the specified log sequence is denied by the operating system.</source>
          <target state="translated">操作系统拒绝了对指定的日志序列的访问。</target>       </trans-unit>
        <trans-unit id="739" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.EndWriteRestartArea(System.IAsyncResult)">
          <source>A reference to the outstanding asynchronous I/O request.</source>
          <target state="translated">对未完成的异步 I/O 请求的引用。</target>       </trans-unit>
        <trans-unit id="740" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.EndWriteRestartArea(System.IAsyncResult)">
          <source>Ends an asynchronous restart area write operation.</source>
          <target state="translated">结束异步重新开始区域写入操作。</target>       </trans-unit>
        <trans-unit id="741" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.EndWriteRestartArea(System.IAsyncResult)">
          <source>This method cannot be inherited.</source>
          <target state="translated">不能继承此方法。</target>       </trans-unit>
        <trans-unit id="742" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.EndWriteRestartArea(System.IAsyncResult)">
          <source>The sequence number of the written log record.</source>
          <target state="translated">写入的日志记录的序列号。</target>       </trans-unit>
        <trans-unit id="743" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.EndWriteRestartArea(System.IAsyncResult)">
          <source>This method blocks until the I/O operation has completed.</source>
          <target state="translated">此方法将一直阻塞，直到 I/O 操作已完成。</target>       </trans-unit>
        <trans-unit id="744" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.EndWriteRestartArea(System.IAsyncResult)">
          <source>Errors that occur during an asynchronous write request, such as a disk failure during the I/O request, become visible when <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence.EndWriteRestartArea%2A&gt;</ph> is called.</source>
          <target state="translated">调用 <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence.EndWriteRestartArea%2A&gt;</ph> 时，异步写入请求过程中发生的错误（例如，I/O 请求过程中的磁盘故障）将变得可见。</target>       </trans-unit>
        <trans-unit id="745" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.EndWriteRestartArea(System.IAsyncResult)">
          <source>This method must be called exactly once on every <ph id="ph1">&lt;xref:System.IAsyncResult&gt;</ph> returned by the <ph id="ph2">&lt;xref:System.IO.Log.LogRecordSequence.BeginWriteRestartArea%2A&gt;</ph> method.</source>
          <target state="translated">必须对 <ph id="ph1">&lt;xref:System.IAsyncResult&gt;</ph> 方法返回的每个 <ph id="ph2">&lt;xref:System.IO.Log.LogRecordSequence.BeginWriteRestartArea%2A&gt;</ph> 调用此方法且只能调用一次。</target>       </trans-unit>
        <trans-unit id="746" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.EndWriteRestartArea(System.IAsyncResult)">
          <source><ph id="ph1">&lt;paramref name="result" /&gt;</ph> is not valid.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="result" /&gt;</ph> 无效。</target>       </trans-unit>
        <trans-unit id="747" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.EndWriteRestartArea(System.IAsyncResult)">
          <source>A new or existing archive tail or base of the active log is invalid.</source>
          <target state="translated">活动日志新存档或现有存档的尾数据或基数据无效。</target>       </trans-unit>
        <trans-unit id="748" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.EndWriteRestartArea(System.IAsyncResult)">
          <source>The request could not be performed because of an unexpected I/O exception.</source>
          <target state="translated">由于出现意外的 I/O 异常，因此无法执行该请求。</target>       </trans-unit>
        <trans-unit id="749" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.EndWriteRestartArea(System.IAsyncResult)">
          <source><ph id="ph1">&lt;see langword="End" /&gt;</ph> has already been called for this asynchronous operation.</source>
          <target state="translated">已对此异步操作调用了 <ph id="ph1">&lt;see langword="End" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="750" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.EndWriteRestartArea(System.IAsyncResult)">
          <source>The method was called after the sequence has been disposed of.</source>
          <target state="translated">该方法是在序列已释放之后调用的。</target>       </trans-unit>
        <trans-unit id="751" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.EndWriteRestartArea(System.IAsyncResult)">
          <source>There is not enough memory to continue the execution of the program.</source>
          <target state="translated">没有足够的内存来继续执行该程序。</target>       </trans-unit>
        <trans-unit id="752" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.EndWriteRestartArea(System.IAsyncResult)">
          <source>Access for the specified log sequence is denied by the operating system.</source>
          <target state="translated">操作系统拒绝了对指定的日志序列的访问。</target>       </trans-unit>
        <trans-unit id="753" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.EndWriteRestartArea(System.IAsyncResult)">
          <source>The record sequence is full.</source>
          <target state="translated">记录序列已满。</target>       </trans-unit>
        <trans-unit id="754" translate="yes" xml:space="preserve" uid="T:System.IO.Log.LogRecordSequence">
          <source>Writes appended records durably</source>
          <target state="translated">持久写入追加的记录</target>       </trans-unit>
        <trans-unit id="755" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Flush">
          <source>Ensures that all appended records have been written.</source>
          <target state="translated">确保所有追加的记录都已写入。</target>       </trans-unit>
        <trans-unit id="756" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Flush">
          <source>This method cannot be inherited.</source>
          <target state="translated">不能继承此方法。</target>       </trans-unit>
        <trans-unit id="757" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Flush">
          <source>The sequence number of the last record written.</source>
          <target state="translated">写入的最新记录的序列号。</target>       </trans-unit>
        <trans-unit id="758" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.Flush">
          <source>Calling this method ensures that all records that have been appended to the <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence&gt;</ph> have been durably written.</source>
          <target state="translated">调用此方法可以确保已追加到 <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence&gt;</ph> 的所有记录都已持久写入。</target>       </trans-unit>
        <trans-unit id="759" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Flush">
          <source>An I/O error occurred while flushing the data.</source>
          <target state="translated">刷新数据时，发生了 I/O 错误。</target>       </trans-unit>
        <trans-unit id="760" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Flush">
          <source>The method was called after the sequence has been disposed of.</source>
          <target state="translated">该方法是在序列已释放之后调用的。</target>       </trans-unit>
        <trans-unit id="761" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Flush">
          <source>This operation is not supported.</source>
          <target state="translated">不支持此操作。</target>       </trans-unit>
        <trans-unit id="762" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Flush">
          <source>There is not enough memory to continue the execution of the program.</source>
          <target state="translated">没有足够的内存来继续执行该程序。</target>       </trans-unit>
        <trans-unit id="763" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Flush">
          <source>Access for the specified log sequence is denied by the operating system.</source>
          <target state="translated">操作系统拒绝了对指定的日志序列的访问。</target>       </trans-unit>
        <trans-unit id="764" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Flush">
          <source>The record sequence could not make enough free space to contain the new restart area.</source>
          <target state="translated">记录序列无法获得足够的可用空间来容纳新的重新开始区域。</target>       </trans-unit>
        <trans-unit id="765" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Flush">
          <source>The specified log does not have any extents.</source>
          <target state="translated">指定的日志没有任何范围。</target>       </trans-unit>
        <trans-unit id="766" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Flush">
          <source>One or more extents must be created before a record sequence can be used.</source>
          <target state="translated">必须创建一个或多个范围，然后才能使用记录序列。</target>       </trans-unit>
        <trans-unit id="767" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Flush(System.IO.Log.SequenceNumber)">
          <source>The sequence number of the latest record that must be written.</source>
          <target state="translated">必须写入的最新记录的序列号。</target>       </trans-unit>
        <trans-unit id="768" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Flush(System.IO.Log.SequenceNumber)">
          <source>If this <ph id="ph1">&lt;see cref="T:System.IO.Log.SequenceNumber" /&gt;</ph> is invalid, then all records must be written.</source>
          <target state="translated">如果此 <ph id="ph1">&lt;see cref="T:System.IO.Log.SequenceNumber" /&gt;</ph> 无效，则必须写入所有记录。</target>       </trans-unit>
        <trans-unit id="769" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Flush(System.IO.Log.SequenceNumber)">
          <source>Ensures that all appended records up to and including the record with the specified sequence number have been durably written.</source>
          <target state="translated">确保序列号不高于指定序列号的所有追加记录都已持久写入。</target>       </trans-unit>
        <trans-unit id="770" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Flush(System.IO.Log.SequenceNumber)">
          <source>This method cannot be inherited.</source>
          <target state="translated">不能继承此方法。</target>       </trans-unit>
        <trans-unit id="771" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Flush(System.IO.Log.SequenceNumber)">
          <source>The sequence number of the last record written.</source>
          <target state="translated">写入的最新记录的序列号。</target>       </trans-unit>
        <trans-unit id="772" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.Flush(System.IO.Log.SequenceNumber)">
          <source>Calling this method ensures that all records with sequence numbers up to and including the specified sequence number have been durably written.</source>
          <target state="translated">调用此方法可以确保序列号不高于指定序列号的所有记录都已持久写入。</target>       </trans-unit>
        <trans-unit id="773" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Flush(System.IO.Log.SequenceNumber)">
          <source><ph id="ph1">&lt;paramref name="sequenceNumber" /&gt;</ph> is not valid for this sequence.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="sequenceNumber" /&gt;</ph> 对此序列无效。</target>       </trans-unit>
        <trans-unit id="774" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Flush(System.IO.Log.SequenceNumber)">
          <source><ph id="ph1">&lt;paramref name="sequenceNumber" /&gt;</ph> is not between the base and last sequence numbers of this sequence.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="sequenceNumber" /&gt;</ph> 不在此序列的基序列号和最后一个序列号之间。</target>       </trans-unit>
        <trans-unit id="775" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Flush(System.IO.Log.SequenceNumber)">
          <source>The request could not be performed because of an unexpected I/O exception.</source>
          <target state="translated">由于出现意外的 I/O 异常，因此无法执行该请求。</target>       </trans-unit>
        <trans-unit id="776" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Flush(System.IO.Log.SequenceNumber)">
          <source>The specified log does not have any extents.</source>
          <target state="translated">指定的日志没有任何范围。</target>       </trans-unit>
        <trans-unit id="777" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Flush(System.IO.Log.SequenceNumber)">
          <source>One or more extents must be created before a record sequence can be used.</source>
          <target state="translated">必须创建一个或多个范围，然后才能使用记录序列。</target>       </trans-unit>
        <trans-unit id="778" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Flush(System.IO.Log.SequenceNumber)">
          <source>The operation cannot be performed because the record sequence was opened with read-only access.</source>
          <target state="translated">由于记录序列是通过只读访问权限打开的，因此无法执行该操作。</target>       </trans-unit>
        <trans-unit id="779" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Flush(System.IO.Log.SequenceNumber)">
          <source>The method was called after the sequence has been disposed of.</source>
          <target state="translated">该方法是在序列已释放之后调用的。</target>       </trans-unit>
        <trans-unit id="780" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Flush(System.IO.Log.SequenceNumber)">
          <source>There is not enough memory to continue the execution of the program.</source>
          <target state="translated">没有足够的内存来继续执行该程序。</target>       </trans-unit>
        <trans-unit id="781" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Flush(System.IO.Log.SequenceNumber)">
          <source>The record sequence is full.</source>
          <target state="translated">记录序列已满。</target>       </trans-unit>
        <trans-unit id="782" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Flush(System.IO.Log.SequenceNumber)">
          <source>Access for the specified log sequence is denied by the operating system.</source>
          <target state="translated">操作系统拒绝了对指定的日志序列的访问。</target>       </trans-unit>
        <trans-unit id="783" translate="yes" xml:space="preserve" uid="P:System.IO.Log.LogRecordSequence.LastSequenceNumber">
          <source>Gets the sequence number which is greater than the last record appended</source>
          <target state="translated">获取比追加的最后一条记录大的序列号</target>       </trans-unit>
        <trans-unit id="784" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.Log.LogRecordSequence.LastSequenceNumber">
          <source>A sequence number which is greater than the last record appended.</source>
          <target state="translated">比追加的最新记录大的序列号。</target>       </trans-unit>
        <trans-unit id="785" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.Log.LogRecordSequence.LastSequenceNumber">
          <source>This property contains a sequence number that is guaranteed to be larger than the sequence number of the last appended record.</source>
          <target state="translated">此属性包含一个序列号，并且保证它大于最后追加的记录的序列号。</target>       </trans-unit>
        <trans-unit id="786" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.Log.LogRecordSequence.LastSequenceNumber">
          <source>Valid sequence numbers are greater than or equal to <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence.BaseSequenceNumber%2A&gt;</ph> and less than <ph id="ph2">&lt;xref:System.IO.Log.LogRecordSequence.LastSequenceNumber%2A&gt;</ph>.</source>
          <target state="translated">有效序列号大于或等于 <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence.BaseSequenceNumber%2A&gt;</ph> 且小于 <ph id="ph2">&lt;xref:System.IO.Log.LogRecordSequence.LastSequenceNumber%2A&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="787" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.Log.LogRecordSequence.LastSequenceNumber">
          <source>All other sequence numbers are invalid.</source>
          <target state="translated">所有其他序列号均无效。</target>       </trans-unit>
        <trans-unit id="788" translate="yes" xml:space="preserve" uid="P:System.IO.Log.LogRecordSequence.LastSequenceNumber">
          <source>The property was accessed after the sequence has been disposed of.</source>
          <target state="translated">该属性是在序列已释放之后访问的。</target>       </trans-unit>
        <trans-unit id="789" translate="yes" xml:space="preserve" uid="P:System.IO.Log.LogRecordSequence.LogStore">
          <source>Gets the <ph id="ph1">&lt;see cref="T:System.IO.Log.LogStore" /&gt;</ph> that contains the data for this record sequence.</source>
          <target state="translated">获取包含此记录序列数据的 <ph id="ph1">&lt;see cref="T:System.IO.Log.LogStore" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="790" translate="yes" xml:space="preserve" uid="P:System.IO.Log.LogRecordSequence.LogStore">
          <source>This method cannot be inherited.</source>
          <target state="translated">不能继承此方法。</target>       </trans-unit>
        <trans-unit id="791" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.Log.LogRecordSequence.LogStore">
          <source>The <ph id="ph1">&lt;see cref="T:System.IO.Log.LogStore" /&gt;</ph> that contains the data for this record sequence.</source>
          <target state="translated">包含此记录序列数据的 <ph id="ph1">&lt;see cref="T:System.IO.Log.LogStore" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="792" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.Log.LogRecordSequence.LogStore">
          <source>This example shows how to use the <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence.LogStore%2A&gt;</ph> member to add extents.</source>
          <target state="translated">此示例演示如何使用 <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence.LogStore%2A&gt;</ph> 成员来添加范围。</target>       </trans-unit>
        <trans-unit id="793" translate="yes" xml:space="preserve" uid="P:System.IO.Log.LogRecordSequence.MaximumRecordLength">
          <source>Gets the maximum size of a record that can be added to this record sequence.</source>
          <target state="translated">获取可添加到此记录序列中的记录的最大大小。</target>       </trans-unit>
        <trans-unit id="794" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.Log.LogRecordSequence.MaximumRecordLength">
          <source>The maximum size of a record that can be added to this record sequence.</source>
          <target state="translated">可添加到此记录序列中的记录的最大大小。</target>       </trans-unit>
        <trans-unit id="795" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.ReadLogRecords(System.IO.Log.SequenceNumber,System.IO.Log.LogRecordEnumeratorType)">
          <source>The sequence number of the first record where the reading starts.</source>
          <target state="translated">读取操作开始处的第一条记录的序列号。</target>       </trans-unit>
        <trans-unit id="796" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.ReadLogRecords(System.IO.Log.SequenceNumber,System.IO.Log.LogRecordEnumeratorType)">
          <source>A valid <ph id="ph1">&lt;see cref="T:System.IO.Log.LogRecordEnumeratorType" /&gt;</ph> value that specifies the manner (that is, forward or backward) in which records should be read from a <ph id="ph2">&lt;see cref="T:System.IO.Log.LogRecordSequence" /&gt;</ph>.</source>
          <target state="translated">一个有效的 <ph id="ph1">&lt;see cref="T:System.IO.Log.LogRecordEnumeratorType" /&gt;</ph> 值，该值指定从 <ph id="ph2">&lt;see cref="T:System.IO.Log.LogRecordSequence" /&gt;</ph> 中读取记录的方式（即，向前或向后）。</target>       </trans-unit>
        <trans-unit id="797" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.ReadLogRecords(System.IO.Log.SequenceNumber,System.IO.Log.LogRecordEnumeratorType)">
          <source>Returns an enumerable collection of records in the sequence.</source>
          <target state="translated">返回序列中记录的可枚举集合。</target>       </trans-unit>
        <trans-unit id="798" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.ReadLogRecords(System.IO.Log.SequenceNumber,System.IO.Log.LogRecordEnumeratorType)">
          <source>This method cannot be inherited.</source>
          <target state="translated">不能继承此方法。</target>       </trans-unit>
        <trans-unit id="799" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.ReadLogRecords(System.IO.Log.SequenceNumber,System.IO.Log.LogRecordEnumeratorType)">
          <source>An enumerable collection of records in the sequence.</source>
          <target state="translated">序列中记录的可枚举集合。</target>       </trans-unit>
        <trans-unit id="800" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.ReadLogRecords(System.IO.Log.SequenceNumber,System.IO.Log.LogRecordEnumeratorType)">
          <source>This method returns an enumerable collection of records in the sequence.</source>
          <target state="translated">此方法返回序列中记录的可枚举集合。</target>       </trans-unit>
        <trans-unit id="801" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.ReadLogRecords(System.IO.Log.SequenceNumber,System.IO.Log.LogRecordEnumeratorType)">
          <source>The order of the enumerated records depends on the value of the <ph id="ph1">`logRecordEnum`</ph> parameter.</source>
          <target state="translated">所枚举记录的顺序取决于 <ph id="ph1">`logRecordEnum`</ph> 参数的值。</target>       </trans-unit>
        <trans-unit id="802" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.ReadLogRecords(System.IO.Log.SequenceNumber,System.IO.Log.LogRecordEnumeratorType)">
          <source>This example shows how to use <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence.ReadLogRecords%2A&gt;</ph> in a loop.</source>
          <target state="translated">此示例演示如何在循环中使用 <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence.ReadLogRecords%2A&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="803" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.ReadLogRecords(System.IO.Log.SequenceNumber,System.IO.Log.LogRecordEnumeratorType)">
          <source><ph id="ph1">&lt;paramref name="start" /&gt;</ph> is not valid for this sequence.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="start" /&gt;</ph> 对此序列无效。</target>       </trans-unit>
        <trans-unit id="804" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.ReadLogRecords(System.IO.Log.SequenceNumber,System.IO.Log.LogRecordEnumeratorType)">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="805" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.ReadLogRecords(System.IO.Log.SequenceNumber,System.IO.Log.LogRecordEnumeratorType)">
          <source><ph id="ph1">&lt;paramref name="logRecordEnum" /&gt;</ph> is invalid.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="logRecordEnum" /&gt;</ph> 无效。</target>       </trans-unit>
        <trans-unit id="806" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.ReadLogRecords(System.IO.Log.SequenceNumber,System.IO.Log.LogRecordEnumeratorType)">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="807" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.ReadLogRecords(System.IO.Log.SequenceNumber,System.IO.Log.LogRecordEnumeratorType)">
          <source>The specified element was not found in the collection.</source>
          <target state="translated">在集合中找不到指定的元素。</target>       </trans-unit>
        <trans-unit id="808" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.ReadLogRecords(System.IO.Log.SequenceNumber,System.IO.Log.LogRecordEnumeratorType)">
          <source><ph id="ph1">&lt;paramref name="start" /&gt;</ph> is not between the base and last sequence numbers of this sequence.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="start" /&gt;</ph> 不在此序列的基序列号和最后一个序列号之间。</target>       </trans-unit>
        <trans-unit id="809" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.ReadLogRecords(System.IO.Log.SequenceNumber,System.IO.Log.LogRecordEnumeratorType)">
          <source>The request could not be performed because of an unexpected I/O exception.</source>
          <target state="translated">由于出现意外的 I/O 异常，因此无法执行该请求。</target>       </trans-unit>
        <trans-unit id="810" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.ReadLogRecords(System.IO.Log.SequenceNumber,System.IO.Log.LogRecordEnumeratorType)">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="811" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.ReadLogRecords(System.IO.Log.SequenceNumber,System.IO.Log.LogRecordEnumeratorType)">
          <source>The request could not be performed because of an I/O device error.</source>
          <target state="translated">由于出现 I/O 设备错误，因此无法执行该请求。</target>       </trans-unit>
        <trans-unit id="812" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.ReadLogRecords(System.IO.Log.SequenceNumber,System.IO.Log.LogRecordEnumeratorType)">
          <source>-or</source>
          <target state="translated">- 或 -</target>       </trans-unit>
        <trans-unit id="813" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.ReadLogRecords(System.IO.Log.SequenceNumber,System.IO.Log.LogRecordEnumeratorType)">
          <source>The buffer size used to write the log record is larger than the buffer size being used to read it.</source>
          <target state="translated">用于写入日志记录的缓冲区大小大于用于读取日志记录的缓冲区大小。</target>       </trans-unit>
        <trans-unit id="814" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.ReadLogRecords(System.IO.Log.SequenceNumber,System.IO.Log.LogRecordEnumeratorType)">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="815" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.ReadLogRecords(System.IO.Log.SequenceNumber,System.IO.Log.LogRecordEnumeratorType)">
          <source>The record sequence is corrupted.</source>
          <target state="translated">记录序列已损坏。</target>       </trans-unit>
        <trans-unit id="816" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.ReadLogRecords(System.IO.Log.SequenceNumber,System.IO.Log.LogRecordEnumeratorType)">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="817" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.ReadLogRecords(System.IO.Log.SequenceNumber,System.IO.Log.LogRecordEnumeratorType)">
          <source>The specified log file format or version is invalid.</source>
          <target state="translated">指定的日志文件格式或版本无效。</target>       </trans-unit>
        <trans-unit id="818" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.ReadLogRecords(System.IO.Log.SequenceNumber,System.IO.Log.LogRecordEnumeratorType)">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="819" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.ReadLogRecords(System.IO.Log.SequenceNumber,System.IO.Log.LogRecordEnumeratorType)">
          <source>The record was written with an incompatible version of the record sequence.</source>
          <target state="translated">记录是使用不兼容的记录序列版本写入的。</target>       </trans-unit>
        <trans-unit id="820" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.ReadLogRecords(System.IO.Log.SequenceNumber,System.IO.Log.LogRecordEnumeratorType)">
          <source>The operation is invalid because the enumeration has not been started.</source>
          <target state="translated">操作无效，原因是枚举尚未开始。</target>       </trans-unit>
        <trans-unit id="821" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.ReadLogRecords(System.IO.Log.SequenceNumber,System.IO.Log.LogRecordEnumeratorType)">
          <source>A call to <ph id="ph1">&lt;see cref="M:System.Collections.IEnumerator.MoveNext" /&gt;</ph> must be made.</source>
          <target state="translated">必须调用 <ph id="ph1">&lt;see cref="M:System.Collections.IEnumerator.MoveNext" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="822" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.ReadLogRecords(System.IO.Log.SequenceNumber,System.IO.Log.LogRecordEnumeratorType)">
          <source>The method was called after the sequence has been disposed of.</source>
          <target state="translated">该方法是在序列已释放之后调用的。</target>       </trans-unit>
        <trans-unit id="823" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.ReadLogRecords(System.IO.Log.SequenceNumber,System.IO.Log.LogRecordEnumeratorType)">
          <source>There is not enough memory to continue the execution of the program.</source>
          <target state="translated">没有足够的内存来继续执行该程序。</target>       </trans-unit>
        <trans-unit id="824" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.ReadLogRecords(System.IO.Log.SequenceNumber,System.IO.Log.LogRecordEnumeratorType)">
          <source>Access for the specified log sequence is denied by the operating system.</source>
          <target state="translated">操作系统拒绝了对指定的日志序列的访问。</target>       </trans-unit>
        <trans-unit id="825" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.ReadRestartAreas">
          <source>Returns an enumerable collection of the restart areas in the sequence.</source>
          <target state="translated">返回序列中重新开始区域的可枚举集合。</target>       </trans-unit>
        <trans-unit id="826" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.ReadRestartAreas">
          <source>This method cannot be inherited.</source>
          <target state="translated">不能继承此方法。</target>       </trans-unit>
        <trans-unit id="827" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.ReadRestartAreas">
          <source>An enumerable collection of the restart areas in the sequence.</source>
          <target state="translated">序列中重新开始区域的可枚举集合。</target>       </trans-unit>
        <trans-unit id="828" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.ReadRestartAreas">
          <source>The restart areas are enumerated in reverse sequence number order, that is, from the highest sequence number to the lowest sequence number.</source>
          <target state="translated">重新开始区域按序列号的倒序枚举，即从最高序列号到最低序列号枚举。</target>       </trans-unit>
        <trans-unit id="829" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.ReadRestartAreas">
          <source>Only restart areas with sequence numbers between the last sequence number and the base sequence number are enumerated.</source>
          <target state="translated">仅枚举序列号介于最后一个序列号和基序列号之间的重新开始区域。</target>       </trans-unit>
        <trans-unit id="830" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.ReadRestartAreas">
          <source><ph id="ph1">&lt;paramref name="start" /&gt;</ph> is not between the base and last sequence numbers of this sequence.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="start" /&gt;</ph> 不在此序列的基序列号和最后一个序列号之间。</target>       </trans-unit>
        <trans-unit id="831" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.ReadRestartAreas">
          <source>The request could not be performed because of an unexpected I/O exception.</source>
          <target state="translated">由于出现意外的 I/O 异常，因此无法执行该请求。</target>       </trans-unit>
        <trans-unit id="832" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.ReadRestartAreas">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="833" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.ReadRestartAreas">
          <source>The request could not be performed because of an I/O device error.</source>
          <target state="translated">由于出现 I/O 设备错误，因此无法执行该请求。</target>       </trans-unit>
        <trans-unit id="834" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.ReadRestartAreas">
          <source>-or</source>
          <target state="translated">- 或 -</target>       </trans-unit>
        <trans-unit id="835" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.ReadRestartAreas">
          <source>The buffer size used to write the log record is larger than the buffer size being used to read it.</source>
          <target state="translated">用于写入日志记录的缓冲区大小大于用于读取日志记录的缓冲区大小。</target>       </trans-unit>
        <trans-unit id="836" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.ReadRestartAreas">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="837" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.ReadRestartAreas">
          <source>The record sequence is corrupted.</source>
          <target state="translated">记录序列已损坏。</target>       </trans-unit>
        <trans-unit id="838" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.ReadRestartAreas">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="839" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.ReadRestartAreas">
          <source>The specified log file format or version is invalid.</source>
          <target state="translated">指定的日志文件格式或版本无效。</target>       </trans-unit>
        <trans-unit id="840" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.ReadRestartAreas">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="841" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.ReadRestartAreas">
          <source>The record was written with an incompatible version of the record sequence.</source>
          <target state="translated">记录是使用不兼容的记录序列版本写入的。</target>       </trans-unit>
        <trans-unit id="842" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.ReadRestartAreas">
          <source>The operation is invalid because the enumeration has not been started.</source>
          <target state="translated">操作无效，原因是枚举尚未开始。</target>       </trans-unit>
        <trans-unit id="843" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.ReadRestartAreas">
          <source>A call to <ph id="ph1">&lt;see cref="M:System.Collections.IEnumerator.MoveNext" /&gt;</ph> must be made.</source>
          <target state="translated">必须调用 <ph id="ph1">&lt;see cref="M:System.Collections.IEnumerator.MoveNext" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="844" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.ReadRestartAreas">
          <source>-or</source>
          <target state="translated">- 或 -</target>       </trans-unit>
        <trans-unit id="845" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.ReadRestartAreas">
          <source>The enumeration has ended.</source>
          <target state="translated">枚举已经终止。</target>       </trans-unit>
        <trans-unit id="846" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.ReadRestartAreas">
          <source>The method was called after the sequence has been disposed of.</source>
          <target state="translated">该方法是在序列已释放之后调用的。</target>       </trans-unit>
        <trans-unit id="847" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.ReadRestartAreas">
          <source>There is not enough memory to continue the execution of the program.</source>
          <target state="translated">没有足够的内存来继续执行该程序。</target>       </trans-unit>
        <trans-unit id="848" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.ReadRestartAreas">
          <source>Access for the specified log sequence is denied by the operating system.</source>
          <target state="translated">操作系统拒绝了对指定的日志序列的访问。</target>       </trans-unit>
        <trans-unit id="849" translate="yes" xml:space="preserve" uid="T:System.IO.Log.LogRecordSequence">
          <source>Automatically makes a single reservation and appends a record to the sequence.</source>
          <target state="translated">自动生成一个保留，并向序列中追加一条记录。</target>       </trans-unit>
        <trans-unit id="850" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.ReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])">
          <source>A list of byte array segments that will be concatenated and appended as the record.</source>
          <target state="translated">将连接在一起并以记录形式追加的字节数组段的列表。</target>       </trans-unit>
        <trans-unit id="851" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.ReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])">
          <source>The sequence number of the next record in the user-specified order.</source>
          <target state="translated">用户指定顺序中下一条记录的序列号。</target>       </trans-unit>
        <trans-unit id="852" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.ReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])">
          <source>The sequence number of the next record in Previous order.</source>
          <target state="translated">“上一个”顺序中下一条记录的序列号。</target>       </trans-unit>
        <trans-unit id="853" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.ReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])">
          <source>A valid value of <ph id="ph1">&lt;see cref="T:System.IO.Log.RecordAppendOptions" /&gt;</ph> that specifies how the data should be written.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.IO.Log.RecordAppendOptions" /&gt;</ph> 的一个有效值，用于指定应如何写入数据。</target>       </trans-unit>
        <trans-unit id="854" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.ReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])">
          <source>A <ph id="ph1">&lt;see cref="T:System.IO.Log.ReservationCollection" /&gt;</ph> that contains the collection to make reservations in.</source>
          <target state="translated">一个 <ph id="ph1">&lt;see cref="T:System.IO.Log.ReservationCollection" /&gt;</ph>，它包含要在其中生成保留的集合。</target>       </trans-unit>
        <trans-unit id="855" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.ReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])">
          <source>The reservations to make, in bytes.</source>
          <target state="translated">要生成的保留（以字节为单位）。</target>       </trans-unit>
        <trans-unit id="856" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.ReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])">
          <source>Automatically makes a single reservation and appends a record to the sequence.</source>
          <target state="translated">自动生成一个保留，并向序列中追加一条记录。</target>       </trans-unit>
        <trans-unit id="857" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.ReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])">
          <source>This method cannot be inherited.</source>
          <target state="translated">不能继承此方法。</target>       </trans-unit>
        <trans-unit id="858" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.ReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])">
          <source>The sequence number of the appended log record.</source>
          <target state="translated">追加的日志记录的序列号。</target>       </trans-unit>
        <trans-unit id="859" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.ReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])">
          <source>Data contained in the <ph id="ph1">`data`</ph> parameter will be concatenated into a single byte array for appending as the record.</source>
          <target state="translated">包含在 <ph id="ph1">`data`</ph> 参数中的数据将连接成单个字节数组，以便以记录形式追加。</target>       </trans-unit>
        <trans-unit id="860" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.ReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])">
          <source>However, no provision is made for splitting data back into array segments when the record is read.</source>
          <target state="translated">但在读取记录时，无法将数据重新拆分为数组段。</target>       </trans-unit>
        <trans-unit id="861" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.ReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])">
          <source>The specified reservations are added to the provided reservation collection in an atomic operation with a record append operation.</source>
          <target state="translated">在原子操作中，使用记录追加操作将指定的保留添加到所提供的保留集合。</target>       </trans-unit>
        <trans-unit id="862" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.ReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])">
          <source>If the append fails, no space is reserved.</source>
          <target state="translated">如果追加失败，将不保留任何空间。</target>       </trans-unit>
        <trans-unit id="863" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.ReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])">
          <source>Normally, this method may complete before the record has been written.</source>
          <target state="translated">通常，此方法可以在写入记录之前完成。</target>       </trans-unit>
        <trans-unit id="864" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.ReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])">
          <source>To ensure that a record has been written, either specify the <ph id="ph1">&lt;xref:System.IO.Log.RecordAppendOptions.ForceFlush&gt;</ph> flag using the <ph id="ph2">`recordAppendOptions`</ph> parameter, or call the <ph id="ph3">&lt;xref:System.IO.Log.LogRecordSequence.Flush%2A&gt;</ph> method.</source>
          <target state="translated">若要确保记录已写入，请使用 <ph id="ph1">&lt;xref:System.IO.Log.RecordAppendOptions.ForceFlush&gt;</ph> 参数指定 <ph id="ph2">`recordAppendOptions`</ph> 标志，或者调用 <ph id="ph3">&lt;xref:System.IO.Log.LogRecordSequence.Flush%2A&gt;</ph> 方法。</target>       </trans-unit>
        <trans-unit id="865" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.ReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])">
          <source>The following example shows how to use this method to make reservations.</source>
          <target state="translated">下面的示例演示如何使用此方法来生成保留。</target>       </trans-unit>
        <trans-unit id="866" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.ReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])">
          <source>Notice that this task can only be performed when using the CLFS-based <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence&gt;</ph> class.</source>
          <target state="translated">请注意，只有在使用基于 CLFS 的 <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence&gt;</ph> 类时才能执行此任务。</target>       </trans-unit>
        <trans-unit id="867" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.ReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])">
          <source><ph id="ph1">&lt;paramref name="nextUndoRecord" /&gt;</ph> or <ph id="ph2">&lt;paramref name="previousRecord" /&gt;</ph> is not valid for this sequence.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="nextUndoRecord" /&gt;</ph> 或 <ph id="ph2">&lt;paramref name="previousRecord" /&gt;</ph> 对此序列无效。</target>       </trans-unit>
        <trans-unit id="868" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.ReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="869" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.ReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])">
          <source><ph id="ph1">&lt;paramref name="data" /&gt;</ph> cannot be appended because it is larger than the maximum record size.</source>
          <target state="translated">无法追加 <ph id="ph1">&lt;paramref name="data" /&gt;</ph>，原因是它比最大记录大小要大。</target>       </trans-unit>
        <trans-unit id="870" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.ReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="871" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.ReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])">
          <source><ph id="ph1">&lt;paramref name="reservations" /&gt;</ph> was not created by this record sequence.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="reservations" /&gt;</ph> 不是由此记录序列创建的。</target>       </trans-unit>
        <trans-unit id="872" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.ReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])">
          <source>One or more of the arguments are <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">一个或多个参数为 <ph id="ph1">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="873" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.ReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])">
          <source><ph id="ph1">&lt;paramref name="nextUndoRecord" /&gt;</ph> or <ph id="ph2">&lt;paramref name="previousRecord" /&gt;</ph> is not between the base and last sequence numbers of this sequence.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="nextUndoRecord" /&gt;</ph> 或 <ph id="ph2">&lt;paramref name="previousRecord" /&gt;</ph> 不在此序列的基序列号和最新序列号之间。</target>       </trans-unit>
        <trans-unit id="874" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.ReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])">
          <source>The request could not be performed because of an unexpected I/O exception.</source>
          <target state="translated">由于出现意外的 I/O 异常，因此无法执行该请求。</target>       </trans-unit>
        <trans-unit id="875" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.ReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="876" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.ReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])">
          <source>The request could not be performed because of an I/O device error.</source>
          <target state="translated">由于出现 I/O 设备错误，因此无法执行该请求。</target>       </trans-unit>
        <trans-unit id="877" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.ReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])">
          <source>The operation cannot be performed because the record sequence was opened with read-only access.</source>
          <target state="translated">由于记录序列是通过只读访问权限打开的，因此无法执行该操作。</target>       </trans-unit>
        <trans-unit id="878" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.ReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])">
          <source>The method was called after the sequence has been disposed of.</source>
          <target state="translated">该方法是在序列已释放之后调用的。</target>       </trans-unit>
        <trans-unit id="879" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.ReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])">
          <source>There is not enough memory to continue the execution of the program.</source>
          <target state="translated">没有足够的内存来继续执行该程序。</target>       </trans-unit>
        <trans-unit id="880" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.ReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])">
          <source>The record sequence is full.</source>
          <target state="translated">记录序列已满。</target>       </trans-unit>
        <trans-unit id="881" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.ReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])">
          <source>Access for the specified log sequence is denied by the operating system.</source>
          <target state="translated">操作系统拒绝了对指定的日志序列的访问。</target>       </trans-unit>
        <trans-unit id="882" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.ReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])">
          <source>No reservation large enough to fit <ph id="ph1">&lt;paramref name="data" /&gt;</ph> can be found in <ph id="ph2">&lt;paramref name="reservations" /&gt;</ph>.</source>
          <target state="translated">在 <ph id="ph1">&lt;paramref name="data" /&gt;</ph> 中找不到足以容纳 <ph id="ph2">&lt;paramref name="reservations" /&gt;</ph> 的保留。</target>       </trans-unit>
        <trans-unit id="883" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.ReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])">
          <source>A list of byte array segments that will be concatenated and appended as the record.</source>
          <target state="translated">将连接在一起并以记录形式追加的字节数组段的列表。</target>       </trans-unit>
        <trans-unit id="884" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.ReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])">
          <source>The sequence number of the next record in the user-specified order.</source>
          <target state="translated">用户指定顺序中下一条记录的序列号。</target>       </trans-unit>
        <trans-unit id="885" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.ReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])">
          <source>The sequence number of the next record in Previous order.</source>
          <target state="translated">“上一个”顺序中下一条记录的序列号。</target>       </trans-unit>
        <trans-unit id="886" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.ReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])">
          <source>A valid value of <ph id="ph1">&lt;see cref="T:System.IO.Log.RecordAppendOptions" /&gt;</ph> that specifies how the data should be written.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.IO.Log.RecordAppendOptions" /&gt;</ph> 的一个有效值，用于指定应如何写入数据。</target>       </trans-unit>
        <trans-unit id="887" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.ReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])">
          <source>The reservation collection to make reservations in.</source>
          <target state="translated">要在其中生成保留的保留集合。</target>       </trans-unit>
        <trans-unit id="888" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.ReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])">
          <source>The reservations to make, in bytes.</source>
          <target state="translated">要生成的保留（以字节为单位）。</target>       </trans-unit>
        <trans-unit id="889" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.ReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])">
          <source>Automatically makes a single reservation and appends a record to the sequence.</source>
          <target state="translated">自动生成一个保留，并向序列中追加一条记录。</target>       </trans-unit>
        <trans-unit id="890" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.ReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])">
          <source>This method cannot be inherited.</source>
          <target state="translated">不能继承此方法。</target>       </trans-unit>
        <trans-unit id="891" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.ReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])">
          <source>The sequence number of the appended log record.</source>
          <target state="translated">追加的日志记录的序列号。</target>       </trans-unit>
        <trans-unit id="892" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.ReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])">
          <source>Data contained in the <ph id="ph1">`data`</ph> parameter will be concatenated into a single byte array for appending as the record.</source>
          <target state="translated">包含在 <ph id="ph1">`data`</ph> 参数中的数据将连接成单个字节数组，以便以记录形式追加。</target>       </trans-unit>
        <trans-unit id="893" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.ReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])">
          <source>However, no provision is made for splitting data back into array segments when the record is read.</source>
          <target state="translated">但在读取记录时，无法将数据重新拆分为数组段。</target>       </trans-unit>
        <trans-unit id="894" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.ReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])">
          <source>The specified reservations are added to the provided reservation collection in an atomic operation with a record append operation.</source>
          <target state="translated">在原子操作中，使用记录追加操作将指定的保留添加到所提供的保留集合。</target>       </trans-unit>
        <trans-unit id="895" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.ReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])">
          <source>If the append fails, no space is reserved.</source>
          <target state="translated">如果追加失败，将不保留任何空间。</target>       </trans-unit>
        <trans-unit id="896" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.ReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])">
          <source>Normally, this method may complete before the record has been written.</source>
          <target state="translated">通常，此方法可以在写入记录之前完成。</target>       </trans-unit>
        <trans-unit id="897" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.ReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])">
          <source>To ensure that a record has been written, either specify the <ph id="ph1">&lt;xref:System.IO.Log.RecordAppendOptions.ForceFlush&gt;</ph> flag using the <ph id="ph2">`recordAppendOptions`</ph> parameter, or call the <ph id="ph3">&lt;xref:System.IO.Log.LogRecordSequence.Flush%2A&gt;</ph> method.</source>
          <target state="translated">若要确保记录已写入，请使用 <ph id="ph1">&lt;xref:System.IO.Log.RecordAppendOptions.ForceFlush&gt;</ph> 参数指定 <ph id="ph2">`recordAppendOptions`</ph> 标志，或者调用 <ph id="ph3">&lt;xref:System.IO.Log.LogRecordSequence.Flush%2A&gt;</ph> 方法。</target>       </trans-unit>
        <trans-unit id="898" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.ReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])">
          <source>One or more of the arguments is invalid.</source>
          <target state="translated">一个或多个自变量无效。</target>       </trans-unit>
        <trans-unit id="899" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.ReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])">
          <source>An I/O error occurred while appending the record.</source>
          <target state="translated">追加记录时，发生了 I/O 错误。</target>       </trans-unit>
        <trans-unit id="900" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.ReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])">
          <source>The record sequence could not make enough free space to contain the new record, or to make the reservation.</source>
          <target state="translated">记录序列无法获得足够的可用空间来容纳新记录或生成保留。</target>       </trans-unit>
        <trans-unit id="901" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.ReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])">
          <source>The method was called after the sequence has been disposed of.</source>
          <target state="translated">该方法是在序列已释放之后调用的。</target>       </trans-unit>
        <trans-unit id="902" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.ReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])">
          <source>One or more of the arguments are <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">一个或多个参数为 <ph id="ph1">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="903" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.ReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])">
          <source><ph id="ph1">&lt;paramref name="userRecord" /&gt;</ph> or <ph id="ph2">&lt;paramref name="previousRecord" /&gt;</ph> is not between the base and last sequence numbers of this sequence.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="userRecord" /&gt;</ph> 或 <ph id="ph2">&lt;paramref name="previousRecord" /&gt;</ph> 不在此序列的基序列号和最新序列号之间。</target>       </trans-unit>
        <trans-unit id="904" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.ReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])">
          <source>The operation cannot be performed because the record sequence was opened with read-only access.</source>
          <target state="translated">由于记录序列是通过只读访问权限打开的，因此无法执行该操作。</target>       </trans-unit>
        <trans-unit id="905" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.ReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])">
          <source>There is not enough memory to continue the execution of the program.</source>
          <target state="translated">没有足够的内存来继续执行该程序。</target>       </trans-unit>
        <trans-unit id="906" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.ReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])">
          <source>Access for the specified log sequence is denied by the operating system.</source>
          <target state="translated">操作系统拒绝了对指定的日志序列的访问。</target>       </trans-unit>
        <trans-unit id="907" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.ReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])">
          <source>No reservation large enough to fit <ph id="ph1">&lt;paramref name="data" /&gt;</ph> can be found in <ph id="ph2">&lt;paramref name="reservations" /&gt;</ph>.</source>
          <target state="translated">在 <ph id="ph1">&lt;paramref name="data" /&gt;</ph> 中找不到足以容纳 <ph id="ph2">&lt;paramref name="reservations" /&gt;</ph> 的保留。</target>       </trans-unit>
        <trans-unit id="908" translate="yes" xml:space="preserve" uid="P:System.IO.Log.LogRecordSequence.ReservedBytes">
          <source>Gets the total number of bytes that have been reserved.</source>
          <target state="translated">获取已保留的字节总数。</target>       </trans-unit>
        <trans-unit id="909" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.Log.LogRecordSequence.ReservedBytes">
          <source>The total size of all reservations made in this record sequence.</source>
          <target state="translated">此记录序列中做出的所有保留的总大小。</target>       </trans-unit>
        <trans-unit id="910" translate="yes" xml:space="preserve" uid="P:System.IO.Log.LogRecordSequence.ReservedBytes">
          <source>The property was accessed after the sequence has been disposed of.</source>
          <target state="translated">该属性是在序列已释放之后访问的。</target>       </trans-unit>
        <trans-unit id="911" translate="yes" xml:space="preserve" uid="P:System.IO.Log.LogRecordSequence.RestartSequenceNumber">
          <source>Gets the sequence number of the restart area closest to the end of the log.</source>
          <target state="translated">获取最接近日志末尾的重新开始区域的序列号。</target>       </trans-unit>
        <trans-unit id="912" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.Log.LogRecordSequence.RestartSequenceNumber">
          <source>The sequence number of the restart area closest to the end of the log.</source>
          <target state="translated">最接近日志末尾的重新开始区域的序列号。</target>       </trans-unit>
        <trans-unit id="913" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.Log.LogRecordSequence.RestartSequenceNumber">
          <source>A restart area is used to temporarily store information containing a client's last checkpoint operation.</source>
          <target state="translated">重新开始区域用于临时存储包含客户端最后一次检查点操作的信息。</target>       </trans-unit>
        <trans-unit id="914" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.Log.LogRecordSequence.RestartSequenceNumber">
          <source>The Common Log File System (CLFS) maintains two restart areas to guarantee that at least one valid area is always available.</source>
          <target state="translated">公用日志文件系统 (CLFS) 维护两个重新开始区域，以确保至少有一个有效区域总是可用。</target>       </trans-unit>
        <trans-unit id="915" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.Log.LogRecordSequence.RestartSequenceNumber">
          <source>When a recovery is necessary, the CLFS reads its restart area and all the data from the last checkpoint operation.</source>
          <target state="translated">需要恢复时，CLFS 读取自己的重新开始区域和最后一个检查点操作中的所有数据。</target>       </trans-unit>
        <trans-unit id="916" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.Log.LogRecordSequence.RestartSequenceNumber">
          <source>This data initializes the transaction table, dirty pages table, and open file table so they can be used in the recovery process.</source>
          <target state="translated">这些数据将初始化事务表、脏页表和打开文件表，以便它们能够用于恢复过程。</target>       </trans-unit>
        <trans-unit id="917" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.Log.LogRecordSequence.RestartSequenceNumber">
          <source>Using the <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence.SetLastRecord%2A&gt;</ph> method, you can remove the most recently written restart area.</source>
          <target state="translated">通过使用 <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence.SetLastRecord%2A&gt;</ph> 方法，您可以移除最近写入的重新开始区域。</target>       </trans-unit>
        <trans-unit id="918" translate="yes" xml:space="preserve" uid="P:System.IO.Log.LogRecordSequence.RestartSequenceNumber">
          <source>The property was accessed after the sequence has been disposed of.</source>
          <target state="translated">该属性是在序列已释放之后访问的。</target>       </trans-unit>
        <trans-unit id="919" translate="yes" xml:space="preserve" uid="P:System.IO.Log.LogRecordSequence.RetryAppend">
          <source>Gets or sets a value indicating whether or not appends are automatically retried if the log is full.</source>
          <target state="translated">获取或设置一个值，指示在日志已满时是否自动重试追加操作。</target>       </trans-unit>
        <trans-unit id="920" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.Log.LogRecordSequence.RetryAppend">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if appends are automatically retried if the log is full; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">如果在日志已满时自动重试追加操作，则为 <ph id="ph1">&lt;see langword="true" /&gt;</ph>；否则为 <ph id="ph2">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="921" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.Log.LogRecordSequence.RetryAppend">
          <source>The default is <ph id="ph1">&lt;see langword="true" /&gt;</ph>.</source>
          <target state="translated">默认值为 <ph id="ph1">&lt;see langword="true" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="922" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.Log.LogRecordSequence.RetryAppend">
          <source>If the value of this property is <ph id="ph1">`true`</ph>, and an <ph id="ph2">&lt;xref:System.IO.Log.LogRecordSequence.Append%2A&gt;</ph> call fails because there is not enough space in the sequence, the record sequence will try to free space and retry the append.</source>
          <target state="translated">如果此属性的值为 <ph id="ph1">`true`</ph>，且 <ph id="ph2">&lt;xref:System.IO.Log.LogRecordSequence.Append%2A&gt;</ph> 调用因为序列中没有足够的空间而失败，则记录序列将尝试释放空间，然后重试追加操作。</target>       </trans-unit>
        <trans-unit id="923" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.Log.LogRecordSequence.RetryAppend">
          <source>This example shows how to use the <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence.RetryAppend%2A&gt;</ph> property.</source>
          <target state="translated">此示例演示如何使用 <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence.RetryAppend%2A&gt;</ph> 属性。</target>       </trans-unit>
        <trans-unit id="924" translate="yes" xml:space="preserve" uid="P:System.IO.Log.LogRecordSequence.RetryAppend">
          <source>The property was accessed after the sequence has been disposed of.</source>
          <target state="translated">该属性是在序列已释放之后访问的。</target>       </trans-unit>
        <trans-unit id="925" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.SetLastRecord(System.IO.Log.SequenceNumber)">
          <source>The new last sequence number in the <ph id="ph1">&lt;see cref="T:System.IO.Log.LogRecordSequence" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.IO.Log.LogRecordSequence" /&gt;</ph> 中的最后一个新序列号。</target>       </trans-unit>
        <trans-unit id="926" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.SetLastRecord(System.IO.Log.SequenceNumber)">
          <source>This should refer to a current valid record   currently in the log.</source>
          <target state="translated">它指的应该是日志中的当前有效记录。</target>       </trans-unit>
        <trans-unit id="927" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.SetLastRecord(System.IO.Log.SequenceNumber)">
          <source>Sets the last record in the <ph id="ph1">&lt;see cref="T:System.IO.Log.LogRecordSequence" /&gt;</ph>.</source>
          <target state="translated">设置 <ph id="ph1">&lt;see cref="T:System.IO.Log.LogRecordSequence" /&gt;</ph> 中的最后一条记录。</target>       </trans-unit>
        <trans-unit id="928" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.SetLastRecord(System.IO.Log.SequenceNumber)">
          <source>The specified sequence number must be larger than the base sequence number.</source>
          <target state="translated">指定的序列号必须大于基序列号。</target>       </trans-unit>
        <trans-unit id="929" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.SetLastRecord(System.IO.Log.SequenceNumber)">
          <source>When this method completes, all records that had previously been appended with sequence numbers greater than the specified sequence number are inaccessible.</source>
          <target state="translated">此方法完成后，将无法访问序列号大于指定序列号的所有先前追加的记录。</target>       </trans-unit>
        <trans-unit id="930" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.SetLastRecord(System.IO.Log.SequenceNumber)">
          <source><ph id="ph1">&lt;paramref name="sequenceNumber" /&gt;</ph> is not valid for this sequence.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="sequenceNumber" /&gt;</ph> 对此序列无效。</target>       </trans-unit>
        <trans-unit id="931" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.SetLastRecord(System.IO.Log.SequenceNumber)">
          <source>A new or existing archive tail or base of the active log is invalid.</source>
          <target state="translated">活动日志新存档或现有存档的尾数据或基数据无效。</target>       </trans-unit>
        <trans-unit id="932" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.SetLastRecord(System.IO.Log.SequenceNumber)">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="933" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.SetLastRecord(System.IO.Log.SequenceNumber)">
          <source><ph id="ph1">&lt;paramref name="sequenceNumber" /&gt;</ph> is not between the base and last sequence numbers of this sequence.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="sequenceNumber" /&gt;</ph> 不在此序列的基序列号和最后一个序列号之间。</target>       </trans-unit>
        <trans-unit id="934" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.SetLastRecord(System.IO.Log.SequenceNumber)">
          <source>The request could not be performed because of an unexpected I/O exception.</source>
          <target state="translated">由于出现意外的 I/O 异常，因此无法执行该请求。</target>       </trans-unit>
        <trans-unit id="935" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.SetLastRecord(System.IO.Log.SequenceNumber)">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="936" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.SetLastRecord(System.IO.Log.SequenceNumber)">
          <source>The end of the log has been reached.</source>
          <target state="translated">已到达日志的末尾。</target>       </trans-unit>
        <trans-unit id="937" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.SetLastRecord(System.IO.Log.SequenceNumber)">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="938" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.SetLastRecord(System.IO.Log.SequenceNumber)">
          <source>The specified log file format or version is invalid.</source>
          <target state="translated">指定的日志文件格式或版本无效。</target>       </trans-unit>
        <trans-unit id="939" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.SetLastRecord(System.IO.Log.SequenceNumber)">
          <source>The method was called after the sequence has been disposed of.</source>
          <target state="translated">该方法是在序列已释放之后调用的。</target>       </trans-unit>
        <trans-unit id="940" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.SetLastRecord(System.IO.Log.SequenceNumber)">
          <source>There is not enough memory to continue the execution of the program.</source>
          <target state="translated">没有足够的内存来继续执行该程序。</target>       </trans-unit>
        <trans-unit id="941" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.SetLastRecord(System.IO.Log.SequenceNumber)">
          <source>Access for the specified log sequence is denied by the operating system.</source>
          <target state="translated">操作系统拒绝了对指定的日志序列的访问。</target>       </trans-unit>
        <trans-unit id="942" translate="yes" xml:space="preserve" uid="E:System.IO.Log.LogRecordSequence.TailPinned">
          <source>Signals the need to move the tail of the sequence.</source>
          <target state="translated">发信号通知需要移动序列的尾数据。</target>       </trans-unit>
        <trans-unit id="943" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.IO.Log.LogRecordSequence.TailPinned">
          <source>You can fire this event when the record sequence has run out of space.</source>
          <target state="translated">可以在记录序列空间不足时激发此事件。</target>       </trans-unit>
        <trans-unit id="944" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.IO.Log.LogRecordSequence.TailPinned">
          <source>When this event is fired, the tail of the sequence (that is, the base sequence number) is moved forward to free up space.</source>
          <target state="translated">此事件激发时，序列的尾数据（即基序列号）将前移以释放空间。</target>       </trans-unit>
        <trans-unit id="945" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.IO.Log.LogRecordSequence.TailPinned">
          <source>The event can be fired at any time when the record sequence decides that it must free up space, for any reason.</source>
          <target state="translated">当记录序列决定必须释放空间时，可以借任何理由随时激发该事件。</target>       </trans-unit>
        <trans-unit id="946" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.IO.Log.LogRecordSequence.TailPinned">
          <source>For example, the CLFS policy engine may decide to fire the event when it determines that the tails of two log clients sharing the same log file are too far apart.</source>
          <target state="translated">例如，当 CLFS 策略引擎确定共享同一日志文件的两个日志客户端的结尾相距过远时，它可能会决定激发该事件。</target>       </trans-unit>
        <trans-unit id="947" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.IO.Log.LogRecordSequence.TailPinned">
          <source>Freeing space can be done by either writing restart areas, or truncating the log and using the <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence.AdvanceBaseSequenceNumber%2A&gt;</ph> method to clear space.</source>
          <target state="translated">可以通过写入重新开始区域、截断日志及使用 <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence.AdvanceBaseSequenceNumber%2A&gt;</ph> 方法清除空间来释放空间。</target>       </trans-unit>
        <trans-unit id="948" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.IO.Log.LogRecordSequence.TailPinned">
          <source>The code sample in the Example section demonstrates the second approach.</source>
          <target state="translated">“示例”部分的代码示例演示了第二种方式。</target>       </trans-unit>
        <trans-unit id="949" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.IO.Log.LogRecordSequence.TailPinned">
          <source>You can also call the <ph id="ph1">&lt;xref:System.IO.Log.FileRecordSequence.WriteRestartArea%2A&gt;</ph> method outside of the <ph id="ph2">&lt;xref:System.IO.Log.LogRecordSequence.TailPinned&gt;</ph> event to free space.</source>
          <target state="translated">还可以在 <ph id="ph1">&lt;xref:System.IO.Log.FileRecordSequence.WriteRestartArea%2A&gt;</ph> 事件之外调用 <ph id="ph2">&lt;xref:System.IO.Log.LogRecordSequence.TailPinned&gt;</ph> 方法以释放空间。</target>       </trans-unit>
        <trans-unit id="950" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.IO.Log.LogRecordSequence.TailPinned">
          <source>A restart area is similar to a checkpoint in other log processing systems.</source>
          <target state="translated">重新开始区域类似于其他日志处理系统内的检查点。</target>       </trans-unit>
        <trans-unit id="951" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.IO.Log.LogRecordSequence.TailPinned">
          <source>Calling this method indicates that the application considers all prior records before the restart area as fully completed, and usable for future record appends.</source>
          <target state="translated">调用此方法则表示，在重新开始区域彻底完成以及可用于在以后追加记录之前，应用程序将考虑以前的所有记录。</target>       </trans-unit>
        <trans-unit id="952" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.IO.Log.LogRecordSequence.TailPinned">
          <source>Similar to any other records, the record written by this method requires actual free space in the log to function.</source>
          <target state="translated">与其他任何记录类似，此方法写入的记录需要使用日志中实际的可用空间才有效。</target>       </trans-unit>
        <trans-unit id="953" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.IO.Log.LogRecordSequence.TailPinned">
          <source>This example shows how to use the <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence.TailPinned&gt;</ph> event.</source>
          <target state="translated">此示例演示如何使用 <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence.TailPinned&gt;</ph> 事件。</target>       </trans-unit>
        <trans-unit id="954" translate="yes" xml:space="preserve" uid="T:System.IO.Log.LogRecordSequence">
          <source>Writes a restart area to the <ph id="ph1">&lt;see cref="T:System.IO.Log.LogRecordSequence" /&gt;</ph>.</source>
          <target state="translated">将重新开始区域写入 <ph id="ph1">&lt;see cref="T:System.IO.Log.LogRecordSequence" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="955" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.Log.LogRecordSequence">
          <source>A restart area is used to temporarily store information containing a client's last checkpoint operation.</source>
          <target state="translated">重新开始区域用于临时存储包含客户端最后一次检查点操作的信息。</target>       </trans-unit>
        <trans-unit id="956" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.Log.LogRecordSequence">
          <source>The Common Log File System (CLFS) maintains two restart areas to guarantee that at least one valid area is always available.</source>
          <target state="translated">公用日志文件系统 (CLFS) 维护两个重新开始区域，以确保至少有一个有效区域总是可用。</target>       </trans-unit>
        <trans-unit id="957" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.Log.LogRecordSequence">
          <source>When a recovery is necessary, the CLFS reads its restart area and all the data from the last checkpoint operation.</source>
          <target state="translated">需要恢复时，CLFS 读取自己的重新开始区域和最后一个检查点操作中的所有数据。</target>       </trans-unit>
        <trans-unit id="958" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.Log.LogRecordSequence">
          <source>This data initializes the transaction table, dirty pages table, and open file table so they can be used in the recovery process.</source>
          <target state="translated">这些数据将初始化事务表、脏页表和打开文件表，以便它们能够用于恢复过程。</target>       </trans-unit>
        <trans-unit id="959" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.Log.LogRecordSequence">
          <source>A restart area can be read using the <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence.ReadRestartAreas%2A&gt;</ph> method.</source>
          <target state="translated">可以使用 <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence.ReadRestartAreas%2A&gt;</ph> 方法来读取重新开始区域。</target>       </trans-unit>
        <trans-unit id="960" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte})">
          <source>An array segment that will be concatenated and appended as the record.</source>
          <target state="translated">将连接在一起并以记录形式追加的数组段。</target>       </trans-unit>
        <trans-unit id="961" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte})">
          <source>Writes a restart area to the <ph id="ph1">&lt;see cref="T:System.IO.Log.LogRecordSequence" /&gt;</ph>.</source>
          <target state="translated">将重新开始区域写入 <ph id="ph1">&lt;see cref="T:System.IO.Log.LogRecordSequence" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="962" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte})">
          <source>This method cannot be inherited.</source>
          <target state="translated">不能继承此方法。</target>       </trans-unit>
        <trans-unit id="963" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte})">
          <source>The sequence number of the written restart area.</source>
          <target state="translated">写入的重新开始区域的序列号。</target>       </trans-unit>
        <trans-unit id="964" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte})">
          <source>A restart area is used to temporarily store information containing a client's last checkpoint operation.</source>
          <target state="translated">重新开始区域用于临时存储包含客户端最后一次检查点操作的信息。</target>       </trans-unit>
        <trans-unit id="965" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte})">
          <source>The Common Log File System (CLFS) maintains two restart areas to guarantee that at least one valid area is always available.</source>
          <target state="translated">公用日志文件系统 (CLFS) 维护两个重新开始区域，以确保至少有一个有效区域总是可用。</target>       </trans-unit>
        <trans-unit id="966" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte})">
          <source>When a recovery is necessary, the CLFS reads its restart area and all the data from the last checkpoint operation.</source>
          <target state="translated">需要恢复时，CLFS 读取自己的重新开始区域和最后一个检查点操作中的所有数据。</target>       </trans-unit>
        <trans-unit id="967" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte})">
          <source>This data initializes the transaction table, dirty pages table, and open file table so they can be used in the recovery process.</source>
          <target state="translated">这些数据将初始化事务表、脏页表和打开文件表，以便它们能够用于恢复过程。</target>       </trans-unit>
        <trans-unit id="968" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte})">
          <source>A restart area can be read using the <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence.ReadRestartAreas%2A&gt;</ph> method.</source>
          <target state="translated">可以使用 <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence.ReadRestartAreas%2A&gt;</ph> 方法来读取重新开始区域。</target>       </trans-unit>
        <trans-unit id="969" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte})">
          <source>The data in the byte array segments will be concatenated into a single byte array for appending as the record.</source>
          <target state="translated">字节数组段中的数据将连接成单个字节数组，以便以记录形式追加。</target>       </trans-unit>
        <trans-unit id="970" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte})">
          <source>No provision is made for splitting data back into array segments when the restart area is read.</source>
          <target state="translated">在读取重新开始区域时，无法将数据重新拆分为数组段。</target>       </trans-unit>
        <trans-unit id="971" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte})">
          <source>One or more of the arguments is invalid.</source>
          <target state="translated">一个或多个自变量无效。</target>       </trans-unit>
        <trans-unit id="972" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte})">
          <source>An I/O error occurred while writing the restart area.</source>
          <target state="translated">写入重新开始区域时，发生了 I/O 错误。</target>       </trans-unit>
        <trans-unit id="973" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte})">
          <source>The record sequence could not make enough free space to contain the new restart area.</source>
          <target state="translated">记录序列无法获得足够的可用空间来容纳新的重新开始区域。</target>       </trans-unit>
        <trans-unit id="974" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte})">
          <source>The method was called after the sequence has been disposed of.</source>
          <target state="translated">该方法是在序列已释放之后调用的。</target>       </trans-unit>
        <trans-unit id="975" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte})">
          <source>One or more of the arguments are <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">一个或多个参数为 <ph id="ph1">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="976" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte})">
          <source>Access for the specified log sequence is denied by the operating system.</source>
          <target state="translated">操作系统拒绝了对指定的日志序列的访问。</target>       </trans-unit>
        <trans-unit id="977" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte})">
          <source>There is not enough memory to continue the execution of the program.</source>
          <target state="translated">没有足够的内存来继续执行该程序。</target>       </trans-unit>
        <trans-unit id="978" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>A list of byte array segments that will be concatenated and appended as the record.</source>
          <target state="translated">将连接在一起并以记录形式追加的字节数组段的列表。</target>       </trans-unit>
        <trans-unit id="979" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>Writes a restart area to the <ph id="ph1">&lt;see cref="T:System.IO.Log.LogRecordSequence" /&gt;</ph>.</source>
          <target state="translated">将重新开始区域写入 <ph id="ph1">&lt;see cref="T:System.IO.Log.LogRecordSequence" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="980" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>This method cannot be inherited.</source>
          <target state="translated">不能继承此方法。</target>       </trans-unit>
        <trans-unit id="981" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>The sequence number of the written restart area.</source>
          <target state="translated">写入的重新开始区域的序列号。</target>       </trans-unit>
        <trans-unit id="982" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>A restart area is used to temporarily store information containing a client's last checkpoint operation.</source>
          <target state="translated">重新开始区域用于临时存储包含客户端最后一次检查点操作的信息。</target>       </trans-unit>
        <trans-unit id="983" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>The Common Log File System (CLFS) maintains two restart areas to guarantee that at least one valid area is always available.</source>
          <target state="translated">公用日志文件系统 (CLFS) 维护两个重新开始区域，以确保至少有一个有效区域总是可用。</target>       </trans-unit>
        <trans-unit id="984" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>When a recovery is necessary, the CLFS reads its restart area and all the data from the last checkpoint operation.</source>
          <target state="translated">需要恢复时，CLFS 读取自己的重新开始区域和最后一个检查点操作中的所有数据。</target>       </trans-unit>
        <trans-unit id="985" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>This data initializes the transaction table, dirty pages table, and open file table so they can be used in the recovery process.</source>
          <target state="translated">这些数据将初始化事务表、脏页表和打开文件表，以便它们能够用于恢复过程。</target>       </trans-unit>
        <trans-unit id="986" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>A restart area can be read using the <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence.ReadRestartAreas%2A&gt;</ph> method.</source>
          <target state="translated">可以使用 <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence.ReadRestartAreas%2A&gt;</ph> 方法来读取重新开始区域。</target>       </trans-unit>
        <trans-unit id="987" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>The data in the byte array segments will be concatenated into a single byte array for appending as the record.</source>
          <target state="translated">字节数组段中的数据将连接成单个字节数组，以便以记录形式追加。</target>       </trans-unit>
        <trans-unit id="988" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>No provision is made for splitting data back into array segments when the restart area is read.</source>
          <target state="translated">在读取重新开始区域时，无法将数据重新拆分为数组段。</target>       </trans-unit>
        <trans-unit id="989" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>One or more of the arguments is invalid.</source>
          <target state="translated">一个或多个自变量无效。</target>       </trans-unit>
        <trans-unit id="990" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>An I/O error occurred while writing the restart area.</source>
          <target state="translated">写入重新开始区域时，发生了 I/O 错误。</target>       </trans-unit>
        <trans-unit id="991" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>The record sequence could not make enough free space to contain the new restart area.</source>
          <target state="translated">记录序列无法获得足够的可用空间来容纳新的重新开始区域。</target>       </trans-unit>
        <trans-unit id="992" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>The method was called after the sequence has been disposed of.</source>
          <target state="translated">该方法是在序列已释放之后调用的。</target>       </trans-unit>
        <trans-unit id="993" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>One or more of the arguments are <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">一个或多个参数为 <ph id="ph1">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="994" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>Access for the specified log sequence is denied by the operating system.</source>
          <target state="translated">操作系统拒绝了对指定的日志序列的访问。</target>       </trans-unit>
        <trans-unit id="995" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>There is not enough memory to continue the execution of the program.</source>
          <target state="translated">没有足够的内存来继续执行该程序。</target>       </trans-unit>
        <trans-unit id="996" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber)">
          <source>A list of byte array segments that will be concatenated and appended as the record.</source>
          <target state="translated">将连接在一起并以记录形式追加的字节数组段的列表。</target>       </trans-unit>
        <trans-unit id="997" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber)">
          <source>The new base sequence number.</source>
          <target state="translated">新的基序列号。</target>       </trans-unit>
        <trans-unit id="998" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber)">
          <source>The specified sequence number must be greater than or equal to the current base sequence number.</source>
          <target state="translated">指定的序列号必须大于或等于当前基序列号。</target>       </trans-unit>
        <trans-unit id="999" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber)">
          <source>Writes a restart area to the <ph id="ph1">&lt;see cref="T:System.IO.Log.LogRecordSequence" /&gt;</ph> and updates the base sequence number.</source>
          <target state="translated">将重新开始区域写入 <ph id="ph1">&lt;see cref="T:System.IO.Log.LogRecordSequence" /&gt;</ph> 并更新基序列号。</target>       </trans-unit>
        <trans-unit id="1000" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber)">
          <source>This method cannot be inherited.</source>
          <target state="translated">不能继承此方法。</target>       </trans-unit>
        <trans-unit id="1001" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber)">
          <source>The sequence number of the written restart area.</source>
          <target state="translated">写入的重新开始区域的序列号。</target>       </trans-unit>
        <trans-unit id="1002" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber)">
          <source>A restart area is used to temporarily store information containing a client's last checkpoint operation.</source>
          <target state="translated">重新开始区域用于临时存储包含客户端最后一次检查点操作的信息。</target>       </trans-unit>
        <trans-unit id="1003" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber)">
          <source>The Common Log File System (CLFS) maintains two restart areas to guarantee that at least one valid area is always available.</source>
          <target state="translated">公用日志文件系统 (CLFS) 维护两个重新开始区域，以确保至少有一个有效区域总是可用。</target>       </trans-unit>
        <trans-unit id="1004" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber)">
          <source>When a recovery is necessary, the CLFS reads its restart area and all the data from the last checkpoint operation.</source>
          <target state="translated">需要恢复时，CLFS 读取自己的重新开始区域和最后一个检查点操作中的所有数据。</target>       </trans-unit>
        <trans-unit id="1005" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber)">
          <source>This data initializes the transaction table, dirty pages table, and open file table so they can be used in the recovery process.</source>
          <target state="translated">这些数据将初始化事务表、脏页表和打开文件表，以便它们能够用于恢复过程。</target>       </trans-unit>
        <trans-unit id="1006" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber)">
          <source>A restart area can be read using the <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence.ReadRestartAreas%2A&gt;</ph> method.</source>
          <target state="translated">可以使用 <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence.ReadRestartAreas%2A&gt;</ph> 方法来读取重新开始区域。</target>       </trans-unit>
        <trans-unit id="1007" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber)">
          <source>When a restart area is written, the data in the byte array segments are concatenated into a single byte array for appending as the record.</source>
          <target state="translated">写入重新开始区域时，字节数组段中的数据将连接成单个字节数组，以便以记录形式追加。</target>       </trans-unit>
        <trans-unit id="1008" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber)">
          <source>No provision is made for splitting data back into array segments when the restart area is read.</source>
          <target state="translated">在读取重新开始区域时，无法将数据重新拆分为数组段。</target>       </trans-unit>
        <trans-unit id="1009" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber)">
          <source>When this method successfully completes, the base sequence number has been updated.</source>
          <target state="translated">此方法成功完成时，基序列号已更新。</target>       </trans-unit>
        <trans-unit id="1010" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber)">
          <source>All log records with sequence numbers less than the new base sequence number are inaccessible.</source>
          <target state="translated">其序列号小于新的基序列号的所有日志记录都不可访问。</target>       </trans-unit>
        <trans-unit id="1011" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber)">
          <source>If a record sequence has been disposed of, or if you pass an invalid argument, exceptions are thrown immediately within this operation.</source>
          <target state="translated">如果记录序列已经释放，或者如果传递了无效自变量，此操作内将立即引发异常。</target>       </trans-unit>
        <trans-unit id="1012" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber)">
          <source>Errors that occurred during an asynchronous append request, for example, a disk failure during the I/O request, will result in exceptions being thrown when the <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A&gt;</ph> method is called.</source>
          <target state="translated">异步追加请求过程中发生的错误（例如，I/O 请求过程中的磁盘故障）将导致在调用 <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A&gt;</ph> 方法时引发异常。</target>       </trans-unit>
        <trans-unit id="1013" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber)">
          <source>One or more of the arguments is invalid.</source>
          <target state="translated">一个或多个自变量无效。</target>       </trans-unit>
        <trans-unit id="1014" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber)">
          <source>An I/O error occurred while writing the restart area.</source>
          <target state="translated">写入重新开始区域时，发生了 I/O 错误。</target>       </trans-unit>
        <trans-unit id="1015" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber)">
          <source>The record sequence could not make enough free space to contain the new restart area.</source>
          <target state="translated">记录序列无法获得足够的可用空间来容纳新的重新开始区域。</target>       </trans-unit>
        <trans-unit id="1016" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber)">
          <source>The method was called after the sequence has been disposed of.</source>
          <target state="translated">该方法是在序列已释放之后调用的。</target>       </trans-unit>
        <trans-unit id="1017" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber)">
          <source>A list of byte array segments that will be concatenated and appended as the record.</source>
          <target state="translated">将连接在一起并以记录形式追加的字节数组段的列表。</target>       </trans-unit>
        <trans-unit id="1018" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber)">
          <source>The new base sequence number.</source>
          <target state="translated">新的基序列号。</target>       </trans-unit>
        <trans-unit id="1019" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber)">
          <source>The specified sequence number must be greater than or equal to the current base sequence number.</source>
          <target state="translated">指定的序列号必须大于或等于当前基序列号。</target>       </trans-unit>
        <trans-unit id="1020" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber)">
          <source>Writes a restart area to the <ph id="ph1">&lt;see cref="T:System.IO.Log.LogRecordSequence" /&gt;</ph> and updates the base sequence number.</source>
          <target state="translated">将重新开始区域写入 <ph id="ph1">&lt;see cref="T:System.IO.Log.LogRecordSequence" /&gt;</ph> 并更新基序列号。</target>       </trans-unit>
        <trans-unit id="1021" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber)">
          <source>This method cannot be inherited.</source>
          <target state="translated">不能继承此方法。</target>       </trans-unit>
        <trans-unit id="1022" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber)">
          <source>The sequence number of the written restart area.</source>
          <target state="translated">写入的重新开始区域的序列号。</target>       </trans-unit>
        <trans-unit id="1023" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber)">
          <source>A restart area is used to temporarily store information containing a client's last checkpoint operation.</source>
          <target state="translated">重新开始区域用于临时存储包含客户端最后一次检查点操作的信息。</target>       </trans-unit>
        <trans-unit id="1024" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber)">
          <source>The Common Log File System (CLFS) maintains two restart areas to guarantee that at least one valid area is always available.</source>
          <target state="translated">公用日志文件系统 (CLFS) 维护两个重新开始区域，以确保至少有一个有效区域总是可用。</target>       </trans-unit>
        <trans-unit id="1025" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber)">
          <source>When a recovery is necessary, the CLFS reads its restart area and all the data from the last checkpoint operation.</source>
          <target state="translated">需要恢复时，CLFS 读取自己的重新开始区域和最后一个检查点操作中的所有数据。</target>       </trans-unit>
        <trans-unit id="1026" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber)">
          <source>This data initializes the transaction table, dirty pages table, and open file table so they can be used in the recovery process.</source>
          <target state="translated">这些数据将初始化事务表、脏页表和打开文件表，以便它们能够用于恢复过程。</target>       </trans-unit>
        <trans-unit id="1027" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber)">
          <source>A restart area can be read using the <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence.ReadRestartAreas%2A&gt;</ph> method.</source>
          <target state="translated">可以使用 <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence.ReadRestartAreas%2A&gt;</ph> 方法来读取重新开始区域。</target>       </trans-unit>
        <trans-unit id="1028" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber)">
          <source>When a restart area is written, the data in the byte array segments are concatenated into a single byte array for appending as the record.</source>
          <target state="translated">写入重新开始区域时，字节数组段中的数据将连接成单个字节数组，以便以记录形式追加。</target>       </trans-unit>
        <trans-unit id="1029" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber)">
          <source>No provision is made for splitting data back into array segments when the restart area is read.</source>
          <target state="translated">在读取重新开始区域时，无法将数据重新拆分为数组段。</target>       </trans-unit>
        <trans-unit id="1030" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber)">
          <source>When this method successfully completes, the base sequence number has been updated.</source>
          <target state="translated">此方法成功完成时，基序列号已更新。</target>       </trans-unit>
        <trans-unit id="1031" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber)">
          <source>All log records with sequence numbers less than the new base sequence number are inaccessible.</source>
          <target state="translated">其序列号小于新的基序列号的所有日志记录都不可访问。</target>       </trans-unit>
        <trans-unit id="1032" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber)">
          <source>If a record sequence has been disposed of, or if you pass an invalid argument, exceptions are thrown immediately within this operation.</source>
          <target state="translated">如果记录序列已经释放，或者如果传递了无效自变量，此操作内将立即引发异常。</target>       </trans-unit>
        <trans-unit id="1033" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber)">
          <source>Errors that occurred during an asynchronous append request, for example, a disk failure during the I/O request, will result in exceptions being thrown when the <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A&gt;</ph> method is called.</source>
          <target state="translated">异步追加请求过程中发生的错误（例如，I/O 请求过程中的磁盘故障）将导致在调用 <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A&gt;</ph> 方法时引发异常。</target>       </trans-unit>
        <trans-unit id="1034" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber)">
          <source>One or more of the arguments is invalid.</source>
          <target state="translated">一个或多个自变量无效。</target>       </trans-unit>
        <trans-unit id="1035" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber)">
          <source>An I/O error occurred while writing the restart area.</source>
          <target state="translated">写入重新开始区域时，发生了 I/O 错误。</target>       </trans-unit>
        <trans-unit id="1036" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber)">
          <source>The record sequence could not make enough free space to contain the new restart area.</source>
          <target state="translated">记录序列无法获得足够的可用空间来容纳新的重新开始区域。</target>       </trans-unit>
        <trans-unit id="1037" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber)">
          <source>The method was called after the sequence has been disposed of.</source>
          <target state="translated">该方法是在序列已释放之后调用的。</target>       </trans-unit>
        <trans-unit id="1038" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)">
          <source>A list of byte array segments that will be concatenated and appended as the record.</source>
          <target state="translated">将连接在一起并以记录形式追加的字节数组段的列表。</target>       </trans-unit>
        <trans-unit id="1039" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)">
          <source>The new base sequence number.</source>
          <target state="translated">新的基序列号。</target>       </trans-unit>
        <trans-unit id="1040" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)">
          <source>The specified sequence number must be greater than or equal to the current base sequence number.</source>
          <target state="translated">指定的序列号必须大于或等于当前基序列号。</target>       </trans-unit>
        <trans-unit id="1041" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)">
          <source>A <ph id="ph1">&lt;see cref="T:System.IO.Log.ReservationCollection" /&gt;</ph> that contains the reservation that should be used for this restart area.</source>
          <target state="translated">一个 <ph id="ph1">&lt;see cref="T:System.IO.Log.ReservationCollection" /&gt;</ph>，它包含应当用于此重新开始区域的保留。</target>       </trans-unit>
        <trans-unit id="1042" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)">
          <source>Writes a restart area to the <ph id="ph1">&lt;see cref="T:System.IO.Log.LogRecordSequence" /&gt;</ph> using a reservation, and updates the base sequence number.</source>
          <target state="translated">使用保留将重新开始区域写入 <ph id="ph1">&lt;see cref="T:System.IO.Log.LogRecordSequence" /&gt;</ph> 并更新基序列号。</target>       </trans-unit>
        <trans-unit id="1043" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)">
          <source>This method cannot be inherited.</source>
          <target state="translated">不能继承此方法。</target>       </trans-unit>
        <trans-unit id="1044" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)">
          <source>The sequence number of the written restart area.</source>
          <target state="translated">写入的重新开始区域的序列号。</target>       </trans-unit>
        <trans-unit id="1045" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)">
          <source>A restart area is used to temporarily store information containing a client's last checkpoint operation.</source>
          <target state="translated">重新开始区域用于临时存储包含客户端最后一次检查点操作的信息。</target>       </trans-unit>
        <trans-unit id="1046" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)">
          <source>The Common Log File System (CLFS) maintains two restart areas to guarantee that at least one valid area is always available.</source>
          <target state="translated">公用日志文件系统 (CLFS) 维护两个重新开始区域，以确保至少有一个有效区域总是可用。</target>       </trans-unit>
        <trans-unit id="1047" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)">
          <source>When a recovery is necessary, the CLFS reads its restart area and all the data from the last checkpoint operation.</source>
          <target state="translated">需要恢复时，CLFS 读取自己的重新开始区域和最后一个检查点操作中的所有数据。</target>       </trans-unit>
        <trans-unit id="1048" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)">
          <source>This data initializes the transaction table, dirty pages table, and open file table so they can be used in the recovery process.</source>
          <target state="translated">这些数据将初始化事务表、脏页表和打开文件表，以便它们能够用于恢复过程。</target>       </trans-unit>
        <trans-unit id="1049" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)">
          <source>A restart area can be read using the <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence.ReadRestartAreas%2A&gt;</ph> method.</source>
          <target state="translated">可以使用 <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence.ReadRestartAreas%2A&gt;</ph> 方法来读取重新开始区域。</target>       </trans-unit>
        <trans-unit id="1050" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)">
          <source>When a restart area is written, the data in the byte array segments are concatenated into a single byte array for appending as the record.</source>
          <target state="translated">写入重新开始区域时，字节数组段中的数据将连接成单个字节数组，以便以记录形式追加。</target>       </trans-unit>
        <trans-unit id="1051" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)">
          <source>No provision is made for splitting data back into array segments when the restart area is read.</source>
          <target state="translated">在读取重新开始区域时，无法将数据重新拆分为数组段。</target>       </trans-unit>
        <trans-unit id="1052" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)">
          <source>If a reservation is specified, the written restart area will consume space that has been previously reserved, using a reservation contained in the collection.</source>
          <target state="translated">如果指定了保留，写入的重新开始区域将使用集合中包含的保留来占用先前已保留的空间。</target>       </trans-unit>
        <trans-unit id="1053" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)">
          <source>If the method succeeds, it will consume the smallest reservation that can contain the data, and that reservation will be removed from the collection.</source>
          <target state="translated">如果该方法成功，它将占用能容纳数据的最小保留，而该保留将从集合中移除。</target>       </trans-unit>
        <trans-unit id="1054" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)">
          <source>When this method successfully completes, the base sequence number has been updated.</source>
          <target state="translated">此方法成功完成时，基序列号已更新。</target>       </trans-unit>
        <trans-unit id="1055" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)">
          <source>All log records with sequence numbers less than the new base sequence number are inaccessible.</source>
          <target state="translated">其序列号小于新的基序列号的所有日志记录都不可访问。</target>       </trans-unit>
        <trans-unit id="1056" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)">
          <source>If a record sequence has been disposed of, or if you pass an invalid argument, exceptions are thrown immediately within this operation.</source>
          <target state="translated">如果记录序列已经释放，或者如果传递了无效自变量，此操作内将立即引发异常。</target>       </trans-unit>
        <trans-unit id="1057" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)">
          <source>Errors that occurred during an asynchronous append request, for example, a disk failure during the I/O request, will result in exceptions being thrown when the <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A&gt;</ph> method is called.</source>
          <target state="translated">异步追加请求过程中发生的错误（例如，I/O 请求过程中的磁盘故障）将导致在调用 <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A&gt;</ph> 方法时引发异常。</target>       </trans-unit>
        <trans-unit id="1058" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)">
          <source>One or more of the arguments is invalid.</source>
          <target state="translated">一个或多个自变量无效。</target>       </trans-unit>
        <trans-unit id="1059" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)">
          <source>An I/O error occurred while writing the restart area.</source>
          <target state="translated">写入重新开始区域时，发生了 I/O 错误。</target>       </trans-unit>
        <trans-unit id="1060" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)">
          <source>The record sequence could not make enough free space to contain the new restart area.</source>
          <target state="translated">记录序列无法获得足够的可用空间来容纳新的重新开始区域。</target>       </trans-unit>
        <trans-unit id="1061" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)">
          <source>The method was called after the sequence has been disposed of.</source>
          <target state="translated">该方法是在序列已释放之后调用的。</target>       </trans-unit>
        <trans-unit id="1062" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)">
          <source>A list of byte array segments that will be concatenated and appended as the record.</source>
          <target state="translated">将连接在一起并以记录形式追加的字节数组段的列表。</target>       </trans-unit>
        <trans-unit id="1063" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)">
          <source>The new base sequence number.</source>
          <target state="translated">新的基序列号。</target>       </trans-unit>
        <trans-unit id="1064" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)">
          <source>The specified sequence number must be greater than or equal to the current base sequence number.</source>
          <target state="translated">指定的序列号必须大于或等于当前基序列号。</target>       </trans-unit>
        <trans-unit id="1065" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)">
          <source>A <ph id="ph1">&lt;see cref="T:System.IO.Log.ReservationCollection" /&gt;</ph> that contains the reservation that should be used for this restart area.</source>
          <target state="translated">一个 <ph id="ph1">&lt;see cref="T:System.IO.Log.ReservationCollection" /&gt;</ph>，它包含应当用于此重新开始区域的保留。</target>       </trans-unit>
        <trans-unit id="1066" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)">
          <source>Writes a restart area to the <ph id="ph1">&lt;see cref="T:System.IO.Log.LogRecordSequence" /&gt;</ph> using a reservation, and updates the base sequence number.</source>
          <target state="translated">使用保留将重新开始区域写入 <ph id="ph1">&lt;see cref="T:System.IO.Log.LogRecordSequence" /&gt;</ph> 并更新基序列号。</target>       </trans-unit>
        <trans-unit id="1067" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)">
          <source>This method cannot be inherited.</source>
          <target state="translated">不能继承此方法。</target>       </trans-unit>
        <trans-unit id="1068" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)">
          <source>The sequence number of the written restart area.</source>
          <target state="translated">写入的重新开始区域的序列号。</target>       </trans-unit>
        <trans-unit id="1069" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)">
          <source>A restart area is used to temporarily store information containing a client's last checkpoint operation.</source>
          <target state="translated">重新开始区域用于临时存储包含客户端最后一次检查点操作的信息。</target>       </trans-unit>
        <trans-unit id="1070" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)">
          <source>The Common Log File System (CLFS) maintains two restart areas to guarantee that at least one valid area is always available.</source>
          <target state="translated">公用日志文件系统 (CLFS) 维护两个重新开始区域，以确保至少有一个有效区域总是可用。</target>       </trans-unit>
        <trans-unit id="1071" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)">
          <source>When a recovery is necessary, the CLFS reads its restart area and all the data from the last checkpoint operation.</source>
          <target state="translated">需要恢复时，CLFS 读取自己的重新开始区域和最后一个检查点操作中的所有数据。</target>       </trans-unit>
        <trans-unit id="1072" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)">
          <source>This data initializes the transaction table, dirty pages table, and open file table so they can be used in the recovery process.</source>
          <target state="translated">这些数据将初始化事务表、脏页表和打开文件表，以便它们能够用于恢复过程。</target>       </trans-unit>
        <trans-unit id="1073" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)">
          <source>A restart area can be read using the <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence.ReadRestartAreas%2A&gt;</ph> method.</source>
          <target state="translated">可以使用 <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence.ReadRestartAreas%2A&gt;</ph> 方法来读取重新开始区域。</target>       </trans-unit>
        <trans-unit id="1074" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)">
          <source>When a restart area is written, the data in the byte array segments are concatenated into a single byte array for appending as the record.</source>
          <target state="translated">写入重新开始区域时，字节数组段中的数据将连接成单个字节数组，以便以记录形式追加。</target>       </trans-unit>
        <trans-unit id="1075" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)">
          <source>No provision is made for splitting data back into array segments when the restart area is read.</source>
          <target state="translated">在读取重新开始区域时，无法将数据重新拆分为数组段。</target>       </trans-unit>
        <trans-unit id="1076" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)">
          <source>If a reservation is specified, the written restart area will consume space that has been previously reserved, using a reservation contained in the collection.</source>
          <target state="translated">如果指定了保留，写入的重新开始区域将使用集合中包含的保留来占用先前已保留的空间。</target>       </trans-unit>
        <trans-unit id="1077" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)">
          <source>If the method succeeds, it will consume the smallest reservation that can contain the data, and that reservation will be removed from the collection.</source>
          <target state="translated">如果该方法成功，它将占用能容纳数据的最小保留，而该保留将从集合中移除。</target>       </trans-unit>
        <trans-unit id="1078" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)">
          <source>When this method successfully completes, the base sequence number has been updated.</source>
          <target state="translated">此方法成功完成时，基序列号已更新。</target>       </trans-unit>
        <trans-unit id="1079" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)">
          <source>All log records with sequence numbers less than the new base sequence number are inaccessible.</source>
          <target state="translated">其序列号小于新的基序列号的所有日志记录都不可访问。</target>       </trans-unit>
        <trans-unit id="1080" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)">
          <source>If a record sequence has been disposed of, or if you pass an invalid argument, exceptions are thrown immediately within this operation.</source>
          <target state="translated">如果记录序列已经释放，或者如果传递了无效自变量，此操作内将立即引发异常。</target>       </trans-unit>
        <trans-unit id="1081" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)">
          <source>Errors that occurred during an asynchronous append request, for example, a disk failure during the I/O request, will result in exceptions being thrown when the <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A&gt;</ph> method is called.</source>
          <target state="translated">异步追加请求过程中发生的错误（例如，I/O 请求过程中的磁盘故障）将导致在调用 <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A&gt;</ph> 方法时引发异常。</target>       </trans-unit>
        <trans-unit id="1082" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)">
          <source><ph id="ph1">&lt;paramref name="newBaseSeqNum" /&gt;</ph> is not valid for this sequence.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="newBaseSeqNum" /&gt;</ph> 对此序列无效。</target>       </trans-unit>
        <trans-unit id="1083" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="1084" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)">
          <source>The specified log enumeration start sequence number is invalid.</source>
          <target state="translated">指定的日志枚举开始序列号无效。</target>       </trans-unit>
        <trans-unit id="1085" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="1086" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)">
          <source><ph id="ph1">&lt;paramref name="data" /&gt;</ph> cannot be appended because it is larger than the maximum record size.</source>
          <target state="translated">无法追加 <ph id="ph1">&lt;paramref name="data" /&gt;</ph>，原因是它比最大记录大小要大。</target>       </trans-unit>
        <trans-unit id="1087" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="1088" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)">
          <source><ph id="ph1">&lt;paramref name="reservationCollection" /&gt;</ph> was not created by this record sequence.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="reservationCollection" /&gt;</ph> 不是由此记录序列创建的。</target>       </trans-unit>
        <trans-unit id="1089" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)">
          <source>One or more of the parameters is <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">一个或多个参数为 <ph id="ph1">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1090" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)">
          <source>A new or existing archive tail or base of the active log is invalid.</source>
          <target state="translated">活动日志新存档或现有存档的尾数据或基数据无效。</target>       </trans-unit>
        <trans-unit id="1091" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="1092" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)">
          <source><ph id="ph1">&lt;paramref name="newBaseSeqNum" /&gt;</ph> is not between the base and last sequence numbers of this sequence.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="newBaseSeqNum" /&gt;</ph> 不在此序列的基序列号和最后一个序列号之间。</target>       </trans-unit>
        <trans-unit id="1093" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)">
          <source>The request could not be performed because of an unexpected I/O exception.</source>
          <target state="translated">由于出现意外的 I/O 异常，因此无法执行该请求。</target>       </trans-unit>
        <trans-unit id="1094" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="1095" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)">
          <source>The request could not be performed because of an I/O device error.</source>
          <target state="translated">由于出现 I/O 设备错误，因此无法执行该请求。</target>       </trans-unit>
        <trans-unit id="1096" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)">
          <source>The method was called after the sequence has been disposed of.</source>
          <target state="translated">该方法是在序列已释放之后调用的。</target>       </trans-unit>
        <trans-unit id="1097" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)">
          <source>There is not enough memory to continue the execution of the program.</source>
          <target state="translated">没有足够的内存来继续执行该程序。</target>       </trans-unit>
        <trans-unit id="1098" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)">
          <source>Access for the specified log sequence is denied by the operating system.</source>
          <target state="translated">操作系统拒绝了对指定的日志序列的访问。</target>       </trans-unit>
        <trans-unit id="1099" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)">
          <source>The record sequence is full.</source>
          <target state="translated">记录序列已满。</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>