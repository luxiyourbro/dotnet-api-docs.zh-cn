<Type Name="NamedPipeServerStream" FullName="System.IO.Pipes.NamedPipeServerStream">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="c40d6947ec66b9e66a0e8ba16ffcdc9847c55695" />
    <Meta Name="ms.sourcegitcommit" Value="0ec122ee5f3681159b8460ab15b409fd6e3d3ae0" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-CN" />
    <Meta Name="ms.lasthandoff" Value="10/04/2018" />
    <Meta Name="ms.locfileid" Value="48633881" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class NamedPipeServerStream : System.IO.Pipes.PipeStream" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit NamedPipeServerStream extends System.IO.Pipes.PipeStream" />
  <TypeSignature Language="DocId" Value="T:System.IO.Pipes.NamedPipeServerStream" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class NamedPipeServerStream&#xA;Inherits PipeStream" />
  <TypeSignature Language="C++ CLI" Value="public ref class NamedPipeServerStream sealed : System::IO::Pipes::PipeStream" />
  <TypeSignature Language="F#" Value="type NamedPipeServerStream = class&#xA;    inherit PipeStream" />
  <AssemblyInfo>
    <AssemblyName>System.IO.Pipes</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Core</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>3.5.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.IO.Pipes.PipeStream</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>公开命名管道周围的 <see cref="T:System.IO.Stream" />，该管道既支持同步读写操作，也支持异步读写操作。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 命名的管道提供单向或双工管道的管道服务器与一个或多个管道客户端之间的通信。 本地或网络，可以进行进程间通信使用命名的管道。 可由多个共享单个管道名称<xref:System.IO.Pipes.NamedPipeClientStream>对象。  
  
 任何进程可以充当命名的管道服务器和/或客户端。  
  
> [!NOTE]
>  有关[!INCLUDE[winxppro](~/includes/winxppro-md.md)]和[!INCLUDE[win2kserver](~/includes/win2kserver-md.md)]，最多 10 个管道可以通过网络同时连接。  
  
   
  
## Examples  
 下面的示例演示一种方法将字符串从父进程发送到同一计算机上使用命名管道的子进程。 此示例将创建<xref:System.IO.Pipes.NamedPipeServerStream>对象中父进程<xref:System.IO.Pipes.PipeDirection>的值<xref:System.IO.Pipes.PipeDirection.Out>。 然后等待服务器<xref:System.IO.Pipes.NamedPipeClientStream>中用于连接到它的子进程的对象。 在此示例中，这两个进程都位于同一台计算机上并<xref:System.IO.Pipes.NamedPipeClientStream>对象具有<xref:System.IO.Pipes.PipeDirection>的值<xref:System.IO.Pipes.PipeDirection.In>。 接下来，父进程将用户提供的字符串发送给子进程。 该字符串显示到控制台。  
  
 此示例适用于服务器过程中，使用<xref:System.IO.Pipes.NamedPipeServerStream>类。 有关完整的代码示例，包括代码管道客户端和服务器，请参阅[如何： 使用命名管道进行网络进程间通信](~/docs/standard/io/how-to-use-named-pipes-for-network-interprocess-communication.md)。  
  
 [!code-csharp[System.IO.Pipes.NamedPipeServerStream_Sample1#01](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Pipes.NamedPipeServerStream_Sample1/cs/Program.cs#01)]
 [!code-vb[System.IO.Pipes.NamedPipeServerStream_Sample1#01](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Pipes.NamedPipeServerStream_Sample1/vb/program.vb#01)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>初始化 <see cref="T:System.IO.Pipes.NamedPipeServerStream" /> 类的新实例。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public NamedPipeServerStream (string pipeName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string pipeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Pipes.NamedPipeServerStream.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (pipeName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; NamedPipeServerStream(System::String ^ pipeName);" />
      <MemberSignature Language="F#" Value="new System.IO.Pipes.NamedPipeServerStream : string -&gt; System.IO.Pipes.NamedPipeServerStream" Usage="new System.IO.Pipes.NamedPipeServerStream pipeName" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="pipeName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="pipeName">管道的名称。</param>
        <summary>用指定的管道名称初始化 <see cref="T:System.IO.Pipes.NamedPipeServerStream" /> 类的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此构造函数创建<xref:System.IO.Pipes.NamedPipeServerStream>对象，它具有以下特征：  
  
-   默认管道方向为<xref:System.IO.Pipes.PipeDirection.InOut>。  
  
-   服务器实例共享相同名称的最大数目设置为 1。  
  
-   一个 <xref:System.IO.Pipes.PipeTransmissionMode.Byte> 的 <xref:System.IO.Pipes.PipeTransmissionMode> 值。  
  
-   一个 <xref:System.IO.Pipes.PipeOptions.None> 的 <xref:System.IO.Pipes.PipeOptions> 值。  
  
-   默认输入和输出缓冲区大小。  
  
-   没有管道安全性。  
  
-   一个 <xref:System.IO.HandleInheritability.None> 的 <xref:System.IO.HandleInheritability> 值。  
  
-   未指定其他<xref:System.IO.Pipes.PipeAccessRights>。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="pipeName" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="pipeName" /> 是一个长度为零的字符串。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="pipeName" /> 设置为“匿名”。</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="pipeName" /> 包含一个冒号 (":")。</exception>
        <exception cref="T:System.PlatformNotSupportedException">操作系统是不受支持的 Windows Millennium Edition、Windows 98 或 Windows 95。</exception>
        <exception cref="T:System.IO.IOException">已超出服务器实例的最大数量。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.Demand">对于直接调用方的完全信任。 此成员不能由部分信任的代码使用。</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public NamedPipeServerStream (string pipeName, System.IO.Pipes.PipeDirection direction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string pipeName, valuetype System.IO.Pipes.PipeDirection direction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Pipes.NamedPipeServerStream.#ctor(System.String,System.IO.Pipes.PipeDirection)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (pipeName As String, direction As PipeDirection)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; NamedPipeServerStream(System::String ^ pipeName, System::IO::Pipes::PipeDirection direction);" />
      <MemberSignature Language="F#" Value="new System.IO.Pipes.NamedPipeServerStream : string * System.IO.Pipes.PipeDirection -&gt; System.IO.Pipes.NamedPipeServerStream" Usage="new System.IO.Pipes.NamedPipeServerStream (pipeName, direction)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="pipeName" Type="System.String" />
        <Parameter Name="direction" Type="System.IO.Pipes.PipeDirection" />
      </Parameters>
      <Docs>
        <param name="pipeName">管道的名称。</param>
        <param name="direction">确定管道方向的枚举值之一。</param>
        <summary>使用指定的管道名称和管道方向初始化 <see cref="T:System.IO.Pipes.NamedPipeServerStream" /> 类的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此构造函数创建<xref:System.IO.Pipes.NamedPipeServerStream>对象，它具有以下特征：  
  
-   一个 <xref:System.IO.Pipes.PipeTransmissionMode.Byte> 的 <xref:System.IO.Pipes.PipeTransmissionMode> 值。  
  
-   一个 <xref:System.IO.Pipes.PipeOptions.None> 的 <xref:System.IO.Pipes.PipeOptions> 值。  
  
-   默认输入和输出缓冲区大小。  
  
-   没有管道安全性。  
  
-   一个 <xref:System.IO.HandleInheritability.None> 的 <xref:System.IO.HandleInheritability> 值。  
  
-   未指定其他<xref:System.IO.Pipes.PipeAccessRights>。  
  
   
  
## Examples  
 下面的示例演示如何将字符串从父进程发送到子进程，使用命名管道的方法。 此示例将创建<xref:System.IO.Pipes.NamedPipeServerStream>父进程中的对象。 <xref:System.IO.Pipes.NamedPipeServerStream>对象具有<xref:System.IO.Pipes.PipeDirection>的值<xref:System.IO.Pipes.PipeDirection.Out>，然后进行阻止，直到<xref:System.IO.Pipes.NamedPipeClientStream>对象建立到当前的连接<xref:System.IO.Pipes.NamedPipeServerStream>对象。  
  
 [!code-csharp[System.IO.Pipes.NamedPipeServerStream_Sample1#01](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Pipes.NamedPipeServerStream_Sample1/cs/Program.cs#01)]
 [!code-vb[System.IO.Pipes.NamedPipeServerStream_Sample1#01](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Pipes.NamedPipeServerStream_Sample1/vb/program.vb#01)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="pipeName" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="pipeName" /> 是一个长度为零的字符串。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="pipeName" /> 设置为“匿名”。  
  
或 
 <paramref name="direction" /> 不是有效的 <see cref="T:System.IO.Pipes.PipeDirection" /> 值。</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="pipeName" /> 包含一个冒号 (":")。</exception>
        <exception cref="T:System.PlatformNotSupportedException">操作系统是不受支持的 Windows Millennium Edition、Windows 98 或 Windows 95。</exception>
        <exception cref="T:System.IO.IOException">已超出服务器实例的最大数量。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.Demand">对于直接调用方的完全信任。 此成员不能由部分信任的代码使用。</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public NamedPipeServerStream (string pipeName, System.IO.Pipes.PipeDirection direction, int maxNumberOfServerInstances);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string pipeName, valuetype System.IO.Pipes.PipeDirection direction, int32 maxNumberOfServerInstances) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Pipes.NamedPipeServerStream.#ctor(System.String,System.IO.Pipes.PipeDirection,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (pipeName As String, direction As PipeDirection, maxNumberOfServerInstances As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; NamedPipeServerStream(System::String ^ pipeName, System::IO::Pipes::PipeDirection direction, int maxNumberOfServerInstances);" />
      <MemberSignature Language="F#" Value="new System.IO.Pipes.NamedPipeServerStream : string * System.IO.Pipes.PipeDirection * int -&gt; System.IO.Pipes.NamedPipeServerStream" Usage="new System.IO.Pipes.NamedPipeServerStream (pipeName, direction, maxNumberOfServerInstances)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="pipeName" Type="System.String" />
        <Parameter Name="direction" Type="System.IO.Pipes.PipeDirection" />
        <Parameter Name="maxNumberOfServerInstances" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="pipeName">管道的名称。</param>
        <param name="direction">确定管道方向的枚举值之一。</param>
        <param name="maxNumberOfServerInstances">共享同一名称的服务器实例的最大数量。 可以为此值传递 <see cref="F:System.IO.Pipes.NamedPipeServerStream.MaxAllowedServerInstances" />。</param>
        <summary>使用指定的管道名称、管道方向和最大数量的服务器实例初始化 <see cref="T:System.IO.Pipes.NamedPipeServerStream" /> 类的一个新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此构造函数创建<xref:System.IO.Pipes.NamedPipeServerStream>对象，它具有以下特征：  
  
-   默认值为 1 共享相同名称的服务器实例的最大数目。  
  
-   默认值<xref:System.IO.Pipes.PipeTransmissionMode>的值<xref:System.IO.Pipes.PipeTransmissionMode.Byte>。  
  
-   一个 <xref:System.IO.Pipes.PipeOptions.None> 的 <xref:System.IO.Pipes.PipeOptions> 值。  
  
-   默认输入和输出缓冲区大小。  
  
-   没有管道安全性。  
  
-   一个 <xref:System.IO.HandleInheritability.None> 的 <xref:System.IO.HandleInheritability> 值。  
  
-   未指定其他<xref:System.IO.Pipes.PipeAccessRights>。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="pipeName" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="pipeName" /> 是一个长度为零的字符串。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="pipeName" /> 设置为“匿名”。  
  
或 
 <paramref name="direction" /> 不是有效的 <see cref="T:System.IO.Pipes.PipeDirection" /> 值。  
  
或 
需要非负数。  
  
或 
 <paramref name="maxNumberofServerInstances" /> 小于 -1 或大于 254（-1 指示 <see cref="F:System.IO.Pipes.NamedPipeServerStream.MaxAllowedServerInstances" />） 
或 
 需要 <see cref="F:System.IO.HandleInheritability.None" /> 或 <see cref="F:System.IO.HandleInheritability.Inheritable" />。  
  
或 
访问权限仅限于 <see cref="F:System.IO.Pipes.PipeAccessRights.ChangePermissions" />、<see cref="F:System.IO.Pipes.PipeAccessRights.TakeOwnership" /> 和 <see cref="F:System.IO.Pipes.PipeAccessRights.AccessSystemSecurity" /> 标志。</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="pipeName" /> 包含一个冒号 (":")。</exception>
        <exception cref="T:System.PlatformNotSupportedException">操作系统是不受支持的 Windows Millennium Edition、Windows 98 或 Windows 95。</exception>
        <exception cref="T:System.IO.IOException">已超出服务器实例的最大数量。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.Demand">对于直接调用方的完全信任。 此成员不能由部分信任的代码使用。</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public NamedPipeServerStream (System.IO.Pipes.PipeDirection direction, bool isAsync, bool isConnected, Microsoft.Win32.SafeHandles.SafePipeHandle safePipeHandle);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.IO.Pipes.PipeDirection direction, bool isAsync, bool isConnected, class Microsoft.Win32.SafeHandles.SafePipeHandle safePipeHandle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Pipes.NamedPipeServerStream.#ctor(System.IO.Pipes.PipeDirection,System.Boolean,System.Boolean,Microsoft.Win32.SafeHandles.SafePipeHandle)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; NamedPipeServerStream(System::IO::Pipes::PipeDirection direction, bool isAsync, bool isConnected, Microsoft::Win32::SafeHandles::SafePipeHandle ^ safePipeHandle);" />
      <MemberSignature Language="F#" Value="new System.IO.Pipes.NamedPipeServerStream : System.IO.Pipes.PipeDirection * bool * bool * Microsoft.Win32.SafeHandles.SafePipeHandle -&gt; System.IO.Pipes.NamedPipeServerStream" Usage="new System.IO.Pipes.NamedPipeServerStream (direction, isAsync, isConnected, safePipeHandle)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.5;netframework-4.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="direction" Type="System.IO.Pipes.PipeDirection" />
        <Parameter Name="isAsync" Type="System.Boolean" />
        <Parameter Name="isConnected" Type="System.Boolean" />
        <Parameter Name="safePipeHandle" Type="Microsoft.Win32.SafeHandles.SafePipeHandle" />
      </Parameters>
      <Docs>
        <param name="direction">确定管道方向的枚举值之一。</param>
        <param name="isAsync">
          <see langword="true" /> 指示句柄已异步打开；否则为 <see langword="false" />。</param>
        <param name="isConnected">指示管道已连接，则为 <see langword="true" />；否则为 <see langword="false" />。</param>
        <param name="safePipeHandle">此 <see cref="T:System.IO.Pipes.NamedPipeServerStream" /> 对象将封装的管道的安全句柄。</param>
        <summary>从指定的管道句柄初始化 <see cref="T:System.IO.Pipes.NamedPipeServerStream" /> 类的一个新实例。</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="direction" /> 不是有效的 <see cref="T:System.IO.Pipes.PipeDirection" /> 值。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="safePipeHandle" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="safePipeHandle" /> 是无效的句柄。</exception>
        <exception cref="T:System.IO.IOException">
          <paramref name="safePipeHandle" /> 不是有效的管道句柄。  
  
或 
已超出服务器实例的最大数量。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.Demand">对于直接调用方的完全信任。 此成员不能由部分信任的代码使用。</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public NamedPipeServerStream (string pipeName, System.IO.Pipes.PipeDirection direction, int maxNumberOfServerInstances, System.IO.Pipes.PipeTransmissionMode transmissionMode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string pipeName, valuetype System.IO.Pipes.PipeDirection direction, int32 maxNumberOfServerInstances, valuetype System.IO.Pipes.PipeTransmissionMode transmissionMode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Pipes.NamedPipeServerStream.#ctor(System.String,System.IO.Pipes.PipeDirection,System.Int32,System.IO.Pipes.PipeTransmissionMode)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (pipeName As String, direction As PipeDirection, maxNumberOfServerInstances As Integer, transmissionMode As PipeTransmissionMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; NamedPipeServerStream(System::String ^ pipeName, System::IO::Pipes::PipeDirection direction, int maxNumberOfServerInstances, System::IO::Pipes::PipeTransmissionMode transmissionMode);" />
      <MemberSignature Language="F#" Value="new System.IO.Pipes.NamedPipeServerStream : string * System.IO.Pipes.PipeDirection * int * System.IO.Pipes.PipeTransmissionMode -&gt; System.IO.Pipes.NamedPipeServerStream" Usage="new System.IO.Pipes.NamedPipeServerStream (pipeName, direction, maxNumberOfServerInstances, transmissionMode)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="pipeName" Type="System.String" />
        <Parameter Name="direction" Type="System.IO.Pipes.PipeDirection" />
        <Parameter Name="maxNumberOfServerInstances" Type="System.Int32" />
        <Parameter Name="transmissionMode" Type="System.IO.Pipes.PipeTransmissionMode" />
      </Parameters>
      <Docs>
        <param name="pipeName">管道的名称。</param>
        <param name="direction">确定管道方向的枚举值之一。</param>
        <param name="maxNumberOfServerInstances">共享同一名称的服务器实例的最大数量。 可以为此值传递 <see cref="F:System.IO.Pipes.NamedPipeServerStream.MaxAllowedServerInstances" />。</param>
        <param name="transmissionMode">确定管道传输模式的枚举值之一。</param>
        <summary>使用指定的管道名称、管道方向、最大数量的服务器实例和传输模式初始化 <see cref="T:System.IO.Pipes.NamedPipeServerStream" /> 类的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此构造函数创建<xref:System.IO.Pipes.NamedPipeServerStream>对象，它具有以下特征：  
  
-   默认值<xref:System.IO.Pipes.PipeOptions>的值<xref:System.IO.Pipes.PipeOptions.None>。  
  
-   默认输入和输出缓冲区大小。  
  
-   没有管道安全性。  
  
-   一个 <xref:System.IO.HandleInheritability.None> 的 <xref:System.IO.HandleInheritability> 值。  
  
-   未指定其他<xref:System.IO.Pipes.PipeAccessRights>。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="pipeName" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="pipeName" /> 是一个长度为零的字符串。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="pipeName" /> 设置为“匿名”。  
  
或 
 <paramref name="direction" /> 不是有效的 <see cref="T:System.IO.Pipes.PipeDirection" /> 值。  
  
或 
 <paramref name="maxNumberofServerInstances" /> 小于 -1 或大于 254（-1 指示 <see cref="F:System.IO.Pipes.NamedPipeServerStream.MaxAllowedServerInstances" />）</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="pipeName" /> 包含一个冒号 (":")。</exception>
        <exception cref="T:System.PlatformNotSupportedException">操作系统是不受支持的 Windows Millennium Edition、Windows 98 或 Windows 95。</exception>
        <exception cref="T:System.IO.IOException">已超出服务器实例的最大数量。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.Demand">对于直接调用方的完全信任。 此成员不能由部分信任的代码使用。</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public NamedPipeServerStream (string pipeName, System.IO.Pipes.PipeDirection direction, int maxNumberOfServerInstances, System.IO.Pipes.PipeTransmissionMode transmissionMode, System.IO.Pipes.PipeOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string pipeName, valuetype System.IO.Pipes.PipeDirection direction, int32 maxNumberOfServerInstances, valuetype System.IO.Pipes.PipeTransmissionMode transmissionMode, valuetype System.IO.Pipes.PipeOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Pipes.NamedPipeServerStream.#ctor(System.String,System.IO.Pipes.PipeDirection,System.Int32,System.IO.Pipes.PipeTransmissionMode,System.IO.Pipes.PipeOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (pipeName As String, direction As PipeDirection, maxNumberOfServerInstances As Integer, transmissionMode As PipeTransmissionMode, options As PipeOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; NamedPipeServerStream(System::String ^ pipeName, System::IO::Pipes::PipeDirection direction, int maxNumberOfServerInstances, System::IO::Pipes::PipeTransmissionMode transmissionMode, System::IO::Pipes::PipeOptions options);" />
      <MemberSignature Language="F#" Value="new System.IO.Pipes.NamedPipeServerStream : string * System.IO.Pipes.PipeDirection * int * System.IO.Pipes.PipeTransmissionMode * System.IO.Pipes.PipeOptions -&gt; System.IO.Pipes.NamedPipeServerStream" Usage="new System.IO.Pipes.NamedPipeServerStream (pipeName, direction, maxNumberOfServerInstances, transmissionMode, options)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="pipeName" Type="System.String" />
        <Parameter Name="direction" Type="System.IO.Pipes.PipeDirection" />
        <Parameter Name="maxNumberOfServerInstances" Type="System.Int32" />
        <Parameter Name="transmissionMode" Type="System.IO.Pipes.PipeTransmissionMode" />
        <Parameter Name="options" Type="System.IO.Pipes.PipeOptions" />
      </Parameters>
      <Docs>
        <param name="pipeName">管道的名称。</param>
        <param name="direction">确定管道方向的枚举值之一。</param>
        <param name="maxNumberOfServerInstances">共享同一名称的服务器实例的最大数量。 可以为此值传递 <see cref="F:System.IO.Pipes.NamedPipeServerStream.MaxAllowedServerInstances" />。</param>
        <param name="transmissionMode">确定管道传输模式的枚举值之一。</param>
        <param name="options">确定如何打开或创建管道的枚举值之一。</param>
        <summary>使用指定的管道名称、管道方向、最大数量的服务器实例、传输模式和管道选项初始化 <see cref="T:System.IO.Pipes.NamedPipeServerStream" /> 类的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此构造函数创建<xref:System.IO.Pipes.NamedPipeServerStream>对象，它具有以下特征：  
  
-   默认输入和输出缓冲区大小。  
  
-   没有管道安全性。  
  
-   一个 <xref:System.IO.HandleInheritability.None> 的 <xref:System.IO.HandleInheritability> 值。  
  
-   未指定其他<xref:System.IO.Pipes.PipeAccessRights>。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="pipeName" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="pipeName" /> 是一个长度为零的字符串。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="pipeName" /> 设置为“匿名”。  
  
或 
 <paramref name="direction" /> 不是有效的 <see cref="T:System.IO.Pipes.PipeDirection" /> 值。  
  
或 
 <paramref name="maxNumberofServerInstances" /> 小于 -1 或大于 254（-1 指示 <see cref="F:System.IO.Pipes.NamedPipeServerStream.MaxAllowedServerInstances" />） 
或 
 <paramref name="options" /> 不是有效的 <see cref="T:System.IO.Pipes.PipeOptions" /> 值。</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="pipeName" /> 包含一个冒号 (":")。</exception>
        <exception cref="T:System.PlatformNotSupportedException">操作系统是不受支持的 Windows Millennium Edition、Windows 98 或 Windows 95。</exception>
        <exception cref="T:System.IO.IOException">已超出服务器实例的最大数量。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.Demand">对于直接调用方的完全信任。 此成员不能由部分信任的代码使用。</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public NamedPipeServerStream (string pipeName, System.IO.Pipes.PipeDirection direction, int maxNumberOfServerInstances, System.IO.Pipes.PipeTransmissionMode transmissionMode, System.IO.Pipes.PipeOptions options, int inBufferSize, int outBufferSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string pipeName, valuetype System.IO.Pipes.PipeDirection direction, int32 maxNumberOfServerInstances, valuetype System.IO.Pipes.PipeTransmissionMode transmissionMode, valuetype System.IO.Pipes.PipeOptions options, int32 inBufferSize, int32 outBufferSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Pipes.NamedPipeServerStream.#ctor(System.String,System.IO.Pipes.PipeDirection,System.Int32,System.IO.Pipes.PipeTransmissionMode,System.IO.Pipes.PipeOptions,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (pipeName As String, direction As PipeDirection, maxNumberOfServerInstances As Integer, transmissionMode As PipeTransmissionMode, options As PipeOptions, inBufferSize As Integer, outBufferSize As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; NamedPipeServerStream(System::String ^ pipeName, System::IO::Pipes::PipeDirection direction, int maxNumberOfServerInstances, System::IO::Pipes::PipeTransmissionMode transmissionMode, System::IO::Pipes::PipeOptions options, int inBufferSize, int outBufferSize);" />
      <MemberSignature Language="F#" Value="new System.IO.Pipes.NamedPipeServerStream : string * System.IO.Pipes.PipeDirection * int * System.IO.Pipes.PipeTransmissionMode * System.IO.Pipes.PipeOptions * int * int -&gt; System.IO.Pipes.NamedPipeServerStream" Usage="new System.IO.Pipes.NamedPipeServerStream (pipeName, direction, maxNumberOfServerInstances, transmissionMode, options, inBufferSize, outBufferSize)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="pipeName" Type="System.String" />
        <Parameter Name="direction" Type="System.IO.Pipes.PipeDirection" />
        <Parameter Name="maxNumberOfServerInstances" Type="System.Int32" />
        <Parameter Name="transmissionMode" Type="System.IO.Pipes.PipeTransmissionMode" />
        <Parameter Name="options" Type="System.IO.Pipes.PipeOptions" />
        <Parameter Name="inBufferSize" Type="System.Int32" />
        <Parameter Name="outBufferSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="pipeName">管道的名称。</param>
        <param name="direction">确定管道方向的枚举值之一。</param>
        <param name="maxNumberOfServerInstances">共享同一名称的服务器实例的最大数量。 可以为此值传递 <see cref="F:System.IO.Pipes.NamedPipeServerStream.MaxAllowedServerInstances" />。</param>
        <param name="transmissionMode">确定管道传输模式的枚举值之一。</param>
        <param name="options">确定如何打开或创建管道的枚举值之一。</param>
        <param name="inBufferSize">一个大于 0 的正值，指示输入缓冲区大小。</param>
        <param name="outBufferSize">一个大于 0 的正值，指示输出缓冲区大小。</param>
        <summary>使用指定的管道名称、管道方向、最大数量的服务器实例、传输模式、管道选项和建议的输入输出缓冲区大小初始化 <see cref="T:System.IO.Pipes.NamedPipeServerStream" /> 类的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此构造函数创建<xref:System.IO.Pipes.NamedPipeServerStream>对象，它具有以下特征：  
  
-   没有其他管道安全性。  
  
-   默认值<xref:System.IO.HandleInheritability>的值<xref:System.IO.HandleInheritability.None>。  
  
-   未指定其他<xref:System.IO.Pipes.PipeAccessRights>。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="pipeName" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="pipeName" /> 是一个长度为零的字符串。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="pipeName" /> 设置为“匿名”。  
  
或 
 <paramref name="direction" /> 不是有效的 <see cref="T:System.IO.Pipes.PipeDirection" /> 值。  
  
或 
 <paramref name="maxNumberofServerInstances" /> 小于 -1 或大于 254（-1 指示 <see cref="F:System.IO.Pipes.NamedPipeServerStream.MaxAllowedServerInstances" />） 
或 
 <paramref name="options" /> 不是有效的 <see cref="T:System.IO.Pipes.PipeOptions" /> 值。  
  
或 
 <paramref name="inBufferSize" /> 为负数。</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="pipeName" /> 包含一个冒号 (":")。</exception>
        <exception cref="T:System.PlatformNotSupportedException">操作系统是不受支持的 Windows Millennium Edition、Windows 98 或 Windows 95。</exception>
        <exception cref="T:System.IO.IOException">已超出服务器实例的最大数量。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.Demand">对于直接调用方的完全信任。 此成员不能由部分信任的代码使用。</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public NamedPipeServerStream (string pipeName, System.IO.Pipes.PipeDirection direction, int maxNumberOfServerInstances, System.IO.Pipes.PipeTransmissionMode transmissionMode, System.IO.Pipes.PipeOptions options, int inBufferSize, int outBufferSize, System.IO.Pipes.PipeSecurity pipeSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string pipeName, valuetype System.IO.Pipes.PipeDirection direction, int32 maxNumberOfServerInstances, valuetype System.IO.Pipes.PipeTransmissionMode transmissionMode, valuetype System.IO.Pipes.PipeOptions options, int32 inBufferSize, int32 outBufferSize, class System.IO.Pipes.PipeSecurity pipeSecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Pipes.NamedPipeServerStream.#ctor(System.String,System.IO.Pipes.PipeDirection,System.Int32,System.IO.Pipes.PipeTransmissionMode,System.IO.Pipes.PipeOptions,System.Int32,System.Int32,System.IO.Pipes.PipeSecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; NamedPipeServerStream(System::String ^ pipeName, System::IO::Pipes::PipeDirection direction, int maxNumberOfServerInstances, System::IO::Pipes::PipeTransmissionMode transmissionMode, System::IO::Pipes::PipeOptions options, int inBufferSize, int outBufferSize, System::IO::Pipes::PipeSecurity ^ pipeSecurity);" />
      <MemberSignature Language="F#" Value="new System.IO.Pipes.NamedPipeServerStream : string * System.IO.Pipes.PipeDirection * int * System.IO.Pipes.PipeTransmissionMode * System.IO.Pipes.PipeOptions * int * int * System.IO.Pipes.PipeSecurity -&gt; System.IO.Pipes.NamedPipeServerStream" Usage="new System.IO.Pipes.NamedPipeServerStream (pipeName, direction, maxNumberOfServerInstances, transmissionMode, options, inBufferSize, outBufferSize, pipeSecurity)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="pipeName" Type="System.String" />
        <Parameter Name="direction" Type="System.IO.Pipes.PipeDirection" />
        <Parameter Name="maxNumberOfServerInstances" Type="System.Int32" />
        <Parameter Name="transmissionMode" Type="System.IO.Pipes.PipeTransmissionMode" />
        <Parameter Name="options" Type="System.IO.Pipes.PipeOptions" />
        <Parameter Name="inBufferSize" Type="System.Int32" />
        <Parameter Name="outBufferSize" Type="System.Int32" />
        <Parameter Name="pipeSecurity" Type="System.IO.Pipes.PipeSecurity" />
      </Parameters>
      <Docs>
        <param name="pipeName">管道的名称。</param>
        <param name="direction">确定管道方向的枚举值之一。</param>
        <param name="maxNumberOfServerInstances">共享同一名称的服务器实例的最大数量。 可以为此值传递 <see cref="F:System.IO.Pipes.NamedPipeServerStream.MaxAllowedServerInstances" />。</param>
        <param name="transmissionMode">确定管道传输模式的枚举值之一。</param>
        <param name="options">确定如何打开或创建管道的枚举值之一。</param>
        <param name="inBufferSize">一个大于 0 的正值，指示输入缓冲区大小。</param>
        <param name="outBufferSize">一个大于 0 的正值，指示输出缓冲区大小。</param>
        <param name="pipeSecurity">一个对象，确定管道的访问控制和审核安全性。</param>
        <summary>使用指定的管道名称、管道方向、最大数量的服务器实例、传输模式、管道选项、建议的输入输出缓冲区大小和管道安全性初始化 <see cref="T:System.IO.Pipes.NamedPipeServerStream" /> 类的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此构造函数创建<xref:System.IO.Pipes.NamedPipeServerStream>对象，它具有以下特征：  
  
-   默认值<xref:System.IO.HandleInheritability>的值<xref:System.IO.HandleInheritability.None>。  
  
-   未指定其他<xref:System.IO.Pipes.PipeAccessRights>。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="pipeName" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="pipeName" /> 是一个长度为零的字符串。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="pipeName" /> 设置为“匿名”。  
  
或 
 <paramref name="direction" /> 不是有效的 <see cref="T:System.IO.Pipes.PipeDirection" /> 值。  
  
或 
 <paramref name="maxNumberofServerInstances" /> 小于 -1 或大于 254（-1 指示 <see cref="F:System.IO.Pipes.NamedPipeServerStream.MaxAllowedServerInstances" />） 
或 
 <paramref name="options" /> 不是有效的 <see cref="T:System.IO.Pipes.PipeOptions" /> 值。  
  
或 
 <paramref name="inBufferSize" /> 为负数。</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="pipeName" /> 包含一个冒号 (":")。</exception>
        <exception cref="T:System.PlatformNotSupportedException">操作系统是不受支持的 Windows Millennium Edition、Windows 98 或 Windows 95。</exception>
        <exception cref="T:System.IO.IOException">已超出服务器实例的最大数量。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.Demand">对于直接调用方的完全信任。 此成员不能由部分信任的代码使用。</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public NamedPipeServerStream (string pipeName, System.IO.Pipes.PipeDirection direction, int maxNumberOfServerInstances, System.IO.Pipes.PipeTransmissionMode transmissionMode, System.IO.Pipes.PipeOptions options, int inBufferSize, int outBufferSize, System.IO.Pipes.PipeSecurity pipeSecurity, System.IO.HandleInheritability inheritability);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string pipeName, valuetype System.IO.Pipes.PipeDirection direction, int32 maxNumberOfServerInstances, valuetype System.IO.Pipes.PipeTransmissionMode transmissionMode, valuetype System.IO.Pipes.PipeOptions options, int32 inBufferSize, int32 outBufferSize, class System.IO.Pipes.PipeSecurity pipeSecurity, valuetype System.IO.HandleInheritability inheritability) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Pipes.NamedPipeServerStream.#ctor(System.String,System.IO.Pipes.PipeDirection,System.Int32,System.IO.Pipes.PipeTransmissionMode,System.IO.Pipes.PipeOptions,System.Int32,System.Int32,System.IO.Pipes.PipeSecurity,System.IO.HandleInheritability)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; NamedPipeServerStream(System::String ^ pipeName, System::IO::Pipes::PipeDirection direction, int maxNumberOfServerInstances, System::IO::Pipes::PipeTransmissionMode transmissionMode, System::IO::Pipes::PipeOptions options, int inBufferSize, int outBufferSize, System::IO::Pipes::PipeSecurity ^ pipeSecurity, System::IO::HandleInheritability inheritability);" />
      <MemberSignature Language="F#" Value="new System.IO.Pipes.NamedPipeServerStream : string * System.IO.Pipes.PipeDirection * int * System.IO.Pipes.PipeTransmissionMode * System.IO.Pipes.PipeOptions * int * int * System.IO.Pipes.PipeSecurity * System.IO.HandleInheritability -&gt; System.IO.Pipes.NamedPipeServerStream" Usage="new System.IO.Pipes.NamedPipeServerStream (pipeName, direction, maxNumberOfServerInstances, transmissionMode, options, inBufferSize, outBufferSize, pipeSecurity, inheritability)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="pipeName" Type="System.String" />
        <Parameter Name="direction" Type="System.IO.Pipes.PipeDirection" />
        <Parameter Name="maxNumberOfServerInstances" Type="System.Int32" />
        <Parameter Name="transmissionMode" Type="System.IO.Pipes.PipeTransmissionMode" />
        <Parameter Name="options" Type="System.IO.Pipes.PipeOptions" />
        <Parameter Name="inBufferSize" Type="System.Int32" />
        <Parameter Name="outBufferSize" Type="System.Int32" />
        <Parameter Name="pipeSecurity" Type="System.IO.Pipes.PipeSecurity" />
        <Parameter Name="inheritability" Type="System.IO.HandleInheritability" />
      </Parameters>
      <Docs>
        <param name="pipeName">管道的名称。</param>
        <param name="direction">确定管道方向的枚举值之一。</param>
        <param name="maxNumberOfServerInstances">共享同一名称的服务器实例的最大数量。 可以为此值传递 <see cref="F:System.IO.Pipes.NamedPipeServerStream.MaxAllowedServerInstances" />。</param>
        <param name="transmissionMode">确定管道传输模式的枚举值之一。</param>
        <param name="options">确定如何打开或创建管道的枚举值之一。</param>
        <param name="inBufferSize">一个大于 0 的正值，指示输入缓冲区大小。</param>
        <param name="outBufferSize">一个大于 0 的正值，指示输出缓冲区大小。</param>
        <param name="pipeSecurity">一个对象，确定管道的访问控制和审核安全性。</param>
        <param name="inheritability">确定基础句柄能否由子进程继承的枚举值之一。</param>
        <summary>使用指定的管道名称、管道方向、最大数量的服务器实例、传输模式、管道选项、建议的输入输出缓冲区大小、管道安全性和继承模式初始化 <see cref="T:System.IO.Pipes.NamedPipeServerStream" /> 类的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此构造函数创建<xref:System.IO.Pipes.NamedPipeServerStream>对象，它不具有指定的附加<xref:System.IO.Pipes.PipeAccessRights>。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="pipeName" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="pipeName" /> 是一个长度为零的字符串。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="pipeName" /> 设置为“匿名”。  
  
或 
 <paramref name="direction" /> 不是有效的 <see cref="T:System.IO.Pipes.PipeDirection" /> 值。  
  
或 
 <paramref name="maxNumberofServerInstances" /> 小于 -1 或大于 254（-1 指示 <see cref="F:System.IO.Pipes.NamedPipeServerStream.MaxAllowedServerInstances" />） 
或 
 <paramref name="options" /> 不是有效的 <see cref="T:System.IO.Pipes.PipeOptions" /> 值。  
  
或 
 <paramref name="inBufferSize" /> 为负数。  
  
或 
 <paramref name="inheritability" /> 不是有效的 <see cref="T:System.IO.HandleInheritability" /> 值。</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="pipeName" /> 包含一个冒号 (":")。</exception>
        <exception cref="T:System.PlatformNotSupportedException">操作系统是不受支持的 Windows Millennium Edition、Windows 98 或 Windows 95。</exception>
        <exception cref="T:System.IO.IOException">已超出服务器实例的最大数量。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.Demand">对于直接调用方的完全信任。 此成员不能由部分信任的代码使用。</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public NamedPipeServerStream (string pipeName, System.IO.Pipes.PipeDirection direction, int maxNumberOfServerInstances, System.IO.Pipes.PipeTransmissionMode transmissionMode, System.IO.Pipes.PipeOptions options, int inBufferSize, int outBufferSize, System.IO.Pipes.PipeSecurity pipeSecurity, System.IO.HandleInheritability inheritability, System.IO.Pipes.PipeAccessRights additionalAccessRights);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string pipeName, valuetype System.IO.Pipes.PipeDirection direction, int32 maxNumberOfServerInstances, valuetype System.IO.Pipes.PipeTransmissionMode transmissionMode, valuetype System.IO.Pipes.PipeOptions options, int32 inBufferSize, int32 outBufferSize, class System.IO.Pipes.PipeSecurity pipeSecurity, valuetype System.IO.HandleInheritability inheritability, valuetype System.IO.Pipes.PipeAccessRights additionalAccessRights) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Pipes.NamedPipeServerStream.#ctor(System.String,System.IO.Pipes.PipeDirection,System.Int32,System.IO.Pipes.PipeTransmissionMode,System.IO.Pipes.PipeOptions,System.Int32,System.Int32,System.IO.Pipes.PipeSecurity,System.IO.HandleInheritability,System.IO.Pipes.PipeAccessRights)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; NamedPipeServerStream(System::String ^ pipeName, System::IO::Pipes::PipeDirection direction, int maxNumberOfServerInstances, System::IO::Pipes::PipeTransmissionMode transmissionMode, System::IO::Pipes::PipeOptions options, int inBufferSize, int outBufferSize, System::IO::Pipes::PipeSecurity ^ pipeSecurity, System::IO::HandleInheritability inheritability, System::IO::Pipes::PipeAccessRights additionalAccessRights);" />
      <MemberSignature Language="F#" Value="new System.IO.Pipes.NamedPipeServerStream : string * System.IO.Pipes.PipeDirection * int * System.IO.Pipes.PipeTransmissionMode * System.IO.Pipes.PipeOptions * int * int * System.IO.Pipes.PipeSecurity * System.IO.HandleInheritability * System.IO.Pipes.PipeAccessRights -&gt; System.IO.Pipes.NamedPipeServerStream" Usage="new System.IO.Pipes.NamedPipeServerStream (pipeName, direction, maxNumberOfServerInstances, transmissionMode, options, inBufferSize, outBufferSize, pipeSecurity, inheritability, additionalAccessRights)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.5;netframework-4.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="pipeName" Type="System.String" />
        <Parameter Name="direction" Type="System.IO.Pipes.PipeDirection" />
        <Parameter Name="maxNumberOfServerInstances" Type="System.Int32" />
        <Parameter Name="transmissionMode" Type="System.IO.Pipes.PipeTransmissionMode" />
        <Parameter Name="options" Type="System.IO.Pipes.PipeOptions" />
        <Parameter Name="inBufferSize" Type="System.Int32" />
        <Parameter Name="outBufferSize" Type="System.Int32" />
        <Parameter Name="pipeSecurity" Type="System.IO.Pipes.PipeSecurity" />
        <Parameter Name="inheritability" Type="System.IO.HandleInheritability" />
        <Parameter Name="additionalAccessRights" Type="System.IO.Pipes.PipeAccessRights" />
      </Parameters>
      <Docs>
        <param name="pipeName">管道的名称。</param>
        <param name="direction">确定管道方向的枚举值之一。</param>
        <param name="maxNumberOfServerInstances">共享同一名称的服务器实例的最大数量。 可以为此值传递 <see cref="F:System.IO.Pipes.NamedPipeServerStream.MaxAllowedServerInstances" />。</param>
        <param name="transmissionMode">确定管道传输模式的枚举值之一。</param>
        <param name="options">确定如何打开或创建管道的枚举值之一。</param>
        <param name="inBufferSize">输入缓冲区大小。</param>
        <param name="outBufferSize">输出缓冲区大小。</param>
        <param name="pipeSecurity">一个对象，确定管道的访问控制和审核安全性。</param>
        <param name="inheritability">确定基础句柄能否由子进程继承的枚举值之一。</param>
        <param name="additionalAccessRights">枚举值之一，指定管道的访问权限。</param>
        <summary>使用指定的管道名称、管道方向、最大数量的服务器实例、传输模式、管道选项、建议的输入输出缓冲区大小、管道安全性、继承模式和管道访问权限初始化 <see cref="T:System.IO.Pipes.NamedPipeServerStream" /> 类的新实例。</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="pipeName" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="pipeName" /> 是一个长度为零的字符串。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="pipeName" /> 设置为“匿名”。  
  
或 
 <paramref name="direction" /> 不是有效的 <see cref="T:System.IO.Pipes.PipeDirection" /> 值。  
  
或 
 <paramref name="maxNumberofServerInstances" /> 小于 -1 或大于 254（-1 指示 <see cref="F:System.IO.Pipes.NamedPipeServerStream.MaxAllowedServerInstances" />） 
或 
 <paramref name="options" /> 不是有效的 <see cref="T:System.IO.Pipes.PipeOptions" /> 值。  
  
或 
 <paramref name="inBufferSize" /> 为负数。  
  
或 
 <paramref name="inheritability" /> 不是有效的 <see cref="T:System.IO.HandleInheritability" /> 值。  
  
或 
 <paramref name="additionalAccessRights" /> 不是有效的 <see cref="T:System.IO.Pipes.PipeAccessRights" /> 值。</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="pipeName" /> 包含一个冒号 (":")。</exception>
        <exception cref="T:System.PlatformNotSupportedException">操作系统是不受支持的 Windows Millennium Edition、Windows 98 或 Windows 95。</exception>
        <exception cref="T:System.IO.IOException">已超出服务器实例的最大数量。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.Demand">对于直接调用方的完全信任。 此成员不能由部分信任的代码使用。</permission>
      </Docs>
    </Member>
    <Member MemberName="BeginWaitForConnection">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginWaitForConnection (AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginWaitForConnection(class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Pipes.NamedPipeServerStream.BeginWaitForConnection(System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginWaitForConnection (callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginWaitForConnection(AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginWaitForConnection : AsyncCallback * obj -&gt; IAsyncResult" Usage="namedPipeServerStream.BeginWaitForConnection (callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="callback">客户端连接到 <see cref="T:System.IO.Pipes.NamedPipeServerStream" /> 对象时调用的方法。</param>
        <param name="state">一个用户提供的对象，它将该特定的异步请求与其他请求区别开来。</param>
        <summary>开始异步操作以等待客户端建立连接。</summary>
        <returns>一个引用该异步请求的对象。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 这是异步等效项<xref:System.IO.Pipes.NamedPipeServerStream.WaitForConnection%2A>。  
  
 <xref:System.IO.Pipes.NamedPipeServerStream.EndWaitForConnection%2A> 必须为每个调用一次调用<xref:System.IO.Pipes.NamedPipeServerStream.BeginWaitForConnection%2A>。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">管道未异步打开。  
  
或 
已建立管道连接。  
  
或 
尚未设置管道句柄。</exception>
        <exception cref="T:System.IO.IOException">管道连接已中断。</exception>
        <exception cref="T:System.ObjectDisposedException">管道已关闭。</exception>
      </Docs>
    </Member>
    <Member MemberName="Disconnect">
      <MemberSignature Language="C#" Value="public void Disconnect ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Disconnect() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Pipes.NamedPipeServerStream.Disconnect" />
      <MemberSignature Language="VB.NET" Value="Public Sub Disconnect ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Disconnect();" />
      <MemberSignature Language="F#" Value="member this.Disconnect : unit -&gt; unit" Usage="namedPipeServerStream.Disconnect " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>断开当前连接。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 调用<xref:System.IO.Pipes.NamedPipeServerStream.Disconnect%2A>方法会阻塞，直到所有已发送的字符都已读取，除非将管道的传输模式设置为<xref:System.IO.Pipes.PipeTransmissionMode.Message>中创建的构造函数设置缓冲区大小和<xref:System.IO.Pipes.NamedPipeServerStream>对象。 在这种情况下，将接收不是所有的消息。 调用<xref:System.IO.Pipes.PipeStream.WaitForPipeDrain%2A>会导致服务器进行阻止，直到从管道读取所有数据。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">尚未建立管道连接。  
  
或 
连接的管道已断开。  
  
或 
尚未设置管道句柄。</exception>
        <exception cref="T:System.ObjectDisposedException">管道已关闭。</exception>
      </Docs>
    </Member>
    <Member MemberName="EndWaitForConnection">
      <MemberSignature Language="C#" Value="public void EndWaitForConnection (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EndWaitForConnection(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Pipes.NamedPipeServerStream.EndWaitForConnection(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndWaitForConnection (asyncResult As IAsyncResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EndWaitForConnection(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="member this.EndWaitForConnection : IAsyncResult -&gt; unit" Usage="namedPipeServerStream.EndWaitForConnection asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">挂起的异步请求。</param>
        <summary>结束异步操作以等待客户端建立连接。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Pipes.NamedPipeServerStream.EndWaitForConnection%2A> 必须为每个调用一次调用<xref:System.IO.Pipes.NamedPipeServerStream.BeginWaitForConnection%2A>。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="asyncResult" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">管道未异步打开。  
  
或 
尚未设置管道句柄。</exception>
        <exception cref="T:System.IO.IOException">管道连接已中断。</exception>
        <exception cref="T:System.ObjectDisposedException">管道已关闭。</exception>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~NamedPipeServerStream ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Pipes.NamedPipeServerStream.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!NamedPipeServerStream ()" />
      <MemberSignature Language="F#" Value="override this.Finalize : unit -&gt; unit" Usage="namedPipeServerStream.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>在通过垃圾回收将 <see cref="T:System.IO.Pipes.NamedPipeServerStream" /> 实例回收之前，释放非托管资源并执行其他清理操作。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetImpersonationUserName">
      <MemberSignature Language="C#" Value="public string GetImpersonationUserName ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetImpersonationUserName() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Pipes.NamedPipeServerStream.GetImpersonationUserName" />
      <MemberSignature Language="VB.NET" Value="Public Function GetImpersonationUserName () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetImpersonationUserName();" />
      <MemberSignature Language="F#" Value="member this.GetImpersonationUserName : unit -&gt; string" Usage="namedPipeServerStream.GetImpersonationUserName " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>获取管道另一端的客户端用户名。</summary>
        <returns>管道另一端的客户端用户名。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Pipes.NamedPipeServerStream.GetImpersonationUserName%2A>方法将返回`null`如果客户端但尚未写入管道，或连接的客户端未与连接<xref:System.Security.Principal.TokenImpersonationLevel>的<xref:System.Security.Principal.TokenImpersonationLevel.Impersonation>。  
  
   
  
## Examples  
 下面的示例演示一个方法来创建多个同时进行的客户端请求，可响应的管道服务器和客户端模拟的方法。 此示例将创建<xref:System.IO.Pipes.NamedPipeServerStream>对象中父进程，然后创建多个线程等待<xref:System.IO.Pipes.NamedPipeClientStream>要连接的对象。 客户端连接后，它会提供到服务器的文件名称，该文件的内容是读取和发送回客户端。 因为<xref:System.IO.Pipes.NamedPipeServerStream>模拟客户端打开文件时，客户端可以请求只有文件其具有足够的权限打开。  
  
 [!code-cpp[System.IO.Pipes.NamedPipeServerStream_ImpersonationSample1#01](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Pipes.NamedPipeServerStream_ImpersonationSample1/cpp/program.cpp#01)]
 [!code-csharp[System.IO.Pipes.NamedPipeServerStream_ImpersonationSample1#01](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Pipes.NamedPipeServerStream_ImpersonationSample1/cs/Program.cs#01)]
 [!code-vb[System.IO.Pipes.NamedPipeServerStream_ImpersonationSample1#01](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Pipes.NamedPipeServerStream_ImpersonationSample1/vb/program.vb#01)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">尚未建立管道连接。  
  
或 
连接的管道已断开。  
  
或 
尚未设置管道句柄。</exception>
        <exception cref="T:System.ObjectDisposedException">管道已关闭。</exception>
        <exception cref="T:System.IO.IOException">管道连接已中断。  
  
或 
客户端用户名的长度超过了 19 个字符。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermissionFlag">它能够操作主体对象。 安全操作： <see cref="F:System.Security.Permissions.SecurityAction.Demand" />。 关联的枚举： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPrincipal" /></permission>
      </Docs>
    </Member>
    <Member MemberName="MaxAllowedServerInstances">
      <MemberSignature Language="C#" Value="public const int MaxAllowedServerInstances = -1;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal int32 MaxAllowedServerInstances = (-1)" />
      <MemberSignature Language="DocId" Value="F:System.IO.Pipes.NamedPipeServerStream.MaxAllowedServerInstances" />
      <MemberSignature Language="VB.NET" Value="Public Const MaxAllowedServerInstances As Integer  = -1" />
      <MemberSignature Language="C++ CLI" Value="public: int MaxAllowedServerInstances = -1;" />
      <MemberSignature Language="F#" Value="val mutable MaxAllowedServerInstances : int" Usage="System.IO.Pipes.NamedPipeServerStream.MaxAllowedServerInstances" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <MemberValue>-1</MemberValue>
      <Docs>
        <summary>表示系统资源允许的服务器实例的最大数量。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用<xref:System.IO.Pipes.NamedPipeServerStream.MaxAllowedServerInstances>创建时<xref:System.IO.Pipes.NamedPipeServerStream>对象来设置的系统资源允许的服务器实例的最大数目。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RunAsClient">
      <MemberSignature Language="C#" Value="public void RunAsClient (System.IO.Pipes.PipeStreamImpersonationWorker impersonationWorker);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RunAsClient(class System.IO.Pipes.PipeStreamImpersonationWorker impersonationWorker) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Pipes.NamedPipeServerStream.RunAsClient(System.IO.Pipes.PipeStreamImpersonationWorker)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RunAsClient (impersonationWorker As PipeStreamImpersonationWorker)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RunAsClient(System::IO::Pipes::PipeStreamImpersonationWorker ^ impersonationWorker);" />
      <MemberSignature Language="F#" Value="member this.RunAsClient : System.IO.Pipes.PipeStreamImpersonationWorker -&gt; unit" Usage="namedPipeServerStream.RunAsClient impersonationWorker" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="impersonationWorker" Type="System.IO.Pipes.PipeStreamImpersonationWorker" />
      </Parameters>
      <Docs>
        <param name="impersonationWorker">指定要调用的方法的委托。</param>
        <summary>模拟客户端时调用委托。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 连接客户端的权限应用于远程服务器。 例如，如果连接的客户端尝试请求服务器上的文件的内容时，客户端可以请求具有足够的权限打开的文件。  
  
   
  
## Examples  
 下面的示例演示一个方法来创建多个同时进行的客户端请求，可响应的管道服务器和客户端模拟的方法。 此示例将创建<xref:System.IO.Pipes.NamedPipeServerStream>对象中父进程，然后创建多个线程等待<xref:System.IO.Pipes.NamedPipeClientStream>要连接的对象。 客户端连接后，它会提供到服务器的文件名称，该文件的内容是读取和发送回客户端。 因为<xref:System.IO.Pipes.NamedPipeServerStream>模拟客户端打开文件时，客户端可以请求只有文件其具有足够的权限打开。  
  
 [!code-cpp[System.IO.Pipes.NamedPipeServerStream_ImpersonationSample1#01](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Pipes.NamedPipeServerStream_ImpersonationSample1/cpp/program.cpp#01)]
 [!code-csharp[System.IO.Pipes.NamedPipeServerStream_ImpersonationSample1#01](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Pipes.NamedPipeServerStream_ImpersonationSample1/cs/Program.cs#01)]
 [!code-vb[System.IO.Pipes.NamedPipeServerStream_ImpersonationSample1#01](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Pipes.NamedPipeServerStream_ImpersonationSample1/vb/program.vb#01)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">尚未建立管道连接。  
  
或 
连接的管道已断开。  
  
或 
尚未设置管道句柄。</exception>
        <exception cref="T:System.ObjectDisposedException">管道已关闭。</exception>
        <exception cref="T:System.IO.IOException">管道连接已中断。  
  
或 
出现 I/O 错误。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermissionFlag">它能够操作主体对象。 安全操作： <see cref="F:System.Security.Permissions.SecurityAction.Demand" />。 关联的枚举： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPrincipal" /></permission>
      </Docs>
    </Member>
    <Member MemberName="WaitForConnection">
      <MemberSignature Language="C#" Value="public void WaitForConnection ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WaitForConnection() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Pipes.NamedPipeServerStream.WaitForConnection" />
      <MemberSignature Language="VB.NET" Value="Public Sub WaitForConnection ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WaitForConnection();" />
      <MemberSignature Language="F#" Value="member this.WaitForConnection : unit -&gt; unit" Usage="namedPipeServerStream.WaitForConnection " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>等待客户端连接到该 <see cref="T:System.IO.Pipes.NamedPipeServerStream" /> 对象。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 调用此方法会导致<xref:System.IO.Pipes.NamedPipeServerStream>对象进行阻止，直到客户端连接。  
  
   
  
## Examples  
 下面的示例演示如何将字符串从父进程发送到子进程，使用命名管道的方法。 此示例将创建<xref:System.IO.Pipes.NamedPipeServerStream>父进程中的对象。 此对象是否有<xref:System.IO.Pipes.PipeDirection>的值<xref:System.IO.Pipes.PipeDirection.Out>，然后进行阻止，直到<xref:System.IO.Pipes.NamedPipeClientStream>对象建立与<xref:System.IO.Pipes.NamedPipeServerStream>对象。 此示例摘自一个更大的示例为提供<xref:System.IO.Pipes.NamedPipeServerStream>和<xref:System.IO.Pipes.NamedPipeClientStream>类。  
  
 [!code-csharp[System.IO.Pipes.NamedPipeServerStream_Sample1#01](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Pipes.NamedPipeServerStream_Sample1/cs/Program.cs#01)]
 [!code-vb[System.IO.Pipes.NamedPipeServerStream_Sample1#01](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Pipes.NamedPipeServerStream_Sample1/vb/program.vb#01)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">已建立管道连接。  
  
或 
尚未设置管道句柄。</exception>
        <exception cref="T:System.ObjectDisposedException">管道已关闭。</exception>
        <exception cref="T:System.IO.IOException">管道连接已中断。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitForConnectionAsync">
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>异步等待客户端连接到该 <see cref="T:System.IO.Pipes.NamedPipeServerStream" /> 对象。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitForConnectionAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task WaitForConnectionAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task WaitForConnectionAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Pipes.NamedPipeServerStream.WaitForConnectionAsync" />
      <MemberSignature Language="VB.NET" Value="Public Function WaitForConnectionAsync () As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ WaitForConnectionAsync();" />
      <MemberSignature Language="F#" Value="member this.WaitForConnectionAsync : unit -&gt; System.Threading.Tasks.Task" Usage="namedPipeServerStream.WaitForConnectionAsync " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>异步等待客户端连接到该 <see cref="T:System.IO.Pipes.NamedPipeServerStream" /> 对象。</summary>
        <returns>表示异步等待操作的任务。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 因为它是异步的此方法将立即返回，但在连接过程完成时，客户端调用<xref:System.IO.Pipes.NamedPipeClientStream.Connect%2A>或<xref:System.IO.Pipes.NamedPipeClientStream.ConnectAsync%2A>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WaitForConnectionAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task WaitForConnectionAsync (System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task WaitForConnectionAsync(valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Pipes.NamedPipeServerStream.WaitForConnectionAsync(System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ WaitForConnectionAsync(System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="member this.WaitForConnectionAsync : System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="namedPipeServerStream.WaitForConnectionAsync cancellationToken" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="cancellationToken">要监视取消请求的标记。</param>
        <summary>异步等待客户端连接到该 <see cref="T:System.IO.Pipes.NamedPipeServerStream" /> 对象并监视取消请求。</summary>
        <returns>表示异步等待操作的任务。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 因为它是异步的此方法将立即返回，但在连接过程完成时，客户端调用<xref:System.IO.Pipes.NamedPipeClientStream.Connect%2A>或<xref:System.IO.Pipes.NamedPipeClientStream.ConnectAsync%2A>。  
  
 取消请求使用取消标记才起作用<xref:System.IO.Pipes.NamedPipeServerStream>对象创建管道选项值为<xref:System.IO.Pipes.PipeOptions.Asynchronous?displayProperty=nameWithType>或者如果取消发生之前<xref:System.IO.Pipes.NamedPipeServerStream.WaitForConnectionAsync%2A>调用方法。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>