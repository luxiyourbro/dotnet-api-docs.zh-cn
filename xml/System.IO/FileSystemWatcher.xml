<Type Name="FileSystemWatcher" FullName="System.IO.FileSystemWatcher">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="a9ac0c5d96c95a9574125fb22b9322bd986f8986" />
    <Meta Name="ms.sourcegitcommit" Value="434f60616a9793fa8436744549fc856e94f7a648" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-CN" />
    <Meta Name="ms.lasthandoff" Value="08/25/2018" />
    <Meta Name="ms.locfileid" Value="39983516" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class FileSystemWatcher : System.ComponentModel.Component, System.ComponentModel.ISupportInitialize" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit FileSystemWatcher extends System.ComponentModel.Component implements class System.ComponentModel.ISupportInitialize" />
  <TypeSignature Language="DocId" Value="T:System.IO.FileSystemWatcher" />
  <TypeSignature Language="VB.NET" Value="Public Class FileSystemWatcher&#xA;Inherits Component&#xA;Implements ISupportInitialize" />
  <TypeSignature Language="C++ CLI" Value="public ref class FileSystemWatcher : System::ComponentModel::Component, System::ComponentModel::ISupportInitialize" />
  <TypeSignature Language="F#" Value="type FileSystemWatcher = class&#xA;    inherit Component&#xA;    interface ISupportInitialize" />
  <AssemblyInfo>
    <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-4.5">System.ComponentModel.Component</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ComponentModel.ISupportInitialize</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinmac-3.0">
      <AttributeName>System.ComponentModel.DefaultEvent("Changed")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="xamarinmac-3.0">
      <AttributeName>System.IO.IODescription("")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
      <AttributeName>System.IO.IODescription("FileSystemWatcherDesc")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>侦听文件系统更改通知，并在目录或目录中的文件发生更改时引发事件。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用<xref:System.IO.FileSystemWatcher>要监视的指定目录中的更改。 可监视文件和指定的目录的子目录中的更改。 可以创建一个组件来监视本地计算机、 网络驱动器或远程计算机上的文件。  
  
 若要监视的所有文件中的更改，请设置<xref:System.IO.FileSystemWatcher.Filter%2A>属性为空字符串 ("") 或使用通配符 ("*。\*")。 若要监视特定文件，请设置<xref:System.IO.FileSystemWatcher.Filter%2A>属性设置为的文件的名称。 例如，若要监视的文件 MyDoc.txt 中的更改，请设置<xref:System.IO.FileSystemWatcher.Filter%2A>属性设置为"MyDoc.txt"。 此外可以监视特定类型的文件中的更改。 例如，若要监视的文本文件中的更改，请设置<xref:System.IO.FileSystemWatcher.Filter%2A>属性设置为"\*.txt"。  
  
 有几种类型的可监视的目录或文件中的更改。 例如，可以监视中更改`Attributes`，则`LastWrite`日期和时间，或`Size`的文件或目录。 这是通过设置<xref:System.IO.FileSystemWatcher.NotifyFilter%2A>属性设置为其中一个<xref:System.IO.NotifyFilters>值。 您可以观看上的更改的类型的详细信息，请参阅<xref:System.IO.NotifyFilters>。  
  
 你可以监视重命名，删除或创建文件或目录。 例如，若要监视的重命名的文本文件，请设置<xref:System.IO.FileSystemWatcher.Filter%2A>属性设置为"*.txt"，并调用<xref:System.IO.FileSystemWatcher.WaitForChanged%2A>方法替换<xref:System.IO.WatcherChangeTypes.Renamed>为其参数指定。  
  
 Windows 操作系统会通知您的组件的创建的缓冲区中的文件更改<xref:System.IO.FileSystemWatcher>。 如果在短时间有很多更改，则缓冲区可能溢出。 这会导致组件无法在目录中，更改跟踪并且它将只提供一般性通知。 增加使用的缓冲区的大小<xref:System.IO.FileSystemWatcher.InternalBufferSize%2A>属性开销较大，因为它来自无法换出到磁盘中，所以尚未保持缓冲区尽可能小的非分页内存大足以不会遗漏任何文件更改事件。 若要避免缓冲区溢出，请使用<xref:System.IO.FileSystemWatcher.NotifyFilter%2A>和<xref:System.IO.FileSystemWatcher.IncludeSubdirectories%2A>属性，以便您可以筛选出不需要更改通知。  
  
 有关实例的初始属性值的列表<xref:System.IO.FileSystemWatcher>，请参阅<xref:System.IO.FileSystemWatcher.%23ctor%2A>构造函数。  
  
 使用时，请注意以下<xref:System.IO.FileSystemWatcher>类。  
  
-   不忽略隐藏的文件。  
  
-   在某些系统<xref:System.IO.FileSystemWatcher>报告使用短 8.3 文件名称格式的文件更改。 例如，对"LongFileName.LongExtension"的更改可能被报告为"LongFil ~。Lon"。  
  
-   此类包含一个链接要求和继承要求在类级别应用于所有成员。 一个<xref:System.Security.SecurityException>直接调用方或派生的类没有完全信任权限时引发。 有关安全要求的详细信息，请参阅[链接要求](~/docs/framework/misc/link-demands.md)。  
  
-   可以为设置的最大大小<xref:System.IO.FileSystemWatcher.InternalBufferSize%2A>属性用于在网络上监视目录为 64 KB。  
  
> [!NOTE]
>  运行<xref:System.IO.FileSystemWatcher>不支持在 Windows 98 上。  
  
## <a name="copying-and-moving-folders"></a>复制和移动文件夹  
 操作系统和<xref:System.IO.FileSystemWatcher>对象解释剪切和粘贴操作或作为文件夹及其内容的重命名操作的移动操作。 如果要剪切并粘贴到受监视的文件夹的文件的文件夹<xref:System.IO.FileSystemWatcher>对象报告仅为新的该文件夹，但而非其内容，因为它们实质上只重命名。  
  
 若要得到通知文件夹的内容已移动或复制到受监视的文件夹，请提供<xref:System.IO.FileSystemWatcher.OnChanged%2A>和<xref:System.IO.FileSystemWatcher.OnRenamed%2A>根据下表中的建议事件处理程序方法。  
  
|事件处理程序|处理事件|执行|  
|-------------------|--------------------|--------------|  
|<xref:System.IO.FileSystemWatcher.OnChanged%2A>|<xref:System.IO.FileSystemWatcher.Changed>, <xref:System.IO.FileSystemWatcher.Created>, <xref:System.IO.FileSystemWatcher.Deleted>|报告中的文件属性、 创建的文件和已删除的文件的更改。|  
|<xref:System.IO.FileSystemWatcher.OnRenamed%2A>|<xref:System.IO.FileSystemWatcher.Renamed>|中列出的旧的和新路径的重命名的文件和文件夹，如果需要扩展以递归方式。|  
  
## <a name="events-and-buffer-sizes"></a>事件和缓冲区大小  
 请注意，几个因素可以影响引发哪些文件系统更改事件，如以下所述：  
  
-   常见的文件系统操作可能会引发多个事件。 例如，当文件从一个目录移到另一个、 多个<xref:System.IO.FileSystemWatcher.OnChanged%2A>和某些<xref:System.IO.FileSystemWatcher.OnCreated%2A>和<xref:System.IO.FileSystemWatcher.OnDeleted%2A>可能引发事件。 移动文件由多个简单操作组成的复杂操作，因此会引发多个事件。 同样，某些应用程序 （例如，防病毒软件） 可能会导致检测到的其他文件系统事件<xref:System.IO.FileSystemWatcher>。  
  
-   <xref:System.IO.FileSystemWatcher>可以观看磁盘，只要它们不切换或删除。 <xref:System.IO.FileSystemWatcher>不会引发事件的 Cd 和 Dvd，因为时间戳和属性不能更改。 远程计算机必须有一个安装组件才能正常工作所需平台。  
  
-   如果多个<xref:System.IO.FileSystemWatcher>对象正在监视在 Windows XP Service Pack 1 之前的同一个 UNC 路径或 Windows 2000 SP2 或更早版本，则仅一个对象将引发一个事件。 在计算机上运行 Windows XP SP1 和更高版本，Windows 2000 SP3 或更高版本或 Windows Server 2003 中，所有<xref:System.IO.FileSystemWatcher>对象会引发相应事件。  
  
 请注意，<xref:System.IO.FileSystemWatcher>可能会错过的缓冲区大小超出时发生的事件。 若要避免丢失事件，请遵循以下准则：  
  
-   通过设置增加缓冲区大小<xref:System.IO.FileSystemWatcher.InternalBufferSize%2A>属性。  
  
-   避免监视具有长文件名的文件，因为长文件名可能会导致填满缓冲区。 请考虑重命名这些文件使用较短的名称。  
  
-   使事件处理代码尽可能短。  
  
   
  
## Examples  
 下面的示例创建<xref:System.IO.FileSystemWatcher>监视在运行时指定的目录。 该组件设置为监视中的更改`LastWrite`和`LastAccess`时间、 创建、 删除、 或重命名的目录中的文本文件。 如果文件是更改、 创建，或删除，文件的路径将打印到控制台。 在一个文件重命名后，旧的和新路径将打印到控制台。  
  
 使用<xref:System.Diagnostics>和<xref:System.IO>对于此示例的命名空间。  
  
 [!code-cpp[Classic NotifyFilters Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CPP/source.cpp#1)]
 [!code-csharp[Classic NotifyFilters Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CS/source.cs#1)]
 [!code-vb[Classic NotifyFilters Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic NotifyFilters Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <permission cref="T:System.Security.Permissions.SecurityPermission">从派生<see cref="T:System.Diagnostics.ProcessStartInfo" />类。 要求值： <see cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand" />;命名权限集： <see langword="FullTrust" />。</permission>
    <altmember cref="P:System.IO.FileSystemWatcher.NotifyFilter" />
    <altmember cref="T:System.IO.NotifyFilters" />
    <altmember cref="T:System.IO.FileSystemEventArgs" />
    <altmember cref="T:System.IO.FileSystemEventHandler" />
    <altmember cref="P:System.IO.FileSystemWatcher.Filter" />
    <altmember cref="P:System.IO.FileSystemWatcher.IncludeSubdirectories" />
    <altmember cref="T:System.IO.InternalBufferOverflowException" />
    <altmember cref="T:System.IO.RenamedEventArgs" />
    <altmember cref="T:System.IO.RenamedEventHandler" />
    <altmember cref="T:System.IO.WaitForChangedResult" />
    <altmember cref="T:System.IO.WatcherChangeTypes" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>初始化 <see cref="T:System.IO.FileSystemWatcher" /> 类的新实例。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileSystemWatcher ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileSystemWatcher();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>初始化 <see cref="T:System.IO.FileSystemWatcher" /> 类的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 不能观看不具有 Windows NT 或 Windows 2000 的远程计算机。 不能观看从 Windows NT 4.0 计算机的远程 Windows NT 4.0 计算机。  
  
 下表显示的实例的初始属性值<xref:System.IO.FileSystemWatcher>。  
  
|Property|初始值|  
|--------------|-------------------|  
|<xref:System.IO.FileSystemWatcher.NotifyFilter%2A>|按位 OR 组合`LastWrite`， `FileName`，和 `DirectoryName`|  
|<xref:System.IO.FileSystemWatcher.EnableRaisingEvents%2A>|`false`|  
|<xref:System.IO.FileSystemWatcher.Filter%2A>|"*.\*"（监视所有文件。）|  
|<xref:System.IO.FileSystemWatcher.IncludeSubdirectories%2A>|`false`|  
|<xref:System.IO.FileSystemWatcher.InternalBufferSize%2A>|8192|  
|<xref:System.IO.FileSystemWatcher.Path%2A>|空字符串 ("")|  
  
> [!NOTE]
>  该组件将不监视指定的目录，直到<xref:System.IO.FileSystemWatcher.Path%2A>设置，并<xref:System.IO.FileSystemWatcher.EnableRaisingEvents%2A>是`true`。  
  
   
  
## Examples  
 下面的示例创建<xref:System.IO.FileSystemWatcher>要监视在运行时指定的目录对象。 <xref:System.IO.FileSystemWatcher>对象中的更改会监视`LastWrite`和`LastAccess`时间，以及创建、 删除或重命名的文本目录中的文件。 如果文件是更改、 创建，或删除，将显示在控制台文件的路径。 在一个文件重命名后，旧的和新路径将显示到控制台。  
  
 此示例使用<xref:System.Diagnostics>和<xref:System.IO>命名空间。  
  
 [!code-cpp[Classic NotifyFilters Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CPP/source.cpp#1)]
 [!code-csharp[Classic NotifyFilters Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CS/source.cs#1)]
 [!code-vb[Classic NotifyFilters Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic NotifyFilters Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">对于直接调用方的完全信任。 此成员不能由部分信任的代码使用。</permission>
        <altmember cref="T:System.IO.NotifyFilters" />
        <altmember cref="T:System.IO.FileSystemEventArgs" />
        <altmember cref="T:System.IO.FileSystemEventHandler" />
        <altmember cref="T:System.IO.InternalBufferOverflowException" />
        <altmember cref="P:System.IO.FileSystemWatcher.Path" />
        <altmember cref="T:System.IO.RenamedEventArgs" />
        <altmember cref="T:System.IO.RenamedEventHandler" />
        <altmember cref="T:System.IO.WaitForChangedResult" />
        <altmember cref="T:System.IO.WatcherChangeTypes" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileSystemWatcher (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileSystemWatcher(System::String ^ path);" />
      <MemberSignature Language="F#" Value="new System.IO.FileSystemWatcher : string -&gt; System.IO.FileSystemWatcher" Usage="new System.IO.FileSystemWatcher path" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">要监视的目录，以标准表示法或通用命名约定 (UNC) 表示法表示。</param>
        <summary>在给定要监视的指定目录的情况下，初始化 <see cref="T:System.IO.FileSystemWatcher" /> 类的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  该组件将不监视指定的目录，直到<xref:System.IO.FileSystemWatcher.Path%2A>设置，并<xref:System.IO.FileSystemWatcher.EnableRaisingEvents%2A>是`true`。  
  
 该组件可以监视您的个人计算机、 网络驱动器或远程计算机上的文件。  
  
 不能观看不具有 Windows NT 或 Windows 2000 的远程计算机。 不能观看从 Windows NT 4.0 计算机的远程 Windows NT 4.0 计算机。 <xref:System.IO.FileSystemWatcher.Filter%2A>属性设置默认情况下，若要监视的所有文件。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> 参数为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> 参数为空字符串 ("")。  
  
或 
通过 <paramref name="path" /> 参数指定的路径不存在。</exception>
        <exception cref="T:System.IO.PathTooLongException">
          <paramref name="path" /> 过长。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">对于直接调用方的完全信任。 此成员不能由部分信任的代码使用。</permission>
        <altmember cref="T:System.IO.NotifyFilters" />
        <altmember cref="T:System.IO.FileSystemEventArgs" />
        <altmember cref="T:System.IO.FileSystemEventHandler" />
        <altmember cref="P:System.IO.FileSystemWatcher.Filter" />
        <altmember cref="T:System.IO.InternalBufferOverflowException" />
        <altmember cref="P:System.IO.FileSystemWatcher.Path" />
        <altmember cref="T:System.IO.RenamedEventArgs" />
        <altmember cref="T:System.IO.RenamedEventHandler" />
        <altmember cref="T:System.IO.WaitForChangedResult" />
        <altmember cref="T:System.IO.WatcherChangeTypes" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileSystemWatcher (string path, string filter);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, string filter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.#ctor(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, filter As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileSystemWatcher(System::String ^ path, System::String ^ filter);" />
      <MemberSignature Language="F#" Value="new System.IO.FileSystemWatcher : string * string -&gt; System.IO.FileSystemWatcher" Usage="new System.IO.FileSystemWatcher (path, filter)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="filter" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">要监视的目录，以标准表示法或通用命名约定 (UNC) 表示法表示。</param>
        <param name="filter">要监视的文件的类型。 例如，“*.txt”监视所有文本文件的更改。</param>
        <summary>在给定要监视的指定目录和文件类型的情况下，初始化 <see cref="T:System.IO.FileSystemWatcher" /> 类的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  该组件将不监视指定的目录，直到<xref:System.IO.FileSystemWatcher.Path%2A>设置，并<xref:System.IO.FileSystemWatcher.EnableRaisingEvents%2A>是`true`。  
  
 该组件可以监视您的个人计算机、 网络驱动器或远程计算机上的文件。  
  
 不能观看不具有 Windows NT 或 Windows 2000 的远程计算机。 不能观看从 Windows NT 4.0 计算机的远程 Windows NT 4.0 计算机。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> 参数为 <see langword="null" />。  
  
或 
<paramref name="filter" /> 参数为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> 参数为空字符串 ("")。  
  
或 
通过 <paramref name="path" /> 参数指定的路径不存在。</exception>
        <exception cref="T:System.IO.PathTooLongException">
          <paramref name="path" /> 过长。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">对于直接调用方的完全信任。 此成员不能由部分信任的代码使用。</permission>
        <altmember cref="T:System.IO.NotifyFilters" />
        <altmember cref="T:System.IO.FileSystemEventArgs" />
        <altmember cref="T:System.IO.FileSystemEventHandler" />
        <altmember cref="P:System.IO.FileSystemWatcher.Filter" />
        <altmember cref="T:System.IO.InternalBufferOverflowException" />
        <altmember cref="P:System.IO.FileSystemWatcher.Path" />
        <altmember cref="T:System.IO.RenamedEventArgs" />
        <altmember cref="T:System.IO.RenamedEventHandler" />
        <altmember cref="T:System.IO.WaitForChangedResult" />
        <altmember cref="T:System.IO.WatcherChangeTypes" />
      </Docs>
    </Member>
    <Member MemberName="BeginInit">
      <MemberSignature Language="C#" Value="public void BeginInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void BeginInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.BeginInit" />
      <MemberSignature Language="VB.NET" Value="Public Sub BeginInit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void BeginInit();" />
      <MemberSignature Language="F#" Value="abstract member BeginInit : unit -&gt; unit&#xA;override this.BeginInit : unit -&gt; unit" Usage="fileSystemWatcher.BeginInit " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ComponentModel.ISupportInitialize.BeginInit</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>开始初始化在窗体上使用或由另一个组件使用的 <see cref="T:System.IO.FileSystemWatcher" />。 初始化发生在运行时。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [!INCLUDE[vsprvslong](~/includes/vsprvslong-md.md)]设计环境使用此方法来启动组件的初始化在窗体上使用或由另一个组件使用。 <xref:System.IO.FileSystemWatcher.EndInit%2A>方法结束初始化。 使用<xref:System.IO.FileSystemWatcher.BeginInit%2A>和<xref:System.IO.FileSystemWatcher.EndInit%2A>方法可以防止该控件完全初始化之前使用。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.IO.FileSystemWatcher.EndInit" />
      </Docs>
    </Member>
    <Member MemberName="Changed">
      <MemberSignature Language="C#" Value="public event System.IO.FileSystemEventHandler Changed;" />
      <MemberSignature Language="ILAsm" Value=".event class System.IO.FileSystemEventHandler Changed" />
      <MemberSignature Language="DocId" Value="E:System.IO.FileSystemWatcher.Changed" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Changed As FileSystemEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::IO::FileSystemEventHandler ^ Changed;" />
      <MemberSignature Language="F#" Value="member this.Changed : System.IO.FileSystemEventHandler " Usage="member this.Changed : System.IO.FileSystemEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.IO.IODescription("Occurs when a file/directory change matches the filter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.IO.IODescription("FSW_Changed")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.FileSystemEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当更改指定 <see cref="P:System.IO.FileSystemWatcher.Path" /> 中的文件和目录时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.FileSystemWatcher.Changed>大小发生更改时引发事件时，系统属性、 上次写入时间、 上次访问时间或文件或目录的安全权限在所监视的目录中。  
  
> [!NOTE]
>  常见的文件系统操作可能会引发多个事件。 例如，当文件从一个目录移到另一个、 多个<xref:System.IO.FileSystemWatcher.OnChanged%2A>和某些<xref:System.IO.FileSystemWatcher.OnCreated%2A>和<xref:System.IO.FileSystemWatcher.OnDeleted%2A>可能引发事件。 移动文件由多个简单操作组成的复杂操作，因此会引发多个事件。 同样，某些应用程序 （例如，防病毒软件） 可能会导致检测到的其他文件系统事件<xref:System.IO.FileSystemWatcher>。  
  
 使用<xref:System.IO.FileSystemWatcher.NotifyFilter%2A>来限制处理此事件时引发的通知数。  
  
> [!NOTE]
>  <xref:System.IO.FileSystemWatcher.Changed>时文件重命名，但如果重命名目录，则不会引发意外引发事件。 若要监视的重命名，请使用<xref:System.IO.FileSystemWatcher.Renamed>事件。  
  
> [!NOTE]
>  依据的顺序<xref:System.IO.FileSystemWatcher.Changed>相对于其他引发事件<xref:System.IO.FileSystemWatcher>事件可能会更改何时<xref:System.IO.FileSystemWatcher.SynchronizingObject%2A>属性不是`null`。  
  
   
  
## Examples  
 下面的示例使用<xref:System.IO.FileSystemWatcher.Changed>事件时对受监视的文件发生更改的文件路径显示到控制台。  
  
 [!code-cpp[Classic NotifyFilters Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CPP/source.cpp#1)]
 [!code-csharp[Classic NotifyFilters Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CS/source.cs#1)]
 [!code-vb[Classic NotifyFilters Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic NotifyFilters Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.IO.FileSystemWatcher.NotifyFilter" />
        <altmember cref="M:System.IO.FileSystemWatcher.OnChanged(System.IO.FileSystemEventArgs)" />
        <altmember cref="P:System.IO.FileSystemWatcher.SynchronizingObject" />
        <altmember cref="T:System.IO.FileSystemEventArgs" />
        <altmember cref="T:System.IO.FileSystemEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="Created">
      <MemberSignature Language="C#" Value="public event System.IO.FileSystemEventHandler Created;" />
      <MemberSignature Language="ILAsm" Value=".event class System.IO.FileSystemEventHandler Created" />
      <MemberSignature Language="DocId" Value="E:System.IO.FileSystemWatcher.Created" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Created As FileSystemEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::IO::FileSystemEventHandler ^ Created;" />
      <MemberSignature Language="F#" Value="member this.Created : System.IO.FileSystemEventHandler " Usage="member this.Created : System.IO.FileSystemEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.IO.IODescription("Occurs when a file/directory creation matches the filter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.IO.IODescription("FSW_Created")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.FileSystemEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当在指定 <see cref="P:System.IO.FileSystemWatcher.Path" /> 中创建文件和目录时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 一些常见的事件，如复制和移动文件或目录，并直接对应一个事件，但这些事件执行操作会导致要在引发事件。 复制文件或目录时，系统会引发<xref:System.IO.FileSystemWatcher.Created>文件被复制到，如果该目录正在受监视的目录中的事件。 如果正在监视从其复制的目录的另一实例<xref:System.IO.FileSystemWatcher>，会引发任何事件。 例如，创建的两个实例<xref:System.IO.FileSystemWatcher>。 FileSystemWatcher1 设置为监视"C:\My Documents"，并设置 FileSystemWatcher2 观看"C:\Your 文档"。 如果将文件从"我的文档"复制到"您的文档"， <xref:System.IO.FileSystemWatcher.Created> FileSystemWatcher2，将引发事件，但对于 FileSystemWatcher1 不引发任何事件。 与复制不同，移动文件或目录将引发两个事件。 上述示例中，如果"我的文档"从文件移至"您的文档"，从<xref:System.IO.FileSystemWatcher.Created>FileSystemWatcher2 会引发事件和一个<xref:System.IO.FileSystemWatcher.Deleted>FileSystemWatcher1 会引发事件。  
  
> [!NOTE]
>  常见的文件系统操作可能会引发多个事件。 例如，当文件从一个目录移到另一个、 多个<xref:System.IO.FileSystemWatcher.OnChanged%2A>和某些<xref:System.IO.FileSystemWatcher.OnCreated%2A>和<xref:System.IO.FileSystemWatcher.OnDeleted%2A>可能引发事件。 移动文件由多个简单操作组成的复杂操作，因此会引发多个事件。 同样，某些应用程序 （例如，防病毒软件） 可能会导致检测到的其他文件系统事件<xref:System.IO.FileSystemWatcher>。  
  
> [!NOTE]
>  依据的顺序<xref:System.IO.FileSystemWatcher.Created>相对于其他引发事件<xref:System.IO.FileSystemWatcher>事件可能会更改何时<xref:System.IO.FileSystemWatcher.SynchronizingObject%2A>属性不是`null`。  
  
 <xref:System.IO.FileSystemWatcher.OnCreated%2A>文件创建时立即引发事件。 是否有文件被复制或传输到受监视的目录，<xref:System.IO.FileSystemWatcher.OnCreated%2A>事件会立即发生后, 跟一个或多个<xref:System.IO.FileSystemWatcher.OnChanged%2A>事件。  
  
   
  
## Examples  
 下面的示例使用<xref:System.IO.FileSystemWatcher.Created>事件时对受监视的文件创建向控制台显示的文件路径。  
  
 [!code-cpp[Classic NotifyFilters Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CPP/source.cpp#1)]
 [!code-csharp[Classic NotifyFilters Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CS/source.cs#1)]
 [!code-vb[Classic NotifyFilters Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic NotifyFilters Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.IO.FileSystemWatcher.Deleted" />
        <altmember cref="M:System.IO.FileSystemWatcher.OnDeleted(System.IO.FileSystemEventArgs)" />
        <altmember cref="P:System.IO.FileSystemWatcher.SynchronizingObject" />
        <altmember cref="T:System.IO.FileSystemEventArgs" />
        <altmember cref="T:System.IO.FileSystemEventHandler" />
        <altmember cref="M:System.IO.FileSystemWatcher.OnCreated(System.IO.FileSystemEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="Deleted">
      <MemberSignature Language="C#" Value="public event System.IO.FileSystemEventHandler Deleted;" />
      <MemberSignature Language="ILAsm" Value=".event class System.IO.FileSystemEventHandler Deleted" />
      <MemberSignature Language="DocId" Value="E:System.IO.FileSystemWatcher.Deleted" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Deleted As FileSystemEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::IO::FileSystemEventHandler ^ Deleted;" />
      <MemberSignature Language="F#" Value="member this.Deleted : System.IO.FileSystemEventHandler " Usage="member this.Deleted : System.IO.FileSystemEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.IO.IODescription("Occurs when a file/directory deletion matches the filter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.IO.IODescription("FSW_Deleted")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.FileSystemEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>删除指定 <see cref="P:System.IO.FileSystemWatcher.Path" /> 中的文件或目录时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 一些常见的事件，如复制和移动文件或目录，并直接对应一个事件，但这些事件执行操作会导致要在引发事件。 复制文件或目录时，系统会引发<xref:System.IO.FileSystemWatcher.Created>文件被复制到，如果该目录正在受监视的目录中的事件。 如果正在监视从其复制的目录的另一实例<xref:System.IO.FileSystemWatcher>，会引发任何事件。 例如，创建的两个实例<xref:System.IO.FileSystemWatcher>。 FileSystemWatcher1 设置为监视"C:\My Documents"，并设置 FileSystemWatcher2 观看"C:\Your 文档"。 如果将文件从"我的文档"复制到"您的文档"， <xref:System.IO.FileSystemWatcher.Created> FileSystemWatcher2，将引发事件，但对于 FileSystemWatcher1 不引发任何事件。 与复制不同，移动文件或目录将引发两个事件。 上述示例中，如果"我的文档"从文件移至"您的文档"，从<xref:System.IO.FileSystemWatcher.Created>FileSystemWatcher2 会引发事件和一个<xref:System.IO.FileSystemWatcher.Deleted>FileSystemWatcher1 会引发事件。  
  
> [!NOTE]
>  常见的文件系统操作可能会引发多个事件。 例如，当文件从一个目录移到另一个、 多个<xref:System.IO.FileSystemWatcher.OnChanged%2A>和某些<xref:System.IO.FileSystemWatcher.OnCreated%2A>和<xref:System.IO.FileSystemWatcher.OnDeleted%2A>可能引发事件。 移动文件由多个简单操作组成的复杂操作，因此会引发多个事件。 同样，某些应用程序 （例如，防病毒软件） 可能会导致检测到的其他文件系统事件<xref:System.IO.FileSystemWatcher>。  
  
> [!NOTE]
>  依据的顺序<xref:System.IO.FileSystemWatcher.Deleted>相对于其他引发事件<xref:System.IO.FileSystemWatcher>事件可能会更改何时<xref:System.IO.FileSystemWatcher.SynchronizingObject%2A>属性不是`null`。  
  
   
  
## Examples  
 下面的示例使用<xref:System.IO.FileSystemWatcher.Deleted>事件，以删除对受监视的文件时向控制台显示的文件路径。  
  
 [!code-cpp[Classic NotifyFilters Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CPP/source.cpp#1)]
 [!code-csharp[Classic NotifyFilters Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CS/source.cs#1)]
 [!code-vb[Classic NotifyFilters Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic NotifyFilters Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.IO.FileSystemWatcher.Created" />
        <altmember cref="M:System.IO.FileSystemWatcher.OnCreated(System.IO.FileSystemEventArgs)" />
        <altmember cref="P:System.IO.FileSystemWatcher.SynchronizingObject" />
        <altmember cref="T:System.IO.FileSystemEventArgs" />
        <altmember cref="T:System.IO.FileSystemEventHandler" />
        <altmember cref="M:System.IO.FileSystemWatcher.OnDeleted(System.IO.FileSystemEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public virtual void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="override this.Dispose : unit -&gt; unit" Usage="fileSystemWatcher.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="override this.Dispose : bool -&gt; unit" Usage="fileSystemWatcher.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">若要释放托管资源和非托管资源，则为 <see langword="true" />；若仅释放非托管资源，则为 <see langword="false" />。</param>
        <summary>释放由 <see cref="T:System.IO.FileSystemWatcher" /> 占用的非托管资源，还可以另外再释放托管资源。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 调用此方法由公共<xref:System.ComponentModel.Component.Dispose%2A>方法和<xref:System.Object.Finalize%2A>方法。 <xref:System.ComponentModel.Component.Dispose%2A> 调用受保护<xref:System.IO.FileSystemWatcher.Dispose%2A>方法替换`disposing`参数设置为`true`。 <xref:System.Object.Finalize%2A> 调用<xref:System.IO.FileSystemWatcher.Dispose%2A>与`disposing`设置为`false`。  
  
 当 `disposing` 参数为 `true` 时，此方法释放该 <xref:System.IO.Compression.DeflateStream> 引用的、由任何托管对象持有的全部资源。 此方法调用每个引用对象的 <xref:System.ComponentModel.Component.Dispose%2A> 方法。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <see cref="M:System.ComponentModel.Component.Dispose" /> 可以多次调用由其他对象。重写时<see cref="M:System.IO.FileSystemWatcher.Dispose(System.Boolean)" />小心不要引用已经释放的早期调用中的对象<see cref="M:System.ComponentModel.Component.Dispose" />。有关如何实现详细信息<see cref="M:System.IO.FileSystemWatcher.Dispose(System.Boolean)" />，请参阅[实现 Dispose 方法](~/docs/standard/garbage-collection/implementing-dispose.md)。有关详细信息<see cref="M:System.ComponentModel.Component.Dispose" />并<see cref="M:System.Object.Finalize" />，请参阅[清理了非托管资源](~/docs/standard/garbage-collection/unmanaged.md)。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="EnableRaisingEvents">
      <MemberSignature Language="C#" Value="public bool EnableRaisingEvents { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableRaisingEvents" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileSystemWatcher.EnableRaisingEvents" />
      <MemberSignature Language="VB.NET" Value="Public Property EnableRaisingEvents As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool EnableRaisingEvents { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.EnableRaisingEvents : bool with get, set" Usage="System.IO.FileSystemWatcher.EnableRaisingEvents" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.IO.IODescription("Flag to indicate if this instance is active")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.IO.IODescription("FSW_Enabled")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值指示是否启用此组件。</summary>
        <value>如果启用此组件，则为 <see langword="true" />；否则为 <see langword="false" />。 默认值为 <see langword="false" />。 如果在 [!INCLUDE[vsprvslong](~/includes/vsprvslong-md.md)] 的设计器上使用该组件，则默认值为 <see langword="true" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 除非设置，该组件不会引发事件<xref:System.IO.FileSystemWatcher.EnableRaisingEvents%2A>到`true`。  
  
> [!NOTE]
>  该组件将不监视指定的目录，直到<xref:System.IO.FileSystemWatcher.Path%2A>已设置属性和<xref:System.IO.FileSystemWatcher.EnableRaisingEvents%2A>是`true`。  
  
 <xref:System.IO.FileSystemWatcher.WaitForChanged%2A>方法允许事件处理程序调用以响应的文件更改，即使此属性设置为`false`。  
  
   
  
## Examples  
 下面的示例创建<xref:System.IO.FileSystemWatcher>监视在运行时指定的目录。 该组件设置为监视中的更改`LastWrite`和`LastAccess`时间、 创建、 删除、 或重命名的目录中的文本文件。 如果文件是更改、 创建，或删除，文件的路径将打印到控制台。 在一个文件重命名后，旧的和新路径将打印到控制台。  
  
 使用<xref:System.Diagnostics>和<xref:System.IO>对于此示例的命名空间。  
  
 [!code-cpp[Classic NotifyFilters Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CPP/source.cpp#1)]
 [!code-csharp[Classic NotifyFilters Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CS/source.cs#1)]
 [!code-vb[Classic NotifyFilters Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic NotifyFilters Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.IO.FileSystemWatcher" /> 对象已释放。</exception>
        <exception cref="T:System.PlatformNotSupportedException">当前操作系统不是 Microsoft Windows NT 或更高版本。</exception>
        <exception cref="T:System.IO.FileNotFoundException">未能找到 <see cref="P:System.IO.FileSystemWatcher.Path" /> 中指定的目录。</exception>
        <exception cref="T:System.ArgumentException">
          <see cref="P:System.IO.FileSystemWatcher.Path" /> 尚未设置或无效。</exception>
      </Docs>
    </Member>
    <Member MemberName="EndInit">
      <MemberSignature Language="C#" Value="public void EndInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EndInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.EndInit" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndInit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void EndInit();" />
      <MemberSignature Language="F#" Value="abstract member EndInit : unit -&gt; unit&#xA;override this.EndInit : unit -&gt; unit" Usage="fileSystemWatcher.EndInit " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ComponentModel.ISupportInitialize.EndInit</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>结束在窗体上使用或由另一个组件使用的 <see cref="T:System.IO.FileSystemWatcher" /> 的初始化。 初始化发生在运行时。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [!INCLUDE[vsprvslong](~/includes/vsprvslong-md.md)]设计环境使用此方法来结束对组件的初始化在窗体上使用或由另一个组件使用。 <xref:System.IO.FileSystemWatcher.BeginInit%2A>方法开始初始化。 使用<xref:System.IO.FileSystemWatcher.BeginInit%2A>和<xref:System.IO.FileSystemWatcher.EndInit%2A>方法可以防止该控件完全初始化之前使用。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.IO.FileSystemWatcher.BeginInit" />
      </Docs>
    </Member>
    <Member MemberName="Error">
      <MemberSignature Language="C#" Value="public event System.IO.ErrorEventHandler Error;" />
      <MemberSignature Language="ILAsm" Value=".event class System.IO.ErrorEventHandler Error" />
      <MemberSignature Language="DocId" Value="E:System.IO.FileSystemWatcher.Error" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Error As ErrorEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::IO::ErrorEventHandler ^ Error;" />
      <MemberSignature Language="F#" Value="member this.Error : System.IO.ErrorEventHandler " Usage="member this.Error : System.IO.ErrorEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.ErrorEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当 <see cref="T:System.IO.FileSystemWatcher" /> 的实例无法继续监视更改或内部缓冲区溢出时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 某些内容阻止时将引发此事件<xref:System.IO.FileSystemWatcher>从监视更改的对象。 例如，如果对象正在监视远程目录中的更改和与该目录的连接已丢失，<xref:System.IO.FileSystemWatcher.Error>引发事件。  
  
 系统会通知您文件发生更改，并将这些更改存储的缓冲区中，在组件创建并传递给 Api。 如果在短时间有很多更改，则缓冲区可能溢出。 这会导致组件无法在目录中，更改跟踪并且它将只提供一般性通知。 增加缓冲区的大小较大，因为它来自非分页内存无法换出到磁盘，因此保持缓冲区尽可能小。 若要避免缓冲区溢出，请使用<xref:System.IO.FileSystemWatcher.NotifyFilter%2A>， <xref:System.IO.FileSystemWatcher.Filter%2A>，和<xref:System.IO.FileSystemWatcher.IncludeSubdirectories%2A>属性筛选掉不需要的更改通知。  
  
> [!NOTE]
>  常见的文件系统操作可能会引发多个事件。 例如，当文件从一个目录移到另一个、 多个<xref:System.IO.FileSystemWatcher.OnChanged%2A>和某些<xref:System.IO.FileSystemWatcher.OnCreated%2A>和<xref:System.IO.FileSystemWatcher.OnDeleted%2A>可能引发事件。 移动文件由多个简单操作组成的复杂操作，因此会引发多个事件。 同样，某些应用程序 （例如，防病毒软件） 可能会导致检测到的其他文件系统事件<xref:System.IO.FileSystemWatcher>。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.IO.FileSystemWatcher.NotifyFilter" />
        <altmember cref="T:System.IO.ErrorEventArgs" />
        <altmember cref="T:System.IO.ErrorEventHandler" />
        <altmember cref="P:System.IO.FileSystemWatcher.Filter" />
        <altmember cref="P:System.IO.FileSystemWatcher.IncludeSubdirectories" />
        <altmember cref="M:System.IO.FileSystemWatcher.OnError(System.IO.ErrorEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="Filter">
      <MemberSignature Language="C#" Value="public string Filter { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Filter" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileSystemWatcher.Filter" />
      <MemberSignature Language="VB.NET" Value="Public Property Filter As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Filter { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Filter : string with get, set" Usage="System.IO.FileSystemWatcher.Filter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.DefaultValue("*.*")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.RecommendedAsConfigurable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.StringValueConverter, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.IO.IODescription("File name filter pattern")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.StringValueConverter, System.Design, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.IO.IODescription("FSW_Filter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.StringValueConverter, System.Design, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0">
          <AttributeName>System.ComponentModel.SettingsBindable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置用于确定在目录中监视哪些文件的筛选器字符串。</summary>
        <value>筛选器字符串。 默认值为"*。\*"（监视所有文件。）</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要监视的所有文件中的更改，将设置<xref:System.IO.FileSystemWatcher.Filter%2A>属性为空字符串 ("")。 若要监视特定文件，请设置<xref:System.IO.FileSystemWatcher.Filter%2A>属性设置为的文件的名称。 例如，若要监视的文件 MyDoc.txt 中的更改，请设置<xref:System.IO.FileSystemWatcher.Filter%2A>属性设置为"MyDoc.txt"。 此外可以监视特定类型的文件中的更改。 例如，若要监视的任何文本文件中的更改，请设置<xref:System.IO.FileSystemWatcher.Filter%2A>属性设置为"*.txt"。 使用多个筛选器，如"\*.txt&#124;\*.doc"不受支持。  
  
 <xref:System.IO.FileSystemWatcher.Filter%2A>后，可以更改属性<xref:System.IO.FileSystemWatcher>对象已开始接收事件。  
  
 有关筛选掉不需要的通知的详细信息，请参阅<xref:System.IO.FileSystemWatcher.NotifyFilter%2A>， <xref:System.IO.FileSystemWatcher.IncludeSubdirectories%2A>，和<xref:System.IO.FileSystemWatcher.InternalBufferSize%2A>属性。  
  
 <xref:System.IO.FileSystemWatcher.Filter%2A> 接受通配符来匹配文件，如以下示例所示。  
  
|筛选器字符串|监视以下文件|  
|-------------------|---------------------------------|  
|*.\*|所有文件 （默认值）。 空字符串 ("") 还会监视所有文件。|  
|*.txt|使用"txt"扩展的所有文件。|  
|*recipe.doc|"Recipe"扩展名"doc"结尾的所有文件。|  
|win*.xml|"Xml"扩展与"win"开头的所有文件。|  
|Sales * 200？。xls|匹配以下项：<br /><br /> 销售年 7 月 2001.xlsSales 年 8 月 2002.xlsSales 年 3 月 2004.xls<br /><br /> 但不匹配：<br /><br /> 销售年 11 月 1999.xls|  
|MyReport.Doc|监视仅 MyReport.doc|  
  
   
  
## Examples  
 下面的示例创建<xref:System.IO.FileSystemWatcher>监视在运行时指定的目录。 该组件设置为监视中的更改`LastWrite`和`LastAccess`时间、 创建、 删除、 或重命名的目录中的文本文件。 如果文件是更改、 创建，或删除，文件的路径将打印到控制台。 在一个文件重命名后，旧的和新路径将打印到控制台。  
  
 使用<xref:System.Diagnostics>和<xref:System.IO>对于此示例的命名空间。  
  
 [!code-cpp[Classic NotifyFilters Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CPP/source.cpp#1)]
 [!code-csharp[Classic NotifyFilters Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CS/source.cs#1)]
 [!code-vb[Classic NotifyFilters Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic NotifyFilters Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.IO.FileSystemWatcher.NotifyFilter" />
        <altmember cref="P:System.IO.FileSystemWatcher.IncludeSubdirectories" />
        <altmember cref="P:System.IO.FileSystemWatcher.InternalBufferSize" />
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~FileSystemWatcher ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!FileSystemWatcher ()" />
      <MemberSignature Language="F#" Value="override this.Finalize : unit -&gt; unit" Usage="fileSystemWatcher.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IncludeSubdirectories">
      <MemberSignature Language="C#" Value="public bool IncludeSubdirectories { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IncludeSubdirectories" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileSystemWatcher.IncludeSubdirectories" />
      <MemberSignature Language="VB.NET" Value="Public Property IncludeSubdirectories As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IncludeSubdirectories { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.IncludeSubdirectories : bool with get, set" Usage="System.IO.FileSystemWatcher.IncludeSubdirectories" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.IO.IODescription("Flag to indicate we want to watch subdirectories")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.IO.IODescription("FSW_IncludeSubdirectories")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值指示是否应监视指定路径中的子目录。</summary>
        <value>如果要监视子目录，则为 <see langword="true" />；否则为 <see langword="false" />。 默认值为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 设置<xref:System.IO.FileSystemWatcher.IncludeSubdirectories%2A>到`true`当你想要监视的文件和目录中通过指定的目录包含的更改通知<xref:System.IO.FileSystemWatcher.Path%2A>属性和及其子目录。 设置<xref:System.IO.FileSystemWatcher.IncludeSubdirectories%2A>属性设置为`false`有助于减少发送到内部缓冲区的通知数。 筛选掉不需要的通知的详细信息，请参阅<xref:System.IO.FileSystemWatcher.NotifyFilter%2A>和<xref:System.IO.FileSystemWatcher.InternalBufferSize%2A>属性。  
  
 当`true`，<xref:System.IO.FileSystemWatcher.IncludeSubdirectories%2A>通过整个子树，而不仅仅是直接子目录进行递归。 文件或子树内的目录的相对路径返回中<xref:System.IO.FileSystemEventArgs.Name%2A>的属性<xref:System.IO.FileSystemEventArgs>并<xref:System.IO.RenamedEventArgs.OldName%2A>属性的<xref:System.IO.RenamedEventArgs>，取决于正在监视的更改。 可以获取从的完全限定的路径<xref:System.IO.FileSystemEventArgs.FullPath%2A>的属性<xref:System.IO.FileSystemEventArgs>并<xref:System.IO.RenamedEventArgs.OldFullPath%2A>属性<xref:System.IO.RenamedEventArgs>，取决于正在监视的更改。  
  
 如果您正在监视的目录的子树中创建一个目录并<xref:System.IO.FileSystemWatcher.IncludeSubdirectories%2A>是`true`，该目录将自动进行监视。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.IO.FileSystemWatcher.NotifyFilter" />
        <altmember cref="T:System.IO.FileSystemEventArgs" />
        <altmember cref="P:System.IO.FileSystemWatcher.Filter" />
        <altmember cref="P:System.IO.FileSystemEventArgs.FullPath" />
        <altmember cref="P:System.IO.RenamedEventArgs.OldFullPath" />
        <altmember cref="P:System.IO.FileSystemWatcher.InternalBufferSize" />
        <altmember cref="P:System.IO.FileSystemEventArgs.Name" />
        <altmember cref="P:System.IO.RenamedEventArgs.OldName" />
        <altmember cref="P:System.IO.FileSystemWatcher.Path" />
        <altmember cref="T:System.IO.RenamedEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="InternalBufferSize">
      <MemberSignature Language="C#" Value="public int InternalBufferSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 InternalBufferSize" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileSystemWatcher.InternalBufferSize" />
      <MemberSignature Language="VB.NET" Value="Public Property InternalBufferSize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int InternalBufferSize { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.InternalBufferSize : int with get, set" Usage="System.IO.FileSystemWatcher.InternalBufferSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.DefaultValue(8192)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置内部缓冲区的大小（以字节为单位）。</summary>
        <value>内部缓冲区的大小（以字节为单位）。 默认值为 8192 (8 KB)。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 您可以设置缓冲区，为 4 KB 或更大，但它不能超过 64 KB。 如果您尝试设置<xref:System.IO.FileSystemWatcher.InternalBufferSize%2A>属性为小于 4096 个字节，你的值将被丢弃和<xref:System.IO.FileSystemWatcher.InternalBufferSize%2A>属性设置为 4096 个字节。 为了获得最佳性能，在基于 Intel 的计算机上使用 4 KB 的倍数。  
  
 系统会通知文件更改的组件并将这些更改存储该组件创建并传递给 Api 的缓冲区中。 每个事件可以使用最多 16 个字节的内存中，不包括的文件的名称。 如果在短时间有很多更改，则缓冲区可能溢出。 这会导致组件无法在目录中，更改跟踪并且它将只提供一般性通知。 增加缓冲区的大小可以防止丢失文件系统更改事件。 但是，增加缓冲区大小很高的因为它来自无法换出到磁盘中，因此保持缓冲区尽可能小的非分页内存。 若要避免缓冲区溢出，请使用<xref:System.IO.FileSystemWatcher.NotifyFilter%2A>和<xref:System.IO.FileSystemWatcher.IncludeSubdirectories%2A>属性筛选掉不需要的更改通知。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.IO.FileSystemWatcher.NotifyFilter" />
        <altmember cref="M:System.IO.FileSystemWatcher.OnError(System.IO.ErrorEventArgs)" />
        <altmember cref="P:System.IO.FileSystemWatcher.Filter" />
        <altmember cref="P:System.IO.FileSystemWatcher.IncludeSubdirectories" />
        <altmember cref="T:System.IO.InternalBufferOverflowException" />
      </Docs>
    </Member>
    <Member MemberName="NotifyFilter">
      <MemberSignature Language="C#" Value="public System.IO.NotifyFilters NotifyFilter { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.IO.NotifyFilters NotifyFilter" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileSystemWatcher.NotifyFilter" />
      <MemberSignature Language="VB.NET" Value="Public Property NotifyFilter As NotifyFilters" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::NotifyFilters NotifyFilter { System::IO::NotifyFilters get(); void set(System::IO::NotifyFilters value); };" />
      <MemberSignature Language="F#" Value="member this.NotifyFilter : System.IO.NotifyFilters with get, set" Usage="System.IO.FileSystemWatcher.NotifyFilter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.IO.IODescription("Flag to indicate which change event we want to monitor")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.IO.IODescription("FSW_ChangedFilter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.NotifyFilters</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置要监视的更改的类型。</summary>
        <value>
          <see cref="T:System.IO.NotifyFilters" /> 值之一。 默认值为 <see langword="LastWrite" />、<see langword="FileName" /> 和 <see langword="DirectoryName" /> 的按位“或”组合。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 你可以组合的成员<xref:System.IO.NotifyFilters>枚举要监视的多个类型一次更改。 例如，可以监视的更改的文件的大小和中的更改`LastWrite`时间。 这引发一个事件，每当文件或文件夹大小的更改或中的更改`LastWrite`文件或文件夹的时间。  
  
 这是筛选掉不需要通知的一种方法。 筛选掉不需要的通知的详细信息，请参阅<xref:System.IO.FileSystemWatcher.Filter%2A>， <xref:System.IO.FileSystemWatcher.IncludeSubdirectories%2A>，和<xref:System.IO.FileSystemWatcher.InternalBufferSize%2A>属性。  
  
   
  
## Examples  
 下面的示例创建<xref:System.IO.FileSystemWatcher>监视在运行时指定的目录。 该组件设置为监视中的更改`LastWrite`和`LastAccess`时间、 创建、 删除、 或重命名的目录中的文本文件。 如果文件是更改、 创建，或删除，文件的路径将打印到控制台。 在一个文件重命名后，旧的和新路径将打印到控制台。  
  
 使用<xref:System.Diagnostics>和<xref:System.IO>对于此示例的命名空间。  
  
 [!code-cpp[Classic NotifyFilters Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CPP/source.cpp#1)]
 [!code-csharp[Classic NotifyFilters Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CS/source.cs#1)]
 [!code-vb[Classic NotifyFilters Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic NotifyFilters Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">该值不是 <see cref="T:System.IO.NotifyFilters" /> 值的有效按位“或”组合。</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">正在设置的值无效。</exception>
        <altmember cref="T:System.IO.NotifyFilters" />
        <altmember cref="P:System.IO.FileSystemWatcher.Filter" />
        <altmember cref="P:System.IO.FileSystemWatcher.IncludeSubdirectories" />
        <altmember cref="P:System.IO.FileSystemWatcher.InternalBufferSize" />
      </Docs>
    </Member>
    <Member MemberName="OnChanged">
      <MemberSignature Language="C#" Value="protected void OnChanged (System.IO.FileSystemEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void OnChanged(class System.IO.FileSystemEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.OnChanged(System.IO.FileSystemEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub OnChanged (e As FileSystemEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void OnChanged(System::IO::FileSystemEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.OnChanged : System.IO.FileSystemEventArgs -&gt; unit" Usage="fileSystemWatcher.OnChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.IO.FileSystemEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.IO.FileSystemEventArgs" />。</param>
        <summary>引发 <see cref="E:System.IO.FileSystemWatcher.Changed" /> 事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.FileSystemWatcher.OnChanged%2A> 对大小、 系统属性、 上次写入时间、 上次访问时间或安全权限的文件或目录在所监视的目录中进行更改时调用。  
  
 使用<xref:System.IO.FileSystemWatcher.NotifyFilter%2A>属性来限制事件数目时引发<xref:System.IO.FileSystemWatcher.Changed>处理事件。  
  
 <xref:System.IO.FileSystemWatcher.OnCreated%2A>文件创建时立即引发事件。 是否有文件被复制或传输到受监视的目录，<xref:System.IO.FileSystemWatcher.OnCreated%2A>事件会立即发生后, 跟一个或多个<xref:System.IO.FileSystemWatcher.OnChanged%2A>事件。  
  
 引发事件时，将通过委托调用事件处理程序。 有关详细信息，请参阅[处理和引发事件](~/docs/standard/events/index.md)。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>重写时<see cref="M:System.IO.FileSystemWatcher.OnChanged(System.IO.FileSystemEventArgs)" />在派生类中，请务必调用基类的<see cref="M:System.IO.FileSystemWatcher.OnChanged(System.IO.FileSystemEventArgs)" />方法。</para>
        </block>
        <altmember cref="E:System.IO.FileSystemWatcher.Changed" />
        <altmember cref="P:System.IO.FileSystemWatcher.NotifyFilter" />
        <altmember cref="T:System.IO.FileSystemEventArgs" />
        <altmember cref="T:System.IO.FileSystemEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="OnCreated">
      <MemberSignature Language="C#" Value="protected void OnCreated (System.IO.FileSystemEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void OnCreated(class System.IO.FileSystemEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.OnCreated(System.IO.FileSystemEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub OnCreated (e As FileSystemEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void OnCreated(System::IO::FileSystemEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.OnCreated : System.IO.FileSystemEventArgs -&gt; unit" Usage="fileSystemWatcher.OnCreated e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.IO.FileSystemEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.IO.FileSystemEventArgs" />。</param>
        <summary>引发 <see cref="E:System.IO.FileSystemWatcher.Created" /> 事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.FileSystemWatcher.OnCreated%2A> 所监视的目录中创建文件或目录时调用。  
  
 一些常见的事件，如复制和移动文件或目录，并直接对应一个事件，但这些事件执行操作会导致要在引发事件。 复制文件或目录时，系统会引发<xref:System.IO.FileSystemWatcher.Created>文件被复制到，如果该目录正在受监视的目录中的事件。 如果正在监视从其复制的目录的另一实例<xref:System.IO.FileSystemWatcher>，会引发任何事件。 例如，创建的两个实例<xref:System.IO.FileSystemWatcher>。 FileSystemWatcher1 设置为监视"C:\My Documents"，并设置 FileSystemWatcher2 观看"C:\Your 文档"。 如果您从"我的文档"复制文件并将其粘贴到"您的文档"，<xref:System.IO.FileSystemWatcher.Created>中 FileSystemWatcher2，将引发事件，但对于 FileSystemWatcher1 不引发任何事件。 与复制不同，移动文件或目录将引发两个事件。 上述示例中，如果"我的文档"从文件移至"您的文档"，从<xref:System.IO.FileSystemWatcher.Created>FileSystemWatcher2 中会引发事件和一个<xref:System.IO.FileSystemWatcher.Deleted>FileSystemWatcher1 中会引发事件。  
  
 <xref:System.IO.FileSystemWatcher.OnCreated%2A>文件创建时立即引发事件。 是否有文件被复制或传输到受监视的目录，<xref:System.IO.FileSystemWatcher.OnCreated%2A>事件会立即发生后, 跟一个或多个<xref:System.IO.FileSystemWatcher.OnChanged%2A>事件。  
  
 引发事件时，将通过委托调用事件处理程序。 有关详细信息，请参阅[处理和引发事件](~/docs/standard/events/index.md)。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>重写时<see cref="M:System.IO.FileSystemWatcher.OnCreated(System.IO.FileSystemEventArgs)" />在派生类中，请务必调用基类的<see cref="M:System.IO.FileSystemWatcher.OnCreated(System.IO.FileSystemEventArgs)" />方法。</para>
        </block>
        <altmember cref="E:System.IO.FileSystemWatcher.Created" />
        <altmember cref="E:System.IO.FileSystemWatcher.Deleted" />
        <altmember cref="T:System.IO.FileSystemEventArgs" />
        <altmember cref="T:System.IO.FileSystemEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="OnDeleted">
      <MemberSignature Language="C#" Value="protected void OnDeleted (System.IO.FileSystemEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void OnDeleted(class System.IO.FileSystemEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.OnDeleted(System.IO.FileSystemEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub OnDeleted (e As FileSystemEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void OnDeleted(System::IO::FileSystemEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.OnDeleted : System.IO.FileSystemEventArgs -&gt; unit" Usage="fileSystemWatcher.OnDeleted e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.IO.FileSystemEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.IO.FileSystemEventArgs" />。</param>
        <summary>引发 <see cref="E:System.IO.FileSystemWatcher.Deleted" /> 事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.FileSystemWatcher.OnDeleted%2A> 删除文件或目录，在所监视的目录中时调用。  
  
 一些常见的事件，如复制和移动文件或目录，并直接对应一个事件，但这些事件执行操作会导致要在引发事件。 复制文件或目录时，系统会引发<xref:System.IO.FileSystemWatcher.Created>文件被复制到，如果该目录正在受监视的目录中的事件。 如果正在监视从其复制的目录的另一实例<xref:System.IO.FileSystemWatcher>，会引发任何事件。 例如，创建的两个实例<xref:System.IO.FileSystemWatcher>。 FileSystemWatcher1 设置为监视"C:\My Documents"，并设置 FileSystemWatcher2 观看"C:\Your 文档"。 如果将文件从"我的文档"复制到"您的文档"， <xref:System.IO.FileSystemWatcher.Created> FileSystemWatcher2，将引发事件，但对于 FileSystemWatcher1 不引发任何事件。 与复制不同，移动文件或目录将引发两个事件。 上述示例中，如果"我的文档"从文件移至"您的文档"，从<xref:System.IO.FileSystemWatcher.Created>FileSystemWatcher2 会引发事件和一个<xref:System.IO.FileSystemWatcher.Deleted>FileSystemWatcher1 会引发事件。  
  
 引发事件时，将通过委托调用事件处理程序。 有关详细信息，请参阅[处理和引发事件](~/docs/standard/events/index.md)。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>重写时<see cref="M:System.IO.FileSystemWatcher.OnDeleted(System.IO.FileSystemEventArgs)" />在派生类中，请务必调用基类的<see cref="M:System.IO.FileSystemWatcher.OnDeleted(System.IO.FileSystemEventArgs)" />方法。</para>
        </block>
        <altmember cref="E:System.IO.FileSystemWatcher.Created" />
        <altmember cref="E:System.IO.FileSystemWatcher.Deleted" />
        <altmember cref="T:System.IO.FileSystemEventArgs" />
        <altmember cref="T:System.IO.FileSystemEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="OnError">
      <MemberSignature Language="C#" Value="protected void OnError (System.IO.ErrorEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void OnError(class System.IO.ErrorEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.OnError(System.IO.ErrorEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub OnError (e As ErrorEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void OnError(System::IO::ErrorEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.OnError : System.IO.ErrorEventArgs -&gt; unit" Usage="fileSystemWatcher.OnError e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.IO.ErrorEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.IO.ErrorEventArgs" />。</param>
        <summary>引发 <see cref="E:System.IO.FileSystemWatcher.Error" /> 事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.FileSystemWatcher.OnError%2A> 发生错误时调用。  
  
 引发事件时，将通过委托调用事件处理程序。 有关详细信息，请参阅[处理和引发事件](~/docs/standard/events/index.md)。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>重写时<see cref="M:System.IO.FileSystemWatcher.OnError(System.IO.ErrorEventArgs)" />在派生类中，请务必调用基类的<see cref="M:System.IO.FileSystemWatcher.OnError(System.IO.ErrorEventArgs)" />方法。</para>
        </block>
        <altmember cref="E:System.IO.FileSystemWatcher.Error" />
        <altmember cref="T:System.IO.ErrorEventArgs" />
        <altmember cref="T:System.IO.ErrorEventHandler" />
        <altmember cref="T:System.IO.InternalBufferOverflowException" />
      </Docs>
    </Member>
    <Member MemberName="OnRenamed">
      <MemberSignature Language="C#" Value="protected void OnRenamed (System.IO.RenamedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void OnRenamed(class System.IO.RenamedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.OnRenamed(System.IO.RenamedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub OnRenamed (e As RenamedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void OnRenamed(System::IO::RenamedEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.OnRenamed : System.IO.RenamedEventArgs -&gt; unit" Usage="fileSystemWatcher.OnRenamed e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.IO.RenamedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.IO.RenamedEventArgs" />。</param>
        <summary>引发 <see cref="E:System.IO.FileSystemWatcher.Renamed" /> 事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.FileSystemWatcher.OnRenamed%2A> 重命名文件或目录在所监视的目录中时调用。 其<xref:System.IO.RenamedEventArgs>参数包含有关重命名操作，如更改、 旧的和新路径和旧的和新名称的类型的信息。 请注意，其<xref:System.IO.FileSystemEventArgs.Name>属性可为 null 如果重命名事件<xref:System.IO.FileSystemWatcher>不会获得匹配来自操作系统的新旧名称事件。 
  
 引发事件时，将通过委托调用事件处理程序。 有关详细信息，请参阅[处理和引发事件](~/docs/standard/events/index.md)。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>重写时<see cref="M:System.IO.FileSystemWatcher.OnRenamed(System.IO.RenamedEventArgs)" />在派生类中，请务必调用基类的<see cref="M:System.IO.FileSystemWatcher.OnRenamed(System.IO.RenamedEventArgs)" />方法。</para>
        </block>
        <altmember cref="E:System.IO.FileSystemWatcher.Renamed" />
        <altmember cref="T:System.IO.RenamedEventArgs" />
        <altmember cref="T:System.IO.RenamedEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="Path">
      <MemberSignature Language="C#" Value="public string Path { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Path" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileSystemWatcher.Path" />
      <MemberSignature Language="VB.NET" Value="Public Property Path As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Path { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Path : string with get, set" Usage="System.IO.FileSystemWatcher.Path" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.Editor("System.Diagnostics.Design.FSWPathEditor, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.RecommendedAsConfigurable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.StringValueConverter, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.IO.IODescription("The directory to monitor")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.ComponentModel.Editor("System.Diagnostics.Design.FSWPathEditor, System.Design, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.StringValueConverter, System.Design, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.IO.IODescription("FSW_Path")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.Editor("System.Diagnostics.Design.FSWPathEditor, System.Design, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.StringValueConverter, System.Design, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0">
          <AttributeName>System.ComponentModel.SettingsBindable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置要监视的目录的路径。</summary>
        <value>要监视的路径。 默认值为空字符串("")。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 这是一个目录的完全限定的路径。 如果<xref:System.IO.FileSystemWatcher.IncludeSubdirectories%2A>属性是`true`，此目录为的根的系统监视的更改; 否则它为受监视的唯一目录。 若要监视特定文件，请设置<xref:System.IO.FileSystemWatcher.Path%2A>属性设置为完全限定的正确目录中，和<xref:System.IO.FileSystemWatcher.Filter%2A>属性设置为的文件的名称。  
  
 <xref:System.IO.FileSystemWatcher.Path%2A>属性支持通用命名约定 (UNC) 路径。  
  
> [!NOTE]
>  该组件可监视更改之前，必须设置此属性。  
  
 如果重命名目录，，<xref:System.IO.FileSystemWatcher>自动重新自身附加到新的重命名项。 例如，如果您设置<xref:System.IO.FileSystemWatcher.Path%2A>属性设置为"C:\My Documents"，然后手动重命名为"C:\Your 文档"目录，该组件会继续侦听新的重命名目录上的更改通知。 但是，当要求提供<xref:System.IO.FileSystemWatcher.Path%2A>属性，它包含旧路径。 这是因为该组件确定所监视基于句柄，而不是目录的名称。 重命名并不影响该句柄。 因此，如果销毁该组件，然后重新创建它而不更新<xref:System.IO.FileSystemWatcher.Path%2A>属性，你的应用程序将失败，因为该目录不再存在。  
  
   
  
## Examples  
 下面的示例创建<xref:System.IO.FileSystemWatcher>监视在运行时指定的目录。 该组件设置为监视中的更改`LastWrite`和`LastAccess`时间、 创建、 删除、 或重命名的目录中的文本文件。 如果文件是更改、 创建，或删除，文件的路径将打印到控制台。 在一个文件重命名后，旧的和新路径将打印到控制台。  
  
 使用<xref:System.Diagnostics>和<xref:System.IO>对于此示例的命名空间。  
  
 [!code-cpp[Classic NotifyFilters Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CPP/source.cpp#1)]
 [!code-csharp[Classic NotifyFilters Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CS/source.cs#1)]
 [!code-vb[Classic NotifyFilters Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic NotifyFilters Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">指定的路径不存在或找不到。  
  
或 
指定的路径包含通配符。  
  
或 
指定的路径包含无效路径字符。</exception>
        <altmember cref="T:System.IO.FileSystemWatcher" />
        <altmember cref="P:System.IO.FileSystemWatcher.Filter" />
      </Docs>
    </Member>
    <Member MemberName="Renamed">
      <MemberSignature Language="C#" Value="public event System.IO.RenamedEventHandler Renamed;" />
      <MemberSignature Language="ILAsm" Value=".event class System.IO.RenamedEventHandler Renamed" />
      <MemberSignature Language="DocId" Value="E:System.IO.FileSystemWatcher.Renamed" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Renamed As RenamedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::IO::RenamedEventHandler ^ Renamed;" />
      <MemberSignature Language="F#" Value="member this.Renamed : System.IO.RenamedEventHandler " Usage="member this.Renamed : System.IO.RenamedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.IO.IODescription("Occurs when a file/directory rename matches the filter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.IO.IODescription("FSW_Renamed")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.RenamedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>重命名指定 <see cref="P:System.IO.FileSystemWatcher.Path" /> 中的文件或目录时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Renamed`事件是<xref:System.IO.RenamedEventHandler>具有以下签名的委托：

 ```csharp
public delegate void Renamed(object sender, RenamedEventArgs e);
 ```
 ```vb
Public Delegate Sub RenamedEventHandler(sender As Object, e As RenamedEventArgs)
 ```
 <xref:System.IO.RenamedEventArgs>对象提供有关重命名操作，例如重命名的类型信息 (<xref:System.IO.FileSystemEventArgs.ChangeType>属性)，旧的和新名称和旧的和新路径。 请注意，<xref:System.IO.FileSystemEventArgs.Name>属性可为 null 如果重命名事件<xref:System.IO.FileSystemWatcher>不会获得匹配来自操作系统的新旧名称事件。

 重命名正在监视的目录不会引发通知。 您正在监视的目录中的条目，才引发通知。  
  
   
  
## Examples  
 下面的示例使用<xref:System.IO.FileSystemWatcher.Renamed>事件时对受监视的文件重命名的文件路径显示到控制台。  
  
 [!code-cpp[Classic NotifyFilters Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CPP/source.cpp#1)]
 [!code-csharp[Classic NotifyFilters Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CS/source.cs#1)]
 [!code-vb[Classic NotifyFilters Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic NotifyFilters Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.IO.FileSystemWatcher.OnRenamed(System.IO.RenamedEventArgs)" />
        <altmember cref="P:System.IO.FileSystemWatcher.SynchronizingObject" />
        <altmember cref="P:System.IO.FileSystemWatcher.Path" />
        <altmember cref="T:System.IO.RenamedEventArgs" />
        <altmember cref="T:System.IO.RenamedEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="Site">
      <MemberSignature Language="C#" Value="public override System.ComponentModel.ISite Site { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ComponentModel.ISite Site" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileSystemWatcher.Site" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Site As ISite" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::ComponentModel::ISite ^ Site { System::ComponentModel::ISite ^ get(); void set(System::ComponentModel::ISite ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Site : System.ComponentModel.ISite with get, set" Usage="System.IO.FileSystemWatcher.Site" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.ISite</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置 <see cref="T:System.IO.FileSystemWatcher" /> 的 <see cref="T:System.ComponentModel.ISite" />。</summary>
        <value>
          <see cref="T:System.ComponentModel.ISite" /> 的一个 <see cref="T:System.IO.FileSystemWatcher" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 站点绑定<xref:System.ComponentModel.Component>到<xref:System.ComponentModel.Design.IDesignerHost.Container%2A>启用它们之间的通信，以及为要管理其组件的容器提供的方法。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SynchronizingObject">
      <MemberSignature Language="C#" Value="public System.ComponentModel.ISynchronizeInvoke SynchronizingObject { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ComponentModel.ISynchronizeInvoke SynchronizingObject" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileSystemWatcher.SynchronizingObject" />
      <MemberSignature Language="VB.NET" Value="Public Property SynchronizingObject As ISynchronizeInvoke" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ComponentModel::ISynchronizeInvoke ^ SynchronizingObject { System::ComponentModel::ISynchronizeInvoke ^ get(); void set(System::ComponentModel::ISynchronizeInvoke ^ value); };" />
      <MemberSignature Language="F#" Value="member this.SynchronizingObject : System.ComponentModel.ISynchronizeInvoke with get, set" Usage="System.IO.FileSystemWatcher.SynchronizingObject" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.IO.IODescription("The object used to marshal the event handler calls resulting from a directory change")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.IO.IODescription("FSW_SynchronizingObject")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.ISynchronizeInvoke</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置用于封送因目录更改而发出的事件处理程序调用的对象。</summary>
        <value>
          <see cref="T:System.ComponentModel.ISynchronizeInvoke" />，表示一个对象，该对象用于封送因目录更改而发出的事件处理程序调用。 默认值为 <see langword="null" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当<xref:System.IO.FileSystemWatcher.SynchronizingObject%2A>是`null`，方法处理<xref:System.IO.FileSystemWatcher.Changed>， <xref:System.IO.FileSystemWatcher.Created>， <xref:System.IO.FileSystemWatcher.Deleted>，并<xref:System.IO.FileSystemWatcher.Renamed>从系统线程池线程上调用事件。 系统线程池的详细信息，请参阅<xref:System.Threading.ThreadPool>。  
  
 当<xref:System.IO.FileSystemWatcher.Changed>， <xref:System.IO.FileSystemWatcher.Created>， <xref:System.IO.FileSystemWatcher.Deleted>，和<xref:System.IO.FileSystemWatcher.Renamed>事件由 visual 的 Windows 窗体组件，如处理<xref:System.Windows.Forms.Button>，通过系统线程池访问组件可能无法工作，或可能会导致异常。 通过设置来避免这<xref:System.IO.FileSystemWatcher.SynchronizingObject%2A>到 Windows 窗体组件时，这将导致处理的方法<xref:System.IO.FileSystemWatcher.Changed>， <xref:System.IO.FileSystemWatcher.Created>， <xref:System.IO.FileSystemWatcher.Deleted>，和<xref:System.IO.FileSystemWatcher.Renamed>要在其创建该组件在同一线程上调用事件。  
  
 如果<xref:System.IO.FileSystemWatcher>内部使用[!INCLUDE[vsprvslong](~/includes/vsprvslong-md.md)]在 Windows 窗体设计器中，<xref:System.IO.FileSystemWatcher.SynchronizingObject%2A>自动设置为包含的控件<xref:System.IO.FileSystemWatcher>。 例如，如果将置于<xref:System.IO.FileSystemWatcher>Form1 的设计器上 (派生自<xref:System.Windows.Forms.Form>)<xref:System.IO.FileSystemWatcher.SynchronizingObject%2A>属性的<xref:System.IO.FileSystemWatcher>设置为 Form1 的实例。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.ComponentModel.ISynchronizeInvoke" />
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitForChanged">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>一种同步方法，该方法会返回包含已发生的更改上的特定信息的结构。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitForChanged">
      <MemberSignature Language="C#" Value="public System.IO.WaitForChangedResult WaitForChanged (System.IO.WatcherChangeTypes changeType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.IO.WaitForChangedResult WaitForChanged(valuetype System.IO.WatcherChangeTypes changeType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.WaitForChanged(System.IO.WatcherChangeTypes)" />
      <MemberSignature Language="VB.NET" Value="Public Function WaitForChanged (changeType As WatcherChangeTypes) As WaitForChangedResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::WaitForChangedResult WaitForChanged(System::IO::WatcherChangeTypes changeType);" />
      <MemberSignature Language="F#" Value="member this.WaitForChanged : System.IO.WatcherChangeTypes -&gt; System.IO.WaitForChangedResult" Usage="fileSystemWatcher.WaitForChanged changeType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.WaitForChangedResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="changeType" Type="System.IO.WatcherChangeTypes" />
      </Parameters>
      <Docs>
        <param name="changeType">要监视的 <see cref="T:System.IO.WatcherChangeTypes" />。</param>
        <summary>一种同步方法，在给定要监视的更改的类型情况下，它会返回包含已发生的更改上的特定信息的结构。</summary>
        <returns>
          <see cref="T:System.IO.WaitForChangedResult" />，包含关于已发生的更改的特定信息。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法将等到无限期第一次更改发生，并返回。 这是使用相同<xref:System.IO.FileSystemWatcher.WaitForChanged%2A>与`timeout`参数设置为-1。  
  
> [!NOTE]
>  此方法允许事件处理程序调用来响应文件的更改，即使<xref:System.IO.FileSystemWatcher.EnableRaisingEvents%2A>属性设置为`false`。  
  
 在某些系统<xref:System.IO.FileSystemWatcher>报告使用短 8.3 文件名称格式的文件更改。 例如，对"LongFileName.LongExtension"的更改可能被报告为"LongFi ~。Lon"。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.IO.WaitForChangedResult" />
      </Docs>
    </Member>
    <Member MemberName="WaitForChanged">
      <MemberSignature Language="C#" Value="public System.IO.WaitForChangedResult WaitForChanged (System.IO.WatcherChangeTypes changeType, int timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.IO.WaitForChangedResult WaitForChanged(valuetype System.IO.WatcherChangeTypes changeType, int32 timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.WaitForChanged(System.IO.WatcherChangeTypes,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function WaitForChanged (changeType As WatcherChangeTypes, timeout As Integer) As WaitForChangedResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::WaitForChangedResult WaitForChanged(System::IO::WatcherChangeTypes changeType, int timeout);" />
      <MemberSignature Language="F#" Value="member this.WaitForChanged : System.IO.WatcherChangeTypes * int -&gt; System.IO.WaitForChangedResult" Usage="fileSystemWatcher.WaitForChanged (changeType, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.WaitForChangedResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="changeType" Type="System.IO.WatcherChangeTypes" />
        <Parameter Name="timeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="changeType">要监视的 <see cref="T:System.IO.WatcherChangeTypes" />。</param>
        <param name="timeout">超时前等待的时间（以毫秒表示）。</param>
        <summary>一种同步方法，在给定要监视的更改的类型以及在超时前等待的时间（以毫秒表示）的情况下，它会返回包含已发生的更改上的特定信息的结构。</summary>
        <returns>
          <see cref="T:System.IO.WaitForChangedResult" />，包含关于已发生的更改的特定信息。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法等待，直到发生更改或已超时。值为-1 表示`timeout`参数表示无限期等待。  
  
> [!NOTE]
>  此方法允许事件处理程序调用来响应文件的更改，即使<xref:System.IO.FileSystemWatcher.EnableRaisingEvents%2A>属性设置为`false`。  
  
 在某些系统<xref:System.IO.FileSystemWatcher>报告使用短 8.3 文件名称格式的文件更改。 例如，对"LongFileName.LongExtension"的更改可能被报告为"LongFi ~。Lon"。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.IO.WaitForChangedResult" />
      </Docs>
    </Member>
  </Members>
</Type>