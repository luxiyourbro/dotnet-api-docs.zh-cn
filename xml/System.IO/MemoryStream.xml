<Type Name="MemoryStream" FullName="System.IO.MemoryStream">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="9a12f5194c1d7abbbf4c41abee52479b2aaefff3" />
    <Meta Name="ms.sourcegitcommit" Value="0ec122ee5f3681159b8460ab15b409fd6e3d3ae0" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-CN" />
    <Meta Name="ms.lasthandoff" Value="10/04/2018" />
    <Meta Name="ms.locfileid" Value="48678575" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class MemoryStream : System.IO.Stream" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit MemoryStream extends System.IO.Stream" />
  <TypeSignature Language="DocId" Value="T:System.IO.MemoryStream" />
  <TypeSignature Language="VB.NET" Value="Public Class MemoryStream&#xA;Inherits Stream" />
  <TypeSignature Language="C++ CLI" Value="public ref class MemoryStream : System::IO::Stream" />
  <TypeSignature Language="F#" Value="type MemoryStream = class&#xA;    inherit Stream" />
  <AssemblyInfo>
    <AssemblyName>System.IO</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Extensions</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.IO.Stream</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>
      <span data-ttu-id="2b41c-101">创建一个流，其后备存储为内存。</span>
      <span class="sxs-lookup">
        <span data-stu-id="2b41c-101">Creates a stream whose backing store is memory.</span>
      </span>
    </summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2b41c-102">流的当前位置不在其下一个读取或写入操作的位置可能发生的位置。</span><span class="sxs-lookup"><span data-stu-id="2b41c-102">The current position of a stream is the position at which the next read or write operation could take place.</span></span> <span data-ttu-id="2b41c-103">可以检索当前的位置或通过设置<xref:System.IO.MemoryStream.Seek%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="2b41c-103">The current position can be retrieved or set through the <xref:System.IO.MemoryStream.Seek%2A> method.</span></span> <span data-ttu-id="2b41c-104">新实例时<xref:System.IO.MemoryStream>创建后，当前位置设置为零。</span><span class="sxs-lookup"><span data-stu-id="2b41c-104">When a new instance of <xref:System.IO.MemoryStream> is created, the current position is set to zero.</span></span>  
  
[!INCLUDE[note_unnecessary_dispose](~/includes/note-unnecessary-dispose.md)]
  
 <span data-ttu-id="2b41c-105">创建与非无符号的字节数组的内存流提供无法调整大小的数据的流。</span><span class="sxs-lookup"><span data-stu-id="2b41c-105">Memory streams created with an unsigned byte array provide a non-resizable stream of the data.</span></span> <span data-ttu-id="2b41c-106">时使用的字节数组，您不能将追加到或缩小流，尽管您可能能够修改的现有内容，具体取决于传递到构造函数的参数。</span><span class="sxs-lookup"><span data-stu-id="2b41c-106">When using a byte array, you can neither append to nor shrink the stream, although you might be able to modify the existing contents depending on the parameters passed into the constructor.</span></span> <span data-ttu-id="2b41c-107">空的内存流大小进行调整，并可以写入以及从中读取。</span><span class="sxs-lookup"><span data-stu-id="2b41c-107">Empty memory streams are resizable, and can be written to and read from.</span></span>  
  
 <span data-ttu-id="2b41c-108">如果<xref:System.IO.MemoryStream>对象添加到 ResX 文件或.resources 文件，请调用<xref:System.Resources.ResourceManager.GetStream%2A>方法在运行时对其进行检索。</span><span class="sxs-lookup"><span data-stu-id="2b41c-108">If a <xref:System.IO.MemoryStream> object is added to a ResX file or a .resources file, call the <xref:System.Resources.ResourceManager.GetStream%2A> method at runtime to retrieve it.</span></span>  
  
 <span data-ttu-id="2b41c-109">如果<xref:System.IO.MemoryStream>对象序列化为一个资源文件，它实际上会序列化为<xref:System.IO.UnmanagedMemoryStream>。</span><span class="sxs-lookup"><span data-stu-id="2b41c-109">If a <xref:System.IO.MemoryStream> object is serialized to a resource file it will actually be serialized as an <xref:System.IO.UnmanagedMemoryStream>.</span></span> <span data-ttu-id="2b41c-110">此行为提供更好的性能，以及能够直接，而无需通过获取对数据指针<xref:System.IO.Stream>方法。</span><span class="sxs-lookup"><span data-stu-id="2b41c-110">This behavior provides better performance, as well as the ability to get a pointer to the data directly, without having to go through <xref:System.IO.Stream> methods.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2b41c-111">下面的代码示例演示如何读取和写入将内存用作后备存储的数据。</span><span class="sxs-lookup"><span data-stu-id="2b41c-111">The following code example shows how to read and write data using memory as a backing store.</span></span>  
  
 [!code-cpp[System.IO.MemoryStream#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.MemoryStream/CPP/memstream.cpp#1)]
 [!code-csharp[System.IO.MemoryStream#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.MemoryStream/CS/memstream.cs#1)]
 [!code-vb[System.IO.MemoryStream#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.MemoryStream/VB/memstream.vb#1)]  
  
 ]]></format>
    </remarks>
    <related type="Article" href="~/docs/standard/io/index.md">
      <span data-ttu-id="2b41c-112">文件和流 I/O</span>
      <span class="sxs-lookup">
        <span data-stu-id="2b41c-112">File and Stream I/O</span>
      </span>
    </related>
    <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">
      <span data-ttu-id="2b41c-113">如何：从文件读取文本</span>
      <span class="sxs-lookup">
        <span data-stu-id="2b41c-113">How to: Read Text from a File</span>
      </span>
    </related>
    <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">
      <span data-ttu-id="2b41c-114">如何：向文件写入文本</span>
      <span class="sxs-lookup">
        <span data-stu-id="2b41c-114">How to: Write Text to a File</span>
      </span>
    </related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="2b41c-115">初始化 <see cref="T:System.IO.MemoryStream" /> 类的新实例。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2b41c-115">Initializes a new instance of the <see cref="T:System.IO.MemoryStream" /> class.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MemoryStream ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryStream.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MemoryStream();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="2b41c-116">使用初始化为零的可扩展容量初始化 <see cref="T:System.IO.MemoryStream" /> 类的新实例。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2b41c-116">Initializes a new instance of the <see cref="T:System.IO.MemoryStream" /> class with an expandable capacity initialized to zero.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2b41c-117"><xref:System.IO.MemoryStream.CanRead%2A>， <xref:System.IO.MemoryStream.CanSeek%2A>，并<xref:System.IO.MemoryStream.CanWrite%2A>属性均设置为`true`。</span><span class="sxs-lookup"><span data-stu-id="2b41c-117">The <xref:System.IO.MemoryStream.CanRead%2A>, <xref:System.IO.MemoryStream.CanSeek%2A>, and <xref:System.IO.MemoryStream.CanWrite%2A> properties are all set to `true`.</span></span>  
  
 <span data-ttu-id="2b41c-118">当你使用时自动增加当前流的容量<xref:System.IO.MemoryStream.SetLength%2A>方法设置为值的长度大于当前流的容量。</span><span class="sxs-lookup"><span data-stu-id="2b41c-118">The capacity of the current stream automatically increases when you use the <xref:System.IO.MemoryStream.SetLength%2A> method to set the length to a value larger than the capacity of the current stream.</span></span>  
  
 <span data-ttu-id="2b41c-119">此构造函数将公开基础流，其中<xref:System.IO.MemoryStream.GetBuffer%2A>返回。</span><span class="sxs-lookup"><span data-stu-id="2b41c-119">This constructor exposes the underlying stream, which <xref:System.IO.MemoryStream.GetBuffer%2A> returns.</span></span>  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/io/index.md">
          <span data-ttu-id="2b41c-120">文件和流 I/O</span>
          <span class="sxs-lookup">
            <span data-stu-id="2b41c-120">File and Stream I/O</span>
          </span>
        </related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">
          <span data-ttu-id="2b41c-121">如何：从文件读取文本</span>
          <span class="sxs-lookup">
            <span data-stu-id="2b41c-121">How to: Read Text from a File</span>
          </span>
        </related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">
          <span data-ttu-id="2b41c-122">如何：向文件写入文本</span>
          <span class="sxs-lookup">
            <span data-stu-id="2b41c-122">How to: Write Text to a File</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MemoryStream (byte[] buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(unsigned int8[] buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryStream.#ctor(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (buffer As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MemoryStream(cli::array &lt;System::Byte&gt; ^ buffer);" />
      <MemberSignature Language="F#" Value="new System.IO.MemoryStream : byte[] -&gt; System.IO.MemoryStream" Usage="new System.IO.MemoryStream buffer" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="buffer">
          <span data-ttu-id="2b41c-123">从中创建当前流的无符号字节数组。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2b41c-123">The array of unsigned bytes from which to create the current stream.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="2b41c-124">基于指定的字节数组初始化 <see cref="T:System.IO.MemoryStream" /> 类的无法调整大小的新实例。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2b41c-124">Initializes a new non-resizable instance of the <see cref="T:System.IO.MemoryStream" /> class based on the specified byte array.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2b41c-125"><xref:System.IO.MemoryStream.CanRead%2A>， <xref:System.IO.MemoryStream.CanSeek%2A>，并<xref:System.IO.MemoryStream.CanWrite%2A>属性均设置为`true`。</span><span class="sxs-lookup"><span data-stu-id="2b41c-125">The <xref:System.IO.MemoryStream.CanRead%2A>, <xref:System.IO.MemoryStream.CanSeek%2A>, and <xref:System.IO.MemoryStream.CanWrite%2A> properties are all set to `true`.</span></span> <span data-ttu-id="2b41c-126"><xref:System.IO.MemoryStream.Capacity%2A> 设置为指定的字节数组的长度。</span><span class="sxs-lookup"><span data-stu-id="2b41c-126"><xref:System.IO.MemoryStream.Capacity%2A> is set to the length of the specified byte array.</span></span> <span data-ttu-id="2b41c-127">新的流可以写入，但不是可调整大小。</span><span class="sxs-lookup"><span data-stu-id="2b41c-127">The new stream can be written to, but is not resizable.</span></span>  
  
 <span data-ttu-id="2b41c-128">流的长度不能设置为一个值大于指定的字节数组; 的初始长度但是，可以截断流 (请参阅<xref:System.IO.MemoryStream.SetLength%2A>)。</span><span class="sxs-lookup"><span data-stu-id="2b41c-128">The length of the stream cannot be set to a value greater than the initial length of the specified byte array; however, the stream can be truncated (see <xref:System.IO.MemoryStream.SetLength%2A>).</span></span>  
  
 <span data-ttu-id="2b41c-129">此构造函数不会公开基础流。</span><span class="sxs-lookup"><span data-stu-id="2b41c-129">This constructor does not expose the underlying stream.</span></span> <span data-ttu-id="2b41c-130"><xref:System.IO.MemoryStream.GetBuffer%2A> 引发<xref:System.UnauthorizedAccessException>。</span><span class="sxs-lookup"><span data-stu-id="2b41c-130"><xref:System.IO.MemoryStream.GetBuffer%2A> throws <xref:System.UnauthorizedAccessException>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="2b41c-131">
            <paramref name="buffer" /> 为 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2b41c-131">
              <paramref name="buffer" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <related type="Article" href="~/docs/standard/io/index.md">
          <span data-ttu-id="2b41c-132">文件和流 I/O</span>
          <span class="sxs-lookup">
            <span data-stu-id="2b41c-132">File and Stream I/O</span>
          </span>
        </related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">
          <span data-ttu-id="2b41c-133">如何：从文件读取文本</span>
          <span class="sxs-lookup">
            <span data-stu-id="2b41c-133">How to: Read Text from a File</span>
          </span>
        </related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">
          <span data-ttu-id="2b41c-134">如何：向文件写入文本</span>
          <span class="sxs-lookup">
            <span data-stu-id="2b41c-134">How to: Write Text to a File</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MemoryStream (int capacity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 capacity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryStream.#ctor(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (capacity As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MemoryStream(int capacity);" />
      <MemberSignature Language="F#" Value="new System.IO.MemoryStream : int -&gt; System.IO.MemoryStream" Usage="new System.IO.MemoryStream capacity" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="capacity" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="capacity">
          <span data-ttu-id="2b41c-135">内部数组的初始大小（以字节为单位）。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2b41c-135">The initial size of the internal array in bytes.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="2b41c-136">使用按指定要求初始化的可扩展容量初始化 <see cref="T:System.IO.MemoryStream" /> 类的新实例。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2b41c-136">Initializes a new instance of the <see cref="T:System.IO.MemoryStream" /> class with an expandable capacity initialized as specified.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2b41c-137"><xref:System.IO.MemoryStream.CanRead%2A>， <xref:System.IO.MemoryStream.CanSeek%2A>，并<xref:System.IO.MemoryStream.CanWrite%2A>属性均设置为`true`。</span><span class="sxs-lookup"><span data-stu-id="2b41c-137">The <xref:System.IO.MemoryStream.CanRead%2A>, <xref:System.IO.MemoryStream.CanSeek%2A>, and <xref:System.IO.MemoryStream.CanWrite%2A> properties are all set to `true`.</span></span>  
  
 <span data-ttu-id="2b41c-138">当你使用时自动增加容量<xref:System.IO.MemoryStream.SetLength%2A>方法设置为值的长度大于当前流的容量。</span><span class="sxs-lookup"><span data-stu-id="2b41c-138">The capacity automatically increases when you use the <xref:System.IO.MemoryStream.SetLength%2A> method to set the length to a value larger than the capacity of the current stream.</span></span> <span data-ttu-id="2b41c-139">除`MemoryStream`使用 byte [] 参数构造的写入操作的末尾`MemoryStream`展开`MemoryStream`。</span><span class="sxs-lookup"><span data-stu-id="2b41c-139">Except for a `MemoryStream` constructed with a byte[] parameter, write operations at the end of a `MemoryStream` expand the `MemoryStream`.</span></span>  
  
 <span data-ttu-id="2b41c-140">此构造函数将公开基础流<xref:System.IO.MemoryStream.GetBuffer%2A>返回。</span><span class="sxs-lookup"><span data-stu-id="2b41c-140">This constructor exposes the underlying stream that <xref:System.IO.MemoryStream.GetBuffer%2A> returns.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2b41c-141">此代码示例是为提供一个更大示例的一部分<xref:System.IO.MemoryStream>类。</span><span class="sxs-lookup"><span data-stu-id="2b41c-141">This code example is part of a larger example provided for the <xref:System.IO.MemoryStream> class.</span></span>  
  
 [!code-cpp[System.IO.MemoryStream#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.MemoryStream/CPP/memstream.cpp#2)]
 [!code-csharp[System.IO.MemoryStream#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.MemoryStream/CS/memstream.cs#2)]
 [!code-vb[System.IO.MemoryStream#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.MemoryStream/VB/memstream.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="2b41c-142">
            <paramref name="capacity" /> 为负数。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2b41c-142">
              <paramref name="capacity" /> is negative.</span>
          </span>
        </exception>
        <related type="Article" href="~/docs/standard/io/index.md">
          <span data-ttu-id="2b41c-143">文件和流 I/O</span>
          <span class="sxs-lookup">
            <span data-stu-id="2b41c-143">File and Stream I/O</span>
          </span>
        </related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">
          <span data-ttu-id="2b41c-144">如何：从文件读取文本</span>
          <span class="sxs-lookup">
            <span data-stu-id="2b41c-144">How to: Read Text from a File</span>
          </span>
        </related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">
          <span data-ttu-id="2b41c-145">如何：向文件写入文本</span>
          <span class="sxs-lookup">
            <span data-stu-id="2b41c-145">How to: Write Text to a File</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MemoryStream (byte[] buffer, bool writable);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(unsigned int8[] buffer, bool writable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryStream.#ctor(System.Byte[],System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (buffer As Byte(), writable As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MemoryStream(cli::array &lt;System::Byte&gt; ^ buffer, bool writable);" />
      <MemberSignature Language="F#" Value="new System.IO.MemoryStream : byte[] * bool -&gt; System.IO.MemoryStream" Usage="new System.IO.MemoryStream (buffer, writable)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="writable" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="buffer">
          <span data-ttu-id="2b41c-146">从中创建此流的无符号字节的数组。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2b41c-146">The array of unsigned bytes from which to create this stream.</span>
          </span>
        </param>
        <param name="writable">
          <span data-ttu-id="2b41c-147">
            <see cref="P:System.IO.MemoryStream.CanWrite" /> 属性的设置，确定该流是否支持写入。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2b41c-147">The setting of the <see cref="P:System.IO.MemoryStream.CanWrite" /> property, which determines whether the stream supports writing.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="2b41c-148">在 <see cref="P:System.IO.MemoryStream.CanWrite" /> 属性按指定设置的状态下，基于指定的字节数组初始化 <see cref="T:System.IO.MemoryStream" /> 类的无法调整大小的新实例。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2b41c-148">Initializes a new non-resizable instance of the <see cref="T:System.IO.MemoryStream" /> class based on the specified byte array with the <see cref="P:System.IO.MemoryStream.CanWrite" /> property set as specified.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2b41c-149"><xref:System.IO.MemoryStream.CanRead%2A>并<xref:System.IO.MemoryStream.CanSeek%2A>属性均设置为`true`。</span><span class="sxs-lookup"><span data-stu-id="2b41c-149">The <xref:System.IO.MemoryStream.CanRead%2A> and <xref:System.IO.MemoryStream.CanSeek%2A> properties are both set to `true`.</span></span> <span data-ttu-id="2b41c-150"><xref:System.IO.MemoryStream.Capacity%2A> 设置为指定的字节数组的长度。</span><span class="sxs-lookup"><span data-stu-id="2b41c-150"><xref:System.IO.MemoryStream.Capacity%2A> is set to the length of the specified byte array.</span></span>  
  
 <span data-ttu-id="2b41c-151">流的长度不能设置为一个值大于指定的字节数组; 的初始长度但是，可以截断流 (请参阅<xref:System.IO.MemoryStream.SetLength%2A>)。</span><span class="sxs-lookup"><span data-stu-id="2b41c-151">The length of the stream cannot be set to a value greater than the initial length of the specified byte array; however, the stream can be truncated (see <xref:System.IO.MemoryStream.SetLength%2A>).</span></span>  
  
 <span data-ttu-id="2b41c-152">此构造函数不会公开基础流。</span><span class="sxs-lookup"><span data-stu-id="2b41c-152">This constructor does not expose the underlying stream.</span></span> <span data-ttu-id="2b41c-153"><xref:System.IO.MemoryStream.GetBuffer%2A> 引发<xref:System.UnauthorizedAccessException>。</span><span class="sxs-lookup"><span data-stu-id="2b41c-153"><xref:System.IO.MemoryStream.GetBuffer%2A> throws <xref:System.UnauthorizedAccessException>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="2b41c-154">
            <paramref name="buffer" /> 为 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2b41c-154">
              <paramref name="buffer" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <related type="Article" href="~/docs/standard/io/index.md">
          <span data-ttu-id="2b41c-155">文件和流 I/O</span>
          <span class="sxs-lookup">
            <span data-stu-id="2b41c-155">File and Stream I/O</span>
          </span>
        </related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">
          <span data-ttu-id="2b41c-156">如何：从文件读取文本</span>
          <span class="sxs-lookup">
            <span data-stu-id="2b41c-156">How to: Read Text from a File</span>
          </span>
        </related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">
          <span data-ttu-id="2b41c-157">如何：向文件写入文本</span>
          <span class="sxs-lookup">
            <span data-stu-id="2b41c-157">How to: Write Text to a File</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MemoryStream (byte[] buffer, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(unsigned int8[] buffer, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryStream.#ctor(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (buffer As Byte(), index As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MemoryStream(cli::array &lt;System::Byte&gt; ^ buffer, int index, int count);" />
      <MemberSignature Language="F#" Value="new System.IO.MemoryStream : byte[] * int * int -&gt; System.IO.MemoryStream" Usage="new System.IO.MemoryStream (buffer, index, count)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">
          <span data-ttu-id="2b41c-158">从中创建此流的无符号字节的数组。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2b41c-158">The array of unsigned bytes from which to create this stream.</span>
          </span>
        </param>
        <param name="index">
          <span data-ttu-id="2b41c-159">
            <c>buffer</c> 内的索引，流从此处开始。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2b41c-159">The index into <c>buffer</c> at which the stream begins.</span>
          </span>
        </param>
        <param name="count">
          <span data-ttu-id="2b41c-160">流的长度（以字节为单位）。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2b41c-160">The length of the stream in bytes.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="2b41c-161">基于字节数组的指定区域（索引）初始化 <see cref="T:System.IO.MemoryStream" /> 类的无法调整大小的新实例。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2b41c-161">Initializes a new non-resizable instance of the <see cref="T:System.IO.MemoryStream" /> class based on the specified region (index) of a byte array.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2b41c-162"><xref:System.IO.MemoryStream.CanRead%2A>， <xref:System.IO.MemoryStream.CanSeek%2A>，并<xref:System.IO.MemoryStream.CanWrite%2A>属性均设置为`true`，但不能更改容量。</span><span class="sxs-lookup"><span data-stu-id="2b41c-162">The <xref:System.IO.MemoryStream.CanRead%2A>, <xref:System.IO.MemoryStream.CanSeek%2A>, and <xref:System.IO.MemoryStream.CanWrite%2A> properties are all set to `true`, but the capacity cannot be changed.</span></span> <span data-ttu-id="2b41c-163">将 <xref:System.IO.MemoryStream.Capacity%2A> 设置为 `count`。</span><span class="sxs-lookup"><span data-stu-id="2b41c-163"><xref:System.IO.MemoryStream.Capacity%2A> is set to `count`.</span></span>  
  
 <span data-ttu-id="2b41c-164">流的长度不能设置为一个值大于指定的字节数组; 的初始长度但是，可以截断流 (请参阅<xref:System.IO.MemoryStream.SetLength%2A>)。</span><span class="sxs-lookup"><span data-stu-id="2b41c-164">The length of the stream cannot be set to a value greater than the initial length of the specified byte array; however, the stream can be truncated (see <xref:System.IO.MemoryStream.SetLength%2A>).</span></span>  
  
 <span data-ttu-id="2b41c-165">此构造函数不会公开基础流。</span><span class="sxs-lookup"><span data-stu-id="2b41c-165">This constructor does not expose the underlying stream.</span></span> <span data-ttu-id="2b41c-166"><xref:System.IO.MemoryStream.GetBuffer%2A> 引发<xref:System.UnauthorizedAccessException>。</span><span class="sxs-lookup"><span data-stu-id="2b41c-166"><xref:System.IO.MemoryStream.GetBuffer%2A> throws <xref:System.UnauthorizedAccessException>.</span></span> <span data-ttu-id="2b41c-167">但是，可以写入到流。</span><span class="sxs-lookup"><span data-stu-id="2b41c-167">However, you can write to the stream.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="2b41c-168">
            <paramref name="buffer" /> 为 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2b41c-168">
              <paramref name="buffer" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="2b41c-169">
            <paramref name="index" /> 或 <paramref name="count" /> 小于零。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2b41c-169">
              <paramref name="index" /> or <paramref name="count" /> is less than zero.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="2b41c-170">缓冲区长度减去 <paramref name="index" /> 小于 <paramref name="count" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2b41c-170">The buffer length minus <paramref name="index" /> is less than <paramref name="count" />.</span>
          </span>
        </exception>
        <related type="Article" href="~/docs/standard/io/index.md">
          <span data-ttu-id="2b41c-171">文件和流 I/O</span>
          <span class="sxs-lookup">
            <span data-stu-id="2b41c-171">File and Stream I/O</span>
          </span>
        </related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">
          <span data-ttu-id="2b41c-172">如何：从文件读取文本</span>
          <span class="sxs-lookup">
            <span data-stu-id="2b41c-172">How to: Read Text from a File</span>
          </span>
        </related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">
          <span data-ttu-id="2b41c-173">如何：向文件写入文本</span>
          <span class="sxs-lookup">
            <span data-stu-id="2b41c-173">How to: Write Text to a File</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MemoryStream (byte[] buffer, int index, int count, bool writable);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(unsigned int8[] buffer, int32 index, int32 count, bool writable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryStream.#ctor(System.Byte[],System.Int32,System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (buffer As Byte(), index As Integer, count As Integer, writable As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MemoryStream(cli::array &lt;System::Byte&gt; ^ buffer, int index, int count, bool writable);" />
      <MemberSignature Language="F#" Value="new System.IO.MemoryStream : byte[] * int * int * bool -&gt; System.IO.MemoryStream" Usage="new System.IO.MemoryStream (buffer, index, count, writable)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="writable" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="buffer">
          <span data-ttu-id="2b41c-174">从中创建此流的无符号字节的数组。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2b41c-174">The array of unsigned bytes from which to create this stream.</span>
          </span>
        </param>
        <param name="index">
          <span data-ttu-id="2b41c-175">
            <c>buffer</c> 内的索引，流从此处开始。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2b41c-175">The index in <c>buffer</c> at which the stream begins.</span>
          </span>
        </param>
        <param name="count">
          <span data-ttu-id="2b41c-176">流的长度（以字节为单位）。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2b41c-176">The length of the stream in bytes.</span>
          </span>
        </param>
        <param name="writable">
          <span data-ttu-id="2b41c-177">
            <see cref="P:System.IO.MemoryStream.CanWrite" /> 属性的设置，确定该流是否支持写入。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2b41c-177">The setting of the <see cref="P:System.IO.MemoryStream.CanWrite" /> property, which determines whether the stream supports writing.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="2b41c-178">在 <see cref="P:System.IO.MemoryStream.CanWrite" /> 属性按指定设置的状态下，基于字节数组的指定区域，初始化 <see cref="T:System.IO.MemoryStream" /> 类的无法调整大小的新实例。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2b41c-178">Initializes a new non-resizable instance of the <see cref="T:System.IO.MemoryStream" /> class based on the specified region of a byte array, with the <see cref="P:System.IO.MemoryStream.CanWrite" /> property set as specified.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2b41c-179"><xref:System.IO.MemoryStream.CanRead%2A>并<xref:System.IO.MemoryStream.CanSeek%2A>属性均设置为`true`。</span><span class="sxs-lookup"><span data-stu-id="2b41c-179">The <xref:System.IO.MemoryStream.CanRead%2A> and <xref:System.IO.MemoryStream.CanSeek%2A> properties are both set to `true`.</span></span> <span data-ttu-id="2b41c-180">将 <xref:System.IO.MemoryStream.Capacity%2A> 设置为 `count`。</span><span class="sxs-lookup"><span data-stu-id="2b41c-180"><xref:System.IO.MemoryStream.Capacity%2A> is set to `count`.</span></span>  
  
 <span data-ttu-id="2b41c-181">流的长度不能设置为一个值大于指定的字节数组; 的初始长度但是，可以截断流 (请参阅<xref:System.IO.MemoryStream.SetLength%2A>)。</span><span class="sxs-lookup"><span data-stu-id="2b41c-181">The length of the stream cannot be set to a value greater than the initial length of the specified byte array; however, the stream can be truncated (see <xref:System.IO.MemoryStream.SetLength%2A>).</span></span>  
  
 <span data-ttu-id="2b41c-182">此构造函数不会公开基础流。</span><span class="sxs-lookup"><span data-stu-id="2b41c-182">This constructor does not expose the underlying stream.</span></span> <span data-ttu-id="2b41c-183"><xref:System.IO.MemoryStream.GetBuffer%2A> 引发<xref:System.UnauthorizedAccessException>。</span><span class="sxs-lookup"><span data-stu-id="2b41c-183"><xref:System.IO.MemoryStream.GetBuffer%2A> throws <xref:System.UnauthorizedAccessException>.</span></span> <span data-ttu-id="2b41c-184">但是，您可以写入到流如果`writable`是`true`。</span><span class="sxs-lookup"><span data-stu-id="2b41c-184">However, you can write to the stream if `writable` is `true`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="2b41c-185">
            <paramref name="buffer" /> 为 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2b41c-185">
              <paramref name="buffer" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="2b41c-186">
            <paramref name="index" /> 或 <paramref name="count" /> 为负。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2b41c-186">
              <paramref name="index" /> or <paramref name="count" /> are negative.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="2b41c-187">缓冲区长度减去 <paramref name="index" /> 小于 <paramref name="count" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2b41c-187">The buffer length minus <paramref name="index" /> is less than <paramref name="count" />.</span>
          </span>
        </exception>
        <related type="Article" href="~/docs/standard/io/index.md">
          <span data-ttu-id="2b41c-188">文件和流 I/O</span>
          <span class="sxs-lookup">
            <span data-stu-id="2b41c-188">File and Stream I/O</span>
          </span>
        </related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">
          <span data-ttu-id="2b41c-189">如何：从文件读取文本</span>
          <span class="sxs-lookup">
            <span data-stu-id="2b41c-189">How to: Read Text from a File</span>
          </span>
        </related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">
          <span data-ttu-id="2b41c-190">如何：向文件写入文本</span>
          <span class="sxs-lookup">
            <span data-stu-id="2b41c-190">How to: Write Text to a File</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MemoryStream (byte[] buffer, int index, int count, bool writable, bool publiclyVisible);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(unsigned int8[] buffer, int32 index, int32 count, bool writable, bool publiclyVisible) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryStream.#ctor(System.Byte[],System.Int32,System.Int32,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (buffer As Byte(), index As Integer, count As Integer, writable As Boolean, publiclyVisible As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MemoryStream(cli::array &lt;System::Byte&gt; ^ buffer, int index, int count, bool writable, bool publiclyVisible);" />
      <MemberSignature Language="F#" Value="new System.IO.MemoryStream : byte[] * int * int * bool * bool -&gt; System.IO.MemoryStream" Usage="new System.IO.MemoryStream (buffer, index, count, writable, publiclyVisible)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="writable" Type="System.Boolean" />
        <Parameter Name="publiclyVisible" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="buffer">
          <span data-ttu-id="2b41c-191">从中创建此流的无符号字节的数组。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2b41c-191">The array of unsigned bytes from which to create this stream.</span>
          </span>
        </param>
        <param name="index">
          <span data-ttu-id="2b41c-192">
            <c>buffer</c> 内的索引，流从此处开始。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2b41c-192">The index into <c>buffer</c> at which the stream begins.</span>
          </span>
        </param>
        <param name="count">
          <span data-ttu-id="2b41c-193">流的长度（以字节为单位）。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2b41c-193">The length of the stream in bytes.</span>
          </span>
        </param>
        <param name="writable">
          <span data-ttu-id="2b41c-194">
            <see cref="P:System.IO.MemoryStream.CanWrite" /> 属性的设置，确定该流是否支持写入。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2b41c-194">The setting of the <see cref="P:System.IO.MemoryStream.CanWrite" /> property, which determines whether the stream supports writing.</span>
          </span>
        </param>
        <param name="publiclyVisible">
          <span data-ttu-id="2b41c-195">设置为 <see langword="true" /> 可以启用 <see cref="M:System.IO.MemoryStream.GetBuffer" />，它返回无符号字节数组，流从该数组创建；否则为 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2b41c-195">
              <see langword="true" /> to enable <see cref="M:System.IO.MemoryStream.GetBuffer" />, which returns the unsigned byte array from which the stream was created; otherwise, <see langword="false" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="2b41c-196">在 <see cref="P:System.IO.MemoryStream.CanWrite" /> 属性和调用 <see cref="M:System.IO.MemoryStream.GetBuffer" /> 的能力按指定设置的状态下，基于字节数组的指定区域初始化 <see cref="T:System.IO.MemoryStream" /> 类的新实例。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2b41c-196">Initializes a new instance of the <see cref="T:System.IO.MemoryStream" /> class based on the specified region of a byte array, with the <see cref="P:System.IO.MemoryStream.CanWrite" /> property set as specified, and the ability to call <see cref="M:System.IO.MemoryStream.GetBuffer" /> set as specified.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2b41c-197"><xref:System.IO.MemoryStream.CanRead%2A>并<xref:System.IO.MemoryStream.CanSeek%2A>属性均设置为`true`。</span><span class="sxs-lookup"><span data-stu-id="2b41c-197">The <xref:System.IO.MemoryStream.CanRead%2A> and <xref:System.IO.MemoryStream.CanSeek%2A> properties are both set to `true`.</span></span> <span data-ttu-id="2b41c-198">将 <xref:System.IO.MemoryStream.Capacity%2A> 设置为 `count`。</span><span class="sxs-lookup"><span data-stu-id="2b41c-198"><xref:System.IO.MemoryStream.Capacity%2A> is set to `count`.</span></span>  
  
 <span data-ttu-id="2b41c-199">在新的流实例都可以写入，但<xref:System.IO.MemoryStream.Capacity%2A>不能更改基础字节数组。</span><span class="sxs-lookup"><span data-stu-id="2b41c-199">The new stream instance can be written to, but the <xref:System.IO.MemoryStream.Capacity%2A> of the underlying byte array cannot be changed.</span></span> <span data-ttu-id="2b41c-200">流的长度不能设置为一个值大于指定的字节数组; 的初始长度但是，可以截断流 (请参阅<xref:System.IO.MemoryStream.SetLength%2A>)。</span><span class="sxs-lookup"><span data-stu-id="2b41c-200">The length of the stream cannot be set to a value greater than the initial length of the specified byte array; however, the stream can be truncated (see <xref:System.IO.MemoryStream.SetLength%2A>).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="2b41c-201">
            <paramref name="buffer" /> 为 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2b41c-201">
              <paramref name="buffer" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="2b41c-202">
            <paramref name="index" /> 或 <paramref name="count" /> 为负数。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2b41c-202">
              <paramref name="index" /> or <paramref name="count" /> is negative.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="2b41c-203">缓冲区长度减去 <paramref name="index" /> 小于 <paramref name="count" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2b41c-203">The buffer length minus <paramref name="index" /> is less than <paramref name="count" />.</span>
          </span>
        </exception>
        <related type="Article" href="~/docs/standard/io/index.md">
          <span data-ttu-id="2b41c-204">文件和流 I/O</span>
          <span class="sxs-lookup">
            <span data-stu-id="2b41c-204">File and Stream I/O</span>
          </span>
        </related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">
          <span data-ttu-id="2b41c-205">如何：从文件读取文本</span>
          <span class="sxs-lookup">
            <span data-stu-id="2b41c-205">How to: Read Text from a File</span>
          </span>
        </related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">
          <span data-ttu-id="2b41c-206">如何：向文件写入文本</span>
          <span class="sxs-lookup">
            <span data-stu-id="2b41c-206">How to: Write Text to a File</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="BeginRead">
      <MemberSignature Language="C#" Value="public override IAsyncResult BeginRead (byte[] buffer, int offset, int count, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IAsyncResult BeginRead(unsigned int8[] buffer, int32 offset, int32 count, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function BeginRead (buffer As Byte(), offset As Integer, count As Integer, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override IAsyncResult ^ BeginRead(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="override this.BeginRead : byte[] * int * int * AsyncCallback * obj -&gt; IAsyncResult" Usage="memoryStream.BeginRead (buffer, offset, count, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <param name="offset">To be added.</param>
        <param name="count">To be added.</param>
        <param name="callback">To be added.</param>
        <param name="state">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginWrite">
      <MemberSignature Language="C#" Value="public override IAsyncResult BeginWrite (byte[] buffer, int offset, int count, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IAsyncResult BeginWrite(unsigned int8[] buffer, int32 offset, int32 count, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function BeginWrite (buffer As Byte(), offset As Integer, count As Integer, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override IAsyncResult ^ BeginWrite(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="override this.BeginWrite : byte[] * int * int * AsyncCallback * obj -&gt; IAsyncResult" Usage="memoryStream.BeginWrite (buffer, offset, count, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <param name="offset">To be added.</param>
        <param name="count">To be added.</param>
        <param name="callback">To be added.</param>
        <param name="state">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CanRead">
      <MemberSignature Language="C#" Value="public override bool CanRead { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanRead" />
      <MemberSignature Language="DocId" Value="P:System.IO.MemoryStream.CanRead" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanRead As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanRead { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanRead : bool" Usage="System.IO.MemoryStream.CanRead" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="2b41c-207">获取一个值，该值指示当前流是否支持读取。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2b41c-207">Gets a value indicating whether the current stream supports reading.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="2b41c-208">如果流是打开的，则为 <see langword="true" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2b41c-208">
              <see langword="true" /> if the stream is open.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2b41c-209">如果一个类派生自<xref:System.IO.Stream>不支持读取，而对调用<xref:System.IO.MemoryStream.Read%2A>并<xref:System.IO.MemoryStream.ReadByte%2A>方法将引发<xref:System.NotSupportedException>。</span><span class="sxs-lookup"><span data-stu-id="2b41c-209">If a class derived from <xref:System.IO.Stream> does not support reading, calls to the <xref:System.IO.MemoryStream.Read%2A> and <xref:System.IO.MemoryStream.ReadByte%2A> methods throw a <xref:System.NotSupportedException>.</span></span>  
  
 <span data-ttu-id="2b41c-210">如果流已关闭，此属性返回`false`。</span><span class="sxs-lookup"><span data-stu-id="2b41c-210">If the stream is closed, this property returns `false`.</span></span>  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/io/index.md">
          <span data-ttu-id="2b41c-211">文件和流 I/O</span>
          <span class="sxs-lookup">
            <span data-stu-id="2b41c-211">File and Stream I/O</span>
          </span>
        </related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">
          <span data-ttu-id="2b41c-212">如何：从文件读取文本</span>
          <span class="sxs-lookup">
            <span data-stu-id="2b41c-212">How to: Read Text from a File</span>
          </span>
        </related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">
          <span data-ttu-id="2b41c-213">如何：向文件写入文本</span>
          <span class="sxs-lookup">
            <span data-stu-id="2b41c-213">How to: Write Text to a File</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="CanSeek">
      <MemberSignature Language="C#" Value="public override bool CanSeek { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanSeek" />
      <MemberSignature Language="DocId" Value="P:System.IO.MemoryStream.CanSeek" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanSeek As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanSeek { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanSeek : bool" Usage="System.IO.MemoryStream.CanSeek" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="2b41c-214">获取一个值，该值指示当前流是否支持查找。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2b41c-214">Gets a value indicating whether the current stream supports seeking.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="2b41c-215">如果流是打开的，则为 <see langword="true" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2b41c-215">
              <see langword="true" /> if the stream is open.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2b41c-216">如果一个类派生自<xref:System.IO.Stream>不支持查找，则调用<xref:System.IO.MemoryStream.Length%2A>， <xref:System.IO.MemoryStream.SetLength%2A>， <xref:System.IO.MemoryStream.Position%2A>，并<xref:System.IO.MemoryStream.Seek%2A>引发<xref:System.NotSupportedException>。</span><span class="sxs-lookup"><span data-stu-id="2b41c-216">If a class derived from <xref:System.IO.Stream> does not support seeking, calls to <xref:System.IO.MemoryStream.Length%2A>, <xref:System.IO.MemoryStream.SetLength%2A>, <xref:System.IO.MemoryStream.Position%2A>, and <xref:System.IO.MemoryStream.Seek%2A> throw a <xref:System.NotSupportedException>.</span></span>  
  
 <span data-ttu-id="2b41c-217">如果流已关闭，此属性返回`false`。</span><span class="sxs-lookup"><span data-stu-id="2b41c-217">If the stream is closed, this property returns `false`.</span></span>  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/io/index.md">
          <span data-ttu-id="2b41c-218">文件和流 I/O</span>
          <span class="sxs-lookup">
            <span data-stu-id="2b41c-218">File and Stream I/O</span>
          </span>
        </related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">
          <span data-ttu-id="2b41c-219">如何：从文件读取文本</span>
          <span class="sxs-lookup">
            <span data-stu-id="2b41c-219">How to: Read Text from a File</span>
          </span>
        </related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">
          <span data-ttu-id="2b41c-220">如何：向文件写入文本</span>
          <span class="sxs-lookup">
            <span data-stu-id="2b41c-220">How to: Write Text to a File</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="CanWrite">
      <MemberSignature Language="C#" Value="public override bool CanWrite { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanWrite" />
      <MemberSignature Language="DocId" Value="P:System.IO.MemoryStream.CanWrite" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanWrite As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanWrite { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanWrite : bool" Usage="System.IO.MemoryStream.CanWrite" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="2b41c-221">获取一个值，该值指示当前流是否支持写入。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2b41c-221">Gets a value indicating whether the current stream supports writing.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="2b41c-222">如果流支持写入，则为 <see langword="true" />；否则为 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2b41c-222">
              <see langword="true" /> if the stream supports writing; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2b41c-223">如果一个类派生自<xref:System.IO.Stream>不支持写入，调用<xref:System.IO.Stream.SetLength%2A>， <xref:System.IO.Stream.Write%2A>，或<xref:System.IO.Stream.WriteByte%2A>引发<xref:System.NotSupportedException>。</span><span class="sxs-lookup"><span data-stu-id="2b41c-223">If a class derived from <xref:System.IO.Stream> does not support writing, a call to <xref:System.IO.Stream.SetLength%2A>, <xref:System.IO.Stream.Write%2A>, or <xref:System.IO.Stream.WriteByte%2A> throws a <xref:System.NotSupportedException>.</span></span>  
  
 <span data-ttu-id="2b41c-224">如果流已关闭，此属性返回`false`。</span><span class="sxs-lookup"><span data-stu-id="2b41c-224">If the stream is closed, this property returns `false`.</span></span>  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/io/index.md">
          <span data-ttu-id="2b41c-225">文件和流 I/O</span>
          <span class="sxs-lookup">
            <span data-stu-id="2b41c-225">File and Stream I/O</span>
          </span>
        </related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">
          <span data-ttu-id="2b41c-226">如何：从文件读取文本</span>
          <span class="sxs-lookup">
            <span data-stu-id="2b41c-226">How to: Read Text from a File</span>
          </span>
        </related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">
          <span data-ttu-id="2b41c-227">如何：向文件写入文本</span>
          <span class="sxs-lookup">
            <span data-stu-id="2b41c-227">How to: Write Text to a File</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="Capacity">
      <MemberSignature Language="C#" Value="public virtual int Capacity { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Capacity" />
      <MemberSignature Language="DocId" Value="P:System.IO.MemoryStream.Capacity" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property Capacity As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int Capacity { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.Capacity : int with get, set" Usage="System.IO.MemoryStream.Capacity" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="2b41c-228">获取或设置分配给该流的字节数。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2b41c-228">Gets or sets the number of bytes allocated for this stream.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="2b41c-229">流的缓冲区的可使用部分的长度。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2b41c-229">The length of the usable portion of the buffer for the stream.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2b41c-230">`Capacity` 是系统提供的字节数组的缓冲区长度。</span><span class="sxs-lookup"><span data-stu-id="2b41c-230">`Capacity` is the buffer length for system-provided byte arrays.</span></span> <span data-ttu-id="2b41c-231">`Capacity` 不能设置为小于流的当前长度的值。</span><span class="sxs-lookup"><span data-stu-id="2b41c-231">`Capacity` cannot be set to a value less than the current length of the stream.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2b41c-232">此代码示例是为提供一个更大示例的一部分<xref:System.IO.MemoryStream>类。</span><span class="sxs-lookup"><span data-stu-id="2b41c-232">This code example is part of a larger example provided for the <xref:System.IO.MemoryStream> class.</span></span>  
  
 [!code-cpp[System.IO.MemoryStream#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.MemoryStream/CPP/memstream.cpp#5)]
 [!code-csharp[System.IO.MemoryStream#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.MemoryStream/CS/memstream.cs#5)]
 [!code-vb[System.IO.MemoryStream#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.MemoryStream/VB/memstream.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="2b41c-233">容量设置为负或小于流的当前长度。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2b41c-233">A capacity is set that is negative or less than the current length of the stream.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="2b41c-234">当前流已关闭。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2b41c-234">The current stream is closed.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="2b41c-235">对不能修改其容量的流调用 <see langword="set" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2b41c-235">
              <see langword="set" /> is invoked on a stream whose capacity cannot be modified.</span>
          </span>
        </exception>
        <related type="Article" href="~/docs/standard/io/index.md">
          <span data-ttu-id="2b41c-236">文件和流 I/O</span>
          <span class="sxs-lookup">
            <span data-stu-id="2b41c-236">File and Stream I/O</span>
          </span>
        </related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">
          <span data-ttu-id="2b41c-237">如何：从文件读取文本</span>
          <span class="sxs-lookup">
            <span data-stu-id="2b41c-237">How to: Read Text from a File</span>
          </span>
        </related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">
          <span data-ttu-id="2b41c-238">如何：向文件写入文本</span>
          <span class="sxs-lookup">
            <span data-stu-id="2b41c-238">How to: Write Text to a File</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public override void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryStream.Close" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Close();" />
      <MemberSignature Language="F#" Value="override this.Close : unit -&gt; unit" Usage="memoryStream.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public override void CopyTo (System.IO.Stream destination, int bufferSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void CopyTo(class System.IO.Stream destination, int32 bufferSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryStream.CopyTo(System.IO.Stream,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub CopyTo (destination As Stream, bufferSize As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void CopyTo(System::IO::Stream ^ destination, int bufferSize);" />
      <MemberSignature Language="F#" Value="override this.CopyTo : System.IO.Stream * int -&gt; unit" Usage="memoryStream.CopyTo (destination, bufferSize)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.IO.Stream" />
        <Parameter Name="bufferSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="destination">To be added.</param>
        <param name="bufferSize">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CopyToAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.Task CopyToAsync (System.IO.Stream destination, int bufferSize, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Threading.Tasks.Task CopyToAsync(class System.IO.Stream destination, int32 bufferSize, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryStream.CopyToAsync(System.IO.Stream,System.Int32,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Threading::Tasks::Task ^ CopyToAsync(System::IO::Stream ^ destination, int bufferSize, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="override this.CopyToAsync : System.IO.Stream * int * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="memoryStream.CopyToAsync (destination, bufferSize, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.IO.Stream" />
        <Parameter Name="bufferSize" Type="System.Int32" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="destination">
          <span data-ttu-id="2b41c-239">当前流的内容将复制到的流。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2b41c-239">The stream to which the contents of the current stream will be copied.</span>
          </span>
        </param>
        <param name="bufferSize">
          <span data-ttu-id="2b41c-240">缓冲区的大小（以字节为单位）。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2b41c-240">The size, in bytes, of the buffer.</span>
          </span>
          <span data-ttu-id="2b41c-241">此值必须大于零。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2b41c-241">This value must be greater than zero.</span>
          </span>
        </param>
        <param name="cancellationToken">
          <span data-ttu-id="2b41c-242">要监视取消请求的标记。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2b41c-242">The token to monitor for cancellation requests.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="2b41c-243">使用指定的缓冲区大小和取消令牌，从当前流中异步读取所有字节并将其写入到另一个流中。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2b41c-243">Asynchronously reads all the bytes from the current stream and writes them to another stream, using a specified buffer size and cancellation token.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="2b41c-244">表示异步复制操作的任务。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2b41c-244">A task that represents the asynchronous copy operation.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="2b41c-245">
            <paramref name="destination" /> 为 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2b41c-245">
              <paramref name="destination" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="2b41c-246">
            <paramref name="buffersize" /> 为负数或零。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2b41c-246">
              <paramref name="buffersize" /> is negative or zero.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="2b41c-247">当前流或目标流已释放。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2b41c-247">Either the current stream or the destination stream is disposed.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="2b41c-248">当前流不支持阅读，或目标流不支持写入。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2b41c-248">The current stream does not support reading, or the destination stream does not support writing.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryStream.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="override this.Dispose : bool -&gt; unit" Usage="memoryStream.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          <span data-ttu-id="2b41c-249">若要释放托管资源和非托管资源，则为 <see langword="true" />；若仅释放非托管资源，则为 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2b41c-249">
              <see langword="true" /> to release both managed and unmanaged resources; <see langword="false" /> to release only unmanaged resources.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="2b41c-250">释放 <see cref="T:System.IO.MemoryStream" /> 类使用的非托管资源，并可以选择释放托管资源。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2b41c-250">Releases the unmanaged resources used by the <see cref="T:System.IO.MemoryStream" /> class and optionally releases the managed resources.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2b41c-251">调用此方法由公共<xref:System.ComponentModel.Component.Dispose%2A>方法和<xref:System.Object.Finalize%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="2b41c-251">This method is called by the public <xref:System.ComponentModel.Component.Dispose%2A> method and the <xref:System.Object.Finalize%2A> method.</span></span> <span data-ttu-id="2b41c-252"><xref:System.ComponentModel.Component.Dispose%2A> 调用受保护<xref:System.IO.MemoryStream.Dispose%2A>方法替换`disposing`参数设置为`true`。</span><span class="sxs-lookup"><span data-stu-id="2b41c-252"><xref:System.ComponentModel.Component.Dispose%2A> invokes the protected <xref:System.IO.MemoryStream.Dispose%2A> method with the `disposing` parameter set to `true`.</span></span> <span data-ttu-id="2b41c-253"><xref:System.Object.Finalize%2A> 调用<xref:System.IO.MemoryStream.Dispose%2A>与`disposing`设置为`false`。</span><span class="sxs-lookup"><span data-stu-id="2b41c-253"><xref:System.Object.Finalize%2A> invokes <xref:System.IO.MemoryStream.Dispose%2A> with `disposing` set to `false`.</span></span>  
  
 <span data-ttu-id="2b41c-254">当 `disposing` 参数为 `true` 时，此方法释放该 <xref:System.IO.MemoryStream> 引用的、由任何托管对象持有的全部资源。</span><span class="sxs-lookup"><span data-stu-id="2b41c-254">When the `disposing` parameter is `true`, this method releases all resources held by any managed objects that this <xref:System.IO.MemoryStream> references.</span></span> <span data-ttu-id="2b41c-255">此方法调用每个引用对象的 <xref:System.ComponentModel.Component.Dispose%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="2b41c-255">This method invokes the <xref:System.ComponentModel.Component.Dispose%2A> method of each referenced object.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <span data-ttu-id="2b41c-256">
              <see cref="M:System.ComponentModel.Component.Dispose" /> 可以由其他对象多次调用。</span>
            <span class="sxs-lookup">
              <span data-stu-id="2b41c-256">
                <see cref="M:System.ComponentModel.Component.Dispose" /> can be called multiple times by other objects.</span>
            </span>
            <span data-ttu-id="2b41c-257">重写时<see cref="M:System.IO.MemoryStream.Dispose(System.Boolean)" />小心不要引用已经释放的早期调用中的对象<see cref="M:System.ComponentModel.Component.Dispose" />。</span>
            <span class="sxs-lookup">
              <span data-stu-id="2b41c-257">When overriding <see cref="M:System.IO.MemoryStream.Dispose(System.Boolean)" /> be careful not to reference objects that have been previously disposed of in an earlier call to <see cref="M:System.ComponentModel.Component.Dispose" />.</span>
            </span>
            <span data-ttu-id="2b41c-258">有关如何实现详细信息<see cref="M:System.IO.MemoryStream.Dispose(System.Boolean)" />，请参阅[实现 Dispose 方法](~/docs/standard/garbage-collection/implementing-dispose.md)。</span>
            <span class="sxs-lookup">
              <span data-stu-id="2b41c-258">For more information about how to implement <see cref="M:System.IO.MemoryStream.Dispose(System.Boolean)" />, see [Implementing a Dispose Method](~/docs/standard/garbage-collection/implementing-dispose.md).</span>
            </span>
            <span data-ttu-id="2b41c-259">有关详细信息<see cref="M:System.ComponentModel.Component.Dispose" />并<see cref="M:System.Object.Finalize" />，请参阅[清理了非托管资源](~/docs/standard/garbage-collection/unmanaged.md)。</span>
            <span class="sxs-lookup">
              <span data-stu-id="2b41c-259">For more information about <see cref="M:System.ComponentModel.Component.Dispose" /> and <see cref="M:System.Object.Finalize" />, see [Cleaning Up Unmanaged Resources](~/docs/standard/garbage-collection/unmanaged.md).</span>
            </span>
          </para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="EndRead">
      <MemberSignature Language="C#" Value="public override int EndRead (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 EndRead(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryStream.EndRead(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function EndRead (asyncResult As IAsyncResult) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int EndRead(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="override this.EndRead : IAsyncResult -&gt; int" Usage="memoryStream.EndRead asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EndWrite">
      <MemberSignature Language="C#" Value="public override void EndWrite (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void EndWrite(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryStream.EndWrite(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub EndWrite (asyncResult As IAsyncResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void EndWrite(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="override this.EndWrite : IAsyncResult -&gt; unit" Usage="memoryStream.EndWrite asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Flush">
      <MemberSignature Language="C#" Value="public override void Flush ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Flush() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryStream.Flush" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Flush ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Flush();" />
      <MemberSignature Language="F#" Value="override this.Flush : unit -&gt; unit" Usage="memoryStream.Flush " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="2b41c-260">重写 <see cref="M:System.IO.Stream.Flush" /> 方法以便不执行任何操作。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2b41c-260">Overrides the <see cref="M:System.IO.Stream.Flush" /> method so that no action is performed.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2b41c-261">此方法重写<xref:System.IO.Stream.Flush%2A?displayProperty=nameWithType>方法。</span><span class="sxs-lookup"><span data-stu-id="2b41c-261">This method overrides the <xref:System.IO.Stream.Flush%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="2b41c-262">由于写入到任何数据<xref:System.IO.MemoryStream>对象写入到 RAM 中，此方法是冗余的。</span><span class="sxs-lookup"><span data-stu-id="2b41c-262">Because any data written to a <xref:System.IO.MemoryStream> object is written into RAM, this method is redundant.</span></span>  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/io/index.md">
          <span data-ttu-id="2b41c-263">文件和流 I/O</span>
          <span class="sxs-lookup">
            <span data-stu-id="2b41c-263">File and Stream I/O</span>
          </span>
        </related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">
          <span data-ttu-id="2b41c-264">如何：从文件读取文本</span>
          <span class="sxs-lookup">
            <span data-stu-id="2b41c-264">How to: Read Text from a File</span>
          </span>
        </related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">
          <span data-ttu-id="2b41c-265">如何：向文件写入文本</span>
          <span class="sxs-lookup">
            <span data-stu-id="2b41c-265">How to: Write Text to a File</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="FlushAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.Task FlushAsync (System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Threading.Tasks.Task FlushAsync(valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryStream.FlushAsync(System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Threading::Tasks::Task ^ FlushAsync(System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="override this.FlushAsync : System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="memoryStream.FlushAsync cancellationToken" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="cancellationToken">
          <span data-ttu-id="2b41c-266">要监视取消请求的标记。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2b41c-266">The token to monitor for cancellation requests.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="2b41c-267">异步清除此流的所有缓冲区，并监视取消请求。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2b41c-267">Asynchronously clears all buffers for this stream, and monitors cancellation requests.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="2b41c-268">表示异步刷新操作的任务。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2b41c-268">A task that represents the asynchronous flush operation.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2b41c-269">由于写入到任何数据<xref:System.IO.MemoryStream>对象写入到 RAM 中，此方法是冗余的。</span><span class="sxs-lookup"><span data-stu-id="2b41c-269">Because any data written to a <xref:System.IO.MemoryStream> object is written into RAM, this method is redundant.</span></span>  
  
 <span data-ttu-id="2b41c-270">如果在完成之前，将取消该操作，则返回的任务将包含<xref:System.Threading.Tasks.TaskStatus.Canceled>值<xref:System.Threading.Tasks.Task.Status%2A>属性。</span><span class="sxs-lookup"><span data-stu-id="2b41c-270">If the operation is canceled before it completes, the returned task contains the <xref:System.Threading.Tasks.TaskStatus.Canceled> value for the <xref:System.Threading.Tasks.Task.Status%2A> property.</span></span>  
  
 <span data-ttu-id="2b41c-271">可以通过创建的实例创建取消标记<xref:System.Threading.CancellationTokenSource>类并传入<xref:System.Threading.CancellationTokenSource.Token%2A>属性设置为`cancellationToken`参数。</span><span class="sxs-lookup"><span data-stu-id="2b41c-271">You can create a cancellation token by creating an instance of the <xref:System.Threading.CancellationTokenSource> class and passing the <xref:System.Threading.CancellationTokenSource.Token%2A> property as the `cancellationToken` parameter.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="2b41c-272">已释放流。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2b41c-272">The stream has been disposed.</span>
          </span>
        </exception>
        <related type="Article" href="~/docs/standard/threading/cancellation-in-managed-threads.md">
          <span data-ttu-id="2b41c-273">取消</span>
          <span class="sxs-lookup">
            <span data-stu-id="2b41c-273">Cancellation</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="GetBuffer">
      <MemberSignature Language="C#" Value="public virtual byte[] GetBuffer ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance unsigned int8[] GetBuffer() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryStream.GetBuffer" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetBuffer () As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Byte&gt; ^ GetBuffer();" />
      <MemberSignature Language="F#" Value="abstract member GetBuffer : unit -&gt; byte[]&#xA;override this.GetBuffer : unit -&gt; byte[]" Usage="memoryStream.GetBuffer " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="2b41c-274">返回从中创建此流的无符号字节的数组。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2b41c-274">Returns the array of unsigned bytes from which this stream was created.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="2b41c-275">创建此流所用的字节数组；或者如果在当前实例的构造期间没有向 <see cref="T:System.IO.MemoryStream" /> 构造函数提供字节数组，则为基础数组。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2b41c-275">The byte array from which this stream was created, or the underlying array if a byte array was not provided to the <see cref="T:System.IO.MemoryStream" /> constructor during construction of the current instance.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2b41c-276">请注意，该缓冲区包含分配的字节，这可能是未使用。</span><span class="sxs-lookup"><span data-stu-id="2b41c-276">Note that the buffer contains allocated bytes which might be unused.</span></span> <span data-ttu-id="2b41c-277">例如，如果"test"的字符串写入到<xref:System.IO.MemoryStream>对象，从返回的缓冲区的长度<xref:System.IO.MemoryStream.GetBuffer%2A>为 256，而不是 4，与未使用为 252 字节。</span><span class="sxs-lookup"><span data-stu-id="2b41c-277">For example, if the string "test" is written into the <xref:System.IO.MemoryStream> object, the length of the buffer returned from <xref:System.IO.MemoryStream.GetBuffer%2A> is 256, not 4, with 252 bytes unused.</span></span> <span data-ttu-id="2b41c-278">若要获取缓冲区中的数据，请使用<xref:System.IO.MemoryStream.ToArray%2A>方法; 但是，<xref:System.IO.MemoryStream.ToArray%2A>在内存中创建数据的副本。</span><span class="sxs-lookup"><span data-stu-id="2b41c-278">To obtain only the data in the buffer, use the <xref:System.IO.MemoryStream.ToArray%2A> method; however, <xref:System.IO.MemoryStream.ToArray%2A> creates a copy of the data in memory.</span></span>  
  
 <span data-ttu-id="2b41c-279">也可以是缓冲区`null`。</span><span class="sxs-lookup"><span data-stu-id="2b41c-279">The buffer can also be `null`.</span></span>  
  
 <span data-ttu-id="2b41c-280">若要创建`MemoryStream`具有公共可见缓冲区，使用实例<xref:System.IO.MemoryStream.%23ctor%2A>， <xref:System.IO.MemoryStream.%23ctor%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Boolean%2CSystem.Boolean%29>，或<xref:System.IO.MemoryStream.%23ctor%28System.Int32%29>。</span><span class="sxs-lookup"><span data-stu-id="2b41c-280">To create a `MemoryStream` instance with a publicly visible buffer, use <xref:System.IO.MemoryStream.%23ctor%2A>, <xref:System.IO.MemoryStream.%23ctor%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Boolean%2CSystem.Boolean%29>, or <xref:System.IO.MemoryStream.%23ctor%28System.Int32%29>.</span></span> <span data-ttu-id="2b41c-281">如果当前流可调整大小，两次调用此方法如果调用之间的大小调整基础字节数组不会返回相同的数组。</span><span class="sxs-lookup"><span data-stu-id="2b41c-281">If the current stream is resizable, two calls to this method do not return the same array if the underlying byte array is resized between calls.</span></span> <span data-ttu-id="2b41c-282">有关附加信息，请参见 <xref:System.IO.MemoryStream.Capacity%2A>。</span><span class="sxs-lookup"><span data-stu-id="2b41c-282">For additional information, see <xref:System.IO.MemoryStream.Capacity%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="2b41c-283">此方法适用于内存流已关闭。</span><span class="sxs-lookup"><span data-stu-id="2b41c-283">This method works when the memory stream is closed.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">
          <span data-ttu-id="2b41c-284">未使用公共可见缓冲区创建 <see langword="MemoryStream" /> 的实例。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2b41c-284">The <see langword="MemoryStream" /> instance was not created with a publicly visible buffer.</span>
          </span>
        </exception>
        <related type="Article" href="~/docs/standard/io/index.md">
          <span data-ttu-id="2b41c-285">文件和流 I/O</span>
          <span class="sxs-lookup">
            <span data-stu-id="2b41c-285">File and Stream I/O</span>
          </span>
        </related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">
          <span data-ttu-id="2b41c-286">如何：从文件读取文本</span>
          <span class="sxs-lookup">
            <span data-stu-id="2b41c-286">How to: Read Text from a File</span>
          </span>
        </related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">
          <span data-ttu-id="2b41c-287">如何：向文件写入文本</span>
          <span class="sxs-lookup">
            <span data-stu-id="2b41c-287">How to: Write Text to a File</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="Length">
      <MemberSignature Language="C#" Value="public override long Length { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 Length" />
      <MemberSignature Language="DocId" Value="P:System.IO.MemoryStream.Length" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Length As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property long Length { long get(); };" />
      <MemberSignature Language="F#" Value="member this.Length : int64" Usage="System.IO.MemoryStream.Length" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="2b41c-288">获取流的长度（以字节为单位）。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2b41c-288">Gets the length of the stream in bytes.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="2b41c-289">流的长度（以字节为单位）。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2b41c-289">The length of the stream in bytes.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="2b41c-290">此代码示例是为提供一个更大示例的一部分<xref:System.IO.MemoryStream>类。</span><span class="sxs-lookup"><span data-stu-id="2b41c-290">This code example is part of a larger example provided for the <xref:System.IO.MemoryStream> class.</span></span>  
  
 [!code-cpp[System.IO.MemoryStream#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.MemoryStream/CPP/memstream.cpp#5)]
 [!code-csharp[System.IO.MemoryStream#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.MemoryStream/CS/memstream.cs#5)]
 [!code-vb[System.IO.MemoryStream#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.MemoryStream/VB/memstream.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="2b41c-291">流已关闭。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2b41c-291">The stream is closed.</span>
          </span>
        </exception>
        <related type="Article" href="~/docs/standard/io/index.md">
          <span data-ttu-id="2b41c-292">文件和流 I/O</span>
          <span class="sxs-lookup">
            <span data-stu-id="2b41c-292">File and Stream I/O</span>
          </span>
        </related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">
          <span data-ttu-id="2b41c-293">如何：从文件读取文本</span>
          <span class="sxs-lookup">
            <span data-stu-id="2b41c-293">How to: Read Text from a File</span>
          </span>
        </related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">
          <span data-ttu-id="2b41c-294">如何：向文件写入文本</span>
          <span class="sxs-lookup">
            <span data-stu-id="2b41c-294">How to: Write Text to a File</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="ObjectInvariant">
      <MemberSignature Language="C#" Value="protected override void ObjectInvariant ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void ObjectInvariant() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryStream.ObjectInvariant" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub ObjectInvariant ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void ObjectInvariant();" />
      <MemberSignature Language="F#" Value="override this.ObjectInvariant : unit -&gt; unit" Usage="memoryStream.ObjectInvariant " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="2b41c-295">提供对 <see cref="T:System.Diagnostics.Contracts.Contract" /> 的支持。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2b41c-295">Provides support for a <see cref="T:System.Diagnostics.Contracts.Contract" />.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
        <forInternalUseOnly />
      </Docs>
    </Member>
    <Member MemberName="Position">
      <MemberSignature Language="C#" Value="public override long Position { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 Position" />
      <MemberSignature Language="DocId" Value="P:System.IO.MemoryStream.Position" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Position As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property long Position { long get(); void set(long value); };" />
      <MemberSignature Language="F#" Value="member this.Position : int64 with get, set" Usage="System.IO.MemoryStream.Position" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="2b41c-296">获取或设置流中的当前位置。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2b41c-296">Gets or sets the current position within the stream.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="2b41c-297">流中的当前位置。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2b41c-297">The current position within the stream.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="2b41c-298">此代码示例是为提供一个更大示例的一部分<xref:System.IO.MemoryStream>类。</span><span class="sxs-lookup"><span data-stu-id="2b41c-298">This code example is part of a larger example provided for the <xref:System.IO.MemoryStream> class.</span></span>  
  
 [!code-cpp[System.IO.MemoryStream#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.MemoryStream/CPP/memstream.cpp#5)]
 [!code-csharp[System.IO.MemoryStream#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.MemoryStream/CS/memstream.cs#5)]
 [!code-vb[System.IO.MemoryStream#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.MemoryStream/VB/memstream.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="2b41c-299">此位置设置为负值或大于 <see cref="F:System.Int32.MaxValue" /> 的值。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2b41c-299">The position is set to a negative value or a value greater than <see cref="F:System.Int32.MaxValue" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="2b41c-300">流已关闭。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2b41c-300">The stream is closed.</span>
          </span>
        </exception>
        <related type="Article" href="~/docs/standard/io/index.md">
          <span data-ttu-id="2b41c-301">文件和流 I/O</span>
          <span class="sxs-lookup">
            <span data-stu-id="2b41c-301">File and Stream I/O</span>
          </span>
        </related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">
          <span data-ttu-id="2b41c-302">如何：从文件读取文本</span>
          <span class="sxs-lookup">
            <span data-stu-id="2b41c-302">How to: Read Text from a File</span>
          </span>
        </related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">
          <span data-ttu-id="2b41c-303">如何：向文件写入文本</span>
          <span class="sxs-lookup">
            <span data-stu-id="2b41c-303">How to: Write Text to a File</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="Read">
      <MemberSignature Language="C#" Value="public override int Read (Span&lt;byte&gt; destination);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 Read(valuetype System.Span`1&lt;unsigned int8&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryStream.Read(System.Span{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Read (destination As Span(Of Byte)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int Read(Span&lt;System::Byte&gt; destination);" />
      <MemberSignature Language="F#" Value="override this.Read : Span&lt;byte&gt; -&gt; int" Usage="memoryStream.Read destination" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Byte&gt;" />
      </Parameters>
      <Docs>
        <param name="destination">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Read">
      <MemberSignature Language="C#" Value="public override int Read (byte[] buffer, int offset, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 Read([out] unsigned int8[] buffer, int32 offset, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryStream.Read(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Read (buffer As Byte(), offset As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int Read(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count);" />
      <MemberSignature Language="F#" Value="override this.Read : byte[] * int * int -&gt; int" Usage="memoryStream.Read (buffer, offset, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">
          <span data-ttu-id="2b41c-304">此方法返回时，该缓冲区包含指定的字节数组，该数组的 <c>offset</c> 和 (<c>offset</c> + <c>count</c> - 1) 之间的值替换为从当前源中读取的字节。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2b41c-304">When this method returns, contains the specified byte array with the values between <c>offset</c> and (<c>offset</c> + <c>count</c> - 1) replaced by the characters read from the current stream.</span>
          </span>
        </param>
        <param name="offset">
          <span data-ttu-id="2b41c-305">
            <c>buffer</c> 中的从零开始的字节偏移量，从此处开始存储当前流中的数据。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2b41c-305">The zero-based byte offset in <c>buffer</c> at which to begin storing data from the current stream.</span>
          </span>
        </param>
        <param name="count">
          <span data-ttu-id="2b41c-306">最多读取的字节数。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2b41c-306">The maximum number of bytes to read.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="2b41c-307">从当前流中读取字节块并将数据写入缓冲区。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2b41c-307">Reads a block of bytes from the current stream and writes the data to a buffer.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="2b41c-308">写入缓冲区中的总字节数。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2b41c-308">The total number of bytes written into the buffer.</span>
          </span>
          <span data-ttu-id="2b41c-309">如果字节数当前不可用，则总字节数可能小于所请求的字节数；如果在读取到任何字节前已到达流结尾，则为零。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2b41c-309">This can be less than the number of bytes requested if that number of bytes are not currently available, or zero if the end of the stream is reached before any bytes are read.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2b41c-310">此方法重写 <xref:System.IO.Stream.Read%2A>。</span><span class="sxs-lookup"><span data-stu-id="2b41c-310">This method overrides <xref:System.IO.Stream.Read%2A>.</span></span>  
  
 <span data-ttu-id="2b41c-311">`offset`参数指定了中的第一个字节的偏移量`buffer`到写入当前流中的哪些数据。</span><span class="sxs-lookup"><span data-stu-id="2b41c-311">The `offset` parameter gives the offset of the first byte in `buffer` to which data from the current stream is written.</span></span> <span data-ttu-id="2b41c-312">`count`参数指定了要从当前流中读取的字节的最大数。</span><span class="sxs-lookup"><span data-stu-id="2b41c-312">The `count` parameter gives the maximum number of bytes to read from the current stream.</span></span> <span data-ttu-id="2b41c-313">如果已到达流的结尾，返回的值是字节读取，则为零的实际数目。</span><span class="sxs-lookup"><span data-stu-id="2b41c-313">The returned value is the actual number of bytes read, or zero if the end of the stream is reached.</span></span>  
  
 <span data-ttu-id="2b41c-314">如果读取的操作成功，流中的当前位置向前移动读取的字节数。</span><span class="sxs-lookup"><span data-stu-id="2b41c-314">If the read operation is successful, the current position within the stream advances by the number of bytes read.</span></span> <span data-ttu-id="2b41c-315">如果发生异常，该流中的当前位置将保持不变。</span><span class="sxs-lookup"><span data-stu-id="2b41c-315">If an exception occurs, the current position within the stream remains unchanged.</span></span>  
  
 <span data-ttu-id="2b41c-316">`Read`方法将返回零，仅当到达流的末尾。</span><span class="sxs-lookup"><span data-stu-id="2b41c-316">The `Read` method will return zero only if the end of the stream is reached.</span></span> <span data-ttu-id="2b41c-317">在所有其他情况下，`Read`始终至少一个字节从流中读取返回之前。</span><span class="sxs-lookup"><span data-stu-id="2b41c-317">In all other cases, `Read` always reads at least one byte from the stream before returning.</span></span> <span data-ttu-id="2b41c-318">根据定义，如果没有任何数据时调用流中可用`Read`，则`Read`方法将返回的 0 （自动到达流的末尾）。</span><span class="sxs-lookup"><span data-stu-id="2b41c-318">By definition, if no data is available from the stream upon a call to `Read`, the `Read` method returns zero (the end of the stream is reached automatically).</span></span> <span data-ttu-id="2b41c-319">实现可以自由地返回少于所请求的字节，即使尚未达到流结尾。</span><span class="sxs-lookup"><span data-stu-id="2b41c-319">An implementation is free to return fewer bytes than requested even if the end of the stream has not been reached.</span></span>  
  
 <span data-ttu-id="2b41c-320">使用<xref:System.IO.BinaryReader>读取基元数据类型。</span><span class="sxs-lookup"><span data-stu-id="2b41c-320">Use <xref:System.IO.BinaryReader> for reading primitive data types.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="2b41c-321">如果字节数组中指定`buffer`参数是返回的基础缓冲区<xref:System.IO.MemoryStream.GetBuffer%2A>方法，都将覆盖数组内容，并不会引发异常。</span><span class="sxs-lookup"><span data-stu-id="2b41c-321">If the byte array specified in the `buffer` parameter is the underlying buffer returned by the <xref:System.IO.MemoryStream.GetBuffer%2A> method, the array contents are overwritten, and no exception is thrown.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2b41c-322">此代码示例是为提供一个更大示例的一部分<xref:System.IO.MemoryStream>类。</span><span class="sxs-lookup"><span data-stu-id="2b41c-322">This code example is part of a larger example provided for the <xref:System.IO.MemoryStream> class.</span></span>  
  
 [!code-cpp[System.IO.MemoryStream#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.MemoryStream/CPP/memstream.cpp#7)]
 [!code-csharp[System.IO.MemoryStream#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.MemoryStream/CS/memstream.cs#7)]
 [!code-vb[System.IO.MemoryStream#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.MemoryStream/VB/memstream.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="2b41c-323">
            <paramref name="buffer" /> 为 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2b41c-323">
              <paramref name="buffer" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="2b41c-324">
            <paramref name="offset" /> 或 <paramref name="count" /> 为负数。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2b41c-324">
              <paramref name="offset" /> or <paramref name="count" /> is negative.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="2b41c-325">缓冲区长度减去 <paramref name="offset" /> 的结果小于 <paramref name="count" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2b41c-325">
              <paramref name="offset" /> subtracted from the buffer length is less than <paramref name="count" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="2b41c-326">当前流实例已关闭。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2b41c-326">The current stream instance is closed.</span>
          </span>
        </exception>
        <related type="Article" href="~/docs/standard/io/index.md">
          <span data-ttu-id="2b41c-327">文件和流 I/O</span>
          <span class="sxs-lookup">
            <span data-stu-id="2b41c-327">File and Stream I/O</span>
          </span>
        </related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">
          <span data-ttu-id="2b41c-328">如何：从文件读取文本</span>
          <span class="sxs-lookup">
            <span data-stu-id="2b41c-328">How to: Read Text from a File</span>
          </span>
        </related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">
          <span data-ttu-id="2b41c-329">如何：向文件写入文本</span>
          <span class="sxs-lookup">
            <span data-stu-id="2b41c-329">How to: Write Text to a File</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="ReadAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.ValueTask&lt;int&gt; ReadAsync (Memory&lt;byte&gt; destination, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance valuetype System.Threading.Tasks.ValueTask`1&lt;int32&gt; ReadAsync(valuetype System.Memory`1&lt;unsigned int8&gt; destination, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryStream.ReadAsync(System.Memory{System.Byte},System.Threading.CancellationToken)" />
      <MemberSignature Language="F#" Value="override this.ReadAsync : Memory&lt;byte&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.ValueTask&lt;int&gt;" Usage="memoryStream.ReadAsync (destination, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ValueTask&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Memory&lt;System.Byte&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="destination">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.Task&lt;int&gt; ReadAsync (byte[] buffer, int offset, int count, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Threading.Tasks.Task`1&lt;int32&gt; ReadAsync(unsigned int8[] buffer, int32 offset, int32 count, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Threading::Tasks::Task&lt;int&gt; ^ ReadAsync(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="override this.ReadAsync : byte[] * int * int * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;int&gt;" Usage="memoryStream.ReadAsync (buffer, offset, count, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="buffer">
          <span data-ttu-id="2b41c-330">数据写入的缓冲区。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2b41c-330">The buffer to write the data into.</span>
          </span>
        </param>
        <param name="offset">
          <span data-ttu-id="2b41c-331">
            <c>buffer</c> 中的字节偏移量，从该偏移量开始写入流中的数据。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2b41c-331">The byte offset in <c>buffer</c> at which to begin writing data from the stream.</span>
          </span>
        </param>
        <param name="count">
          <span data-ttu-id="2b41c-332">最多读取的字节数。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2b41c-332">The maximum number of bytes to read.</span>
          </span>
        </param>
        <param name="cancellationToken">
          <span data-ttu-id="2b41c-333">要监视取消请求的标记。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2b41c-333">The token to monitor for cancellation requests.</span>
          </span>
          <span data-ttu-id="2b41c-334">默认值为 <see cref="P:System.Threading.CancellationToken.None" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2b41c-334">The default value is <see cref="P:System.Threading.CancellationToken.None" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="2b41c-335">从当前流异步读取字节的序列，将流中的位置提升读取的字节数，并监视取消请求。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2b41c-335">Asynchronously reads a sequence of bytes from the current stream, advances the position within the stream by the number of bytes read, and monitors cancellation requests.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="2b41c-336">表示异步读取操作的任务。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2b41c-336">A task that represents the asynchronous read operation.</span>
          </span>
          <span data-ttu-id="2b41c-337">
            <paramref name="TResult" /> 参数的值包含读入缓冲区的总字节数。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2b41c-337">The value of the <paramref name="TResult" /> parameter contains the total number of bytes read into the buffer.</span>
          </span>
          <span data-ttu-id="2b41c-338">如果当前可用字节数少于所请求的字节数，则该结果值可小于所请求的字节数；如果已到达流结尾时，则为 0（零）。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2b41c-338">The result value can be less than the number of bytes requested if the number of bytes currently available is less than the requested number, or it can be 0 (zero) if the end of the stream has been reached.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2b41c-339">如果在完成之前，将取消该操作，则返回的任务将包含<xref:System.Threading.Tasks.TaskStatus.Canceled>值<xref:System.Threading.Tasks.Task.Status%2A>属性。</span><span class="sxs-lookup"><span data-stu-id="2b41c-339">If the operation is canceled before it completes, the returned task contains the <xref:System.Threading.Tasks.TaskStatus.Canceled> value for the <xref:System.Threading.Tasks.Task.Status%2A> property.</span></span>  
  
 <span data-ttu-id="2b41c-340">可以通过创建的实例创建取消标记<xref:System.Threading.CancellationTokenSource>类并传入<xref:System.Threading.CancellationTokenSource.Token%2A>属性设置为`cancellationToken`参数。</span><span class="sxs-lookup"><span data-stu-id="2b41c-340">You can create a cancellation token by creating an instance of the <xref:System.Threading.CancellationTokenSource> class and passing the <xref:System.Threading.CancellationTokenSource.Token%2A> property as the `cancellationToken` parameter.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="2b41c-341">
            <paramref name="buffer" /> 为 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2b41c-341">
              <paramref name="buffer" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="2b41c-342">
            <paramref name="offset" /> 或 <paramref name="count" /> 为负数。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2b41c-342">
              <paramref name="offset" /> or <paramref name="count" /> is negative.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="2b41c-343">
            <paramref name="offset" /> 和 <paramref name="count" /> 的总和大于缓冲区长度。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2b41c-343">The sum of <paramref name="offset" /> and <paramref name="count" /> is larger than the buffer length.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="2b41c-344">流不支持读取。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2b41c-344">The stream does not support reading.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="2b41c-345">已释放流。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2b41c-345">The stream has been disposed.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="2b41c-346">之前的读取操作当前正在使用流。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2b41c-346">The stream is currently in use by a previous read operation.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="ReadByte">
      <MemberSignature Language="C#" Value="public override int ReadByte ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 ReadByte() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryStream.ReadByte" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ReadByte () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int ReadByte();" />
      <MemberSignature Language="F#" Value="override this.ReadByte : unit -&gt; int" Usage="memoryStream.ReadByte " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="2b41c-347">从当前流中读取一个字节。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2b41c-347">Reads a byte from the current stream.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="2b41c-348">强制转换为 <see cref="T:System.Int32" /> 的字节；或者如果已到达流的末尾，则为 -1。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2b41c-348">The byte cast to a <see cref="T:System.Int32" />, or -1 if the end of the stream has been reached.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2b41c-349">此方法重写 <xref:System.IO.Stream.ReadByte%2A>。</span><span class="sxs-lookup"><span data-stu-id="2b41c-349">This method overrides <xref:System.IO.Stream.ReadByte%2A>.</span></span>  
  
 <span data-ttu-id="2b41c-350">如果读取的操作成功，流中的当前位置前进 1 个字节。</span><span class="sxs-lookup"><span data-stu-id="2b41c-350">If the read operation is successful, the current position within the stream is advanced by one byte.</span></span> <span data-ttu-id="2b41c-351">如果发生异常，该流中的当前位置不变。</span><span class="sxs-lookup"><span data-stu-id="2b41c-351">If an exception occurs, the current position within the stream is unchanged.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2b41c-352">此代码示例是为提供一个更大示例的一部分<xref:System.IO.MemoryStream>类。</span><span class="sxs-lookup"><span data-stu-id="2b41c-352">This code example is part of a larger example provided for the <xref:System.IO.MemoryStream> class.</span></span>  
  
 [!code-cpp[System.IO.MemoryStream#8](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.MemoryStream/CPP/memstream.cpp#8)]
 [!code-csharp[System.IO.MemoryStream#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.MemoryStream/CS/memstream.cs#8)]
 [!code-vb[System.IO.MemoryStream#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.MemoryStream/VB/memstream.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="2b41c-353">当前流实例已关闭。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2b41c-353">The current stream instance is closed.</span>
          </span>
        </exception>
        <related type="Article" href="~/docs/standard/io/index.md">
          <span data-ttu-id="2b41c-354">文件和流 I/O</span>
          <span class="sxs-lookup">
            <span data-stu-id="2b41c-354">File and Stream I/O</span>
          </span>
        </related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">
          <span data-ttu-id="2b41c-355">如何：从文件读取文本</span>
          <span class="sxs-lookup">
            <span data-stu-id="2b41c-355">How to: Read Text from a File</span>
          </span>
        </related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">
          <span data-ttu-id="2b41c-356">如何：向文件写入文本</span>
          <span class="sxs-lookup">
            <span data-stu-id="2b41c-356">How to: Write Text to a File</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="Seek">
      <MemberSignature Language="C#" Value="public override long Seek (long offset, System.IO.SeekOrigin loc);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int64 Seek(int64 offset, valuetype System.IO.SeekOrigin loc) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryStream.Seek(System.Int64,System.IO.SeekOrigin)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Seek (offset As Long, loc As SeekOrigin) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override long Seek(long offset, System::IO::SeekOrigin loc);" />
      <MemberSignature Language="F#" Value="override this.Seek : int64 * System.IO.SeekOrigin -&gt; int64" Usage="memoryStream.Seek (offset, loc)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="offset" Type="System.Int64" />
        <Parameter Name="loc" Type="System.IO.SeekOrigin" />
      </Parameters>
      <Docs>
        <param name="offset">
          <span data-ttu-id="2b41c-357">流内的新位置。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2b41c-357">The new position within the stream.</span>
          </span>
          <span data-ttu-id="2b41c-358">它是相对于 <c>loc</c> 参数的位置，而且可正可负。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2b41c-358">This is relative to the <c>loc</c> parameter, and can be positive or negative.</span>
          </span>
        </param>
        <param name="loc">
          <span data-ttu-id="2b41c-359">类型 <see cref="T:System.IO.SeekOrigin" /> 的值，它用作查找引用点。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2b41c-359">A value of type <see cref="T:System.IO.SeekOrigin" />, which acts as the seek reference point.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="2b41c-360">将当前流中的位置设置为指定值。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2b41c-360">Sets the position within the current stream to the specified value.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="2b41c-361">流内的新位置，通过将初始引用点和偏移量合并计算而得。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2b41c-361">The new position within the stream, calculated by combining the initial reference point and the offset.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2b41c-362">此方法重写 <xref:System.IO.Stream.Seek%2A?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="2b41c-362">This method overrides <xref:System.IO.Stream.Seek%2A?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="2b41c-363">支持查找到流的长度超出任何位置。</span><span class="sxs-lookup"><span data-stu-id="2b41c-363">Seeking to any location beyond the length of the stream is supported.</span></span>  
  
 <span data-ttu-id="2b41c-364">不要使用<xref:System.IO.MemoryStream.Seek%2A>方法，以确定流中的新位置，如果<xref:System.IO.MemoryStream>具有非零值的偏移量初始化。</span><span class="sxs-lookup"><span data-stu-id="2b41c-364">Do not use the <xref:System.IO.MemoryStream.Seek%2A> method to determine the new position in the stream if the <xref:System.IO.MemoryStream> was initialized with a non-zero offset.</span></span> <span data-ttu-id="2b41c-365">如果这样做，<xref:System.IO.MemoryStream.Seek%2A>将返回不准确的值。</span><span class="sxs-lookup"><span data-stu-id="2b41c-365">If you do, <xref:System.IO.MemoryStream.Seek%2A> will return an inaccurate value.</span></span> <span data-ttu-id="2b41c-366">请改用<xref:System.IO.MemoryStream.Position%2A>属性来获取新的流的位置。</span><span class="sxs-lookup"><span data-stu-id="2b41c-366">Instead, use the <xref:System.IO.MemoryStream.Position%2A> property to get the new position of the stream.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2b41c-367">此代码示例是为提供一个更大示例的一部分<xref:System.IO.MemoryStream>类。</span><span class="sxs-lookup"><span data-stu-id="2b41c-367">This code example is part of a larger example provided for the <xref:System.IO.MemoryStream> class.</span></span>  
  
 [!code-cpp[System.IO.MemoryStream#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.MemoryStream/CPP/memstream.cpp#6)]
 [!code-csharp[System.IO.MemoryStream#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.MemoryStream/CS/memstream.cs#6)]
 [!code-vb[System.IO.MemoryStream#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.MemoryStream/VB/memstream.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="2b41c-368">试图在流的开始位置之前进行查找。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2b41c-368">Seeking is attempted before the beginning of the stream.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="2b41c-369">
            <paramref name="offset" /> 大于 <see cref="F:System.Int32.MaxValue" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2b41c-369">
              <paramref name="offset" /> is greater than <see cref="F:System.Int32.MaxValue" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="2b41c-370">
            <see cref="T:System.IO.SeekOrigin" /> 无效。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2b41c-370">There is an invalid <see cref="T:System.IO.SeekOrigin" />.</span>
          </span>
          <span data-ttu-id="2b41c-371">或</span>
          <span class="sxs-lookup">
            <span data-stu-id="2b41c-371">-or-</span>
          </span>
          <span data-ttu-id="2b41c-372">
            <paramref name="offset" /> 导致算法溢出。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2b41c-372">
              <paramref name="offset" /> caused an arithmetic overflow.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="2b41c-373">当前流实例已关闭。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2b41c-373">The current stream instance is closed.</span>
          </span>
        </exception>
        <related type="Article" href="~/docs/standard/io/index.md">
          <span data-ttu-id="2b41c-374">文件和流 I/O</span>
          <span class="sxs-lookup">
            <span data-stu-id="2b41c-374">File and Stream I/O</span>
          </span>
        </related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">
          <span data-ttu-id="2b41c-375">如何：从文件读取文本</span>
          <span class="sxs-lookup">
            <span data-stu-id="2b41c-375">How to: Read Text from a File</span>
          </span>
        </related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">
          <span data-ttu-id="2b41c-376">如何：向文件写入文本</span>
          <span class="sxs-lookup">
            <span data-stu-id="2b41c-376">How to: Write Text to a File</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="SetLength">
      <MemberSignature Language="C#" Value="public override void SetLength (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void SetLength(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryStream.SetLength(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub SetLength (value As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void SetLength(long value);" />
      <MemberSignature Language="F#" Value="override this.SetLength : int64 -&gt; unit" Usage="memoryStream.SetLength value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="2b41c-377">用于设置长度的值。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2b41c-377">The value at which to set the length.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="2b41c-378">将当前流的长度设为指定值。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2b41c-378">Sets the length of the current stream to the specified value.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2b41c-379">此方法重写 <xref:System.IO.Stream.SetLength%2A>。</span><span class="sxs-lookup"><span data-stu-id="2b41c-379">This method overrides <xref:System.IO.Stream.SetLength%2A>.</span></span>  
  
 <span data-ttu-id="2b41c-380">如果指定的值小于当前流的长度，则流被截断。</span><span class="sxs-lookup"><span data-stu-id="2b41c-380">If the specified value is less than the current length of the stream, the stream is truncated.</span></span> <span data-ttu-id="2b41c-381">如果截断后中流的当前位置为过去的流的结尾<xref:System.IO.MemoryStream.ReadByte%2A>方法返回-1，<xref:System.IO.MemoryStream.Read%2A>方法将零字节读取到提供的字节数组，并<xref:System.IO.MemoryStream.Write%2A>和<xref:System.IO.MemoryStream.WriteByte%2A>方法追加增加其长度的流末尾处的指定字节数。</span><span class="sxs-lookup"><span data-stu-id="2b41c-381">If after the truncation the current position within the stream is past the end of the stream, the <xref:System.IO.MemoryStream.ReadByte%2A> method returns -1, the <xref:System.IO.MemoryStream.Read%2A> method reads zero bytes into the provided byte array, and <xref:System.IO.MemoryStream.Write%2A> and <xref:System.IO.MemoryStream.WriteByte%2A> methods append specified bytes at the end of the stream, increasing its length.</span></span> <span data-ttu-id="2b41c-382">如果指定的值大于当前容量并且该流是可调整大小，增加容量，并在流中的当前位置保持不变。</span><span class="sxs-lookup"><span data-stu-id="2b41c-382">If the specified value is larger than the current capacity and the stream is resizable, the capacity is increased, and the current position within the stream is unchanged.</span></span> <span data-ttu-id="2b41c-383">如果长度增加时，旧的和新的长度之间的流的内容被初始化为零。</span><span class="sxs-lookup"><span data-stu-id="2b41c-383">If the length is increased, the contents of the stream between the old and the new length are initialized to zeros.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="2b41c-384">一个<xref:System.IO.MemoryStream>实例必须支持此方法运行的写入。</span><span class="sxs-lookup"><span data-stu-id="2b41c-384">A <xref:System.IO.MemoryStream> instance must support writing for this method to work.</span></span> <span data-ttu-id="2b41c-385">使用<xref:System.IO.MemoryStream.CanWrite%2A>属性来确定当前实例是否支持写入。</span><span class="sxs-lookup"><span data-stu-id="2b41c-385">Use the <xref:System.IO.MemoryStream.CanWrite%2A> property to determine whether the current instance supports writing.</span></span> <span data-ttu-id="2b41c-386">有关附加信息，请参见 <xref:System.IO.Stream.CanWrite%2A>。</span><span class="sxs-lookup"><span data-stu-id="2b41c-386">For additional information, see <xref:System.IO.Stream.CanWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="2b41c-387">当前流无法调整大小，而且 <paramref name="value" /> 大于当前容量。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2b41c-387">The current stream is not resizable and <paramref name="value" /> is larger than the current capacity.</span>
          </span>
          <span data-ttu-id="2b41c-388">或</span>
          <span class="sxs-lookup">
            <span data-stu-id="2b41c-388">-or-</span>
          </span>
          <span data-ttu-id="2b41c-389">当前流不支持写入。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2b41c-389">The current stream does not support writing.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="2b41c-390">
            <paramref name="value" /> 为负或者大于 <see cref="T:System.IO.MemoryStream" /> 的最大长度，其中最大长度为 (<see cref="F:System.Int32.MaxValue" />- origin)，origin 为基础缓冲区中作为流的起点的索引。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2b41c-390">
              <paramref name="value" /> is negative or is greater than the maximum length of the <see cref="T:System.IO.MemoryStream" />, where the maximum length is(<see cref="F:System.Int32.MaxValue" /> - origin), and origin is the index into the underlying buffer at which the stream starts.</span>
          </span>
        </exception>
        <related type="Article" href="~/docs/standard/io/index.md">
          <span data-ttu-id="2b41c-391">文件和流 I/O</span>
          <span class="sxs-lookup">
            <span data-stu-id="2b41c-391">File and Stream I/O</span>
          </span>
        </related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">
          <span data-ttu-id="2b41c-392">如何：从文件读取文本</span>
          <span class="sxs-lookup">
            <span data-stu-id="2b41c-392">How to: Read Text from a File</span>
          </span>
        </related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">
          <span data-ttu-id="2b41c-393">如何：向文件写入文本</span>
          <span class="sxs-lookup">
            <span data-stu-id="2b41c-393">How to: Write Text to a File</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="ToArray">
      <MemberSignature Language="C#" Value="public virtual byte[] ToArray ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance unsigned int8[] ToArray() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryStream.ToArray" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ToArray () As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Byte&gt; ^ ToArray();" />
      <MemberSignature Language="F#" Value="abstract member ToArray : unit -&gt; byte[]&#xA;override this.ToArray : unit -&gt; byte[]" Usage="memoryStream.ToArray " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="2b41c-394">将流内容写入字节数组，而与 <see cref="P:System.IO.MemoryStream.Position" /> 属性无关。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2b41c-394">Writes the stream contents to a byte array, regardless of the <see cref="P:System.IO.MemoryStream.Position" /> property.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="2b41c-395">新的字节数组。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2b41c-395">A new byte array.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2b41c-396">此方法中省略<xref:System.IO.MemoryStream>数组中。</span><span class="sxs-lookup"><span data-stu-id="2b41c-396">This method omits unused bytes in <xref:System.IO.MemoryStream> from the array.</span></span> <span data-ttu-id="2b41c-397">若要获取整个缓冲区，使用<xref:System.IO.MemoryStream.GetBuffer%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="2b41c-397">To get the entire buffer, use the <xref:System.IO.MemoryStream.GetBuffer%2A> method.</span></span>  
  
 <span data-ttu-id="2b41c-398">此方法返回的内容的副本<xref:System.IO.MemoryStream>作为字节数组。</span><span class="sxs-lookup"><span data-stu-id="2b41c-398">This method returns a copy of the contents of the <xref:System.IO.MemoryStream> as a byte array.</span></span> <span data-ttu-id="2b41c-399">如果当前实例在提供的字节数组构造的则返回此实例有权访问数组的一部分的副本。</span><span class="sxs-lookup"><span data-stu-id="2b41c-399">If the current instance was constructed on a provided byte array, a copy of the section of the array to which this instance has access is returned.</span></span> <span data-ttu-id="2b41c-400">请参阅<xref:System.IO.MemoryStream.%23ctor%2A>构造函数的详细信息。</span><span class="sxs-lookup"><span data-stu-id="2b41c-400">See the <xref:System.IO.MemoryStream.%23ctor%2A> constructor for details.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="2b41c-401">此方法适用于当<xref:System.IO.MemoryStream>已关闭。</span><span class="sxs-lookup"><span data-stu-id="2b41c-401">This method works when the <xref:System.IO.MemoryStream> is closed.</span></span>  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/io/index.md">
          <span data-ttu-id="2b41c-402">文件和流 I/O</span>
          <span class="sxs-lookup">
            <span data-stu-id="2b41c-402">File and Stream I/O</span>
          </span>
        </related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">
          <span data-ttu-id="2b41c-403">如何：从文件读取文本</span>
          <span class="sxs-lookup">
            <span data-stu-id="2b41c-403">How to: Read Text from a File</span>
          </span>
        </related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">
          <span data-ttu-id="2b41c-404">如何：向文件写入文本</span>
          <span class="sxs-lookup">
            <span data-stu-id="2b41c-404">How to: Write Text to a File</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="TryGetBuffer">
      <MemberSignature Language="C#" Value="public virtual bool TryGetBuffer (out ArraySegment&lt;byte&gt; buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool TryGetBuffer([out] valuetype System.ArraySegment`1&lt;unsigned int8&gt;&amp; buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryStream.TryGetBuffer(System.ArraySegment{System.Byte}@)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function TryGetBuffer (ByRef buffer As ArraySegment(Of Byte)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool TryGetBuffer([Runtime::InteropServices::Out] ArraySegment&lt;System::Byte&gt; % buffer);" />
      <MemberSignature Language="F#" Value="abstract member TryGetBuffer :  -&gt; bool&#xA;override this.TryGetBuffer :  -&gt; bool" Usage="memoryStream.TryGetBuffer buffer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.ArraySegment&lt;System.Byte&gt;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="buffer">
          <span data-ttu-id="2b41c-405">用于创建此流的字节数组段。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2b41c-405">The byte array segment from which this stream was created.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="2b41c-406">返回从中创建此流的无符号字节的数组。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2b41c-406">Returns the array of unsigned bytes from which this stream was created.</span>
          </span>
          <span data-ttu-id="2b41c-407">用于指示转换是否成功的返回值。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2b41c-407">The return value indicates whether the conversion succeeded.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="2b41c-408">如果转换成功，则为 <see langword="true" />；否则为 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2b41c-408">
              <see langword="true" /> if the conversion was successful; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public override void Write (ReadOnlySpan&lt;byte&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Write(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryStream.Write(System.ReadOnlySpan{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Write (source As ReadOnlySpan(Of Byte))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Write(ReadOnlySpan&lt;System::Byte&gt; source);" />
      <MemberSignature Language="F#" Value="override this.Write : ReadOnlySpan&lt;byte&gt; -&gt; unit" Usage="memoryStream.Write source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
      </Parameters>
      <Docs>
        <param name="source">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public override void Write (byte[] buffer, int offset, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Write(unsigned int8[] buffer, int32 offset, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryStream.Write(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Write (buffer As Byte(), offset As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Write(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count);" />
      <MemberSignature Language="F#" Value="override this.Write : byte[] * int * int -&gt; unit" Usage="memoryStream.Write (buffer, offset, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">
          <span data-ttu-id="2b41c-409">从中写入数据的缓冲区。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2b41c-409">The buffer to write data from.</span>
          </span>
        </param>
        <param name="offset">
          <span data-ttu-id="2b41c-410">
            <c>buffer</c> 中的从零开始的字节偏移量，从此处开始将字节复制到当前流。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2b41c-410">The zero-based byte offset in <c>buffer</c> at which to begin copying bytes to the current stream.</span>
          </span>
        </param>
        <param name="count">
          <span data-ttu-id="2b41c-411">最多写入的字节数。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2b41c-411">The maximum number of bytes to write.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="2b41c-412">使用从缓冲区读取的数据将字节块写入当前流。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2b41c-412">Writes a block of bytes to the current stream using data read from a buffer.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2b41c-413">此方法重写 <xref:System.IO.Stream.Write%2A>。</span><span class="sxs-lookup"><span data-stu-id="2b41c-413">This method overrides <xref:System.IO.Stream.Write%2A>.</span></span>  
  
 <span data-ttu-id="2b41c-414">`offset`参数指定了中的第一个字节的偏移量`buffer`能够从，编写和`count`参数指定了要写入的字节数。</span><span class="sxs-lookup"><span data-stu-id="2b41c-414">The `offset` parameter gives the offset of the first byte in `buffer` to write from, and the `count` parameter gives the number of bytes to write.</span></span> <span data-ttu-id="2b41c-415">如果写入操作成功，流中的当前位置前进写入的字节数。</span><span class="sxs-lookup"><span data-stu-id="2b41c-415">If the write operation is successful, the current position within the stream is advanced by the number of bytes written.</span></span> <span data-ttu-id="2b41c-416">如果发生异常，该流中的当前位置不变。</span><span class="sxs-lookup"><span data-stu-id="2b41c-416">If an exception occurs, the current position within the stream is unchanged.</span></span>  
  
 <span data-ttu-id="2b41c-417">除`MemoryStream`使用 byte [] 参数构造的写入操作的末尾`MemoryStream`展开`MemoryStream`。</span><span class="sxs-lookup"><span data-stu-id="2b41c-417">Except for a `MemoryStream` constructed with a byte[] parameter, write operations at the end of a `MemoryStream` expand the `MemoryStream`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2b41c-418">此代码示例是为提供一个更大示例的一部分<xref:System.IO.MemoryStream>类。</span><span class="sxs-lookup"><span data-stu-id="2b41c-418">This code example is part of a larger example provided for the <xref:System.IO.MemoryStream> class.</span></span>  
  
 [!code-cpp[System.IO.MemoryStream#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.MemoryStream/CPP/memstream.cpp#3)]
 [!code-csharp[System.IO.MemoryStream#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.MemoryStream/CS/memstream.cs#3)]
 [!code-vb[System.IO.MemoryStream#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.MemoryStream/VB/memstream.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="2b41c-419">
            <paramref name="buffer" /> 为 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2b41c-419">
              <paramref name="buffer" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="2b41c-420">流不支持写入。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2b41c-420">The stream does not support writing.</span>
          </span>
          <span data-ttu-id="2b41c-421">有关其他信息，请参见 <see cref="P:System.IO.Stream.CanWrite" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2b41c-421">For additional information see <see cref="P:System.IO.Stream.CanWrite" />.</span>
          </span>
          <span data-ttu-id="2b41c-422">或</span>
          <span class="sxs-lookup">
            <span data-stu-id="2b41c-422">-or-</span>
          </span>
          <span data-ttu-id="2b41c-423">当前位置到流结尾的距离小于 <paramref name="count" /> 字节，并且无法修改容量。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2b41c-423">The current position is closer than <paramref name="count" /> bytes to the end of the stream, and the capacity cannot be modified.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="2b41c-424">缓冲区长度减去 <paramref name="offset" /> 的结果小于 <paramref name="count" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2b41c-424">
              <paramref name="offset" /> subtracted from the buffer length is less than <paramref name="count" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="2b41c-425">
            <paramref name="offset" /> 或 <paramref name="count" /> 为负。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2b41c-425">
              <paramref name="offset" /> or <paramref name="count" /> are negative.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="2b41c-426">出现 I/O 错误。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2b41c-426">An I/O error occurs.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="2b41c-427">当前流实例已关闭。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2b41c-427">The current stream instance is closed.</span>
          </span>
        </exception>
        <related type="Article" href="~/docs/standard/io/index.md">
          <span data-ttu-id="2b41c-428">文件和流 I/O</span>
          <span class="sxs-lookup">
            <span data-stu-id="2b41c-428">File and Stream I/O</span>
          </span>
        </related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">
          <span data-ttu-id="2b41c-429">如何：从文件读取文本</span>
          <span class="sxs-lookup">
            <span data-stu-id="2b41c-429">How to: Read Text from a File</span>
          </span>
        </related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">
          <span data-ttu-id="2b41c-430">如何：向文件写入文本</span>
          <span class="sxs-lookup">
            <span data-stu-id="2b41c-430">How to: Write Text to a File</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="WriteAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.ValueTask WriteAsync (ReadOnlyMemory&lt;byte&gt; source, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance valuetype System.Threading.Tasks.ValueTask WriteAsync(valuetype System.ReadOnlyMemory`1&lt;unsigned int8&gt; source, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryStream.WriteAsync(System.ReadOnlyMemory{System.Byte},System.Threading.CancellationToken)" />
      <MemberSignature Language="F#" Value="override this.WriteAsync : ReadOnlyMemory&lt;byte&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.ValueTask" Usage="memoryStream.WriteAsync (source, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ValueTask</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.ReadOnlyMemory&lt;System.Byte&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="source">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.Task WriteAsync (byte[] buffer, int offset, int count, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Threading.Tasks.Task WriteAsync(unsigned int8[] buffer, int32 offset, int32 count, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Threading::Tasks::Task ^ WriteAsync(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="override this.WriteAsync : byte[] * int * int * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="memoryStream.WriteAsync (buffer, offset, count, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="buffer">
          <span data-ttu-id="2b41c-431">从中写入数据的缓冲区。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2b41c-431">The buffer to write data from.</span>
          </span>
        </param>
        <param name="offset">
          <span data-ttu-id="2b41c-432">
            <c>buffer</c> 中的从零开始的字节偏移量，从此处开始将字节复制到该流。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2b41c-432">The zero-based byte offset in <c>buffer</c> from which to begin copying bytes to the stream.</span>
          </span>
        </param>
        <param name="count">
          <span data-ttu-id="2b41c-433">最多写入的字节数。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2b41c-433">The maximum number of bytes to write.</span>
          </span>
        </param>
        <param name="cancellationToken">
          <span data-ttu-id="2b41c-434">要监视取消请求的标记。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2b41c-434">The token to monitor for cancellation requests.</span>
          </span>
          <span data-ttu-id="2b41c-435">默认值为 <see cref="P:System.Threading.CancellationToken.None" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2b41c-435">The default value is <see cref="P:System.Threading.CancellationToken.None" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="2b41c-436">将字节的序列异步写入当前流，将该流中的当前位置提升写入的字节数，并监视取消请求。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2b41c-436">Asynchronously writes a sequence of bytes to the current stream, advances the current position within this stream by the number of bytes written, and monitors cancellation requests.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="2b41c-437">表示异步写入操作的任务。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2b41c-437">A task that represents the asynchronous write operation.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2b41c-438">如果在完成之前，将取消该操作，则返回的任务将包含<xref:System.Threading.Tasks.TaskStatus.Canceled>值<xref:System.Threading.Tasks.Task.Status%2A>属性。</span><span class="sxs-lookup"><span data-stu-id="2b41c-438">If the operation is canceled before it completes, the returned task contains the <xref:System.Threading.Tasks.TaskStatus.Canceled> value for the <xref:System.Threading.Tasks.Task.Status%2A> property.</span></span>  
  
 <span data-ttu-id="2b41c-439">可以通过创建的实例创建取消标记<xref:System.Threading.CancellationTokenSource>类并传入<xref:System.Threading.CancellationTokenSource.Token%2A>属性设置为`cancellationToken`参数。</span><span class="sxs-lookup"><span data-stu-id="2b41c-439">You can create a cancellation token by creating an instance of the <xref:System.Threading.CancellationTokenSource> class and passing the <xref:System.Threading.CancellationTokenSource.Token%2A> property as the `cancellationToken` parameter.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="2b41c-440">
            <paramref name="buffer" /> 为 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2b41c-440">
              <paramref name="buffer" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="2b41c-441">
            <paramref name="offset" /> 或 <paramref name="count" /> 为负数。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2b41c-441">
              <paramref name="offset" /> or <paramref name="count" /> is negative.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="2b41c-442">
            <paramref name="offset" /> 和 <paramref name="count" /> 的总和大于缓冲区长度。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2b41c-442">The sum of <paramref name="offset" /> and <paramref name="count" /> is larger than the buffer length.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="2b41c-443">流不支持写入。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2b41c-443">The stream does not support writing.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="2b41c-444">已释放流。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2b41c-444">The stream has been disposed.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="2b41c-445">流正在由前一次写操作使用。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2b41c-445">The stream is currently in use by a previous write operation.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="WriteByte">
      <MemberSignature Language="C#" Value="public override void WriteByte (byte value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void WriteByte(unsigned int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryStream.WriteByte(System.Byte)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub WriteByte (value As Byte)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void WriteByte(System::Byte value);" />
      <MemberSignature Language="F#" Value="override this.WriteByte : byte -&gt; unit" Usage="memoryStream.WriteByte value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Byte" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="2b41c-446">要写入的字节。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2b41c-446">The byte to write.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="2b41c-447">将一个字节写入当前位置上的当前流。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2b41c-447">Writes a byte to the current stream at the current position.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2b41c-448">此方法重写 <xref:System.IO.Stream.WriteByte%2A>。</span><span class="sxs-lookup"><span data-stu-id="2b41c-448">This method overrides <xref:System.IO.Stream.WriteByte%2A>.</span></span>  
  
 <span data-ttu-id="2b41c-449">除`MemoryStream`使用 byte [] 参数构造的写入操作的末尾`MemoryStream`展开`MemoryStream`。</span><span class="sxs-lookup"><span data-stu-id="2b41c-449">Except for a `MemoryStream` constructed with a byte[] parameter, write operations at the end of a `MemoryStream` expand the `MemoryStream`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2b41c-450">此代码示例是为提供一个更大示例的一部分<xref:System.IO.MemoryStream>类。</span><span class="sxs-lookup"><span data-stu-id="2b41c-450">This code example is part of a larger example provided for the <xref:System.IO.MemoryStream> class.</span></span>  
  
 [!code-cpp[System.IO.MemoryStream#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.MemoryStream/CPP/memstream.cpp#4)]
 [!code-csharp[System.IO.MemoryStream#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.MemoryStream/CS/memstream.cs#4)]
 [!code-vb[System.IO.MemoryStream#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.MemoryStream/VB/memstream.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="2b41c-451">流不支持写入。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2b41c-451">The stream does not support writing.</span>
          </span>
          <span data-ttu-id="2b41c-452">有关其他信息，请参见 <see cref="P:System.IO.Stream.CanWrite" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2b41c-452">For additional information see <see cref="P:System.IO.Stream.CanWrite" />.</span>
          </span>
          <span data-ttu-id="2b41c-453">或</span>
          <span class="sxs-lookup">
            <span data-stu-id="2b41c-453">-or-</span>
          </span>
          <span data-ttu-id="2b41c-454">当前位置位于流的末尾，而且容量不能被修改。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2b41c-454">The current position is at the end of the stream, and the capacity cannot be modified.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="2b41c-455">当前流已关闭。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2b41c-455">The current stream is closed.</span>
          </span>
        </exception>
        <related type="Article" href="~/docs/standard/io/index.md">
          <span data-ttu-id="2b41c-456">文件和流 I/O</span>
          <span class="sxs-lookup">
            <span data-stu-id="2b41c-456">File and Stream I/O</span>
          </span>
        </related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">
          <span data-ttu-id="2b41c-457">如何：从文件读取文本</span>
          <span class="sxs-lookup">
            <span data-stu-id="2b41c-457">How to: Read Text from a File</span>
          </span>
        </related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">
          <span data-ttu-id="2b41c-458">如何：向文件写入文本</span>
          <span class="sxs-lookup">
            <span data-stu-id="2b41c-458">How to: Write Text to a File</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="WriteTo">
      <MemberSignature Language="C#" Value="public virtual void WriteTo (System.IO.Stream stream);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void WriteTo(class System.IO.Stream stream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryStream.WriteTo(System.IO.Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void WriteTo(System::IO::Stream ^ stream);" />
      <MemberSignature Language="F#" Value="abstract member WriteTo : System.IO.Stream -&gt; unit&#xA;override this.WriteTo : System.IO.Stream -&gt; unit" Usage="memoryStream.WriteTo stream" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="stream">
          <span data-ttu-id="2b41c-459">要写入此内存流的流。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2b41c-459">The stream to write this memory stream to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="2b41c-460">将此内存流的整个内容写入到另一个流中。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2b41c-460">Writes the entire contents of this memory stream to another stream.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2b41c-461">打开当前的流时，此方法相当于调用<xref:System.IO.Stream.Write%2A?displayProperty=nameWithType>此流对基础缓冲区。</span><span class="sxs-lookup"><span data-stu-id="2b41c-461">When the current stream is open, this method is equivalent to calling <xref:System.IO.Stream.Write%2A?displayProperty=nameWithType> on the underlying buffer of this stream.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="2b41c-462">
            <paramref name="stream" /> 为 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2b41c-462">
              <paramref name="stream" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="2b41c-463">当前流或目标流已关闭。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2b41c-463">The current or target stream is closed.</span>
          </span>
        </exception>
        <related type="Article" href="~/docs/standard/io/index.md">
          <span data-ttu-id="2b41c-464">文件和流 I/O</span>
          <span class="sxs-lookup">
            <span data-stu-id="2b41c-464">File and Stream I/O</span>
          </span>
        </related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">
          <span data-ttu-id="2b41c-465">如何：从文件读取文本</span>
          <span class="sxs-lookup">
            <span data-stu-id="2b41c-465">How to: Read Text from a File</span>
          </span>
        </related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">
          <span data-ttu-id="2b41c-466">如何：向文件写入文本</span>
          <span class="sxs-lookup">
            <span data-stu-id="2b41c-466">How to: Write Text to a File</span>
          </span>
        </related>
      </Docs>
    </Member>
  </Members>
</Type>