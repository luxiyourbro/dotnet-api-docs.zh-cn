<Type Name="MessageQueue" FullName="System.Messaging.MessageQueue">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="8e7d61300c9cf64adf3ca60830f03308af35ee5a" />
    <Meta Name="ms.sourcegitcommit" Value="16d2d159872fd213cae4b8f371d7ae9c8b027c89" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-CN" />
    <Meta Name="ms.lasthandoff" Value="11/17/2018" />
    <Meta Name="ms.locfileid" Value="51889678" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class MessageQueue : System.ComponentModel.Component, System.Collections.IEnumerable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit MessageQueue extends System.ComponentModel.Component implements class System.Collections.IEnumerable" />
  <TypeSignature Language="DocId" Value="T:System.Messaging.MessageQueue" />
  <TypeSignature Language="VB.NET" Value="Public Class MessageQueue&#xA;Inherits Component&#xA;Implements IEnumerable" />
  <TypeSignature Language="C++ CLI" Value="public ref class MessageQueue : System::ComponentModel::Component, System::Collections::IEnumerable" />
  <TypeSignature Language="F#" Value="type MessageQueue = class&#xA;    inherit Component&#xA;    interface IEnumerable" />
  <AssemblyInfo>
    <AssemblyName>System.Messaging</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ComponentModel.Component</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.IEnumerable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.ComponentModel.DefaultEvent("ReceiveCompleted")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.ComponentModel.Editor("System.Messaging.Design.QueuePathEditor", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.ComponentModel.InstallerType(typeof(System.Messaging.MessageQueueInstaller))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Messaging.Design.MessageQueueConverter))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1">
      <AttributeName>System.ComponentModel.Designer("Microsoft.VisualStudio.Install.MessageQueueInstallableComponentDesigner, Microsoft.VisualStudio, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1">
      <AttributeName>System.ComponentModel.Editor("System.Messaging.Design.QueuePathEditor", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
      <AttributeName>System.ComponentModel.Editor("System.Messaging.Design.QueuePathEditor", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.Messaging.MessagingDescription("MessageQueueDesc")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>提供对“消息队列”服务器上的队列的访问。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 消息队列技术允许在不同时间运行的应用程序能够跨异类网络和可能暂时脱机的系统进行通信。 应用程序发送、 接收或查看队列中的 （而不删除其读取） 消息。 消息队列是一个可选组件的[!INCLUDE[Win2kFamily](~/includes/win2kfamily-md.md)]和 Windows NT，必须单独安装。  
  
 <xref:System.Messaging.MessageQueue>类是包装消息队列。 有多个版本的消息队列，并使用<xref:System.Messaging.MessageQueue>类可能会导致略有不同的行为，具体取决于操作系统所使用。 每个版本的消息队列的特定功能的信息，请参阅 MSDN 中的平台 SDK 中的"什么是消息队列中的新增功能"主题。  
  
 <xref:System.Messaging.MessageQueue>类提供对消息队列的队列的引用。 您可以指定在路径<xref:System.Messaging.MessageQueue.%23ctor%2A>构造函数，以连接到现有资源，也可以在服务器上创建一个新队列。 可以调用之前<xref:System.Messaging.MessageQueue.Send%28System.Object%29>， <xref:System.Messaging.MessageQueue.Peek%2A>，或<xref:System.Messaging.MessageQueue.Receive%2A>，则必须将关联的新实例<xref:System.Messaging.MessageQueue>与现有队列的类。 此时，如操作队列的属性<xref:System.Messaging.MessageQueue.Category%2A>和<xref:System.Messaging.MessageQueue.Label%2A>。  
  
 <xref:System.Messaging.MessageQueue> 支持两种类型的消息检索： 同步和异步。 同步方法<xref:System.Messaging.MessageQueue.Peek%2A>和<xref:System.Messaging.MessageQueue.Receive%2A>，会导致进程线程等待新消息到达队列中指定的时间间隔。 异步方法中，<xref:System.Messaging.MessageQueue.BeginPeek%2A>和<xref:System.Messaging.MessageQueue.BeginReceive%2A>，允许以继续在另一个线程，直到有消息到达队列中的主应用程序任务。 这些方法通过使用回调对象和状态对象将在线程之间的信息进行工作。  
  
 当你创建的新实例<xref:System.Messaging.MessageQueue>类，不会创建一个新的消息队列队列。 相反，可以使用<xref:System.Messaging.MessageQueue.Create%28System.String%29>， <xref:System.Messaging.MessageQueue.Delete%28System.String%29>，和<xref:System.Messaging.MessageQueue.Purge%2A>方法，用于管理服务器上的队列。  
  
 与不同<xref:System.Messaging.MessageQueue.Purge%2A>，<xref:System.Messaging.MessageQueue.Create%28System.String%29>并<xref:System.Messaging.MessageQueue.Delete%28System.String%29>是`static`成员，因此可以调用这些方法而无需创建的新实例<xref:System.Messaging.MessageQueue>类。  
  
 可以设置<xref:System.Messaging.MessageQueue>对象的<xref:System.Messaging.MessageQueue.Path%2A>具有三个名称的一个属性： 友好名称， <xref:System.Messaging.MessageQueue.FormatName%2A>，或<xref:System.Messaging.MessageQueue.Label%2A>。 定义的队列的友好名称<xref:System.Messaging.MessageQueue.MachineName%2A>并<xref:System.Messaging.MessageQueue.QueueName%2A>属性，是<xref:System.Messaging.MessageQueue.MachineName%2A> \\ <xref:System.Messaging.MessageQueue.QueueName%2A>对于公用队列，和<xref:System.Messaging.MessageQueue.MachineName%2A> \\ `Private$` \\ <xref:System.Messaging.MessageQueue.QueueName%2A>用于专用队列。 <xref:System.Messaging.MessageQueue.FormatName%2A>属性允许脱机访问消息队列。 最后，可以使用队列<xref:System.Messaging.MessageQueue.Label%2A>属性来设置队列的<xref:System.Messaging.MessageQueue.Path%2A>。  
  
 有关实例的初始属性值的列表<xref:System.Messaging.MessageQueue>，请参阅<xref:System.Messaging.MessageQueue.%23ctor%2A>构造函数。  
  
   
  
## Examples  
 下面的代码示例创建新<xref:System.Messaging.MessageQueue>对象使用各种路径名称语法类型。 每种情况下，它将一条消息发送到队列的构造函数中定义的路径。  
  
 [!code-cpp[MessageQueue.Path#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Path/CPP/mqpath.cpp#1)]
 [!code-csharp[MessageQueue.Path#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Path/CS/mqpath.cs#1)]
 [!code-vb[MessageQueue.Path#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Path/VB/mqpath.vb#1)]  
  
 下面的代码示例将消息发送到队列，并从队列中，使用名为的特定于应用程序的类接收消息`Order`。  
  
 [!code-cpp[MessageQueue.Receive_noparms#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Receive_noparms/CPP/mqreceive_noparms.cpp#1)]
 [!code-csharp[MessageQueue.Receive_noparms#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Receive_noparms/CS/mqreceive_noparms.cs#1)]
 [!code-vb[MessageQueue.Receive_noparms#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Receive_noparms/VB/mqreceive_noparms.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>仅<see cref="M:System.Messaging.MessageQueue.GetAllMessages" />方法是线程安全。</threadsafe>
    <altmember cref="T:System.Messaging.Message" />
    <altmember cref="T:System.Messaging.DefaultPropertiesToSend" />
    <altmember cref="T:System.Messaging.MessageQueueException" />
    <altmember cref="M:System.Messaging.MessageQueue.#ctor" />
    <altmember cref="M:System.Messaging.MessageQueue.Peek" />
    <altmember cref="M:System.Messaging.MessageQueue.Receive" />
    <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
    <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
    <altmember cref="P:System.Messaging.MessageQueue.Path" />
    <altmember cref="P:System.Messaging.MessageQueue.Label" />
    <altmember cref="P:System.Messaging.MessageQueue.FormatName" />
    <altmember cref="P:System.Messaging.MessageQueue.QueueName" />
    <altmember cref="P:System.Messaging.MessageQueue.MachineName" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>初始化 <see cref="T:System.Messaging.MessageQueue" /> 类的新实例。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MessageQueue ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MessageQueue();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>初始化 <see cref="T:System.Messaging.MessageQueue" /> 类的新实例。 默认构造函数初始化新实例后，必须设置该实例的 <see cref="P:System.Messaging.MessageQueue.Path" /> 属性才能使用该实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用此重载来创建的新实例<xref:System.Messaging.MessageQueue>不立即绑定到消息队列服务器上的队列的类。 使用此实例前，您必须将其连接到现有消息队列队列通过设置<xref:System.Messaging.MessageQueue.Path%2A>属性。 或者，可以设置<xref:System.Messaging.MessageQueue>引用<xref:System.Messaging.MessageQueue.Create%28System.String%29>方法的返回值，从而创建一个新的消息队列队列。  
  
 <xref:System.Messaging.MessageQueue.%23ctor%2A>构造函数实例化的新实例<xref:System.Messaging.MessageQueue>类; 它不会创建一个新的消息队列队列。  
  
 下表显示的实例的初始属性值<xref:System.Messaging.MessageQueue>。  
  
|Property|初始值|  
|--------------|-------------------|  
|<xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>|设置的默认构造函数的值<xref:System.Messaging.DefaultPropertiesToSend>类。|  
|<xref:System.Messaging.MessageQueue.Formatter%2A>|<xref:System.Messaging.XmlMessageFormatter>|  
|<xref:System.Messaging.MessageQueue.MessageReadPropertyFilter%2A>|设置的默认构造函数的值<xref:System.Messaging.MessagePropertyFilter>类。 所有筛选器值设置为`true`。|  
|<xref:System.Messaging.MessageQueue.DenySharedReceive%2A>|`false`|  
  
   
  
## Examples  
 下面的代码示例创建一个新<xref:System.Messaging.MessageQueue>。  
  
 [!code-csharp[MessageQueue#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
        <altmember cref="P:System.Messaging.MessageQueue.QueueName" />
        <altmember cref="P:System.Messaging.MessageQueue.FormatName" />
        <altmember cref="P:System.Messaging.MessageQueue.Label" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MessageQueue (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MessageQueue(System::String ^ path);" />
      <MemberSignature Language="F#" Value="new System.Messaging.MessageQueue : string -&gt; System.Messaging.MessageQueue" Usage="new System.Messaging.MessageQueue path" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">此 <see cref="T:System.Messaging.MessageQueue" /> 引用的队列的位置。</param>
        <summary>初始化 <see cref="T:System.Messaging.MessageQueue" /> 类的新实例，该实例引用指定路径处的“消息队列”队列。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当你想要将新使用此重载<xref:System.Messaging.MessageQueue>实例与特定消息队列的队列，并为其知道路径、 格式名称或标签。 如果你想要授予独占访问第一个应用程序引用的队列，则必须设置<xref:System.Messaging.MessageQueue.DenySharedReceive%2A>属性设置为`true`或使用传递的读取访问权限限制参数的构造函数。  
  
 <xref:System.Messaging.MessageQueue.%23ctor%2A>构造函数实例化的新实例<xref:System.Messaging.MessageQueue>类; 它不会创建一个新的消息队列队列。 若要在消息队列中创建一个新队列，使用<xref:System.Messaging.MessageQueue.Create%28System.String%29>。  
  
 语法`path`参数取决于队列的类型它的引用下, 表中所示。  
  
|队列类型|语法|  
|----------------|------------|  
|公用队列|`MachineName`\\`QueueName`|  
|专用队列|`MachineName`\\`Private$`\\`QueueName`|  
|日记队列|`MachineName`\\`QueueName`\\`Journal$`|  
|计算机日志队列|`MachineName`\\`Journal$`|  
|计算机死信队列|`MachineName`\\`Deadletter$`|  
|计算机事务性死信队列|`MachineName`\\`XactDeadletter$`|  
  
 或者，可以使用<xref:System.Messaging.MessageQueue.FormatName%2A>或<xref:System.Messaging.MessageQueue.Label%2A>来描述的队列路径下, 表中所示。  
  
|参考|语法|示例|  
|---------------|------------|-------------|  
|格式名称|`FormatName:` [*格式名称*]|`FormatName:Public=` 5A5F7535-AE9A-41d4-935C-845C2AFF7112<br /><br /> `FormatName:DIRECT=SPX:` `NetworkNumber`; `HostNumber`\\`QueueName`<br /><br /> `FormatName:DIRECT=TCP:` `IPAddress`\\`QueueName`<br /><br /> `FormatName:DIRECT=OS:` `MachineName`\\`QueueName`|  
|Label|`Label:` [*标签*]|`Label:` 标签|  
  
 若要在脱机工作，必须使用格式名语法，而不是路径名称语法的构造函数。 否则，因为主域控制器不可用，将路径解析为格式名，将引发异常。  
  
 下表显示的实例的初始属性值<xref:System.Messaging.MessageQueue>。 这些值基于消息队列队列的属性与指定的路径`path`参数。  
  
|Property|初始值|  
|--------------|-------------------|  
|<xref:System.Messaging.MessageQueue.Authenticate%2A>|`false`|  
|<xref:System.Messaging.MessageQueue.BasePriority%2A>|0|  
|<xref:System.Messaging.MessageQueue.Category%2A>|<xref:System.Guid.Empty>|  
|<xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>|设置的默认构造函数的值<xref:System.Messaging.DefaultPropertiesToSend>类。|  
|<xref:System.Messaging.MessageQueue.EncryptionRequired%2A>|`true`如果消息队列队列的隐私级别设置为"正文";否则为`false`。|  
|<xref:System.Messaging.MessageQueue.Formatter%2A>|<xref:System.Messaging.XmlMessageFormatter>|  
|<xref:System.Messaging.MessageQueue.Label%2A>|<xref:System.String.Empty>|  
|<xref:System.Messaging.MessageQueue.MachineName%2A>|消息队列队列的计算机名称属性的值。|  
|<xref:System.Messaging.MessageQueue.MaximumJournalSize%2A>|<xref:System.Messaging.MessageQueue.InfiniteQueueSize>|  
|<xref:System.Messaging.MessageQueue.MaximumQueueSize%2A>|<xref:System.Messaging.MessageQueue.InfiniteQueueSize>|  
|<xref:System.Messaging.MessageQueue.MessageReadPropertyFilter%2A>|设置的默认构造函数的值<xref:System.Messaging.MessagePropertyFilter>类。|  
|<xref:System.Messaging.MessageQueue.Path%2A>|<xref:System.String.Empty>如果未设置的构造函数。|  
|<xref:System.Messaging.MessageQueue.QueueName%2A>|<xref:System.String.Empty>如果未设置的构造函数。|  
|<xref:System.Messaging.MessageQueue.DenySharedReceive%2A>|`false`|  
|<xref:System.Messaging.MessageQueue.UseJournalQueue%2A>|`true`如果启用消息队列对象的日志设置;否则为`false`。|  
  
   
  
## Examples  
 下面的代码示例创建新<xref:System.Messaging.MessageQueue>对象使用各种路径名称语法类型。 每种情况下，它将一条消息发送到队列的构造函数中定义的路径。  
  
 [!code-cpp[MessageQueue.Path#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Path/CPP/mqpath.cpp#1)]
 [!code-csharp[MessageQueue.Path#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Path/CS/mqpath.cs#1)]
 [!code-vb[MessageQueue.Path#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Path/VB/mqpath.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <see cref="P:System.Messaging.MessageQueue.Path" /> 属性无效，很可能因为尚未设置该属性。</exception>
        <altmember cref="P:System.Messaging.MessageQueue.FormatName" />
        <altmember cref="P:System.Messaging.MessageQueue.Label" />
        <altmember cref="P:System.Messaging.MessageQueue.QueueName" />
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MessageQueue (string path, bool sharedModeDenyReceive);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, bool sharedModeDenyReceive) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.#ctor(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, sharedModeDenyReceive As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MessageQueue(System::String ^ path, bool sharedModeDenyReceive);" />
      <MemberSignature Language="F#" Value="new System.Messaging.MessageQueue : string * bool -&gt; System.Messaging.MessageQueue" Usage="new System.Messaging.MessageQueue (path, sharedModeDenyReceive)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="sharedModeDenyReceive" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="path">此 <see cref="T:System.Messaging.MessageQueue" /> 引用的队列的位置，它对于本地计算机可以是“.”。</param>
        <param name="sharedModeDenyReceive">
          <see langword="true" />，授予访问该队列的第一个应用程序独占读访问权；否则为 <see langword="false" />。</param>
        <summary>初始化 <see cref="T:System.Messaging.MessageQueue" /> 类的新实例，该实例引用位于指定路径处而且具有指定读访问限制的“消息队列”队列。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当你想要将新使用此重载<xref:System.Messaging.MessageQueue>到特定消息队列的队列，并为其知道路径、 格式名称或标签。 如果你想要授予独占访问第一个应用程序的引用的队列，设置`sharedModeDenyReceive`参数`true`。 否则，设置`sharedModeDenyReceive`到`false`或使用仅具有构造函数`path`参数。  
  
 设置`sharedModeDenyReceive`到`true`影响访问消息队列队列，包括其他应用程序的所有对象。 参数的效果不会限制对此应用程序。  
  
 <xref:System.Messaging.MessageQueue.%23ctor%2A>构造函数创建的新实例<xref:System.Messaging.MessageQueue>类; 它不会创建一个新的消息队列队列。 若要在消息队列中创建一个新队列，使用<xref:System.Messaging.MessageQueue.Create%28System.String%29>。  
  
 语法`path`参数取决于队列的类型。  
  
|队列类型|语法|  
|----------------|------------|  
|公用队列|`MachineName`\\`QueueName`|  
|专用队列|`MachineName`\\`Private$`\\`QueueName`|  
|日记队列|`MachineName`\\`QueueName`\\`Journal$`|  
|计算机日志队列|`MachineName`\\`Journal$`|  
|计算机死信队列|`MachineName`\\`Deadletter$`|  
|计算机事务性死信队列|`MachineName`\\`XactDeadletter$`|  
  
 或者，可以使用的格式名称或消息队列的队列的标签来描述的队列路径。  
  
|参考|语法|示例|  
|---------------|------------|-------------|  
|格式名称|`FormatName:` [*格式名称*]|`FormatName:Public=` 5A5F7535-AE9A-41d4-935C-845C2AFF7112<br /><br /> `FormatName:DIRECT=SPX:` `NetworkNumber`; `HostNumber`\\`QueueName`<br /><br /> `FormatName:DIRECT=TCP:` `IPAddress`\\`QueueName`<br /><br /> `FormatName:DIRECT=OS:` `MachineName`\\`QueueName`|  
|Label|`Label:` [*标签*]|`Label:` 标签|  
  
 若要在脱机工作，必须使用格式名语法，而不是友好名称语法。 否则，因为主域控制器 （Active Directory 所在） 不是可用于将路径解析为格式名，将引发异常。  
  
 如果<xref:System.Messaging.MessageQueue>打开一个队列`sharedModeDenyReceive`参数设置为`true`，则所有<xref:System.Messaging.MessageQueue>，随后尝试从队列中读取生成<xref:System.Messaging.MessageQueueException>由于共享冲突。 一个<xref:System.Messaging.MessageQueueException>也会引发，如果<xref:System.Messaging.MessageQueue>尝试访问队列中排他模式，而另一个<xref:System.Messaging.MessageQueue>已具有到队列的非独占访问。  
  
 下表显示的实例的初始属性值<xref:System.Messaging.MessageQueue>。 这些值基于属性的消息队列队列中，使用指定的路径`path`参数。  
  
|Property|初始值|  
|--------------|-------------------|  
|<xref:System.Messaging.MessageQueue.Authenticate%2A>|`false`。|  
|<xref:System.Messaging.MessageQueue.BasePriority%2A>|0.|  
|<xref:System.Messaging.MessageQueue.Category%2A>|<xref:System.Guid.Empty>。|  
|<xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>|设置的默认构造函数的值<xref:System.Messaging.DefaultPropertiesToSend>类。|  
|<xref:System.Messaging.MessageQueue.EncryptionRequired%2A>|`true`如果消息队列队列的隐私级别设置为"正文";否则为`false`。|  
|<xref:System.Messaging.MessageQueue.Formatter%2A>|<xref:System.Messaging.XmlMessageFormatter>。|  
|<xref:System.Messaging.MessageQueue.Label%2A>|<xref:System.String.Empty>。|  
|<xref:System.Messaging.MessageQueue.MachineName%2A>|消息队列队列的计算机名称属性的值。|  
|<xref:System.Messaging.MessageQueue.MaximumJournalSize%2A>|<xref:System.Messaging.MessageQueue.InfiniteQueueSize>。|  
|<xref:System.Messaging.MessageQueue.MaximumQueueSize%2A>|<xref:System.Messaging.MessageQueue.InfiniteQueueSize>。|  
|<xref:System.Messaging.MessageQueue.MessageReadPropertyFilter%2A>|设置的默认构造函数的值<xref:System.Messaging.MessagePropertyFilter>类。|  
|<xref:System.Messaging.MessageQueue.Path%2A>|<xref:System.String.Empty>如果未设置的构造函数。|  
|<xref:System.Messaging.MessageQueue.QueueName%2A>|<xref:System.String.Empty>如果未设置的构造函数。|  
|<xref:System.Messaging.MessageQueue.DenySharedReceive%2A>|`sharedModeDenyReceive` 参数的值。|  
|<xref:System.Messaging.MessageQueue.UseJournalQueue%2A>|`true`如果启用消息队列对象的日志设置;否则为`false`。|  
  
   
  
## Examples  
 下面的代码示例创建一个新<xref:System.Messaging.MessageQueue>具有独占访问权，设置其路径，并将消息发送到队列。  
  
 [!code-cpp[MessageQueue.ctor_PathSharedModeDenyReceive#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.ctor_PathSharedModeDenyReceive/CPP/mqctor_denysharedreceive.cpp#1)]
 [!code-csharp[MessageQueue.ctor_PathSharedModeDenyReceive#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.ctor_PathSharedModeDenyReceive/CS/mqctor_denysharedreceive.cs#1)]
 [!code-vb[MessageQueue.ctor_PathSharedModeDenyReceive#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.ctor_PathSharedModeDenyReceive/VB/mqctor_denysharedreceive.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <see cref="P:System.Messaging.MessageQueue.Path" /> 属性无效，很可能因为尚未设置该属性。</exception>
        <altmember cref="P:System.Messaging.MessageQueue.FormatName" />
        <altmember cref="P:System.Messaging.MessageQueue.Label" />
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
        <altmember cref="P:System.Messaging.MessageQueue.QueueName" />
        <altmember cref="P:System.Messaging.MessageQueue.DenySharedReceive" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MessageQueue (string path, System.Messaging.QueueAccessMode accessMode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.Messaging.QueueAccessMode accessMode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.#ctor(System.String,System.Messaging.QueueAccessMode)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, accessMode As QueueAccessMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MessageQueue(System::String ^ path, System::Messaging::QueueAccessMode accessMode);" />
      <MemberSignature Language="F#" Value="new System.Messaging.MessageQueue : string * System.Messaging.QueueAccessMode -&gt; System.Messaging.MessageQueue" Usage="new System.Messaging.MessageQueue (path, accessMode)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="accessMode" Type="System.Messaging.QueueAccessMode" />
      </Parameters>
      <Docs>
        <param name="path">此 <see cref="T:System.Messaging.MessageQueue" /> 引用的队列的位置，它对于本地计算机可以是“.”。</param>
        <param name="accessMode">
          <see cref="T:System.Messaging.QueueAccessMode" /> 值之一。</param>
        <summary>初始化 <see cref="T:System.Messaging.MessageQueue" /> 类的新实例。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MessageQueue (string path, bool sharedModeDenyReceive, bool enableCache);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, bool sharedModeDenyReceive, bool enableCache) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.#ctor(System.String,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, sharedModeDenyReceive As Boolean, enableCache As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MessageQueue(System::String ^ path, bool sharedModeDenyReceive, bool enableCache);" />
      <MemberSignature Language="F#" Value="new System.Messaging.MessageQueue : string * bool * bool -&gt; System.Messaging.MessageQueue" Usage="new System.Messaging.MessageQueue (path, sharedModeDenyReceive, enableCache)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="sharedModeDenyReceive" Type="System.Boolean" />
        <Parameter Name="enableCache" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="path">此 <see cref="T:System.Messaging.MessageQueue" /> 引用的队列的位置，它对于本地计算机可以是“.”。</param>
        <param name="sharedModeDenyReceive">
          <see langword="true" />，授予访问该队列的第一个应用程序独占读访问权；否则为 <see langword="false" />。</param>
        <param name="enableCache">如果创建和使用连接缓存，则为 <see langword="true" />；否则为 <see langword="false" />。</param>
        <summary>初始化 <see cref="T:System.Messaging.MessageQueue" /> 类的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下面的代码示例创建一个新<xref:System.Messaging.MessageQueue>具有独占读取访问权限，且已启用连接缓存。  
  
 [!code-cpp[MessageQueue4#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue4/cpp/class1.cpp#1)]
 [!code-csharp[MessageQueue4#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue4/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MessageQueue (string path, bool sharedModeDenyReceive, bool enableCache, System.Messaging.QueueAccessMode accessMode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, bool sharedModeDenyReceive, bool enableCache, valuetype System.Messaging.QueueAccessMode accessMode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.#ctor(System.String,System.Boolean,System.Boolean,System.Messaging.QueueAccessMode)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, sharedModeDenyReceive As Boolean, enableCache As Boolean, accessMode As QueueAccessMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MessageQueue(System::String ^ path, bool sharedModeDenyReceive, bool enableCache, System::Messaging::QueueAccessMode accessMode);" />
      <MemberSignature Language="F#" Value="new System.Messaging.MessageQueue : string * bool * bool * System.Messaging.QueueAccessMode -&gt; System.Messaging.MessageQueue" Usage="new System.Messaging.MessageQueue (path, sharedModeDenyReceive, enableCache, accessMode)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="sharedModeDenyReceive" Type="System.Boolean" />
        <Parameter Name="enableCache" Type="System.Boolean" />
        <Parameter Name="accessMode" Type="System.Messaging.QueueAccessMode" />
      </Parameters>
      <Docs>
        <param name="path">此 <see cref="T:System.Messaging.MessageQueue" /> 引用的队列的位置，它对于本地计算机可以是“.”。</param>
        <param name="sharedModeDenyReceive">
          <see langword="true" />，授予访问该队列的第一个应用程序独占读访问权；否则为 <see langword="false" />。</param>
        <param name="enableCache">如果创建和使用连接缓存，则为 <see langword="true" />；否则为 <see langword="false" />。</param>
        <param name="accessMode">
          <see cref="T:System.Messaging.QueueAccessMode" /> 值之一。</param>
        <summary>初始化 <see cref="T:System.Messaging.MessageQueue" /> 类的新实例。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AccessMode">
      <MemberSignature Language="C#" Value="public System.Messaging.QueueAccessMode AccessMode { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Messaging.QueueAccessMode AccessMode" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.AccessMode" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AccessMode As QueueAccessMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::QueueAccessMode AccessMode { System::Messaging::QueueAccessMode get(); };" />
      <MemberSignature Language="F#" Value="member this.AccessMode : System.Messaging.QueueAccessMode" Usage="System.Messaging.MessageQueue.AccessMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.QueueAccessMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示队列的访问模式。</summary>
        <value>
          <see cref="T:System.Messaging.QueueAccessMode" /> 值之一。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 队列的默认访问模式是`QueueAccessMode.SendAndReceive`，除非指定，否则时调用的构造函数。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Authenticate">
      <MemberSignature Language="C#" Value="public bool Authenticate { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Authenticate" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.Authenticate" />
      <MemberSignature Language="VB.NET" Value="Public Property Authenticate As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Authenticate { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Authenticate : bool with get, set" Usage="System.Messaging.MessageQueue.Authenticate" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_Authenticate")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值指示队列是否仅接受经过身份验证的消息。</summary>
        <value>如果队列仅接受已经过身份验证的消息，则为 <see langword="true" />；否则为 <see langword="false" />。 默认值为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 消息身份验证提供了一种方法来确保消息的完整性并验证消息发件人。 若要请求身份验证，发送应用程序设置消息的身份验证级别。  
  
 当您将设置<xref:System.Messaging.MessageQueue.Authenticate%2A>到`true`，可将在服务器上，不只与此队列的访问权限<xref:System.Messaging.MessageQueue>实例。 使用针对相同的消息队列队列的所有客户端会受到影响。  
  
 只接受经过身份验证的消息队列将拒绝未经身份验证的消息。 若要请求消息遭到拒绝的通知，发送应用程序可以设置<xref:System.Messaging.Message.AcknowledgeType%2A>消息属性。 由于存在其他不表明消息遭到拒绝的因此发送应用程序可能会丢失消息，除非请求，它将发送到死信队列。  
  
 下表显示了此属性是否可在各种工作组模式下。  
  
|工作组模式下|可用|  
|--------------------|---------------|  
|本地计算机|是|  
|本地计算机和直接格式名|是|  
|远程计算机|否|  
|远程计算机并直接格式名|否|  
  
   
  
## Examples  
 下面的代码示例获取和设置的值的消息队列的<xref:System.Messaging.MessageQueue.Authenticate%2A>属性。  
  
 [!code-csharp[MessageQueue#3](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">访问“消息队列”方法时出错。</exception>
        <altmember cref="P:System.Messaging.Message.UseDeadLetterQueue" />
        <altmember cref="P:System.Messaging.Message.AcknowledgeType" />
      </Docs>
    </Member>
    <Member MemberName="BasePriority">
      <MemberSignature Language="C#" Value="public short BasePriority { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int16 BasePriority" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.BasePriority" />
      <MemberSignature Language="VB.NET" Value="Public Property BasePriority As Short" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property short BasePriority { short get(); void set(short value); };" />
      <MemberSignature Language="F#" Value="member this.BasePriority : int16 with get, set" Usage="System.Messaging.MessageQueue.BasePriority" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_BasePriority")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置基优先级，“消息队列”使用该基优先级在网络上传送公共队列的消息。</summary>
        <value>发送到（公共）队列的所有消息的单个基本优先级。 默认值为零 (0)。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 消息队列的基本优先级指定如何传送的消息队列在通过网络传输时被处理的。 可以设置<xref:System.Messaging.MessageQueue.BasePriority%2A>属性来授予到所有消息发送到指定比发送到其他队列的队列的更高版本或更低优先级。 设置此属性修改消息队列队列。 因此，任何其他<xref:System.Messaging.MessageQueue>更改会影响实例。  
  
 消息队列<xref:System.Messaging.MessageQueue.BasePriority%2A>无关<xref:System.Messaging.Message.Priority%2A>消息，它指定在其中传入消息放置在队列中的顺序的属性。  
  
 <xref:System.Messaging.MessageQueue.BasePriority%2A> 应用使用的格式名称指定其路径仅为公共队列。 专用队列的基本优先级始终为零 (0)。  
  
 下表显示了此属性是否可在各种工作组模式下。  
  
|工作组模式下|可用|  
|--------------------|---------------|  
|本地计算机|是|  
|本地计算机和直接格式名|是|  
|远程计算机|否|  
|远程计算机并直接格式名|否|  
  
   
  
## Examples  
 下面的代码示例获取和设置的值的消息队列的<xref:System.Messaging.MessageQueue.BasePriority%2A>属性。  
  
 [!code-csharp[MessageQueue#4](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">基优先级被设置为无效值。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">访问“消息队列”方法时出错。</exception>
        <altmember cref="P:System.Messaging.MessageQueue.FormatName" />
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginPeek">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <threadsafe>该方法不是线程安全。</threadsafe>
        <summary>通过通知“消息队列”开始查看消息并在完成后通知事件处理程序，启动一个异步查看操作。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginPeek">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginPeek ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginPeek() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginPeek" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginPeek () As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginPeek();" />
      <MemberSignature Language="F#" Value="member this.BeginPeek : unit -&gt; IAsyncResult" Usage="messageQueue.BeginPeek " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>启动一个没有超时设定的异步查看操作。直到队列中出现消息时，才完成此操作。</summary>
        <returns>该 <see cref="T:System.IAsyncResult" /> 标识已发布的异步请求的。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在异步处理，您将使用<xref:System.Messaging.MessageQueue.BeginPeek%2A>引发<xref:System.Messaging.MessageQueue.PeekCompleted>一条消息在队列中可用时的事件。  
  
 <xref:System.Messaging.MessageQueue.PeekCompleted> 也会引发如果一条消息在队列中已存在。  
  
 若要使用<xref:System.Messaging.MessageQueue.BeginPeek%2A>、 创建的事件处理程序处理异步操作的结果，并将其与事件委托。 <xref:System.Messaging.MessageQueue.BeginPeek%2A> 启动异步查看操作;<xref:System.Messaging.MessageQueue>通知，通过引发<xref:System.Messaging.MessageQueue.PeekCompleted>事件时，如果有消息到达队列中。 <xref:System.Messaging.MessageQueue>然后通过调用访问消息<xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29>或通过检索结果使用<xref:System.Messaging.PeekCompletedEventArgs>。  
  
 <xref:System.Messaging.MessageQueue.BeginPeek%2A>方法将立即返回，但直到调用事件处理程序，则不会完成异步操作。  
  
 因为<xref:System.Messaging.MessageQueue.BeginPeek%2A>是异步的您可以调用它查看队列，而不会阻止当前线程的执行。 若要以同步方式查看队列，使用<xref:System.Messaging.MessageQueue.Peek%2A>方法。  
  
 异步操作完成后，可以调用<xref:System.Messaging.MessageQueue.BeginPeek%2A>或<xref:System.Messaging.MessageQueue.BeginReceive%2A>再次在事件处理程序以继续接收通知。  
  
 <xref:System.IAsyncResult>的<xref:System.Messaging.MessageQueue.BeginPeek%2A>返回标识方法启动的异步操作。 可以使用此<xref:System.IAsyncResult>的整个生存期内操作，尽管您通常不使用它直到<xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29>调用。 但是，如果启动多个异步操作，你可以放置其<xref:System.IAsyncResult>值数组中，并指定是否要等待的所有操作或任何操作完成。 在这种情况下，使用<xref:System.IAsyncResult.AsyncWaitHandle%2A>属性的<xref:System.IAsyncResult>来标识已完成的操作。  
  
 如果<xref:System.Messaging.MessageQueue.CanRead%2A>是`false`，则引发完成事件，但调用时，将引发异常<xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29>。  
  
 下表显示了此方法是在各种工作组模式下可用。  
  
|工作组模式下|可用|  
|--------------------|---------------|  
|本地计算机|是|  
|本地计算机和直接格式名|是|  
|远程计算机|否|  
|远程计算机并直接格式名|是|  
  
   
  
## Examples  
 下面的代码示例创建名为一个事件处理程序`MyPeekCompleted`，将其附加到<xref:System.Messaging.MessageQueue.PeekCompleted>事件处理程序委托，然后调用<xref:System.Messaging.MessageQueue.BeginPeek%2A>启动异步查看操作上的队列的路径处"。 \myQueue"。 当<xref:System.Messaging.MessageQueue.PeekCompleted>引发事件，该示例查看的消息并将其正文写入到屏幕。 该示例然后调用<xref:System.Messaging.MessageQueue.BeginPeek%2A>再次以启动新的异步查看操作。  
  
 [!code-cpp[MessageQueue.BeginPeek_noparms#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.BeginPeek_noparms/CPP/mqbeginpeek_noparms.cpp#1)]
 [!code-csharp[MessageQueue.BeginPeek_noparms#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.BeginPeek_noparms/CS/mqbeginpeek_noparms.cs#1)]
 [!code-vb[MessageQueue.BeginPeek_noparms#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.BeginPeek_noparms/VB/mqbeginpeek_noparms.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">访问“消息队列”方法时出错。</exception>
        <threadsafe>该方法不是线程安全。</threadsafe>
        <altmember cref="E:System.Messaging.MessageQueue.PeekCompleted" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
      </Docs>
    </Member>
    <Member MemberName="BeginPeek">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginPeek (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginPeek(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginPeek(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginPeek (timeout As TimeSpan) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginPeek(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.BeginPeek : TimeSpan -&gt; IAsyncResult" Usage="messageQueue.BeginPeek timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">一个 <see cref="T:System.TimeSpan" /> 指示等待消息变为可用所用的时间间隔。</param>
        <summary>启动一个具有指定超时设定的异步查看操作。直到队列中出现消息时或发生超时时才完成操作。</summary>
        <returns>该 <see cref="T:System.IAsyncResult" /> 标识已发布的异步请求的。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在异步处理，您将使用<xref:System.Messaging.MessageQueue.BeginPeek%2A>引发<xref:System.Messaging.MessageQueue.PeekCompleted>一条消息变为可用的队列中，或指定的时间间隔已过期时的事件。  
  
 <xref:System.Messaging.MessageQueue.PeekCompleted> 也会引发如果一条消息在队列中已存在。  
  
 若要使用<xref:System.Messaging.MessageQueue.BeginPeek%2A>、 创建的事件处理程序处理异步操作的结果，并将其与事件委托。 <xref:System.Messaging.MessageQueue.BeginPeek%2A> 启动异步查看操作;<xref:System.Messaging.MessageQueue>通知，通过引发<xref:System.Messaging.MessageQueue.PeekCompleted>事件时，如果有消息到达队列中。 <xref:System.Messaging.MessageQueue>然后通过调用访问消息<xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29>或通过检索结果使用<xref:System.Messaging.PeekCompletedEventArgs>。  
  
 <xref:System.Messaging.MessageQueue.BeginPeek%2A>方法将立即返回，但直到调用事件处理程序，则不会完成异步操作。  
  
 因为<xref:System.Messaging.MessageQueue.BeginPeek%2A>是异步的您可以调用它查看队列，而不会阻止当前线程的执行。 若要以同步方式查看队列，使用<xref:System.Messaging.MessageQueue.Peek%2A>方法。  
  
 异步操作完成后，可以调用<xref:System.Messaging.MessageQueue.BeginPeek%2A>或<xref:System.Messaging.MessageQueue.BeginReceive%2A>再次在事件处理程序以继续接收通知。  
  
 <xref:System.IAsyncResult>的<xref:System.Messaging.MessageQueue.BeginPeek%2A>返回标识方法启动的异步操作。 可以使用此<xref:System.IAsyncResult>的整个生存期内操作，尽管您通常不使用它直到<xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29>调用。 但是，如果启动多个异步操作，你可以放置其<xref:System.IAsyncResult>值数组中，并指定是否要等待的所有操作或任何操作完成。 在这种情况下，使用<xref:System.IAsyncResult.AsyncWaitHandle%2A>属性的<xref:System.IAsyncResult>来标识已完成的操作。  
  
 此重载指定超时值。如果指定的间隔`timeout`参数过期，则此组件将产生<xref:System.Messaging.MessageQueue.PeekCompleted>事件。 因为没有消息，随后调用<xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29>将引发异常。  
  
 如果<xref:System.Messaging.MessageQueue.CanRead%2A>是`false`，则引发完成事件，但调用时，将引发异常<xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29>。  
  
 下表显示了此方法是在各种工作组模式下可用。  
  
|工作组模式下|可用|  
|--------------------|---------------|  
|本地计算机|是|  
|本地计算机和直接格式名|是|  
|远程计算机|否|  
|远程计算机并直接格式名|是|  
  
   
  
## Examples  
 下面的代码示例创建一个异步查看操作，使用的队列路径"。 \myQueue"。 它将创建一个事件处理程序`MyPeekCompleted`，并将其附加到<xref:System.Messaging.MessageQueue.PeekCompleted>事件处理程序委托。 <xref:System.Messaging.MessageQueue.BeginPeek%2A> 调用的超时值为 1 分钟后，可启动异步查看操作。 当<xref:System.Messaging.MessageQueue.PeekCompleted>引发事件或超时时间已到，如果存在，且其正文会写到屏幕中检索消息。 然后<xref:System.Messaging.MessageQueue.BeginPeek%2A>再次调用以启动新的异步查看操作相同的超时时间。  
  
 [!code-cpp[MessageQueue.BeginPeek_timeout#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.BeginPeek_timeout/CPP/mqbeginpeek_timeout.cpp#1)]
 [!code-csharp[MessageQueue.BeginPeek_timeout#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.BeginPeek_timeout/CS/mqbeginpeek_timeout.cs#1)]
 [!code-vb[MessageQueue.BeginPeek_timeout#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.BeginPeek_timeout/VB/mqbeginpeek_timeout.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">为 <paramref name="timeout" /> 参数指定的值无效。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">访问“消息队列”方法时出错。</exception>
        <threadsafe>该方法不是线程安全。</threadsafe>
        <altmember cref="E:System.Messaging.MessageQueue.PeekCompleted" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="T:System.TimeSpan" />
      </Docs>
    </Member>
    <Member MemberName="BeginPeek">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginPeek (TimeSpan timeout, object stateObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginPeek(valuetype System.TimeSpan timeout, object stateObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginPeek(System.TimeSpan,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginPeek (timeout As TimeSpan, stateObject As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginPeek(TimeSpan timeout, System::Object ^ stateObject);" />
      <MemberSignature Language="F#" Value="member this.BeginPeek : TimeSpan * obj -&gt; IAsyncResult" Usage="messageQueue.BeginPeek (timeout, stateObject)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="stateObject" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="timeout">一个 <see cref="T:System.TimeSpan" /> 指示等待消息变为可用所用的时间间隔。</param>
        <param name="stateObject">应用程序指定的状态对象，包含与异步操作关联的信息。</param>
        <summary>启动具有指定超时设定和指定状态对象的异步查看操作，此状态对象在操作的整个生存期内提供相关信息。 直到队列中出现消息时或发生超时时才完成操作。</summary>
        <returns>该 <see cref="T:System.IAsyncResult" /> 标识已发布的异步请求的。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在异步处理，您将使用<xref:System.Messaging.MessageQueue.BeginPeek%2A>引发<xref:System.Messaging.MessageQueue.PeekCompleted>一条消息变为可用的队列中，或指定的时间间隔已过期时的事件。  
  
 <xref:System.Messaging.MessageQueue.PeekCompleted> 也会引发如果一条消息在队列中已存在。  
  
 使用此重载能够将整个操作的整个生存期内保留该操作相关联的信息。 事件处理程序可以访问此信息通过查看<xref:System.IAsyncResult.AsyncState%2A>属性的<xref:System.IAsyncResult>与操作相关联。  
  
 若要使用<xref:System.Messaging.MessageQueue.BeginPeek%2A>、 创建的事件处理程序处理异步操作的结果，并将其与事件委托。 <xref:System.Messaging.MessageQueue.BeginPeek%2A> 启动异步查看操作;<xref:System.Messaging.MessageQueue>通知，通过引发<xref:System.Messaging.MessageQueue.PeekCompleted>事件时，如果有消息到达队列中。 <xref:System.Messaging.MessageQueue>然后通过调用访问消息<xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29>或通过检索结果使用<xref:System.Messaging.PeekCompletedEventArgs>。  
  
 <xref:System.Messaging.MessageQueue.BeginPeek%2A>方法将立即返回，但直到调用事件处理程序，则不会完成异步操作。  
  
 因为<xref:System.Messaging.MessageQueue.BeginPeek%2A>是异步的您可以调用它查看队列，而不会阻止当前线程的执行。 若要以同步方式查看队列，使用<xref:System.Messaging.MessageQueue.Peek%2A>方法。  
  
 异步操作完成后，可以调用<xref:System.Messaging.MessageQueue.BeginPeek%2A>或<xref:System.Messaging.MessageQueue.BeginReceive%2A>再次在事件处理程序以继续接收通知。  
  
 <xref:System.Messaging.MessageQueue.BeginPeek%2A> 返回<xref:System.IAsyncResult>标识方法启动的异步操作。 可以使用此<xref:System.IAsyncResult>的整个生存期内操作，尽管您通常不使用它直到<xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29>调用。 但是，如果启动多个异步操作，你可以放置其<xref:System.IAsyncResult>值数组中，并指定是否要等待的所有操作或任何操作完成。 在这种情况下，使用<xref:System.IAsyncResult.AsyncWaitHandle%2A>属性的<xref:System.IAsyncResult>来标识已完成的操作。  
  
 此重载指定超时和状态对象。 如果指定的间隔`timeout`参数过期，则此组件将产生<xref:System.Messaging.MessageQueue.PeekCompleted>事件。 因为没有消息，随后调用<xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29>将引发异常。  
  
 状态对象将与操作相关联的状态信息。 例如，如果您调用<xref:System.Messaging.MessageQueue.BeginPeek%2A>多次启动多个操作，你可以指定通过单独的状态对象定义的每个操作。 有关此方案的说明，请参阅示例部分。  
  
 状态对象还可用于进程线程中传递信息。 如果线程已启动，但回调是在另一个线程在异步方案中，状态对象是封送，并从该事件返回与信息一起传递。  
  
 如果<xref:System.Messaging.MessageQueue.CanRead%2A>是`false`，则引发完成事件，但调用时，将引发异常<xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29>。  
  
 下表显示了此方法是在各种工作组模式下可用。  
  
|工作组模式下|可用|  
|--------------------|---------------|  
|本地计算机|是|  
|本地计算机和直接格式名|是|  
|远程计算机|否|  
|远程计算机并直接格式名|是|  
  
   
  
## Examples  
 下面的代码示例创建一个异步查看操作，使用的队列路径"。 \myQueue"。 它将创建一个事件处理程序`MyPeekCompleted`，并将其附加到<xref:System.Messaging.MessageQueue.PeekCompleted>事件处理程序委托。 <xref:System.Messaging.MessageQueue.BeginPeek%2A> 调用时，一分钟的超时。 每次调用<xref:System.Messaging.MessageQueue.BeginPeek%2A>具有一个唯一的关联的整数，它标识该特定操作。 当<xref:System.Messaging.MessageQueue.PeekCompleted>引发事件或超时到期时，检索消息，如果存在，并在屏幕上写入其主体和特定于操作的整数标识符。 然后<xref:System.Messaging.MessageQueue.BeginPeek%2A>再次调用以启动新的异步查看操作具有相同的超时和的只是已完成的操作关联的整数。  
  
 [!code-cpp[MessageQueue.BeginPeek_TimeSpanStateObject#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.BeginPeek_TimeSpanStateObject/CPP/mqbeginpeek_timeoutstateobject.cpp#1)]
 [!code-csharp[MessageQueue.BeginPeek_TimeSpanStateObject#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.BeginPeek_TimeSpanStateObject/CS/mqbeginpeek_timeoutstateobject.cs#1)]
 [!code-vb[MessageQueue.BeginPeek_TimeSpanStateObject#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.BeginPeek_TimeSpanStateObject/VB/mqbeginpeek_timeoutstateobject.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">为 <paramref name="timeout" /> 参数指定的值无效。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">访问“消息队列”方法时出错。</exception>
        <threadsafe>该方法不是线程安全。</threadsafe>
        <altmember cref="E:System.Messaging.MessageQueue.PeekCompleted" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="T:System.TimeSpan" />
      </Docs>
    </Member>
    <Member MemberName="BeginPeek">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginPeek (TimeSpan timeout, object stateObject, AsyncCallback callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginPeek(valuetype System.TimeSpan timeout, object stateObject, class System.AsyncCallback callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginPeek(System.TimeSpan,System.Object,System.AsyncCallback)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginPeek (timeout As TimeSpan, stateObject As Object, callback As AsyncCallback) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginPeek(TimeSpan timeout, System::Object ^ stateObject, AsyncCallback ^ callback);" />
      <MemberSignature Language="F#" Value="member this.BeginPeek : TimeSpan * obj * AsyncCallback -&gt; IAsyncResult" Usage="messageQueue.BeginPeek (timeout, stateObject, callback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="stateObject" Type="System.Object" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
      </Parameters>
      <Docs>
        <param name="timeout">一个 <see cref="T:System.TimeSpan" /> 指示等待消息变为可用所用的时间间隔。</param>
        <param name="stateObject">应用程序指定的状态对象，包含与异步操作关联的信息。</param>
        <param name="callback">该 <see cref="T:System.AsyncCallback" /> 将接收异步操作完成通知。</param>
        <summary>启动具有指定超时设定和指定状态对象的异步查看操作，此状态对象在操作的整个生存期内提供相关信息。 此重载通过回调接收操作的事件处理程序标识的通知。 直到队列中出现消息时或发生超时时才完成操作。</summary>
        <returns>该 <see cref="T:System.IAsyncResult" /> 标识已发布的异步请求的。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 一条消息变为可用的队列中或者指定的时间间隔已过期; 时，使用此重载，直接调用的回调参数中指定的回调<xref:System.Messaging.MessageQueue.PeekCompleted>不会引发事件。 其他重载<xref:System.Messaging.MessageQueue.BeginPeek%2A>依赖于此组件以引发<xref:System.Messaging.MessageQueue.PeekCompleted>事件。  
  
 <xref:System.Messaging.MessageQueue.PeekCompleted> 也会引发如果一条消息在队列中已存在。  
  
 <xref:System.Messaging.MessageQueue.BeginPeek%2A>方法将立即返回，但直到调用事件处理程序，则不会完成异步操作。  
  
 因为<xref:System.Messaging.MessageQueue.BeginPeek%2A>是异步的您可以调用它查看队列，而不会阻止当前线程的执行。 若要以同步方式查看队列，使用<xref:System.Messaging.MessageQueue.Peek%2A>方法。  
  
 异步操作完成后，可以调用<xref:System.Messaging.MessageQueue.BeginPeek%2A>或<xref:System.Messaging.MessageQueue.BeginReceive%2A>再次在事件处理程序以继续接收通知。  
  
 <xref:System.Messaging.MessageQueue.BeginPeek%2A> 返回<xref:System.IAsyncResult>标识方法启动的异步操作。 可以使用此<xref:System.IAsyncResult>的整个生存期内操作，尽管您通常不使用它直到<xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29>调用。 但是，如果启动多个异步操作，你可以放置其<xref:System.IAsyncResult>值数组中，并指定是否要等待的所有操作或任何操作完成。 在这种情况下，使用<xref:System.IAsyncResult.AsyncWaitHandle%2A>属性的<xref:System.IAsyncResult>来标识已完成的操作。  
  
 状态对象将与操作相关联的状态信息。 例如，如果您调用<xref:System.Messaging.MessageQueue.BeginPeek%2A>多次启动多个操作，你可以指定通过单独的状态对象定义的每个操作。  
  
 下表显示了此方法是在各种工作组模式下可用。  
  
|工作组模式下|可用|  
|--------------------|---------------|  
|本地计算机|是|  
|本地计算机和直接格式名|是|  
|远程计算机|否|  
|远程计算机并直接格式名|是|  
  
   
  
## Examples  
 下面的代码示例创建一个异步查看操作。 代码示例将消息发送到本地消息队列，然后调用<xref:System.Messaging.MessageQueue.BeginPeek%28System.TimeSpan%2CSystem.Object%2CSystem.AsyncCallback%29>，并传入： 十秒的超时值; 标识该特定消息; 和的新实例的唯一整数<xref:System.AsyncCallback>，用于标识事件处理程序`MyPeekCompleted`. 当<xref:System.Messaging.MessageQueue.PeekCompleted>引发事件，事件处理程序查看的消息，并在屏幕上写入消息正文和整数消息标识符。  
  
 [!code-cpp[MessageQueueBeginPeek#0](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueueBeginPeek/cpp/class1.cpp#0)]
 [!code-csharp[MessageQueueBeginPeek#0](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueueBeginPeek/CS/class1.cs#0)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">为 <paramref name="timeout" /> 参数指定的值无效。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">访问“消息队列”方法时出错。</exception>
        <threadsafe>该方法不是线程安全。</threadsafe>
        <altmember cref="E:System.Messaging.MessageQueue.PeekCompleted" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="T:System.TimeSpan" />
      </Docs>
    </Member>
    <Member MemberName="BeginPeek">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginPeek (TimeSpan timeout, System.Messaging.Cursor cursor, System.Messaging.PeekAction action, object state, AsyncCallback callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginPeek(valuetype System.TimeSpan timeout, class System.Messaging.Cursor cursor, valuetype System.Messaging.PeekAction action, object state, class System.AsyncCallback callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginPeek(System.TimeSpan,System.Messaging.Cursor,System.Messaging.PeekAction,System.Object,System.AsyncCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginPeek(TimeSpan timeout, System::Messaging::Cursor ^ cursor, System::Messaging::PeekAction action, System::Object ^ state, AsyncCallback ^ callback);" />
      <MemberSignature Language="F#" Value="member this.BeginPeek : TimeSpan * System.Messaging.Cursor * System.Messaging.PeekAction * obj * AsyncCallback -&gt; IAsyncResult" Usage="messageQueue.BeginPeek (timeout, cursor, action, state, callback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="cursor" Type="System.Messaging.Cursor" />
        <Parameter Name="action" Type="System.Messaging.PeekAction" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
      </Parameters>
      <Docs>
        <param name="timeout">一个 <see cref="T:System.TimeSpan" /> 指示等待消息变为可用所用的时间间隔。</param>
        <param name="cursor">维持消息队列中特定位置的 <see cref="T:System.Messaging.Cursor" />。</param>
        <param name="action">
          <see cref="T:System.Messaging.PeekAction" /> 值之一。 指示是查看队列中的当前消息还是下一条消息。</param>
        <param name="state">应用程序指定的状态对象，包含与异步操作关联的信息。</param>
        <param name="callback">该 <see cref="T:System.AsyncCallback" /> 将接收异步操作完成通知。</param>
        <summary>启动异步查看操作，此操作具有指定的超时并使用指定的游标、指定的查看操作和指定的状态对象。 状态对象在操作的整个生存期内提供相关的信息。 此重载通过回调接收操作的事件处理程序标识的通知。 直到队列中出现消息时或发生超时时才完成操作。</summary>
        <returns>该 <see cref="T:System.IAsyncResult" /> 标识已发布的异步请求的。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当您使用此重载时，一条消息变为可用的队列中，或指定的时间间隔已过期时回调参数中指定的回调是直接调用。 <xref:System.Messaging.MessageQueue.PeekCompleted>不会引发事件。 其他重载<xref:System.Messaging.MessageQueue.BeginPeek%2A>依赖于此组件以引发<xref:System.Messaging.MessageQueue.PeekCompleted>事件。  
  
 <xref:System.Messaging.MessageQueue.PeekCompleted> 也会引发如果一条消息在队列中已存在。  
  
 <xref:System.Messaging.MessageQueue.BeginPeek%2A>方法将立即返回，但直到调用事件处理程序，则不会完成异步操作。  
  
 因为<xref:System.Messaging.MessageQueue.BeginPeek%2A>是异步的您可以调用它查看队列，而不会阻止当前线程的执行。 若要以同步方式查看队列，使用<xref:System.Messaging.MessageQueue.Peek%2A>方法。  
  
 异步操作完成后，可以调用<xref:System.Messaging.MessageQueue.BeginPeek%2A>或<xref:System.Messaging.MessageQueue.BeginReceive%2A>再次在事件处理程序以继续接收通知。  
  
 <xref:System.Messaging.MessageQueue.BeginPeek%2A> 返回<xref:System.IAsyncResult>标识方法启动的异步操作。 可以使用此<xref:System.IAsyncResult>的整个生存期内操作，尽管您通常不使用它直到<xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29>调用。 但是，如果启动多个异步操作，你可以放置其<xref:System.IAsyncResult>值数组中，并指定是否要等待的所有操作或任何操作完成。 在这种情况下，使用<xref:System.IAsyncResult.AsyncWaitHandle%2A>属性的<xref:System.IAsyncResult>来标识已完成的操作。  
  
 状态对象将与操作相关联的状态信息。 例如，如果您调用<xref:System.Messaging.MessageQueue.BeginPeek%2A>多次启动多个操作，你可以指定通过单独的状态对象定义的每个操作。  
  
 下表显示了此方法是在各种工作组模式下可用。  
  
|工作组模式下|可用|  
|--------------------|---------------|  
|本地计算机|是|  
|本地计算机和直接格式名|是|  
|远程计算机|否|  
|远程计算机并直接格式名|是|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">为 <paramref name="action" /> 参数指定的值不是 <see langword="PeekAction.Current" /> 和 <see langword="PeekAction.Next" />。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="cursor" /> 参数为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">为 <paramref name="timeout" /> 参数指定的值无效。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">访问“消息队列”方法时出错。</exception>
        <threadsafe>该方法不是线程安全。</threadsafe>
        <altmember cref="E:System.Messaging.MessageQueue.PeekCompleted" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="T:System.TimeSpan" />
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginReceive">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <threadsafe>该方法不是线程安全。</threadsafe>
        <summary>通过通知“消息队列”开始接收消息并在完成后通知事件处理程序，启动一个异步接收操作。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginReceive" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginReceive () As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive();" />
      <MemberSignature Language="F#" Value="member this.BeginReceive : unit -&gt; IAsyncResult" Usage="messageQueue.BeginReceive " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>启动一个没有超时设定的异步接收操作。直到队列中出现消息时，才完成此操作。</summary>
        <returns>该 <see cref="T:System.IAsyncResult" /> 标识已发布的异步请求的。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在异步处理，您将使用<xref:System.Messaging.MessageQueue.BeginReceive%2A>引发<xref:System.Messaging.MessageQueue.ReceiveCompleted>事件时从队列中删除一条消息。  
  
 <xref:System.Messaging.MessageQueue.ReceiveCompleted> 也会引发如果一条消息在队列中已存在。  
  
 若要使用<xref:System.Messaging.MessageQueue.BeginReceive%2A>、 创建的事件处理程序处理异步操作的结果，并将其与事件委托。 <xref:System.Messaging.MessageQueue.BeginReceive%2A> 启动异步接收操作;<xref:System.Messaging.MessageQueue>通知，通过引发<xref:System.Messaging.MessageQueue.ReceiveCompleted>事件时，如果有消息到达队列中。 <xref:System.Messaging.MessageQueue>然后通过调用访问消息<xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29>。  
  
 <xref:System.Messaging.MessageQueue.BeginReceive%2A>方法将立即返回，但直到调用事件处理程序，则不会完成异步操作。  
  
 因为<xref:System.Messaging.MessageQueue.BeginReceive%2A>是异步的您可以调用它可接收来自队列的消息，而不会阻止当前线程的执行。 若要以同步方式接收一条消息，使用<xref:System.Messaging.MessageQueue.Receive%2A>方法。  
  
 异步操作完成后，可以调用<xref:System.Messaging.MessageQueue.BeginPeek%2A>或<xref:System.Messaging.MessageQueue.BeginReceive%2A>再次在事件处理程序以继续接收通知。  
  
 <xref:System.IAsyncResult>的<xref:System.Messaging.MessageQueue.BeginReceive%2A>返回标识方法启动的异步操作。 可以使用此<xref:System.IAsyncResult>的整个生存期内操作，尽管您通常不使用它直到<xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29>调用。 但是，如果启动多个异步操作，你可以放置其<xref:System.IAsyncResult>值数组中，并指定是否要等待的所有操作或任何操作完成。 在这种情况下，使用<xref:System.IAsyncResult.AsyncWaitHandle%2A>属性的<xref:System.IAsyncResult>来标识已完成的操作。  
  
 如果<xref:System.Messaging.MessageQueue.CanRead%2A>是`false`，则引发完成事件，但调用时，将引发异常<xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29>。  
  
 不使用异步调用<xref:System.Messaging.MessageQueue.BeginReceive%2A>与事务。 如果你想要执行的事务的异步操作，调用<xref:System.Messaging.MessageQueue.BeginPeek%2A>，并将该事务和 （同步） 放<xref:System.Messaging.MessageQueue.Receive%2A>查看操作中创建的事件处理程序方法。 事件处理程序可能包含的功能，如下面的 C# 代码中所示。  
  
```csharp  
myMessageQueue.BeginTransaction();  
 myMessageQueue.Receive();  
 myMessageQueue.CommitTransaction();  
```  
  
 下表显示了此方法是在各种工作组模式下可用。  
  
|工作组模式下|可用|  
|--------------------|---------------|  
|本地计算机|是|  
|本地计算机和直接格式名|是|  
|远程计算机|否|  
|远程计算机并直接格式名|是|  
  
   
  
## Examples  
 下面的代码示例链接异步请求。 它假定名为"myQueue"的本地计算机上没有队列。 `Main`函数启动异步操作由处理`MyReceiveCompleted`例程。 `MyReceiveCompleted` 处理当前消息并开始一个新异步接收操作。  
  
 [!code-cpp[MessageQueue.BeginReceive_noparms_combined#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.BeginReceive_noparms_combined/CPP/mqbeginreceive_noparms_mre.cpp#1)]
 [!code-csharp[MessageQueue.BeginReceive_noparms_combined#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.BeginReceive_noparms_combined/CS/mqbeginreceive_noparms_mre.cs#1)]
 [!code-vb[MessageQueue.BeginReceive_noparms_combined#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.BeginReceive_noparms_combined/VB/mqbeginreceive_noparms_mre.vb#1)]  
  
 下面的代码示例将异步请求排队。 在调用<xref:System.Messaging.MessageQueue.BeginReceive%2A>使用<xref:System.IAsyncResult.AsyncWaitHandle%2A>其返回值中。 `Main`例程等待所有异步操作完成后才退出。  
  
 [!code-cpp[MessageQueue.BeginReceive_noparms_combined#2](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.BeginReceive_noparms_combined/CPP/mqbeginreceive_noparms_wh.cpp#2)]
 [!code-csharp[MessageQueue.BeginReceive_noparms_combined#2](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.BeginReceive_noparms_combined/CS/mqbeginreceive_noparms_wh.cs#2)]
 [!code-vb[MessageQueue.BeginReceive_noparms_combined#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.BeginReceive_noparms_combined/VB/mqbeginreceive_noparms_wh.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">访问“消息队列”方法时出错。</exception>
        <threadsafe>该方法不是线程安全。</threadsafe>
        <altmember cref="E:System.Messaging.MessageQueue.ReceiveCompleted" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
      </Docs>
    </Member>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginReceive(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginReceive (timeout As TimeSpan) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.BeginReceive : TimeSpan -&gt; IAsyncResult" Usage="messageQueue.BeginReceive timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">一个 <see cref="T:System.TimeSpan" /> 指示等待消息变为可用所用的时间间隔。</param>
        <summary>启动具有指定超时设定的异步接收操作。直到队列中出现消息时或发生超时时才完成操作。</summary>
        <returns>该 <see cref="T:System.IAsyncResult" /> 标识已发布的异步请求的。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在异步处理，您将使用<xref:System.Messaging.MessageQueue.BeginReceive%2A>引发<xref:System.Messaging.MessageQueue.ReceiveCompleted>一条消息变为可用的队列中，或指定的时间间隔已过期时的事件。  
  
 <xref:System.Messaging.MessageQueue.ReceiveCompleted> 也会引发如果一条消息在队列中已存在。  
  
 若要使用<xref:System.Messaging.MessageQueue.BeginReceive%2A>、 创建的事件处理程序处理异步操作的结果，并将其与事件委托。 <xref:System.Messaging.MessageQueue.BeginReceive%2A> 启动异步接收操作;<xref:System.Messaging.MessageQueue>通知，通过引发<xref:System.Messaging.MessageQueue.ReceiveCompleted>事件时，如果有消息到达队列中。 <xref:System.Messaging.MessageQueue>然后通过调用访问消息<xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29>或检索结果使用<xref:System.Messaging.ReceiveCompletedEventArgs>。  
  
 <xref:System.Messaging.MessageQueue.BeginReceive%2A>方法将立即返回，但直到调用事件处理程序，则不会完成异步操作。  
  
 因为<xref:System.Messaging.MessageQueue.BeginReceive%2A>是异步的您可以调用它可接收来自队列的消息，而不会阻止当前线程的执行。 若要以同步方式接收一条消息，使用<xref:System.Messaging.MessageQueue.Receive%2A>方法。  
  
 异步操作完成后，可以调用<xref:System.Messaging.MessageQueue.BeginPeek%2A>或<xref:System.Messaging.MessageQueue.BeginReceive%2A>再次在事件处理程序以继续接收通知。  
  
 如果<xref:System.Messaging.MessageQueue.CanRead%2A>是`false`，则引发完成事件，但调用时，将引发异常<xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29>。  
  
 <xref:System.IAsyncResult>的<xref:System.Messaging.MessageQueue.BeginReceive%2A>返回标识方法启动的异步操作。 可以使用此<xref:System.IAsyncResult>的整个生存期内操作，尽管您通常不使用它直到<xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29>调用。 但是，如果启动多个异步操作，你可以放置其<xref:System.IAsyncResult>值数组中，并指定是否要等待的所有操作或任何操作完成。 在这种情况下，使用<xref:System.IAsyncResult.AsyncWaitHandle%2A>属性的<xref:System.IAsyncResult>来标识已完成的操作。  
  
 此重载指定超时值。如果指定的间隔`timeout`参数过期，则此组件将产生<xref:System.Messaging.MessageQueue.ReceiveCompleted>事件。 因为没有消息，随后调用<xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29>将引发异常。  
  
 不使用异步调用<xref:System.Messaging.MessageQueue.BeginReceive%2A>与事务。 如果你想要执行的事务的异步操作，调用<xref:System.Messaging.MessageQueue.BeginPeek%2A>，并将该事务和 （同步） 放<xref:System.Messaging.MessageQueue.Receive%2A>查看操作中创建的事件处理程序方法。 事件处理程序可能包含的功能，如下面的 C# 代码中所示。  
  
```csharp  
myMessageQueue.BeginTransaction();  
 myMessageQueue.Receive();  
 myMessageQueue.CommitTransaction();  
```  
  
 下表显示了此方法是在各种工作组模式下可用。  
  
|工作组模式下|可用|  
|--------------------|---------------|  
|本地计算机|是|  
|本地计算机和直接格式名|是|  
|远程计算机|否|  
|远程计算机并直接格式名|是|  
  
   
  
## Examples  
 下面的代码示例创建异步接收操作。 该代码示例创建一个事件处理程序`MyReceiveCompleted`，并将其附加到<xref:System.Messaging.MessageQueue.ReceiveCompleted>事件处理程序委托。 代码示例将消息发送到本地消息队列，然后调用<xref:System.Messaging.MessageQueue.BeginReceive%28System.TimeSpan%29>、 传入十秒的超时值。 当<xref:System.Messaging.MessageQueue.ReceiveCompleted>引发事件，事件处理程序接收的消息并将消息正文写到屏幕。  
  
 [!code-cpp[MessageQueueBeginReceive1#0](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueueBeginReceive1/cpp/class1.cpp#0)]
 [!code-csharp[MessageQueueBeginReceive1#0](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueueBeginReceive1/CS/class1.cs#0)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">为 <paramref name="timeout" /> 参数指定的值无效，可能是因为它表示负数。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">访问“消息队列”方法时出错。</exception>
        <threadsafe>该方法不是线程安全。</threadsafe>
        <altmember cref="E:System.Messaging.MessageQueue.ReceiveCompleted" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="T:System.TimeSpan" />
      </Docs>
    </Member>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (TimeSpan timeout, object stateObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(valuetype System.TimeSpan timeout, object stateObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginReceive(System.TimeSpan,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginReceive (timeout As TimeSpan, stateObject As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(TimeSpan timeout, System::Object ^ stateObject);" />
      <MemberSignature Language="F#" Value="member this.BeginReceive : TimeSpan * obj -&gt; IAsyncResult" Usage="messageQueue.BeginReceive (timeout, stateObject)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="stateObject" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="timeout">一个 <see cref="T:System.TimeSpan" /> 指示等待消息变为可用所用的时间间隔。</param>
        <param name="stateObject">应用程序指定的状态对象，包含与异步操作关联的信息。</param>
        <summary>启动具有指定超时设定和指定状态对象的异步接收操作，此状态对象在操作的整个生存期内提供相关信息。 直到队列中出现消息时或发生超时时才完成操作。</summary>
        <returns>该 <see cref="T:System.IAsyncResult" /> 标识已发布的异步请求的。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在异步处理，您将使用<xref:System.Messaging.MessageQueue.BeginReceive%2A>引发<xref:System.Messaging.MessageQueue.ReceiveCompleted>一条消息变为可用的队列中，或指定的时间间隔已过期时的事件。  
  
 <xref:System.Messaging.MessageQueue.ReceiveCompleted> 也会引发如果一条消息在队列中已存在。  
  
 使用此重载能够将整个操作的整个生存期内保留该操作相关联的信息。 事件处理程序可通过查看来检测此信息<xref:System.IAsyncResult.AsyncState%2A>属性的<xref:System.IAsyncResult>与操作相关联。  
  
 若要使用<xref:System.Messaging.MessageQueue.BeginReceive%2A>、 创建的事件处理程序处理异步操作的结果，并将其与事件委托。 <xref:System.Messaging.MessageQueue.BeginReceive%2A> 启动异步接收操作;<xref:System.Messaging.MessageQueue>通知，通过引发<xref:System.Messaging.MessageQueue.ReceiveCompleted>事件时，如果有消息到达队列中。 <xref:System.Messaging.MessageQueue>然后通过调用访问消息<xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29>或检索结果使用<xref:System.Messaging.ReceiveCompletedEventArgs>。  
  
 <xref:System.Messaging.MessageQueue.BeginReceive%2A>方法将立即返回，但直到调用事件处理程序，则不会完成异步操作。  
  
 因为<xref:System.Messaging.MessageQueue.BeginReceive%2A>是异步的您可以调用它可接收来自队列的消息，而不会阻止当前线程的执行。 若要以同步方式接收一条消息，使用<xref:System.Messaging.MessageQueue.Receive%2A>方法。  
  
 异步操作完成后，可以调用<xref:System.Messaging.MessageQueue.BeginPeek%2A>或<xref:System.Messaging.MessageQueue.BeginReceive%2A>再次在事件处理程序以继续接收通知。  
  
 <xref:System.IAsyncResult>的<xref:System.Messaging.MessageQueue.BeginReceive%2A>返回标识方法启动的异步操作。 可以使用此<xref:System.IAsyncResult>的整个生存期内操作，尽管您通常不使用它直到<xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29>调用。 但是，如果启动多个异步操作，你可以放置其<xref:System.IAsyncResult>值数组中，并指定是否要等待的所有操作或任何操作完成。 在这种情况下，使用<xref:System.IAsyncResult.AsyncWaitHandle%2A>属性的<xref:System.IAsyncResult>来标识已完成的操作。  
  
 此重载指定超时和状态对象。 如果指定的间隔`timeout`参数过期，则此组件将产生<xref:System.Messaging.MessageQueue.ReceiveCompleted>事件。 因为没有消息，随后调用<xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29>将引发异常。  
  
 状态对象将与操作相关联的状态信息。 例如，如果您调用<xref:System.Messaging.MessageQueue.BeginReceive%2A>多次启动多个操作，你可以指定通过单独的状态对象定义的每个操作。  
  
 状态对象还可用于进程线程中传递信息。 如果线程已启动，但回调是在另一个线程在异步方案中，状态对象是封送，并从该事件返回与信息一起传递。  
  
 不使用异步调用<xref:System.Messaging.MessageQueue.BeginReceive%2A>与事务。 如果你想要执行的事务的异步操作，调用<xref:System.Messaging.MessageQueue.BeginPeek%2A>，并将该事务和 （同步） 放<xref:System.Messaging.MessageQueue.Receive%2A>查看操作中创建的事件处理程序方法。 事件处理程序可能包含的功能，如下面的 C# 代码中所示。  
  
```csharp  
myMessageQueue.BeginTransaction();  
 myMessageQueue.Receive();  
 myMessageQueue.CommitTransaction();  
```  
  
 下表显示了此方法是在各种工作组模式下可用。  
  
|工作组模式下|可用|  
|--------------------|---------------|  
|本地计算机|是|  
|本地计算机和直接格式名|是|  
|远程计算机|否|  
|远程计算机并直接格式名|是|  
  
   
  
## Examples  
 下面的代码示例创建异步接收操作。 该代码示例创建一个事件处理程序`MyReceiveCompleted`，并将其附加到<xref:System.Messaging.MessageQueue.ReceiveCompleted>事件处理程序委托。 代码示例将消息发送到本地消息队列，然后调用<xref:System.Messaging.MessageQueue.BeginReceive%28System.TimeSpan%2CSystem.Object%29>、 传入超时值为 10 秒并标识该特定消息的唯一整数。 当<xref:System.Messaging.MessageQueue.ReceiveCompleted>引发事件、 事件处理程序接收消息，并在屏幕上写入消息正文和整数消息标识符。  
  
 [!code-cpp[MessageQueueBeginReceive2#0](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueueBeginReceive2/cpp/class1.cpp#0)]
 [!code-csharp[MessageQueueBeginReceive2#0](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueueBeginReceive2/CS/class1.cs#0)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">为 <paramref name="timeout" /> 参数指定的值无效。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">访问“消息队列”方法时出错。</exception>
        <threadsafe>该方法不是线程安全。</threadsafe>
        <altmember cref="E:System.Messaging.MessageQueue.ReceiveCompleted" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="T:System.TimeSpan" />
      </Docs>
    </Member>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (TimeSpan timeout, object stateObject, AsyncCallback callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(valuetype System.TimeSpan timeout, object stateObject, class System.AsyncCallback callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginReceive(System.TimeSpan,System.Object,System.AsyncCallback)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginReceive (timeout As TimeSpan, stateObject As Object, callback As AsyncCallback) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(TimeSpan timeout, System::Object ^ stateObject, AsyncCallback ^ callback);" />
      <MemberSignature Language="F#" Value="member this.BeginReceive : TimeSpan * obj * AsyncCallback -&gt; IAsyncResult" Usage="messageQueue.BeginReceive (timeout, stateObject, callback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="stateObject" Type="System.Object" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
      </Parameters>
      <Docs>
        <param name="timeout">一个 <see cref="T:System.TimeSpan" /> 指示等待消息变为可用所用的时间间隔。</param>
        <param name="stateObject">应用程序指定的状态对象，包含与异步操作关联的信息。</param>
        <param name="callback">该 <see cref="T:System.AsyncCallback" /> 将接收异步操作完成通知。</param>
        <summary>启动具有指定超时设定和指定状态对象的异步接收操作，此状态对象在操作的整个生存期内提供相关信息。 此重载通过回调接收操作的事件处理程序标识的通知。 直到队列中出现消息时或发生超时时才完成操作。</summary>
        <returns>该 <see cref="T:System.IAsyncResult" /> 标识已发布的异步请求的。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 一条消息变为可用的队列中或者指定的时间间隔已过期; 时，使用此重载，直接调用的回调参数中指定的回调<xref:System.Messaging.MessageQueue.ReceiveCompleted>不会引发事件。 其他重载<xref:System.Messaging.MessageQueue.BeginReceive%2A>依赖于此组件以引发<xref:System.Messaging.MessageQueue.ReceiveCompleted>事件。  
  
 <xref:System.Messaging.MessageQueue.ReceiveCompleted> 也会引发如果一条消息在队列中已存在。  
  
 若要使用<xref:System.Messaging.MessageQueue.BeginReceive%2A>、 创建的事件处理程序处理异步操作的结果，并将其与事件委托。 <xref:System.Messaging.MessageQueue.BeginReceive%2A> 启动异步接收操作;<xref:System.Messaging.MessageQueue>通知，通过引发<xref:System.Messaging.MessageQueue.ReceiveCompleted>事件时，如果有消息到达队列中。 <xref:System.Messaging.MessageQueue>然后通过调用访问消息<xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29>或检索结果使用<xref:System.Messaging.ReceiveCompletedEventArgs>。  
  
 <xref:System.Messaging.MessageQueue.BeginReceive%2A>方法将立即返回，但直到调用事件处理程序，则不会完成异步操作。  
  
 因为<xref:System.Messaging.MessageQueue.BeginReceive%2A>是异步的您可以调用它可接收来自队列的消息，而不会阻止当前线程的执行。 若要以同步方式接收一条消息，使用<xref:System.Messaging.MessageQueue.Receive%2A>方法。  
  
 异步操作完成后，可以调用<xref:System.Messaging.MessageQueue.BeginPeek%2A>或<xref:System.Messaging.MessageQueue.BeginReceive%2A>再次在事件处理程序以继续接收通知。  
  
 <xref:System.IAsyncResult>的<xref:System.Messaging.MessageQueue.BeginReceive%2A>返回标识方法启动的异步操作。 可以使用此<xref:System.IAsyncResult>的整个生存期内操作，尽管您通常不使用它直到<xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29>调用。 但是，如果启动多个异步操作，你可以放置其<xref:System.IAsyncResult>值数组中，并指定是否要等待的所有操作或任何操作完成。 在这种情况下，使用<xref:System.IAsyncResult.AsyncWaitHandle%2A>属性的<xref:System.IAsyncResult>来标识已完成的操作。  
  
 状态对象将与操作相关联的状态信息。 例如，如果您调用<xref:System.Messaging.MessageQueue.BeginReceive%2A>多次启动多个操作，你可以指定通过单独的状态对象定义的每个操作。  
  
 状态对象还可用于进程线程中传递信息。 如果线程已启动，但回调是在另一个线程在异步方案中，状态对象是封送，并从该事件返回与信息一起传递。  
  
 不使用异步调用<xref:System.Messaging.MessageQueue.BeginReceive%2A>与事务。 如果你想要执行的事务的异步操作，调用<xref:System.Messaging.MessageQueue.BeginPeek%2A>，并将该事务和 （同步） 放<xref:System.Messaging.MessageQueue.Receive%2A>查看操作中创建的事件处理程序方法。 事件处理程序可能包含的功能，如下面的 C# 代码中所示。  
  
```csharp  
myMessageQueue.BeginTransaction();  
 myMessageQueue.Receive();  
 myMessageQueue.CommitTransaction();  
```  
  
 下表显示了此方法是在各种工作组模式下可用。  
  
|工作组模式下|可用|  
|--------------------|---------------|  
|本地计算机|是|  
|本地计算机和直接格式名|是|  
|远程计算机|否|  
|远程计算机并直接格式名|是|  
  
   
  
## Examples  
 下面的代码示例创建异步接收操作。 代码示例将消息发送到本地消息队列，然后调用<xref:System.Messaging.MessageQueue.BeginReceive%28System.TimeSpan%2CSystem.Object%2CSystem.AsyncCallback%29>，并传入： 十秒的超时值; 标识该特定消息; 和的新实例的唯一整数<xref:System.AsyncCallback>，用于标识事件处理程序`MyReceiveCompleted`. 当<xref:System.Messaging.MessageQueue.ReceiveCompleted>引发事件、 事件处理程序接收消息，并在屏幕上写入消息正文和整数消息标识符。  
  
 [!code-cpp[MessageQueueBeginReceive3#0](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueueBeginReceive3/cpp/class1.cpp#0)]
 [!code-csharp[MessageQueueBeginReceive3#0](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueueBeginReceive3/CS/class1.cs#0)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">为 <paramref name="timeout" /> 参数指定的值无效。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">访问“消息队列”方法时出错。</exception>
        <threadsafe>该方法不是线程安全。</threadsafe>
        <altmember cref="E:System.Messaging.MessageQueue.ReceiveCompleted" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="T:System.TimeSpan" />
      </Docs>
    </Member>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (TimeSpan timeout, System.Messaging.Cursor cursor, object state, AsyncCallback callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(valuetype System.TimeSpan timeout, class System.Messaging.Cursor cursor, object state, class System.AsyncCallback callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginReceive(System.TimeSpan,System.Messaging.Cursor,System.Object,System.AsyncCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(TimeSpan timeout, System::Messaging::Cursor ^ cursor, System::Object ^ state, AsyncCallback ^ callback);" />
      <MemberSignature Language="F#" Value="member this.BeginReceive : TimeSpan * System.Messaging.Cursor * obj * AsyncCallback -&gt; IAsyncResult" Usage="messageQueue.BeginReceive (timeout, cursor, state, callback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="cursor" Type="System.Messaging.Cursor" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
      </Parameters>
      <Docs>
        <param name="timeout">一个 <see cref="T:System.TimeSpan" /> 指示等待消息变为可用所用的时间间隔。</param>
        <param name="cursor">维持消息队列中特定位置的 <see cref="T:System.Messaging.Cursor" />。</param>
        <param name="state">应用程序指定的状态对象，包含与异步操作关联的信息。</param>
        <param name="callback">该 <see cref="T:System.AsyncCallback" /> 将接收异步操作完成通知。</param>
        <summary>启动异步接收操作，此操作具有指定的超时并使用指定的游标和指定的状态对象。 状态对象在操作的整个生存期内提供相关的信息。 此重载通过回调接收操作的事件处理程序标识的通知。 直到队列中出现消息时或发生超时时才完成操作。</summary>
        <returns>该 <see cref="T:System.IAsyncResult" /> 标识已发布的异步请求的。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 一条消息变为可用的队列中或者指定的时间间隔已过期; 时，使用此重载，直接调用的回调参数中指定的回调<xref:System.Messaging.MessageQueue.ReceiveCompleted>不会引发事件。 其他重载<xref:System.Messaging.MessageQueue.BeginReceive%2A>依赖于此组件以引发<xref:System.Messaging.MessageQueue.ReceiveCompleted>事件。  
  
 <xref:System.Messaging.MessageQueue.ReceiveCompleted> 也会引发如果一条消息在队列中已存在。  
  
 若要使用<xref:System.Messaging.MessageQueue.BeginReceive%2A>、 创建的事件处理程序处理异步操作的结果，并将其与事件委托。 <xref:System.Messaging.MessageQueue.BeginReceive%2A> 启动异步接收操作;<xref:System.Messaging.MessageQueue>通知，通过引发<xref:System.Messaging.MessageQueue.ReceiveCompleted>事件时，如果有消息到达队列中。 <xref:System.Messaging.MessageQueue>然后通过调用访问消息<xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29>或检索结果使用<xref:System.Messaging.ReceiveCompletedEventArgs>。  
  
 <xref:System.Messaging.MessageQueue.BeginReceive%2A>方法将立即返回，但直到调用事件处理程序，则不会完成异步操作。  
  
 因为<xref:System.Messaging.MessageQueue.BeginReceive%2A>是异步的您可以调用它可接收来自队列的消息，而不会阻止当前线程的执行。 若要以同步方式接收一条消息，使用<xref:System.Messaging.MessageQueue.Receive%2A>方法。  
  
 异步操作完成后，可以调用<xref:System.Messaging.MessageQueue.BeginPeek%2A>或<xref:System.Messaging.MessageQueue.BeginReceive%2A>再次在事件处理程序以继续接收通知。  
  
 <xref:System.IAsyncResult>的<xref:System.Messaging.MessageQueue.BeginReceive%2A>返回标识方法启动的异步操作。 可以使用此<xref:System.IAsyncResult>的整个生存期内操作，尽管您通常不使用它直到<xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29>调用。 但是，如果启动多个异步操作，你可以放置其<xref:System.IAsyncResult>值数组中，并指定是否要等待的所有操作或任何操作完成。 在这种情况下，使用<xref:System.IAsyncResult.AsyncWaitHandle%2A>属性的<xref:System.IAsyncResult>来标识已完成的操作。  
  
 状态对象将与操作相关联的状态信息。 例如，如果您调用<xref:System.Messaging.MessageQueue.BeginReceive%2A>多次启动多个操作，你可以指定通过单独的状态对象定义的每个操作。  
  
 状态对象还可用于进程线程中传递信息。 如果线程已启动，但回调是在另一个线程在异步方案中，状态对象是封送，并从该事件返回与信息一起传递。  
  
 不使用异步调用<xref:System.Messaging.MessageQueue.BeginReceive%2A>与事务。 如果你想要执行的事务的异步操作，调用<xref:System.Messaging.MessageQueue.BeginPeek%2A>，并将该事务和 （同步） 放<xref:System.Messaging.MessageQueue.Receive%2A>查看操作中创建的事件处理程序方法。 事件处理程序可能包含的功能，如下面的 C# 代码中所示。  
  
```csharp  
myMessageQueue.BeginTransaction();  
 myMessageQueue.Receive();  
 myMessageQueue.CommitTransaction();  
```  
  
 下表显示了此方法是在各种工作组模式下可用。  
  
|工作组模式下|可用|  
|--------------------|---------------|  
|本地计算机|是|  
|本地计算机和直接格式名|是|  
|远程计算机|否|  
|远程计算机并直接格式名|是|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="cursor" /> 参数为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">为 <paramref name="timeout" /> 参数指定的值无效。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">访问“消息队列”方法时出错。</exception>
        <threadsafe>该方法不是线程安全。</threadsafe>
        <altmember cref="T:System.Messaging.Cursor" />
        <altmember cref="E:System.Messaging.MessageQueue.ReceiveCompleted" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="T:System.TimeSpan" />
      </Docs>
    </Member>
    <Member MemberName="CanRead">
      <MemberSignature Language="C#" Value="public bool CanRead { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanRead" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.CanRead" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CanRead As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CanRead { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanRead : bool" Usage="System.Messaging.MessageQueue.CanRead" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_CanRead")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示 <see cref="T:System.Messaging.MessageQueue" /> 是否可读。</summary>
        <value>如果存在 <see cref="T:System.Messaging.MessageQueue" /> 而且应用程序可从其中读取，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.CanRead%2A> 指示应用程序是否能够查看或从队列接收消息。 如果<xref:System.Messaging.MessageQueue.CanRead%2A>是`true`，则<xref:System.Messaging.MessageQueue>可以接收或查看队列中的消息。 否则，不能。  
  
 <xref:System.Messaging.MessageQueue.CanRead%2A> 是`false`如果队列已打开具有独占读取访问权限 (或如果它是开放的非独占访问，这<xref:System.Messaging.MessageQueue>请求独占访问权限)，或如果应用程序不具有足够的权限来访问它。 如果你的应用程序尝试从队列中读取时<xref:System.Messaging.MessageQueue.CanRead%2A>是`false`，访问被拒绝。  
  
 下表显示了此属性是否可在各种工作组模式下。  
  
|工作组模式下|可用|  
|--------------------|---------------|  
|本地计算机|是|  
|本地计算机和直接格式名|是|  
|远程计算机|否|  
|远程计算机并直接格式名|是|  
  
   
  
## Examples  
 下面的代码示例显示一个消息队列的值<xref:System.Messaging.MessageQueue.CanRead%2A>属性。  
  
 [!code-csharp[MessageQueue#5](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#5)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Messaging.MessageQueue.CanWrite" />
        <altmember cref="P:System.Messaging.MessageQueue.ReadHandle" />
      </Docs>
    </Member>
    <Member MemberName="CanWrite">
      <MemberSignature Language="C#" Value="public bool CanWrite { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanWrite" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.CanWrite" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CanWrite As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CanWrite { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanWrite : bool" Usage="System.Messaging.MessageQueue.CanWrite" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_CanWrite")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示 <see cref="T:System.Messaging.MessageQueue" /> 是否可写。</summary>
        <value>如果存在 <see cref="T:System.Messaging.MessageQueue" /> 而且应用程序可向其中写入，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.CanWrite%2A> 指示应用程序是否能够将消息发送到队列。 如果<xref:System.Messaging.MessageQueue.CanWrite%2A>是`true`，则<xref:System.Messaging.MessageQueue>可以向队列发送消息。 否则，不能。  
  
 <xref:System.Messaging.MessageQueue.CanWrite%2A> 是`false`如果队列已用独占写访问权限打开 (或如果它是开放的非独占访问，这<xref:System.Messaging.MessageQueue>请求独占访问权限)，或如果应用程序不具有足够的权限来访问它。 如果你的应用程序尝试写入队列时<xref:System.Messaging.MessageQueue.CanWrite%2A>是`false`，访问被拒绝。  
  
 下表显示了此属性是否可在各种工作组模式下。  
  
|工作组模式下|可用|  
|--------------------|---------------|  
|本地计算机|是|  
|本地计算机和直接格式名|是|  
|远程计算机|否|  
|远程计算机并直接格式名|是|  
  
   
  
## Examples  
 下面的代码示例显示一个消息队列的值<xref:System.Messaging.MessageQueue.CanWrite%2A>属性。  
  
 [!code-csharp[MessageQueue#6](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#6)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Messaging.MessageQueue.WriteHandle" />
        <altmember cref="P:System.Messaging.MessageQueue.CanRead" />
      </Docs>
    </Member>
    <Member MemberName="Category">
      <MemberSignature Language="C#" Value="public Guid Category { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Guid Category" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.Category" />
      <MemberSignature Language="VB.NET" Value="Public Property Category As Guid" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Guid Category { Guid get(); void set(Guid value); };" />
      <MemberSignature Language="F#" Value="member this.Category : Guid with get, set" Usage="System.Messaging.MessageQueue.Category" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_Category")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Guid</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置队列类别。</summary>
        <value>
          <see cref="T:System.Guid" />，表示队列类别（“消息队列”类型标识符），它允许应用程序将其队列分类。 默认值为 <see langword="Guid.empty" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 队列类别允许应用程序将其队列分类。 例如，可以将所有计费队列都放在一个类别和另一个中的所有订单队列中。  
  
 <xref:System.Messaging.MessageQueue.Category%2A>属性提供访问权限的消息队列类型 ID 属性 （这是读/写），可通过访问**队列属性**计算机管理控制台中的对话框。 您可以定义新类别。 尽管可以使用<xref:System.Guid.NewGuid%2A>若要创建跨所有都是唯一的类别值<xref:System.Guid>值，此操作是不必要的。 类别值必须是只能从其他类别，不能从其他所有非重复<xref:System.Guid>值。 例如，您可以将分配{00000000-0000-0000-0000-000000000001}作为<xref:System.Messaging.MessageQueue.Category%2A>获取队列的一套并{00000000-0000-0000-0000-000000000002}作为<xref:System.Messaging.MessageQueue.Category%2A>为另一组。  
  
 不需要设置<xref:System.Messaging.MessageQueue.Category%2A>。 该值可以为 `null`。  
  
 设置此属性修改消息队列队列。 因此，任何其他<xref:System.Messaging.MessageQueue>更改会影响实例。  
  
 下表显示了此属性是否可在各种工作组模式下。  
  
|工作组模式下|可用|  
|--------------------|---------------|  
|本地计算机|是|  
|本地计算机和直接格式名|是|  
|远程计算机|否|  
|远程计算机并直接格式名|否|  
  
   
  
## Examples  
 下面的代码示例获取和设置的值的消息队列的<xref:System.Messaging.MessageQueue.Category%2A>属性。  
  
 [!code-csharp[MessageQueue#7](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">队列类别被设置为无效值。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">访问“消息队列”方法时出错。</exception>
        <altmember cref="P:System.Messaging.MessageQueue.Id" />
        <altmember cref="P:System.Messaging.MessageQueue.Label" />
        <altmember cref="M:System.Messaging.MessageQueue.GetPublicQueues" />
      </Docs>
    </Member>
    <Member MemberName="ClearConnectionCache">
      <MemberSignature Language="C#" Value="public static void ClearConnectionCache ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ClearConnectionCache() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ClearConnectionCache" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ClearConnectionCache ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ClearConnectionCache();" />
      <MemberSignature Language="F#" Value="static member ClearConnectionCache : unit -&gt; unit" Usage="System.Messaging.MessageQueue.ClearConnectionCache " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>清除连接缓存。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当您调用<xref:System.Messaging.MessageQueue.ClearConnectionCache%2A>、 删除存储在缓存中的格式名称和关闭句柄打开并存储在缓存中。  
  
 下表显示了此方法是在各种工作组模式下可用。  
  
|工作组模式下|可用|  
|--------------------|---------------|  
|本地计算机|是|  
|本地计算机和直接格式名|是|  
|远程计算机|是|  
|远程计算机并直接格式名|是|  
  
   
  
## Examples  
 下面的代码示例调用 <xref:System.Messaging.MessageQueue.ClearConnectionCache%2A>。  
  
 [!code-csharp[MessageQueue#8](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#8)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close();" />
      <MemberSignature Language="F#" Value="member this.Close : unit -&gt; unit" Usage="messageQueue.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>释放 <see cref="T:System.Messaging.MessageQueue" /> 分配的所有资源。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.Close%2A> 释放与关联的所有资源<xref:System.Messaging.MessageQueue>，如果适用，包括共享资源。 系统自动重新获取这些资源它们是否仍然可用，例如调用<xref:System.Messaging.MessageQueue.Send%28System.Object%29>方法，如下面的 C# 代码所示。  
  
```csharp  
myMessageQueue.Send("Text 1.");  
myMessageQueue.Close();  
myMessageQueue.Send("Text 2."); //Resources are re-acquired.  
```  
  
 当您调用<xref:System.Messaging.MessageQueue.Close%2A>，则所有<xref:System.Messaging.MessageQueue>用于直接访问消息队列队列的属性会清除。<xref:System.Messaging.MessageQueue.Path%2A>， <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>， <xref:System.Messaging.MessageQueue.Formatter%2A>，和<xref:System.Messaging.MessageQueue.MessageReadPropertyFilter%2A>所有保持不变。  
  
 <xref:System.Messaging.MessageQueue.Close%2A> 不会不总是免费读和写到队列，句柄，因为它们可能被共享。 您可以采取以下步骤以确保<xref:System.Messaging.MessageQueue.Close%2A>释放到队列的读取和写入句柄：  
  
-   创建<xref:System.Messaging.MessageQueue>获得独占访问权限。 若要执行此操作，调用<xref:System.Messaging.MessageQueue.%23ctor%28System.String%2CSystem.Boolean%29>或<xref:System.Messaging.MessageQueue.%23ctor%28System.String%2CSystem.Boolean%2CSystem.Boolean%29>构造函数和集`sharedModeDenyReceive`参数`true`。  
  
-   创建<xref:System.Messaging.MessageQueue>禁用了连接缓存。 若要执行此操作，调用<xref:System.Messaging.MessageQueue.%23ctor%28System.String%2CSystem.Boolean%2CSystem.Boolean%29>构造函数和集`enableConnectionCache`参数`false`。  
  
-   禁用连接缓存。 若要执行此操作，设置<xref:System.Messaging.MessageQueue.EnableConnectionCache%2A>属性设置为`false`。  
  
 应调用<xref:System.Messaging.MessageQueue.Close%2A>队列删除消息队列服务器上的队列。 否则为发送到队列的消息可能会引发异常或出现在死信队列。  
  
 下表显示了此方法是在各种工作组模式下可用。  
  
|工作组模式下|可用|  
|--------------------|---------------|  
|本地计算机|是|  
|本地计算机和直接格式名|是|  
|远程计算机|是|  
|远程计算机并直接格式名|是|  
  
   
  
## Examples  
 下面的代码示例将关闭消息队列的队列。  
  
 [!code-cpp[MessageQueue.Close#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Close/CPP/mqclose.cpp#1)]
 [!code-csharp[MessageQueue.Close#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Close/CS/mqclose.cs#1)]
 [!code-vb[MessageQueue.Close#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Close/VB/mqclose.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Create">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>在“消息队列”服务器上的指定路径中创建新队列。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueue Create (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueue Create(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Create(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create (path As String) As MessageQueue" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Messaging::MessageQueue ^ Create(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member Create : string -&gt; System.Messaging.MessageQueue" Usage="System.Messaging.MessageQueue.Create path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">要创建的队列的路径。</param>
        <summary>在指定的路径中创建非事务性“消息队列”队列。</summary>
        <returns>表示新队列的 <see cref="T:System.Messaging.MessageQueue" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用此重载以创建消息队列的非事务性队列。  
  
 若要创建的新实例<xref:System.Messaging.MessageQueue>类在应用程序中并将其绑定到现有队列，请使用<xref:System.Messaging.MessageQueue.%23ctor%2A>构造函数。 若要在消息队列中创建一个新队列，调用<xref:System.Messaging.MessageQueue.Create%28System.String%29>。  
  
 语法`path`参数取决于队列的类型它的引用下, 表中所示。  
  
|队列类型|语法|  
|----------------|------------|  
|公用队列|`MachineName`\\`QueueName`|  
|专用队列|`MachineName`\\`Private$`\\`QueueName`|  
  
 使用"。"本地计算机。 有关更多语法，请参阅<xref:System.Messaging.MessageQueue.Path%2A>属性。  
  
 下表显示了此方法是在各种工作组模式下可用。  
  
|工作组模式下|可用|  
|--------------------|---------------|  
|本地计算机|是|  
|本地计算机和直接格式名|是|  
|远程计算机|否|  
|远程计算机并直接格式名|否|  
  
   
  
## Examples  
 下面的代码示例创建公用和专用队列。 它将一条消息发送到所选队列。  
  
 [!code-cpp[MessageQueue.Create_path#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Create_path/CPP/mqcreate.cpp#1)]
 [!code-csharp[MessageQueue.Create_path#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Create_path/CS/mqcreate.cs#1)]
 [!code-vb[MessageQueue.Create_path#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Create_path/VB/mqcreate.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> 参数为 <see langword="null" /> 或者是空字符串 ("")。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">队列已存在于指定的路径中。  
  
或 
访问“消息队列”方法时出错。</exception>
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
        <altmember cref="M:System.Messaging.MessageQueue.#ctor" />
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueue Create (string path, bool transactional);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueue Create(string path, bool transactional) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Create(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create (path As String, transactional As Boolean) As MessageQueue" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Messaging::MessageQueue ^ Create(System::String ^ path, bool transactional);" />
      <MemberSignature Language="F#" Value="static member Create : string * bool -&gt; System.Messaging.MessageQueue" Usage="System.Messaging.MessageQueue.Create (path, transactional)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="transactional" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="path">要创建的队列的路径。</param>
        <param name="transactional">如果创建事务性队列，为 <see langword="true" />；如果创建非事务性队列，则为 <see langword="false" />。</param>
        <summary>在指定的路径中创建事务性或非事务性“消息队列”队列。</summary>
        <returns>表示新队列的 <see cref="T:System.Messaging.MessageQueue" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此重载可用于在消息队列中创建事务性队列。 可以通过设置创建非事务性队列`transactional`参数`false`或通过调用的其他重载<xref:System.Messaging.MessageQueue.Create%28System.String%29>。  
  
 若要创建的新实例<xref:System.Messaging.MessageQueue>类在应用程序中并将其绑定到现有队列，请使用<xref:System.Messaging.MessageQueue.%23ctor%2A>构造函数。 若要在消息队列中创建一个新队列，调用<xref:System.Messaging.MessageQueue.Create%28System.String%29>。  
  
 语法`path`参数取决于队列的类型它的引用下, 表中所示。  
  
|队列类型|语法|  
|----------------|------------|  
|公用队列|`MachineName`\\`QueueName`|  
|专用队列|`MachineName`\\`Private$`\\`QueueName`|  
  
 使用"。"本地计算机。 有关更多语法，请参阅<xref:System.Messaging.MessageQueue.Path%2A>属性。  
  
 下表显示了此方法是在各种工作组模式下可用。  
  
|工作组模式下|可用|  
|--------------------|---------------|  
|本地计算机|是|  
|本地计算机和直接格式名|是|  
|远程计算机|否|  
|远程计算机并直接格式名|否|  
  
   
  
## Examples  
 下面的代码示例创建公用和专用的事务性队列。 它将一条消息发送到所选队列。  
  
 [!code-cpp[MessageQueue.Create_PathTransactional#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Create_PathTransactional/CPP/mqcreate_transactional.cpp#1)]
 [!code-csharp[MessageQueue.Create_PathTransactional#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Create_PathTransactional/CS/mqcreate_transactional.cs#1)]
 [!code-vb[MessageQueue.Create_PathTransactional#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Create_PathTransactional/VB/mqcreate_transactional.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> 参数为 <see langword="null" /> 或者是空字符串 ("")。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">队列已存在于指定的路径中。  
  
或 
访问“消息队列”方法时出错。</exception>
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
        <altmember cref="M:System.Messaging.MessageQueue.#ctor" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
      </Docs>
    </Member>
    <Member MemberName="CreateCursor">
      <MemberSignature Language="C#" Value="public System.Messaging.Cursor CreateCursor ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Cursor CreateCursor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.CreateCursor" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateCursor () As Cursor" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Cursor ^ CreateCursor();" />
      <MemberSignature Language="F#" Value="member this.CreateCursor : unit -&gt; System.Messaging.Cursor" Usage="messageQueue.CreateCursor " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Cursor</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>为当前消息队列创建新的 <see cref="T:System.Messaging.Cursor" />。</summary>
        <returns>当前消息队列的新 <see cref="T:System.Messaging.Cursor" />。 此游标用于在读取队列的消息时保持队列中的特定位置。</returns>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.Messaging.Cursor" />
      </Docs>
    </Member>
    <Member MemberName="CreateTime">
      <MemberSignature Language="C#" Value="public DateTime CreateTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime CreateTime" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.CreateTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CreateTime As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property DateTime CreateTime { DateTime get(); };" />
      <MemberSignature Language="F#" Value="member this.CreateTime : DateTime" Usage="System.Messaging.MessageQueue.CreateTime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_CreateTime")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取在“消息队列”中创建队列的时间和日期。</summary>
        <value>表示队列创建日期和时间的 <see cref="T:System.DateTime" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.CreateTime%2A> 不是指在消息队列服务器上，队列<xref:System.Messaging.MessageQueue>实例。  
  
 如果该队列存在，则此属性表示创建队列，队列已存在的服务器的本地时间进行调整的时间。  
  
 下表显示了此属性是否可在各种工作组模式下。  
  
|工作组模式下|可用|  
|--------------------|---------------|  
|本地计算机|是|  
|本地计算机和直接格式名|是|  
|远程计算机|否|  
|远程计算机并直接格式名|否|  
  
   
  
## Examples  
 下面的代码示例显示一个消息队列的值<xref:System.Messaging.MessageQueue.CreateTime%2A>属性。  
  
 [!code-csharp[MessageQueue#9](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">访问“消息队列”方法时出错。</exception>
        <altmember cref="P:System.Messaging.MessageQueue.LastModifyTime" />
      </Docs>
    </Member>
    <Member MemberName="DefaultPropertiesToSend">
      <MemberSignature Language="C#" Value="public System.Messaging.DefaultPropertiesToSend DefaultPropertiesToSend { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Messaging.DefaultPropertiesToSend DefaultPropertiesToSend" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.DefaultPropertiesToSend" />
      <MemberSignature Language="VB.NET" Value="Public Property DefaultPropertiesToSend As DefaultPropertiesToSend" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::DefaultPropertiesToSend ^ DefaultPropertiesToSend { System::Messaging::DefaultPropertiesToSend ^ get(); void set(System::Messaging::DefaultPropertiesToSend ^ value); };" />
      <MemberSignature Language="F#" Value="member this.DefaultPropertiesToSend : System.Messaging.DefaultPropertiesToSend with get, set" Usage="System.Messaging.MessageQueue.DefaultPropertiesToSend" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_DefaultPropertiesToSend")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Content)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.DefaultPropertiesToSend</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置(当应用程序向队列发送消息时)默认情况下使用的消息属性值。</summary>
        <value>
          <see cref="T:System.Messaging.DefaultPropertiesToSend" />，它包含当应用程序向队列发送 <see cref="T:System.Messaging.Message" /> 实例以外的对象时使用的默认“消息队列”消息属性值。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果要将发送的类型不是任何对象<xref:System.Messaging.Message>到队列，<xref:System.Messaging.MessageQueue>将对象插入到消息队列的消息。 此时，<xref:System.Messaging.MessageQueue>适用于消息中指定的属性值<xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>属性。 相反，如果您发送<xref:System.Messaging.Message>到队列，这些属性已指定为该实例本身，因此<xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>对于忽略<xref:System.Messaging.Message>。  
  
 虽然设置属性流过<xref:System.Messaging.MessageQueue>对象，<xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>指发送到队列的队列的消息的属性。  
  
 下表中显示的属性的默认值。  
  
|Property|默认值|  
|--------------|-------------------|  
|<xref:System.Messaging.DefaultPropertiesToSend.AcknowledgeType%2A>|`AcknowledgeType.None`|  
|<xref:System.Messaging.DefaultPropertiesToSend.AdministrationQueue%2A>|`null`|  
|<xref:System.Messaging.DefaultPropertiesToSend.AppSpecific%2A>|零 (0)|  
|<xref:System.Messaging.DefaultPropertiesToSend.AttachSenderId%2A>|`true`|  
|<xref:System.Messaging.DefaultPropertiesToSend.EncryptionAlgorithm%2A>|`EncryptionAlgorithm.RC2`|  
|<xref:System.Messaging.DefaultPropertiesToSend.Extension%2A>|长度为零的字节数组|  
|<xref:System.Messaging.DefaultPropertiesToSend.HashAlgorithm%2A>|`HashAlgorithm.MD5`|  
|<xref:System.Messaging.DefaultPropertiesToSend.Label%2A>|空字符串 ("")|  
|<xref:System.Messaging.DefaultPropertiesToSend.Priority%2A>|`MessagePriority.Normal`|  
|<xref:System.Messaging.DefaultPropertiesToSend.Recoverable%2A>|`false`|  
|<xref:System.Messaging.DefaultPropertiesToSend.ResponseQueue%2A>|`null`|  
|<xref:System.Messaging.DefaultPropertiesToSend.TimeToBeReceived%2A>|`Message.InfiniteTimeout`|  
|<xref:System.Messaging.DefaultPropertiesToSend.TimeToReachQueue%2A>|`Message.InfiniteTimeout`|  
|<xref:System.Messaging.DefaultPropertiesToSend.TransactionStatusQueue%2A>|`null`|  
|<xref:System.Messaging.DefaultPropertiesToSend.UseAuthentication%2A>|`false`|  
|<xref:System.Messaging.DefaultPropertiesToSend.UseDeadLetterQueue%2A>|`false`|  
|<xref:System.Messaging.DefaultPropertiesToSend.UseEncryption%2A>|`false`|  
|<xref:System.Messaging.DefaultPropertiesToSend.UseJournalQueue%2A>|`false`|  
|<xref:System.Messaging.DefaultPropertiesToSend.UseTracing%2A>|`false`|  
  
 下表显示了此属性是否可在各种工作组模式下。  
  
|工作组模式下|可用|  
|--------------------|---------------|  
|本地计算机|是|  
|本地计算机和直接格式名|是|  
|远程计算机|是|  
|远程计算机并直接格式名|是|  
  
   
  
## Examples  
 下面的代码示例使用一条消息的优先级来确定要发送的消息的默认属性。  
  
 [!code-cpp[MessageQueue.DefaultPropertiesToSend#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.DefaultPropertiesToSend/CPP/mqdefaultpropertiestosend.cpp#1)]
 [!code-csharp[MessageQueue.DefaultPropertiesToSend#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.DefaultPropertiesToSend/CS/mqdefaultpropertiestosend.cs#1)]
 [!code-vb[MessageQueue.DefaultPropertiesToSend#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.DefaultPropertiesToSend/VB/mqdefaultpropertiestosend.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">未能设置队列的默认属性，可能因为这些属性之一无效。</exception>
        <altmember cref="T:System.Messaging.Message" />
        <altmember cref="T:System.Messaging.AcknowledgeTypes" />
        <altmember cref="T:System.Messaging.EncryptionAlgorithm" />
        <altmember cref="T:System.Messaging.HashAlgorithm" />
        <altmember cref="F:System.Messaging.Message.InfiniteTimeout" />
      </Docs>
    </Member>
    <Member MemberName="Delete">
      <MemberSignature Language="C#" Value="public static void Delete (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Delete(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Delete(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Delete (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Delete(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member Delete : string -&gt; unit" Usage="System.Messaging.MessageQueue.Delete path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">要删除的队列的位置。</param>
        <summary>删除“消息队列”服务器上的队列。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 语法`path`参数取决于队列的类型。  
  
|队列类型|语法|  
|----------------|------------|  
|公用队列|`MachineName`\\`QueueName`|  
|专用队列|`MachineName`\\`Private$`\\`QueueName`|  
  
 有关更多语法，请参阅<xref:System.Messaging.MessageQueue.Path%2A>属性。  
  
 或者，可以使用<xref:System.Messaging.MessageQueue.FormatName%2A>或<xref:System.Messaging.MessageQueue.Label%2A>来描述的队列路径。  
  
|参考|语法|  
|---------------|------------|  
|格式名称|格式名称: [*格式名称*]|  
|Label|标签: [*标签*]|  
  
 下表显示了此方法是在各种工作组模式下可用。  
  
|工作组模式下|可用|  
|--------------------|---------------|  
|本地计算机|是|  
|本地计算机和直接格式名|是|  
|远程计算机|否|  
|远程计算机并直接格式名|否|  
  
   
  
## Examples  
 它存在时，下面的代码示例将删除消息队列的队列。  
  
 [!code-cpp[MessageQueue.ExistsDelete#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.ExistsDelete/CPP/mqexistsdelete.cpp#1)]
 [!code-csharp[MessageQueue.ExistsDelete#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.ExistsDelete/CS/mqexistsdelete.cs#1)]
 [!code-vb[MessageQueue.ExistsDelete#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.ExistsDelete/VB/mqexistsdelete.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> 参数为 <see langword="null" /> 或者是空字符串 ("")。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">该 <paramref name="path" /> 参数的语法无效。  
  
或 
访问“消息队列”方法时出错。</exception>
        <altmember cref="M:System.Messaging.MessageQueue.Close" />
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
      </Docs>
    </Member>
    <Member MemberName="DenySharedReceive">
      <MemberSignature Language="C#" Value="public bool DenySharedReceive { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DenySharedReceive" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.DenySharedReceive" />
      <MemberSignature Language="VB.NET" Value="Public Property DenySharedReceive As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool DenySharedReceive { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.DenySharedReceive : bool with get, set" Usage="System.Messaging.MessageQueue.DenySharedReceive" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_DenySharedReceive")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值指示此 <see cref="T:System.Messaging.MessageQueue" /> 对来自“消息队列”队列的消息是否有独占接收访问权。</summary>
        <value>如果此 <see cref="T:System.Messaging.MessageQueue" /> 对来自队列的消息有独占接收权，则为 <see langword="true" />；否则为 <see langword="false" />。 默认值为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.DenySharedReceive%2A> 指定此引用的队列的共享的模式<xref:System.Messaging.MessageQueue>。 设置<xref:System.Messaging.MessageQueue.DenySharedReceive%2A>到`true`以指示只有这<xref:System.Messaging.MessageQueue>应具有访问权限来查看或从指定的队列接收消息<xref:System.Messaging.MessageQueue.Path%2A>。 如果另一个<xref:System.Messaging.MessageQueue>或者使用同一个队列资源，该实例关联的另一个应用程序或应用程序将不能查看或接收消息，但它仍可发送它们。  
  
 如果<xref:System.Messaging.MessageQueue.DenySharedReceive%2A>是`false`，队列可供多个应用程序发送、 扫视、 或接收消息。  
  
 下表显示了此属性是否可在各种工作组模式下。  
  
|工作组模式下|可用|  
|--------------------|---------------|  
|本地计算机|是|  
|本地计算机和直接格式名|是|  
|远程计算机|是|  
|远程计算机并直接格式名|是|  
  
   
  
## Examples  
 下面的代码示例获取和设置的值的消息队列的<xref:System.Messaging.MessageQueue.DenySharedReceive%2A>属性。  
  
 [!code-csharp[MessageQueue#10](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#10)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.#ctor" />
        <altmember cref="P:System.Messaging.MessageQueue.EnableConnectionCache" />
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="abstract member Dispose : bool -&gt; unit&#xA;override this.Dispose : bool -&gt; unit" Usage="messageQueue.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">若要释放托管资源和非托管资源，则为 <see langword="true" />；若仅释放非托管资源，则为 <see langword="false" />。</param>
        <summary>处置由 <see cref="T:System.Messaging.MessageQueue" /> 占用的资源（内存除外）。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在完成使用 <xref:System.Messaging.MessageQueue.Dispose%28System.Boolean%29> 后，应调用 <xref:System.Messaging.MessageQueue>。 <xref:System.Messaging.MessageQueue.Dispose%28System.Boolean%29> 方法使 <xref:System.Messaging.MessageQueue> 处于不可用状态。 在调用<xref:System.Messaging.MessageQueue.Dispose%28System.Boolean%29>，必须释放对所有引用<xref:System.Messaging.MessageQueue>以便可以通过垃圾回收回收其占用的内存。  
  
 应调用<xref:System.Messaging.MessageQueue.Dispose%28System.Boolean%29>发布到最后一个引用之前<xref:System.Messaging.MessageQueue>。 否则为资源<xref:System.Messaging.MessageQueue>是使用之前，不会释放垃圾回收调用<xref:System.Messaging.MessageQueue>对象的析构函数。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.Close" />
      </Docs>
    </Member>
    <Member MemberName="EnableConnectionCache">
      <MemberSignature Language="C#" Value="public static bool EnableConnectionCache { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property bool EnableConnectionCache" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.EnableConnectionCache" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property EnableConnectionCache As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool EnableConnectionCache { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.EnableConnectionCache : bool with get, set" Usage="System.Messaging.MessageQueue.EnableConnectionCache" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值指示应用程序是否维护连接缓存。</summary>
        <value>如果创建和使用连接缓存，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 连接缓存是对包含读取或写入队列句柄的结构的引用的列表。 当<xref:System.Messaging.MessageQueue.EnableConnectionCache%2A>是`true`，则<xref:System.Messaging.MessageQueue>借用每次调用的句柄从缓存<xref:System.Messaging.MessageQueue.Send%28System.Object%29>， <xref:System.Messaging.MessageQueue.Peek%2A>，或<xref:System.Messaging.MessageQueue.Receive%2A>，而不是打开新的句柄。 这可以提高性能。 使用连接缓存还可隔离<xref:System.Messaging.MessageQueue>从网络拓扑中的更改。  
  
 如果您创建与队列的新连接时连接缓存已满，<xref:System.Messaging.MessageQueue>使用新的连接将覆盖最近访问最少的结构。 您可以完全通过调用清除缓存<xref:System.Messaging.MessageQueue.ClearConnectionCache%2A>，例如，如果你正在使用的队列格式名已更改，以便以前的读取和写入句柄不再有效。  
  
 下表显示了此属性是否可在各种工作组模式下。  
  
|工作组模式下|可用|  
|--------------------|---------------|  
|本地计算机|是|  
|本地计算机和直接格式名|是|  
|远程计算机|是|  
|远程计算机并直接格式名|是|  
  
   
  
## Examples  
 下面的代码示例获取和设置的值的消息队列的<xref:System.Messaging.MessageQueue.EnableConnectionCache%2A>属性。  
  
 [!code-csharp[MessageQueue#11](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#11)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.ClearConnectionCache" />
      </Docs>
    </Member>
    <Member MemberName="EncryptionRequired">
      <MemberSignature Language="C#" Value="public System.Messaging.EncryptionRequired EncryptionRequired { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Messaging.EncryptionRequired EncryptionRequired" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.EncryptionRequired" />
      <MemberSignature Language="VB.NET" Value="Public Property EncryptionRequired As EncryptionRequired" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::EncryptionRequired EncryptionRequired { System::Messaging::EncryptionRequired get(); void set(System::Messaging::EncryptionRequired value); };" />
      <MemberSignature Language="F#" Value="member this.EncryptionRequired : System.Messaging.EncryptionRequired with get, set" Usage="System.Messaging.MessageQueue.EncryptionRequired" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_EncryptionRequired")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.EncryptionRequired</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个指示队列是否只接受非私有（非加密）消息的值。</summary>
        <value>
          <see cref="T:System.Messaging.EncryptionRequired" /> 值之一。 默认值为 <see langword="None" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当指定加密是必需的消息发送到队列时，仅消息正文进行加密。 其他成员 (例如，<xref:System.Messaging.Message.Label%2A>和<xref:System.Messaging.Message.SenderId%2A>属性) 不能被加密。  
  
 设置此属性修改消息队列队列。 因此，任何其他<xref:System.Messaging.MessageQueue>更改会影响实例。  
  
 对消息进行加密会使私有消息。 您可以指定队列的加密要求`None`， `Body`，或`Optional`通过设置<xref:System.Messaging.MessageQueue.EncryptionRequired%2A>属性正确。 <xref:System.Messaging.Message.UseEncryption%2A>消息的设置必须对应于队列的加密要求。 如果消息未加密，但队列指定`Body`，或如果对消息进行加密，但队列指定`None`，消息被拒绝的队列。 如果发送应用程序请求否定确认消息，在这种情况，消息队列指示发送应用程序的消息遭到拒绝。 如果<xref:System.Messaging.Message.UseDeadLetterQueue%2A>属性是`true`，失败加密的消息发送到死信队列。 否则，该消息将丢失。  
  
 下表显示了此属性是否可在各种工作组模式下。  
  
|工作组模式下|可用|  
|--------------------|---------------|  
|本地计算机|是|  
|本地计算机和直接格式名|是|  
|远程计算机|否|  
|远程计算机并直接格式名|否|  
  
   
  
## Examples  
 下面的代码示例获取和设置的值的消息队列的<xref:System.Messaging.MessageQueue.EncryptionRequired%2A>属性。  
  
 [!code-csharp[MessageQueue#12](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">访问“消息队列”方法时出错。</exception>
        <altmember cref="T:System.Messaging.Acknowledgment" />
        <altmember cref="P:System.Messaging.Message.UseEncryption" />
      </Docs>
    </Member>
    <Member MemberName="EndPeek">
      <MemberSignature Language="C#" Value="public System.Messaging.Message EndPeek (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message EndPeek(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.EndPeek(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndPeek (asyncResult As IAsyncResult) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ EndPeek(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="member this.EndPeek : IAsyncResult -&gt; System.Messaging.Message" Usage="messageQueue.EndPeek asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">该 <see cref="T:System.IAsyncResult" /> 标识要完成的异步查看操作，并且从它检索最终结果。</param>
        <summary>完成指定的异步查看操作。</summary>
        <returns>该 <see cref="T:System.Messaging.Message" /> 与已完成的异步操作关联。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当<xref:System.Messaging.MessageQueue.PeekCompleted>引发事件时，<xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29>完成时启动了操作<xref:System.Messaging.MessageQueue.BeginPeek%2A>调用。 为此，请<xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29>查看的消息。  
  
 <xref:System.Messaging.MessageQueue.BeginPeek%2A> 可以指定超时，这会导致<xref:System.Messaging.MessageQueue.PeekCompleted>如果队列中出现一条消息之前发生超时的时候引发的事件。 当没有消息到达队列的后续调用中发生超时<xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29>将引发异常。  
  
 <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> 用于读取消息导致<xref:System.Messaging.MessageQueue.PeekCompleted>事件被引发。  
  
 如果你想要继续以异步方式查看消息，则可以再次调用<xref:System.Messaging.MessageQueue.BeginPeek%2A>后调用<xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29>。  
  
 下表显示了此方法是在各种工作组模式下可用。  
  
|工作组模式下|可用|  
|--------------------|---------------|  
|本地计算机|是|  
|本地计算机和直接格式名|是|  
|远程计算机|否|  
|远程计算机并直接格式名|是|  
  
   
  
## Examples  
 下面的代码示例创建名为一个事件处理程序`MyPeekCompleted`，将其附加到<xref:System.Messaging.MessageQueue.PeekCompleted>事件处理程序委托，然后调用<xref:System.Messaging.MessageQueue.BeginPeek%2A>启动异步查看操作上的队列的路径处"。 \myQueue"。 当<xref:System.Messaging.MessageQueue.PeekCompleted>引发事件，该示例查看的消息并将其正文写入到屏幕。 该示例然后调用<xref:System.Messaging.MessageQueue.BeginPeek%2A>再次以启动新的异步查看操作。  
  
 [!code-cpp[MessageQueue.BeginPeek_noparms#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.BeginPeek_noparms/CPP/mqbeginpeek_noparms.cpp#1)]
 [!code-csharp[MessageQueue.BeginPeek_noparms#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.BeginPeek_noparms/CS/mqbeginpeek_noparms.cs#1)]
 [!code-vb[MessageQueue.BeginPeek_noparms#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.BeginPeek_noparms/VB/mqbeginpeek_noparms.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="asyncResult" /> 参数为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">该 <paramref name="asyncResult" /> 参数的语法无效。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">访问“消息队列”方法时出错。</exception>
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="E:System.Messaging.MessageQueue.PeekCompleted" />
      </Docs>
    </Member>
    <Member MemberName="EndReceive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message EndReceive (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message EndReceive(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.EndReceive(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndReceive (asyncResult As IAsyncResult) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ EndReceive(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="member this.EndReceive : IAsyncResult -&gt; System.Messaging.Message" Usage="messageQueue.EndReceive asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">该 <see cref="T:System.IAsyncResult" /> 标识要完成的异步接收操作，并且从它检索最终结果。</param>
        <summary>完成指定的异步接收操作。</summary>
        <returns>该 <see cref="T:System.Messaging.Message" /> 与已完成的异步操作关联。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当<xref:System.Messaging.MessageQueue.ReceiveCompleted>引发事件时，<xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29>完成时启动了操作<xref:System.Messaging.MessageQueue.BeginReceive%2A>调用。 为此，请<xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29>接收的消息。  
  
 <xref:System.Messaging.MessageQueue.BeginReceive%2A> 可以指定超时，这会导致<xref:System.Messaging.MessageQueue.ReceiveCompleted>如果队列中出现一条消息之前发生超时的时候引发的事件。 当没有消息到达队列的后续调用中发生超时<xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29>将引发异常。  
  
 <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> 用于读取 （从队列中删除） 导致的消息<xref:System.Messaging.MessageQueue.ReceiveCompleted>事件被引发。  
  
 如果你想要继续以异步方式接收消息，则可以再次调用<xref:System.Messaging.MessageQueue.BeginReceive%2A>后调用<xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29>。  
  
 下表显示了此方法是在各种工作组模式下可用。  
  
|工作组模式下|可用|  
|--------------------|---------------|  
|本地计算机|是|  
|本地计算机和直接格式名|是|  
|远程计算机|否|  
|远程计算机并直接格式名|是|  
  
   
  
## Examples  
 下面的代码示例链接异步请求。 它假定名为"myQueue"的本地计算机上没有队列。 `Main`函数启动异步操作由处理`MyReceiveCompleted`例程。 `MyReceiveCompleted` 处理当前消息并开始一个新异步接收操作。  
  
 [!code-cpp[MessageQueue.BeginReceive_noparms_combined#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.BeginReceive_noparms_combined/CPP/mqbeginreceive_noparms_mre.cpp#1)]
 [!code-csharp[MessageQueue.BeginReceive_noparms_combined#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.BeginReceive_noparms_combined/CS/mqbeginreceive_noparms_mre.cs#1)]
 [!code-vb[MessageQueue.BeginReceive_noparms_combined#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.BeginReceive_noparms_combined/VB/mqbeginreceive_noparms_mre.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="asyncResult" /> 参数为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">该 <paramref name="asyncResult" /> 参数的语法无效。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">访问“消息队列”方法时出错。</exception>
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
        <altmember cref="E:System.Messaging.MessageQueue.ReceiveCompleted" />
      </Docs>
    </Member>
    <Member MemberName="Exists">
      <MemberSignature Language="C#" Value="public static bool Exists (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Exists(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Exists(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Exists (path As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Exists(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member Exists : string -&gt; bool" Usage="System.Messaging.MessageQueue.Exists path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">要查找的队列的位置。</param>
        <summary>确定指定的路径中是否存在“消息队列”队列。</summary>
        <returns>如果指定的路径中存在队列，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.Exists%28System.String%29>方法确定消息队列的队列是否存在指定的路径。 不存在的方法来确定是否存在具有指定的格式名称的队列。 有关格式名语法和其他路径语法窗体的详细信息，请参阅<xref:System.Messaging.MessageQueue.Path%2A>属性。)  
  
 <xref:System.Messaging.MessageQueue.Exists%28System.String%29> 是代价高昂的操作。 仅在必要时在应用程序中使用它。  
  
> [!NOTE]
>  <xref:System.Messaging.MessageQueue.Exists%28System.String%29>方法不支持<xref:System.Messaging.MessageQueue.FormatName%2A>前缀。  
  
 语法`path`参数取决于队列的类型，如下表中所示。  
  
|队列类型|语法|  
|----------------|------------|  
|公用队列|`MachineName`\\`QueueName`|  
  
 <xref:System.Messaging.MessageQueue.Exists%28System.String%29> 不能调用以验证存在远程专用队列。  
  
 有关更多语法，请参阅<xref:System.Messaging.MessageQueue.Path%2A>属性。  
  
 或者，可以使用<xref:System.Messaging.MessageQueue.Label%2A>来描述的队列路径。  
  
|参考|语法|  
|---------------|------------|  
|Label|标签: [ `label` ]|  
  
 下表显示了此方法是在各种工作组模式下可用。  
  
|工作组模式下|可用|  
|--------------------|---------------|  
|本地计算机|是|  
|本地计算机和直接格式名|否|  
|远程计算机|否|  
|远程计算机并直接格式名|否|  
  
   
  
## Examples  
 下面的代码示例验证消息队列的队列是否存在，以及然后将其删除。  
  
 [!code-cpp[MessageQueue.ExistsDelete#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.ExistsDelete/CPP/mqexistsdelete.cpp#1)]
 [!code-csharp[MessageQueue.ExistsDelete#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.ExistsDelete/CS/mqexistsdelete.cs#1)]
 [!code-vb[MessageQueue.ExistsDelete#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.ExistsDelete/VB/mqexistsdelete.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">该 <paramref name="path" /> 语法无效。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">访问“消息队列”方法时出错。  
  
或 
<see cref="M:System.Messaging.MessageQueue.Exists(System.String)" /> 方法正被远程专用队列调用。</exception>
        <exception cref="T:System.InvalidOperationException">应用程序在验证队列是否存在时使用的格式名语法。</exception>
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
      </Docs>
    </Member>
    <Member MemberName="FormatName">
      <MemberSignature Language="C#" Value="public string FormatName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string FormatName" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.FormatName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property FormatName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ FormatName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.FormatName : string" Usage="System.Messaging.MessageQueue.FormatName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_FormatName")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取“消息队列”在创建队列时生成的唯一队列名。</summary>
        <value>队列的名称，该名称在网络上是唯一的。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.FormatName%2A>属性包含队列的格式名称。 消息队列使用格式名称来标识要打开的队列，以及如何对其进行访问。 与大多数不同的队列的特征，格式名称不是消息队列应用程序队列属性，因此无法访问，通过消息队列管理工具。 格式名是队列，只是唯一的名称创建队列或更高版本生成应用程序时，消息队列生成的。  
  
 如果您使用指定路径的路径名称语法 (如`myComputer\myQueue`) 而不是读取或写入队列时，请使用格式名语法，将主域控制器 （它使用 Active Directory）<xref:System.Messaging.MessageQueue.Path%2A>到关联<xref:System.Messaging.MessageQueue.FormatName%2A>之前访问该队列。 如果你的应用程序正在脱机工作，则必须使用格式名语法;否则，主域控制器将不能为执行路径转换。  
  
 下表显示了此属性是否可在各种工作组模式下。  
  
|工作组模式下|可用|  
|--------------------|---------------|  
|本地计算机|是|  
|本地计算机和直接格式名|是|  
|远程计算机|是|  
|远程计算机并直接格式名|是|  
  
   
  
## Examples  
 下面的代码示例显示一个消息队列的值<xref:System.Messaging.MessageQueue.FormatName%2A>属性。  
  
 [!code-csharp[MessageQueue#13](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">未设置 <see cref="P:System.Messaging.MessageQueue.Path" />。  
  
或 
访问“消息队列”方法时出错。</exception>
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
        <altmember cref="P:System.Messaging.MessageQueue.Label" />
        <altmember cref="T:System.Messaging.MessageQueue" />
      </Docs>
    </Member>
    <Member MemberName="Formatter">
      <MemberSignature Language="C#" Value="public System.Messaging.IMessageFormatter Formatter { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Messaging.IMessageFormatter Formatter" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.Formatter" />
      <MemberSignature Language="VB.NET" Value="Public Property Formatter As IMessageFormatter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::IMessageFormatter ^ Formatter { System::Messaging::IMessageFormatter ^ get(); void set(System::Messaging::IMessageFormatter ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Formatter : System.Messaging.IMessageFormatter with get, set" Usage="System.Messaging.MessageQueue.Formatter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Messaging.Design.MessageFormatterConverter))</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_Formatter")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.IMessageFormatter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置格式化程序，该格式化程序用于将对象序列化为从队列读取或写入队列的消息体，或者用于将从队列读取或写入队列的消息体反序列化为对象。</summary>
        <value>该 <see cref="T:System.Messaging.IMessageFormatter" /> 产生要写入消息体或要从消息体中读取的流。 默认值为 <see cref="T:System.Messaging.XmlMessageFormatter" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.Formatter%2A>属性包含格式化程序对象，该转换时你的应用程序读取或写入队列消息对象的实例。  
  
 当应用程序将消息发送到队列时，格式化程序对象序列化为流，并将其插入到消息正文。 从队列读取时，格式化程序反序列化到消息数据<xref:System.Messaging.Message.Body%2A>属性的<xref:System.Messaging.Message>。  
  
 <xref:System.Messaging.XmlMessageFormatter>松散耦合的因此不需要具有相同的对象类型上的发送方和接收方时使用此格式。 <xref:System.Messaging.ActiveXMessageFormatter>和<xref:System.Messaging.BinaryMessageFormatter>数据序列化为二进制表示形式。 <xref:System.Messaging.ActiveXMessageFormatter>发送或接收 COM 组件时使用。  
  
 <xref:System.Messaging.BinaryMessageFormatter> 并<xref:System.Messaging.ActiveXMessageFormatter>提供更快的吞吐量比<xref:System.Messaging.XmlMessageFormatter>。 <xref:System.Messaging.ActiveXMessageFormatter>允许与 Visual Basic 6.0 消息队列应用程序互操作性。  
  
 当你的应用程序将消息发送到队列中，<xref:System.Messaging.MessageQueue.Formatter%2A?displayProperty=nameWithType>仅应用于使用默认消息属性，这些消息<xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>。 如果您发送<xref:System.Messaging.Message>到队列，消息队列使用的格式化程序中定义<xref:System.Messaging.Message.Formatter%2A?displayProperty=nameWithType>属性而序列化正文。  
  
 <xref:System.Messaging.MessageQueue>类将始终使用<xref:System.Messaging.Message>接收或查看队列的消息。 该消息使用反序列化<xref:System.Messaging.MessageQueue.Formatter%2A?displayProperty=nameWithType>属性。  
  
 下表显示了此属性是否可在各种工作组模式下。  
  
|工作组模式下|可用|  
|--------------------|---------------|  
|本地计算机|是|  
|本地计算机和直接格式名|是|  
|远程计算机|否|  
|远程计算机并直接格式名|是|  
  
   
  
## Examples  
 下面的代码示例演示了格式设置消息正文使用<xref:System.Messaging.BinaryMessageFormatter>。  
  
 [!code-cpp[MessagingBinaryFormatter#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessagingBinaryFormatter/CPP/message_binaryformatter.cpp#1)]
 [!code-csharp[MessagingBinaryFormatter#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessagingBinaryFormatter/CS/message_binaryformatter.cs#1)]
 [!code-vb[MessagingBinaryFormatter#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessagingBinaryFormatter/VB/message_binaryformatter.vb#1)]  
  
 下面的代码示例演示了格式设置消息正文使用<xref:System.Messaging.XmlMessageFormatter>。  
  
 [!code-cpp[Message.Body#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.Body/CPP/message_sendreceive.cpp#1)]
 [!code-csharp[Message.Body#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.Body/CS/message_sendreceive.cs#1)]
 [!code-vb[Message.Body#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.Body/VB/message_sendreceive.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Messaging.XmlMessageFormatter" />
        <altmember cref="T:System.Messaging.ActiveXMessageFormatter" />
        <altmember cref="T:System.Messaging.BinaryMessageFormatter" />
        <altmember cref="P:System.Messaging.Message.Formatter" />
      </Docs>
    </Member>
    <Member MemberName="GetAllMessages">
      <MemberSignature Language="C#" Value="public System.Messaging.Message[] GetAllMessages ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message[] GetAllMessages() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetAllMessages" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAllMessages () As Message()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Messaging::Message ^&gt; ^ GetAllMessages();" />
      <MemberSignature Language="F#" Value="member this.GetAllMessages : unit -&gt; System.Messaging.Message[]" Usage="messageQueue.GetAllMessages " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回位于队列中的所有消息。</summary>
        <returns>类型 <see cref="T:System.Messaging.Message" /> 的数组，表示队列中所有消息，其顺序与这些消息在“消息队列”队列中的出现顺序相同。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.GetAllMessages%2A> 这些消息返回队列中的消息，不是动态链接的静态快照。 因此，数组不能用于修改在队列中的消息。 如果你想与队列 （如删除消息的功能） 的实时、 动态交互，调用<xref:System.Messaging.MessageQueue.GetMessageEnumerator2%2A>方法，它返回队列中消息的动态列表。  
  
 因为<xref:System.Messaging.MessageQueue.GetAllMessages%2A>调用该方法返回一个队列中消息的副本时，该数组不会反映新到达队列的消息或从队列中删除的消息。  
  
 <xref:System.Messaging.MessageQueue.GetAllMessages%2A> 仅检索那些未通过筛选出<xref:System.Messaging.MessageQueue.MessageReadPropertyFilter%2A>属性。  
  
 下表显示了此方法是在各种工作组模式下可用。  
  
|工作组模式下|可用|  
|--------------------|---------------|  
|本地计算机|是|  
|本地计算机和直接格式名|是|  
|远程计算机|否|  
|远程计算机并直接格式名|是|  
  
   
  
## Examples  
 以下代码示例演示了 <xref:System.Messaging.MessageQueue.GetAllMessages%2A> 的用法。  
  
 [!code-cpp[MessageQueue2#21](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#21)]
 [!code-csharp[MessageQueue2#21](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#21)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">访问“消息队列”方法时出错。</exception>
        <altmember cref="T:System.Messaging.Message" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageEnumerator2" />
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public System.Collections.IEnumerator GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.IEnumerator GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetEnumerator () As IEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::IEnumerator ^ GetEnumerator();" />
      <MemberSignature Language="F#" Value="abstract member GetEnumerator : unit -&gt; System.Collections.IEnumerator&#xA;override this.GetEnumerator : unit -&gt; System.Collections.IEnumerator" Usage="messageQueue.GetEnumerator " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("This method returns a MessageEnumerator that implements RemoveCurrent family of methods incorrectly. Please use GetMessageEnumerator2 instead.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>枚举队列中的消息。 <see cref="M:System.Messaging.MessageQueue.GetEnumerator" /> 已弃用。 应改用 <see cref="M:System.Messaging.MessageQueue.GetMessageEnumerator2" />。</summary>
        <returns>
          <see cref="T:System.Collections.IEnumerator" />，它提供与队列消息的动态连接。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表显示了此方法是在各种工作组模式下可用。  
  
|工作组模式下|可用|  
|--------------------|---------------|  
|本地计算机|是|  
|本地计算机和直接格式名|是|  
|远程计算机|否|  
|远程计算机并直接格式名|是|  
  
   
  
## Examples  
 以下代码示例演示了 <xref:System.Messaging.MessageQueue.GetEnumerator%2A> 的用法。  
  
 [!code-cpp[MessageQueue2#22](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#22)]
 [!code-csharp[MessageQueue2#22](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#22)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageEnumerator2" />
      </Docs>
    </Member>
    <Member MemberName="GetMachineId">
      <MemberSignature Language="C#" Value="public static Guid GetMachineId (string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Guid GetMachineId(string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetMachineId(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetMachineId (machineName As String) As Guid" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Guid GetMachineId(System::String ^ machineName);" />
      <MemberSignature Language="F#" Value="static member GetMachineId : string -&gt; Guid" Usage="System.Messaging.MessageQueue.GetMachineId machineName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Guid</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="machineName">包含队列的计算机的名称，名称前不含两个反斜杠 (\\\\)。</param>
        <summary>获取计算机的标识符，此 <see cref="T:System.Messaging.MessageQueue" /> 引用的队列位于该计算机上。</summary>
        <returns>
          <see cref="T:System.Guid" />，表示队列所在的计算机的唯一标识符。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 可用于两种用途，以及其他计算机的标识符： 读取计算机日志和设置的安全证书。 但是，不能调用<xref:System.Messaging.MessageQueue.GetMachineId%28System.String%29>时脱机工作因为应用程序必须有权访问目录服务域控制器上以远程计算机。  
  
 计算机标识符 （或的计算机的标识符） 是<xref:System.Guid>消息队列时，创建一台计算机添加到企业。 消息队列结合使用计算机标识符`Machine`并`Journal`关键字来创建具有语法的计算机日记格式名称`Machine=<computeridentifier>;Journal`。 计算机日记，也称为作为日记队列中，是用于存储副本的系统队列应用程序生成消息何时<xref:System.Messaging.MessageQueue.UseJournalQueue%2A>属性是`true`。  
  
 构造队列格式名时，此语法为日志才有效。 路径名称语法`MachineName` \\ `Journal$`。  
  
 下表显示了此方法是在各种工作组模式下可用。  
  
|工作组模式下|可用|  
|--------------------|---------------|  
|本地计算机|否|  
|本地计算机和直接格式名|否|  
|远程计算机|否|  
|远程计算机并直接格式名|否|  
  
   
  
## Examples  
 下面的代码示例调用 <xref:System.Messaging.MessageQueue.GetMachineId%28System.String%29>。  
  
 [!code-csharp[MessageQueue#14](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#14)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">未能检索到计算机标识符，可能是因为目录服务不可用，例如当正在脱机工作时。  
  
或 
访问“消息队列”方法时出错。</exception>
        <altmember cref="P:System.Messaging.MessageQueue.MachineName" />
        <altmember cref="P:System.Messaging.MessageQueue.UseJournalQueue" />
      </Docs>
    </Member>
    <Member MemberName="GetMessageEnumerator">
      <MemberSignature Language="C#" Value="public System.Messaging.MessageEnumerator GetMessageEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.MessageEnumerator GetMessageEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetMessageEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMessageEnumerator () As MessageEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::MessageEnumerator ^ GetMessageEnumerator();" />
      <MemberSignature Language="F#" Value="member this.GetMessageEnumerator : unit -&gt; System.Messaging.MessageEnumerator" Usage="messageQueue.GetMessageEnumerator " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("This method returns a MessageEnumerator that implements RemoveCurrent family of methods incorrectly. Please use GetMessageEnumerator2 instead.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>为队列中的所有消息创建枚举数对象。 <see cref="M:System.Messaging.MessageQueue.GetMessageEnumerator" /> 已弃用。 应改用 <see cref="M:System.Messaging.MessageQueue.GetMessageEnumerator2" />。</summary>
        <returns>该 <see cref="T:System.Messaging.MessageEnumerator" /> 包括队列中所包含的消息。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.GetMessageEnumerator%2A> 在队列中创建的所有消息的动态列表。 您可以从队列中删除的消息，以枚举器的当前位置通过调用<xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A>有关<xref:System.Messaging.MessageEnumerator>的<xref:System.Messaging.MessageQueue.GetMessageEnumerator%2A>返回。  
  
 光标位于与队列中的消息动态列表相关联，因为枚举将反映对队列中的消息进行任何修改，如果消息超出了当前光标位置。 例如，枚举器可以自动访问放置光标的当前位置之后的优先级较低的消息，而不是插入该位置之前是优先级较高的邮件。 但是，您可以重置枚举，从而通过将移动光标返回到列表的开头调用<xref:System.Messaging.MessageEnumerator.Reset%2A>为<xref:System.Messaging.MessageEnumerator>。  
  
 枚举中消息的顺序反映在队列中，其顺序，因此更高优先级的消息将出现之前优先级较低。  
  
 如果您想向其队列而不是动态的连接中消息的静态快照，则调用<xref:System.Messaging.MessageQueue.GetAllMessages%2A>。 此方法返回的数组<xref:System.Messaging.Message>对象，表示调用了该方法时的消息。  
  
 下表显示了此方法是在各种工作组模式下可用。  
  
|工作组模式下|可用|  
|--------------------|---------------|  
|本地计算机|是|  
|本地计算机和直接格式名|是|  
|远程计算机|是|  
|远程计算机并直接格式名|是|  
  
   
  
## Examples  
 下面的代码示例获取队列中消息的动态列表和使用的所有消息进行都计数<xref:System.Messaging.Message.Priority%2A>属性设置为<xref:System.Messaging.MessagePriority.Lowest?displayProperty=nameWithType>。  
  
 [!code-cpp[MessageQueue.GetMessageEnumerator#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.GetMessageEnumerator/CPP/mqgetmessageenumerator.cpp#1)]
 [!code-csharp[MessageQueue.GetMessageEnumerator#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.GetMessageEnumerator/CS/mqgetmessageenumerator.cs#1)]
 [!code-vb[MessageQueue.GetMessageEnumerator#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.GetMessageEnumerator/VB/mqgetmessageenumerator.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.GetAllMessages" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageEnumerator2" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="GetMessageEnumerator2">
      <MemberSignature Language="C#" Value="public System.Messaging.MessageEnumerator GetMessageEnumerator2 ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.MessageEnumerator GetMessageEnumerator2() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetMessageEnumerator2" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMessageEnumerator2 () As MessageEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::MessageEnumerator ^ GetMessageEnumerator2();" />
      <MemberSignature Language="F#" Value="member this.GetMessageEnumerator2 : unit -&gt; System.Messaging.MessageEnumerator" Usage="messageQueue.GetMessageEnumerator2 " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>为队列中的所有消息创建枚举数对象。</summary>
        <returns>该 <see cref="T:System.Messaging.MessageEnumerator" /> 包括队列中所包含的消息。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.GetMessageEnumerator2%2A> 在队列中创建的所有消息的动态列表。 您可以从队列中删除的消息，以枚举器的当前位置通过调用<xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A>有关<xref:System.Messaging.MessageEnumerator>的<xref:System.Messaging.MessageQueue.GetMessageEnumerator2%2A>返回。  
  
 光标位于与队列中的消息动态列表相关联，因为枚举将反映对队列中的消息进行任何修改，如果消息超出了当前光标位置。 例如，枚举器可以自动访问放置光标的当前位置之后的优先级较低的消息，而不是插入该位置之前是优先级较高的邮件。 但是，您可以重置枚举，从而通过将移动光标返回到列表的开头调用<xref:System.Messaging.MessageEnumerator.Reset%2A>为<xref:System.Messaging.MessageEnumerator>。  
  
 枚举中消息的顺序反映在队列中，其顺序，因此更高优先级的消息将出现之前优先级较低。  
  
 如果您想向其队列而不是动态的连接中消息的静态快照，则调用<xref:System.Messaging.MessageQueue.GetAllMessages%2A>。 此方法返回的数组<xref:System.Messaging.Message>对象，表示调用了该方法时的消息。  
  
 下表显示了此方法是在各种工作组模式下可用。  
  
|工作组模式下|可用|  
|--------------------|---------------|  
|本地计算机|是|  
|本地计算机和直接格式名|是|  
|远程计算机|是|  
|远程计算机并直接格式名|是|  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.GetAllMessages" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetMessageQueueEnumerator">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>为网络上公共队列的动态列表创建枚举数对象。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetMessageQueueEnumerator">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueueEnumerator GetMessageQueueEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueueEnumerator GetMessageQueueEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetMessageQueueEnumerator () As MessageQueueEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Messaging::MessageQueueEnumerator ^ GetMessageQueueEnumerator();" />
      <MemberSignature Language="F#" Value="static member GetMessageQueueEnumerator : unit -&gt; System.Messaging.MessageQueueEnumerator" Usage="System.Messaging.MessageQueue.GetMessageQueueEnumerator " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueueEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>提供只进游标语义，以枚举网络上的所有公共队列。</summary>
        <returns>
          <see cref="T:System.Messaging.MessageQueueEnumerator" />，提供网络上所有公共消息队列的动态列表。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此重载<xref:System.Messaging.MessageQueue.GetMessageQueueEnumerator%2A>返回位于网络上的所有公共队列的枚举。  
  
 由于游标与动态列表相关联，则枚举反映对删除或添加游标的当前位置之后的队列的队列列表进行任何修改。 添加或删除队列位于光标的当前位置之前不会反映。 例如，枚举器可以自动访问超出游标位置追加一个队列而不是之前该位置插入。 但是，您可以重置枚举，从而通过将移动光标返回到列表的开头调用<xref:System.Messaging.MessageQueueEnumerator.Reset%2A>为<xref:System.Messaging.MessageQueueEnumerator>。  
  
 没有任何已定义的排序的网络中的队列。 一个枚举器不会不将它们排序，例如，通过计算机、 标签、 公共或私有状态或任何其他可访问的条件。  
  
 如果你想在网络而不是它们的动态连接上的队列的静态快照，则调用<xref:System.Messaging.MessageQueue.GetPublicQueues%2A>或<xref:System.Messaging.MessageQueue.GetPrivateQueuesByMachine%28System.String%29>。 这两种方法的每个返回的数组<xref:System.Messaging.MessageQueue>对象，表示调用了该方法时的队列。  
  
 下表显示了此方法是在各种工作组模式下可用。  
  
|工作组模式下|可用|  
|--------------------|---------------|  
|本地计算机|否|  
|本地计算机和直接格式名|否|  
|远程计算机|否|  
|远程计算机并直接格式名|否|  
  
   
  
## Examples  
 下面的代码示例循环访问在网络中的所有消息队列，并检查每个队列的路径。 最后，它显示在网络上的公共队列数。  
  
 [!code-cpp[MessageQueue.GetMessageQueueEnumerator_noparms#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.GetMessageQueueEnumerator_noparms/CPP/mqgetmessagequeueenumerator.cpp#1)]
 [!code-csharp[MessageQueue.GetMessageQueueEnumerator_noparms#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.GetMessageQueueEnumerator_noparms/CS/mqgetmessagequeueenumerator.cs#1)]
 [!code-vb[MessageQueue.GetMessageQueueEnumerator_noparms#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.GetMessageQueueEnumerator_noparms/VB/mqgetmessagequeueenumerator.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.GetPublicQueues" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageEnumerator2" />
      </Docs>
    </Member>
    <Member MemberName="GetMessageQueueEnumerator">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueueEnumerator GetMessageQueueEnumerator (System.Messaging.MessageQueueCriteria criteria);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueueEnumerator GetMessageQueueEnumerator(class System.Messaging.MessageQueueCriteria criteria) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator(System.Messaging.MessageQueueCriteria)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetMessageQueueEnumerator (criteria As MessageQueueCriteria) As MessageQueueEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Messaging::MessageQueueEnumerator ^ GetMessageQueueEnumerator(System::Messaging::MessageQueueCriteria ^ criteria);" />
      <MemberSignature Language="F#" Value="static member GetMessageQueueEnumerator : System.Messaging.MessageQueueCriteria -&gt; System.Messaging.MessageQueueEnumerator" Usage="System.Messaging.MessageQueue.GetMessageQueueEnumerator criteria" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueueEnumerator</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="criteria" Type="System.Messaging.MessageQueueCriteria" />
      </Parameters>
      <Docs>
        <param name="criteria">
          <see cref="T:System.Messaging.MessageQueueCriteria" />，包含用于筛选可用消息队列的判据。</param>
        <summary>提供只进游标语义，以枚举网络上满足指定判据的所有公共队列。</summary>
        <returns>
          <see cref="T:System.Messaging.MessageQueueEnumerator" />，提供网络上公共消息队列的动态列表，这些消息队列满足 <paramref name="criteria" /> 参数指定的限制。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此重载<xref:System.Messaging.MessageQueue.GetMessageQueueEnumerator%2A>返回满足条件的应用程序条件中定义的网络上的所有公共队列的列表。 您可以指定的条件来包括，例如，队列创建或修改时间、 计算机名称、 标签、 类别或这些项的组合。  
  
 由于游标与动态列表相关联，则枚举反映对游标的当前位置之后发生的队列进行任何修改。 不会反映对队列位于光标的当前位置之前的更改。 例如，枚举器可以自动访问超出游标位置追加一个队列而不是之前该位置插入。 但是，您可以重置枚举，从而通过将移动光标返回到列表的开头调用<xref:System.Messaging.MessageQueueEnumerator.Reset%2A>为<xref:System.Messaging.MessageQueueEnumerator>。  
  
 没有任何已定义的排序的网络中的队列。 一个枚举器不会不将它们排序，例如，通过计算机、 标签、 公共或私有状态或任何其他可访问的条件。  
  
 如果你希望网络而不是它们的动态连接上的队列的静态快照，指定的条件<xref:System.Messaging.MessageQueue.GetPublicQueues%2A>或致电<xref:System.Messaging.MessageQueue.GetPrivateQueuesByMachine%28System.String%29>。 这两种方法的每个返回的数组<xref:System.Messaging.MessageQueue>对象，表示调用了该方法时的队列。 调用<xref:System.Messaging.MessageQueue.GetPublicQueuesByCategory%28System.Guid%29>， <xref:System.Messaging.MessageQueue.GetPublicQueuesByLabel%28System.String%29>，或<xref:System.Messaging.MessageQueue.GetPublicQueuesByMachine%28System.String%29>提供了相同的结果与调用<xref:System.Messaging.MessageQueue.GetPublicQueues%2A>使用的筛选条件<xref:System.Messaging.MessageQueue.Category%2A>， <xref:System.Messaging.MessageQueue.Label%2A>，和<xref:System.Messaging.MessageQueue.MachineName%2A>分别。  
  
 下表显示了此方法是在各种工作组模式下可用。  
  
|工作组模式下|可用|  
|--------------------|---------------|  
|本地计算机|否|  
|本地计算机和直接格式名|否|  
|远程计算机|否|  
|远程计算机并直接格式名|否|  
  
   
  
## Examples  
 下面的代码示例循环访问消息队列，并显示计算机"MyComputer"上的每个队列中的最后一天的已创建和存在的路径。  
  
 [!code-cpp[MessageQueue.GetMessageQueueEnumerator_criteria#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.GetMessageQueueEnumerator_criteria/CPP/mqgetmessagequeueenumerator_criteria.cpp#1)]
 [!code-csharp[MessageQueue.GetMessageQueueEnumerator_criteria#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.GetMessageQueueEnumerator_criteria/CS/mqgetmessagequeueenumerator_criteria.cs#1)]
 [!code-vb[MessageQueue.GetMessageQueueEnumerator_criteria#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.GetMessageQueueEnumerator_criteria/VB/mqgetmessagequeueenumerator_criteria.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.GetPublicQueues" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageEnumerator2" />
      </Docs>
    </Member>
    <Member MemberName="GetPrivateQueuesByMachine">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueue[] GetPrivateQueuesByMachine (string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueue[] GetPrivateQueuesByMachine(string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetPrivateQueuesByMachine(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetPrivateQueuesByMachine (machineName As String) As MessageQueue()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Messaging::MessageQueue ^&gt; ^ GetPrivateQueuesByMachine(System::String ^ machineName);" />
      <MemberSignature Language="F#" Value="static member GetPrivateQueuesByMachine : string -&gt; System.Messaging.MessageQueue[]" Usage="System.Messaging.MessageQueue.GetPrivateQueuesByMachine machineName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="machineName">计算机，从其中检索专用队列。</param>
        <summary>检索指定计算机上的所有专用队列。</summary>
        <returns>引用检索的专用队列的 <see cref="T:System.Messaging.MessageQueue" /> 对象数组。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.GetPrivateQueuesByMachine%28System.String%29> 检索指定计算机上的队列的静态快照。  
  
 下表显示了此方法是在各种工作组模式下可用。  
  
|工作组模式下|可用|  
|--------------------|---------------|  
|本地计算机|是|  
|本地计算机和直接格式名|是|  
|远程计算机|是|  
|远程计算机并直接格式名|是|  
  
   
  
## Examples  
 下面的代码示例检索队列的列表。  
  
 [!code-cpp[MessageQueue.GetQueueLists#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CPP/mqgetqueuelists.cpp#1)]
 [!code-csharp[MessageQueue.GetQueueLists#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CS/mqgetqueuelists.cs#1)]
 [!code-vb[MessageQueue.GetQueueLists#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.GetQueueLists/VB/mqgetqueuelists.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="machineName" /> 参数为 <see langword="null" /> 或是空字符串（“”）。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">访问“消息队列”方法时出错。</exception>
        <altmember cref="P:System.Messaging.MessageQueue.MachineName" />
        <altmember cref="M:System.Messaging.MessageQueue.GetPublicQueues" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetPublicQueues">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>检索网络上的所有公共队列。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetPublicQueues">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueue[] GetPublicQueues ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueue[] GetPublicQueues() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetPublicQueues" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetPublicQueues () As MessageQueue()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Messaging::MessageQueue ^&gt; ^ GetPublicQueues();" />
      <MemberSignature Language="F#" Value="static member GetPublicQueues : unit -&gt; System.Messaging.MessageQueue[]" Usage="System.Messaging.MessageQueue.GetPublicQueues " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>检索网络上的所有公共队列。</summary>
        <returns>引用检索的公共队列的 <see cref="T:System.Messaging.MessageQueue" /> 对象数组。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果你想要在网络上的所有公共队列的完整列表，请使用此重载。 如果你想要按特定条件，如限制列表<xref:System.Messaging.MessageQueue.MachineName%2A>， <xref:System.Messaging.MessageQueue.Category%2A>，或上次修改的时间，请使用此方法的另一个重载。 (或者，可以使用<xref:System.Messaging.MessageQueue.GetPublicQueuesByMachine%28System.String%29>， <xref:System.Messaging.MessageQueue.GetPublicQueuesByCategory%28System.Guid%29>，或<xref:System.Messaging.MessageQueue.GetPublicQueuesByLabel%28System.String%29>。)  
  
 <xref:System.Messaging.MessageQueue.GetPublicQueues%2A> 检索队列的静态快照。 若要与队列的动态列表进行交互，请使用<xref:System.Messaging.MessageQueue.GetMessageQueueEnumerator%2A>。  
  
 下表显示了此方法是在各种工作组模式下可用。  
  
|工作组模式下|可用|  
|--------------------|---------------|  
|本地计算机|否|  
|本地计算机和直接格式名|否|  
|远程计算机|否|  
|远程计算机并直接格式名|否|  
  
   
  
## Examples  
 下面的代码示例检索队列的列表。  
  
 [!code-cpp[MessageQueue.GetQueueLists#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CPP/mqgetqueuelists.cpp#1)]
 [!code-csharp[MessageQueue.GetQueueLists#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CS/mqgetqueuelists.cs#1)]
 [!code-vb[MessageQueue.GetQueueLists#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.GetQueueLists/VB/mqgetqueuelists.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">访问“消息队列”方法时出错。</exception>
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="GetPublicQueues">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueue[] GetPublicQueues (System.Messaging.MessageQueueCriteria criteria);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueue[] GetPublicQueues(class System.Messaging.MessageQueueCriteria criteria) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetPublicQueues(System.Messaging.MessageQueueCriteria)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetPublicQueues (criteria As MessageQueueCriteria) As MessageQueue()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Messaging::MessageQueue ^&gt; ^ GetPublicQueues(System::Messaging::MessageQueueCriteria ^ criteria);" />
      <MemberSignature Language="F#" Value="static member GetPublicQueues : System.Messaging.MessageQueueCriteria -&gt; System.Messaging.MessageQueue[]" Usage="System.Messaging.MessageQueue.GetPublicQueues criteria" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="criteria" Type="System.Messaging.MessageQueueCriteria" />
      </Parameters>
      <Docs>
        <param name="criteria">
          <see cref="T:System.Messaging.MessageQueueCriteria" />，包含用于筛选队列的判据。</param>
        <summary>检索网络上满足指定判据的所有公共队列。</summary>
        <returns>引用检索的公共队列的 <see cref="T:System.Messaging.MessageQueue" /> 对象数组。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果你想要按标签、 类别或计算机名称筛选网络上的所有公共队列<xref:System.Messaging.MessageQueue>类包含提供该功能的特定方法 (<xref:System.Messaging.MessageQueue.GetPublicQueuesByLabel%28System.String%29>， <xref:System.Messaging.MessageQueue.GetPublicQueuesByCategory%28System.Guid%29>，和<xref:System.Messaging.MessageQueue.GetPublicQueuesByMachine%28System.String%29>分别)。 使用此重载来获取网络上满足多个这些条件之一 （例如，如果您想要指定标签和类别） 的所有公共队列的列表。 你还可以筛选按消息条件以外<xref:System.Messaging.MessageQueue.Label%2A>， <xref:System.Messaging.MessageQueue.Category%2A>，和<xref:System.Messaging.MessageQueue.MachineName%2A>。 例如，使用此重载按队列的上次修改时间进行筛选。 只需创建的新实例<xref:System.Messaging.MessageQueueCriteria>类，在实例中，设置适当的属性并传递作为实例`criteria`参数。  
  
 <xref:System.Messaging.MessageQueue.GetPublicQueues%2A> 检索队列的静态快照。 若要与队列的动态列表进行交互，请使用<xref:System.Messaging.MessageQueue.GetMessageQueueEnumerator%2A>。  
  
 下表显示了此方法是在各种工作组模式下可用。  
  
|工作组模式下|可用|  
|--------------------|---------------|  
|本地计算机|否|  
|本地计算机和直接格式名|否|  
|远程计算机|否|  
|远程计算机并直接格式名|否|  
  
   
  
## Examples  
 下面的代码示例检索队列的列表。  
  
 [!code-cpp[MessageQueue.GetQueueLists#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CPP/mqgetqueuelists.cpp#1)]
 [!code-csharp[MessageQueue.GetQueueLists#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CS/mqgetqueuelists.cs#1)]
 [!code-vb[MessageQueue.GetQueueLists#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.GetQueueLists/VB/mqgetqueuelists.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">访问“消息队列”方法时出错。</exception>
        <altmember cref="T:System.Messaging.MessageQueueCriteria" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="GetPublicQueuesByCategory">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueue[] GetPublicQueuesByCategory (Guid category);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueue[] GetPublicQueuesByCategory(valuetype System.Guid category) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetPublicQueuesByCategory(System.Guid)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetPublicQueuesByCategory (category As Guid) As MessageQueue()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Messaging::MessageQueue ^&gt; ^ GetPublicQueuesByCategory(Guid category);" />
      <MemberSignature Language="F#" Value="static member GetPublicQueuesByCategory : Guid -&gt; System.Messaging.MessageQueue[]" Usage="System.Messaging.MessageQueue.GetPublicQueuesByCategory category" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="category" Type="System.Guid" />
      </Parameters>
      <Docs>
        <param name="category">一个 <see cref="T:System.Guid" />，它将要检索的队列集分组。</param>
        <summary>检索网络上所有属于指定类别的公共队列。</summary>
        <returns>引用检索的公共队列的 <see cref="T:System.Messaging.MessageQueue" /> 对象数组。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用此方法来按类别筛选公用队列。 <xref:System.Messaging.MessageQueue.Category%2A>属性提供访问权限的消息队列类型 ID 属性 （这是读/写） 的特定队列。 尽管可以使用<xref:System.Guid.NewGuid%2A>若要创建跨所有都是唯一的类别值<xref:System.Guid>值，不需要。 类别值必须是只能从其他类别，不能从其他所有非重复<xref:System.Guid>值。 例如，您可以将分配{00000000-0000-0000-0000-000000000001}作为<xref:System.Messaging.MessageQueue.Category%2A>获取队列的一套并{00000000-0000-0000-0000-000000000002}作为<xref:System.Messaging.MessageQueue.Category%2A>为另一组。  
  
 <xref:System.Messaging.MessageQueue.GetPublicQueuesByCategory%28System.Guid%29> 检索队列的静态快照。 若要与队列的动态列表进行交互，请使用<xref:System.Messaging.MessageQueue.GetMessageQueueEnumerator%2A>。 可将类别指定作为的一部分<xref:System.Messaging.MessageQueueCriteria>传入该方法。  
  
 下表显示了此方法是在各种工作组模式下可用。  
  
|工作组模式下|可用|  
|--------------------|---------------|  
|本地计算机|否|  
|本地计算机和直接格式名|否|  
|远程计算机|否|  
|远程计算机并直接格式名|否|  
  
   
  
## Examples  
 下面的代码示例检索队列的列表。  
  
 [!code-cpp[MessageQueue.GetQueueLists#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CPP/mqgetqueuelists.cpp#1)]
 [!code-csharp[MessageQueue.GetQueueLists#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CS/mqgetqueuelists.cs#1)]
 [!code-vb[MessageQueue.GetQueueLists#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.GetQueueLists/VB/mqgetqueuelists.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">访问“消息队列”方法时出错。</exception>
        <altmember cref="P:System.Messaging.MessageQueue.Category" />
        <altmember cref="M:System.Messaging.MessageQueue.GetPublicQueues" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="GetPublicQueuesByLabel">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueue[] GetPublicQueuesByLabel (string label);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueue[] GetPublicQueuesByLabel(string label) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetPublicQueuesByLabel(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetPublicQueuesByLabel (label As String) As MessageQueue()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Messaging::MessageQueue ^&gt; ^ GetPublicQueuesByLabel(System::String ^ label);" />
      <MemberSignature Language="F#" Value="static member GetPublicQueuesByLabel : string -&gt; System.Messaging.MessageQueue[]" Usage="System.Messaging.MessageQueue.GetPublicQueuesByLabel label" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="label" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="label">一个标签，它将要检索的队列集分组。</param>
        <summary>检索网络上带有指定标签的所有公共队列。</summary>
        <returns>引用检索的公共队列的 <see cref="T:System.Messaging.MessageQueue" /> 对象数组。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用此方法以按标签进行筛选的公共队列。  
  
 <xref:System.Messaging.MessageQueue.GetPublicQueuesByLabel%28System.String%29> 检索队列的静态快照。 若要与队列的动态列表进行交互，请使用<xref:System.Messaging.MessageQueue.GetMessageQueueEnumerator%2A>。 可以作为的一部分指定的标签<xref:System.Messaging.MessageQueueCriteria>传入该方法。  
  
 下表显示了此方法是在各种工作组模式下可用。  
  
|工作组模式下|可用|  
|--------------------|---------------|  
|本地计算机|否|  
|本地计算机和直接格式名|否|  
|远程计算机|否|  
|远程计算机并直接格式名|否|  
  
   
  
## Examples  
 下面的代码示例检索队列的列表。  
  
 [!code-cpp[MessageQueue.GetQueueLists#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CPP/mqgetqueuelists.cpp#1)]
 [!code-csharp[MessageQueue.GetQueueLists#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CS/mqgetqueuelists.cs#1)]
 [!code-vb[MessageQueue.GetQueueLists#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.GetQueueLists/VB/mqgetqueuelists.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">访问“消息队列”方法时出错。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="label" /> 参数为 <see langword="null" />。</exception>
        <altmember cref="P:System.Messaging.MessageQueue.Label" />
        <altmember cref="M:System.Messaging.MessageQueue.GetPublicQueues" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="GetPublicQueuesByMachine">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueue[] GetPublicQueuesByMachine (string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueue[] GetPublicQueuesByMachine(string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetPublicQueuesByMachine(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetPublicQueuesByMachine (machineName As String) As MessageQueue()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Messaging::MessageQueue ^&gt; ^ GetPublicQueuesByMachine(System::String ^ machineName);" />
      <MemberSignature Language="F#" Value="static member GetPublicQueuesByMachine : string -&gt; System.Messaging.MessageQueue[]" Usage="System.Messaging.MessageQueue.GetPublicQueuesByMachine machineName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="machineName">计算机的名称，该计算机包含要检索的公共队列集。</param>
        <summary>检索驻留在指定计算机上的所有公共队列。</summary>
        <returns>
          <see cref="T:System.Messaging.MessageQueue" /> 对象数组，这些对象引用该计算机上的公共队列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用此方法以按计算机筛选公用队列。  
  
 <xref:System.Messaging.MessageQueue.GetPublicQueuesByMachine%28System.String%29> 检索队列的静态快照。 若要与队列的动态列表进行交互，请使用<xref:System.Messaging.MessageQueue.GetMessageQueueEnumerator%2A>。 您可以指定计算机名称作为的一部分<xref:System.Messaging.MessageQueueCriteria>传入该方法。  
  
 下表显示了此方法是在各种工作组模式下可用。  
  
|工作组模式下|可用|  
|--------------------|---------------|  
|本地计算机|否|  
|本地计算机和直接格式名|否|  
|远程计算机|否|  
|远程计算机并直接格式名|否|  
  
   
  
## Examples  
 下面的代码示例检索队列的列表。  
  
 [!code-cpp[MessageQueue.GetQueueLists#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CPP/mqgetqueuelists.cpp#1)]
 [!code-csharp[MessageQueue.GetQueueLists#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CS/mqgetqueuelists.cs#1)]
 [!code-vb[MessageQueue.GetQueueLists#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.GetQueueLists/VB/mqgetqueuelists.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="machineName" /> 参数的语法不正确。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">访问“消息队列”方法时出错。</exception>
        <altmember cref="P:System.Messaging.MessageQueue.MachineName" />
        <altmember cref="M:System.Messaging.MessageQueue.GetPublicQueues" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="GetSecurityContext">
      <MemberSignature Language="C#" Value="public static System.Messaging.SecurityContext GetSecurityContext ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.SecurityContext GetSecurityContext() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetSecurityContext" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetSecurityContext () As SecurityContext" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Messaging::SecurityContext ^ GetSecurityContext();" />
      <MemberSignature Language="F#" Value="static member GetSecurityContext : unit -&gt; System.Messaging.SecurityContext" Usage="System.Messaging.MessageQueue.GetSecurityContext " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.SecurityContext</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>检索进行此调用时 MSMQ 将当前用户（线程标识）关联到的安全上下文。</summary>
        <returns>包含安全上下文的 <see cref="T:System.Messaging.SecurityContext" /> 对象。</returns>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Messaging.Message.SecurityContext" />
      </Docs>
    </Member>
    <Member MemberName="Id">
      <MemberSignature Language="C#" Value="public Guid Id { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Guid Id" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.Id" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Id As Guid" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Guid Id { Guid get(); };" />
      <MemberSignature Language="F#" Value="member this.Id : Guid" Usage="System.Messaging.MessageQueue.Id" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_GuidId")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Guid</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取队列的唯一“消息队列”标识符。</summary>
        <value>
          <see cref="P:System.Messaging.MessageQueue.Id" />，表示由“消息队列”应用程序生成的消息标识符。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 消息队列集<xref:System.Messaging.MessageQueue.Id%2A>属性时它将创建队列。 此属性才可供公用队列。  
  
 下表显示了此属性是否可在各种工作组模式下。  
  
|工作组模式下|可用|  
|--------------------|---------------|  
|本地计算机|是|  
|本地计算机和直接格式名|是|  
|远程计算机|否|  
|远程计算机并直接格式名|否|  
  
   
  
## Examples  
 下面的代码示例显示一个消息队列的值<xref:System.Messaging.MessageQueue.Id%2A>属性。  
  
 [!code-csharp[MessageQueue#15](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#15)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">访问“消息队列”方法时出错。</exception>
        <altmember cref="P:System.Messaging.MessageQueue.Category" />
      </Docs>
    </Member>
    <Member MemberName="InfiniteQueueSize">
      <MemberSignature Language="C#" Value="public static readonly long InfiniteQueueSize;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly int64 InfiniteQueueSize" />
      <MemberSignature Language="DocId" Value="F:System.Messaging.MessageQueue.InfiniteQueueSize" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly InfiniteQueueSize As Long " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly long InfiniteQueueSize;" />
      <MemberSignature Language="F#" Value=" staticval mutable InfiniteQueueSize : int64" Usage="System.Messaging.MessageQueue.InfiniteQueueSize" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>指定对某队列不存在大小限制。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 设置时，经常使用此成员<xref:System.Messaging.MessageQueue.MaximumJournalSize%2A>或<xref:System.Messaging.MessageQueue.MaximumQueueSize%2A>。  
  
   
  
## Examples  
 下面的代码示例演示如何将<xref:System.Messaging.MessageQueue.InfiniteQueueSize>成员。  
  
 [!code-csharp[MessageQueue#16](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#16)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Messaging.MessageQueue.MaximumJournalSize" />
        <altmember cref="P:System.Messaging.MessageQueue.MaximumQueueSize" />
      </Docs>
    </Member>
    <Member MemberName="InfiniteTimeout">
      <MemberSignature Language="C#" Value="public static readonly TimeSpan InfiniteTimeout;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.TimeSpan InfiniteTimeout" />
      <MemberSignature Language="DocId" Value="F:System.Messaging.MessageQueue.InfiniteTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly InfiniteTimeout As TimeSpan " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly TimeSpan InfiniteTimeout;" />
      <MemberSignature Language="F#" Value=" staticval mutable InfiniteTimeout : TimeSpan" Usage="System.Messaging.MessageQueue.InfiniteTimeout" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>指定对查看或接收消息的方法不存在超时设定。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue> 支持两种类型的消息检索： 同步和异步。 同步方法<xref:System.Messaging.MessageQueue.Peek%2A>和<xref:System.Messaging.MessageQueue.Receive%2A>，会导致进程线程等待新消息到达队列中指定的时间间隔。 如果指定的时间间隔是<xref:System.Messaging.MessageQueue.InfiniteTimeout>，直到有可用的新消息将一直被阻止的进程线程。 但是，<xref:System.Messaging.MessageQueue.BeginPeek%2A>和<xref:System.Messaging.MessageQueue.BeginReceive%2A>（异步方法），允许以继续在另一个线程，直到有消息到达队列中的主应用程序任务。  
  
   
  
## Examples  
 下面的代码示例演示如何将<xref:System.Messaging.MessageQueue.InfiniteTimeout>成员。  
  
 [!code-csharp[MessageQueue#17](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#17)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Label">
      <MemberSignature Language="C#" Value="public string Label { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Label" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.Label" />
      <MemberSignature Language="VB.NET" Value="Public Property Label As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Label { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Label : string with get, set" Usage="System.Messaging.MessageQueue.Label" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_Label")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置队列说明。</summary>
        <value>消息队列的标签。 默认值为空字符串("")。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 消息队列标签的最大长度为 124 个字符。  
  
 <xref:System.Messaging.MessageQueue.Label%2A>不需要在所有队列是唯一的属性。 但是，如果多个队列共用同一个<xref:System.Messaging.MessageQueue.Label%2A>，不能使用<xref:System.Messaging.MessageQueue.Send%28System.Object%29>广播到所有这些消息的方法。 如果使用的标签语法<xref:System.Messaging.MessageQueue.Path%2A>属性发送消息时，将引发异常，如果<xref:System.Messaging.MessageQueue.Label%2A>不是唯一的。  
  
 下表显示了此属性是否可在各种工作组模式下。  
  
|工作组模式下|可用|  
|--------------------|---------------|  
|本地计算机|是|  
|本地计算机和直接格式名|是|  
|远程计算机|否|  
|远程计算机并直接格式名|否|  
  
   
  
## Examples  
 下面的代码示例获取和设置的值的消息队列的<xref:System.Messaging.MessageQueue.Label%2A>属性。  
  
 [!code-csharp[MessageQueue#18](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#18)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">标签被设置为无效值。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">访问“消息队列”方法时出错。</exception>
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
        <altmember cref="P:System.Messaging.MessageQueue.FormatName" />
        <altmember cref="M:System.Messaging.MessageQueue.GetPublicQueues" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="LastModifyTime">
      <MemberSignature Language="C#" Value="public DateTime LastModifyTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime LastModifyTime" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.LastModifyTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LastModifyTime As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property DateTime LastModifyTime { DateTime get(); };" />
      <MemberSignature Language="F#" Value="member this.LastModifyTime : DateTime" Usage="System.Messaging.MessageQueue.LastModifyTime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_LastModifyTime")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取队列属性的最近修改时间。</summary>
        <value>指示队列属性最近修改时间的 <see cref="T:System.DateTime" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 上次修改时间包括创建队列时和任何<xref:System.Messaging.MessageQueue>属性，可修改的消息队列队列中，如<xref:System.Messaging.MessageQueue.BasePriority%2A>。 值<xref:System.Messaging.MessageQueue.LastModifyTime%2A>属性表示本地计算机的系统时间。  
  
 必须调用<xref:System.Messaging.MessageQueue.Refresh%2A>之前<xref:System.Messaging.MessageQueue.LastModifyTime%2A>属性; 否则，修改时间与此相关联<xref:System.Messaging.MessageQueue>可能不是最新。  
  
 下表显示了此属性是否可在各种工作组模式下。  
  
|工作组模式下|可用|  
|--------------------|---------------|  
|本地计算机|是|  
|本地计算机和直接格式名|是|  
|远程计算机|否|  
|远程计算机并直接格式名|否|  
  
   
  
## Examples  
 下面的代码示例显示一个消息队列的值<xref:System.Messaging.MessageQueue.LastModifyTime%2A>属性。  
  
 [!code-csharp[MessageQueue#19](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#19)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">访问“消息队列”方法时出错。</exception>
        <altmember cref="P:System.Messaging.MessageQueue.CreateTime" />
        <altmember cref="P:System.Messaging.MessageQueue.DenySharedReceive" />
      </Docs>
    </Member>
    <Member MemberName="MachineName">
      <MemberSignature Language="C#" Value="public string MachineName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string MachineName" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.MachineName" />
      <MemberSignature Language="VB.NET" Value="Public Property MachineName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ MachineName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.MachineName : string with get, set" Usage="System.Messaging.MessageQueue.MachineName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_MachineName")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置“消息队列”队列所在的计算机的名称。</summary>
        <value>队列所在的计算机的名称。 “消息队列”默认值为“.”，即本地计算机。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.MachineName%2A>是必不可少的组成部分的队列的友好名称语法<xref:System.Messaging.MessageQueue.Path%2A>。 下表显示了当你想要确定使用友好名称的队列路径时应使用指定类型的队列的语法。  
  
|队列类型|语法|  
|----------------|------------|  
|公用队列|`MachineName`\\`QueueName`|  
|专用队列|`MachineName`\\`Private$`\\`QueueName`|  
|日记队列|`MachineName`\\`QueueName`\\`Journal$`|  
|计算机日志队列|`MachineName`\\`Journal$`|  
|计算机死信队列|`MachineName`\\`Deadletter$`|  
|计算机事务性死信队列|`MachineName`\\`XactDeadletter$`|  
  
 使用"。"本地计算机时指定<xref:System.Messaging.MessageQueue.MachineName%2A>。 例如，对于此属性，识别仅计算机名称`Server0`。 <xref:System.Messaging.MessageQueue.MachineName%2A>属性不支持 IP 地址格式。  
  
 如果定义了<xref:System.Messaging.MessageQueue.Path%2A>的<xref:System.Messaging.MessageQueue.MachineName%2A>，应用程序将引发异常，因为域控制器是路径翻译需要脱机工作时。 因此，必须使用<xref:System.Messaging.MessageQueue.FormatName%2A>为<xref:System.Messaging.MessageQueue.Path%2A>脱机工作时的语法。  
  
 <xref:System.Messaging.MessageQueue.MachineName%2A>， <xref:System.Messaging.MessageQueue.Path%2A>，和<xref:System.Messaging.MessageQueue.QueueName%2A>相关的属性。 更改<xref:System.Messaging.MessageQueue.MachineName%2A>属性会导致<xref:System.Messaging.MessageQueue.Path%2A>要更改属性。 从新构建<xref:System.Messaging.MessageQueue.MachineName%2A>和<xref:System.Messaging.MessageQueue.QueueName%2A>。 更改<xref:System.Messaging.MessageQueue.Path%2A>（例如，若要使用的格式名称语法） 将重置<xref:System.Messaging.MessageQueue.MachineName%2A>和<xref:System.Messaging.MessageQueue.QueueName%2A>属性来引用新队列。 如果<xref:System.Messaging.MessageQueue.QueueName%2A>属性为空，<xref:System.Messaging.MessageQueue.Path%2A>设置为指定的计算机的日志队列。  
  
 下表显示了此属性是否可在各种工作组模式下。  
  
|工作组模式下|可用|  
|--------------------|---------------|  
|本地计算机|是|  
|本地计算机和直接格式名|是|  
|远程计算机|是|  
|远程计算机并直接格式名|否|  
  
   
  
## Examples  
 下面的代码示例获取和设置的值的消息队列的<xref:System.Messaging.MessageQueue.MachineName%2A>属性。  
  
 [!code-csharp[MessageQueue#20](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#20)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">计算机名称无效，可能是因为语法不正确。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">访问“消息队列”方法时出错。</exception>
        <altmember cref="P:System.Messaging.MessageQueue.QueueName" />
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
        <altmember cref="P:System.Messaging.MessageQueue.FormatName" />
        <altmember cref="M:System.Messaging.MessageQueue.GetPublicQueues" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="MaximumJournalSize">
      <MemberSignature Language="C#" Value="public long MaximumJournalSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 MaximumJournalSize" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.MaximumJournalSize" />
      <MemberSignature Language="VB.NET" Value="Public Property MaximumJournalSize As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long MaximumJournalSize { long get(); void set(long value); };" />
      <MemberSignature Language="F#" Value="member this.MaximumJournalSize : int64 with get, set" Usage="System.Messaging.MessageQueue.MaximumJournalSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_MaximumJournalSize")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Messaging.Design.SizeConverter))</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置日记队列的最大大小。</summary>
        <value>日记队列的最大大小，以千字节为单位。 “消息队列”默认设置指定：不存在任何限制。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.MaximumJournalSize%2A> 提供对消息队列的日志存储限制访问。 它是唯一时才可用<xref:System.Messaging.MessageQueue.UseJournalQueue%2A>是`true`。 设置此属性修改消息队列队列。 因此，任何其他<xref:System.Messaging.MessageQueue>更改会影响实例  
  
 如果在日志或死信队列存储消息，则应定期清除要删除不再需要的消息的队列。 此类队列中的消息都计入队列所驻留的计算机的消息配额。 （管理员设置的计算机配额。）  
  
 下表显示了此属性是否可在各种工作组模式下。  
  
|工作组模式下|可用|  
|--------------------|---------------|  
|本地计算机|是|  
|本地计算机和直接格式名|是|  
|远程计算机|否|  
|远程计算机并直接格式名|否|  
  
   
  
## Examples  
 下面的代码示例获取和设置的值的消息队列的<xref:System.Messaging.MessageQueue.MaximumJournalSize%2A>属性。  
  
 [!code-csharp[MessageQueue#21](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#21)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">日记队列的最大大小被设置为无效值。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">访问“消息队列”方法时出错。</exception>
        <altmember cref="P:System.Messaging.MessageQueue.UseJournalQueue" />
        <altmember cref="P:System.Messaging.MessageQueue.MaximumQueueSize" />
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteQueueSize" />
      </Docs>
    </Member>
    <Member MemberName="MaximumQueueSize">
      <MemberSignature Language="C#" Value="public long MaximumQueueSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 MaximumQueueSize" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.MaximumQueueSize" />
      <MemberSignature Language="VB.NET" Value="Public Property MaximumQueueSize As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long MaximumQueueSize { long get(); void set(long value); };" />
      <MemberSignature Language="F#" Value="member this.MaximumQueueSize : int64 with get, set" Usage="System.Messaging.MessageQueue.MaximumQueueSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_MaximumQueueSize")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Messaging.Design.SizeConverter))</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置队列的最大大小。</summary>
        <value>队列的最大大小，以千字节为单位。 “消息队列”默认设置指定：不存在任何限制。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.MaximumQueueSize%2A>连接可以访问消息队列消息存储限额，这不同于计算机的管理员定义的消息配额。 有关消息配额的详细信息，请参阅<xref:System.Messaging.MessageQueue.MaximumJournalSize%2A>。  
  
 设置此属性修改消息队列队列。 因此，任何其他<xref:System.Messaging.MessageQueue>更改会影响实例  
  
 如果试图超过最大队列大小或的计算机的消息配额，则消息可能会丢失。 当达到队列配额时，消息队列通知发送的应用程序，以指示该队列已满，通过返回一个否定确认消息的管理队列。 消息队列仍会继续发送否定确认，直到队列中消息的总大小降低到限制。  
  
 下表显示了此属性是否可在各种工作组模式下。  
  
|工作组模式下|可用|  
|--------------------|---------------|  
|本地计算机|是|  
|本地计算机和直接格式名|是|  
|远程计算机|否|  
|远程计算机并直接格式名|否|  
  
   
  
## Examples  
 下面的代码示例获取和设置的值的消息队列的<xref:System.Messaging.MessageQueue.MaximumQueueSize%2A>属性。  
  
 [!code-csharp[MessageQueue#22](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#22)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">队列最大大小包含负值。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">访问“消息队列”方法时出错。</exception>
        <altmember cref="P:System.Messaging.MessageQueue.MaximumJournalSize" />
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteQueueSize" />
      </Docs>
    </Member>
    <Member MemberName="MessageReadPropertyFilter">
      <MemberSignature Language="C#" Value="public System.Messaging.MessagePropertyFilter MessageReadPropertyFilter { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Messaging.MessagePropertyFilter MessageReadPropertyFilter" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.MessageReadPropertyFilter" />
      <MemberSignature Language="VB.NET" Value="Public Property MessageReadPropertyFilter As MessagePropertyFilter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::MessagePropertyFilter ^ MessageReadPropertyFilter { System::Messaging::MessagePropertyFilter ^ get(); void set(System::Messaging::MessagePropertyFilter ^ value); };" />
      <MemberSignature Language="F#" Value="member this.MessageReadPropertyFilter : System.Messaging.MessagePropertyFilter with get, set" Usage="System.Messaging.MessageQueue.MessageReadPropertyFilter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_MessageReadPropertyFilter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Content)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.MessagePropertyFilter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置接收或查看消息的属性筛选器。</summary>
        <value>由队列使用的 <see cref="T:System.Messaging.MessagePropertyFilter" />，用来筛选队列所接收或查看的每个消息的属性集。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此筛选器是一组限制消息属性的布尔值的<xref:System.Messaging.MessageQueue>接收或查看。 当<xref:System.Messaging.MessageQueue>接收或查看消息从服务器队列中，它仅检索那些为其<xref:System.Messaging.MessageQueue.MessageReadPropertyFilter%2A>值是`true`。  
  
 以下显示的初始属性值<xref:System.Messaging.MessageQueue.MessageReadPropertyFilter%2A>属性。 这些设置是相当于调用<xref:System.Messaging.MessagePropertyFilter.SetDefaults%2A>上<xref:System.Messaging.MessagePropertyFilter>。  
  
|Property|默认值|  
|--------------|-------------------|  
|<xref:System.Messaging.MessagePropertyFilter.Acknowledgment%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.AcknowledgeType%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.AdministrationQueue%2A>|`true`|  
|<xref:System.Messaging.MessagePropertyFilter.AppSpecific%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.ArrivedTime%2A>|`true`|  
|<xref:System.Messaging.MessagePropertyFilter.AttachSenderId%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.Authenticated%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.AuthenticationProviderName%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.AuthenticationProviderType%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.Body%2A>|`true`|  
|<xref:System.Messaging.MessagePropertyFilter.ConnectorType%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.CorrelationId%2A>|`true`|  
|<xref:System.Messaging.MessagePropertyFilter.DefaultBodySize%2A>|1024 个字节|  
|<xref:System.Messaging.MessagePropertyFilter.DefaultExtensionSize%2A>|255 个字节|  
|<xref:System.Messaging.MessagePropertyFilter.DefaultLabelSize%2A>|255 个字节|  
|<xref:System.Messaging.MessagePropertyFilter.DestinationQueue%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.DestinationSymmetricKey%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.DigitalSignature%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.EncryptionAlgorithm%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.Extension%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.HashAlgorithm%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.Id%2A>|`true`|  
|<xref:System.Messaging.MessagePropertyFilter.IsFirstInTransaction%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.IsLastInTransaction%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.Label%2A>|`true`|  
|<xref:System.Messaging.MessagePropertyFilter.MessageType%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.Priority%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.Recoverable%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.ResponseQueue%2A>|`true`|  
|<xref:System.Messaging.MessagePropertyFilter.SenderCertificate%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.SenderId%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.SenderVersion%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.SentTime%2A>|`true`|  
|<xref:System.Messaging.MessagePropertyFilter.SourceMachine%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.TimeToBeReceived%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.TimeToReachQueue%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.TransactionId%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.TransactionStatusQueue%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.UseAuthentication%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.UseDeadLetterQueue%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.UseEncryption%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.UseJournalQueue%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.UseTracing%2A>|`false`|  
  
 下表显示了此属性是否可在各种工作组模式下。  
  
|工作组模式下|可用|  
|--------------------|---------------|  
|本地计算机|是|  
|本地计算机和直接格式名|是|  
|远程计算机|是|  
|远程计算机并直接格式名|是|  
  
   
  
## Examples  
 下面的代码示例使用<xref:System.Messaging.MessageQueue.MessageReadPropertyFilter%2A>来限制接收的消息属性。  
  
 [!code-cpp[MessageQueue.MessageReadPropertyFilter#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.MessageReadPropertyFilter/CPP/mqmessagereadpropertyfilter.cpp#1)]
 [!code-csharp[MessageQueue.MessageReadPropertyFilter#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.MessageReadPropertyFilter/CS/mqmessagereadpropertyfilter.cs#1)]
 [!code-vb[MessageQueue.MessageReadPropertyFilter#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.MessageReadPropertyFilter/VB/mqmessagereadpropertyfilter.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">筛选器为 <see langword="null" />。</exception>
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="MulticastAddress">
      <MemberSignature Language="C#" Value="public string MulticastAddress { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string MulticastAddress" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.MulticastAddress" />
      <MemberSignature Language="VB.NET" Value="Public Property MulticastAddress As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ MulticastAddress { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.MulticastAddress : string with get, set" Usage="System.Messaging.MessageQueue.MulticastAddress" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_MulticastAddress")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在 MSMQ 3.0 中引入。 获取或设置与队列关联的多路广播地址。</summary>
        <value>包含有效的多路广播地址（格式如下）的 <see cref="T:System.String" />，或者为 <see langword="null" />，这表示队列与多路广播地址不关联。  
  
```  
&lt;address&gt;:&lt;port&gt;  
```</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.MulticastAddress%2A>属性用于将非事务性队列发送消息时可以使用的多播地址与相关联。 不能将事务性队列与多播地址相关联。 当发送应用程序将消息发送到多播地址时，消息队列将消息的副本发送到与该地址相关联的每个队列。  
  
 IP 多播地址必须位于类 D 范围介于 224.0.0.0 到 239.255.255.255，对应于等于 1110年的前四个高阶位设置。 但是，只有特定范围的此范围内的地址是保留的可用于发送多播的消息。 保留的多播地址的最新列表，请参阅[Internet 分配号机构 (IANA) Internet 多播地址](https://go.microsoft.com/fwlink/?linkid=3859)网页。 没有任何限制上的端口号。  
  
 如果多个源计算机发送多播的消息，并且你想要从只有一台源计算机接收消息的特定队列，每台源计算机必须向不同的 IP 地址和端口号组合发送消息。  
  
 若要取消关联的多播地址从一个队列，设置<xref:System.Messaging.MessageQueue.MulticastAddress%2A>属性设置为零长度字符串。 不将其设置为`null`，因为这将导致<xref:System.ArgumentNullException>。  
  
 下表显示了此属性是否可在各种工作组模式下。  
  
|工作组模式下|可用|  
|--------------------|---------------|  
|本地计算机|是|  
|本地计算机和直接格式名|是|  
|远程计算机|否|  
|远程计算机并直接格式名|否|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">未安装 MSMQ 3.0。</exception>
      </Docs>
    </Member>
    <Member MemberName="Path">
      <MemberSignature Language="C#" Value="public string Path { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Path" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.Path" />
      <MemberSignature Language="VB.NET" Value="Public Property Path As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Path { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Path : string with get, set" Usage="System.Messaging.MessageQueue.Path" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Editor("System.Messaging.Design.QueuePathEditor", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.StringValueConverter, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_Path")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.ComponentModel.Editor("System.Messaging.Design.QueuePathEditor", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.ComponentModel.RecommendedAsConfigurable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.StringValueConverter, System.Design, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.Editor("System.Messaging.Design.QueuePathEditor", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.RefreshProperties(System.ComponentModel.RefreshProperties.All)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.SettingsBindable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.StringValueConverter, System.Design, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.RefreshProperties</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置队列的路径。 设置 <see cref="P:System.Messaging.MessageQueue.Path" /> 会导致 <see cref="T:System.Messaging.MessageQueue" /> 指向新队列。</summary>
        <value>由 <see cref="T:System.Messaging.MessageQueue" /> 引用的队列。 默认值取决于所使用的 <see cref="M:System.Messaging.MessageQueue.#ctor" /> 构造函数；它或者是 <see langword="null" />，或者是由构造函数的 <paramref name="path" /> 参数指定的。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 语法<xref:System.Messaging.MessageQueue.Path%2A>属性取决于队列的类型它点为下表中所示。  
  
|队列类型|语法|  
|----------------|------------|  
|公用队列|`MachineName`\\`QueueName`|  
|专用队列|`MachineName`\\`Private$`\\`QueueName`|  
|日记队列|`MachineName`\\`QueueName`\\`Journal$`|  
|计算机日志队列|`MachineName`\\`Journal$`|  
|计算机死信队列|`MachineName`\\`Deadletter$`|  
|计算机事务性死信队列|`MachineName`\\`XactDeadletter$`|  
  
 使用"。"来表示本地计算机。  
  
 <xref:System.Messaging.MessageQueue.MachineName%2A>， <xref:System.Messaging.MessageQueue.Path%2A>，和<xref:System.Messaging.MessageQueue.QueueName%2A>相关的属性。 更改<xref:System.Messaging.MessageQueue.MachineName%2A>属性会导致<xref:System.Messaging.MessageQueue.Path%2A>要更改属性。 从新构建<xref:System.Messaging.MessageQueue.MachineName%2A>和<xref:System.Messaging.MessageQueue.QueueName%2A>。 更改<xref:System.Messaging.MessageQueue.Path%2A>（例如，若要使用的格式名称语法） 将重置<xref:System.Messaging.MessageQueue.MachineName%2A>和<xref:System.Messaging.MessageQueue.QueueName%2A>属性来引用新队列。  
  
 或者，可以使用<xref:System.Messaging.MessageQueue.FormatName%2A>或<xref:System.Messaging.MessageQueue.Label%2A>来描述的队列路径下, 表中所示。  
  
|参考|语法|示例|  
|---------------|------------|-------------|  
|格式名称|`FormatName:` [*格式名称*]|`FormatName:Public=` 5A5F7535-AE9A-41d4-935C-845C2AFF7112|  
|Label|`Label:` [*标签*]|`Label:` 标签|  
  
 如果使用的标签语法<xref:System.Messaging.MessageQueue.Path%2A>属性发送消息时，将引发异常，如果<xref:System.Messaging.MessageQueue.Label%2A>不是唯一的。  
  
 若要脱机工作，必须在第一个表中使用格式名语法，而不是友好名称语法。 否则，因为主域控制器 （Active Directory 所在） 不是可用于将路径解析为格式名，将引发异常。  
  
 设置新路径关闭消息队列，并释放所有句柄。  
  
 下表显示了此属性是否可在各种工作组模式下。  
  
|工作组模式下|可用|  
|--------------------|---------------|  
|本地计算机|是|  
|本地计算机和直接格式名|是|  
|远程计算机|是|  
|远程计算机并直接格式名|是|  
  
> [!NOTE]
>  在工作组模式下只能使用专用队列。 指定在路径中使用的专用队列语法`MachineName` \\ `Private$` \\ `QueueName`。  
  
   
  
## Examples  
 下面的代码示例创建新<xref:System.Messaging.MessageQueue>对象使用各种路径名称语法类型。 每种情况下，它将一条消息发送到队列的构造函数中定义的路径。  
  
 [!code-cpp[MessageQueue.Path#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Path/CPP/mqpath.cpp#1)]
 [!code-csharp[MessageQueue.Path#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Path/CS/mqpath.cs#1)]
 [!code-vb[MessageQueue.Path#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Path/VB/mqpath.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">路径无效，可能是因为语法无效。</exception>
        <altmember cref="P:System.Messaging.MessageQueue.QueueName" />
        <altmember cref="P:System.Messaging.MessageQueue.MachineName" />
        <altmember cref="P:System.Messaging.MessageQueue.FormatName" />
        <altmember cref="P:System.Messaging.MessageQueue.Label" />
        <altmember cref="M:System.Messaging.MessageQueue.#ctor" />
        <altmember cref="M:System.Messaging.MessageQueue.Close" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Peek">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <threadsafe>该方法不是线程安全。</threadsafe>
        <summary>返回队列中第一条消息的副本，而不从队列中移除该消息。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Peek">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Peek ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Peek() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Peek" />
      <MemberSignature Language="VB.NET" Value="Public Function Peek () As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Peek();" />
      <MemberSignature Language="F#" Value="member this.Peek : unit -&gt; System.Messaging.Message" Usage="messageQueue.Peek " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回但不移除（查看）此 <see cref="T:System.Messaging.MessageQueue" /> 所引用的队列中的第一条消息。 <see cref="M:System.Messaging.MessageQueue.Peek" /> 方法是同步的，所以在有可用消息前，该方法阻塞当前线程。</summary>
        <returns>该 <see cref="T:System.Messaging.Message" /> 表示队列中第一条消息。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要查看队列，或等待，直到在队列中存在一条消息，请使用此重载。  
  
 <xref:System.Messaging.MessageQueue.Peek%2A>方法读取，但不会删除队列中的第一个消息。 因此，重复调用<xref:System.Messaging.MessageQueue.Peek%2A>返回相同的消息，除非较高优先级的消息到达队列中。 <xref:System.Messaging.MessageQueue.Receive%2A>方法，但是，读取并从队列中移除第一条消息。 重复调用<xref:System.Messaging.MessageQueue.Receive%2A>，因此，返回不同的消息。  
  
 消息队列的优先级和到达时间根据队列中进行排序的消息。 仅当优先级较高，较新消息放旧的前面。  
  
 如果当前线程在等待消息到达队列时可以被阻塞，则使用 <xref:System.Messaging.MessageQueue.Peek%2A>。 此重载不指定超时，因为该应用程序可能会无限期等待。 如果需要应用程序处理继续进行而不等待，则使用异步 <xref:System.Messaging.MessageQueue.BeginPeek%2A> 方法。 或者，可以指定要使用的重载到达队列的消息的超时值<xref:System.Messaging.MessageQueue.Peek%2A>指定超时。  
  
 下表显示了此方法是在各种工作组模式下可用。  
  
|工作组模式下|可用|  
|--------------------|---------------|  
|本地计算机|是|  
|本地计算机和直接格式名|是|  
|远程计算机|否|  
|远程计算机并直接格式名|是|  
  
   
  
## Examples  
 下面的示例使用<xref:System.Messaging.MessageQueue.Peek%2A>队列上的方法。  
  
 在第一个示例中，应用程序等待，直到有可用的队列中消息。 请注意第一个示例不会访问的消息的到达;它只是暂停处理直到有消息到达。 如果在队列中已存在一条消息，它将立即返回。  
  
 在第二个示例中，包含应用程序定义的消息`Order`类是发送到队列，，然后从队列中查看。  
  
 [!code-cpp[MessageQueue.Peek_noparms#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Peek_noparms/CPP/mqpeek_noparms.cpp#1)]
 [!code-csharp[MessageQueue.Peek_noparms#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Peek_noparms/CS/mqpeek_noparms.cs#1)]
 [!code-vb[MessageQueue.Peek_noparms#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Peek_noparms/VB/mqpeek_noparms.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">访问“消息队列”方法时出错。</exception>
        <threadsafe>该方法不是线程安全。</threadsafe>
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
      </Docs>
    </Member>
    <Member MemberName="Peek">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Peek (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Peek(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Peek(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function Peek (timeout As TimeSpan) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Peek(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.Peek : TimeSpan -&gt; System.Messaging.Message" Usage="messageQueue.Peek timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">一个 <see cref="T:System.TimeSpan" /> 指示等待队列包含消息所用的最长时间。</param>
        <summary>返回但不移除（查看）此 <see cref="T:System.Messaging.MessageQueue" /> 所引用的队列中的第一条消息。 <see cref="M:System.Messaging.MessageQueue.Peek" /> 方法是同步的，因此在有可用消息或发生指定的超时之前，它一直阻止当前线程。</summary>
        <returns>该 <see cref="T:System.Messaging.Message" /> 表示队列中第一条消息。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要查看队列，或等待一段指定时间，直到在队列中存在一条消息，请使用此重载。 如果消息在队列中已存在，方法将立即返回。  
  
 <xref:System.Messaging.MessageQueue.Peek%2A>方法读取，但不会删除队列中的第一个消息。 因此，重复调用<xref:System.Messaging.MessageQueue.Peek%2A>返回相同的消息，除非较高优先级的消息到达队列中。 <xref:System.Messaging.MessageQueue.Receive%2A>方法，但是，读取并从队列中移除第一条消息。 重复调用<xref:System.Messaging.MessageQueue.Receive%2A>，因此，返回不同的消息。  
  
 消息队列的优先级和到达时间根据队列中进行排序的消息。 仅当优先级较高，较新消息放旧的前面。  
  
 如果当前线程在等待消息到达队列时可以被阻塞，则使用 <xref:System.Messaging.MessageQueue.Peek%2A>。 线程将阻塞段指定的时间，或者如果您指示<xref:System.Messaging.MessageQueue.InfiniteTimeout>。 如果需要应用程序处理继续进行而不等待，则使用异步 <xref:System.Messaging.MessageQueue.BeginPeek%2A> 方法。  
  
 下表显示了此方法是在各种工作组模式下可用。  
  
|工作组模式下|可用|  
|--------------------|---------------|  
|本地计算机|是|  
|本地计算机和直接格式名|是|  
|远程计算机|否|  
|远程计算机并直接格式名|是|  
  
   
  
## Examples  
 下面的代码示例使用<xref:System.Messaging.MessageQueue.Peek%2A>方法的超时值为零，以检查队列是否为空。  
  
 [!code-cpp[MessageQueue.Peek_timeout#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Peek_timeout/CPP/mqpeek_timeout.cpp#1)]
 [!code-csharp[MessageQueue.Peek_timeout#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Peek_timeout/CS/mqpeek_timeout.cs#1)]
 [!code-vb[MessageQueue.Peek_timeout#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Peek_timeout/VB/mqpeek_timeout.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">为 <paramref name="timeout" /> 参数指定的值无效，可能是 <paramref name="timeout" /> 小于 <see cref="F:System.TimeSpan.Zero" /> 或大于 <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">访问“消息队列”方法时出错。</exception>
        <threadsafe>该方法不是线程安全。</threadsafe>
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
      </Docs>
    </Member>
    <Member MemberName="Peek">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Peek (TimeSpan timeout, System.Messaging.Cursor cursor, System.Messaging.PeekAction action);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Peek(valuetype System.TimeSpan timeout, class System.Messaging.Cursor cursor, valuetype System.Messaging.PeekAction action) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Peek(System.TimeSpan,System.Messaging.Cursor,System.Messaging.PeekAction)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Peek(TimeSpan timeout, System::Messaging::Cursor ^ cursor, System::Messaging::PeekAction action);" />
      <MemberSignature Language="F#" Value="member this.Peek : TimeSpan * System.Messaging.Cursor * System.Messaging.PeekAction -&gt; System.Messaging.Message" Usage="messageQueue.Peek (timeout, cursor, action)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="cursor" Type="System.Messaging.Cursor" />
        <Parameter Name="action" Type="System.Messaging.PeekAction" />
      </Parameters>
      <Docs>
        <param name="timeout">一个 <see cref="T:System.TimeSpan" /> 指示等待队列包含消息所用的最长时间。</param>
        <param name="cursor">维持消息队列中特定位置的 <see cref="T:System.Messaging.Cursor" />。</param>
        <param name="action">
          <see cref="T:System.Messaging.PeekAction" /> 值之一。 指示是查看队列中的当前消息还是下一条消息。</param>
        <summary>使用指定的游标返回但不移除（查看）队列中的当前消息或下一条消息。 <see cref="M:System.Messaging.MessageQueue.Peek" /> 方法是同步的，因此在有可用消息或发生指定的超时之前，它一直阻止当前线程。</summary>
        <returns>一个 <see cref="T:System.Messaging.Message" />，表示队列中的消息。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要查看队列，或等待一段指定时间，直到在队列中存在一条消息，请使用此重载。 如果消息在队列中已存在，方法将立即返回。  
  
 <xref:System.Messaging.MessageQueue.Peek%2A>方法读取，但不会删除队列的消息。 <xref:System.Messaging.MessageQueue.Receive%2A>方法，但是，读取并从队列中删除一条消息。  
  
 如果当前线程在等待消息到达队列时可以被阻塞，则使用 <xref:System.Messaging.MessageQueue.Peek%2A>。 线程阻塞段指定的时间，或者如果您指示<xref:System.Messaging.MessageQueue.InfiniteTimeout>。 如果需要应用程序处理继续进行而不等待，则使用异步 <xref:System.Messaging.MessageQueue.BeginPeek%2A> 方法。  
  
 下表显示了此方法是在各种工作组模式下可用。  
  
|工作组模式下|可用|  
|--------------------|---------------|  
|本地计算机|是|  
|本地计算机和直接格式名|是|  
|远程计算机|否|  
|远程计算机并直接格式名|是|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">为 <paramref name="action" /> 参数指定的值不是 <see langword="PeekAction.Current" /> 和 <see langword="PeekAction.Next" />。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="cursor" /> 参数为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">为 <paramref name="timeout" /> 参数指定的值无效。 <paramref name="timeout" /> 可能小于 <see cref="F:System.TimeSpan.Zero" /> 或大于 <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">访问“消息队列”方法时出错。</exception>
        <threadsafe>该方法不是线程安全。</threadsafe>
        <altmember cref="T:System.Messaging.Cursor" />
        <altmember cref="T:System.Messaging.PeekAction" />
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
      </Docs>
    </Member>
    <MemberGroup MemberName="PeekByCorrelationId">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>查看匹配给定相关标识符的消息。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="PeekByCorrelationId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message PeekByCorrelationId (string correlationId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message PeekByCorrelationId(string correlationId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.PeekByCorrelationId(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function PeekByCorrelationId (correlationId As String) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ PeekByCorrelationId(System::String ^ correlationId);" />
      <MemberSignature Language="F#" Value="member this.PeekByCorrelationId : string -&gt; System.Messaging.Message" Usage="messageQueue.PeekByCorrelationId correlationId" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="correlationId" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="correlationId">要查看的消息的 <see cref="P:System.Messaging.Message.CorrelationId" />。</param>
        <summary>查看匹配给定相关标识符的消息，而且在队列中当前不存在具有指定相关标识符的消息时，立即引发异常。</summary>
        <returns>其 <see cref="T:System.Messaging.Message" /> 匹配传入的 <paramref name="correlationId" /> 参数的 <see cref="P:System.Messaging.Message.CorrelationId" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法中引用的队列中查找<xref:System.Messaging.MessageQueue>消息其<xref:System.Messaging.Message.CorrelationId%2A>匹配指定`correlationId`参数。 如果未找到消息相匹配`correlationID`参数，将引发异常。  
  
 <xref:System.Messaging.Message.CorrelationId%2A>属性用于将绑定到队列相关联的响应、 报表或确认消息发送到发送的消息。  
  
 其他两种方法可以查看队列中的消息。 <xref:System.Messaging.MessageQueue.Peek%2A>方法在队列中，将返回第一条消息和<xref:System.Messaging.MessageQueue.PeekById%28System.String%29>方法用于检索一条消息，通过指定它的唯一标识符。  
  
 下表显示了此方法是在各种工作组模式下可用。  
  
|工作组模式下|可用|  
|--------------------|---------------|  
|本地计算机|是|  
|本地计算机和直接格式名|是|  
|远程计算机|否|  
|远程计算机并直接格式名|是|  
  
   
  
## Examples  
 下面的代码示例发送和接收包含订单到和从队列的消息。 它专门请求肯定确认当原始消息到达或已从队列中检索。  
  
 [!code-cpp[Message.Acknowledgment#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.Acknowledgment/CPP/message_acknowledgment.cpp#1)]
 [!code-csharp[Message.Acknowledgment#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.Acknowledgment/CS/message_acknowledgment.cs#1)]
 [!code-vb[Message.Acknowledgment#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.Acknowledgment/VB/message_acknowledgment.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="correlationId" /> 参数为 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">未能找到具有指定 <paramref name="correlationId" /> 的消息。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">访问“消息队列”方法时出错。</exception>
        <altmember cref="P:System.Messaging.Message.CorrelationId" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
      </Docs>
    </Member>
    <Member MemberName="PeekByCorrelationId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message PeekByCorrelationId (string correlationId, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message PeekByCorrelationId(string correlationId, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.PeekByCorrelationId(System.String,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function PeekByCorrelationId (correlationId As String, timeout As TimeSpan) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ PeekByCorrelationId(System::String ^ correlationId, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.PeekByCorrelationId : string * TimeSpan -&gt; System.Messaging.Message" Usage="messageQueue.PeekByCorrelationId (correlationId, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="correlationId" Type="System.String" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="correlationId">要查看的消息的 <see cref="P:System.Messaging.Message.CorrelationId" />。</param>
        <param name="timeout">一个 <see cref="T:System.TimeSpan" /> 指示有新消息可用于检查之前等待的时间。</param>
        <summary>查看匹配给定相关标识符的消息，并且一直等到队列中出现具有指定相关标识符的消息或超时过期时。</summary>
        <returns>其 <see cref="T:System.Messaging.Message" /> 匹配传入的 <paramref name="correlationId" /> 参数的 <see cref="P:System.Messaging.Message.CorrelationId" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法中引用的队列中查找<xref:System.Messaging.MessageQueue>消息其<xref:System.Messaging.Message.CorrelationId%2A>匹配指定`correlationId`参数。 如果未找到消息相匹配`correlationID`参数，并且没有新消息到达队列中指定的时期内`timeout`参数，将引发异常。  
  
 `timeout`参数未指定的总运行时间为此方法。 相反，它指定为新消息到达队列中等待的时间。 每次有新消息到达时，此方法将检查<xref:System.Messaging.Message.CorrelationId%2A>的新消息，以查看其是否符合`correlationId`参数。 如果没有，此方法通过启动的超时期限，等待另一个新消息到达。 因此，如果新消息继续到达在超时期内，就可以为此方法以继续无限期运行直到超时期限到期且无需任何新消息到达，或者直到有消息到达其<xref:System.Messaging.Message.CorrelationId%2A>匹配`correlationId`参数。  
  
 <xref:System.Messaging.Message.CorrelationId%2A>属性用于将绑定到队列相关联的响应、 报表或确认消息发送到发送的消息。  
  
 其他两种方法可以查看队列中的消息。 <xref:System.Messaging.MessageQueue.Peek%2A>方法在队列中，将返回第一条消息和<xref:System.Messaging.MessageQueue.PeekById%28System.String%29>方法用于检索一条消息，通过指定它的唯一标识符。  
  
 下表显示了此方法是在各种工作组模式下可用。  
  
|工作组模式下|可用|  
|--------------------|---------------|  
|本地计算机|是|  
|本地计算机和直接格式名|是|  
|远程计算机|否|  
|远程计算机并直接格式名|是|  
  
   
  
## Examples  
 以下代码示例演示了 <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%2CSystem.TimeSpan%29> 的用法。  
  
 [!code-cpp[MessageQueue2#5](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#5)]
 [!code-csharp[MessageQueue2#5](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="correlationId" /> 参数为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">为 <paramref name="timeout" /> 参数指定的值无效，可能是 <paramref name="timeout" /> 小于 <see cref="F:System.TimeSpan.Zero" /> 或大于 <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />。</exception>
        <exception cref="T:System.InvalidOperationException">具有指定 <paramref name="correlationId" /> 的消息不在队列中，而且在超时过期之前没有到达。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">消息在超时过期前没有到达。  
  
或 
访问“消息队列”方法时出错。</exception>
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />
        <altmember cref="P:System.Messaging.Message.CorrelationId" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
      </Docs>
    </Member>
    <MemberGroup MemberName="PeekById">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>返回具有指定消息标识符的消息的副本，但不从队列中移除消息。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="PeekById">
      <MemberSignature Language="C#" Value="public System.Messaging.Message PeekById (string id);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message PeekById(string id) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.PeekById(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function PeekById (id As String) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ PeekById(System::String ^ id);" />
      <MemberSignature Language="F#" Value="member this.PeekById : string -&gt; System.Messaging.Message" Usage="messageQueue.PeekById id" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="id">要查看的消息的 <see cref="P:System.Messaging.Message.Id" />。</param>
        <summary>查看其消息标识符匹配 <paramref name="id" /> 参数的消息。</summary>
        <returns>
          <see cref="T:System.Messaging.Message" />，其 <see cref="P:System.Messaging.Message.Id" /> 属性匹配 <paramref name="id" /> 参数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用<xref:System.Messaging.MessageQueue.PeekById%28System.String%29>读取，不从队列中删除具有已知的消息标识符的消息。 一条消息的标识符是整个消息队列企业内、 唯一的因此将有最多一条消息中的队列的匹配给定`id`参数。 如果队列中当前不包含该消息，此重载将引发异常。  
  
 两个其他方法使您得以在队列中扫视消息：<xref:System.Messaging.MessageQueue.Peek%2A>和<xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29>。 <xref:System.Messaging.MessageQueue.Peek%2A>方法返回的第一个消息队列; 中<xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29>返回确认、 报表或已创建第一条消息发送到队列的应用程序生成的响应消息。  
  
 下表显示了此方法是在各种工作组模式下可用。  
  
|工作组模式下|可用|  
|--------------------|---------------|  
|本地计算机|是|  
|本地计算机和直接格式名|是|  
|远程计算机|否|  
|远程计算机并直接格式名|是|  
  
   
  
## Examples  
 以下代码示例演示了 <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> 的用法。  
  
 [!code-cpp[MessageQueue2#6](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#6)]
 [!code-csharp[MessageQueue2#6](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="id" /> 参数为 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">不存在具有指定 <paramref name="id" /> 的消息。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">访问“消息队列”方法时出错。</exception>
        <altmember cref="P:System.Messaging.Message.Id" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
      </Docs>
    </Member>
    <Member MemberName="PeekById">
      <MemberSignature Language="C#" Value="public System.Messaging.Message PeekById (string id, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message PeekById(string id, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.PeekById(System.String,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function PeekById (id As String, timeout As TimeSpan) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ PeekById(System::String ^ id, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.PeekById : string * TimeSpan -&gt; System.Messaging.Message" Usage="messageQueue.PeekById (id, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="id">要查看的消息的 <see cref="P:System.Messaging.Message.Id" />。</param>
        <param name="timeout">一个 <see cref="T:System.TimeSpan" /> 指示有新消息可用于检查之前等待的时间。</param>
        <summary>查看其消息标识符匹配 <paramref name="id" /> 参数的消息。 一直等到队列中出现该消息或发生超时。</summary>
        <returns>
          <see cref="T:System.Messaging.Message" />，其 <see cref="P:System.Messaging.Message.Id" /> 属性匹配 <paramref name="id" /> 参数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用<xref:System.Messaging.MessageQueue.PeekById%28System.String%29>读取，不从队列中删除具有已知的消息标识符的消息。 一条消息的标识符是整个消息队列企业内、 唯一的因此将有最多一条消息中的队列的匹配给定`id`参数。 如果队列当前不包括消息和新的消息没有到达之前发生超时的时候，此重载将引发异常。  
  
 `timeout`参数未指定的总运行时间为此方法。 相反，它指定为新消息到达队列中等待的时间。 每次有新消息到达时，此方法将检查<xref:System.Messaging.Message.Id%2A>的新消息，以查看其是否符合`id`参数。 如果没有，此方法通过启动的超时期限，等待另一个新消息到达。 因此，如果新消息继续到达在超时期内，就可以为此方法以继续无限期运行直到超时期限到期且无需任何新消息到达，或者直到有消息到达其<xref:System.Messaging.Message.Id%2A>匹配`id`参数。  
  
 两个其他方法使您得以在队列中扫视消息：<xref:System.Messaging.MessageQueue.Peek%2A>和<xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29>。 <xref:System.Messaging.MessageQueue.Peek%2A>方法返回的第一个消息队列; 中<xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29>返回确认、 报表或已创建第一条消息发送到队列的应用程序生成的响应消息。  
  
 下表显示了此方法是在各种工作组模式下可用。  
  
|工作组模式下|可用|  
|--------------------|---------------|  
|本地计算机|是|  
|本地计算机和直接格式名|是|  
|远程计算机|否|  
|远程计算机并直接格式名|是|  
  
   
  
## Examples  
 以下代码示例演示了 <xref:System.Messaging.MessageQueue.PeekById%28System.String%2CSystem.TimeSpan%29> 的用法。  
  
 [!code-cpp[MessageQueue2#7](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#7)]
 [!code-csharp[MessageQueue2#7](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="id" /> 参数为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">为 <paramref name="timeout" /> 参数指定的值无效，可能是 <paramref name="timeout" /> 小于 <see cref="F:System.TimeSpan.Zero" /> 或大于 <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />。</exception>
        <exception cref="T:System.InvalidOperationException">队列中不存在具有指定 <paramref name="id" /> 的消息，并且在 <paramref name="timeout" /> 参数指定的时间段过期之前该消息仍未到达。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">访问“消息队列”方法时出错。</exception>
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />
        <altmember cref="P:System.Messaging.Message.Id" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
      </Docs>
    </Member>
    <MemberGroup MemberName="PeekByLookupId">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>在 MSMQ 3.0 中引入。 查看队列中特定的消息。 消息可通过查询标识符来指定，也可以通过其相对于队首或队尾的位置来指定。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="PeekByLookupId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message PeekByLookupId (long lookupId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message PeekByLookupId(int64 lookupId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.PeekByLookupId(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function PeekByLookupId (lookupId As Long) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ PeekByLookupId(long lookupId);" />
      <MemberSignature Language="F#" Value="member this.PeekByLookupId : int64 -&gt; System.Messaging.Message" Usage="messageQueue.PeekByLookupId lookupId" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="lookupId" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="lookupId">要查看的消息的 <see cref="P:System.Messaging.Message.LookupId" />。</param>
        <summary>在 MSMQ 3.0 中引入。 从非事务性队列中查看与给定查找标识符匹配的消息。</summary>
        <returns>
          <see cref="T:System.Messaging.Message" />，其 <see cref="P:System.Messaging.Message.LookupId" /> 属性匹配传入的 <paramref name="lookupId" /> 参数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用此方法读取具有已知的查找标识符的消息，而从队列中删除它。 如果消息不是在队列中，此方法将立即引发异常。  
  
 <xref:System.Messaging.Message.LookupId%2A>消息的属性是唯一的队列消息所在的位置，因此将存在最多一条消息中的队列的匹配给定`lookupId`参数。  
  
 若要读取具有指定的查找标识符的消息并将其从队列删除，请使用<xref:System.Messaging.MessageQueue.ReceiveByLookupId%2A>方法。  
  
 下表显示了此方法是在各种工作组模式下可用。  
  
|工作组模式下|可用|  
|--------------------|---------------|  
|本地计算机|是|  
|本地计算机和直接格式名|是|  
|远程计算机|否|  
|远程计算机并直接格式名|是|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">未安装 MSMQ 3.0。</exception>
        <exception cref="T:System.InvalidOperationException">未能找到具有指定 <paramref name="lookupId" /> 的消息。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">访问“消息队列”方法时出错。</exception>
        <altmember cref="P:System.Messaging.Message.LookupId" />
        <altmember cref="M:System.Messaging.MessageQueue.ReceiveByLookupId" />
      </Docs>
    </Member>
    <Member MemberName="PeekByLookupId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message PeekByLookupId (System.Messaging.MessageLookupAction action, long lookupId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message PeekByLookupId(valuetype System.Messaging.MessageLookupAction action, int64 lookupId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.PeekByLookupId(System.Messaging.MessageLookupAction,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function PeekByLookupId (action As MessageLookupAction, lookupId As Long) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ PeekByLookupId(System::Messaging::MessageLookupAction action, long lookupId);" />
      <MemberSignature Language="F#" Value="member this.PeekByLookupId : System.Messaging.MessageLookupAction * int64 -&gt; System.Messaging.Message" Usage="messageQueue.PeekByLookupId (action, lookupId)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="action" Type="System.Messaging.MessageLookupAction" />
        <Parameter Name="lookupId" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="action">一个 <see cref="T:System.Messaging.MessageLookupAction" /> 值，指定读取队列中消息的方式。 指定以下值之一： 
 <see langword="MessageLookupAction.Current" />：查看由 <c>lookupId</c> 指定的消息。  
  
 <see langword="MessageLookupAction.Next" />：查看由 <c>lookupId</c> 指定消息的下一条消息。  
  
 <see langword="MessageLookupAction.Previous" />：查看由 <c>lookupId</c> 指定消息的上一条消息。  
  
 <see langword="MessageLookupAction.First" />：查看队列中的第一条消息。 <c>lookupId</c> 参数必须设置为 0。  
  
 <see langword="MessageLookupAction.Last" />：查看队列中的最后一条消息。 <c>lookupId</c> 参数必须设置为 0。</param>
        <param name="lookupId">要查看的消息的 <see cref="P:System.Messaging.Message.LookupId" /> 或者为 0。 访问队列中的第一条和最后一条消息时使用 0。</param>
        <summary>在 MSMQ 3.0 中引入。 查看队列中特定的消息。 消息可通过查询标识符来指定，也可以通过其相对于队首或队尾的位置来指定。</summary>
        <returns>由传入的 <paramref name="action" /> 和 <paramref name="lookupId" /> 参数指定的 <see cref="T:System.Messaging.Message" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用此方法读取具有已知的查找标识符的消息，而从队列中删除它。 如果消息不是在队列中，此方法将立即引发异常。  
  
 <xref:System.Messaging.Message.LookupId%2A>消息的属性是唯一的队列消息所在的位置，因此将存在最多一条消息中的队列的匹配给定`lookupId`参数。  
  
 若要读取具有指定标识符的消息并将其从队列删除，请使用<xref:System.Messaging.MessageQueue.ReceiveByLookupId%2A>方法。  
  
 下表显示了此方法是在各种工作组模式下可用。  
  
|工作组模式下|可用|  
|--------------------|---------------|  
|本地计算机|是|  
|本地计算机和直接格式名|是|  
|远程计算机|否|  
|远程计算机并直接格式名|是|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">未安装 MSMQ 3.0。</exception>
        <exception cref="T:System.InvalidOperationException">未能找到具有指定 <paramref name="lookupId" /> 的消息。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">访问“消息队列”方法时出错。</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="action" /> 参数不是 <see cref="T:System.Messaging.MessageLookupAction" /> 成员之一。</exception>
        <altmember cref="P:System.Messaging.Message.LookupId" />
        <altmember cref="M:System.Messaging.MessageQueue.ReceiveByLookupId" />
      </Docs>
    </Member>
    <Member MemberName="PeekCompleted">
      <MemberSignature Language="C#" Value="public event System.Messaging.PeekCompletedEventHandler PeekCompleted;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Messaging.PeekCompletedEventHandler PeekCompleted" />
      <MemberSignature Language="DocId" Value="E:System.Messaging.MessageQueue.PeekCompleted" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PeekCompleted As PeekCompletedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Messaging::PeekCompletedEventHandler ^ PeekCompleted;" />
      <MemberSignature Language="F#" Value="member this.PeekCompleted : System.Messaging.PeekCompletedEventHandler " Usage="member this.PeekCompleted : System.Messaging.PeekCompletedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_PeekCompleted")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.PeekCompletedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在消息未从队列移除的情况下读取该消息时发生。 这是异步操作 <see cref="M:System.Messaging.MessageQueue.BeginPeek" /> 的结果。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.BeginPeek%2A> 在异步处理过程中用来发出<xref:System.Messaging.MessageQueue.PeekCompleted>事件队列中出现一条消息时。  
  
 <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> 用于完成通过调用启动的操作<xref:System.Messaging.MessageQueue.BeginPeek%2A>和扫视消息时<xref:System.Messaging.MessageQueue.PeekCompleted>引发事件。  
  
 创建 <xref:System.Messaging.PeekCompletedEventHandler> 委托时，需要标识将处理该事件的方法。 若要将事件与事件处理程序关联，请将该委托的一个实例添加到事件中。 除非移除了该委托，否则每当发生该事件时就会调用事件处理程序。 有关事件处理程序委托的详细信息，请参阅[处理和引发事件](~/docs/standard/events/index.md)。  
  
   
  
## Examples  
 下面的代码示例创建名为一个事件处理程序`MyPeekCompleted`，将其附加到<xref:System.Messaging.MessageQueue.PeekCompleted>事件处理程序委托，然后调用<xref:System.Messaging.MessageQueue.BeginPeek%2A>启动异步查看操作上的队列的路径处"。 \myQueue"。 当<xref:System.Messaging.MessageQueue.PeekCompleted>引发事件，该示例查看的消息并将其正文写入到屏幕。 该示例然后调用<xref:System.Messaging.MessageQueue.BeginPeek%2A>再次以启动新的异步查看操作  
  
 [!code-cpp[MessageQueue.BeginPeek_noparms#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.BeginPeek_noparms/CPP/mqbeginpeek_noparms.cpp#1)]
 [!code-csharp[MessageQueue.BeginPeek_noparms#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.BeginPeek_noparms/CS/mqbeginpeek_noparms.cs#1)]
 [!code-vb[MessageQueue.BeginPeek_noparms#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.BeginPeek_noparms/VB/mqbeginpeek_noparms.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="E:System.Messaging.MessageQueue.ReceiveCompleted" />
        <altmember cref="T:System.TimeSpan" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="T:System.IAsyncResult" />
      </Docs>
    </Member>
    <Member MemberName="Purge">
      <MemberSignature Language="C#" Value="public void Purge ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Purge() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Purge" />
      <MemberSignature Language="VB.NET" Value="Public Sub Purge ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Purge();" />
      <MemberSignature Language="F#" Value="member this.Purge : unit -&gt; unit" Usage="messageQueue.Purge " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>删除队列中包含的所有消息。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 清除队列导致消息队列设置队列修改标志，这会影响<xref:System.Messaging.MessageQueue.LastModifyTime%2A>属性。 从队列中清除的消息将会丢失;它们不发送到死信队列或日志队列。  
  
 下表显示了此方法是在各种工作组模式下可用。  
  
|工作组模式下|可用|  
|--------------------|---------------|  
|本地计算机|是|  
|本地计算机和直接格式名|是|  
|远程计算机|否|  
|远程计算机并直接格式名|是|  
  
   
  
## Examples  
 以下代码示例演示了 <xref:System.Messaging.MessageQueue.Purge%2A> 的用法。  
  
 [!code-cpp[MessageQueue2#29](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#29)]
 [!code-csharp[MessageQueue2#29](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#29)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">访问“消息队列”方法时出错。</exception>
        <altmember cref="M:System.Messaging.MessageQueue.Close" />
        <altmember cref="M:System.Messaging.MessageQueue.Refresh" />
      </Docs>
    </Member>
    <Member MemberName="QueueName">
      <MemberSignature Language="C#" Value="public string QueueName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string QueueName" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.QueueName" />
      <MemberSignature Language="VB.NET" Value="Public Property QueueName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ QueueName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.QueueName : string with get, set" Usage="System.Messaging.MessageQueue.QueueName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_QueueName")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置标识队列的友好名称。</summary>
        <value>名称，该名称标识由此 <see cref="T:System.Messaging.MessageQueue" /> 引用的队列。 该值不能为 <see langword="null" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 你可以组合<xref:System.Messaging.MessageQueue.QueueName%2A>与<xref:System.Messaging.MessageQueue.MachineName%2A>若要创建一个友好<xref:System.Messaging.MessageQueue.Path%2A>为队列名称。 友好名称变体的语法<xref:System.Messaging.MessageQueue.Path%2A>属性取决于队列的类型，如下表中所示。  
  
|队列类型|语法|  
|----------------|------------|  
|公用队列|`MachineName`\\`QueueName`|  
|专用队列|`MachineName`\\`Private$`\\`QueueName`|  
|日记队列|`MachineName`\\`QueueName`\\`Journal$`|  
  
 使用"。"来表示本地计算机。  
  
 更改<xref:System.Messaging.MessageQueue.QueueName%2A>属性会影响<xref:System.Messaging.MessageQueue.Path%2A>属性。 如果您设置<xref:System.Messaging.MessageQueue.QueueName%2A>而无需设置<xref:System.Messaging.MessageQueue.MachineName%2A>属性，<xref:System.Messaging.MessageQueue.Path%2A>属性将成为。\\`QueueName`. 否则为<xref:System.Messaging.MessageQueue.Path%2A>变得`MachineName` \\ `QueueName`。  
  
 下表显示了此属性是否可在各种工作组模式下。  
  
|工作组模式下|可用|  
|--------------------|---------------|  
|本地计算机|是|  
|本地计算机和直接格式名|是|  
|远程计算机|是|  
|远程计算机并直接格式名|否|  
  
   
  
## Examples  
 下面的代码示例获取和设置的值的消息队列的<xref:System.Messaging.MessageQueue.QueueName%2A>属性。  
  
 [!code-csharp[MessageQueue#24](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#24)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">队列名称为 <see langword="null" />。</exception>
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
        <altmember cref="P:System.Messaging.MessageQueue.MachineName" />
      </Docs>
    </Member>
    <Member MemberName="ReadHandle">
      <MemberSignature Language="C#" Value="public IntPtr ReadHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int ReadHandle" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.ReadHandle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ReadHandle As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr ReadHandle { IntPtr get(); };" />
      <MemberSignature Language="F#" Value="member this.ReadHandle : nativeint" Usage="System.Messaging.MessageQueue.ReadHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_ReadHandle")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取用于从消息队列读取消息的本机句柄。</summary>
        <value>用于查看和接收来自队列的消息的本机队列对象的句柄。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.ReadHandle%2A>提供用于查看和从队列接收消息的消息队列对象的本机 Windows 句柄。 如果更改队列的路径，该句柄关闭，并使用新值重新打开。  
  
 下表显示了此属性是否可在各种工作组模式下。  
  
|工作组模式下|可用|  
|--------------------|---------------|  
|本地计算机|是|  
|本地计算机和直接格式名|是|  
|远程计算机|否|  
|远程计算机并直接格式名|是|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">访问“消息队列”方法时出错。</exception>
        <altmember cref="P:System.Messaging.MessageQueue.CanRead" />
        <altmember cref="P:System.Messaging.MessageQueue.WriteHandle" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Receive">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <threadsafe>该方法不是线程安全。</threadsafe>
        <summary>接收队列中的第一条消息，但不将它从队列中移除。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Receive ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Receive() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Receive" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive () As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Receive();" />
      <MemberSignature Language="F#" Value="member this.Receive : unit -&gt; System.Messaging.Message" Usage="messageQueue.Receive " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>接收 <see cref="T:System.Messaging.MessageQueue" /> 引用的队列中可用的第一条消息。 此调用是同步的，在有可用消息前，它将一直阻止当前线程的执行。</summary>
        <returns>
          <see cref="T:System.Messaging.Message" />，它引用队列中可用的第一条消息。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用此重载以接收来自队列的消息或等待，直到队列中有消息。  
  
 <xref:System.Messaging.MessageQueue.Receive%2A>方法允许同步读取一条消息，因此它从队列中删除。 对后续调用<xref:System.Messaging.MessageQueue.Receive%2A>将返回的消息在队列中，或新的、 更高优先级的消息。  
  
 若要从队列删除读取队列中的第一个消息，使用<xref:System.Messaging.MessageQueue.Peek%2A>方法。 <xref:System.Messaging.MessageQueue.Peek%2A>方法始终返回第一条消息在队列中，因此对方法的后续调用返回相同的消息，除非较高优先级的消息到达队列中。  
  
 使用调用<xref:System.Messaging.MessageQueue.Receive%2A>时等待消息到达队列中时，阻止当前线程。 因为这一重载<xref:System.Messaging.MessageQueue.Receive%2A>方法指定无限期超时，该应用程序可能会无限期等待。 如果应用程序处理应继续而无需等待该消息，请考虑使用异步方法， <xref:System.Messaging.MessageQueue.BeginReceive%2A>。  
  
 下表显示了此方法是在各种工作组模式下可用。  
  
|工作组模式下|可用|  
|--------------------|---------------|  
|本地计算机|是|  
|本地计算机和直接格式名|是|  
|远程计算机|否|  
|远程计算机并直接格式名|是|  
  
   
  
## Examples  
 下面的代码示例从队列接收消息，并输出到屏幕的消息的相关信息。  
  
 [!code-cpp[MessageQueue.Receive_noparms#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Receive_noparms/CPP/mqreceive_noparms.cpp#1)]
 [!code-csharp[MessageQueue.Receive_noparms#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Receive_noparms/CS/mqreceive_noparms.cs#1)]
 [!code-vb[MessageQueue.Receive_noparms#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Receive_noparms/VB/mqreceive_noparms.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">访问“消息队列”方法时出错。</exception>
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Receive (System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Receive(class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Receive(System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive (transaction As MessageQueueTransaction) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Receive(System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberSignature Language="F#" Value="member this.Receive : System.Messaging.MessageQueueTransaction -&gt; System.Messaging.Message" Usage="messageQueue.Receive transaction" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="transaction">
          <see cref="T:System.Messaging.MessageQueueTransaction" /> 对象。</param>
        <summary>接收 <see cref="T:System.Messaging.MessageQueue" /> 引用的事务性队列中可用的第一条消息。 此调用是同步的，在有可用消息前，它将一直阻止当前线程的执行。</summary>
        <returns>
          <see cref="T:System.Messaging.Message" />，它引用队列中可用的第一条消息。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用此重载从事务性队列使用由定义的内部事务上下文中接收的消息`transaction`参数，或者一直等到队列中有消息。  
  
 <xref:System.Messaging.MessageQueue.Receive%2A>方法允许同步读取一条消息，因此它从队列中删除。 对后续调用<xref:System.Messaging.MessageQueue.Receive%2A>将后面的消息返回队列中。  
  
 事务性队列上调用此方法，因为收到的消息将返回到队列如果该事务被中止。 该消息是不永久地从队列中删除在事务提交之前。  
  
 若要从队列删除读取队列中的第一个消息，使用<xref:System.Messaging.MessageQueue.Peek%2A>方法。 <xref:System.Messaging.MessageQueue.Peek%2A>方法始终返回第一条消息在队列中，因此对方法的后续调用返回相同的消息，除非较高优先级的消息到达队列中。 没有与通过调用返回的消息关联事务上下文<xref:System.Messaging.MessageQueue.Peek%2A>。 因为<xref:System.Messaging.MessageQueue.Peek%2A>不会的删除队列中的任何消息，会执行任何操作来回滚通过调用<xref:System.Messaging.MessageQueueTransaction.Abort%2A>。  
  
 使用调用<xref:System.Messaging.MessageQueue.Receive%2A>时等待消息到达队列中时，阻止当前线程。 因为这一重载<xref:System.Messaging.MessageQueue.Receive%2A>方法指定无限期超时，该应用程序可能会无限期等待。 如果应用程序处理应继续而无需等待该消息，请考虑使用异步方法， <xref:System.Messaging.MessageQueue.BeginReceive%2A>。  
  
 下表显示了此方法是在各种工作组模式下可用。  
  
|工作组模式下|可用|  
|--------------------|---------------|  
|本地计算机|是|  
|本地计算机和直接格式名|是|  
|远程计算机|否|  
|远程计算机并直接格式名|是|  
  
   
  
## Examples  
 下面的代码示例连接到本地计算机上的事务性队列，并将消息发送到队列。 它然后接收包含订单的消息。 如果遇到非事务性队列，则会引发异常并回滚该事务。  
  
 [!code-cpp[MessageQueue.Receive_transaction#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Receive_transaction/CPP/mqreceive_transaction.cpp#1)]
 [!code-csharp[MessageQueue.Receive_transaction#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Receive_transaction/CS/mqreceive_transaction.cs#1)]
 [!code-vb[MessageQueue.Receive_transaction#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Receive_transaction/VB/mqreceive_transaction.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">访问“消息队列”方法时出错。  
  
或 
该队列为非事务性队列。</exception>
        <threadsafe>该方法不是线程安全。</threadsafe>
        <altmember cref="T:System.Messaging.MessageQueueTransaction" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Receive (System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Receive(valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Receive(System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive (transactionType As MessageQueueTransactionType) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Receive(System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="F#" Value="member this.Receive : System.Messaging.MessageQueueTransactionType -&gt; System.Messaging.Message" Usage="messageQueue.Receive transactionType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="transactionType">
          <see cref="T:System.Messaging.MessageQueueTransactionType" /> 值之一，它描述与消息关联的事务上下文的类型。</param>
        <summary>接收 <see cref="T:System.Messaging.MessageQueue" /> 引用的队列中可用的第一条消息。 此调用是同步的，在有可用消息前，它将一直阻止当前线程的执行。</summary>
        <returns>
          <see cref="T:System.Messaging.Message" />，它引用队列中可用的第一条消息。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用此重载使用定义的事务上下文从队列接收消息`transactionType`参数，或者一直等到队列中有消息。  
  
 指定`Automatic`为`transactionType`参数如果已经有外部事务上下文附加到你想要使用用于接收消息的线程。 指定`Single`如果想要接收的消息作为单个内部事务。 您可以指定`None`如果你想要接收来自事务上下文外的事务性队列的消息。  
  
 <xref:System.Messaging.MessageQueue.Receive%2A>方法允许同步读取一条消息，因此它从队列中删除。 对后续调用<xref:System.Messaging.MessageQueue.Receive%2A>将后面的消息返回队列中。  
  
 如果调用此方法从事务性队列接收消息，接收到的消息将返回到队列如果该事务被中止。 该消息是不永久地从队列中删除在事务提交之前。  
  
 若要从队列删除读取队列中的第一个消息，使用<xref:System.Messaging.MessageQueue.Peek%2A>方法。 <xref:System.Messaging.MessageQueue.Peek%2A>方法始终返回第一条消息在队列中，因此对方法的后续调用返回相同的消息，除非较高优先级的消息到达队列中。 没有与通过调用返回的消息关联事务上下文<xref:System.Messaging.MessageQueue.Peek%2A>。 因为<xref:System.Messaging.MessageQueue.Peek%2A>不会的删除队列中的任何消息，会执行任何操作来回滚通过调用<xref:System.Messaging.MessageQueueTransaction.Abort%2A>。  
  
 使用调用<xref:System.Messaging.MessageQueue.Receive%2A>时等待消息到达队列中时，阻止当前线程。 因为这一重载<xref:System.Messaging.MessageQueue.Receive%2A>方法指定无限期超时，该应用程序可能会无限期等待。 如果应用程序处理应继续而无需等待该消息，请考虑使用异步方法， <xref:System.Messaging.MessageQueue.BeginReceive%2A>。  
  
 下表显示了此方法是在各种工作组模式下可用。  
  
|工作组模式下|可用|  
|--------------------|---------------|  
|本地计算机|是|  
|本地计算机和直接格式名|是|  
|远程计算机|否|  
|远程计算机并直接格式名|是|  
  
   
  
## Examples  
 以下代码示例演示了 <xref:System.Messaging.MessageQueue.Receive%28System.Messaging.MessageQueueTransactionType%29> 的用法。  
  
 [!code-cpp[MessageQueue2#9](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#9)]
 [!code-csharp[MessageQueue2#9](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">访问“消息队列”方法时出错。</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="transactionType" /> 参数不是 <see cref="T:System.Messaging.MessageQueueTransactionType" /> 成员之一。</exception>
        <threadsafe>该方法不是线程安全。</threadsafe>
        <altmember cref="T:System.Messaging.MessageQueueTransactionType" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Receive (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Receive(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Receive(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive (timeout As TimeSpan) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Receive(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.Receive : TimeSpan -&gt; System.Messaging.Message" Usage="messageQueue.Receive timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">一个 <see cref="T:System.TimeSpan" /> 指示有新消息可用于检查之前等待的时间。</param>
        <summary>接收由 <see cref="T:System.Messaging.MessageQueue" /> 引用的队列中的第一条可用消息，并且一直等到队列中有可用消息或超时过期。</summary>
        <returns>
          <see cref="T:System.Messaging.Message" />，它引用队列中可用的第一条消息。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用此重载接收消息并在队列中没有消息时在指定的时间段内返回。  
  
 <xref:System.Messaging.MessageQueue.Receive%2A>方法允许同步读取一条消息，从队列中删除它。 对后续调用<xref:System.Messaging.MessageQueue.Receive%2A>将返回的消息在队列中，或新的、 更高优先级的消息。  
  
 若要从队列删除读取队列中的第一个消息，使用<xref:System.Messaging.MessageQueue.Peek%2A>方法。 <xref:System.Messaging.MessageQueue.Peek%2A>方法始终返回第一条消息在队列中，因此对方法的后续调用返回相同的消息，除非较高优先级的消息到达队列中。  
  
 使用调用<xref:System.Messaging.MessageQueue.Receive%2A>时等待消息到达队列中时，阻止当前线程。 会阻止该线程在给定期间的时间，或者如果指定了值<xref:System.Messaging.MessageQueue.InfiniteTimeout>为`timeout`参数。 如果应用程序处理应继续而无需等待一条消息，请考虑使用异步方法， <xref:System.Messaging.MessageQueue.BeginReceive%2A>。  
  
 下表显示了此方法是在各种工作组模式下可用。  
  
|工作组模式下|可用|  
|--------------------|---------------|  
|本地计算机|是|  
|本地计算机和直接格式名|是|  
|远程计算机|否|  
|远程计算机并直接格式名|是|  
  
   
  
## Examples  
 下面的代码示例从队列接收消息，并输出到屏幕的消息的相关信息。 该示例暂停等待消息到达队列中时最多为 5 秒的执行。  
  
 [!code-cpp[MessageQueue.Receive_timeout#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Receive_timeout/CPP/mqreceive_timeout.cpp#1)]
 [!code-csharp[MessageQueue.Receive_timeout#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Receive_timeout/CS/mqreceive_timeout.cs#1)]
 [!code-vb[MessageQueue.Receive_timeout#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Receive_timeout/VB/mqreceive_timeout.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">为 <paramref name="timeout" /> 参数指定的值无效，可能是 <paramref name="timeout" /> 小于 <see cref="F:System.TimeSpan.Zero" /> 或大于 <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">在超时过期之前消息没有到达队列。  
  
或 
访问“消息队列”方法时出错。</exception>
        <threadsafe>该方法不是线程安全。</threadsafe>
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Receive (TimeSpan timeout, System.Messaging.Cursor cursor);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Receive(valuetype System.TimeSpan timeout, class System.Messaging.Cursor cursor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.Cursor)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Receive(TimeSpan timeout, System::Messaging::Cursor ^ cursor);" />
      <MemberSignature Language="F#" Value="member this.Receive : TimeSpan * System.Messaging.Cursor -&gt; System.Messaging.Message" Usage="messageQueue.Receive (timeout, cursor)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="cursor" Type="System.Messaging.Cursor" />
      </Parameters>
      <Docs>
        <param name="timeout">一个 <see cref="T:System.TimeSpan" /> 指示有新消息可用于检查之前等待的时间。</param>
        <param name="cursor">维持消息队列中特定位置的 <see cref="T:System.Messaging.Cursor" />。</param>
        <summary>使用指定的游标接收队列中的当前消息。 如果没有可用的消息，此方法将等待，直到有可用的消息或超时到期为止。</summary>
        <returns>
          <see cref="T:System.Messaging.Message" />，它引用队列中可用的第一条消息。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">为 <paramref name="timeout" /> 参数指定的值无效，可能是 <paramref name="timeout" /> 小于 <see cref="F:System.TimeSpan.Zero" /> 或大于 <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">在超时过期之前消息没有到达队列。  
  
或 
访问“消息队列”方法时出错。 
使用此重载接收消息并在队列中没有消息时在指定的时间段内返回。</exception>
        <threadsafe>该方法不是线程安全。</threadsafe>
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Receive (TimeSpan timeout, System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Receive(valuetype System.TimeSpan timeout, class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive (timeout As TimeSpan, transaction As MessageQueueTransaction) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Receive(TimeSpan timeout, System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberSignature Language="F#" Value="member this.Receive : TimeSpan * System.Messaging.MessageQueueTransaction -&gt; System.Messaging.Message" Usage="messageQueue.Receive (timeout, transaction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="timeout">一个 <see cref="T:System.TimeSpan" /> 指示有新消息可用于检查之前等待的时间。</param>
        <param name="transaction">
          <see cref="T:System.Messaging.MessageQueueTransaction" /> 对象。</param>
        <summary>接收由 <see cref="T:System.Messaging.MessageQueue" /> 引用的事务性队列中的第一条可用消息，并且一直等到队列中有可用消息或超时过期。</summary>
        <returns>
          <see cref="T:System.Messaging.Message" />，它引用队列中可用的第一条消息。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用此重载从事务性队列使用由定义的内部事务上下文中接收的消息`transaction`参数，并返回在指定时间段内是否存在任何消息队列中。  
  
 <xref:System.Messaging.MessageQueue.Receive%2A>方法允许同步读取一条消息，因此它从队列中删除。 对后续调用<xref:System.Messaging.MessageQueue.Receive%2A>将后面的消息返回队列中。  
  
 事务性队列上调用此方法，因为收到的消息将返回到队列如果该事务被中止。 该消息是不永久地从队列中删除在事务提交之前。  
  
 若要从队列删除读取队列中的第一个消息，使用<xref:System.Messaging.MessageQueue.Peek%2A>方法。 <xref:System.Messaging.MessageQueue.Peek%2A>方法始终返回第一条消息在队列中，因此对方法的后续调用返回相同的消息，除非较高优先级的消息到达队列中。 没有与通过调用返回的消息关联事务上下文<xref:System.Messaging.MessageQueue.Peek%2A>。 因为<xref:System.Messaging.MessageQueue.Peek%2A>不会的删除队列中的任何消息，会执行任何操作来回滚通过调用<xref:System.Messaging.MessageQueueTransaction.Abort%2A>。  
  
 使用调用<xref:System.Messaging.MessageQueue.Receive%2A>时等待消息到达队列中时，阻止当前线程。 会阻止该线程在给定期间的时间，或者如果指定了值<xref:System.Messaging.MessageQueue.InfiniteTimeout>为`timeout`参数。 如果应用程序处理应继续而无需等待一条消息，请考虑使用异步方法， <xref:System.Messaging.MessageQueue.BeginReceive%2A>。  
  
 下表显示了此方法是在各种工作组模式下可用。  
  
|工作组模式下|可用|  
|--------------------|---------------|  
|本地计算机|是|  
|本地计算机和直接格式名|是|  
|远程计算机|否|  
|远程计算机并直接格式名|是|  
  
   
  
## Examples  
 下面的代码示例演示如何使用此方法。  
  
 [!code-cpp[MessageQueue.Receive_TimeoutTransaction#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Receive_TimeoutTransaction/CPP/mqreceive_timeouttransaction.cpp#1)]
 [!code-csharp[MessageQueue.Receive_TimeoutTransaction#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Receive_TimeoutTransaction/CS/mqreceive_timeouttransaction.cs#1)]
 [!code-vb[MessageQueue.Receive_TimeoutTransaction#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Receive_TimeoutTransaction/VB/mqreceive_timeouttransaction.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">为 <paramref name="timeout" /> 参数指定的值无效，可能是 <paramref name="timeout" /> 小于 <see cref="F:System.TimeSpan.Zero" /> 或大于 <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">在超时过期之前消息没有到达队列。  
  
或 
该队列为非事务性队列。  
  
或 
访问“消息队列”方法时出错。</exception>
        <threadsafe>该方法不是线程安全。</threadsafe>
        <altmember cref="T:System.Messaging.MessageQueueTransaction" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Receive (TimeSpan timeout, System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Receive(valuetype System.TimeSpan timeout, valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive (timeout As TimeSpan, transactionType As MessageQueueTransactionType) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Receive(TimeSpan timeout, System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="F#" Value="member this.Receive : TimeSpan * System.Messaging.MessageQueueTransactionType -&gt; System.Messaging.Message" Usage="messageQueue.Receive (timeout, transactionType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="timeout">一个 <see cref="T:System.TimeSpan" /> 指示有新消息可用于检查之前等待的时间。</param>
        <param name="transactionType">
          <see cref="T:System.Messaging.MessageQueueTransactionType" /> 值之一，它描述与消息关联的事务上下文的类型。</param>
        <summary>接收 <see cref="T:System.Messaging.MessageQueue" /> 引用的队列中可用的第一条消息。 此调用是同步的，并且一直等到队列中有可用的消息或超时到期。</summary>
        <returns>
          <see cref="T:System.Messaging.Message" />，它引用队列中可用的第一条消息。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用此重载使用定义的事务上下文从队列接收消息`transactionType`参数，并返回在指定时间段内是否存在任何消息队列中。  
  
 指定`Automatic`为`transactionType`参数如果已经有外部事务上下文附加到你想要使用用于接收消息的线程。 指定`Single`如果想要接收的消息作为单个内部事务。 您可以指定`None`如果你想要接收来自事务上下文外的事务性队列的消息。  
  
 <xref:System.Messaging.MessageQueue.Receive%2A>方法允许同步读取一条消息，因此它从队列中删除。 对后续调用<xref:System.Messaging.MessageQueue.Receive%2A>将后面的消息返回队列中。  
  
 如果调用此方法从事务性队列接收消息，接收到的消息将返回到队列如果该事务被中止。 该消息是不永久地从队列中删除在事务提交之前。  
  
 若要从队列删除读取队列中的第一个消息，使用<xref:System.Messaging.MessageQueue.Peek%2A>方法。 <xref:System.Messaging.MessageQueue.Peek%2A>方法始终返回第一条消息在队列中，因此对方法的后续调用返回相同的消息，除非较高优先级的消息到达队列中。 没有与通过调用返回的消息关联事务上下文<xref:System.Messaging.MessageQueue.Peek%2A>。 因为<xref:System.Messaging.MessageQueue.Peek%2A>不会的删除队列中的任何消息，会执行任何操作来回滚通过调用<xref:System.Messaging.MessageQueueTransaction.Abort%2A>。  
  
 使用调用<xref:System.Messaging.MessageQueue.Receive%2A>时等待消息到达队列中时，阻止当前线程。 会阻止该线程在给定期间的时间，或者如果指定了值<xref:System.Messaging.MessageQueue.InfiniteTimeout>为`timeout`参数。 如果应用程序处理应继续而无需等待一条消息，请考虑使用异步方法， <xref:System.Messaging.MessageQueue.BeginReceive%2A>。  
  
 下表显示了此方法是在各种工作组模式下可用。  
  
|工作组模式下|可用|  
|--------------------|---------------|  
|本地计算机|是|  
|本地计算机和直接格式名|是|  
|远程计算机|否|  
|远程计算机并直接格式名|是|  
  
   
  
## Examples  
 下面的代码示例演示如何使用此方法。  
  
 [!code-cpp[MessageQueue2#8](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#8)]
 [!code-csharp[MessageQueue2#8](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">为 <paramref name="timeout" /> 参数指定的值无效，可能是 <paramref name="timeout" /> 小于 <see cref="F:System.TimeSpan.Zero" /> 或大于 <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />。</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="transactionType" /> 参数不是 <see cref="T:System.Messaging.MessageQueueTransactionType" /> 成员之一。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">在超时过期之前消息没有到达队列。  
  
或 
访问“消息队列”方法时出错。</exception>
        <threadsafe>该方法不是线程安全。</threadsafe>
        <altmember cref="T:System.Messaging.MessageQueueTransactionType" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Receive (TimeSpan timeout, System.Messaging.Cursor cursor, System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Receive(valuetype System.TimeSpan timeout, class System.Messaging.Cursor cursor, class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.Cursor,System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Receive(TimeSpan timeout, System::Messaging::Cursor ^ cursor, System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberSignature Language="F#" Value="member this.Receive : TimeSpan * System.Messaging.Cursor * System.Messaging.MessageQueueTransaction -&gt; System.Messaging.Message" Usage="messageQueue.Receive (timeout, cursor, transaction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="cursor" Type="System.Messaging.Cursor" />
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="timeout">一个 <see cref="T:System.TimeSpan" /> 指示有新消息可用于检查之前等待的时间。</param>
        <param name="cursor">维持消息队列中特定位置的 <see cref="T:System.Messaging.Cursor" />。</param>
        <param name="transaction">
          <see cref="T:System.Messaging.MessageQueueTransaction" /> 对象。</param>
        <summary>使用指定的游标接收队列中的当前消息。 如果没有可用的消息，此方法将等待，直到有可用的消息或超时到期为止。</summary>
        <returns>一个 <see cref="T:System.Messaging.Message" />，它引用队列中的一条消息。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用此重载从事务性队列使用由定义的内部事务上下文中接收的消息`transaction`参数，并返回在指定时间段内是否存在任何消息队列中。  
  
 <xref:System.Messaging.MessageQueue.Receive%2A>方法允许同步读取一条消息，因此它从队列中删除。 对后续调用<xref:System.Messaging.MessageQueue.Receive%2A>后面的消息返回队列中。  
  
 事务性队列上调用此方法，因为收到的消息被返回到队列，如果该事务被中止。 该消息是不永久地从队列中删除在事务提交之前。  
  
 若要读取队列中的消息从队列删除，使用<xref:System.Messaging.MessageQueue.Peek%2A>方法。 没有与通过调用返回的消息关联事务上下文<xref:System.Messaging.MessageQueue.Peek%2A>。 因为<xref:System.Messaging.MessageQueue.Peek%2A>不会的删除任何消息队列中，没有要回滚通过调用<xref:System.Messaging.MessageQueueTransaction.Abort%2A>。  
  
 使用调用<xref:System.Messaging.MessageQueue.Receive%2A>时等待消息到达队列中时，阻止当前线程。 为给定期间的时间，或无限期地阻止线程如果指定了值<xref:System.Messaging.MessageQueue.InfiniteTimeout>为`timeout`参数。 如果应用程序处理应继续而无需等待一条消息，请考虑使用异步方法， <xref:System.Messaging.MessageQueue.BeginReceive%2A>。  
  
 下表显示了此方法是在各种工作组模式下可用。  
  
|工作组模式下|可用|  
|--------------------|---------------|  
|本地计算机|是|  
|本地计算机和直接格式名|是|  
|远程计算机|否|  
|远程计算机并直接格式名|是|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="cursor" /> 参数为 <see langword="null" />。  
  
或 
<paramref name="transaction" /> 参数为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">为 <paramref name="timeout" /> 参数指定的值无效。 <paramref name="timeout" /> 可能小于 <see cref="F:System.TimeSpan.Zero" /> 或大于 <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">在超时过期之前消息没有到达队列。  
  
或 
该队列为非事务性队列。  
  
或 
访问“消息队列”方法时出错。</exception>
        <threadsafe>该方法不是线程安全。</threadsafe>
        <altmember cref="T:System.Messaging.Cursor" />
        <altmember cref="T:System.Messaging.MessageQueueTransaction" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Receive (TimeSpan timeout, System.Messaging.Cursor cursor, System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Receive(valuetype System.TimeSpan timeout, class System.Messaging.Cursor cursor, valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.Cursor,System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Receive(TimeSpan timeout, System::Messaging::Cursor ^ cursor, System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="F#" Value="member this.Receive : TimeSpan * System.Messaging.Cursor * System.Messaging.MessageQueueTransactionType -&gt; System.Messaging.Message" Usage="messageQueue.Receive (timeout, cursor, transactionType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="cursor" Type="System.Messaging.Cursor" />
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="timeout">一个 <see cref="T:System.TimeSpan" /> 指示有新消息可用于检查之前等待的时间。</param>
        <param name="cursor">维持消息队列中特定位置的 <see cref="T:System.Messaging.Cursor" />。</param>
        <param name="transactionType">
          <see cref="T:System.Messaging.MessageQueueTransactionType" /> 值之一，它描述与消息关联的事务上下文类型。</param>
        <summary>使用指定的游标接收队列中的当前消息。 如果没有可用的消息，此方法将等待，直到有可用的消息或超时到期为止。</summary>
        <returns>一个 <see cref="T:System.Messaging.Message" />，它引用队列中的一条消息。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用此重载使用定义的事务上下文从队列接收消息`transactionType`参数，并返回在指定时间段内是否存在任何消息队列中。  
  
 指定`Automatic`为`transactionType`参数如果已经有外部事务上下文附加到你想要使用用于接收消息的线程。 指定`Single`如果想要接收的消息作为单个内部事务。 您可以指定`None`如果你想要接收来自事务上下文外的事务性队列的消息。  
  
 <xref:System.Messaging.MessageQueue.Receive%2A>方法允许同步读取一条消息，因此它从队列中删除。 对后续调用<xref:System.Messaging.MessageQueue.Receive%2A>后面的消息返回队列中。  
  
 如果调用此方法从事务性队列接收消息，接收到的消息被返回到队列，如果该事务被中止。 该消息是不永久地从队列中删除在事务提交之前。  
  
 若要读取队列中的消息从队列删除，使用<xref:System.Messaging.MessageQueue.Peek%2A>方法。 没有与通过调用返回的消息关联事务上下文<xref:System.Messaging.MessageQueue.Peek%2A>。 因为<xref:System.Messaging.MessageQueue.Peek%2A>不会的删除任何消息队列中，没有要回滚通过调用<xref:System.Messaging.MessageQueueTransaction.Abort%2A>。  
  
 使用调用<xref:System.Messaging.MessageQueue.Receive%2A>时等待消息到达队列中时，阻止当前线程。 为给定期间的时间，或无限期地阻止线程如果指定了值<xref:System.Messaging.MessageQueue.InfiniteTimeout>为`timeout`参数。 如果应用程序处理应继续而无需等待一条消息，请考虑使用异步方法， <xref:System.Messaging.MessageQueue.BeginReceive%2A>。  
  
 下表显示了此方法是在各种工作组模式下可用。  
  
|工作组模式下|可用|  
|--------------------|---------------|  
|本地计算机|是|  
|本地计算机和直接格式名|是|  
|远程计算机|否|  
|远程计算机并直接格式名|是|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="cursor" /> 参数为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">为 <paramref name="timeout" /> 参数指定的值无效。 <paramref name="timeout" /> 可能小于 <see cref="F:System.TimeSpan.Zero" /> 或大于 <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />。</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="transactionType" /> 参数不是 <see cref="T:System.Messaging.MessageQueueTransactionType" /> 成员之一。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">在超时过期之前消息没有到达队列。  
  
或 
访问“消息队列”方法时出错。</exception>
        <threadsafe>该方法不是线程安全。</threadsafe>
        <altmember cref="T:System.Messaging.Cursor" />
        <altmember cref="T:System.Messaging.MessageQueueTransactionType" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ReceiveByCorrelationId">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>接收匹配给定相关标识符的消息。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReceiveByCorrelationId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveByCorrelationId (string correlationId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveByCorrelationId(string correlationId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveByCorrelationId (correlationId As String) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveByCorrelationId(System::String ^ correlationId);" />
      <MemberSignature Language="F#" Value="member this.ReceiveByCorrelationId : string -&gt; System.Messaging.Message" Usage="messageQueue.ReceiveByCorrelationId correlationId" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="correlationId" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="correlationId">要接收的消息的 <see cref="P:System.Messaging.Message.CorrelationId" />。</param>
        <summary>从非事务性队列中接收与给定的相关标识符匹配的消息，而且在队列中当前不存在具有指定相关标识符的消息时立即引发异常。</summary>
        <returns>其 <see cref="T:System.Messaging.Message" /> 匹配传入的 <paramref name="correlationId" /> 参数的 <see cref="P:System.Messaging.Message.CorrelationId" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法中引用的非事务性队列中查找<xref:System.Messaging.MessageQueue>消息其<xref:System.Messaging.Message.CorrelationId%2A>匹配指定`correlationId`参数。 如果未找到消息相匹配`correlationID`参数，将引发异常。 否则为该消息是从队列中移除并返回到应用程序。  
  
 <xref:System.Messaging.Message.CorrelationId%2A>属性用于将绑定到队列相关联的响应、 报表或确认消息发送到发送的消息。  
  
 其他两种方法，可从队列接收消息。 <xref:System.Messaging.MessageQueue.Receive%2A>方法在队列中，将返回第一条消息和<xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29>方法中检索消息时通过指定它的唯一标识符。  
  
 若要读取具有指定的相关标识符的消息从队列删除，使用<xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29>方法。 <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29>方法始终返回第一条消息在队列中，因此对方法的后续调用返回相同的消息，除非较高优先级的消息到达队列中。  
  
 下表显示了此方法是在各种工作组模式下可用。  
  
|工作组模式下|可用|  
|--------------------|---------------|  
|本地计算机|是|  
|本地计算机和直接格式名|是|  
|远程计算机|否|  
|远程计算机并直接格式名|是|  
  
   
  
## Examples  
 下面的代码示例发送和接收包含订单到和从队列的消息。 它专门请求肯定确认当原始消息到达或已从队列中检索。  
  
 [!code-cpp[Message.Acknowledgment#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.Acknowledgment/CPP/message_acknowledgment.cpp#1)]
 [!code-csharp[Message.Acknowledgment#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.Acknowledgment/CS/message_acknowledgment.cs#1)]
 [!code-vb[Message.Acknowledgment#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.Acknowledgment/VB/message_acknowledgment.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="correlationId" /> 参数为 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">未能找到具有指定 <paramref name="correlationId" /> 的消息。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">访问“消息队列”方法时出错。</exception>
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveByCorrelationId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveByCorrelationId (string correlationId, System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveByCorrelationId(string correlationId, class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveByCorrelationId (correlationId As String, transaction As MessageQueueTransaction) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveByCorrelationId(System::String ^ correlationId, System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberSignature Language="F#" Value="member this.ReceiveByCorrelationId : string * System.Messaging.MessageQueueTransaction -&gt; System.Messaging.Message" Usage="messageQueue.ReceiveByCorrelationId (correlationId, transaction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="correlationId" Type="System.String" />
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="correlationId">要接收的消息的 <see cref="P:System.Messaging.Message.CorrelationId" />。</param>
        <param name="transaction">
          <see cref="T:System.Messaging.MessageQueueTransaction" /> 对象。</param>
        <summary>从事务性队列中接收与给定的相关标识符匹配的消息，而且在队列中当前不存在具有指定相关标识符的消息时立即引发异常。</summary>
        <returns>其 <see cref="T:System.Messaging.Message" /> 匹配传入的 <paramref name="correlationId" /> 参数的 <see cref="P:System.Messaging.Message.CorrelationId" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法中引用的事务性队列中查找<xref:System.Messaging.MessageQueue>消息其<xref:System.Messaging.Message.CorrelationId%2A>匹配指定`correlationId`参数。 如果未找到消息相匹配`correlationID`参数，将引发异常。 否则为将消息从队列中移除并返回应用程序使用由定义的内部事务上下文`transaction`参数。  
  
 事务性队列上调用此方法，因为收到的消息将返回到队列如果该事务被中止。 该消息是不永久地从队列中删除在事务提交之前。  
  
 <xref:System.Messaging.Message.CorrelationId%2A>属性用于将绑定到队列相关联的响应、 报表或确认消息发送到发送的消息。  
  
 其他两种方法，可从队列接收消息。 <xref:System.Messaging.MessageQueue.Receive%2A>方法在队列中，将返回第一条消息和<xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29>方法用于检索一条消息，通过指定它的唯一标识符。  
  
 若要读取具有指定的相关标识符的消息从队列删除，使用<xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29>方法。 <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29>方法始终返回第一条消息在队列中，因此对方法的后续调用返回相同的消息，除非较高优先级的消息到达队列中。 没有与通过调用返回的消息关联事务上下文<xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29>。 因为<xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29>不会的删除队列中的任何消息，这将会执行任何操作来回滚该事务已中止。  
  
 下表显示了此方法是在各种工作组模式下可用。  
  
|工作组模式下|可用|  
|--------------------|---------------|  
|本地计算机|是|  
|本地计算机和直接格式名|是|  
|远程计算机|否|  
|远程计算机并直接格式名|是|  
  
   
  
## Examples  
 以下代码示例演示了 <xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%2CSystem.Messaging.MessageQueueTransaction%29> 的用法。  
  
 [!code-cpp[MessageQueue2#14](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#14)]
 [!code-csharp[MessageQueue2#14](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#14)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="correlationId" /> 参数为 <see langword="null" />。  
  
或 
<paramref name="transaction" /> 参数为 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">未能找到具有指定 <paramref name="correlationId" /> 的消息。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">该队列为非事务性队列。  
  
或 
访问“消息队列”方法时出错。</exception>
        <altmember cref="T:System.Messaging.MessageQueueTransaction" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveByCorrelationId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveByCorrelationId (string correlationId, System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveByCorrelationId(string correlationId, valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveByCorrelationId (correlationId As String, transactionType As MessageQueueTransactionType) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveByCorrelationId(System::String ^ correlationId, System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="F#" Value="member this.ReceiveByCorrelationId : string * System.Messaging.MessageQueueTransactionType -&gt; System.Messaging.Message" Usage="messageQueue.ReceiveByCorrelationId (correlationId, transactionType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="correlationId" Type="System.String" />
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="correlationId">要接收的消息的 <see cref="P:System.Messaging.Message.CorrelationId" />。</param>
        <param name="transactionType">
          <see cref="T:System.Messaging.MessageQueueTransactionType" /> 值之一，它描述与消息关联的事务上下文的类型。</param>
        <summary>接收匹配给定相关标识符的消息，而且在队列中当前不存在具有指定相关标识符的消息时立即引发异常。</summary>
        <returns>其 <see cref="T:System.Messaging.Message" /> 匹配传入的 <paramref name="correlationId" /> 参数的 <see cref="P:System.Messaging.Message.CorrelationId" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法中引用的队列中查找<xref:System.Messaging.MessageQueue>消息其<xref:System.Messaging.Message.CorrelationId%2A>匹配指定`correlationId`参数。 如果未找到消息相匹配`correlationID`参数，将引发异常。 否则为将消息从队列中移除并返回应用程序使用通过定义的事务上下文`transactionType`参数。  
  
 指定`Automatic`为`transactionType`参数如果已经有外部事务上下文附加到你想要使用用于接收消息的线程。 指定`Single`如果想要接收的消息作为单个内部事务。 您可以指定`None`如果你想要接收来自事务上下文外的事务性队列的消息。  
  
 如果调用此方法从事务性队列接收消息，接收到的消息将返回到队列如果该事务被中止。 该消息是不永久地从队列中删除在事务提交之前。  
  
 <xref:System.Messaging.Message.CorrelationId%2A>属性用于将绑定到队列相关联的响应、 报表或确认消息发送到发送的消息。  
  
 其他两种方法，可从队列接收消息。 <xref:System.Messaging.MessageQueue.Receive%2A>方法在队列中，将返回第一条消息和<xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29>方法用于检索一条消息，通过指定它的唯一标识符。  
  
 若要读取具有指定的相关标识符的消息从队列删除，使用<xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29>方法。 <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29>方法始终返回第一条消息在队列中，因此对方法的后续调用返回相同的消息，除非较高优先级的消息到达队列中。 没有与通过调用返回的消息关联事务上下文<xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29>。 因为<xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29>不会的删除队列中的任何消息，这将会执行任何操作来回滚该事务已中止。  
  
 下表显示了此方法是在各种工作组模式下可用。  
  
|工作组模式下|可用|  
|--------------------|---------------|  
|本地计算机|是|  
|本地计算机和直接格式名|是|  
|远程计算机|否|  
|远程计算机并直接格式名|是|  
  
   
  
## Examples  
 以下代码示例演示了 <xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%2CSystem.Messaging.MessageQueueTransactionType%29> 的用法。  
  
 [!code-cpp[MessageQueue2#11](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#11)]
 [!code-csharp[MessageQueue2#11](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="correlationId" /> 参数为 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">未能找到具有指定 <paramref name="correlationId" /> 的消息。</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="transactionType" /> 参数不是 <see cref="T:System.Messaging.MessageQueueTransactionType" /> 成员之一。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">访问“消息队列”方法时出错。</exception>
        <altmember cref="T:System.Messaging.MessageQueueTransactionType" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveByCorrelationId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveByCorrelationId (string correlationId, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveByCorrelationId(string correlationId, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveByCorrelationId (correlationId As String, timeout As TimeSpan) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveByCorrelationId(System::String ^ correlationId, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.ReceiveByCorrelationId : string * TimeSpan -&gt; System.Messaging.Message" Usage="messageQueue.ReceiveByCorrelationId (correlationId, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="correlationId" Type="System.String" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="correlationId">要接收的消息的 <see cref="P:System.Messaging.Message.CorrelationId" />。</param>
        <param name="timeout">一个 <see cref="T:System.TimeSpan" /> 指示有新消息可用于检查之前等待的时间。</param>
        <summary>从非事务性队列中接收与给定的相关标识符匹配的消息，并且一直等到队列中出现具有指定相关标识符的消息或者超时过期。</summary>
        <returns>其 <see cref="T:System.Messaging.Message" /> 匹配传入的 <paramref name="correlationId" /> 参数的 <see cref="P:System.Messaging.Message.CorrelationId" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法中引用的非事务性队列中查找<xref:System.Messaging.MessageQueue>消息其<xref:System.Messaging.Message.CorrelationId%2A>匹配指定`correlationId`参数。 此方法将立即返回指定相关标识符的消息如果`correlationId`参数是在队列中。 否则，该方法将等待给定的新消息到达的时间段。 如果新消息没有到达之前超时时间已到，将引发异常。  
  
 `timeout`参数未指定的总运行时间为此方法。 相反，它指定为新消息到达队列中等待的时间。 每次有新消息到达时，此方法将检查<xref:System.Messaging.Message.CorrelationId%2A>的新消息，以查看其是否符合`correlationId`参数。 如果没有，此方法通过启动的超时期限，等待另一个新消息到达。 因此，如果新消息继续到达在超时期内，就可以为此方法以继续无限期运行直到超时期限到期且无需任何新消息到达，或者直到有消息到达其<xref:System.Messaging.Message.CorrelationId%2A>匹配`correlationId`参数。  
  
 <xref:System.Messaging.Message.CorrelationId%2A>属性用于将绑定到队列相关联的响应、 报表或确认消息发送到发送的消息。  
  
 其他两种方法，可从队列接收消息。 <xref:System.Messaging.MessageQueue.Receive%2A>方法在队列中，将返回第一条消息和<xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29>方法用于检索一条消息，通过指定它的唯一标识符。  
  
 若要读取具有指定的相关标识符的消息从队列删除，使用<xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29>方法。 <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29>方法始终返回第一条消息在队列中，因此对方法的后续调用返回相同的消息，除非较高优先级的消息到达队列中。  
  
 下表显示了此方法是在各种工作组模式下可用。  
  
|工作组模式下|可用|  
|--------------------|---------------|  
|本地计算机|是|  
|本地计算机和直接格式名|是|  
|远程计算机|否|  
|远程计算机并直接格式名|是|  
  
   
  
## Examples  
 以下代码示例演示了 <xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%2CSystem.TimeSpan%29> 的用法。  
  
 [!code-cpp[MessageQueue2#10](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#10)]
 [!code-csharp[MessageQueue2#10](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="correlationId" /> 参数为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">为 <paramref name="timeout" /> 参数指定的值无效，可能是 <paramref name="timeout" /> 小于 <see cref="F:System.TimeSpan.Zero" /> 或大于 <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">具有指定 <paramref name="correlationId" /> 的消息不在队列中，而且在超时过期之前没有到达。  
  
或 
访问“消息队列”方法时出错。</exception>
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveByCorrelationId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveByCorrelationId (string correlationId, TimeSpan timeout, System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveByCorrelationId(string correlationId, valuetype System.TimeSpan timeout, class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.TimeSpan,System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveByCorrelationId (correlationId As String, timeout As TimeSpan, transaction As MessageQueueTransaction) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveByCorrelationId(System::String ^ correlationId, TimeSpan timeout, System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberSignature Language="F#" Value="member this.ReceiveByCorrelationId : string * TimeSpan * System.Messaging.MessageQueueTransaction -&gt; System.Messaging.Message" Usage="messageQueue.ReceiveByCorrelationId (correlationId, timeout, transaction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="correlationId" Type="System.String" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="correlationId">要接收的消息的 <see cref="P:System.Messaging.Message.CorrelationId" />。</param>
        <param name="timeout">一个 <see cref="T:System.TimeSpan" /> 指示有新消息可用于检查之前等待的时间。</param>
        <param name="transaction">
          <see cref="T:System.Messaging.MessageQueueTransaction" /> 对象。</param>
        <summary>从事务性队列中接收与给定的相关标识符匹配的消息，并且一直等到队列中出现具有指定相关标识符的消息或者超时过期。</summary>
        <returns>其 <see cref="T:System.Messaging.Message" /> 匹配传入的 <paramref name="correlationId" /> 参数的 <see cref="P:System.Messaging.Message.CorrelationId" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法中引用的事务性队列中查找<xref:System.Messaging.MessageQueue>消息其<xref:System.Messaging.Message.CorrelationId%2A>匹配指定`correlationId`参数。 此方法将立即返回指定相关标识符的消息如果`correlationId`参数是在队列中，使用由定义的内部事务上下文`transaction`参数。 否则，该方法将等待给定的新消息到达的时间段。 如果新消息没有到达之前超时时间已到，将引发异常。  
  
 `timeout`参数未指定的总运行时间为此方法。 相反，它指定为新消息到达队列中等待的时间。 每次有新消息到达时，此方法将检查<xref:System.Messaging.Message.CorrelationId%2A>的新消息，以查看其是否符合`correlationId`参数。 如果没有，此方法通过启动的超时期限，等待另一个新消息到达。 因此，如果新消息继续到达在超时期内，就可以为此方法以继续无限期运行直到超时期限到期且无需任何新消息到达，或者直到有消息到达其<xref:System.Messaging.Message.CorrelationId%2A>匹配`correlationId`参数。  
  
 事务性队列上调用此方法，因为收到的消息将返回到队列如果该事务被中止。 该消息是不永久地从队列中删除在事务提交之前。  
  
 <xref:System.Messaging.Message.CorrelationId%2A>属性用于将绑定到队列相关联的响应、 报表或确认消息发送到发送的消息。  
  
 其他两种方法，可从队列接收消息。 <xref:System.Messaging.MessageQueue.Receive%2A>方法在队列中，将返回第一条消息和<xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29>方法用于检索一条消息，通过指定它的唯一标识符。  
  
 若要读取具有指定的相关标识符的消息从队列删除，使用<xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29>方法。 <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29>方法始终返回第一条消息在队列中，因此对方法的后续调用返回相同的消息，除非较高优先级的消息到达队列中。 没有与通过调用返回的消息关联事务上下文<xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29>。 因为<xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29>不会的删除队列中的任何消息，这将会执行任何操作来回滚该事务已中止。  
  
 下表显示了此方法是在各种工作组模式下可用。  
  
|工作组模式下|可用|  
|--------------------|---------------|  
|本地计算机|是|  
|本地计算机和直接格式名|是|  
|远程计算机|否|  
|远程计算机并直接格式名|是|  
  
   
  
## Examples  
 以下代码示例演示了 <xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%2CSystem.TimeSpan%2CSystem.Messaging.MessageQueueTransaction%29> 的用法。  
  
 [!code-cpp[MessageQueue2#13](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#13)]
 [!code-csharp[MessageQueue2#13](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="correlationId" /> 参数为 <see langword="null" />。  
  
或 
<paramref name="transaction" /> 参数为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">为 <paramref name="timeout" /> 参数指定的值无效，可能是 <paramref name="timeout" /> 小于 <see cref="F:System.TimeSpan.Zero" /> 或大于 <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">具有指定 <paramref name="correlationId" /> 的消息不在队列中，而且在超时过期之前没有到达。  
  
或 
该队列为非事务性队列。  
  
或 
访问“消息队列”方法时出错。</exception>
        <altmember cref="T:System.Messaging.MessageQueueTransaction" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveByCorrelationId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveByCorrelationId (string correlationId, TimeSpan timeout, System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveByCorrelationId(string correlationId, valuetype System.TimeSpan timeout, valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.TimeSpan,System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveByCorrelationId (correlationId As String, timeout As TimeSpan, transactionType As MessageQueueTransactionType) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveByCorrelationId(System::String ^ correlationId, TimeSpan timeout, System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="F#" Value="member this.ReceiveByCorrelationId : string * TimeSpan * System.Messaging.MessageQueueTransactionType -&gt; System.Messaging.Message" Usage="messageQueue.ReceiveByCorrelationId (correlationId, timeout, transactionType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="correlationId" Type="System.String" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="correlationId">要接收的消息的 <see cref="P:System.Messaging.Message.CorrelationId" />。</param>
        <param name="timeout">一个 <see cref="T:System.TimeSpan" /> 指示有新消息可用于检查之前等待的时间。</param>
        <param name="transactionType">
          <see cref="T:System.Messaging.MessageQueueTransactionType" /> 值之一，它描述与消息关联的事务上下文的类型。</param>
        <summary>接收与给定的相关标识符匹配的消息，并且一直等到队列中出现具有指定相关标识符的消息或超时过期。</summary>
        <returns>其 <see cref="T:System.Messaging.Message" /> 匹配传入的 <paramref name="correlationId" /> 参数的 <see cref="P:System.Messaging.Message.CorrelationId" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法中引用的队列中查找<xref:System.Messaging.MessageQueue>消息其<xref:System.Messaging.Message.CorrelationId%2A>匹配指定`correlationId`参数。 此方法将立即返回指定相关标识符的消息如果`correlationId`参数是在队列中，使用定义的事务上下文`transactionType`参数。 否则，该方法将等待给定的新消息到达的时间段。 如果新消息没有到达之前超时时间已到，将引发异常。  
  
 `timeout`参数未指定的总运行时间为此方法。 相反，它指定为新消息到达队列中等待的时间。 每次有新消息到达时，此方法将检查<xref:System.Messaging.Message.CorrelationId%2A>的新消息，以查看其是否符合`correlationId`参数。 如果没有，此方法通过启动的超时期限，等待另一个新消息到达。 因此，如果新消息继续到达在超时期内，就可以为此方法以继续无限期运行直到超时期限到期且无需任何新消息到达，或者直到有消息到达其<xref:System.Messaging.Message.CorrelationId%2A>匹配`correlationId`参数。 指定`Automatic`为`transactionType`参数如果已经有外部事务上下文附加到你想要使用用于接收消息的线程。 指定`Single`如果想要接收的消息作为单个内部事务。 您可以指定`None`如果你想要接收来自事务上下文外的事务性队列的消息。  
  
 如果调用此方法从事务性队列接收消息，接收到的消息将返回到队列如果该事务被中止。 该消息是不永久地从队列中删除在事务提交之前。  
  
 <xref:System.Messaging.Message.CorrelationId%2A>属性用于将绑定到队列相关联的响应、 报表或确认消息发送到发送的消息。  
  
 其他两种方法，可从队列接收消息。 <xref:System.Messaging.MessageQueue.Receive%2A>方法在队列中，将返回第一条消息和<xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29>方法用于检索一条消息，通过指定它的唯一标识符。  
  
 若要读取具有指定的相关标识符的消息从队列删除，使用<xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29>方法。 <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29>方法始终返回第一条消息在队列中，因此对方法的后续调用返回相同的消息，除非较高优先级的消息到达队列中。 没有与通过调用返回的消息关联事务上下文<xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29>。 因为<xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29>不会的删除队列中的任何消息，这将会执行任何操作来回滚该事务已中止。  
  
 下表显示了此方法是在各种工作组模式下可用。  
  
|工作组模式下|可用|  
|--------------------|---------------|  
|本地计算机|是|  
|本地计算机和直接格式名|是|  
|远程计算机|否|  
|远程计算机并直接格式名|是|  
  
   
  
## Examples  
 以下代码示例演示了 <xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%2CSystem.TimeSpan%2CSystem.Messaging.MessageQueueTransactionType%29> 的用法。  
  
 [!code-cpp[MessageQueue2#12](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#12)]
 [!code-csharp[MessageQueue2#12](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="correlationId" /> 参数为 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">未能找到具有指定 <paramref name="correlationId" /> 的消息。</exception>
        <exception cref="T:System.ArgumentException">为 <paramref name="timeout" /> 参数指定的值无效，可能是 <paramref name="timeout" /> 小于 <see cref="F:System.TimeSpan.Zero" /> 或大于 <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />。</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="transactionType" /> 参数不是 <see cref="T:System.Messaging.MessageQueueTransactionType" /> 成员之一。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">具有指定 <paramref name="correlationId" /> 的消息不在队列中，而且在超时过期之前没有到达。  
  
或 
访问“消息队列”方法时出错。</exception>
        <altmember cref="T:System.Messaging.MessageQueueTransactionType" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ReceiveById">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>接收匹配给定标识符的消息，并将其从队列中移除。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReceiveById">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveById (string id);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveById(string id) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveById(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveById (id As String) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveById(System::String ^ id);" />
      <MemberSignature Language="F#" Value="member this.ReceiveById : string -&gt; System.Messaging.Message" Usage="messageQueue.ReceiveById id" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="id">要接收的消息的 <see cref="P:System.Messaging.Message.Id" />。</param>
        <summary>从非事务性队列中接收与给定的标识符匹配的消息，而且在队列中当前不存在具有指定标识符的消息时立即引发异常。</summary>
        <returns>
          <see cref="T:System.Messaging.Message" />，其 <see cref="P:System.Messaging.Message.Id" /> 属性匹配传入的 <paramref name="id" /> 参数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法用于读取具有已知标识符的消息和从队列中删除它。 如果消息不是在队列中，此方法将立即引发异常。  
  
 <xref:System.Messaging.Message.Id%2A>消息的属性是整个消息队列企业内、 唯一的因此将有最多一条消息中的队列的匹配给定`id`参数。  
  
 其他两种方法，可从队列接收消息。 <xref:System.Messaging.MessageQueue.Receive%2A>方法在队列中，将返回第一条消息和<xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%29>方法用于检索确认、 报表或已创建第一条消息发送到队列的应用程序生成的响应消息。  
  
 若要读取具有指定标识符的消息从队列删除，使用<xref:System.Messaging.MessageQueue.PeekById%28System.String%29>方法。 <xref:System.Messaging.MessageQueue.PeekById%28System.String%29>方法始终返回第一条消息在队列中，因此对方法的后续调用返回相同的消息，除非较高优先级的消息到达队列中。  
  
 下表显示了此方法是在各种工作组模式下可用。  
  
|工作组模式下|可用|  
|--------------------|---------------|  
|本地计算机|是|  
|本地计算机和直接格式名|是|  
|远程计算机|否|  
|远程计算机并直接格式名|是|  
  
   
  
## Examples  
 以下代码示例演示了 <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29> 的用法。  
  
 [!code-cpp[MessageQueue2#16](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#16)]
 [!code-csharp[MessageQueue2#16](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#16)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="id" /> 参数为 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">未能找到具有指定 <paramref name="id" /> 的消息。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">访问“消息队列”方法时出错。</exception>
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveById">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveById (string id, System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveById(string id, class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveById (id As String, transaction As MessageQueueTransaction) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveById(System::String ^ id, System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberSignature Language="F#" Value="member this.ReceiveById : string * System.Messaging.MessageQueueTransaction -&gt; System.Messaging.Message" Usage="messageQueue.ReceiveById (id, transaction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="id">要接收的消息的 <see cref="P:System.Messaging.Message.Id" />。</param>
        <param name="transaction">
          <see cref="T:System.Messaging.MessageQueueTransaction" /> 对象。</param>
        <summary>从事务性队列中接收与给定的标识符匹配的消息，而且在队列中当前不存在具有指定标识符的消息时立即引发异常。</summary>
        <returns>
          <see cref="T:System.Messaging.Message" />，其 <see cref="P:System.Messaging.Message.Id" /> 属性匹配传入的 <paramref name="id" /> 参数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法用于读取具有已知标识符的消息并将其从队列中，使用由定义的内部事务上下文删除`transaction`参数。 此方法将引发异常立即如果消息不是在队列中  
  
 <xref:System.Messaging.Message.Id%2A>消息的属性是整个消息队列企业内、 唯一的因此将有最多一条消息中的队列的匹配给定`id`参数。  
  
 事务性队列上调用此方法，因为收到的消息将返回到队列如果该事务被中止。 该消息是不永久地从队列中删除在事务提交之前。  
  
 其他两种方法，可从队列接收消息。 <xref:System.Messaging.MessageQueue.Receive%2A>方法在队列中，将返回第一条消息和<xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%29>方法用于检索确认、 报表或已创建第一条消息发送到队列的应用程序生成的响应消息。  
  
 若要读取具有指定标识符的消息从队列删除，使用<xref:System.Messaging.MessageQueue.PeekById%28System.String%29>方法。 <xref:System.Messaging.MessageQueue.PeekById%28System.String%29>方法始终返回第一条消息在队列中，因此对方法的后续调用返回相同的消息，除非较高优先级的消息到达队列中。 没有与通过调用返回的消息关联事务上下文<xref:System.Messaging.MessageQueue.PeekById%28System.String%29>。 因为<xref:System.Messaging.MessageQueue.PeekById%28System.String%29>不会的删除队列中的任何消息，这将会执行任何操作来回滚该事务已中止。  
  
 下表显示了此方法是在各种工作组模式下可用。  
  
|工作组模式下|可用|  
|--------------------|---------------|  
|本地计算机|是|  
|本地计算机和直接格式名|是|  
|远程计算机|否|  
|远程计算机并直接格式名|是|  
  
   
  
## Examples  
 以下代码示例演示了 <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%2CSystem.Messaging.MessageQueueTransaction%29> 的用法。  
  
 [!code-cpp[MessageQueue2#17](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#17)]
 [!code-csharp[MessageQueue2#17](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#17)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="id" /> 参数为 <see langword="null" />。  
  
或 
<paramref name="transaction" /> 参数为 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">未能找到具有指定 <paramref name="id" /> 的消息。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">该队列为非事务性队列。  
  
或 
访问“消息队列”方法时出错。</exception>
        <altmember cref="T:System.Messaging.MessageQueueTransaction" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveById">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveById (string id, System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveById(string id, valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveById (id As String, transactionType As MessageQueueTransactionType) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveById(System::String ^ id, System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="F#" Value="member this.ReceiveById : string * System.Messaging.MessageQueueTransactionType -&gt; System.Messaging.Message" Usage="messageQueue.ReceiveById (id, transactionType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="id">要接收的消息的 <see cref="P:System.Messaging.Message.Id" />。</param>
        <param name="transactionType">
          <see cref="T:System.Messaging.MessageQueueTransactionType" /> 值之一，它描述与消息关联的事务上下文的类型。</param>
        <summary>接收与给定的标识符匹配的消息，而且在队列中当前不存在具有指定标识符的消息时立即引发异常。</summary>
        <returns>
          <see cref="T:System.Messaging.Message" />，其 <see cref="P:System.Messaging.Message.Id" /> 属性匹配传入的 <paramref name="id" /> 参数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法用于读取具有已知标识符的消息和从队列中删除它。 如果消息不是在队列中，此方法将立即引发异常。 否则为将消息从队列中移除并返回应用程序使用通过定义的事务上下文`transactionType`参数。  
  
 指定`Automatic`为`transactionType`参数如果已经有外部事务上下文附加到你想要使用用于接收消息的线程。 指定`Single`如果想要接收的消息作为单个内部事务。 您可以指定`None`如果你想要接收来自事务上下文外的事务性队列的消息。  
  
 <xref:System.Messaging.Message.Id%2A>消息的属性是整个消息队列企业内、 唯一的因此将有最多一条消息中的队列的匹配给定`id`参数。 如果具有指定标识符的消息队列不是与此关联中<xref:System.Messaging.MessageQueue>实例，该消息将不会找到。  
  
 如果调用此方法从事务性队列接收消息，接收到的消息将返回到队列如果该事务被中止。 该消息是不永久地从队列中删除在事务提交之前。  
  
 其他两种方法，可从队列接收消息。 <xref:System.Messaging.MessageQueue.Receive%2A>方法在队列中，将返回第一条消息和<xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%29>方法用于检索确认、 报表或已创建第一条消息发送到队列的应用程序生成的响应消息。  
  
 若要读取具有指定标识符的消息从队列删除，使用<xref:System.Messaging.MessageQueue.PeekById%28System.String%29>方法。 <xref:System.Messaging.MessageQueue.PeekById%28System.String%29>方法始终返回第一条消息在队列中，因此对方法的后续调用返回相同的消息，除非较高优先级的消息到达队列中。 没有与通过调用返回的消息关联事务上下文<xref:System.Messaging.MessageQueue.PeekById%28System.String%29>。 因为<xref:System.Messaging.MessageQueue.PeekById%28System.String%29>不会的删除队列中的任何消息，这将会执行任何操作来回滚该事务已中止。  
  
 下表显示了此方法是在各种工作组模式下可用。  
  
|工作组模式下|可用|  
|--------------------|---------------|  
|本地计算机|是|  
|本地计算机和直接格式名|是|  
|远程计算机|否|  
|远程计算机并直接格式名|是|  
  
   
  
## Examples  
 以下代码示例演示了 <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%2CSystem.Messaging.MessageQueueTransactionType%29> 的用法。  
  
 [!code-cpp[MessageQueue2#15](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#15)]
 [!code-csharp[MessageQueue2#15](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#15)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="id" /> 参数为 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">未能找到具有指定 <paramref name="id" /> 的消息。</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="transactionType" /> 参数不是 <see cref="T:System.Messaging.MessageQueueTransactionType" /> 成员之一。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">访问“消息队列”方法时出错。</exception>
        <altmember cref="T:System.Messaging.MessageQueueTransactionType" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveById">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveById (string id, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveById(string id, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveById (id As String, timeout As TimeSpan) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveById(System::String ^ id, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.ReceiveById : string * TimeSpan -&gt; System.Messaging.Message" Usage="messageQueue.ReceiveById (id, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="id">要接收的消息的 <see cref="P:System.Messaging.Message.Id" />。</param>
        <param name="timeout">一个 <see cref="T:System.TimeSpan" /> 指示有新消息可用于检查之前等待的时间。</param>
        <summary>从非事务性队列接收与给定的标识符匹配的消息，并且一直等到队列中出现具有指定标识符的消息或超时过期。</summary>
        <returns>
          <see cref="T:System.Messaging.Message" />，其 <see cref="P:System.Messaging.Message.Id" /> 属性匹配传入的 <paramref name="id" /> 参数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法用于读取具有已知标识符的消息和从队列中删除它。 此方法将立即返回指定标识符的消息如果`id`参数是在队列中。 否则，该方法将等待给定的新消息到达的时间段。 如果新消息没有到达之前超时时间已到，将引发异常。  
  
 `timeout`参数未指定的总运行时间为此方法。 相反，它指定为新消息到达队列中等待的时间。 每次有新消息到达时，此方法将检查<xref:System.Messaging.Message.Id%2A>的新消息，以查看其是否符合`id`参数。 如果没有，此方法通过启动的超时期限，等待另一个新消息到达。 因此，如果新消息继续到达在超时期内，就可以为此方法以继续无限期运行直到超时期限到期且无需任何新消息到达，或者直到有消息到达其<xref:System.Messaging.Message.Id%2A>匹配`id`参数。  
  
 <xref:System.Messaging.Message.Id%2A>消息的属性是整个消息队列企业内、 唯一的因此将有最多一条消息中的队列的匹配给定`id`参数。  
  
 请使用此重载<xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29>时，只要新消息继续到达队列所指定的超时时间内阻止当前线程`timeout`参数。 线程会被阻止的至少在给定期间的时间，或者如果指定了值<xref:System.Messaging.MessageQueue.InfiniteTimeout>有关`timeout`参数，或如果新消息继续到达队列所指定的超时时间内`timeout`参数。  
  
 其他两种方法，可从队列接收消息。 <xref:System.Messaging.MessageQueue.Receive%2A>方法在队列中，将返回第一条消息和<xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%29>方法用于检索确认、 报表或已创建第一条消息发送到队列的应用程序生成的响应消息。  
  
 若要读取具有指定标识符的消息从队列删除，使用<xref:System.Messaging.MessageQueue.PeekById%28System.String%29>方法。 <xref:System.Messaging.MessageQueue.PeekById%28System.String%29>方法始终返回第一条消息在队列中，因此对方法的后续调用返回相同的消息，除非较高优先级的消息到达队列中。  
  
 下表显示了此方法是在各种工作组模式下可用。  
  
|工作组模式下|可用|  
|--------------------|---------------|  
|本地计算机|是|  
|本地计算机和直接格式名|是|  
|远程计算机|否|  
|远程计算机并直接格式名|是|  
  
   
  
## Examples  
 以下代码示例演示了 <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%2CSystem.TimeSpan%29> 的用法。  
  
 [!code-cpp[MessageQueue2#20](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#20)]
 [!code-csharp[MessageQueue2#20](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#20)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="id" /> 参数为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">为 <paramref name="timeout" /> 参数指定的值无效，可能是 <paramref name="timeout" /> 小于 <see cref="F:System.TimeSpan.Zero" /> 或大于 <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">在时间超时之前，带有指定 <paramref name="id" /> 的消息没有到达队列。  
  
或 
访问“消息队列”方法时出错。</exception>
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveById">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveById (string id, TimeSpan timeout, System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveById(string id, valuetype System.TimeSpan timeout, class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.TimeSpan,System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveById (id As String, timeout As TimeSpan, transaction As MessageQueueTransaction) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveById(System::String ^ id, TimeSpan timeout, System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberSignature Language="F#" Value="member this.ReceiveById : string * TimeSpan * System.Messaging.MessageQueueTransaction -&gt; System.Messaging.Message" Usage="messageQueue.ReceiveById (id, timeout, transaction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="id">要接收的消息的 <see cref="P:System.Messaging.Message.Id" />。</param>
        <param name="timeout">一个 <see cref="T:System.TimeSpan" /> 指示有新消息可用于检查之前等待的时间。</param>
        <param name="transaction">
          <see cref="T:System.Messaging.MessageQueueTransaction" /> 对象。</param>
        <summary>从事务性队列接收与给定的标识符匹配的消息，并且一直等到队列中出现具有指定标识符的消息或超时过期。</summary>
        <returns>
          <see cref="T:System.Messaging.Message" />，其 <see cref="P:System.Messaging.Message.Id" /> 属性匹配传入的 <paramref name="id" /> 参数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法用于读取具有已知标识符的消息并将其从队列中，使用由定义的内部事务上下文删除`transaction`参数。 此方法将立即返回指定标识符的消息如果`id`参数是在队列中。 否则，该方法将等待给定的新消息到达的时间段。 如果新消息没有到达之前超时时间已到，将引发异常。  
  
 `timeout`参数未指定的总运行时间为此方法。 相反，它指定为新消息到达队列中等待的时间。 每次有新消息到达时，此方法将检查<xref:System.Messaging.Message.Id%2A>的新消息，以查看其是否符合`id`参数。 如果没有，此方法通过启动的超时期限，等待另一个新消息到达。 因此，如果新消息继续到达在超时期内，就可以为此方法以继续无限期运行直到超时期限到期且无需任何新消息到达，或者直到有消息到达其<xref:System.Messaging.Message.Id%2A>匹配`id`参数。  
  
 <xref:System.Messaging.Message.Id%2A>消息的属性是整个消息队列企业内、 唯一的因此将有最多一条消息中的队列的匹配给定`id`参数。  
  
 请使用此重载<xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29>时，只要新消息继续到达队列所指定的超时时间内阻止当前线程`timeout`参数。 线程会被阻止的至少在给定期间的时间，或者如果指定了值<xref:System.Messaging.MessageQueue.InfiniteTimeout>有关`timeout`参数，或如果新消息继续到达队列中指定的超时期限内`timeout`参数。  
  
 事务性队列上调用此方法，因为收到的消息将返回到队列如果该事务被中止。 该消息是不永久地从队列中删除在事务提交之前。  
  
 其他两种方法，可从队列接收消息。 <xref:System.Messaging.MessageQueue.Receive%2A>方法在队列中，将返回第一条消息和<xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%29>方法用于检索确认、 报表或已创建第一条消息发送到队列的应用程序生成的响应消息。  
  
 若要读取具有指定标识符的消息从队列删除，使用<xref:System.Messaging.MessageQueue.PeekById%28System.String%29>方法。 <xref:System.Messaging.MessageQueue.PeekById%28System.String%29>方法始终返回第一条消息在队列中，因此，对方法的后续调用返回相同的消息，除非较高优先级的消息到达队列中。 没有与通过调用返回的消息关联事务上下文<xref:System.Messaging.MessageQueue.PeekById%28System.String%29>。 因为<xref:System.Messaging.MessageQueue.PeekById%28System.String%29>不会的删除队列中的任何消息，这将会执行任何操作来回滚该事务已中止。  
  
 下表显示了此方法是在各种工作组模式下可用。  
  
|工作组模式下|可用|  
|--------------------|---------------|  
|本地计算机|是|  
|本地计算机和直接格式名|是|  
|远程计算机|否|  
|远程计算机并直接格式名|是|  
  
   
  
## Examples  
 以下代码示例演示了 <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%2CSystem.TimeSpan%2CSystem.Messaging.MessageQueueTransaction%29> 的用法。  
  
 [!code-cpp[MessageQueue2#18](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#18)]
 [!code-csharp[MessageQueue2#18](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#18)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="id" /> 参数为 <see langword="null" />。  
  
或 
<paramref name="transaction" /> 参数为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">为 <paramref name="timeout" /> 参数指定的值无效，可能是 <paramref name="timeout" /> 小于 <see cref="F:System.TimeSpan.Zero" /> 或大于 <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">在时间超时之前，带有指定 <paramref name="id" /> 的消息没有到达队列。  
  
或 
该队列为非事务性队列。  
  
或 
访问“消息队列”方法时出错。</exception>
        <altmember cref="T:System.Messaging.MessageQueueTransaction" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveById">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveById (string id, TimeSpan timeout, System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveById(string id, valuetype System.TimeSpan timeout, valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.TimeSpan,System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveById (id As String, timeout As TimeSpan, transactionType As MessageQueueTransactionType) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveById(System::String ^ id, TimeSpan timeout, System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="F#" Value="member this.ReceiveById : string * TimeSpan * System.Messaging.MessageQueueTransactionType -&gt; System.Messaging.Message" Usage="messageQueue.ReceiveById (id, timeout, transactionType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="id">要接收的消息的 <see cref="P:System.Messaging.Message.Id" />。</param>
        <param name="timeout">一个 <see cref="T:System.TimeSpan" /> 指示有新消息可用于检查之前等待的时间。</param>
        <param name="transactionType">
          <see cref="T:System.Messaging.MessageQueueTransactionType" /> 值之一，它描述与消息关联的事务上下文的类型。</param>
        <summary>接收与给定的标识符匹配的消息，并且一直等到队列中出现具有指定标识符的消息或超时过期。</summary>
        <returns>
          <see cref="T:System.Messaging.Message" />，其 <see cref="P:System.Messaging.Message.Id" /> 属性匹配传入的 <paramref name="id" /> 参数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法用于读取具有已知标识符的消息和从队列中删除它。 此方法将立即返回如果由指定的消息的标识符`id`参数是在队列中，使用定义的事务上下文`transactionType`参数。 否则，该方法将等待给定的新消息到达的时间段。 如果新消息没有到达之前超时时间已到，将引发异常。  
  
 `timeout`参数未指定的总运行时间为此方法。 相反，它指定为新消息到达队列中等待的时间。 每次有新消息到达时，此方法将检查<xref:System.Messaging.Message.Id%2A>的新消息，以查看其是否符合`id`参数。 如果没有，此方法通过启动的超时期限，等待另一个新消息到达。 因此，如果新消息继续到达在超时期内，就可以为此方法以继续无限期运行直到超时期限到期且无需任何新消息到达，或者直到有消息到达其<xref:System.Messaging.Message.Id%2A>匹配`id`参数。  
  
 指定`Automatic`为`transactionType`参数如果已经有外部事务上下文附加到你想要使用用于接收消息的线程。 指定`Single`如果想要接收的消息作为单个内部事务。 您可以指定`None`如果你想要接收来自事务上下文外的事务性队列的消息。  
  
 <xref:System.Messaging.Message.Id%2A>消息的属性是整个消息队列企业内、 唯一的因此将有最多一条消息中的队列的匹配给定`id`参数。 如果具有指定标识符的消息队列不是与此关联中<xref:System.Messaging.MessageQueue>实例，该消息将不会找到。  
  
 请使用此重载<xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29>时，只要新消息继续到达队列所指定的超时时间内阻止当前线程`timeout`参数。 线程会被阻止的至少在给定期间的时间，或者如果指定了值<xref:System.Messaging.MessageQueue.InfiniteTimeout>有关`timeout`参数，或如果新消息继续到达队列所指定的超时时间内`timeout`参数。  
  
 如果调用此方法从事务性队列接收消息，接收到的消息将返回到队列如果该事务被中止。 该消息是不永久地从队列中删除在事务提交之前。  
  
 其他两种方法，可从队列接收消息。 <xref:System.Messaging.MessageQueue.Receive%2A>方法在队列中，将返回第一条消息和<xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%29>方法用于检索确认、 报表或已创建第一条消息发送到队列的应用程序生成的响应消息。  
  
 若要读取具有指定标识符的消息从队列删除，使用<xref:System.Messaging.MessageQueue.PeekById%28System.String%29>方法。 <xref:System.Messaging.MessageQueue.PeekById%28System.String%29>方法始终返回第一条消息在队列中，因此对方法的后续调用返回相同的消息，除非较高优先级的消息到达队列中。 没有与通过调用返回的消息关联事务上下文<xref:System.Messaging.MessageQueue.PeekById%28System.String%29>。 因为<xref:System.Messaging.MessageQueue.PeekById%28System.String%29>不会的删除队列中的任何消息，这将会执行任何操作来回滚该事务已中止。  
  
 下表显示了此方法是在各种工作组模式下可用。  
  
|工作组模式下|可用|  
|--------------------|---------------|  
|本地计算机|是|  
|本地计算机和直接格式名|是|  
|远程计算机|否|  
|远程计算机并直接格式名|是|  
  
   
  
## Examples  
 以下代码示例演示了 <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%2CSystem.TimeSpan%2CSystem.Messaging.MessageQueueTransactionType%29> 的用法。  
  
 [!code-cpp[MessageQueue2#19](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#19)]
 [!code-csharp[MessageQueue2#19](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#19)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="id" /> 参数为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">为 <paramref name="timeout" /> 参数指定的值无效，可能是 <paramref name="timeout" /> 小于 <see cref="F:System.TimeSpan.Zero" /> 或大于 <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">在时间超时之前，带有指定 <paramref name="id" /> 的消息没有到达队列。  
  
或 
访问“消息队列”方法时出错。</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="transactionType" /> 参数不是 <see cref="T:System.Messaging.MessageQueueTransactionType" /> 成员之一。</exception>
        <altmember cref="T:System.Messaging.MessageQueueTransactionType" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ReceiveByLookupId">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>在 MSMQ 3.0 中引入。 接收队列中特定的消息。 消息可通过查询标识符来指定，也可以通过其相对于队首或队尾的位置来指定。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReceiveByLookupId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveByLookupId (long lookupId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveByLookupId(int64 lookupId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveByLookupId(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveByLookupId (lookupId As Long) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveByLookupId(long lookupId);" />
      <MemberSignature Language="F#" Value="member this.ReceiveByLookupId : int64 -&gt; System.Messaging.Message" Usage="messageQueue.ReceiveByLookupId lookupId" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="lookupId" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="lookupId">要接收的消息的 <see cref="P:System.Messaging.Message.LookupId" />。</param>
        <summary>在 MSMQ 3.0 中引入。 从非事务性队列中接收与给定的查找标识符匹配的消息。</summary>
        <returns>
          <see cref="T:System.Messaging.Message" />，其 <see cref="P:System.Messaging.Message.LookupId" /> 属性匹配传入的 <paramref name="lookupId" /> 参数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法用于读取具有已知的查找标识符的消息和从队列中删除它。 如果消息不是在队列中，此方法将立即引发异常。  
  
 <xref:System.Messaging.Message.LookupId%2A>消息的属性是唯一的队列消息所在的位置，因此将存在最多一条消息中的队列的匹配给定`lookupId`参数。  
  
 若要读取具有指定的查找标识符的消息从队列删除，使用<xref:System.Messaging.MessageQueue.PeekByLookupId%2A>方法。  
  
 下表显示了此方法是在各种工作组模式下可用。  
  
|工作组模式下|可用|  
|--------------------|---------------|  
|本地计算机|是|  
|本地计算机和直接格式名|是|  
|远程计算机|否|  
|远程计算机并直接格式名|是|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">未安装 MSMQ 3.0。</exception>
        <exception cref="T:System.InvalidOperationException">未能找到具有指定 <paramref name="lookupId" /> 的消息。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">访问“消息队列”方法时出错。</exception>
        <altmember cref="P:System.Messaging.Message.LookupId" />
        <altmember cref="M:System.Messaging.MessageQueue.PeekByLookupId" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveByLookupId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveByLookupId (System.Messaging.MessageLookupAction action, long lookupId, System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveByLookupId(valuetype System.Messaging.MessageLookupAction action, int64 lookupId, class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveByLookupId(System.Messaging.MessageLookupAction,System.Int64,System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveByLookupId (action As MessageLookupAction, lookupId As Long, transaction As MessageQueueTransaction) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveByLookupId(System::Messaging::MessageLookupAction action, long lookupId, System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberSignature Language="F#" Value="member this.ReceiveByLookupId : System.Messaging.MessageLookupAction * int64 * System.Messaging.MessageQueueTransaction -&gt; System.Messaging.Message" Usage="messageQueue.ReceiveByLookupId (action, lookupId, transaction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="action" Type="System.Messaging.MessageLookupAction" />
        <Parameter Name="lookupId" Type="System.Int64" />
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="action">一个 <see cref="T:System.Messaging.MessageLookupAction" /> 值，指定读取队列中消息的方式。 指定以下值之一： 
 <see langword="MessageLookupAction.Current" />：接收由 <c>lookupId</c> 指定的消息，然后将其从队列中移除。  
  
 <see langword="MessageLookupAction.Next" />：接收由 <c>lookupId</c> 指定消息的下一条消息，然后将其从队列中移除。  
  
 <see langword="MessageLookupAction.Previous" />：接收由 <c>lookupId</c> 指定消息的上一条消息，然后将其从队列中移除。  
  
 <see langword="MessageLookupAction.First" />：接收队列中的第一条消息并将它从队列中移除。 <c>lookupId</c> 参数必须设置为 0。  
  
 <see langword="MessageLookupAction.Last" />：接收队列中的最后一条消息并将它从队列中移除。 <c>lookupId</c> 参数必须设置为 0。</param>
        <param name="lookupId">要接收的消息的 <see cref="P:System.Messaging.Message.LookupId" />，或者为 0。 访问队列中的第一条和最后一条消息时使用 0。</param>
        <param name="transaction">
          <see cref="T:System.Messaging.MessageQueueTransaction" /> 对象。</param>
        <summary>在 MSMQ 3.0 中引入。 从事务性队列中接收特定的消息。 消息可通过查询标识符来指定，也可以通过其相对于队首或队尾的位置来指定。</summary>
        <returns>由传入的 <paramref name="lookupId" /> 和 <paramref name="action" /> 参数指定的 <see cref="T:System.Messaging.Message" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法用于读取具有已知的查找标识符的消息并将其从队列中，使用定义的事务上下文删除`transaction`参数。 如果消息不是在队列中，此方法将立即引发异常。  
  
 <xref:System.Messaging.Message.LookupId%2A>消息的属性是唯一的队列消息所在的位置，因此将存在最多一条消息中的队列的匹配给定`lookupId`参数。  
  
 事务性队列上调用此方法，因为收到的消息将返回到队列如果该事务被中止。 该消息是不永久地从队列中删除在事务提交之前。  
  
 若要读取具有指定标识符的消息从队列删除，使用<xref:System.Messaging.MessageQueue.PeekByLookupId%2A>方法。 没有与通过调用返回的消息关联事务上下文<xref:System.Messaging.MessageQueue.PeekByLookupId%2A>。 因为<xref:System.Messaging.MessageQueue.PeekByLookupId%2A>不会的删除任何消息从队列中，会执行任何操作来回滚该事务已中止。  
  
 下表显示了此方法是在各种工作组模式下可用。  
  
|工作组模式下|可用|  
|--------------------|---------------|  
|本地计算机|是|  
|本地计算机和直接格式名|是|  
|远程计算机|否|  
|远程计算机并直接格式名|是|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">未安装 MSMQ 3.0。</exception>
        <exception cref="T:System.InvalidOperationException">未能找到具有指定 <paramref name="lookupId" /> 的消息。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">访问“消息队列”方法时出错。  
  
或 
该队列为非事务性队列。</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="action" /> 参数不是 <see cref="T:System.Messaging.MessageLookupAction" /> 成员之一。</exception>
        <altmember cref="P:System.Messaging.Message.LookupId" />
        <altmember cref="M:System.Messaging.MessageQueue.PeekByLookupId" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveByLookupId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveByLookupId (System.Messaging.MessageLookupAction action, long lookupId, System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveByLookupId(valuetype System.Messaging.MessageLookupAction action, int64 lookupId, valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveByLookupId(System.Messaging.MessageLookupAction,System.Int64,System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveByLookupId (action As MessageLookupAction, lookupId As Long, transactionType As MessageQueueTransactionType) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveByLookupId(System::Messaging::MessageLookupAction action, long lookupId, System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="F#" Value="member this.ReceiveByLookupId : System.Messaging.MessageLookupAction * int64 * System.Messaging.MessageQueueTransactionType -&gt; System.Messaging.Message" Usage="messageQueue.ReceiveByLookupId (action, lookupId, transactionType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="action" Type="System.Messaging.MessageLookupAction" />
        <Parameter Name="lookupId" Type="System.Int64" />
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="action">一个 <see cref="T:System.Messaging.MessageLookupAction" /> 值，指定读取队列中消息的方式。 指定以下值之一： 
 <see langword="MessageLookupAction.Current" />：接收由 <c>lookupId</c> 指定的消息，然后将其从队列中移除。  
  
 <see langword="MessageLookupAction.Next" />：接收由 <c>lookupId</c> 指定消息的下一条消息，然后将其从队列中移除。  
  
 <see langword="MessageLookupAction.Previous" />：接收由 <c>lookupId</c> 指定消息的上一条消息，然后将其从队列中移除。  
  
 <see langword="MessageLookupAction.First" />：接收队列中的第一条消息并将它从队列中移除。 <c>lookupId</c> 参数必须设置为 0。  
  
 <see langword="MessageLookupAction.Last" />：接收队列中的最后一条消息并将它从队列中移除。 <c>lookupId</c> 参数必须设置为 0。</param>
        <param name="lookupId">要接收的消息的 <see cref="P:System.Messaging.Message.LookupId" />，或者为 0。 访问队列中的第一条和最后一条消息时使用 0。</param>
        <param name="transactionType">
          <see cref="T:System.Messaging.MessageQueueTransactionType" /> 值之一，它描述与消息关联的事务上下文的类型。</param>
        <summary>在 MSMQ 3.0 中引入。 使用指定的事务上下文从队列中接收特定的消息。 消息可通过查询标识符来指定，也可以通过其相对于队首或队尾的位置来指定。</summary>
        <returns>由传入的 <paramref name="action" /> 和 <paramref name="lookupId" /> 参数指定的 <see cref="T:System.Messaging.Message" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法用于读取具有已知的查找标识符的消息并将其从队列中，使用定义的事务上下文删除`transactionType`参数。 如果消息不是在队列中，此方法将立即引发异常。  
  
 <xref:System.Messaging.Message.LookupId%2A>消息的属性是唯一的队列消息所在的位置，因此将存在最多一条消息中的队列的匹配给定`lookupId`参数。  
  
 若要读取具有指定标识符的消息从队列删除，使用<xref:System.Messaging.MessageQueue.PeekByLookupId%2A>方法。 没有与通过调用返回的消息关联事务上下文<xref:System.Messaging.MessageQueue.PeekByLookupId%2A>。 因为<xref:System.Messaging.MessageQueue.PeekByLookupId%2A>不会的删除任何消息从队列中，会执行任何操作来回滚该事务已中止。  
  
 指定`Automatic`为`transactionType`参数如果已经有外部事务上下文附加到你想要使用用于接收消息的线程。 指定`Single`如果想要接收的消息作为单个内部事务。 您可以指定`None`如果你想要接收来自事务上下文外的事务性队列的消息。  
  
 如果调用此方法从事务性队列接收消息，接收到的消息将返回到队列如果该事务被中止。 该消息是不永久地从队列中删除在事务提交之前。  
  
 下表显示了此方法是在各种工作组模式下可用。  
  
|工作组模式下|可用|  
|--------------------|---------------|  
|本地计算机|是|  
|本地计算机和直接格式名|是|  
|远程计算机|否|  
|远程计算机并直接格式名|是|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">未安装 MSMQ 3.0。</exception>
        <exception cref="T:System.InvalidOperationException">未能找到具有指定 <paramref name="lookupId" /> 的消息。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">访问“消息队列”方法时出错。</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="action" /> 参数不是 <see cref="T:System.Messaging.MessageLookupAction" /> 成员之一。  
  
或 
<paramref name="transactionType" /> 参数不是 <see cref="T:System.Messaging.MessageQueueTransactionType" /> 成员之一。</exception>
        <altmember cref="P:System.Messaging.Message.LookupId" />
        <altmember cref="M:System.Messaging.MessageQueue.PeekByLookupId" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveCompleted">
      <MemberSignature Language="C#" Value="public event System.Messaging.ReceiveCompletedEventHandler ReceiveCompleted;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Messaging.ReceiveCompletedEventHandler ReceiveCompleted" />
      <MemberSignature Language="DocId" Value="E:System.Messaging.MessageQueue.ReceiveCompleted" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ReceiveCompleted As ReceiveCompletedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Messaging::ReceiveCompletedEventHandler ^ ReceiveCompleted;" />
      <MemberSignature Language="F#" Value="member this.ReceiveCompleted : System.Messaging.ReceiveCompletedEventHandler " Usage="member this.ReceiveCompleted : System.Messaging.ReceiveCompletedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_ReceiveCompleted")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.ReceiveCompletedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在从队列移除某条消息后发生。 此事件由异步操作 <see cref="M:System.Messaging.MessageQueue.BeginReceive" /> 引发。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.BeginReceive%2A> 在异步处理过程中用来发出<xref:System.Messaging.MessageQueue.ReceiveCompleted>事件队列中出现一条消息时。  
  
 <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> 用于完成通过调用启动的操作<xref:System.Messaging.MessageQueue.BeginReceive%2A>和扫视消息时<xref:System.Messaging.MessageQueue.ReceiveCompleted>引发事件。  
  
 创建 <xref:System.Messaging.ReceiveCompletedEventHandler> 委托时，需要标识将处理该事件的方法。 若要将事件与事件处理程序关联，请将该委托的一个实例添加到事件中。 除非移除了该委托，否则每当发生该事件时就会调用事件处理程序。 有关事件处理程序委托的详细信息，请参阅[处理和引发事件](~/docs/standard/events/index.md)。  
  
   
  
## Examples  
 下面的代码示例创建名为一个事件处理程序`MyReceiveCompleted`，将其附加到<xref:System.Messaging.MessageQueue.ReceiveCompleted>事件处理程序委托，然后调用<xref:System.Messaging.MessageQueue.BeginReceive%2A>启动的异步接收操作上的队列的路径处"。 \myQueue"。 当<xref:System.Messaging.MessageQueue.ReceiveCompleted>引发事件，该示例中接收的消息并将其正文写入到屏幕。 该示例然后调用<xref:System.Messaging.MessageQueue.BeginReceive%2A>再次以启动一个新异步接收操作。  
  
 [!code-cpp[MessageQueue.ReceiveCompleted#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.ReceiveCompleted/CPP/mqreceivecompletedeventhandler.cpp#1)]
 [!code-csharp[MessageQueue.ReceiveCompleted#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.ReceiveCompleted/CS/mqreceivecompletedeventhandler.cs#1)]
 [!code-vb[MessageQueue.ReceiveCompleted#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.ReceiveCompleted/VB/mqreceivecompletedeventhandler.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
        <altmember cref="E:System.Messaging.MessageQueue.PeekCompleted" />
        <altmember cref="T:System.TimeSpan" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="T:System.IAsyncResult" />
      </Docs>
    </Member>
    <Member MemberName="Refresh">
      <MemberSignature Language="C#" Value="public void Refresh ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Refresh() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Refresh" />
      <MemberSignature Language="VB.NET" Value="Public Sub Refresh ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Refresh();" />
      <MemberSignature Language="F#" Value="member this.Refresh : unit -&gt; unit" Usage="messageQueue.Refresh " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>刷新 <see cref="T:System.Messaging.MessageQueue" /> 所显示的属性以反映资源的当前状态。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.Refresh%2A> 同步的属性<xref:System.Messaging.MessageQueue>与其关联的消息队列服务器资源。 如果任何属性，如<xref:System.Messaging.MessageQueue.Label%2A>或<xref:System.Messaging.MessageQueue.Category%2A>，以来已更改的服务器上<xref:System.Messaging.MessageQueue>已创建，请<xref:System.Messaging.MessageQueue.Refresh%2A>更新<xref:System.Messaging.MessageQueue>使用新的信息。  
  
 下表显示了此方法是在各种工作组模式下可用。  
  
|工作组模式下|可用|  
|--------------------|---------------|  
|本地计算机|是|  
|本地计算机和直接格式名|是|  
|远程计算机|否|  
|远程计算机并直接格式名|是|  
  
   
  
## Examples  
 以下代码示例演示了 <xref:System.Messaging.MessageQueue.Refresh%2A> 的用法。  
  
 [!code-cpp[MessageQueue2#28](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#28)]
 [!code-csharp[MessageQueue2#28](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#28)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.GetPublicQueues" />
      </Docs>
    </Member>
    <Member MemberName="ResetPermissions">
      <MemberSignature Language="C#" Value="public void ResetPermissions ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ResetPermissions() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ResetPermissions" />
      <MemberSignature Language="VB.NET" Value="Public Sub ResetPermissions ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ResetPermissions();" />
      <MemberSignature Language="F#" Value="member this.ResetPermissions : unit -&gt; unit" Usage="messageQueue.ResetPermissions " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>将权限列表重置为操作系统的默认值。 移除已追加到默认列表中的所有队列权限。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当您调用<xref:System.Messaging.MessageQueue.ResetPermissions%2A>，为其默认值返回的权限列表。 通常情况下，这授予队列创建者的所有权限，并授予组每个用户以下权限：  
  
-   获取队列的属性。  
  
-   获取队列的权限。  
  
-   写入队列。  
  
 下表显示了此方法是在各种工作组模式下可用。  
  
|工作组模式下|可用|  
|--------------------|---------------|  
|本地计算机|是|  
|本地计算机和直接格式名|是|  
|远程计算机|否|  
|远程计算机并直接格式名|否|  
  
   
  
## Examples  
 以下代码示例演示了 <xref:System.Messaging.MessageQueue.ResetPermissions%2A> 的用法。  
  
 [!code-cpp[MessageQueue2#27](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#27)]
 [!code-csharp[MessageQueue2#27](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#27)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">访问“消息队列”方法时出错。</exception>
        <altmember cref="M:System.Messaging.MessageQueue.SetPermissions(System.String,System.Messaging.MessageQueueAccessRights)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Send">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>向队列发送对象。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public void Send (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Send(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Send(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Send (obj As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Send(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="member this.Send : obj -&gt; unit" Usage="messageQueue.Send obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">要发送到队列的对象。</param>
        <summary>将对象发送到此 <see cref="T:System.Messaging.MessageQueue" /> 引用的非事务性队列。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用此重载将发送一条消息，包含`obj`参数所引用的队列<xref:System.Messaging.MessageQueue>。 向队列发送该对象可以是<xref:System.Messaging.Message>或任何托管的对象。 如果任何对象而不发送<xref:System.Messaging.Message>，序列化对象并将其插入到消息的正文。  
  
 如果使用此重载将向事务性队列发送消息，消息将发送到死信队列。 如果你想要将包含其他消息的事务的一部分的消息，使用重载采用<xref:System.Messaging.MessageQueueTransaction>或<xref:System.Messaging.MessageQueueTransactionType>作为参数。  
  
 如果未设置<xref:System.Messaging.MessageQueue.Formatter%2A>属性之前调用<xref:System.Messaging.MessageQueue.Send%28System.Object%29>，格式化程序默认为<xref:System.Messaging.XmlMessageFormatter>。  
  
 <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>属性不是适用于任何对象<xref:System.Messaging.Message>。 如果指定，例如，一个标签或优先级 using<xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>成员，这些值应用于包含的类型不是一个对象的任何消息<xref:System.Messaging.Message>时你的应用程序将其发送到队列。 发送时<xref:System.Messaging.Message>，属性值设置为<xref:System.Messaging.Message>优先于<xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>和消息<xref:System.Messaging.Message.Formatter%2A?displayProperty=nameWithType>属性优先于队列的<xref:System.Messaging.MessageQueue.Formatter%2A?displayProperty=nameWithType>属性。  
  
 下表显示了此方法是在各种工作组模式下可用。  
  
|工作组模式下|可用|  
|--------------------|---------------|  
|本地计算机|是|  
|本地计算机和直接格式名|是|  
|远程计算机|否|  
|远程计算机并直接格式名|是|  
  
   
  
## Examples  
 下面的代码示例连接到消息队列，并将消息发送到队列。  
  
 [!code-cpp[MessageQueue.Send_obj#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Send_obj/CPP/mqsend_generic.cpp#1)]
 [!code-csharp[MessageQueue.Send_obj#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Send_obj/CS/mqsend_generic.cs#1)]
 [!code-vb[MessageQueue.Send_obj#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Send_obj/VB/mqsend_generic.vb#1)]  
  
 下面的代码示例将发送应用程序定义`Order`类到队列，然后从该队列中接收消息。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">尚未设置 <see cref="P:System.Messaging.MessageQueue.Path" /> 属性。  
  
或 
访问“消息队列”方法时出错。</exception>
        <altmember cref="P:System.Messaging.MessageQueue.DefaultPropertiesToSend" />
        <altmember cref="T:System.Messaging.Message" />
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public void Send (object obj, System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Send(object obj, class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Send(System.Object,System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Send (obj As Object, transaction As MessageQueueTransaction)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Send(System::Object ^ obj, System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberSignature Language="F#" Value="member this.Send : obj * System.Messaging.MessageQueueTransaction -&gt; unit" Usage="messageQueue.Send (obj, transaction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="obj">要发送到队列的对象。</param>
        <param name="transaction">
          <see cref="T:System.Messaging.MessageQueueTransaction" /> 对象。</param>
        <summary>将对象发送到此 <see cref="T:System.Messaging.MessageQueue" /> 所引用的事务性队列。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用此重载将发送一条消息，包含`obj`参数所引用的事务性队列<xref:System.Messaging.MessageQueue>，使用定义的内部事务上下文`transaction`参数。 向队列发送该对象可以是<xref:System.Messaging.Message>或任何托管的对象。 如果任何对象而不发送<xref:System.Messaging.Message>，序列化对象并将其插入到消息的正文。  
  
 如果使用此重载将向非事务性队列发送一条消息，则消息可能发送到死信队列中而不引发异常。  
  
 如果未设置<xref:System.Messaging.MessageQueue.Formatter%2A>属性之前调用<xref:System.Messaging.MessageQueue.Send%28System.Object%29>，格式化程序默认为<xref:System.Messaging.XmlMessageFormatter>。  
  
 <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>属性不是适用于任何对象<xref:System.Messaging.Message>。 如果指定，例如，一个标签或优先级 using<xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>成员，这些值应用于包含的类型不是一个对象的任何消息<xref:System.Messaging.Message>时你的应用程序将其发送到队列。 发送时<xref:System.Messaging.Message>，属性值设置为<xref:System.Messaging.Message>优先于<xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>和消息<xref:System.Messaging.Message.Formatter%2A?displayProperty=nameWithType>属性优先于队列的<xref:System.Messaging.MessageQueue.Formatter%2A?displayProperty=nameWithType>属性。  
  
 <xref:System.Messaging.MessageQueueTransaction> 线程处理单元识别，因此，如果单元状态， `STA`，不能在多个线程中使用事务。 Visual Basic 设置到主线程的状态`STA`，因此你必须应用<xref:System.MTAThreadAttribute>中`Main`子例程。 否则，利用另一个线程发送事务性消息将引发 <xref:System.Messaging.MessageQueueException> 异常。 您将应用<xref:System.MTAThreadAttribute>通过使用下面的片段。  
  
```vb  
<System.MTAThreadAttribute>  
 public sub Main()  
```  
  
 下表显示了此方法是在各种工作组模式下可用。  
  
|工作组模式下|可用|  
|--------------------|---------------|  
|本地计算机|是|  
|本地计算机和直接格式名|是|  
|远程计算机|否|  
|远程计算机并直接格式名|是|  
  
   
  
## Examples  
 下面的代码示例将字符串发送到事务性队列，然后从该队列中接收一条消息。  
  
 [!code-cpp[MessageQueue.Send_ObjectTransaction#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Send_ObjectTransaction/CPP/mqsend_objtransaction.cpp#1)]
 [!code-csharp[MessageQueue.Send_ObjectTransaction#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Send_ObjectTransaction/CS/mqsend_objtransaction.cs#1)]
 [!code-vb[MessageQueue.Send_ObjectTransaction#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Send_ObjectTransaction/VB/mqsend_objtransaction.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="transaction" /> 参数为 <see langword="null" />。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">尚未设置 <see cref="P:System.Messaging.MessageQueue.Path" /> 属性。  
  
或 
“消息队列”应用程序指示事务用法不正确。  
  
或 
访问“消息队列”方法时出错。</exception>
        <altmember cref="P:System.Messaging.MessageQueue.DefaultPropertiesToSend" />
        <altmember cref="T:System.Messaging.Message" />
        <altmember cref="T:System.Messaging.MessageQueueTransaction" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public void Send (object obj, System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Send(object obj, valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Send(System.Object,System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Send (obj As Object, transactionType As MessageQueueTransactionType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Send(System::Object ^ obj, System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="F#" Value="member this.Send : obj * System.Messaging.MessageQueueTransactionType -&gt; unit" Usage="messageQueue.Send (obj, transactionType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="obj">要发送到队列的对象。</param>
        <param name="transactionType">
          <see cref="T:System.Messaging.MessageQueueTransactionType" /> 值之一，它描述与消息关联的事务上下文的类型。</param>
        <summary>将对象发送到此 <see cref="T:System.Messaging.MessageQueue" /> 所引用的队列。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用此重载将发送一条消息，包含`obj`参数所引用的队列<xref:System.Messaging.MessageQueue>，使用定义的事务上下文`transactionType`参数。 指定`Automatic`为`transactionType`参数如果已经有外部事务上下文附加到你想要用于发送消息的线程。 指定`Single`如果你想要将消息发送作为单个内部事务。 您可以指定`None`如果你想要将事务性消息发送到非事务性的线程。  
  
 向队列发送该对象可以是<xref:System.Messaging.Message>或任何托管的对象。 如果任何对象而不发送<xref:System.Messaging.Message>，序列化对象并将其插入到消息的正文。  
  
 如果未设置<xref:System.Messaging.MessageQueue.Formatter%2A>属性之前调用<xref:System.Messaging.MessageQueue.Send%28System.Object%29>，格式化程序默认为<xref:System.Messaging.XmlMessageFormatter>。  
  
 <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>属性不是适用于任何对象<xref:System.Messaging.Message>。 如果指定，例如，一个标签或优先级 using<xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>成员，这些值应用于包含的类型不是一个对象的任何消息<xref:System.Messaging.Message>时你的应用程序将其发送到队列。 发送时<xref:System.Messaging.Message>，属性值设置为<xref:System.Messaging.Message>优先于<xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>和消息<xref:System.Messaging.Message.Formatter%2A?displayProperty=nameWithType>属性优先于队列的<xref:System.Messaging.MessageQueue.Formatter%2A?displayProperty=nameWithType>属性。  
  
 下表显示了此方法是在各种工作组模式下可用。  
  
|工作组模式下|可用|  
|--------------------|---------------|  
|本地计算机|是|  
|本地计算机和直接格式名|是|  
|远程计算机|否|  
|远程计算机并直接格式名|是|  
  
   
  
## Examples  
 以下代码示例演示了 <xref:System.Messaging.MessageQueue.Send%28System.Object%2CSystem.Messaging.MessageQueueTransactionType%29> 的用法。  
  
 [!code-cpp[MessageQueue2#2](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#2)]
 [!code-csharp[MessageQueue2#2](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="transactionType" /> 参数不是 <see cref="T:System.Messaging.MessageQueueTransactionType" /> 成员之一。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">尚未设置 <see cref="P:System.Messaging.MessageQueue.Path" /> 属性。  
  
或 
访问“消息队列”方法时出错。</exception>
        <altmember cref="T:System.Messaging.MessageQueueTransactionType" />
        <altmember cref="P:System.Messaging.MessageQueue.DefaultPropertiesToSend" />
        <altmember cref="T:System.Messaging.Message" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public void Send (object obj, string label);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Send(object obj, string label) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Send(System.Object,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Send (obj As Object, label As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Send(System::Object ^ obj, System::String ^ label);" />
      <MemberSignature Language="F#" Value="member this.Send : obj * string -&gt; unit" Usage="messageQueue.Send (obj, label)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="label" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="obj">要发送到队列的对象。</param>
        <param name="label">消息的标签。</param>
        <summary>将对象发送到此 <see cref="T:System.Messaging.MessageQueue" /> 引用的非事务性队列，并指定消息的标签。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用此重载将发送一条消息，包含`obj`参数所引用的队列<xref:System.Messaging.MessageQueue>。 使用此重载，可以指定用于标识消息的字符串为标签。 向队列发送该对象可以是<xref:System.Messaging.Message>，结构、 数据对象或任何托管的对象。 如果任何对象而不发送<xref:System.Messaging.Message>，序列化对象并将其插入到消息的正文。  
  
 消息标签是不同于消息队列标签，但又彼此是应用程序依赖于和没有继承到消息队列的含义。  
  
 如果使用此重载将向事务性队列发送消息，消息将发送到死信队列。 如果你想要将包含其他消息的事务的一部分的消息，使用重载采用<xref:System.Messaging.MessageQueueTransaction>或<xref:System.Messaging.MessageQueueTransactionType>作为参数。  
  
 <xref:System.Messaging.MessageQueue.Path%2A>属性为此<xref:System.Messaging.MessageQueue>发送消息之前，必须指定实例。 如果未设置<xref:System.Messaging.MessageQueue.Formatter%2A>属性之前调用<xref:System.Messaging.MessageQueue.Send%28System.Object%29>，格式化程序默认为<xref:System.Messaging.XmlMessageFormatter>。  
  
 <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>属性不是适用于任何对象<xref:System.Messaging.Message>。 如果指定，例如，一个标签或优先级 using<xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>成员，这些值应用于包含的类型不是一个对象的任何消息<xref:System.Messaging.Message>时你的应用程序将其发送到队列。 发送时<xref:System.Messaging.Message>，属性值设置为<xref:System.Messaging.Message>优先于<xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>和消息<xref:System.Messaging.Message.Formatter%2A?displayProperty=nameWithType>属性优先于队列的<xref:System.Messaging.MessageQueue.Formatter%2A?displayProperty=nameWithType>属性。  
  
 下表显示了此方法是在各种工作组模式下可用。  
  
|工作组模式下|可用|  
|--------------------|---------------|  
|本地计算机|是|  
|本地计算机和直接格式名|是|  
|远程计算机|否|  
|远程计算机并直接格式名|是|  
  
   
  
## Examples  
 以下代码示例演示了 <xref:System.Messaging.MessageQueue.Send%28System.Object%2CSystem.String%29> 的用法。  
  
 [!code-cpp[MessageQueue2#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#1)]
 [!code-csharp[MessageQueue2#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="label" /> 参数为 <see langword="null" />。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">尚未设置 <see cref="P:System.Messaging.MessageQueue.Path" /> 属性。  
  
或 
访问“消息队列”方法时出错。</exception>
        <altmember cref="P:System.Messaging.MessageQueue.DefaultPropertiesToSend" />
        <altmember cref="T:System.Messaging.Message" />
        <altmember cref="P:System.Messaging.MessageQueue.Label" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public void Send (object obj, string label, System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Send(object obj, string label, class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Send(System.Object,System.String,System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Send (obj As Object, label As String, transaction As MessageQueueTransaction)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Send(System::Object ^ obj, System::String ^ label, System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberSignature Language="F#" Value="member this.Send : obj * string * System.Messaging.MessageQueueTransaction -&gt; unit" Usage="messageQueue.Send (obj, label, transaction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="label" Type="System.String" />
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="obj">要发送到队列的对象。</param>
        <param name="label">消息的标签。</param>
        <param name="transaction">
          <see cref="T:System.Messaging.MessageQueueTransaction" /> 对象。</param>
        <summary>将对象发送到此 <see cref="T:System.Messaging.MessageQueue" /> 引用的事务性队列中，并指定该消息的标签。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用此重载将发送一条消息，包含`obj`参数所引用的事务性队列<xref:System.Messaging.MessageQueue>，使用定义的内部事务上下文`transaction`参数。 使用此重载，可以指定用于标识消息的字符串为标签。 向队列发送该对象可以是<xref:System.Messaging.Message>，结构、 数据对象或任何托管的对象。 如果任何对象而不发送<xref:System.Messaging.Message>，序列化对象并将其插入到消息的正文。  
  
 消息标签是不同于消息队列标签，但又彼此是应用程序依赖于和没有继承到消息队列的含义。  
  
 如果使用此重载将向非事务性队列发送一条消息，则消息可能发送到死信队列中而不引发异常。  
  
 如果未设置<xref:System.Messaging.MessageQueue.Formatter%2A>属性之前调用<xref:System.Messaging.MessageQueue.Send%28System.Object%29>，格式化程序默认为<xref:System.Messaging.XmlMessageFormatter>。  
  
 <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>属性不是适用于任何对象<xref:System.Messaging.Message>。 如果指定，例如，一个标签或优先级 using<xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>成员，这些值应用于包含的类型不是一个对象的任何消息<xref:System.Messaging.Message>时你的应用程序将其发送到队列。 发送时<xref:System.Messaging.Message>，属性值设置为<xref:System.Messaging.Message>优先于<xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>和消息<xref:System.Messaging.Message.Formatter%2A?displayProperty=nameWithType>属性优先于队列的<xref:System.Messaging.MessageQueue.Formatter%2A?displayProperty=nameWithType>属性  
  
 <xref:System.Messaging.MessageQueueTransaction> 线程处理单元识别，因此，如果单元状态， `STA`，不能在多个线程中使用事务。 Visual Basic 设置到主线程的状态`STA`，因此你必须应用<xref:System.MTAThreadAttribute>中`Main`子例程。 否则，利用另一个线程发送事务性消息将引发 <xref:System.Messaging.MessageQueueException> 异常。 您将应用<xref:System.MTAThreadAttribute>通过使用下面的片段。  
  
```vb  
<System.MTAThreadAttribute>  
 public sub Main()  
```  
  
 下表显示了此方法是在各种工作组模式下可用。  
  
|工作组模式下|可用|  
|--------------------|---------------|  
|本地计算机|是|  
|本地计算机和直接格式名|是|  
|远程计算机|否|  
|远程计算机并直接格式名|是|  
  
   
  
## Examples  
 以下代码示例演示了 <xref:System.Messaging.MessageQueue.Send%28System.Object%2CSystem.String%2CSystem.Messaging.MessageQueueTransaction%29> 的用法。  
  
 [!code-cpp[MessageQueue2#4](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#4)]
 [!code-csharp[MessageQueue2#4](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="label" /> 参数为 <see langword="null" />。  
  
或 
<paramref name="transaction" /> 参数为 <see langword="null" />。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">尚未设置 <see cref="P:System.Messaging.MessageQueue.Path" /> 属性。  
  
或 
“消息队列”应用程序指示了不正确的事务用法。  
  
或 
访问“消息队列”方法时出错。</exception>
        <altmember cref="P:System.Messaging.MessageQueue.DefaultPropertiesToSend" />
        <altmember cref="T:System.Messaging.Message" />
        <altmember cref="T:System.Messaging.MessageQueueTransaction" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="P:System.Messaging.MessageQueue.Label" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public void Send (object obj, string label, System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Send(object obj, string label, valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Send(System.Object,System.String,System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Send (obj As Object, label As String, transactionType As MessageQueueTransactionType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Send(System::Object ^ obj, System::String ^ label, System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="F#" Value="member this.Send : obj * string * System.Messaging.MessageQueueTransactionType -&gt; unit" Usage="messageQueue.Send (obj, label, transactionType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="label" Type="System.String" />
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="obj">要发送到队列的对象。</param>
        <param name="label">消息的标签。</param>
        <param name="transactionType">
          <see cref="T:System.Messaging.MessageQueueTransactionType" /> 值之一，它描述与消息关联的事务上下文的类型。</param>
        <summary>将对象发送到此 <see cref="T:System.Messaging.MessageQueue" /> 引用的队列中，并指定该消息的标签。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用此重载将发送一条消息，包含`obj`参数所引用的队列<xref:System.Messaging.MessageQueue>，使用定义的事务上下文`transactionType`参数。 指定`Automatic`为`transactionType`参数如果已经有外部事务上下文附加到你想要用于发送消息的线程。 指定`Single`如果你想要将消息发送作为单个内部事务。 您可以指定`None`如果你想要将事务性消息发送到非事务性的线程。  
  
 向队列发送该对象可以是<xref:System.Messaging.Message>或任何托管的对象。 如果任何对象而不发送<xref:System.Messaging.Message>，序列化对象并将其插入到消息的正文。 使用此重载，可以指定用于标识消息的字符串为标签。  
  
 消息标签是不同于消息队列标签，但又彼此是应用程序依赖于和没有继承到消息队列的含义。  
  
 如果未设置<xref:System.Messaging.MessageQueue.Formatter%2A>属性之前调用<xref:System.Messaging.MessageQueue.Send%28System.Object%29>，格式化程序默认为<xref:System.Messaging.XmlMessageFormatter>。  
  
 <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>属性不是适用于任何对象<xref:System.Messaging.Message>。 如果指定，例如，一个标签或优先级 using<xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>成员，这些值应用于包含的类型不是一个对象的任何消息<xref:System.Messaging.Message>时你的应用程序将其发送到队列。 发送时<xref:System.Messaging.Message>，属性值设置为<xref:System.Messaging.Message>优先于<xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>，和消息<xref:System.Messaging.Message.Formatter%2A?displayProperty=nameWithType>属性优先于队列的<xref:System.Messaging.MessageQueue.Formatter%2A?displayProperty=nameWithType>属性。  
  
 下表显示了此方法是在各种工作组模式下可用。  
  
|工作组模式下|可用|  
|--------------------|---------------|  
|本地计算机|是|  
|本地计算机和直接格式名|是|  
|远程计算机|否|  
|远程计算机并直接格式名|是|  
  
   
  
## Examples  
 以下代码示例演示了 <xref:System.Messaging.MessageQueue.Send%28System.Object%2CSystem.String%2CSystem.Messaging.MessageQueueTransactionType%29> 的用法。  
  
 [!code-cpp[MessageQueue2#3](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#3)]
 [!code-csharp[MessageQueue2#3](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="label" /> 参数为 <see langword="null" />。</exception>
        <exception cref="T:System.Messaging.MessageQueueTransaction">“消息队列”应用程序指示了不正确的事务用法。</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="transactionType" /> 参数不是 <see cref="T:System.Messaging.MessageQueueTransactionType" /> 成员之一。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">尚未设置 <see cref="P:System.Messaging.MessageQueue.Path" /> 属性。  
  
或 
访问“消息队列”方法时出错。</exception>
        <altmember cref="T:System.Messaging.MessageQueueTransactionType" />
        <altmember cref="P:System.Messaging.MessageQueue.DefaultPropertiesToSend" />
        <altmember cref="T:System.Messaging.Message" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="P:System.Messaging.MessageQueue.Label" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <MemberGroup MemberName="SetPermissions">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>将权限添加到当前集合中。 这样可控制谁对队列中的队列属性和消息具有访问权限。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetPermissions">
      <MemberSignature Language="C#" Value="public void SetPermissions (System.Messaging.AccessControlList dacl);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetPermissions(class System.Messaging.AccessControlList dacl) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.SetPermissions(System.Messaging.AccessControlList)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetPermissions (dacl As AccessControlList)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetPermissions(System::Messaging::AccessControlList ^ dacl);" />
      <MemberSignature Language="F#" Value="member this.SetPermissions : System.Messaging.AccessControlList -&gt; unit" Usage="messageQueue.SetPermissions dacl" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dacl" Type="System.Messaging.AccessControlList" />
      </Parameters>
      <Docs>
        <param name="dacl">
          <see cref="T:System.Messaging.AccessControlList" />，包含一个或多个指定受信者和要授予的权限的访问控制项。</param>
        <summary>基于访问控制列表的内容将访问权限分配给队列。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用此重载以授予、 拒绝或撤消权限，通过使用一系列访问控制项指定受信者和权限信息。 这用于，例如，同时向多个用户授予权限。  
  
 构造时指定的受信者`ace`参数可以是单个用户、 用户、 组或计算机。 如果受信者个人，请使用格式`DOMAIN` \\ `user`。 您可以指定"。"受信者来指示本地计算机。  
  
 通过分配的权限<xref:System.Messaging.MessageQueue.SetPermissions%2A>将权限添加到现有列表。 默认情况下，公用或专用队列的创建者具有完全控制，并且每个人都有获取队列属性，获取权限，并写入队列的权限的域组。 当您调用<xref:System.Messaging.MessageQueue.SetPermissions%2A>，用户和权限信息追加到现有列表的底部。  
  
 系统将检查每个<xref:System.Messaging.AccessControlEntry>顺序，直到发生以下事件之一：  
  
-   拒绝访问的<xref:System.Messaging.AccessControlEntry>显式拒绝任何对一个线程的访问令牌中列出的受信者的请求的访问权限。  
  
-   一个或多个访问允许<xref:System.Messaging.AccessControlEntry>项受信者明确列出线程的访问令牌中授予的所有请求的访问权限。  
  
-   所有<xref:System.Messaging.AccessControlEntry>已检查的项，并且没有仍在至少一个请求的访问权限没有被明确允许，在这种情况下，隐式拒绝访问。  
  
 构造时`dacl`参数，您将添加<xref:System.Messaging.AccessControlEntry>实例向您<xref:System.Messaging.AccessControlList>集合。 在构造每个访问控制项时，可以指定泛型类型或者标准访问权限。 对队列的权限可以是以下任意组合：  
  
-   删除  
  
-   读取安全  
  
-   编写安全  
  
-   同步  
  
-   修改所有者  
  
-   读取  
  
-   Write  
  
-   执行  
  
-   必需  
  
-   全部  
  
-   无  
  
 这些权限是一组位标志，可结合使用按位 OR 运算符。  
  
-   完全控制  
  
-   删除消息  
  
-   接收消息  
  
-   速览消息  
  
-   接收日志消息  
  
-   获取队列属性  
  
-   设置队列属性  
  
-   获取权限  
  
-   设置权限  
  
-   取得队列所有权  
  
-   编写消息  
  
 下表显示了此方法是在各种工作组模式下可用。  
  
|工作组模式下|可用|  
|--------------------|---------------|  
|本地计算机|是|  
|本地计算机和直接格式名|是|  
|远程计算机|否|  
|远程计算机并直接格式名|否|  
  
   
  
## Examples  
 以下代码示例演示了 <xref:System.Messaging.MessageQueue.SetPermissions%28System.Messaging.AccessControlList%29> 的用法。      
  
 [!code-cpp[MessageQueue2#26](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#26)]
 [!code-csharp[MessageQueue2#26](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#26)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">访问“消息队列”方法时出错。</exception>
        <altmember cref="M:System.Messaging.MessageQueue.ResetPermissions" />
        <altmember cref="T:System.Messaging.Trustee" />
        <altmember cref="T:System.Messaging.AccessControlList" />
      </Docs>
    </Member>
    <Member MemberName="SetPermissions">
      <MemberSignature Language="C#" Value="public void SetPermissions (System.Messaging.MessageQueueAccessControlEntry ace);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetPermissions(class System.Messaging.MessageQueueAccessControlEntry ace) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.SetPermissions(System.Messaging.MessageQueueAccessControlEntry)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetPermissions (ace As MessageQueueAccessControlEntry)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetPermissions(System::Messaging::MessageQueueAccessControlEntry ^ ace);" />
      <MemberSignature Language="F#" Value="member this.SetPermissions : System.Messaging.MessageQueueAccessControlEntry -&gt; unit" Usage="messageQueue.SetPermissions ace" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ace" Type="System.Messaging.MessageQueueAccessControlEntry" />
      </Parameters>
      <Docs>
        <param name="ace">指定用户、访问类型和权限类型的 <see cref="T:System.Messaging.MessageQueueAccessControlEntry" />。</param>
        <summary>基于访问控制项的内容将访问权限分配给队列。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用此重载以授予、 拒绝或撤消权限，通过使用访问控制项来指定受信者和权限信息。  
  
 构造时指定的受信者`ace`参数可以是单个用户、 用户、 组或计算机。 如果受信者个人，请使用格式`DOMAIN` \\ `user`。 您可以指定"。"受信者来指示本地计算机。  
  
 通过分配的权限<xref:System.Messaging.MessageQueue.SetPermissions%2A>将权限添加到现有列表。 默认情况下，公用或专用队列的创建者具有完全控制，并且每个人都有获取队列属性，获取权限，并写入队列的权限的域组。 当您调用<xref:System.Messaging.MessageQueue.SetPermissions%2A>，用户和权限信息追加到现有列表的底部。  
  
 系统将检查每个<xref:System.Messaging.AccessControlEntry>顺序，直到发生以下事件之一：  
  
-   拒绝访问的<xref:System.Messaging.AccessControlEntry>显式拒绝任何对一个线程的访问令牌中列出的受信者的请求的访问权限。  
  
-   一个或多个访问允许<xref:System.Messaging.AccessControlEntry>项受信者明确列出线程的访问令牌中授予的所有请求的访问权限。  
  
-   所有<xref:System.Messaging.AccessControlEntry>已检查的项，并且没有仍在至少一个请求的访问权限没有被明确允许，在这种情况下，隐式拒绝访问。  
  
 在中指定的队列的权限`rights`参数在构造时你<xref:System.Messaging.MessageQueueAccessControlEntry>，可以是以下任意组合：  
  
-   完全控制  
  
-   删除消息  
  
-   接收消息  
  
-   速览消息  
  
-   接收日志消息  
  
-   获取队列属性  
  
-   设置队列属性  
  
-   获取权限  
  
-   设置权限  
  
-   取得队列所有权  
  
-   编写消息  
  
 `rights`参数的构造函数中指定`ace`参数是标记为<xref:System.Messaging.MessageQueueAccessRights>枚举。 它表示一组位标志，可结合使用按位运算符或生成时`rights`参数。  
  
 下表显示了此方法是在各种工作组模式下可用。  
  
|工作组模式下|可用|  
|--------------------|---------------|  
|本地计算机|是|  
|本地计算机和直接格式名|是|  
|远程计算机|否|  
|远程计算机并直接格式名|否|  
  
   
  
## Examples  
 以下代码示例演示了 <xref:System.Messaging.MessageQueue.SetPermissions%28System.Messaging.MessageQueueAccessControlEntry%29> 的用法。  
  
 [!code-cpp[MessageQueue2#24](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#24)]
 [!code-csharp[MessageQueue2#24](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#24)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">访问“消息队列”方法时出错。</exception>
        <altmember cref="M:System.Messaging.MessageQueue.ResetPermissions" />
        <altmember cref="T:System.Messaging.Trustee" />
        <altmember cref="T:System.Messaging.MessageQueueAccessRights" />
        <altmember cref="T:System.Messaging.MessageQueueAccessControlEntry" />
      </Docs>
    </Member>
    <Member MemberName="SetPermissions">
      <MemberSignature Language="C#" Value="public void SetPermissions (string user, System.Messaging.MessageQueueAccessRights rights);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetPermissions(string user, valuetype System.Messaging.MessageQueueAccessRights rights) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.SetPermissions(System.String,System.Messaging.MessageQueueAccessRights)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetPermissions (user As String, rights As MessageQueueAccessRights)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetPermissions(System::String ^ user, System::Messaging::MessageQueueAccessRights rights);" />
      <MemberSignature Language="F#" Value="member this.SetPermissions : string * System.Messaging.MessageQueueAccessRights -&gt; unit" Usage="messageQueue.SetPermissions (user, rights)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="user" Type="System.String" />
        <Parameter Name="rights" Type="System.Messaging.MessageQueueAccessRights" />
      </Parameters>
      <Docs>
        <param name="user">获取对队列的附加权限的个人、组或计算机。</param>
        <param name="rights">
          <see cref="T:System.Messaging.MessageQueueAccessRights" />，指示对消息队列分配给传入的 <c>user</c> 的队列权限集。</param>
        <summary>给予计算机、组或用户指定的访问权限。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用此重载以授予对单个用户指定的权限。 用户可以是任何有效受信者，包括单个用户、 用户、 组或计算机。 如果用户个人，请使用格式`DOMAIN` \\ `user`为`user`参数。 您可以指定"。"有关`user`参数来指示本地计算机。  
  
 通过分配的权限<xref:System.Messaging.MessageQueue.SetPermissions%2A>将权限添加到现有列表。 默认情况下，公用或专用队列的创建者具有完全控制，并且每个人都有获取队列属性，获取权限，并写入队列的权限的域组。 当您调用<xref:System.Messaging.MessageQueue.SetPermissions%2A>，用户和权限信息追加到现有列表的底部。  
  
 系统将检查每个<xref:System.Messaging.AccessControlEntry>顺序，直到发生以下事件之一：  
  
-   拒绝访问的<xref:System.Messaging.AccessControlEntry>显式拒绝任何对一个线程的访问令牌中列出的受信者的请求的访问权限。  
  
-   一个或多个访问允许<xref:System.Messaging.AccessControlEntry>项受信者明确列出线程的访问令牌中授予的所有请求的访问权限。  
  
-   所有<xref:System.Messaging.AccessControlEntry>已检查的项，并且没有仍在至少一个请求的访问权限没有被明确允许，在这种情况下，隐式拒绝访问。  
  
 在指定的队列的权限`rights`参数，可以是以下任意组合：  
  
-   完全控制  
  
-   删除消息  
  
-   接收消息  
  
-   速览消息  
  
-   接收日志消息  
  
-   获取队列属性  
  
-   设置队列属性  
  
-   获取权限  
  
-   设置权限  
  
-   取得队列所有权  
  
-   编写消息  
  
 <xref:System.Messaging.MessageQueueAccessRights>枚举表示一组位标志，可结合使用按位运算符或构建`rights`参数。  
  
 使用此重载中，仅可以授予的权限;不能撤消或拒绝它们。 您必须使用不同的重载来显式授予的任何<xref:System.Messaging.AccessControlEntryType>而不`Allow`。  
  
 下表显示了此方法是在各种工作组模式下可用。  
  
|工作组模式下|可用|  
|--------------------|---------------|  
|本地计算机|是|  
|本地计算机和直接格式名|是|  
|远程计算机|否|  
|远程计算机并直接格式名|否|  
  
   
  
## Examples  
 以下代码示例演示了 <xref:System.Messaging.MessageQueue.SetPermissions%28System.String%2CSystem.Messaging.MessageQueueAccessRights%29> 的用法。  
  
 [!code-cpp[MessageQueue2#23](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#23)]
 [!code-csharp[MessageQueue2#23](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#23)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="user" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">访问“消息队列”方法时出错。</exception>
        <altmember cref="M:System.Messaging.MessageQueue.ResetPermissions" />
        <altmember cref="T:System.Messaging.Trustee" />
        <altmember cref="T:System.Messaging.MessageQueueAccessRights" />
      </Docs>
    </Member>
    <Member MemberName="SetPermissions">
      <MemberSignature Language="C#" Value="public void SetPermissions (string user, System.Messaging.MessageQueueAccessRights rights, System.Messaging.AccessControlEntryType entryType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetPermissions(string user, valuetype System.Messaging.MessageQueueAccessRights rights, valuetype System.Messaging.AccessControlEntryType entryType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.SetPermissions(System.String,System.Messaging.MessageQueueAccessRights,System.Messaging.AccessControlEntryType)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetPermissions (user As String, rights As MessageQueueAccessRights, entryType As AccessControlEntryType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetPermissions(System::String ^ user, System::Messaging::MessageQueueAccessRights rights, System::Messaging::AccessControlEntryType entryType);" />
      <MemberSignature Language="F#" Value="member this.SetPermissions : string * System.Messaging.MessageQueueAccessRights * System.Messaging.AccessControlEntryType -&gt; unit" Usage="messageQueue.SetPermissions (user, rights, entryType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="user" Type="System.String" />
        <Parameter Name="rights" Type="System.Messaging.MessageQueueAccessRights" />
        <Parameter Name="entryType" Type="System.Messaging.AccessControlEntryType" />
      </Parameters>
      <Docs>
        <param name="user">获取对队列的附加权限的个人、组或计算机。</param>
        <param name="rights">
          <see cref="T:System.Messaging.MessageQueueAccessRights" />，指示对消息队列分配给传入的 <c>user</c> 的队列权限集。</param>
        <param name="entryType">
          <see cref="T:System.Messaging.AccessControlEntryType" />，指定授予、拒绝还是撤销 <c>rights</c> 参数指定的权限。</param>
        <summary>利用指定的访问控制类型（允许、拒绝、撤消或设置），给予计算机、组或用户指定的访问权限。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用此重载授予、 拒绝还是撤消指定为单个用户的权限。 用户可以是任何有效受信者，包括单个用户、 用户、 组或计算机。 如果用户个人，请使用格式`DOMAIN` \\ `user`为`user`参数。 您可以指定"。"有关`user`参数来指示本地计算机。  
  
 通过分配的权限<xref:System.Messaging.MessageQueue.SetPermissions%2A>将权限添加到现有列表。 默认情况下，公用或专用队列的创建者具有完全控制，并且每个人都有获取队列属性，获取权限，并写入队列的权限的域组。 当您调用<xref:System.Messaging.MessageQueue.SetPermissions%2A>，用户和权限信息追加到现有列表的底部。  
  
 系统将检查每个<xref:System.Messaging.AccessControlEntry>顺序，直到发生以下事件之一：  
  
-   拒绝访问的<xref:System.Messaging.AccessControlEntry>显式拒绝任何对一个线程的访问令牌中列出的受信者的请求的访问权限。  
  
-   一个或多个访问允许<xref:System.Messaging.AccessControlEntry>项受信者明确列出线程的访问令牌中授予的所有请求的访问权限。  
  
-   所有<xref:System.Messaging.AccessControlEntry>已检查的项，并且没有仍在至少一个请求的访问权限没有被明确允许，在这种情况下，隐式拒绝访问。  
  
 在指定的队列的权限`rights`参数，可以是以下任意组合：  
  
-   完全控制  
  
-   删除消息  
  
-   接收消息  
  
-   速览消息  
  
-   接收日志消息  
  
-   获取队列属性  
  
-   设置队列属性  
  
-   获取权限  
  
-   设置权限  
  
-   取得队列所有权  
  
-   编写消息  
  
 <xref:System.Messaging.MessageQueueAccessRights>枚举表示一组位标志，可结合使用按位运算符或构建`rights`参数。  
  
 下表显示了此方法是在各种工作组模式下可用。  
  
|工作组模式下|可用|  
|--------------------|---------------|  
|本地计算机|是|  
|本地计算机和直接格式名|是|  
|远程计算机|否|  
|远程计算机并直接格式名|否|  
  
   
  
## Examples  
 以下代码示例演示了 <xref:System.Messaging.MessageQueue.SetPermissions%28System.String%2CSystem.Messaging.MessageQueueAccessRights%2CSystem.Messaging.AccessControlEntryType%29> 的用法。  
  
 [!code-cpp[MessageQueue2#25](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#25)]
 [!code-csharp[MessageQueue2#25](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#25)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">访问“消息队列”方法时出错。</exception>
        <altmember cref="M:System.Messaging.MessageQueue.ResetPermissions" />
        <altmember cref="T:System.Messaging.Trustee" />
        <altmember cref="T:System.Messaging.MessageQueueAccessRights" />
        <altmember cref="T:System.Messaging.AccessControlEntry" />
      </Docs>
    </Member>
    <Member MemberName="SynchronizingObject">
      <MemberSignature Language="C#" Value="public System.ComponentModel.ISynchronizeInvoke SynchronizingObject { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ComponentModel.ISynchronizeInvoke SynchronizingObject" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.SynchronizingObject" />
      <MemberSignature Language="VB.NET" Value="Public Property SynchronizingObject As ISynchronizeInvoke" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ComponentModel::ISynchronizeInvoke ^ SynchronizingObject { System::ComponentModel::ISynchronizeInvoke ^ get(); void set(System::ComponentModel::ISynchronizeInvoke ^ value); };" />
      <MemberSignature Language="F#" Value="member this.SynchronizingObject : System.ComponentModel.ISynchronizeInvoke with get, set" Usage="System.Messaging.MessageQueue.SynchronizingObject" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_SynchronizingObject")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.ISynchronizeInvoke</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置由 <see cref="E:System.Messaging.MessageQueue.ReceiveCompleted" /> 或 <see cref="E:System.Messaging.MessageQueue.PeekCompleted" /> 事件产生封送事件处理程序调用的对象。</summary>
        <value>
          <see cref="T:System.ComponentModel.ISynchronizeInvoke" />，表示封送由 <see cref="E:System.Messaging.MessageQueue.ReceiveCompleted" /> 或 <see cref="E:System.Messaging.MessageQueue.PeekCompleted" /> 事件产生的事件处理程序调用的对象。 默认值为 <see langword="null" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 一个<xref:System.Messaging.MessageQueue.ReceiveCompleted>或<xref:System.Messaging.MessageQueue.PeekCompleted>事件得出<xref:System.Messaging.MessageQueue.BeginReceive%2A>或<xref:System.Messaging.MessageQueue.BeginPeek%2A>请求，分别为特定线程。 通常情况下，<xref:System.Messaging.MessageQueue.SynchronizingObject%2A>时设置其相关的组件放在一个控件或窗体，因为这些组件绑定到特定线程。  
  
 通常情况下，同步对象封送到单线程的方法调用。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Messaging.MessageQueue.PeekCompleted" />
        <altmember cref="E:System.Messaging.MessageQueue.ReceiveCompleted" />
      </Docs>
    </Member>
    <Member MemberName="Transactional">
      <MemberSignature Language="C#" Value="public bool Transactional { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Transactional" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.Transactional" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Transactional As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Transactional { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.Transactional : bool" Usage="System.Messaging.MessageQueue.Transactional" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_Transactional")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示队列是否只接受事务。</summary>
        <value>如果队列只接受作为事务的一部分发送的消息，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 事务性消息传送是指多个相关消息组合成单个事务的耦合。 发送消息，因为事务的一部分可确保消息传送的顺序，只传递一次，并从它们的目标队列已成功检索。  
  
 如果队列是事务性的它接受作为事务的一部分发送的消息。 但是，非事务性消息才能发送或接收从本地事务队列，而无需显式使用事务性<xref:System.Messaging.MessageQueueTransaction.Begin%2A>， <xref:System.Messaging.MessageQueueTransaction.Commit%2A>，和<xref:System.Messaging.MessageQueueTransaction.Abort%2A>语法。 如果非事务性消息发送到事务性队列，此组件创建单个消息事务，除非在引用上使用直接格式名的远程计算机的队列的情况下。 在此情况下，如果发送消息时未指定事务上下文，不为您创建一个和消息将发送到死信队列。  
  
 如果将非事务性消息发送到事务性队列中时，你将不能回滚发生异常时的消息。  
  
 <xref:System.Messaging.MessageQueueTransaction> 线程处理单元识别，因此，如果单元状态， `STA`，不能在多个线程中使用事务。 Visual Basic 设置到主线程的状态`STA`，因此你必须应用<xref:System.MTAThreadAttribute>中`Main`子例程。 否则，利用另一个线程发送事务性消息将引发 <xref:System.Messaging.MessageQueueException> 异常。 您将应用<xref:System.MTAThreadAttribute>通过使用下面的片段。  
  
```vb  
<System.MTAThreadAttribute>  
 public sub Main()  
```  
  
 下表显示了此属性是否可在各种工作组模式下。  
  
|工作组模式下|可用|  
|--------------------|---------------|  
|本地计算机|是|  
|本地计算机和直接格式名|是|  
|远程计算机|否|  
|远程计算机并直接格式名|否|  
  
   
  
## Examples  
 下面的代码示例显示一个消息队列的值<xref:System.Messaging.MessageQueue.Transactional%2A>属性。  
  
 [!code-csharp[MessageQueue#27](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#27)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">访问“消息队列”方法时出错。</exception>
        <altmember cref="M:System.Messaging.MessageQueueTransaction.Begin" />
        <altmember cref="M:System.Messaging.MessageQueueTransaction.Commit" />
        <altmember cref="M:System.Messaging.MessageQueueTransaction.Abort" />
        <altmember cref="P:System.Messaging.Message.TransactionId" />
        <altmember cref="P:System.Messaging.Message.IsFirstInTransaction" />
        <altmember cref="P:System.Messaging.Message.IsLastInTransaction" />
      </Docs>
    </Member>
    <Member MemberName="UseJournalQueue">
      <MemberSignature Language="C#" Value="public bool UseJournalQueue { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UseJournalQueue" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.UseJournalQueue" />
      <MemberSignature Language="VB.NET" Value="Public Property UseJournalQueue As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UseJournalQueue { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.UseJournalQueue : bool with get, set" Usage="System.Messaging.MessageQueue.UseJournalQueue" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Messaging.MessagingDescription("MQ_WriteHandle")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_UseJournalQueue")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值指示接收的消息是否复制到日记队列。</summary>
        <value>如果从队列接收到的消息复制到其日记队列，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当消息队列应用程序创建新的应用程序队列时，会自动在同一位置中创建关联的日记队列。 日记队列用于跟踪的消息从队列中删除。 设置此属性修改消息队列队列。 因此，任何其他<xref:System.Messaging.MessageQueue>更改会影响实例。  
  
 日志队列不会跟踪消息从队列删除，因为其接收时间计时器过期，也不会跟踪消息从队列中清除使用的消息队列目录服务 （信息存储或 Active Directory）。  
  
 应用程序不能将消息发送到日志队列;它们被限制为这些队列的只读访问权限。 此外，消息队列永远不会删除邮件日记队列中。 使用队列的应用程序必须清除这些消息通过接收它们或通过清除队列。  
  
 下表显示了此属性是否可在各种工作组模式下。  
  
|工作组模式下|可用|  
|--------------------|---------------|  
|本地计算机|是|  
|本地计算机和直接格式名|是|  
|远程计算机|否|  
|远程计算机并直接格式名|否|  
  
   
  
## Examples  
 下面的代码示例获取和设置的值的消息队列的<xref:System.Messaging.MessageQueue.UseJournalQueue%2A>属性。  
  
 [!code-csharp[MessageQueue#28](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#28)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">访问“消息队列”方法时出错。</exception>
        <altmember cref="P:System.Messaging.MessageQueue.MaximumJournalSize" />
      </Docs>
    </Member>
    <Member MemberName="WriteHandle">
      <MemberSignature Language="C#" Value="public IntPtr WriteHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int WriteHandle" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.WriteHandle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property WriteHandle As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr WriteHandle { IntPtr get(); };" />
      <MemberSignature Language="F#" Value="member this.WriteHandle : nativeint" Usage="System.Messaging.MessageQueue.WriteHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_WriteHandle")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取用于将消息发送到消息队列的本机句柄。</summary>
        <value>用于将消息发送到队列的本机队列对象的句柄。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.WriteHandle%2A>提供了用于将消息发送到队列的消息队列对象的本机 Windows 句柄。 如果更改队列的路径，该句柄关闭，并使用新值重新打开。  
  
 下表显示了此属性是否可在各种工作组模式下。  
  
|工作组模式下|可用|  
|--------------------|---------------|  
|本地计算机|是|  
|本地计算机和直接格式名|是|  
|远程计算机|否|  
|远程计算机并直接格式名|是|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">消息队列无法用于写入。</exception>
        <altmember cref="P:System.Messaging.MessageQueue.CanWrite" />
        <altmember cref="P:System.Messaging.MessageQueue.ReadHandle" />
      </Docs>
    </Member>
  </Members>
</Type>