<Type Name="SslStream" FullName="System.Net.Security.SslStream">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="6db86a2c0a6e5ab07beaf44206e196b18df63c5a" />
    <Meta Name="ms.sourcegitcommit" Value="5a49536d99d2d0b54e4cb7280870903e043272df" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-CN" />
    <Meta Name="ms.lasthandoff" Value="07/03/2018" />
    <Meta Name="ms.locfileid" Value="37477421" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class SslStream : System.Net.Security.AuthenticatedStream" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit SslStream extends System.Net.Security.AuthenticatedStream implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Net.Security.SslStream" />
  <TypeSignature Language="VB.NET" Value="Public Class SslStream&#xA;Inherits AuthenticatedStream" />
  <TypeSignature Language="C++ CLI" Value="public ref class SslStream : System::Net::Security::AuthenticatedStream" />
  <TypeSignature Language="F#" Value="type SslStream = class&#xA;    inherit AuthenticatedStream&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Net.Security</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Net.Security.AuthenticatedStream</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>提供一个用于客户端-服务器通信的流，该流使用安全套接字层 (SSL) 安全协议对服务器和（可选）客户端进行身份验证。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 SSL 协议帮助提供机密性和完整性检查传输使用的消息<xref:System.Net.Security.SslStream>。 SSL 连接，例如提供的<xref:System.Net.Security.SslStream>、 应时使用通信客户端和服务器之间的敏感信息。 使用<xref:System.Net.Security.SslStream>有助于防止任何人读取和在网络上传输时被篡改的信息。  
  
 <xref:System.Net.Security.SslStream>实例将使用在创建时提供的流的数据传输<xref:System.Net.Security.SslStream>。 时提供此基础流，可以选择指定是否关闭<xref:System.Net.Security.SslStream>也会关闭基础流。 通常情况下，<xref:System.Net.Security.SslStream>类用于<xref:System.Net.Sockets.TcpClient>和<xref:System.Net.Sockets.TcpListener>类。 <xref:System.Net.Sockets.TcpClient.GetStream%2A>方法提供<xref:System.Net.Sockets.NetworkStream>适用于<xref:System.Net.Security.SslStream>类。  
  
 在创建后<xref:System.Net.Security.SslStream>，必须进行身份验证服务器和客户端 （可选）。 服务器必须提供 X509 证书建立其标识的证明，并可以请求客户端也执行该操作。 使用信息在传输之前，必须执行身份验证<xref:System.Net.Security.SslStream>。 客户端启动身份验证使用同步<xref:System.Net.Security.SslStream.AuthenticateAsClient%2A>方法，阻止，直到完成身份验证，或异步<xref:System.Net.Security.SslStream.BeginAuthenticateAsClient%2A>方法，不会阻止等待身份验证完成。 服务器启动身份验证使用同步<xref:System.Net.Security.SslStream.AuthenticateAsServer%2A>或异步<xref:System.Net.Security.SslStream.BeginAuthenticateAsServer%2A>方法。 客户端和服务器必须启动的身份验证。  
  
 由安全支持提供程序 (SSPI) 通道提供程序处理身份验证。 客户端有机会来控制通过指定的服务器的证书验证<xref:System.Net.Security.RemoteCertificateValidationCallback>委托创建时<xref:System.Net.Security.SslStream>。 服务器还可以通过提供控制验证<xref:System.Net.Security.RemoteCertificateValidationCallback>委托。 引用委托的方法包括远程方的证书和 SSPI 验证证书时遇到任何错误。 请注意，是否在服务器指定的委托，委托的方法调用而不考虑服务器是否请求客户端身份验证。 如果服务器没有请求客户端身份验证，服务器的委托方法将收到 null 证书和证书错误的空数组。  
  
 如果服务器要求客户端身份验证，客户端必须指定一个或多个证书进行身份验证。 客户端在客户端有多个证书，可以提供<xref:System.Net.Security.LocalCertificateSelectionCallback>委托来选择正确的证书的服务器。 客户端的证书必须位于当前用户的"我的"证书存储区。 不支持通过证书的客户端身份验证<xref:System.Security.Authentication.SslProtocols.Ssl2>(SSL 版本 2) 协议。  
  
 如果身份验证失败，则收到<xref:System.Security.Authentication.AuthenticationException>，和<xref:System.Net.Security.SslStream>已不再使用。 应关闭此对象，并删除对它的所有引用，以便它可以收集的垃圾回收器。  
  
 身份验证过程，也称为 SSL 握手，成功后，建立服务器 （和 （可选） 客户端） 的标识和<xref:System.Net.Security.SslStream>可用于通过客户端和服务器交换消息。 在之前发送或接收信息，客户端和服务器应检查的安全服务和级别提供的<xref:System.Net.Security.SslStream>以确定协议、 算法和所选的优势是否满足其要求的完整性和保密性。 如果当前设置还不够，应关闭流。 你可以检查提供的安全服务<xref:System.Net.Security.SslStream>使用<xref:System.Net.Security.SslStream.IsEncrypted%2A>和<xref:System.Net.Security.SslStream.IsSigned%2A>属性。 下表显示了报表使用的身份验证、 加密和数据签名的加密设置的元素。  
  
|元素|成员|  
|-------------|-------------|  
|用于对服务器和客户端 （可选） 进行身份验证的安全协议。|<xref:System.Net.Security.SslStream.SslProtocol%2A>属性和关联<xref:System.Security.Authentication.SslProtocols>枚举。|  
|密钥交换算法。|<xref:System.Net.Security.SslStream.KeyExchangeAlgorithm%2A>属性和关联<xref:System.Security.Authentication.ExchangeAlgorithmType>枚举。|  
|消息完整性算法。|<xref:System.Net.Security.SslStream.HashAlgorithm%2A>属性和关联<xref:System.Security.Authentication.HashAlgorithmType>枚举。|  
|消息的保密性算法。|<xref:System.Net.Security.SslStream.CipherAlgorithm%2A>属性和关联<xref:System.Security.Authentication.CipherAlgorithmType>枚举。|  
|所选算法的优势。|<xref:System.Net.Security.SslStream.KeyExchangeStrength%2A>， <xref:System.Net.Security.SslStream.HashStrength%2A>，和<xref:System.Net.Security.SslStream.CipherStrength%2A>属性。|  
  
 身份验证成功后，可以发送数据，使用同步<xref:System.Net.Security.SslStream.Write%2A>或异步<xref:System.Net.Security.SslStream.BeginWrite%2A>方法。 可以接收数据使用同步<xref:System.Net.Security.SslStream.Read%2A>或异步<xref:System.Net.Security.SslStream.BeginRead%2A>方法。  
  
 如果指定到<xref:System.Net.Security.SslStream.%23ctor%2A>基础流应保持打开状态，负责完成后关闭该流使用它。  
  
> [!NOTE]
>  如果应用程序的创建<xref:System.Net.Security.SslStream>对象的普通用户凭据运行，应用程序将无法再访问证书安装在本地计算机存储区中，除非权限已显式将提供给用户来执行此操作。  
  
 <xref:System.Net.Security.SslStream> 假定以及任何其他超时<xref:System.IO.IOException>一个从内部流的引发时将被视为致命通过其调用方。 重复使用<xref:System.Net.Security.SslStream>实例后超时将返回垃圾回收。 应用程序应<xref:System.IO.Stream.Close%2A> <xref:System.Net.Security.SslStream> ，并在这些情况下引发异常。  
  
 .NET Framework 4.6 包括一个新的安全功能，将阻止不安全的密码和哈希算法的连接。 默认情况下，使用 TLS/SSL 通过 HttpClient、 HttpWebRequest、 FTPClient，SmtpClient、 SslStream 等 Api 和面向.NET Framework 4.6 的应用程序获得更安全的行为。  
  
 开发人员可能想要选择退出此行为以便保持与带 RC4 服务及其现有 SSL3 服务或 TLS 互操作性。 [这篇文章](https://support.microsoft.com/kb/3069494)介绍了如何修改你的代码，以便禁用新行为。  
  
 .NET Framework 4.7 中添加了新重载的方法的身份验证，未指定 TLS 版本，而是使用 TLS 版本定义中的系统默认值为 SslStreams [SCHANNEL](https://msdn.microsoft.com/library/windows/desktop/aa380123.aspx)。 作为一种方法能够更高版本修改默认值为 TLS 版本最佳做法是更改随着时间推移，应用程序中使用这些方法而无需重新生成并重新部署您的应用程序。

 另请参阅[传输层安全性 (TLS) 最佳实践与.NET Framework](~/docs/framework/network-programming/tls.md)。
  
   
  
## Examples  
 下面的代码示例演示如何创建<xref:System.Net.Sockets.TcpListener>，它使用<xref:System.Net.Security.SslStream>类与客户端通信。  
  
 [!code-cpp[NclSslServerSync#0](~/samples/snippets/cpp/VS_Snippets_Remoting/NclSslServerSync/CPP/NclSslServerSync.cpp#0)]
 [!code-csharp[NclSslServerSync#0](~/samples/snippets/csharp/VS_Snippets_Remoting/NclSslServerSync/CS/serversync.cs#0)]  
  
 下面的代码示例演示如何创建<xref:System.Net.Sockets.TcpClient>，它使用<xref:System.Net.Security.SslStream>类，以与服务器通信。  
  
 [!code-cpp[NclSslClientSync#0](~/samples/snippets/cpp/VS_Snippets_Remoting/NclSslClientSync/CPP/clientsync.cpp#0)]
 [!code-csharp[NclSslClientSync#0](~/samples/snippets/csharp/VS_Snippets_Remoting/NclSslClientSync/CS/clientsync.cs#0)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Net.Security.NegotiateStream" />
    <altmember cref="T:System.Net.Security.AuthenticatedStream" />
    <altmember cref="T:System.IO.IOException" />
    <altmember cref="T:System.IO.Stream" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>初始化 <see cref="T:System.Net.Security.SslStream" /> 类的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要防止<xref:System.Net.Security.SslStream>关闭你提供的流，使用<xref:System.Net.Security.SslStream.%23ctor%2A>构造函数。  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SslStream (System.IO.Stream innerStream);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.IO.Stream innerStream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.SslStream.#ctor(System.IO.Stream)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (innerStream As Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; SslStream(System::IO::Stream ^ innerStream);" />
      <MemberSignature Language="F#" Value="new System.Net.Security.SslStream : System.IO.Stream -&gt; System.Net.Security.SslStream" Usage="new System.Net.Security.SslStream innerStream" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="innerStream" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="innerStream">一个 <see cref="T:System.IO.Stream" /> 对象，<see cref="T:System.Net.Security.SslStream" /> 使用此对象发送和接收数据。</param>
        <summary>使用指定的 <see cref="T:System.Net.Security.SslStream" /> 初始化 <see cref="T:System.IO.Stream" /> 类的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果不 encryptionpolicy，在配置文件中指定一个值，则<xref:System.Net.Security.EncryptionPolicy>默认情况下<xref:System.Net.Security.EncryptionPolicy.RequireEncryption?displayProperty=nameWithType>为<xref:System.Net.Security.SslStream>构造的实例。  
  
 加密策略设置为时需要使用 Null 密码<xref:System.Net.Security.EncryptionPolicy.NoEncryption?displayProperty=nameWithType>。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="innerStream" /> 不可读。  -或-  <paramref name="innerStream" /> 不可写。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="innerStream" /> 为 <see langword="null" />。  -或-  <paramref name="innerStream" /> 等于 <see cref="F:System.IO.Stream.Null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SslStream (System.IO.Stream innerStream, bool leaveInnerStreamOpen);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.IO.Stream innerStream, bool leaveInnerStreamOpen) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.SslStream.#ctor(System.IO.Stream,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (innerStream As Stream, leaveInnerStreamOpen As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; SslStream(System::IO::Stream ^ innerStream, bool leaveInnerStreamOpen);" />
      <MemberSignature Language="F#" Value="new System.Net.Security.SslStream : System.IO.Stream * bool -&gt; System.Net.Security.SslStream" Usage="new System.Net.Security.SslStream (innerStream, leaveInnerStreamOpen)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="innerStream" Type="System.IO.Stream" />
        <Parameter Name="leaveInnerStreamOpen" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="innerStream">一个 <see cref="T:System.IO.Stream" /> 对象，<see cref="T:System.Net.Security.SslStream" /> 使用此对象发送和接收数据。</param>
        <param name="leaveInnerStreamOpen">一个布尔值，它指示 <see cref="T:System.IO.Stream" /> 用来发送和接收数据的 <see cref="T:System.Net.Security.SslStream" /> 对象的封闭行为。 此参数指示内部流是否保持打开状态。</param>
        <summary>使用指定的 <see cref="T:System.Net.Security.SslStream" /> 和流封闭行为初始化 <see cref="T:System.IO.Stream" /> 类的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当指定`true`有关`leaveStreamOpen`参数，关闭<xref:System.Net.Security.SslStream>不起任何作用`innerStream`流; 必须显式关闭`innerStream`时不再需要它。  
  
 如果不 encryptionpolicy，在配置文件中指定一个值，则<xref:System.Net.Security.EncryptionPolicy>默认情况下<xref:System.Net.Security.EncryptionPolicy.RequireEncryption?displayProperty=nameWithType>为<xref:System.Net.Security.SslStream>构造的实例。  
  
 加密策略设置为时需要使用 Null 密码<xref:System.Net.Security.EncryptionPolicy.NoEncryption?displayProperty=nameWithType>。  
  
   
  
## Examples  
 下面的代码示例演示如何调用此构造函数。  
  
 [!code-cpp[NclSslServerSync#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NclSslServerSync/CPP/NclSslServerSync.cpp#1)]
 [!code-csharp[NclSslServerSync#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NclSslServerSync/CS/serversync.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="innerStream" /> 不可读。  -或-  <paramref name="innerStream" /> 不可写。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="innerStream" /> 为 <see langword="null" />。  -或-  <paramref name="innerStream" /> 等于 <see cref="F:System.IO.Stream.Null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SslStream (System.IO.Stream innerStream, bool leaveInnerStreamOpen, System.Net.Security.RemoteCertificateValidationCallback userCertificateValidationCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.IO.Stream innerStream, bool leaveInnerStreamOpen, class System.Net.Security.RemoteCertificateValidationCallback userCertificateValidationCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.SslStream.#ctor(System.IO.Stream,System.Boolean,System.Net.Security.RemoteCertificateValidationCallback)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (innerStream As Stream, leaveInnerStreamOpen As Boolean, userCertificateValidationCallback As RemoteCertificateValidationCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; SslStream(System::IO::Stream ^ innerStream, bool leaveInnerStreamOpen, System::Net::Security::RemoteCertificateValidationCallback ^ userCertificateValidationCallback);" />
      <MemberSignature Language="F#" Value="new System.Net.Security.SslStream : System.IO.Stream * bool * System.Net.Security.RemoteCertificateValidationCallback -&gt; System.Net.Security.SslStream" Usage="new System.Net.Security.SslStream (innerStream, leaveInnerStreamOpen, userCertificateValidationCallback)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="innerStream" Type="System.IO.Stream" />
        <Parameter Name="leaveInnerStreamOpen" Type="System.Boolean" />
        <Parameter Name="userCertificateValidationCallback" Type="System.Net.Security.RemoteCertificateValidationCallback" />
      </Parameters>
      <Docs>
        <param name="innerStream">一个 <see cref="T:System.IO.Stream" /> 对象，<see cref="T:System.Net.Security.SslStream" /> 使用此对象发送和接收数据。</param>
        <param name="leaveInnerStreamOpen">一个布尔值，它指示 <see cref="T:System.IO.Stream" /> 用来发送和接收数据的 <see cref="T:System.Net.Security.SslStream" /> 对象的封闭行为。 此参数指示内部流是否保持打开状态。</param>
        <param name="userCertificateValidationCallback">
          <see cref="T:System.Net.Security.RemoteCertificateValidationCallback" /> 委托，负责验证远程方提供的证书。</param>
        <summary>使用指定的 <see cref="T:System.Net.Security.SslStream" />、流关闭行为和证书验证委托初始化 <see cref="T:System.IO.Stream" /> 类的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当指定`true`有关`leaveStreamOpen`参数，关闭<xref:System.Net.Security.SslStream>不起任何作用`innerStream`流; 必须显式关闭`innerStream`时不再需要它。  
  
 `userCertificateValidationCallback`委托的`certificateErrors`参数包含返回的通道安全支持提供程序接口 (SSPI) 任何 Windows 错误代码。 所调用的方法的返回值`userCertificateValidationCallback`委托确定是否成功进行身份验证。  
  
 安全协议和加密算法已时选择`userCertificateValidationCallback`调用委托的方法。 该方法可用于确定所选的加密算法和优势是否足以满足您的应用程序。 如果不是，该方法应返回`false`以免<xref:System.Net.Security.SslStream>创建。  
  
 如果不 encryptionpolicy，在配置文件中指定一个值，则<xref:System.Net.Security.EncryptionPolicy>默认情况下<xref:System.Net.Security.EncryptionPolicy.RequireEncryption?displayProperty=nameWithType>为<xref:System.Net.Security.SslStream>构造的实例。  
  
 加密策略设置为时需要使用 Null 密码<xref:System.Net.Security.EncryptionPolicy.NoEncryption?displayProperty=nameWithType>。  
  
> [!NOTE]
>  框架缓存 SSL 会话，因为它们创建并尝试再次使用的会话缓存适用于新的请求，在可能的情况。 在尝试以重复使用的 SSL 会话时，框架将使用的第一个元素<xref:System.Net.HttpWebRequest.ClientCertificates%2A>（如果没有一个），或尝试重复使用匿名会话，如果<xref:System.Net.HttpWebRequest.ClientCertificates%2A>为空。  
  
> [!NOTE]
>  不支持 SSL 版本 2 协议在客户端证书。  
  
   
  
## Examples  
 下面的代码示例创建<xref:System.Net.Security.SslStream>并启动身份验证的客户端部分。  
  
 [!code-cpp[NclSslClientSync#4](~/samples/snippets/cpp/VS_Snippets_Remoting/NclSslClientSync/CPP/clientsync.cpp#4)]
 [!code-csharp[NclSslClientSync#4](~/samples/snippets/csharp/VS_Snippets_Remoting/NclSslClientSync/CS/clientsync.cs#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="innerStream" /> 不可读。  -或-  <paramref name="innerStream" /> 不可写。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="innerStream" /> 为 <see langword="null" />。  -或-  <paramref name="innerStream" /> 等于 <see cref="F:System.IO.Stream.Null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SslStream (System.IO.Stream innerStream, bool leaveInnerStreamOpen, System.Net.Security.RemoteCertificateValidationCallback userCertificateValidationCallback, System.Net.Security.LocalCertificateSelectionCallback userCertificateSelectionCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.IO.Stream innerStream, bool leaveInnerStreamOpen, class System.Net.Security.RemoteCertificateValidationCallback userCertificateValidationCallback, class System.Net.Security.LocalCertificateSelectionCallback userCertificateSelectionCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.SslStream.#ctor(System.IO.Stream,System.Boolean,System.Net.Security.RemoteCertificateValidationCallback,System.Net.Security.LocalCertificateSelectionCallback)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (innerStream As Stream, leaveInnerStreamOpen As Boolean, userCertificateValidationCallback As RemoteCertificateValidationCallback, userCertificateSelectionCallback As LocalCertificateSelectionCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; SslStream(System::IO::Stream ^ innerStream, bool leaveInnerStreamOpen, System::Net::Security::RemoteCertificateValidationCallback ^ userCertificateValidationCallback, System::Net::Security::LocalCertificateSelectionCallback ^ userCertificateSelectionCallback);" />
      <MemberSignature Language="F#" Value="new System.Net.Security.SslStream : System.IO.Stream * bool * System.Net.Security.RemoteCertificateValidationCallback * System.Net.Security.LocalCertificateSelectionCallback -&gt; System.Net.Security.SslStream" Usage="new System.Net.Security.SslStream (innerStream, leaveInnerStreamOpen, userCertificateValidationCallback, userCertificateSelectionCallback)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="innerStream" Type="System.IO.Stream" />
        <Parameter Name="leaveInnerStreamOpen" Type="System.Boolean" />
        <Parameter Name="userCertificateValidationCallback" Type="System.Net.Security.RemoteCertificateValidationCallback" />
        <Parameter Name="userCertificateSelectionCallback" Type="System.Net.Security.LocalCertificateSelectionCallback" />
      </Parameters>
      <Docs>
        <param name="innerStream">一个 <see cref="T:System.IO.Stream" /> 对象，<see cref="T:System.Net.Security.SslStream" /> 使用此对象发送和接收数据。</param>
        <param name="leaveInnerStreamOpen">一个布尔值，它指示 <see cref="T:System.IO.Stream" /> 用来发送和接收数据的 <see cref="T:System.Net.Security.SslStream" /> 对象的封闭行为。 此参数指示内部流是否保持打开状态。</param>
        <param name="userCertificateValidationCallback">
          <see cref="T:System.Net.Security.RemoteCertificateValidationCallback" /> 委托，负责验证远程方提供的证书。</param>
        <param name="userCertificateSelectionCallback">
          <see cref="T:System.Net.Security.LocalCertificateSelectionCallback" /> 委托，负责选择用于身份验证的证书。</param>
        <summary>使用指定的 <see cref="T:System.Net.Security.SslStream" />、流关闭行为、证书验证委托和证书选择委托初始化 <see cref="T:System.IO.Stream" /> 类的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当指定`true`有关`leaveStreamOpen`参数，关闭<xref:System.Net.Security.SslStream>不起任何作用`innerStream`流; 必须显式关闭`innerStream`时不再需要它。  
  
 `userCertificateValidationCallback`委托的`certificateErrors`参数包含返回的通道安全支持提供程序接口 (SSPI) 任何 Windows 错误代码。 所调用的方法的返回值`userCertificateValidationCallback`委托确定是否成功进行身份验证。  
  
 安全协议和加密算法已时选择`userCertificateValidationCallback`调用委托的方法。 该方法可用于确定所选的加密算法和优势是否足以满足您的应用程序。 如果不是，该方法应返回`false`以免<xref:System.Net.Security.SslStream>创建。  
  
 `userCertificateSelectionCallback`委托时，可以在应用程序具有多个证书，必须动态选择的证书。 在"MY"存储区中的证书传递给所调用的委托方法。  
  
 如果不 encryptionpolicy，在配置文件中指定一个值，则<xref:System.Net.Security.EncryptionPolicy>默认情况下<xref:System.Net.Security.EncryptionPolicy.RequireEncryption?displayProperty=nameWithType>为<xref:System.Net.Security.SslStream>构造的实例。  
  
 加密策略设置为时需要使用 Null 密码<xref:System.Net.Security.EncryptionPolicy.NoEncryption?displayProperty=nameWithType>。  
  
> [!NOTE]
>  框架缓存 SSL 会话，因为它们创建并尝试再次使用的会话缓存适用于新的请求，在可能的情况。 在尝试以重复使用的 SSL 会话时，框架将使用第一个元素的 P:System.Net.HttpWebRequest.ClientCertificates （如果有），或尝试重复使用匿名会话时为空。  
  
   
  
## Examples  
 下面的代码示例演示如何调用此构造函数。 此示例摘自一个更大的示例为提供<xref:System.Net.Security.SslStream>类。  
  
 [!code-cpp[NclSslClientAsync#6](~/samples/snippets/cpp/VS_Snippets_Remoting/NclSslClientAsync/CPP/NclSslClientAsync.cpp#6)]
 [!code-csharp[NclSslClientAsync#6](~/samples/snippets/csharp/VS_Snippets_Remoting/NclSslClientAsync/CS/clientasync.cs#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="innerStream" /> 不可读。  -或-  <paramref name="innerStream" /> 不可写。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="innerStream" /> 为 <see langword="null" />。  -或-  <paramref name="innerStream" /> 等于 <see cref="F:System.IO.Stream.Null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SslStream (System.IO.Stream innerStream, bool leaveInnerStreamOpen, System.Net.Security.RemoteCertificateValidationCallback userCertificateValidationCallback, System.Net.Security.LocalCertificateSelectionCallback userCertificateSelectionCallback, System.Net.Security.EncryptionPolicy encryptionPolicy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.IO.Stream innerStream, bool leaveInnerStreamOpen, class System.Net.Security.RemoteCertificateValidationCallback userCertificateValidationCallback, class System.Net.Security.LocalCertificateSelectionCallback userCertificateSelectionCallback, valuetype System.Net.Security.EncryptionPolicy encryptionPolicy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.SslStream.#ctor(System.IO.Stream,System.Boolean,System.Net.Security.RemoteCertificateValidationCallback,System.Net.Security.LocalCertificateSelectionCallback,System.Net.Security.EncryptionPolicy)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; SslStream(System::IO::Stream ^ innerStream, bool leaveInnerStreamOpen, System::Net::Security::RemoteCertificateValidationCallback ^ userCertificateValidationCallback, System::Net::Security::LocalCertificateSelectionCallback ^ userCertificateSelectionCallback, System::Net::Security::EncryptionPolicy encryptionPolicy);" />
      <MemberSignature Language="F#" Value="new System.Net.Security.SslStream : System.IO.Stream * bool * System.Net.Security.RemoteCertificateValidationCallback * System.Net.Security.LocalCertificateSelectionCallback * System.Net.Security.EncryptionPolicy -&gt; System.Net.Security.SslStream" Usage="new System.Net.Security.SslStream (innerStream, leaveInnerStreamOpen, userCertificateValidationCallback, userCertificateSelectionCallback, encryptionPolicy)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoLimitation("encryptionPolicy is ignored")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="innerStream" Type="System.IO.Stream" />
        <Parameter Name="leaveInnerStreamOpen" Type="System.Boolean" />
        <Parameter Name="userCertificateValidationCallback" Type="System.Net.Security.RemoteCertificateValidationCallback" />
        <Parameter Name="userCertificateSelectionCallback" Type="System.Net.Security.LocalCertificateSelectionCallback" />
        <Parameter Name="encryptionPolicy" Type="System.Net.Security.EncryptionPolicy" />
      </Parameters>
      <Docs>
        <param name="innerStream">一个 <see cref="T:System.IO.Stream" /> 对象，<see cref="T:System.Net.Security.SslStream" /> 使用此对象发送和接收数据。</param>
        <param name="leaveInnerStreamOpen">一个布尔值，它指示 <see cref="T:System.IO.Stream" /> 用来发送和接收数据的 <see cref="T:System.Net.Security.SslStream" /> 对象的封闭行为。 此参数指示内部流是否保持打开状态。</param>
        <param name="userCertificateValidationCallback">
          <see cref="T:System.Net.Security.RemoteCertificateValidationCallback" /> 委托，负责验证远程方提供的证书。</param>
        <param name="userCertificateSelectionCallback">
          <see cref="T:System.Net.Security.LocalCertificateSelectionCallback" /> 委托，负责选择用于身份验证的证书。</param>
        <param name="encryptionPolicy">要使用的 <see cref="T:System.Net.Security.EncryptionPolicy" />。</param>
        <summary>使用指定的 <see cref="T:System.Net.Security.SslStream" /> 初始化 <see cref="T:System.IO.Stream" /> 类的新实例</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用 Null 密码时，必须`encryptionPolicy`参数设置为<xref:System.Net.Security.EncryptionPolicy.NoEncryption?displayProperty=nameWithType>。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="innerStream" /> 不可读。  -或-  <paramref name="innerStream" /> 不可写。  -或-  <paramref name="encryptionPolicy" /> 无效。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="innerStream" /> 为 <see langword="null" />。  -或-  <paramref name="innerStream" /> 等于 <see cref="F:System.IO.Stream.Null" />。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="AuthenticateAsClient">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>对客户端-服务器连接的客户端进行身份验证。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AuthenticateAsClient">
      <MemberSignature Language="C#" Value="public virtual void AuthenticateAsClient (string targetHost);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void AuthenticateAsClient(string targetHost) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.SslStream.AuthenticateAsClient(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub AuthenticateAsClient (targetHost As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void AuthenticateAsClient(System::String ^ targetHost);" />
      <MemberSignature Language="F#" Value="abstract member AuthenticateAsClient : string -&gt; unit&#xA;override this.AuthenticateAsClient : string -&gt; unit" Usage="sslStream.AuthenticateAsClient targetHost" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Mono.Net.Security.IMonoSslStream.AuthenticateAsClient(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="targetHost" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="targetHost">共享此 <see cref="T:System.Net.Security.SslStream" /> 的服务器名称。</param>
        <summary>由客户端调用，以对服务器或客户端服务器连接中的客户端（可选）进行身份验证。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [!INCLUDE[sslprotocols-none](~/includes/sslprotocols-none-md.md)] 任何客户端证书身份验证中不使用。 在身份验证期间不检查证书吊销列表。 为指定的值`targetHost`必须与服务器的证书上的名称相匹配。  
  
 当身份验证成功时，必须检查<xref:System.Net.Security.SslStream.IsEncrypted%2A>并<xref:System.Net.Security.SslStream.IsSigned%2A>属性以确定由哪些安全服务<xref:System.Net.Security.SslStream>。 检查<xref:System.Net.Security.SslStream.IsMutuallyAuthenticated%2A>属性以确定是否发生了相互身份验证。  
  
 如果身份验证失败，则收到<xref:System.Security.Authentication.AuthenticationException>，并且此<xref:System.Net.Security.SslStream>已不再使用。 应关闭此对象，并删除对它的所有引用，以便它可以收集的垃圾回收器。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="targetHost" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.Security.Authentication.AuthenticationException">身份验证失败，并使此对象处于不可用的状态。</exception>
        <exception cref="T:System.InvalidOperationException">已进行了身份验证。  -或-  之前已尝试使用此 <see cref="T:System.Net.Security.SslStream" /> 进行了服务器身份验证。  -或-  身份验证已在进行中。</exception>
        <exception cref="T:System.ObjectDisposedException">此对象已关闭。</exception>
      </Docs>
    </Member>
    <Member MemberName="AuthenticateAsClient">
      <MemberSignature Language="C#" Value="public virtual void AuthenticateAsClient (string targetHost, System.Security.Cryptography.X509Certificates.X509CertificateCollection clientCertificates, bool checkCertificateRevocation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void AuthenticateAsClient(string targetHost, class System.Security.Cryptography.X509Certificates.X509CertificateCollection clientCertificates, bool checkCertificateRevocation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.SslStream.AuthenticateAsClient(System.String,System.Security.Cryptography.X509Certificates.X509CertificateCollection,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub AuthenticateAsClient (targetHost As String, clientCertificates As X509CertificateCollection, checkCertificateRevocation As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void AuthenticateAsClient(System::String ^ targetHost, System::Security::Cryptography::X509Certificates::X509CertificateCollection ^ clientCertificates, bool checkCertificateRevocation);" />
      <MemberSignature Language="F#" Value="abstract member AuthenticateAsClient : string * System.Security.Cryptography.X509Certificates.X509CertificateCollection * bool -&gt; unit&#xA;override this.AuthenticateAsClient : string * System.Security.Cryptography.X509Certificates.X509CertificateCollection * bool -&gt; unit" Usage="sslStream.AuthenticateAsClient (targetHost, clientCertificates, checkCertificateRevocation)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="targetHost" Type="System.String" />
        <Parameter Name="clientCertificates" Type="System.Security.Cryptography.X509Certificates.X509CertificateCollection" />
        <Parameter Name="checkCertificateRevocation" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="targetHost">将共享此 <see cref="T:System.Net.Security.SslStream" /> 的服务器名称。</param>
        <param name="clientCertificates">包含客户端证书的 <see cref="T:System.Security.Cryptography.X509Certificates.X509CertificateCollection" />。</param>
        <param name="checkCertificateRevocation">一个 <see cref="T:System.Boolean" /> 值，该值指定身份验证期间是否检查证书吊销列表。</param>
        <summary>由客户端调用，以对服务器或客户端服务器连接中的客户端（可选）进行身份验证。 身份验证过程使用指定的证书集合和系统默认的 SSL 协议。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [!INCLUDE[sslprotocols-none](~/includes/sslprotocols-none-md.md)]
 
 当身份验证成功时，必须检查<xref:System.Net.Security.SslStream.IsEncrypted%2A>并<xref:System.Net.Security.SslStream.IsSigned%2A>属性以确定由哪些安全服务<xref:System.Net.Security.SslStream>。 检查<xref:System.Net.Security.SslStream.IsMutuallyAuthenticated%2A>属性以确定是否发生了相互身份验证。  
  
 如果身份验证失败，则收到<xref:System.Security.Authentication.AuthenticationException>，并且此<xref:System.Net.Security.SslStream>已不再使用。 应关闭此对象，并删除对它的所有引用，以便它可以收集的垃圾回收器。  
  
> [!NOTE]
>  不支持 SSL 版本 2 协议在客户端证书。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AuthenticateAsClient">
      <MemberSignature Language="C#" Value="public virtual void AuthenticateAsClient (string targetHost, System.Security.Cryptography.X509Certificates.X509CertificateCollection clientCertificates, System.Security.Authentication.SslProtocols enabledSslProtocols, bool checkCertificateRevocation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void AuthenticateAsClient(string targetHost, class System.Security.Cryptography.X509Certificates.X509CertificateCollection clientCertificates, valuetype System.Security.Authentication.SslProtocols enabledSslProtocols, bool checkCertificateRevocation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.SslStream.AuthenticateAsClient(System.String,System.Security.Cryptography.X509Certificates.X509CertificateCollection,System.Security.Authentication.SslProtocols,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub AuthenticateAsClient (targetHost As String, clientCertificates As X509CertificateCollection, enabledSslProtocols As SslProtocols, checkCertificateRevocation As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void AuthenticateAsClient(System::String ^ targetHost, System::Security::Cryptography::X509Certificates::X509CertificateCollection ^ clientCertificates, System::Security::Authentication::SslProtocols enabledSslProtocols, bool checkCertificateRevocation);" />
      <MemberSignature Language="F#" Value="abstract member AuthenticateAsClient : string * System.Security.Cryptography.X509Certificates.X509CertificateCollection * System.Security.Authentication.SslProtocols * bool -&gt; unit&#xA;override this.AuthenticateAsClient : string * System.Security.Cryptography.X509Certificates.X509CertificateCollection * System.Security.Authentication.SslProtocols * bool -&gt; unit" Usage="sslStream.AuthenticateAsClient (targetHost, clientCertificates, enabledSslProtocols, checkCertificateRevocation)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Mono.Net.Security.IMonoSslStream.AuthenticateAsClient(System.String,System.Security.Cryptography.X509Certificates.X509CertificateCollection,System.Security.Authentication.SslProtocols,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="targetHost" Type="System.String" />
        <Parameter Name="clientCertificates" Type="System.Security.Cryptography.X509Certificates.X509CertificateCollection" />
        <Parameter Name="enabledSslProtocols" Type="System.Security.Authentication.SslProtocols" />
        <Parameter Name="checkCertificateRevocation" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="targetHost">将共享此 <see cref="T:System.Net.Security.SslStream" /> 的服务器名称。</param>
        <param name="clientCertificates">包含客户端证书的 <see cref="T:System.Security.Cryptography.X509Certificates.X509CertificateCollection" />。</param>
        <param name="enabledSslProtocols">代表用于身份验证的协议的 <see cref="T:System.Security.Authentication.SslProtocols" /> 值。</param>
        <param name="checkCertificateRevocation">一个 <see cref="T:System.Boolean" /> 值，该值指定身份验证期间是否检查证书吊销列表。</param>
        <summary>由客户端调用，以对服务器或客户端服务器连接中的客户端（可选）进行身份验证。 身份验证过程使用指定的证书集合和 SSL 协议。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [!INCLUDE[sslprotocols-none](~/includes/sslprotocols-none-md.md)]
 
 当身份验证成功时，必须检查<xref:System.Net.Security.SslStream.IsEncrypted%2A>并<xref:System.Net.Security.SslStream.IsSigned%2A>属性以确定由哪些安全服务<xref:System.Net.Security.SslStream>。 检查<xref:System.Net.Security.SslStream.IsMutuallyAuthenticated%2A>属性以确定是否发生了相互身份验证。  
  
 如果身份验证失败，则收到<xref:System.Security.Authentication.AuthenticationException>，并且此<xref:System.Net.Security.SslStream>已不再使用。 应关闭此对象，并删除对它的所有引用，以便它可以收集的垃圾回收器。  
  
> [!NOTE]
>  不支持 SSL 版本 2 协议在客户端证书。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AuthenticateAsClientAsync">
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>对客户端-服务器连接中的客户端进行身份验证以作为异步操作。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AuthenticateAsClientAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task AuthenticateAsClientAsync (string targetHost);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task AuthenticateAsClientAsync(string targetHost) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.SslStream.AuthenticateAsClientAsync(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function AuthenticateAsClientAsync (targetHost As String) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task ^ AuthenticateAsClientAsync(System::String ^ targetHost);" />
      <MemberSignature Language="F#" Value="abstract member AuthenticateAsClientAsync : string -&gt; System.Threading.Tasks.Task&#xA;override this.AuthenticateAsClientAsync : string -&gt; System.Threading.Tasks.Task" Usage="sslStream.AuthenticateAsClientAsync targetHost" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Mono.Net.Security.IMonoSslStream.AuthenticateAsClientAsync(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="targetHost" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="targetHost">共享此 <see cref="T:System.Net.Security.SslStream" /> 的服务器名称。</param>
        <summary>由客户端调用，以对服务器或客户端服务器连接中的客户端（可选）进行身份验证，此为异步操作。</summary>
        <returns>返回 <see cref="T:System.Threading.Tasks.Task" />  表示异步操作的任务对象。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [!INCLUDE[sslprotocols-none](~/includes/sslprotocols-none-md.md)] 任何客户端证书身份验证中不使用。 在身份验证期间不检查证书吊销列表。 为指定的值`targetHost`必须与服务器的证书上的名称相匹配。  
  
 当身份验证成功时，必须检查<xref:System.Net.Security.SslStream.IsEncrypted%2A>并<xref:System.Net.Security.SslStream.IsSigned%2A>属性以确定由哪些安全服务<xref:System.Net.Security.SslStream>。 检查<xref:System.Net.Security.SslStream.IsMutuallyAuthenticated%2A>属性以确定是否发生了相互身份验证。  
  
 如果身份验证失败，则收到<xref:System.Security.Authentication.AuthenticationException>，并且此<xref:System.Net.Security.SslStream>已不再使用。 应关闭此对象，并删除对它的所有引用，以便它可以收集的垃圾回收器。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="targetHost" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.Security.Authentication.AuthenticationException">身份验证失败，并使此对象处于不可用的状态。</exception>
        <exception cref="T:System.InvalidOperationException">已进行了身份验证。  -或-  之前已尝试使用此 <see cref="T:System.Net.Security.SslStream" /> 进行了服务器身份验证。  -或-  身份验证已在进行中。</exception>
        <exception cref="T:System.ObjectDisposedException">此对象已关闭。</exception>
      </Docs>
    </Member>
    <Member MemberName="AuthenticateAsClientAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task AuthenticateAsClientAsync (System.Net.Security.SslClientAuthenticationOptions sslClientAuthenticationOptions, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task AuthenticateAsClientAsync(class System.Net.Security.SslClientAuthenticationOptions sslClientAuthenticationOptions, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.SslStream.AuthenticateAsClientAsync(System.Net.Security.SslClientAuthenticationOptions,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ AuthenticateAsClientAsync(System::Net::Security::SslClientAuthenticationOptions ^ sslClientAuthenticationOptions, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="member this.AuthenticateAsClientAsync : System.Net.Security.SslClientAuthenticationOptions * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="sslStream.AuthenticateAsClientAsync (sslClientAuthenticationOptions, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sslClientAuthenticationOptions" Type="System.Net.Security.SslClientAuthenticationOptions" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="sslClientAuthenticationOptions">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AuthenticateAsClientAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task AuthenticateAsClientAsync (string targetHost, System.Security.Cryptography.X509Certificates.X509CertificateCollection clientCertificates, bool checkCertificateRevocation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task AuthenticateAsClientAsync(string targetHost, class System.Security.Cryptography.X509Certificates.X509CertificateCollection clientCertificates, bool checkCertificateRevocation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.SslStream.AuthenticateAsClientAsync(System.String,System.Security.Cryptography.X509Certificates.X509CertificateCollection,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function AuthenticateAsClientAsync (targetHost As String, clientCertificates As X509CertificateCollection, checkCertificateRevocation As Boolean) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task ^ AuthenticateAsClientAsync(System::String ^ targetHost, System::Security::Cryptography::X509Certificates::X509CertificateCollection ^ clientCertificates, bool checkCertificateRevocation);" />
      <MemberSignature Language="F#" Value="abstract member AuthenticateAsClientAsync : string * System.Security.Cryptography.X509Certificates.X509CertificateCollection * bool -&gt; System.Threading.Tasks.Task&#xA;override this.AuthenticateAsClientAsync : string * System.Security.Cryptography.X509Certificates.X509CertificateCollection * bool -&gt; System.Threading.Tasks.Task" Usage="sslStream.AuthenticateAsClientAsync (targetHost, clientCertificates, checkCertificateRevocation)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="targetHost" Type="System.String" />
        <Parameter Name="clientCertificates" Type="System.Security.Cryptography.X509Certificates.X509CertificateCollection" />
        <Parameter Name="checkCertificateRevocation" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="targetHost">将共享此 <see cref="T:System.Net.Security.SslStream" /> 的服务器名称。</param>
        <param name="clientCertificates">包含客户端证书的 <see cref="T:System.Security.Cryptography.X509Certificates.X509CertificateCollection" />。</param>
        <param name="checkCertificateRevocation">一个 <see cref="T:System.Boolean" /> 值，该值指定身份验证期间是否检查证书吊销列表。</param>
        <summary>由客户端调用，以对服务器或客户端服务器连接中的客户端（可选）进行身份验证，此为异步操作。 身份验证过程使用指定的证书集合和系统默认的 SSL 协议。</summary>
        <returns>表示异步操作的任务对象。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [!INCLUDE[sslprotocols-none](~/includes/sslprotocols-none-md.md)]
 
 当身份验证成功时，必须检查<xref:System.Net.Security.SslStream.IsEncrypted%2A>并<xref:System.Net.Security.SslStream.IsSigned%2A>属性以确定由哪些安全服务<xref:System.Net.Security.SslStream>。 检查<xref:System.Net.Security.SslStream.IsMutuallyAuthenticated%2A>属性以确定是否发生了相互身份验证。  
  
 如果身份验证失败，则收到<xref:System.Security.Authentication.AuthenticationException>，并且此<xref:System.Net.Security.SslStream>已不再使用。 应关闭此对象，并删除对它的所有引用，以便它可以收集的垃圾回收器。  
  
> [!NOTE]
>  不支持 SSL 版本 2 协议在客户端证书。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AuthenticateAsClientAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task AuthenticateAsClientAsync (string targetHost, System.Security.Cryptography.X509Certificates.X509CertificateCollection clientCertificates, System.Security.Authentication.SslProtocols enabledSslProtocols, bool checkCertificateRevocation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task AuthenticateAsClientAsync(string targetHost, class System.Security.Cryptography.X509Certificates.X509CertificateCollection clientCertificates, valuetype System.Security.Authentication.SslProtocols enabledSslProtocols, bool checkCertificateRevocation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.SslStream.AuthenticateAsClientAsync(System.String,System.Security.Cryptography.X509Certificates.X509CertificateCollection,System.Security.Authentication.SslProtocols,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function AuthenticateAsClientAsync (targetHost As String, clientCertificates As X509CertificateCollection, enabledSslProtocols As SslProtocols, checkCertificateRevocation As Boolean) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task ^ AuthenticateAsClientAsync(System::String ^ targetHost, System::Security::Cryptography::X509Certificates::X509CertificateCollection ^ clientCertificates, System::Security::Authentication::SslProtocols enabledSslProtocols, bool checkCertificateRevocation);" />
      <MemberSignature Language="F#" Value="abstract member AuthenticateAsClientAsync : string * System.Security.Cryptography.X509Certificates.X509CertificateCollection * System.Security.Authentication.SslProtocols * bool -&gt; System.Threading.Tasks.Task&#xA;override this.AuthenticateAsClientAsync : string * System.Security.Cryptography.X509Certificates.X509CertificateCollection * System.Security.Authentication.SslProtocols * bool -&gt; System.Threading.Tasks.Task" Usage="sslStream.AuthenticateAsClientAsync (targetHost, clientCertificates, enabledSslProtocols, checkCertificateRevocation)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Mono.Net.Security.IMonoSslStream.AuthenticateAsClientAsync(System.String,System.Security.Cryptography.X509Certificates.X509CertificateCollection,System.Security.Authentication.SslProtocols,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="targetHost" Type="System.String" />
        <Parameter Name="clientCertificates" Type="System.Security.Cryptography.X509Certificates.X509CertificateCollection" />
        <Parameter Name="enabledSslProtocols" Type="System.Security.Authentication.SslProtocols" />
        <Parameter Name="checkCertificateRevocation" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="targetHost">将共享此 <see cref="T:System.Net.Security.SslStream" /> 的服务器名称。</param>
        <param name="clientCertificates">包含客户端证书的 <see cref="T:System.Security.Cryptography.X509Certificates.X509CertificateCollection" />。</param>
        <param name="enabledSslProtocols">代表用于身份验证的协议的 <see cref="T:System.Security.Authentication.SslProtocols" /> 值。</param>
        <param name="checkCertificateRevocation">一个 <see cref="T:System.Boolean" /> 值，该值指定身份验证期间是否检查证书吊销列表。</param>
        <summary>由客户端调用，以对服务器或客户端服务器连接中的客户端（可选）进行身份验证，此为异步操作。 身份验证过程使用指定的证书集合和 SSL 协议。</summary>
        <returns>返回 <see cref="T:System.Threading.Tasks.Task" />  表示异步操作的任务对象。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [!INCLUDE[sslprotocols-none](~/includes/sslprotocols-none-md.md)]
 
 当身份验证成功时，必须检查<xref:System.Net.Security.SslStream.IsEncrypted%2A>并<xref:System.Net.Security.SslStream.IsSigned%2A>属性以确定由哪些安全服务<xref:System.Net.Security.SslStream>。 检查<xref:System.Net.Security.SslStream.IsMutuallyAuthenticated%2A>属性以确定是否发生了相互身份验证。  
  
 如果身份验证失败，则收到<xref:System.Security.Authentication.AuthenticationException>，并且此<xref:System.Net.Security.SslStream>已不再使用。 应关闭此对象，并删除对它的所有引用，以便它可以收集的垃圾回收器。  
  
> [!NOTE]
>  不支持 SSL 版本 2 协议在客户端证书。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AuthenticateAsServer">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>服务器调用此方法，以便对客户端-服务器连接中的服务器及客户端（可选）进行身份验证。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AuthenticateAsServer">
      <MemberSignature Language="C#" Value="public virtual void AuthenticateAsServer (System.Security.Cryptography.X509Certificates.X509Certificate serverCertificate);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void AuthenticateAsServer(class System.Security.Cryptography.X509Certificates.X509Certificate serverCertificate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.SslStream.AuthenticateAsServer(System.Security.Cryptography.X509Certificates.X509Certificate)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub AuthenticateAsServer (serverCertificate As X509Certificate)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void AuthenticateAsServer(System::Security::Cryptography::X509Certificates::X509Certificate ^ serverCertificate);" />
      <MemberSignature Language="F#" Value="abstract member AuthenticateAsServer : System.Security.Cryptography.X509Certificates.X509Certificate -&gt; unit&#xA;override this.AuthenticateAsServer : System.Security.Cryptography.X509Certificates.X509Certificate -&gt; unit" Usage="sslStream.AuthenticateAsServer serverCertificate" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Mono.Net.Security.IMonoSslStream.AuthenticateAsServer(System.Security.Cryptography.X509Certificates.X509Certificate)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="serverCertificate" Type="System.Security.Cryptography.X509Certificates.X509Certificate" />
      </Parameters>
      <Docs>
        <param name="serverCertificate">用于对服务器进行身份验证的证书。</param>
        <summary>服务器调用此方法，以便使用指定的证书对客户端-服务器连接中的服务器及客户端（可选）进行身份验证。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [!INCLUDE[sslprotocols-none](~/includes/sslprotocols-none-md.md)] 在身份验证期间不检查证书吊销列表。 客户端不需要进行身份验证提供证书。  
  
 此方法进行阻止，直到操作完成。 若要阻止阻塞在操作完成之前，使用之一<xref:System.Net.Security.SslStream.BeginAuthenticateAsServer%2A>方法重载。  
  
 如果身份验证失败，则收到<xref:System.Security.Authentication.AuthenticationException>，并且此<xref:System.Net.Security.SslStream>已不再使用。 应关闭此对象，并删除对它的所有引用，以便它可以收集的垃圾回收器。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="serverCertificate" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.Security.Authentication.AuthenticationException">身份验证失败，并使此对象处于不可用的状态。</exception>
        <exception cref="T:System.InvalidOperationException">已进行了身份验证。  -或-  之前已尝试使用此 <see cref="T:System.Net.Security.SslStream" /> 进行了客户端身份验证。  -或-  身份验证已在进行中。</exception>
        <exception cref="T:System.ObjectDisposedException">此对象已关闭。</exception>
        <exception cref="T:System.PlatformNotSupportedException">Windows 95、Windows 98 或 Windows Millennium 上不支持 <see cref="Overload:System.Net.Security.SslStream.AuthenticateAsServer" /> 方法。</exception>
      </Docs>
    </Member>
    <Member MemberName="AuthenticateAsServer">
      <MemberSignature Language="C#" Value="public virtual void AuthenticateAsServer (System.Security.Cryptography.X509Certificates.X509Certificate serverCertificate, bool clientCertificateRequired, bool checkCertificateRevocation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void AuthenticateAsServer(class System.Security.Cryptography.X509Certificates.X509Certificate serverCertificate, bool clientCertificateRequired, bool checkCertificateRevocation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.SslStream.AuthenticateAsServer(System.Security.Cryptography.X509Certificates.X509Certificate,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub AuthenticateAsServer (serverCertificate As X509Certificate, clientCertificateRequired As Boolean, checkCertificateRevocation As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void AuthenticateAsServer(System::Security::Cryptography::X509Certificates::X509Certificate ^ serverCertificate, bool clientCertificateRequired, bool checkCertificateRevocation);" />
      <MemberSignature Language="F#" Value="abstract member AuthenticateAsServer : System.Security.Cryptography.X509Certificates.X509Certificate * bool * bool -&gt; unit&#xA;override this.AuthenticateAsServer : System.Security.Cryptography.X509Certificates.X509Certificate * bool * bool -&gt; unit" Usage="sslStream.AuthenticateAsServer (serverCertificate, clientCertificateRequired, checkCertificateRevocation)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="serverCertificate" Type="System.Security.Cryptography.X509Certificates.X509Certificate" />
        <Parameter Name="clientCertificateRequired" Type="System.Boolean" />
        <Parameter Name="checkCertificateRevocation" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="serverCertificate">用于对服务器进行身份验证的 X509Certificate 。</param>
        <param name="clientCertificateRequired">一个 <see cref="T:System.Boolean" /> 值，该值指定是否向客户端请求证书用于进行身份验证。 请注意，这只是一个请求 - 如果没有提供任何证书，服务器仍然可接受连接请求。</param>
        <param name="checkCertificateRevocation">一个 <see cref="T:System.Boolean" /> 值，该值指定身份验证期间是否检查证书吊销列表。</param>
        <summary>由服务器调用，以使用指定的证书、要求和系统默认安全协议在客户端 - 服务器连接中对服务器和客户端（可选）进行身份验证。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [!INCLUDE[sslprotocols-none](~/includes/sslprotocols-none-md.md)]
 
 此方法进行阻止，直到操作完成。 若要阻止阻塞在操作完成之前，使用之一<xref:System.Net.Security.SslStream.BeginAuthenticateAsServer%2A>方法重载。  
  
 如果身份验证失败，则收到<xref:System.Security.Authentication.AuthenticationException>，并且此<xref:System.Net.Security.SslStream>已不再使用。 应关闭此对象，并删除对它的所有引用，以便它可以收集的垃圾回收器。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="serverCertificate" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.Security.Authentication.AuthenticationException">身份验证失败，并使此对象处于不可用的状态。</exception>
        <exception cref="T:System.InvalidOperationException">已进行了身份验证。  -或-  之前已尝试使用此 <see cref="T:System.Net.Security.SslStream" /> 进行了客户端身份验证。  -或-  身份验证已在进行中。</exception>
        <exception cref="T:System.ObjectDisposedException">此对象已关闭。</exception>
        <exception cref="T:System.PlatformNotSupportedException">Windows 95、Windows 98 或 Windows Millennium 上不支持 <see cref="Overload:System.Net.Security.SslStream.AuthenticateAsServer" /> 方法。</exception>
      </Docs>
    </Member>
    <Member MemberName="AuthenticateAsServer">
      <MemberSignature Language="C#" Value="public virtual void AuthenticateAsServer (System.Security.Cryptography.X509Certificates.X509Certificate serverCertificate, bool clientCertificateRequired, System.Security.Authentication.SslProtocols enabledSslProtocols, bool checkCertificateRevocation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void AuthenticateAsServer(class System.Security.Cryptography.X509Certificates.X509Certificate serverCertificate, bool clientCertificateRequired, valuetype System.Security.Authentication.SslProtocols enabledSslProtocols, bool checkCertificateRevocation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.SslStream.AuthenticateAsServer(System.Security.Cryptography.X509Certificates.X509Certificate,System.Boolean,System.Security.Authentication.SslProtocols,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub AuthenticateAsServer (serverCertificate As X509Certificate, clientCertificateRequired As Boolean, enabledSslProtocols As SslProtocols, checkCertificateRevocation As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void AuthenticateAsServer(System::Security::Cryptography::X509Certificates::X509Certificate ^ serverCertificate, bool clientCertificateRequired, System::Security::Authentication::SslProtocols enabledSslProtocols, bool checkCertificateRevocation);" />
      <MemberSignature Language="F#" Value="abstract member AuthenticateAsServer : System.Security.Cryptography.X509Certificates.X509Certificate * bool * System.Security.Authentication.SslProtocols * bool -&gt; unit&#xA;override this.AuthenticateAsServer : System.Security.Cryptography.X509Certificates.X509Certificate * bool * System.Security.Authentication.SslProtocols * bool -&gt; unit" Usage="sslStream.AuthenticateAsServer (serverCertificate, clientCertificateRequired, enabledSslProtocols, checkCertificateRevocation)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Mono.Net.Security.IMonoSslStream.AuthenticateAsServer(System.Security.Cryptography.X509Certificates.X509Certificate,System.Boolean,System.Security.Authentication.SslProtocols,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="serverCertificate" Type="System.Security.Cryptography.X509Certificates.X509Certificate" />
        <Parameter Name="clientCertificateRequired" Type="System.Boolean" />
        <Parameter Name="enabledSslProtocols" Type="System.Security.Authentication.SslProtocols" />
        <Parameter Name="checkCertificateRevocation" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="serverCertificate">用于对服务器进行身份验证的 X509Certificate 。</param>
        <param name="clientCertificateRequired">一个 <see cref="T:System.Boolean" /> 值，该值指定是否向客户端请求证书用于进行身份验证。 请注意，这只是一个请求 - 如果没有提供任何证书，服务器仍然可接受连接请求。</param>
        <param name="enabledSslProtocols">代表用于身份验证的协议的 <see cref="T:System.Security.Authentication.SslProtocols" /> 值。</param>
        <param name="checkCertificateRevocation">一个 <see cref="T:System.Boolean" /> 值，该值指定身份验证期间是否检查证书吊销列表。</param>
        <summary>由服务器调用，以使用指定的证书、要求和安全协议在客户端 - 服务器连接中对服务器和客户端（可选）进行身份验证。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [!INCLUDE[sslprotocols-none](~/includes/sslprotocols-none-md.md)]
 
 此方法进行阻止，直到操作完成。 若要阻止阻塞在操作完成之前，使用之一<xref:System.Net.Security.SslStream.BeginAuthenticateAsServer%2A>方法重载。  
  
 如果身份验证失败，则收到<xref:System.Security.Authentication.AuthenticationException>，并且此<xref:System.Net.Security.SslStream>已不再使用。 应关闭此对象，并删除对它的所有引用，以便它可以收集的垃圾回收器。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="serverCertificate" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="enabledSslProtocols" /> 不是有效的 <see cref="T:System.Security.Authentication.SslProtocols" /> 值。</exception>
        <exception cref="T:System.Security.Authentication.AuthenticationException">身份验证失败，并使此对象处于不可用的状态。</exception>
        <exception cref="T:System.InvalidOperationException">已进行了身份验证。  -或-  之前已尝试使用此 <see cref="T:System.Net.Security.SslStream" /> 进行了客户端身份验证。  -或-  身份验证已在进行中。</exception>
        <exception cref="T:System.ObjectDisposedException">此对象已关闭。</exception>
        <exception cref="T:System.PlatformNotSupportedException">Windows 95、Windows 98 或 Windows Millennium 上不支持 <see cref="Overload:System.Net.Security.SslStream.AuthenticateAsServer" /> 方法。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="AuthenticateAsServerAsync">
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>服务器调用此方法，对客户端-服务器连接中的服务器及客户端（可选）进行身份验证以作为异步操作。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AuthenticateAsServerAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task AuthenticateAsServerAsync (System.Security.Cryptography.X509Certificates.X509Certificate serverCertificate);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task AuthenticateAsServerAsync(class System.Security.Cryptography.X509Certificates.X509Certificate serverCertificate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.SslStream.AuthenticateAsServerAsync(System.Security.Cryptography.X509Certificates.X509Certificate)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function AuthenticateAsServerAsync (serverCertificate As X509Certificate) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task ^ AuthenticateAsServerAsync(System::Security::Cryptography::X509Certificates::X509Certificate ^ serverCertificate);" />
      <MemberSignature Language="F#" Value="abstract member AuthenticateAsServerAsync : System.Security.Cryptography.X509Certificates.X509Certificate -&gt; System.Threading.Tasks.Task&#xA;override this.AuthenticateAsServerAsync : System.Security.Cryptography.X509Certificates.X509Certificate -&gt; System.Threading.Tasks.Task" Usage="sslStream.AuthenticateAsServerAsync serverCertificate" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Mono.Net.Security.IMonoSslStream.AuthenticateAsServerAsync(System.Security.Cryptography.X509Certificates.X509Certificate)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="serverCertificate" Type="System.Security.Cryptography.X509Certificates.X509Certificate" />
      </Parameters>
      <Docs>
        <param name="serverCertificate">用于对服务器进行身份验证的证书。</param>
        <summary>服务器调用此方法，使用指定的证书对客户端-服务器连接中的服务器及客户端（可选）进行身份验证以作为异步操作。</summary>
        <returns>返回 <see cref="T:System.Threading.Tasks.Task" />  表示异步操作的任务对象。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [!INCLUDE[sslprotocols-none](~/includes/sslprotocols-none-md.md)]
 
 此方法进行身份验证使用<xref:System.Security.Authentication.SslProtocols.Default>。 在身份验证期间不检查证书吊销列表。 客户端不需要进行身份验证提供证书。  
  
 如果身份验证失败，则收到<xref:System.Security.Authentication.AuthenticationException>，并且此<xref:System.Net.Security.SslStream>已不再使用。 应关闭此对象，并删除对它的所有引用，以便它可以收集的垃圾回收器。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="serverCertificate" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.Security.Authentication.AuthenticationException">身份验证失败，并使此对象处于不可用的状态。</exception>
        <exception cref="T:System.InvalidOperationException">已进行了身份验证。  -或-  之前已尝试使用此 <see cref="T:System.Net.Security.SslStream" /> 进行了客户端身份验证。  -或-  身份验证已在进行中。</exception>
        <exception cref="T:System.ObjectDisposedException">此对象已关闭。</exception>
        <exception cref="T:System.PlatformNotSupportedException">Windows 95、Windows 98 或 Windows Millennium 上不支持 <see cref="Overload:System.Net.Security.SslStream.AuthenticateAsServerAsync" /> 方法。</exception>
      </Docs>
    </Member>
    <Member MemberName="AuthenticateAsServerAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task AuthenticateAsServerAsync (System.Net.Security.SslServerAuthenticationOptions sslServerAuthenticationOptions, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task AuthenticateAsServerAsync(class System.Net.Security.SslServerAuthenticationOptions sslServerAuthenticationOptions, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.SslStream.AuthenticateAsServerAsync(System.Net.Security.SslServerAuthenticationOptions,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ AuthenticateAsServerAsync(System::Net::Security::SslServerAuthenticationOptions ^ sslServerAuthenticationOptions, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="member this.AuthenticateAsServerAsync : System.Net.Security.SslServerAuthenticationOptions * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="sslStream.AuthenticateAsServerAsync (sslServerAuthenticationOptions, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sslServerAuthenticationOptions" Type="System.Net.Security.SslServerAuthenticationOptions" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="sslServerAuthenticationOptions">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AuthenticateAsServerAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task AuthenticateAsServerAsync (System.Security.Cryptography.X509Certificates.X509Certificate serverCertificate, bool clientCertificateRequired, bool checkCertificateRevocation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task AuthenticateAsServerAsync(class System.Security.Cryptography.X509Certificates.X509Certificate serverCertificate, bool clientCertificateRequired, bool checkCertificateRevocation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.SslStream.AuthenticateAsServerAsync(System.Security.Cryptography.X509Certificates.X509Certificate,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function AuthenticateAsServerAsync (serverCertificate As X509Certificate, clientCertificateRequired As Boolean, checkCertificateRevocation As Boolean) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task ^ AuthenticateAsServerAsync(System::Security::Cryptography::X509Certificates::X509Certificate ^ serverCertificate, bool clientCertificateRequired, bool checkCertificateRevocation);" />
      <MemberSignature Language="F#" Value="abstract member AuthenticateAsServerAsync : System.Security.Cryptography.X509Certificates.X509Certificate * bool * bool -&gt; System.Threading.Tasks.Task&#xA;override this.AuthenticateAsServerAsync : System.Security.Cryptography.X509Certificates.X509Certificate * bool * bool -&gt; System.Threading.Tasks.Task" Usage="sslStream.AuthenticateAsServerAsync (serverCertificate, clientCertificateRequired, checkCertificateRevocation)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="serverCertificate" Type="System.Security.Cryptography.X509Certificates.X509Certificate" />
        <Parameter Name="clientCertificateRequired" Type="System.Boolean" />
        <Parameter Name="checkCertificateRevocation" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="serverCertificate">用于对服务器进行身份验证的 X509Certificate 。</param>
        <param name="clientCertificateRequired">一个 <see cref="T:System.Boolean" /> 值，该值指定是否向客户端请求证书用于进行身份验证。 请注意，这只是一个请求 - 如果没有提供任何证书，服务器仍然可接受连接请求。</param>
        <param name="checkCertificateRevocation">一个 <see cref="T:System.Boolean" /> 值，该值指定身份验证期间是否检查证书吊销列表。</param>
        <summary>由服务器调用，以通过异步操作的形式使用指定的证书、要求和安全协议对客户端 - 服务器连接中的服务器和客户端（可选）进行身份验证。</summary>
        <returns>表示异步操作的任务对象。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [!INCLUDE[sslprotocols-none](~/includes/sslprotocols-none-md.md)]
 
 如果身份验证失败，则收到<xref:System.Security.Authentication.AuthenticationException>，并且此<xref:System.Net.Security.SslStream>已不再使用。 应关闭此对象，并删除对它的所有引用，以便它可以收集的垃圾回收器。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AuthenticateAsServerAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task AuthenticateAsServerAsync (System.Security.Cryptography.X509Certificates.X509Certificate serverCertificate, bool clientCertificateRequired, System.Security.Authentication.SslProtocols enabledSslProtocols, bool checkCertificateRevocation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task AuthenticateAsServerAsync(class System.Security.Cryptography.X509Certificates.X509Certificate serverCertificate, bool clientCertificateRequired, valuetype System.Security.Authentication.SslProtocols enabledSslProtocols, bool checkCertificateRevocation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.SslStream.AuthenticateAsServerAsync(System.Security.Cryptography.X509Certificates.X509Certificate,System.Boolean,System.Security.Authentication.SslProtocols,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function AuthenticateAsServerAsync (serverCertificate As X509Certificate, clientCertificateRequired As Boolean, enabledSslProtocols As SslProtocols, checkCertificateRevocation As Boolean) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task ^ AuthenticateAsServerAsync(System::Security::Cryptography::X509Certificates::X509Certificate ^ serverCertificate, bool clientCertificateRequired, System::Security::Authentication::SslProtocols enabledSslProtocols, bool checkCertificateRevocation);" />
      <MemberSignature Language="F#" Value="abstract member AuthenticateAsServerAsync : System.Security.Cryptography.X509Certificates.X509Certificate * bool * System.Security.Authentication.SslProtocols * bool -&gt; System.Threading.Tasks.Task&#xA;override this.AuthenticateAsServerAsync : System.Security.Cryptography.X509Certificates.X509Certificate * bool * System.Security.Authentication.SslProtocols * bool -&gt; System.Threading.Tasks.Task" Usage="sslStream.AuthenticateAsServerAsync (serverCertificate, clientCertificateRequired, enabledSslProtocols, checkCertificateRevocation)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Mono.Net.Security.IMonoSslStream.AuthenticateAsServerAsync(System.Security.Cryptography.X509Certificates.X509Certificate,System.Boolean,System.Security.Authentication.SslProtocols,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="serverCertificate" Type="System.Security.Cryptography.X509Certificates.X509Certificate" />
        <Parameter Name="clientCertificateRequired" Type="System.Boolean" />
        <Parameter Name="enabledSslProtocols" Type="System.Security.Authentication.SslProtocols" />
        <Parameter Name="checkCertificateRevocation" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="serverCertificate">用于对服务器进行身份验证的 X509Certificate 。</param>
        <param name="clientCertificateRequired">一个 <see cref="T:System.Boolean" /> 值，该值指定是否向客户端请求证书用于进行身份验证。 请注意，这只是一个请求 - 如果没有提供任何证书，服务器仍然可接受连接请求。</param>
        <param name="enabledSslProtocols">代表用于身份验证的协议的 <see cref="T:System.Security.Authentication.SslProtocols" /> 值。</param>
        <param name="checkCertificateRevocation">一个 <see cref="T:System.Boolean" /> 值，该值指定身份验证期间是否检查证书吊销列表。</param>
        <summary>由服务器调用，以通过异步操作的形式使用指定的证书、要求和安全协议对客户端 - 服务器连接中的服务器和客户端（可选）进行身份验证。</summary>
        <returns>返回 <see cref="T:System.Threading.Tasks.Task" />  表示异步操作的任务对象。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [!INCLUDE[sslprotocols-none](~/includes/sslprotocols-none-md.md)]
 
 如果身份验证失败，则收到<xref:System.Security.Authentication.AuthenticationException>，并且此<xref:System.Net.Security.SslStream>已不再使用。 应关闭此对象，并删除对它的所有引用，以便它可以收集的垃圾回收器。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginAuthenticateAsClient">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>开始一个操作，以对客户端-服务器连接中的客户端进行身份验证。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在进行身份验证时不会阻止此方法的重载。 若要阻止等待进行身份验证完成时，请使用其中一个<xref:System.Net.Security.SslStream.AuthenticateAsClient%2A>方法。  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginAuthenticateAsClient">
      <MemberSignature Language="C#" Value="public virtual IAsyncResult BeginAuthenticateAsClient (string targetHost, AsyncCallback asyncCallback, object asyncState);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginAuthenticateAsClient(string targetHost, class System.AsyncCallback asyncCallback, object asyncState) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.SslStream.BeginAuthenticateAsClient(System.String,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginAuthenticateAsClient(System::String ^ targetHost, AsyncCallback ^ asyncCallback, System::Object ^ asyncState);" />
      <MemberSignature Language="F#" Value="abstract member BeginAuthenticateAsClient : string * AsyncCallback * obj -&gt; IAsyncResult&#xA;override this.BeginAuthenticateAsClient : string * AsyncCallback * obj -&gt; IAsyncResult" Usage="sslStream.BeginAuthenticateAsClient (targetHost, asyncCallback, asyncState)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Mono.Net.Security.IMonoSslStream.BeginAuthenticateAsClient(System.String,System.AsyncCallback,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="targetHost" Type="System.String" />
        <Parameter Name="asyncCallback" Type="System.AsyncCallback" />
        <Parameter Name="asyncState" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="targetHost">共享此 <see cref="T:System.Net.Security.SslStream" /> 的服务器名称。</param>
        <param name="asyncCallback">一个 <see cref="T:System.AsyncCallback" /> 委托，该委托引用当身份验证完成时要调用的方法。</param>
        <param name="asyncState">一个用户定义对象，其中包含操作的相关信息。 当操作完成后，此对象会被传递给 asyncCallback<c></c> 委托。</param>
        <summary>客户端调用此方法，以便开始一个异步操作，对服务器及客户端（可选）进行身份验证。</summary>
        <returns>一个指示异步操作状态的 <see cref="T:System.IAsyncResult" /> 对象。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [!INCLUDE[sslprotocols-none](~/includes/sslprotocols-none-md.md)] 任何客户端证书身份验证中不使用。 在身份验证期间不检查证书吊销列表。  
  
 为指定的值`targetHost`必须与服务器的证书上的名称相匹配。  
  
 必须通过调用完成异步验证操作<xref:System.Net.Security.SslStream.EndAuthenticateAsClient%2A>方法。 通常情况下，通过调用该方法`asyncCallback`委托。  
  
 在操作完成时，此方法不会阻止。 若要阻止在操作完成之前，请使用其中一个<xref:System.Net.Security.SslStream.AuthenticateAsClient%2A>方法重载。  
  
 有关使用异步编程模型的详细信息，请参阅[异步调用同步方法](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)  
  
 如果你收到<xref:System.Security.Authentication.AuthenticationException>，则此<xref:System.Net.Security.SslStream>已不再使用。 应关闭此对象，并删除对它的所有引用，以便它可以收集的垃圾回收器。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="targetHost" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.Security.Authentication.AuthenticationException">身份验证失败，并使此对象处于不可用的状态。</exception>
        <exception cref="T:System.InvalidOperationException">已进行了身份验证。  -或-  之前已尝试使用此 <see cref="T:System.Net.Security.SslStream" /> 进行了服务器身份验证。  -或-  身份验证已在进行中。</exception>
        <exception cref="T:System.ObjectDisposedException">此对象已关闭。</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginAuthenticateAsClient">
      <MemberSignature Language="C#" Value="public virtual IAsyncResult BeginAuthenticateAsClient (string targetHost, System.Security.Cryptography.X509Certificates.X509CertificateCollection clientCertificates, bool checkCertificateRevocation, AsyncCallback asyncCallback, object asyncState);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginAuthenticateAsClient(string targetHost, class System.Security.Cryptography.X509Certificates.X509CertificateCollection clientCertificates, bool checkCertificateRevocation, class System.AsyncCallback asyncCallback, object asyncState) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.SslStream.BeginAuthenticateAsClient(System.String,System.Security.Cryptography.X509Certificates.X509CertificateCollection,System.Boolean,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginAuthenticateAsClient(System::String ^ targetHost, System::Security::Cryptography::X509Certificates::X509CertificateCollection ^ clientCertificates, bool checkCertificateRevocation, AsyncCallback ^ asyncCallback, System::Object ^ asyncState);" />
      <MemberSignature Language="F#" Value="abstract member BeginAuthenticateAsClient : string * System.Security.Cryptography.X509Certificates.X509CertificateCollection * bool * AsyncCallback * obj -&gt; IAsyncResult&#xA;override this.BeginAuthenticateAsClient : string * System.Security.Cryptography.X509Certificates.X509CertificateCollection * bool * AsyncCallback * obj -&gt; IAsyncResult" Usage="sslStream.BeginAuthenticateAsClient (targetHost, clientCertificates, checkCertificateRevocation, asyncCallback, asyncState)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="targetHost" Type="System.String" />
        <Parameter Name="clientCertificates" Type="System.Security.Cryptography.X509Certificates.X509CertificateCollection" />
        <Parameter Name="checkCertificateRevocation" Type="System.Boolean" />
        <Parameter Name="asyncCallback" Type="System.AsyncCallback" />
        <Parameter Name="asyncState" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="targetHost">共享此 <see cref="T:System.Net.Security.SslStream" /> 的服务器名称。</param>
        <param name="clientCertificates">
          <see cref="T:System.Security.Cryptography.X509Certificates.X509CertificateCollection" /> 包含客户端证书。</param>
        <param name="checkCertificateRevocation">一个 <see cref="T:System.Boolean" /> 值，该值指定身份验证期间是否检查证书吊销列表。</param>
        <param name="asyncCallback">一个 <see cref="T:System.AsyncCallback" /> 委托，该委托引用当身份验证完成时要调用的方法。</param>
        <param name="asyncState">一个用户定义对象，其中包含操作的相关信息。 当操作完成后，此对象会被传递给 asyncCallback<c></c> 委托。</param>
        <summary>由客户端调用，以使用指定的证书和系统默认安全协议开始对服务器和客户端（可选）异步进行身份验证。</summary>
        <returns>一个指示异步操作状态的 <see cref="T:System.IAsyncResult" /> 对象。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [!INCLUDE[sslprotocols-none](~/includes/sslprotocols-none-md.md)]
 
 为指定的值`targetHost`必须与服务器的证书上的名称相匹配。  
  
 必须通过调用完成异步验证操作<xref:System.Net.Security.SslStream.EndAuthenticateAsClient%2A>方法。 通常情况下，通过调用该方法`asyncCallback`委托。  
  
 在操作完成时，此方法不会阻止。 若要阻止在操作完成之前，请使用其中一个<xref:System.Net.Security.SslStream.AuthenticateAsClient%2A>方法重载。  
  
 有关使用异步编程模型的详细信息，请参阅[异步调用同步方法](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)  
  
 如果你收到<xref:System.Security.Authentication.AuthenticationException>，则此<xref:System.Net.Security.SslStream>已不再使用。 应关闭此对象，并删除对它的所有引用，以便它可以收集的垃圾回收器。  
  
> [!NOTE]
>  不支持 SSL 版本 2 协议在客户端证书。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="targetHost" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.Security.Authentication.AuthenticationException">身份验证失败，并使此对象处于不可用的状态。</exception>
        <exception cref="T:System.InvalidOperationException">已进行了身份验证。  -或-  之前已尝试使用此 <see cref="T:System.Net.Security.SslStream" /> 进行了服务器身份验证。  -或-  身份验证已在进行中。</exception>
        <exception cref="T:System.ObjectDisposedException">此对象已关闭。</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginAuthenticateAsClient">
      <MemberSignature Language="C#" Value="public virtual IAsyncResult BeginAuthenticateAsClient (string targetHost, System.Security.Cryptography.X509Certificates.X509CertificateCollection clientCertificates, System.Security.Authentication.SslProtocols enabledSslProtocols, bool checkCertificateRevocation, AsyncCallback asyncCallback, object asyncState);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginAuthenticateAsClient(string targetHost, class System.Security.Cryptography.X509Certificates.X509CertificateCollection clientCertificates, valuetype System.Security.Authentication.SslProtocols enabledSslProtocols, bool checkCertificateRevocation, class System.AsyncCallback asyncCallback, object asyncState) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.SslStream.BeginAuthenticateAsClient(System.String,System.Security.Cryptography.X509Certificates.X509CertificateCollection,System.Security.Authentication.SslProtocols,System.Boolean,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginAuthenticateAsClient(System::String ^ targetHost, System::Security::Cryptography::X509Certificates::X509CertificateCollection ^ clientCertificates, System::Security::Authentication::SslProtocols enabledSslProtocols, bool checkCertificateRevocation, AsyncCallback ^ asyncCallback, System::Object ^ asyncState);" />
      <MemberSignature Language="F#" Value="abstract member BeginAuthenticateAsClient : string * System.Security.Cryptography.X509Certificates.X509CertificateCollection * System.Security.Authentication.SslProtocols * bool * AsyncCallback * obj -&gt; IAsyncResult&#xA;override this.BeginAuthenticateAsClient : string * System.Security.Cryptography.X509Certificates.X509CertificateCollection * System.Security.Authentication.SslProtocols * bool * AsyncCallback * obj -&gt; IAsyncResult" Usage="sslStream.BeginAuthenticateAsClient (targetHost, clientCertificates, enabledSslProtocols, checkCertificateRevocation, asyncCallback, asyncState)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Mono.Net.Security.IMonoSslStream.BeginAuthenticateAsClient(System.String,System.Security.Cryptography.X509Certificates.X509CertificateCollection,System.Security.Authentication.SslProtocols,System.Boolean,System.AsyncCallback,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="targetHost" Type="System.String" />
        <Parameter Name="clientCertificates" Type="System.Security.Cryptography.X509Certificates.X509CertificateCollection" />
        <Parameter Name="enabledSslProtocols" Type="System.Security.Authentication.SslProtocols" />
        <Parameter Name="checkCertificateRevocation" Type="System.Boolean" />
        <Parameter Name="asyncCallback" Type="System.AsyncCallback" />
        <Parameter Name="asyncState" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="targetHost">共享此 <see cref="T:System.Net.Security.SslStream" /> 的服务器名称。</param>
        <param name="clientCertificates">
          <see cref="T:System.Security.Cryptography.X509Certificates.X509CertificateCollection" /> 包含客户端证书。</param>
        <param name="enabledSslProtocols">代表用于身份验证的协议的 <see cref="T:System.Security.Authentication.SslProtocols" /> 值。</param>
        <param name="checkCertificateRevocation">一个 <see cref="T:System.Boolean" /> 值，该值指定身份验证期间是否检查证书吊销列表。</param>
        <param name="asyncCallback">一个 <see cref="T:System.AsyncCallback" /> 委托，该委托引用当身份验证完成时要调用的方法。</param>
        <param name="asyncState">一个用户定义对象，其中包含操作的相关信息。 当操作完成后，此对象会被传递给 asyncCallback<c></c> 委托。</param>
        <summary>客户端调用此方法，以便开始一个异步操作，使用指定的证书和安全协议对服务器及客户端（可选）进行身份验证。</summary>
        <returns>一个指示异步操作状态的 <see cref="T:System.IAsyncResult" /> 对象。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [!INCLUDE[sslprotocols-none](~/includes/sslprotocols-none-md.md)]
 
 为指定的值`targetHost`必须与服务器的证书上的名称相匹配。  
  
 必须通过调用完成异步验证操作<xref:System.Net.Security.SslStream.EndAuthenticateAsClient%2A>方法。 通常情况下，通过调用该方法`asyncCallback`委托。  
  
 在操作完成时，此方法不会阻止。 若要阻止在操作完成之前，请使用其中一个<xref:System.Net.Security.SslStream.AuthenticateAsClient%2A>方法重载。  
  
 有关使用异步编程模型的详细信息，请参阅[异步调用同步方法](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)  
  
 如果你收到<xref:System.Security.Authentication.AuthenticationException>，则此<xref:System.Net.Security.SslStream>已不再使用。 应关闭此对象，并删除对它的所有引用，以便它可以收集的垃圾回收器。  
  
> [!NOTE]
>  不支持 SSL 版本 2 协议在客户端证书。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="targetHost" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="enabledSslProtocols" /> 不是有效的 <see cref="T:System.Security.Authentication.SslProtocols" /> 值。</exception>
        <exception cref="T:System.Security.Authentication.AuthenticationException">身份验证失败，并使此对象处于不可用的状态。</exception>
        <exception cref="T:System.InvalidOperationException">已进行了身份验证。  -或-  之前已尝试使用此 <see cref="T:System.Net.Security.SslStream" /> 进行了服务器身份验证。  -或-  身份验证已在进行中。</exception>
        <exception cref="T:System.ObjectDisposedException">此对象已关闭。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginAuthenticateAsServer">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>开始一个异步操作，以处理进行身份验证的客户端-服务器连接中的服务器端。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在进行身份验证时不会阻止此方法的重载。 若要阻止等待进行身份验证完成时，请使用其中一个<xref:System.Net.Security.SslStream.AuthenticateAsServer%2A>方法。  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginAuthenticateAsServer">
      <MemberSignature Language="C#" Value="public virtual IAsyncResult BeginAuthenticateAsServer (System.Security.Cryptography.X509Certificates.X509Certificate serverCertificate, AsyncCallback asyncCallback, object asyncState);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginAuthenticateAsServer(class System.Security.Cryptography.X509Certificates.X509Certificate serverCertificate, class System.AsyncCallback asyncCallback, object asyncState) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.SslStream.BeginAuthenticateAsServer(System.Security.Cryptography.X509Certificates.X509Certificate,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginAuthenticateAsServer(System::Security::Cryptography::X509Certificates::X509Certificate ^ serverCertificate, AsyncCallback ^ asyncCallback, System::Object ^ asyncState);" />
      <MemberSignature Language="F#" Value="abstract member BeginAuthenticateAsServer : System.Security.Cryptography.X509Certificates.X509Certificate * AsyncCallback * obj -&gt; IAsyncResult&#xA;override this.BeginAuthenticateAsServer : System.Security.Cryptography.X509Certificates.X509Certificate * AsyncCallback * obj -&gt; IAsyncResult" Usage="sslStream.BeginAuthenticateAsServer (serverCertificate, asyncCallback, asyncState)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Mono.Net.Security.IMonoSslStream.BeginAuthenticateAsServer(System.Security.Cryptography.X509Certificates.X509Certificate,System.AsyncCallback,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="serverCertificate" Type="System.Security.Cryptography.X509Certificates.X509Certificate" />
        <Parameter Name="asyncCallback" Type="System.AsyncCallback" />
        <Parameter Name="asyncState" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="serverCertificate">用于对服务器进行身份验证的 X509Certificate 。</param>
        <param name="asyncCallback">一个 <see cref="T:System.AsyncCallback" /> 委托，该委托引用当身份验证完成时要调用的方法。</param>
        <param name="asyncState">一个用户定义对象，其中包含操作的相关信息。 当操作完成后，此对象会被传递给 asyncCallback<c></c> 委托。</param>
        <summary>服务器调用此方法，以便开始一个异步操作，对客户端-服务器连接中的客户端及服务器（可选）进行身份验证。</summary>
        <returns>一个指示异步操作状态的 <see cref="T:System.IAsyncResult" /> 对象。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [!INCLUDE[sslprotocols-none](~/includes/sslprotocols-none-md.md)] 在身份验证期间不检查证书吊销列表。 客户端不需要进行身份验证提供证书。  
  
 必须通过调用完成异步验证操作<xref:System.Net.Security.SslStream.EndAuthenticateAsClient%2A>方法。 通常情况下，通过调用该方法`asyncCallback`委托。  
  
 在操作完成时，此方法不会阻止。 若要阻止在操作完成之前，请使用其中一个<xref:System.Net.Security.SslStream.AuthenticateAsClient%2A>方法重载。  
  
 有关使用异步编程模型的详细信息，请参阅[异步调用同步方法](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)  
  
 如果你收到<xref:System.Security.Authentication.AuthenticationException>，则此<xref:System.Net.Security.SslStream>已不再使用。 应关闭此对象，并删除对它的所有引用，以便它可以收集的垃圾回收器。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="serverCertificate" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.Security.Authentication.AuthenticationException">身份验证失败，并使此对象处于不可用的状态。</exception>
        <exception cref="T:System.InvalidOperationException">已进行了身份验证。  -或-  之前已尝试使用此 <see cref="T:System.Net.Security.SslStream" /> 进行了客户端身份验证。  -或-  身份验证已在进行中。</exception>
        <exception cref="T:System.ObjectDisposedException">此对象已关闭。</exception>
        <exception cref="T:System.PlatformNotSupportedException">Windows 95、Windows 98 或 Windows Millennium 上不支持 <see cref="Overload:System.Net.Security.SslStream.BeginAuthenticateAsServer" /> 方法。</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginAuthenticateAsServer">
      <MemberSignature Language="C#" Value="public virtual IAsyncResult BeginAuthenticateAsServer (System.Security.Cryptography.X509Certificates.X509Certificate serverCertificate, bool clientCertificateRequired, bool checkCertificateRevocation, AsyncCallback asyncCallback, object asyncState);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginAuthenticateAsServer(class System.Security.Cryptography.X509Certificates.X509Certificate serverCertificate, bool clientCertificateRequired, bool checkCertificateRevocation, class System.AsyncCallback asyncCallback, object asyncState) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.SslStream.BeginAuthenticateAsServer(System.Security.Cryptography.X509Certificates.X509Certificate,System.Boolean,System.Boolean,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginAuthenticateAsServer(System::Security::Cryptography::X509Certificates::X509Certificate ^ serverCertificate, bool clientCertificateRequired, bool checkCertificateRevocation, AsyncCallback ^ asyncCallback, System::Object ^ asyncState);" />
      <MemberSignature Language="F#" Value="abstract member BeginAuthenticateAsServer : System.Security.Cryptography.X509Certificates.X509Certificate * bool * bool * AsyncCallback * obj -&gt; IAsyncResult&#xA;override this.BeginAuthenticateAsServer : System.Security.Cryptography.X509Certificates.X509Certificate * bool * bool * AsyncCallback * obj -&gt; IAsyncResult" Usage="sslStream.BeginAuthenticateAsServer (serverCertificate, clientCertificateRequired, checkCertificateRevocation, asyncCallback, asyncState)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="serverCertificate" Type="System.Security.Cryptography.X509Certificates.X509Certificate" />
        <Parameter Name="clientCertificateRequired" Type="System.Boolean" />
        <Parameter Name="checkCertificateRevocation" Type="System.Boolean" />
        <Parameter Name="asyncCallback" Type="System.AsyncCallback" />
        <Parameter Name="asyncState" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="serverCertificate">用于对服务器进行身份验证的 X509Certificate 。</param>
        <param name="clientCertificateRequired">一个 <see cref="T:System.Boolean" /> 值，该值指定是否向客户端请求证书用于进行身份验证。 请注意，这只是一个请求 - 如果没有提供任何证书，服务器仍然可接受连接请求。</param>
        <param name="checkCertificateRevocation">一个 <see cref="T:System.Boolean" /> 值，该值指定身份验证期间是否检查证书吊销列表。</param>
        <param name="asyncCallback">一个 <see cref="T:System.AsyncCallback" /> 委托，该委托引用当身份验证完成时要调用的方法。</param>
        <param name="asyncState">一个用户定义对象，其中包含操作的相关信息。 当操作完成后，此对象会被传递给 asyncCallback<c></c> 委托。</param>
        <summary>由服务器调用，以使用指定的证书、要求和系统默认安全协议开始对服务器和客户端（可选）异步进行身份验证。</summary>
        <returns>一个指示异步操作状态的 <see cref="T:System.IAsyncResult" /> 对象。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [!INCLUDE[sslprotocols-none](~/includes/sslprotocols-none-md.md)]
 
 必须通过调用完成异步验证操作<xref:System.Net.Security.SslStream.EndAuthenticateAsServer%2A>方法。 通常情况下，通过调用该方法`asyncCallback`委托。  
  
 在操作完成时，此方法不会阻止。 若要阻止在操作完成之前，请使用其中一个<xref:System.Net.Security.SslStream.AuthenticateAsServer%2A>方法重载。  
  
 有关使用异步编程模型的详细信息，请参阅[异步调用同步方法](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)  
  
 如果你收到<xref:System.Security.Authentication.AuthenticationException>，则此<xref:System.Net.Security.SslStream>已不再使用。 应关闭此对象，并删除对它的所有引用，以便它可以收集的垃圾回收器。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="serverCertificate" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.Security.Authentication.AuthenticationException">身份验证失败，并使此对象处于不可用的状态。</exception>
        <exception cref="T:System.InvalidOperationException">已进行了身份验证。  -或-  之前已尝试使用此 <see cref="T:System.Net.Security.SslStream" /> 进行了服务器身份验证。  -或-  身份验证已在进行中。</exception>
        <exception cref="T:System.ObjectDisposedException">此对象已关闭。</exception>
        <exception cref="T:System.PlatformNotSupportedException">Windows 95、Windows 98 或 Windows Millennium 上不支持 <see cref="Overload:System.Net.Security.SslStream.BeginAuthenticateAsServer" /> 方法。</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginAuthenticateAsServer">
      <MemberSignature Language="C#" Value="public virtual IAsyncResult BeginAuthenticateAsServer (System.Security.Cryptography.X509Certificates.X509Certificate serverCertificate, bool clientCertificateRequired, System.Security.Authentication.SslProtocols enabledSslProtocols, bool checkCertificateRevocation, AsyncCallback asyncCallback, object asyncState);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginAuthenticateAsServer(class System.Security.Cryptography.X509Certificates.X509Certificate serverCertificate, bool clientCertificateRequired, valuetype System.Security.Authentication.SslProtocols enabledSslProtocols, bool checkCertificateRevocation, class System.AsyncCallback asyncCallback, object asyncState) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.SslStream.BeginAuthenticateAsServer(System.Security.Cryptography.X509Certificates.X509Certificate,System.Boolean,System.Security.Authentication.SslProtocols,System.Boolean,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginAuthenticateAsServer(System::Security::Cryptography::X509Certificates::X509Certificate ^ serverCertificate, bool clientCertificateRequired, System::Security::Authentication::SslProtocols enabledSslProtocols, bool checkCertificateRevocation, AsyncCallback ^ asyncCallback, System::Object ^ asyncState);" />
      <MemberSignature Language="F#" Value="abstract member BeginAuthenticateAsServer : System.Security.Cryptography.X509Certificates.X509Certificate * bool * System.Security.Authentication.SslProtocols * bool * AsyncCallback * obj -&gt; IAsyncResult&#xA;override this.BeginAuthenticateAsServer : System.Security.Cryptography.X509Certificates.X509Certificate * bool * System.Security.Authentication.SslProtocols * bool * AsyncCallback * obj -&gt; IAsyncResult" Usage="sslStream.BeginAuthenticateAsServer (serverCertificate, clientCertificateRequired, enabledSslProtocols, checkCertificateRevocation, asyncCallback, asyncState)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Mono.Net.Security.IMonoSslStream.BeginAuthenticateAsServer(System.Security.Cryptography.X509Certificates.X509Certificate,System.Boolean,System.Security.Authentication.SslProtocols,System.Boolean,System.AsyncCallback,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="serverCertificate" Type="System.Security.Cryptography.X509Certificates.X509Certificate" />
        <Parameter Name="clientCertificateRequired" Type="System.Boolean" />
        <Parameter Name="enabledSslProtocols" Type="System.Security.Authentication.SslProtocols" />
        <Parameter Name="checkCertificateRevocation" Type="System.Boolean" />
        <Parameter Name="asyncCallback" Type="System.AsyncCallback" />
        <Parameter Name="asyncState" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="serverCertificate">用于对服务器进行身份验证的 X509Certificate 。</param>
        <param name="clientCertificateRequired">一个 <see cref="T:System.Boolean" /> 值，该值指定是否向客户端请求证书用于进行身份验证。 请注意，这只是一个请求 - 如果没有提供任何证书，服务器仍然可接受连接请求。</param>
        <param name="enabledSslProtocols">代表用于身份验证的协议的 <see cref="T:System.Security.Authentication.SslProtocols" /> 值。</param>
        <param name="checkCertificateRevocation">一个 <see cref="T:System.Boolean" /> 值，该值指定身份验证期间是否检查证书吊销列表。</param>
        <param name="asyncCallback">一个 <see cref="T:System.AsyncCallback" /> 委托，该委托引用当身份验证完成时要调用的方法。</param>
        <param name="asyncState">一个用户定义对象，其中包含操作的相关信息。 当操作完成后，此对象会被传递给 asyncCallback<c></c> 委托。</param>
        <summary>由服务器调用，以使用指定的证书、要求和安全协议开始对服务器和客户端（可选）异步进行身份验证。</summary>
        <returns>一个指示异步操作状态的 <see cref="T:System.IAsyncResult" /> 对象。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [!INCLUDE[sslprotocols-none](~/includes/sslprotocols-none-md.md)]
 
 必须通过调用完成异步验证操作<xref:System.Net.Security.SslStream.EndAuthenticateAsServer%2A>方法。 通常情况下，通过调用该方法`asyncCallback`委托。  
  
 在操作完成时，此方法不会阻止。 若要阻止在操作完成之前，请使用其中一个<xref:System.Net.Security.SslStream.AuthenticateAsServer%2A>方法重载。  
  
 有关使用异步编程模型的详细信息，请参阅[异步调用同步方法](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)  
  
 如果你收到<xref:System.Security.Authentication.AuthenticationException>，则此<xref:System.Net.Security.SslStream>已不再使用。 应关闭此对象，并删除对它的所有引用，以便它可以收集的垃圾回收器。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="serverCertificate" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="enabledSslProtocols" /> 不是有效的 <see cref="T:System.Security.Authentication.SslProtocols" /> 值。</exception>
        <exception cref="T:System.Security.Authentication.AuthenticationException">身份验证失败，并使此对象处于不可用的状态。</exception>
        <exception cref="T:System.InvalidOperationException">已进行了身份验证。  -或-  之前已尝试使用此 <see cref="T:System.Net.Security.SslStream" /> 进行了服务器身份验证。  -或-  身份验证已在进行中。</exception>
        <exception cref="T:System.ObjectDisposedException">此对象已关闭。</exception>
        <exception cref="T:System.PlatformNotSupportedException">Windows 95、Windows 98 或 Windows Millennium 上不支持 <see cref="Overload:System.Net.Security.SslStream.BeginAuthenticateAsServer" /> 方法。</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginRead">
      <MemberSignature Language="C#" Value="public override IAsyncResult BeginRead (byte[] buffer, int offset, int count, AsyncCallback asyncCallback, object asyncState);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IAsyncResult BeginRead(unsigned int8[] buffer, int32 offset, int32 count, class System.AsyncCallback asyncCallback, object asyncState) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.SslStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override IAsyncResult ^ BeginRead(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count, AsyncCallback ^ asyncCallback, System::Object ^ asyncState);" />
      <MemberSignature Language="F#" Value="override this.BeginRead : byte[] * int * int * AsyncCallback * obj -&gt; IAsyncResult" Usage="sslStream.BeginRead (buffer, offset, count, asyncCallback, asyncState)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Mono.Net.Security.IMonoSslStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="asyncCallback" Type="System.AsyncCallback" />
        <Parameter Name="asyncState" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="buffer">一个 <see cref="T:System.Byte" /> 数组，该数组接收从流中读取的字节。</param>
        <param name="offset">
          <c>缓冲区</c>中从零开始的位置，从此处开始存储从此流中读取的数据。</param>
        <param name="count">要从流中读取的最大字节数。</param>
        <param name="asyncCallback">
          <see cref="T:System.AsyncCallback" /> 委托，该委托引用读操作完成时要调用的方法。</param>
        <param name="asyncState">一个用户定义的对象，其中包含读操作的相关信息。 当操作完成后，此对象会被传递给 asyncCallback<c></c> 委托。</param>
        <summary>开始一个异步读操作，此操作读取流中的数据并将其存储在指定的数组中。</summary>
        <returns>一个指示异步操作状态的 <see cref="T:System.IAsyncResult" /> 对象。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果启用了加密和签名，读取的操作从基础流中读取数据、 检查数据的完整性和/或对其进行解密。 异步读取的操作必须通过调用已完成<xref:System.Net.Security.SslStream.EndRead%2A>方法。 通常情况下，通过调用该方法`asyncCallback`委托。  
  
 在操作完成时，此方法不会阻止。 若要阻止在操作完成之前，请使用<xref:System.Net.Security.SslStream.Read%2A>方法。  
  
 有关使用异步编程模型的详细信息，请参阅[异步调用同步方法](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)  
  
 <xref:System.Net.Security.SslStream>类不支持多个读操作。  
  
 不能调用此方法，直到您已成功通过身份验证。 若要进行身份验证的调用一个<xref:System.Net.Security.SslStream.AuthenticateAsClient%2A>，或<xref:System.Net.Security.SslStream.BeginAuthenticateAsClient%2A>， <xref:System.Net.Security.SslStream.AuthenticateAsServer%2A>，<xref:System.Net.Security.SslStream.BeginAuthenticateAsServer%2A>方法。  
  
   
  
## Examples  
 下面的代码示例演示如何启动一个异步读的操作。  
  
 [!code-cpp[NclSslClientAsync#8](~/samples/snippets/cpp/VS_Snippets_Remoting/NclSslClientAsync/CPP/NclSslClientAsync.cpp#8)]
 [!code-csharp[NclSslClientAsync#8](~/samples/snippets/csharp/VS_Snippets_Remoting/NclSslClientAsync/CS/clientasync.cs#8)]  
  
 [!code-cpp[NclSslClientAsync#4](~/samples/snippets/cpp/VS_Snippets_Remoting/NclSslClientAsync/CPP/NclSslClientAsync.cpp#4)]
 [!code-csharp[NclSslClientAsync#4](~/samples/snippets/csharp/VS_Snippets_Remoting/NclSslClientAsync/CS/clientasync.cs#4)]  
  
 在读取完成时，被调用以下方法。  
  
 [!code-cpp[NclSslClientAsync#5](~/samples/snippets/cpp/VS_Snippets_Remoting/NclSslClientAsync/CPP/NclSslClientAsync.cpp#5)]
 [!code-csharp[NclSslClientAsync#5](~/samples/snippets/csharp/VS_Snippets_Remoting/NclSslClientAsync/CS/clientasync.cs#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="offset" />
          <paramref name="&lt;" />
          <paramref name="0" />.  
  
 <paramref name="-or-" /><paramref name="offset" /> &gt; <paramref name="buffer" /> 的长度。  -或-  <paramref name="offset" /> + count &gt; <paramref name="buffer" /> 的长度。</exception>
        <exception cref="T:System.IO.IOException">读操作失败。  -或-  使用了加密，但未能解密数据。</exception>
        <exception cref="T:System.NotSupportedException">已存在一个正在执行的读取操作。</exception>
        <exception cref="T:System.ObjectDisposedException">此对象已关闭。</exception>
        <exception cref="T:System.InvalidOperationException">未进行身份验证。</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginWrite">
      <MemberSignature Language="C#" Value="public override IAsyncResult BeginWrite (byte[] buffer, int offset, int count, AsyncCallback asyncCallback, object asyncState);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IAsyncResult BeginWrite(unsigned int8[] buffer, int32 offset, int32 count, class System.AsyncCallback asyncCallback, object asyncState) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.SslStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override IAsyncResult ^ BeginWrite(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count, AsyncCallback ^ asyncCallback, System::Object ^ asyncState);" />
      <MemberSignature Language="F#" Value="override this.BeginWrite : byte[] * int * int * AsyncCallback * obj -&gt; IAsyncResult" Usage="sslStream.BeginWrite (buffer, offset, count, asyncCallback, asyncState)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Mono.Net.Security.IMonoSslStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="asyncCallback" Type="System.AsyncCallback" />
        <Parameter Name="asyncState" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="buffer">一个 <see cref="T:System.Byte" /> 数组，该数组提供要写入流中的字节。</param>
        <param name="offset">
          <c>缓冲区</c>中从零开始的位置，从此处开始读取要写入流中的字节。</param>
        <param name="count">
          <see cref="T:System.Int32" /> 值，该值指定要从<c>缓冲区</c>中读取的字节数。</param>
        <param name="asyncCallback">
          <see cref="T:System.AsyncCallback" /> 委托，它引用写操作完成时要调用的方法。</param>
        <param name="asyncState">一个用户定义的对象，其中包含写操作的相关信息。 当操作完成后，此对象会被传递给 asyncCallback<c></c> 委托。</param>
        <summary>开始一个异步写操作，此操作将指定缓冲区中的 <see cref="T:System.Byte" /> 写入到流中。</summary>
        <returns>一个指示异步操作状态的 <see cref="T:System.IAsyncResult" /> 对象。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下面的代码示例演示如何调用此方法。  
  
 [!code-cpp[NclSslServerAsync#5](~/samples/snippets/cpp/VS_Snippets_Remoting/NclSslServerAsync/CPP/NclSslServerAsync.cpp#5)]
 [!code-csharp[NclSslServerAsync#5](~/samples/snippets/csharp/VS_Snippets_Remoting/NclSslServerAsync/CS/serverasync.cs#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="offset" />
          <paramref name="&lt;" />
          <paramref name="0" />.  
  
 <paramref name="-or-" /><paramref name="offset" /> &gt; <paramref name="buffer" /> 的长度。  -或-  <paramref name="offset" /> + count &gt; <paramref name="buffer" /> 的长度。</exception>
        <exception cref="T:System.IO.IOException">写操作失败。</exception>
        <exception cref="T:System.NotSupportedException">已存在一个正在执行的写操作。</exception>
        <exception cref="T:System.ObjectDisposedException">此对象已关闭。</exception>
        <exception cref="T:System.InvalidOperationException">未进行身份验证。</exception>
      </Docs>
    </Member>
    <Member MemberName="CanRead">
      <MemberSignature Language="C#" Value="public override bool CanRead { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanRead" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.SslStream.CanRead" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanRead As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanRead { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanRead : bool" Usage="System.Net.Security.SslStream.CanRead" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Mono.Net.Security.IMonoSslStream.CanRead</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个 <see cref="T:System.Boolean" /> 值，该值指示基础流是否可读。</summary>
        <value>如果已进行身份验证且基础流可读，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果身份验证成功，此属性返回通过调用返回的值<xref:System.IO.Stream.CanRead%2A>对基础流。  
  
 当你创建的实例时指定基础流<xref:System.Net.Security.SslStream>类。  
  
   
  
## Examples  
 下面的代码示例演示如何显示此属性的值。  
  
 [!code-cpp[NclSslServerSync#5](~/samples/snippets/cpp/VS_Snippets_Remoting/NclSslServerSync/CPP/NclSslServerSync.cpp#5)]
 [!code-csharp[NclSslServerSync#5](~/samples/snippets/csharp/VS_Snippets_Remoting/NclSslServerSync/CS/serversync.cs#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanSeek">
      <MemberSignature Language="C#" Value="public override bool CanSeek { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanSeek" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.SslStream.CanSeek" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanSeek As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanSeek { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanSeek : bool" Usage="System.Net.Security.SslStream.CanSeek" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个 <see cref="T:System.Boolean" /> 值，该值指示基础流是否可查找。</summary>
        <value>此属性始终返回 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 不要尝试设置的位置<xref:System.Net.Security.SslStream>对象或其基础流。  
  
 当你创建的实例时指定基础流<xref:System.Net.Security.SslStream>类。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.IO.Stream.CanSeek" />
        <altmember cref="P:System.Net.Security.SslStream.Position" />
      </Docs>
    </Member>
    <Member MemberName="CanTimeout">
      <MemberSignature Language="C#" Value="public override bool CanTimeout { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.SslStream.CanTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanTimeout As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanTimeout { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanTimeout : bool" Usage="System.Net.Security.SslStream.CanTimeout" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Mono.Net.Security.IMonoSslStream.CanTimeout</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个 <see cref="T:System.Boolean" /> 值，该值指示基础流是否支持超时。</summary>
        <value>如果基础流支持超时，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此属性返回通过调用返回的值<xref:System.IO.Stream.CanTimeout%2A>对基础流。  
  
 当你创建的实例时指定基础流<xref:System.Net.Security.SslStream>类。  
  
   
  
## Examples  
 下面的代码示例演示如何显示此属性的值。  
  
 [!code-cpp[NclSslServerSync#5](~/samples/snippets/cpp/VS_Snippets_Remoting/NclSslServerSync/CPP/NclSslServerSync.cpp#5)]
 [!code-csharp[NclSslServerSync#5](~/samples/snippets/csharp/VS_Snippets_Remoting/NclSslServerSync/CS/serversync.cs#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanWrite">
      <MemberSignature Language="C#" Value="public override bool CanWrite { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanWrite" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.SslStream.CanWrite" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanWrite As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanWrite { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanWrite : bool" Usage="System.Net.Security.SslStream.CanWrite" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Mono.Net.Security.IMonoSslStream.CanWrite</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个 <see cref="T:System.Boolean" /> 值，该值指示基础流是否可写。</summary>
        <value>如果已进行身份验证且基础流可写，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果身份验证成功，此属性返回通过调用返回的值<xref:System.IO.Stream.CanWrite%2A>对基础流。  
  
 当你创建的实例时指定基础流<xref:System.Net.Security.SslStream>类。  
  
   
  
## Examples  
 下面的代码示例演示如何显示此属性的值。  
  
 [!code-cpp[NclSslServerSync#5](~/samples/snippets/cpp/VS_Snippets_Remoting/NclSslServerSync/CPP/NclSslServerSync.cpp#5)]
 [!code-csharp[NclSslServerSync#5](~/samples/snippets/csharp/VS_Snippets_Remoting/NclSslServerSync/CS/serversync.cs#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CheckCertRevocationStatus">
      <MemberSignature Language="C#" Value="public virtual bool CheckCertRevocationStatus { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CheckCertRevocationStatus" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.SslStream.CheckCertRevocationStatus" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property CheckCertRevocationStatus As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CheckCertRevocationStatus { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CheckCertRevocationStatus : bool" Usage="System.Net.Security.SslStream.CheckCertRevocationStatus" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Mono.Net.Security.IMonoSslStream.CheckCertRevocationStatus</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个 <see cref="T:System.Boolean" /> 值，该值指示在证书验证过程中是否检查证书吊销列表。</summary>
        <value>如果检查证书吊销列表，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 证书吊销列表包含已被颁发者吊销的证书。 在列表中检查产生负面影响性能，但会提高应用程序安全性。  
  
   
  
## Examples  
 下面的代码示例演示如何显示此属性的值。  
  
 [!code-cpp[NclSslServerSync#5](~/samples/snippets/cpp/VS_Snippets_Remoting/NclSslServerSync/CPP/NclSslServerSync.cpp#5)]
 [!code-csharp[NclSslServerSync#5](~/samples/snippets/csharp/VS_Snippets_Remoting/NclSslServerSync/CS/serversync.cs#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CipherAlgorithm">
      <MemberSignature Language="C#" Value="public virtual System.Security.Authentication.CipherAlgorithmType CipherAlgorithm { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Security.Authentication.CipherAlgorithmType CipherAlgorithm" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.SslStream.CipherAlgorithm" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property CipherAlgorithm As CipherAlgorithmType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Security::Authentication::CipherAlgorithmType CipherAlgorithm { System::Security::Authentication::CipherAlgorithmType get(); };" />
      <MemberSignature Language="F#" Value="member this.CipherAlgorithm : System.Security.Authentication.CipherAlgorithmType" Usage="System.Net.Security.SslStream.CipherAlgorithm" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Mono.Net.Security.IMonoSslStream.CipherAlgorithm</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Authentication.CipherAlgorithmType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值确定此 <see cref="T:System.Net.Security.SslStream" /> 使用的批量加密算法。</summary>
        <value>一个 <see cref="T:System.Security.Authentication.CipherAlgorithmType" /> 值。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 值为<xref:System.Security.Authentication.CipherAlgorithmType.Null>才可进行<xref:System.Net.Security.SslStream.CipherAlgorithm%2A>属性时<xref:System.Net.Security.EncryptionPolicy.NoEncryption>枚举值用于构造<xref:System.Net.Security.SslStream>实例。  
  
 [!INCLUDE[winxpsvr](~/includes/winxpsvr-md.md)] 并[!INCLUDE[winxp](~/includes/winxp-md.md)]不支持<xref:System.Security.Authentication.CipherAlgorithmType.Null>值。 因此，即使<xref:System.Security.Authentication.CipherAlgorithmType.Null>值用于构造<xref:System.Net.Security.SslStream>实例，<xref:System.Net.Security.EncryptionPolicy>属性将为<xref:System.Security.Authentication.CipherAlgorithmType.None>。 <xref:System.Security.Authentication.CipherAlgorithmType.Null>时，Windows Vista 及更高版本才返回值。  
  
   
  
## Examples  
 下面的代码示例显示为指定的流的加密设置。  
  
 [!code-cpp[NclSslServerSync#3](~/samples/snippets/cpp/VS_Snippets_Remoting/NclSslServerSync/CPP/NclSslServerSync.cpp#3)]
 [!code-csharp[NclSslServerSync#3](~/samples/snippets/csharp/VS_Snippets_Remoting/NclSslServerSync/CS/serversync.cs#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:System.Net.Security.SslStream.CipherAlgorithm" /> 属性是在身份验证过程未完成时访问的或者身份验证过程失败。</exception>
      </Docs>
    </Member>
    <Member MemberName="CipherStrength">
      <MemberSignature Language="C#" Value="public virtual int CipherStrength { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 CipherStrength" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.SslStream.CipherStrength" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property CipherStrength As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int CipherStrength { int get(); };" />
      <MemberSignature Language="F#" Value="member this.CipherStrength : int" Usage="System.Net.Security.SslStream.CipherStrength" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Mono.Net.Security.IMonoSslStream.CipherStrength</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值确定此 <see cref="T:System.Net.Security.SslStream" /> 使用的密码算法的强度。</summary>
        <value>
          <see cref="T:System.Int32" /> 值，该值指定算法的强度（以位为单位）。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 身份验证之前，此属性的值为零。  
  
 此属性将返回以下值之一：  
  
-   0  
  
-   40  
  
-   56  
  
-   80  
  
-   128  
  
-   168  
  
-   192  
  
-   256  
  
   
  
## Examples  
 下面的代码示例显示为指定的流的加密设置。  
  
 [!code-cpp[NclSslServerSync#3](~/samples/snippets/cpp/VS_Snippets_Remoting/NclSslServerSync/CPP/NclSslServerSync.cpp#3)]
 [!code-csharp[NclSslServerSync#3](~/samples/snippets/csharp/VS_Snippets_Remoting/NclSslServerSync/CS/serversync.cs#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.SslStream.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="override this.Dispose : bool -&gt; unit" Usage="sslStream.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">若要释放托管资源和非托管资源，则为 <see langword="true" />；若仅释放非托管资源，则为 <see langword="false" />。</param>
        <summary>释放由 <see cref="T:System.Net.Security.SslStream" /> 占用的非托管资源，还可以另外再释放托管资源。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 调用此方法由公共`Dispose()`方法和<xref:System.Object.Finalize%2A>方法。 `Dispose()` 调用受保护`Dispose(Boolean)`方法替换`disposing`参数设置为`true`。 <xref:System.Object.Finalize%2A> 调用`Dispose`与`disposing`设置为`false`。  
  
 当`disposing`参数为 true 时，此方法释放任何托管对象所持有的所有资源，此<xref:System.Net.Security.SslStream>的引用。 此方法调用每个引用对象的 `Dispose()` 方法。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <see langword="Dispose" /> 可以多次调用由其他对象。重写时<see langword="Dispose(Boolean)" />小心不要引用已经释放的早期调用中的对象<see langword="Dispose" />。详细了解如何实现<see langword="Dispose(Boolean)" />，请参阅 [实现 Dispose Method](~/docs/standard/garbage-collection/implementing-dispose.md)。有关详细信息<see langword="Dispose" />并<see cref="M:System.Object.Finalize" />，请参阅 [清理了非托管 Resources](~/docs/standard/garbage-collection/unmanaged.md) 和 [重写 Finalize 方法] (http://msdn.microsoft.com/library/8026cb68-fe93-43fc-96c1-c09ad7d64cd3)。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="EndAuthenticateAsClient">
      <MemberSignature Language="C#" Value="public virtual void EndAuthenticateAsClient (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EndAuthenticateAsClient(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.SslStream.EndAuthenticateAsClient(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub EndAuthenticateAsClient (asyncResult As IAsyncResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void EndAuthenticateAsClient(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="abstract member EndAuthenticateAsClient : IAsyncResult -&gt; unit&#xA;override this.EndAuthenticateAsClient : IAsyncResult -&gt; unit" Usage="sslStream.EndAuthenticateAsClient asyncResult" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Mono.Net.Security.IMonoSslStream.EndAuthenticateAsClient(System.IAsyncResult)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">调用 <see cref="Overload:System.Net.Security.SslStream.BeginAuthenticateAsServer" /> 后返回的 <see cref="T:System.IAsyncResult" /> 实例。</param>
        <summary>结束通过以前调用 <see cref="Overload:System.Net.Security.SslStream.BeginAuthenticateAsServer" /> 而启动的、处于挂起状态的异步服务器身份验证操作。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果该操作未完成，此方法阻止，直至它。 当身份验证成功时，必须检查<xref:System.Net.Security.SslStream.IsEncrypted%2A>并<xref:System.Net.Security.SslStream.IsSigned%2A>属性以确定由哪些安全服务<xref:System.Net.Security.SslStream>。 检查<xref:System.Net.Security.SslStream.IsMutuallyAuthenticated%2A>属性以确定是否发生了相互身份验证。  
  
 如果身份验证失败，则收到<xref:System.Security.Authentication.AuthenticationException>，并且此<xref:System.Net.Security.SslStream>已不再使用。 应关闭此对象，并删除对它的所有引用，以便它可以收集的垃圾回收器。  
  
 若要以同步方式执行此操作，使用之一<xref:System.Net.Security.SslStream.AuthenticateAsServer%2A>方法。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="asyncResult" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="asyncResult" /> 并不是通过对 <see cref="Overload:System.Net.Security.SslStream.BeginAuthenticateAsServer" /> 的调用创建的。</exception>
        <exception cref="T:System.Security.Authentication.AuthenticationException">身份验证失败，并使此对象处于不可用的状态。</exception>
        <exception cref="T:System.InvalidOperationException">没有处于挂起状态的服务器身份验证要完成。</exception>
      </Docs>
    </Member>
    <Member MemberName="EndAuthenticateAsServer">
      <MemberSignature Language="C#" Value="public virtual void EndAuthenticateAsServer (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EndAuthenticateAsServer(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.SslStream.EndAuthenticateAsServer(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub EndAuthenticateAsServer (asyncResult As IAsyncResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void EndAuthenticateAsServer(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="abstract member EndAuthenticateAsServer : IAsyncResult -&gt; unit&#xA;override this.EndAuthenticateAsServer : IAsyncResult -&gt; unit" Usage="sslStream.EndAuthenticateAsServer asyncResult" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Mono.Net.Security.IMonoSslStream.EndAuthenticateAsServer(System.IAsyncResult)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">调用 <see cref="Overload:System.Net.Security.SslStream.BeginAuthenticateAsClient" /> 后返回的 <see cref="T:System.IAsyncResult" /> 实例。</param>
        <summary>结束通过以前调用 <see cref="Overload:System.Net.Security.SslStream.BeginAuthenticateAsClient" /> 而启动的、处于挂起状态的异步客户端身份验证操作。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果该操作未完成，此方法阻止，直至它。 当身份验证成功时，必须检查<xref:System.Net.Security.SslStream.IsEncrypted%2A>并<xref:System.Net.Security.SslStream.IsSigned%2A>属性以确定由哪些安全服务<xref:System.Net.Security.SslStream>。 检查<xref:System.Net.Security.SslStream.IsMutuallyAuthenticated%2A>属性以确定是否发生了相互身份验证。  
  
 如果身份验证失败，则收到<xref:System.Security.Authentication.AuthenticationException>，并且此<xref:System.Net.Security.SslStream>已不再使用。 应关闭此对象，并删除对它的所有引用，以便它可以收集的垃圾回收器。  
  
 若要以同步方式执行此操作，使用之一<xref:System.Net.Security.SslStream.AuthenticateAsClient%2A>方法。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="asyncResult" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="asyncResult" /> 并不是通过对 <see cref="Overload:System.Net.Security.SslStream.BeginAuthenticateAsClient" /> 的调用创建的。</exception>
        <exception cref="T:System.Security.Authentication.AuthenticationException">身份验证失败，并使此对象处于不可用的状态。</exception>
        <exception cref="T:System.InvalidOperationException">没有需要完成的处于挂起状态的客户端身份验证。</exception>
      </Docs>
    </Member>
    <Member MemberName="EndRead">
      <MemberSignature Language="C#" Value="public override int EndRead (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 EndRead(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.SslStream.EndRead(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function EndRead (asyncResult As IAsyncResult) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int EndRead(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="override this.EndRead : IAsyncResult -&gt; int" Usage="sslStream.EndRead asyncResult" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Mono.Net.Security.IMonoSslStream.EndRead(System.IAsyncResult)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">调用 <see cref="M:System.Net.Security.SslStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /> 后返回的 <see cref="T:System.IAsyncResult" /> 实例</param>
        <summary>结束通过以前调用 <see cref="M:System.Net.Security.SslStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /> 而启动的异步读操作。</summary>
        <returns>
          <see cref="T:System.Int32" /> 值，该值指定从基础流中读取的字节数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果该操作未完成，此方法阻止，直至它。  
  
 若要以同步方式执行此操作，请使用<xref:System.Net.Security.SslStream.Read%2A>方法。  
  
 不能调用此方法，直到您已成功通过身份验证。 若要进行身份验证的调用一个<xref:System.Net.Security.SslStream.AuthenticateAsClient%2A>，或<xref:System.Net.Security.SslStream.BeginAuthenticateAsClient%2A>， <xref:System.Net.Security.SslStream.AuthenticateAsServer%2A>，<xref:System.Net.Security.SslStream.BeginAuthenticateAsServer%2A>方法。  
  
   
  
## Examples  
 下面的代码示例演示结束异步读取操作。  
  
 [!code-cpp[NclSslClientAsync#5](~/samples/snippets/cpp/VS_Snippets_Remoting/NclSslClientAsync/CPP/NclSslClientAsync.cpp#5)]
 [!code-csharp[NclSslClientAsync#5](~/samples/snippets/csharp/VS_Snippets_Remoting/NclSslClientAsync/CS/clientasync.cs#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="asyncResult" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="asyncResult" /> 并不是通过对 <see cref="M:System.Net.Security.SslStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /> 的调用创建的。</exception>
        <exception cref="T:System.InvalidOperationException">未进行身份验证。</exception>
        <exception cref="T:System.IO.IOException">读操作失败。</exception>
      </Docs>
    </Member>
    <Member MemberName="EndWrite">
      <MemberSignature Language="C#" Value="public override void EndWrite (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void EndWrite(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.SslStream.EndWrite(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub EndWrite (asyncResult As IAsyncResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void EndWrite(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="override this.EndWrite : IAsyncResult -&gt; unit" Usage="sslStream.EndWrite asyncResult" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Mono.Net.Security.IMonoSslStream.EndWrite(System.IAsyncResult)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">调用 <see cref="M:System.Net.Security.SslStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /> 后返回的 <see cref="T:System.IAsyncResult" /> 实例</param>
        <summary>结束通过以前调用 <see cref="M:System.Net.Security.SslStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /> 而启动的异步写操作。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果该操作未完成，此方法阻止，直至它。  
  
 应用程序不能调用此方法，直到您已成功通过身份验证。 若要进行身份验证，调用之一<xref:System.Net.Security.SslStream.AuthenticateAsClient%2A>，或<xref:System.Net.Security.SslStream.BeginAuthenticateAsClient%2A>， <xref:System.Net.Security.SslStream.AuthenticateAsServer%2A>，<xref:System.Net.Security.SslStream.BeginAuthenticateAsServer%2A>方法。  
  
 若要以同步方式执行此操作，请使用<xref:System.Net.Security.SslStream.Write%2A>方法。  
  
   
  
## Examples  
 下面的代码示例演示如何结束异步写入操作。  
  
 [!code-cpp[NclSslServerAsync#4](~/samples/snippets/cpp/VS_Snippets_Remoting/NclSslServerAsync/CPP/NclSslServerAsync.cpp#4)]
 [!code-csharp[NclSslServerAsync#4](~/samples/snippets/csharp/VS_Snippets_Remoting/NclSslServerAsync/CS/serverasync.cs#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="asyncResult" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="asyncResult" /> 并不是通过对 <see cref="M:System.Net.Security.SslStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /> 的调用创建的。</exception>
        <exception cref="T:System.InvalidOperationException">未进行身份验证。</exception>
        <exception cref="T:System.IO.IOException">写操作失败。</exception>
      </Docs>
    </Member>
    <Member MemberName="Flush">
      <MemberSignature Language="C#" Value="public override void Flush ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Flush() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.SslStream.Flush" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Flush ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Flush();" />
      <MemberSignature Language="F#" Value="override this.Flush : unit -&gt; unit" Usage="sslStream.Flush " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Mono.Net.Security.IMonoSslStream.Flush</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>导致所有缓冲数据都要写入基础设备。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法将调用<xref:System.IO.Stream.Flush%2A>对基础流。  
  
   
  
## Examples  
 下面的代码示例演示如何调用此方法。  
  
 [!code-cpp[NclSslClientSync#5](~/samples/snippets/cpp/VS_Snippets_Remoting/NclSslClientSync/CPP/clientsync.cpp#5)]
 [!code-csharp[NclSslClientSync#5](~/samples/snippets/csharp/VS_Snippets_Remoting/NclSslClientSync/CS/clientsync.cs#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FlushAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.Task FlushAsync (System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Threading.Tasks.Task FlushAsync(valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.SslStream.FlushAsync(System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Threading::Tasks::Task ^ FlushAsync(System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="override this.FlushAsync : System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="sslStream.FlushAsync cancellationToken" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="cancellationToken">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="HashAlgorithm">
      <MemberSignature Language="C#" Value="public virtual System.Security.Authentication.HashAlgorithmType HashAlgorithm { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Security.Authentication.HashAlgorithmType HashAlgorithm" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.SslStream.HashAlgorithm" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property HashAlgorithm As HashAlgorithmType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Security::Authentication::HashAlgorithmType HashAlgorithm { System::Security::Authentication::HashAlgorithmType get(); };" />
      <MemberSignature Language="F#" Value="member this.HashAlgorithm : System.Security.Authentication.HashAlgorithmType" Usage="System.Net.Security.SslStream.HashAlgorithm" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Mono.Net.Security.IMonoSslStream.HashAlgorithm</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Authentication.HashAlgorithmType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取用于生成消息身份验证代码 (MAC) 的算法。</summary>
        <value>一个 <see cref="T:System.Security.Authentication.HashAlgorithmType" /> 值。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 消息验证算法可生成消息哈希和签名用于检测篡改和伪造。  
  
   
  
## Examples  
 下面的代码示例显示为指定的流的加密设置。  
  
 [!code-cpp[NclSslServerSync#3](~/samples/snippets/cpp/VS_Snippets_Remoting/NclSslServerSync/CPP/NclSslServerSync.cpp#3)]
 [!code-csharp[NclSslServerSync#3](~/samples/snippets/csharp/VS_Snippets_Remoting/NclSslServerSync/CS/serversync.cs#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:System.Net.Security.SslStream.HashAlgorithm" /> 属性是在身份验证过程未完成时访问的或者身份验证过程失败。</exception>
      </Docs>
    </Member>
    <Member MemberName="HashStrength">
      <MemberSignature Language="C#" Value="public virtual int HashStrength { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 HashStrength" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.SslStream.HashStrength" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property HashStrength As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int HashStrength { int get(); };" />
      <MemberSignature Language="F#" Value="member this.HashStrength : int" Usage="System.Net.Security.SslStream.HashStrength" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Mono.Net.Security.IMonoSslStream.HashStrength</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值标识此实例使用的哈希算法的强度。</summary>
        <value>一个 <see cref="T:System.Int32" /> 值，指定 <see cref="T:System.Security.Authentication.HashAlgorithmType" /> 算法的强度（以位为单位）。 有效值为 128 或 160。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 身份验证之前，此属性的值为零。  
  
   
  
## Examples  
 下面的代码示例显示为指定的流的加密设置。  
  
 [!code-cpp[NclSslServerSync#3](~/samples/snippets/cpp/VS_Snippets_Remoting/NclSslServerSync/CPP/NclSslServerSync.cpp#3)]
 [!code-csharp[NclSslServerSync#3](~/samples/snippets/csharp/VS_Snippets_Remoting/NclSslServerSync/CS/serversync.cs#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsAuthenticated">
      <MemberSignature Language="C#" Value="public override bool IsAuthenticated { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAuthenticated" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.SslStream.IsAuthenticated" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsAuthenticated As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsAuthenticated { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsAuthenticated : bool" Usage="System.Net.Security.SslStream.IsAuthenticated" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Mono.Net.Security.IMonoSslStream.IsAuthenticated</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个 <see cref="T:System.Boolean" /> 值，该值指示身份验证是否成功。</summary>
        <value>如果身份验证成功，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 客户端进行身份验证通过调用<xref:System.Net.Security.SslStream.AuthenticateAsClient%2A>或<xref:System.Net.Security.SslStream.BeginAuthenticateAsClient%2A>方法。 通过调用的服务器进行身份验证<xref:System.Net.Security.SslStream.AuthenticateAsServer%2A>或<xref:System.Net.Security.SslStream.BeginAuthenticateAsServer%2A>方法。  
  
   
  
## Examples  
 下面的代码示例演示如何显示此属性的值。  
  
 [!code-cpp[NclSslServerSync#4](~/samples/snippets/cpp/VS_Snippets_Remoting/NclSslServerSync/CPP/NclSslServerSync.cpp#4)]
 [!code-csharp[NclSslServerSync#4](~/samples/snippets/csharp/VS_Snippets_Remoting/NclSslServerSync/CS/serversync.cs#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsEncrypted">
      <MemberSignature Language="C#" Value="public override bool IsEncrypted { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsEncrypted" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.SslStream.IsEncrypted" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsEncrypted As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsEncrypted { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsEncrypted : bool" Usage="System.Net.Security.SslStream.IsEncrypted" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Mono.Net.Security.IMonoSslStream.IsEncrypted</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个 <see cref="T:System.Boolean" /> 值，该值指示此 <see cref="T:System.Net.Security.SslStream" /> 是否使用数据加密。</summary>
        <value>如果在通过网络传输数据前将其加密，并在数据到达远程终结点后将其解密，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 加密来帮助保护数据的隐私，即它有助于确保，在传输数据时，它不能解密由第三方。  
  
   
  
## Examples  
 下面的代码示例演示如何显示此属性的值。  
  
 [!code-cpp[NclSslServerSync#4](~/samples/snippets/cpp/VS_Snippets_Remoting/NclSslServerSync/CPP/NclSslServerSync.cpp#4)]
 [!code-csharp[NclSslServerSync#4](~/samples/snippets/csharp/VS_Snippets_Remoting/NclSslServerSync/CS/serversync.cs#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsMutuallyAuthenticated">
      <MemberSignature Language="C#" Value="public override bool IsMutuallyAuthenticated { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsMutuallyAuthenticated" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.SslStream.IsMutuallyAuthenticated" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsMutuallyAuthenticated As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsMutuallyAuthenticated { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsMutuallyAuthenticated : bool" Usage="System.Net.Security.SslStream.IsMutuallyAuthenticated" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Mono.Net.Security.IMonoSslStream.IsMutuallyAuthenticated</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个 <see cref="T:System.Boolean" /> 值，该值指示服务器和客户端是否均已进行身份验证。</summary>
        <value>如果服务器已经过身份验证，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当服务器想客户端进行身份验证提供的证书时，服务器指定相互身份验证。  
  
   
  
## Examples  
 下面的代码示例演示如何显示此属性的值。  
  
 [!code-cpp[NclSslServerSync#4](~/samples/snippets/cpp/VS_Snippets_Remoting/NclSslServerSync/CPP/NclSslServerSync.cpp#4)]
 [!code-csharp[NclSslServerSync#4](~/samples/snippets/csharp/VS_Snippets_Remoting/NclSslServerSync/CS/serversync.cs#4)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Net.Security.SslStream.AuthenticateAsServer" />
        <altmember cref="Overload:System.Net.Security.SslStream.BeginAuthenticateAsServer" />
      </Docs>
    </Member>
    <Member MemberName="IsServer">
      <MemberSignature Language="C#" Value="public override bool IsServer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsServer" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.SslStream.IsServer" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsServer As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsServer { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsServer : bool" Usage="System.Net.Security.SslStream.IsServer" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Mono.Net.Security.IMonoSslStream.IsServer</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个 <see cref="T:System.Boolean" /> 值，该值指示此 <see cref="T:System.Net.Security.SslStream" /> 使用的连接的本地端是否作为服务器进行了身份验证。</summary>
        <value>如果本地终结点作为经过身份验证的连接的服务器端成功地进行了身份验证，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果身份验证失败或未出现，此属性返回`false`。  
  
 若要与服务器进行身份验证，调用<xref:System.Net.Security.SslStream.AuthenticateAsServer%2A>或<xref:System.Net.Security.SslStream.BeginAuthenticateAsServer%2A>方法。  
  
   
  
## Examples  
 下面的代码示例演示如何显示此属性的值。  
  
 [!code-cpp[NclSslServerSync#4](~/samples/snippets/cpp/VS_Snippets_Remoting/NclSslServerSync/CPP/NclSslServerSync.cpp#4)]
 [!code-csharp[NclSslServerSync#4](~/samples/snippets/csharp/VS_Snippets_Remoting/NclSslServerSync/CS/serversync.cs#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsSigned">
      <MemberSignature Language="C#" Value="public override bool IsSigned { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSigned" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.SslStream.IsSigned" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsSigned As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSigned { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSigned : bool" Usage="System.Net.Security.SslStream.IsSigned" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Mono.Net.Security.IMonoSslStream.IsSigned</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个 <see cref="T:System.Boolean" /> 值，该值指示使用此流发送的数据是否进行签名。</summary>
        <value>如果在传输数据前对其签名，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 数据签名可帮助保护数据的完整性，即它可以帮助确定是否将数据已被篡改在传输过程中的收件人。  
  
   
  
## Examples  
 下面的代码示例演示如何显示此属性的值。  
  
 [!code-cpp[NclSslServerSync#4](~/samples/snippets/cpp/VS_Snippets_Remoting/NclSslServerSync/CPP/NclSslServerSync.cpp#4)]
 [!code-csharp[NclSslServerSync#4](~/samples/snippets/csharp/VS_Snippets_Remoting/NclSslServerSync/CS/serversync.cs#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="KeyExchangeAlgorithm">
      <MemberSignature Language="C#" Value="public virtual System.Security.Authentication.ExchangeAlgorithmType KeyExchangeAlgorithm { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Security.Authentication.ExchangeAlgorithmType KeyExchangeAlgorithm" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.SslStream.KeyExchangeAlgorithm" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property KeyExchangeAlgorithm As ExchangeAlgorithmType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Security::Authentication::ExchangeAlgorithmType KeyExchangeAlgorithm { System::Security::Authentication::ExchangeAlgorithmType get(); };" />
      <MemberSignature Language="F#" Value="member this.KeyExchangeAlgorithm : System.Security.Authentication.ExchangeAlgorithmType" Usage="System.Net.Security.SslStream.KeyExchangeAlgorithm" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Mono.Net.Security.IMonoSslStream.KeyExchangeAlgorithm</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Authentication.ExchangeAlgorithmType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取此 <see cref="T:System.Net.Security.SslStream" /> 使用的密钥交换算法。</summary>
        <value>一个 <see cref="T:System.Security.Authentication.ExchangeAlgorithmType" /> 值。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此属性的值是<xref:System.Security.Authentication.ExchangeAlgorithmType.None>之前进行身份验证。  
  
 密钥交换算法可保护用来生成共享的密钥的信息。  
  
   
  
## Examples  
 下面的代码示例显示为指定的流的加密设置。  
  
 [!code-cpp[NclSslServerSync#3](~/samples/snippets/cpp/VS_Snippets_Remoting/NclSslServerSync/CPP/NclSslServerSync.cpp#3)]
 [!code-csharp[NclSslServerSync#3](~/samples/snippets/csharp/VS_Snippets_Remoting/NclSslServerSync/CS/serversync.cs#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="KeyExchangeStrength">
      <MemberSignature Language="C#" Value="public virtual int KeyExchangeStrength { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 KeyExchangeStrength" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.SslStream.KeyExchangeStrength" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property KeyExchangeStrength As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int KeyExchangeStrength { int get(); };" />
      <MemberSignature Language="F#" Value="member this.KeyExchangeStrength : int" Usage="System.Net.Security.SslStream.KeyExchangeStrength" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Mono.Net.Security.IMonoSslStream.KeyExchangeStrength</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示此实例使用的密钥交换算法的强度。</summary>
        <value>一个 <see cref="T:System.Int32" /> 值，指定 <see cref="T:System.Security.Authentication.ExchangeAlgorithmType" /> 算法的强度（以位为单位）。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 身份验证之前，此属性的值为零。  
  
 通常情况下，此属性的值是以下值之一：  
  
-   512  
  
-   768  
  
-   1024  
  
-   2048  
  
   
  
## Examples  
 下面的代码示例显示为指定的流的加密设置。  
  
 [!code-cpp[NclSslServerSync#3](~/samples/snippets/cpp/VS_Snippets_Remoting/NclSslServerSync/CPP/NclSslServerSync.cpp#3)]
 [!code-csharp[NclSslServerSync#3](~/samples/snippets/csharp/VS_Snippets_Remoting/NclSslServerSync/CS/serversync.cs#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Length">
      <MemberSignature Language="C#" Value="public override long Length { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 Length" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.SslStream.Length" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Length As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property long Length { long get(); };" />
      <MemberSignature Language="F#" Value="member this.Length : int64" Usage="System.Net.Security.SslStream.Length" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Mono.Net.Security.IMonoSslStream.Length</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取基础流的长度。</summary>
        <value>
          <see cref="T:System.Int64" />。  基础流的长度。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此属性返回通过调用返回的值<xref:System.IO.Stream.Length%2A>对基础流。 如果基础流不可查找，此方法通常会引发异常。 基础流的运行时类型确定引发的异常的运行时的类型。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">当基础流为 <see cref="T:System.Net.Sockets.NetworkStream" /> 时，不支持获取此属性的值。</exception>
      </Docs>
    </Member>
    <Member MemberName="LocalCertificate">
      <MemberSignature Language="C#" Value="public virtual System.Security.Cryptography.X509Certificates.X509Certificate LocalCertificate { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Cryptography.X509Certificates.X509Certificate LocalCertificate" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.SslStream.LocalCertificate" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property LocalCertificate As X509Certificate" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Security::Cryptography::X509Certificates::X509Certificate ^ LocalCertificate { System::Security::Cryptography::X509Certificates::X509Certificate ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.LocalCertificate : System.Security.Cryptography.X509Certificates.X509Certificate" Usage="System.Net.Security.SslStream.LocalCertificate" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Mono.Net.Security.IMonoSslStream.LocalCertificate</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.X509Certificates.X509Certificate</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取用于对本地终结点进行身份验证的证书。</summary>
        <value>一个 X509Certificate 对象，它表示为身份验证提供的证书；或者，如果没有提供证书，则为 <see langword="null" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下面的代码示例演示如何显示此属性返回的证书。  
  
 [!code-cpp[NclSslServerSync#6](~/samples/snippets/cpp/VS_Snippets_Remoting/NclSslServerSync/CPP/NclSslServerSync.cpp#6)]
 [!code-csharp[NclSslServerSync#6](~/samples/snippets/csharp/VS_Snippets_Remoting/NclSslServerSync/CS/serversync.cs#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">身份验证失败或没有进行身份验证。</exception>
      </Docs>
    </Member>
    <Member MemberName="NegotiatedApplicationProtocol">
      <MemberSignature Language="C#" Value="public System.Net.Security.SslApplicationProtocol NegotiatedApplicationProtocol { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Net.Security.SslApplicationProtocol NegotiatedApplicationProtocol" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.SslStream.NegotiatedApplicationProtocol" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property NegotiatedApplicationProtocol As SslApplicationProtocol" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::Security::SslApplicationProtocol NegotiatedApplicationProtocol { System::Net::Security::SslApplicationProtocol get(); };" />
      <MemberSignature Language="F#" Value="member this.NegotiatedApplicationProtocol : System.Net.Security.SslApplicationProtocol" Usage="System.Net.Security.SslStream.NegotiatedApplicationProtocol" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Security.SslApplicationProtocol</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Position">
      <MemberSignature Language="C#" Value="public override long Position { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 Position" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.SslStream.Position" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Position As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property long Position { long get(); void set(long value); };" />
      <MemberSignature Language="F#" Value="member this.Position : int64 with get, set" Usage="System.Net.Security.SslStream.Position" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置基础流中的当前位置。</summary>
        <value>
          <see cref="T:System.Int64" />。  基础流中的当前位置。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此属性返回通过调用返回的值<xref:System.IO.Stream.Position%2A>对基础流。 如果基础流不可查找，此方法通常会引发异常。 基础流的运行时类型确定引发的异常的运行时的类型。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">不支持设置此属性。  -或-  当基础流为 <see cref="T:System.Net.Sockets.NetworkStream" /> 时，不支持获取此属性的值。</exception>
      </Docs>
    </Member>
    <Member MemberName="Read">
      <MemberSignature Language="C#" Value="public override int Read (byte[] buffer, int offset, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 Read(unsigned int8[] buffer, int32 offset, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.SslStream.Read(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Read (buffer As Byte(), offset As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int Read(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count);" />
      <MemberSignature Language="F#" Value="override this.Read : byte[] * int * int -&gt; int" Usage="sslStream.Read (buffer, offset, count)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Mono.Net.Security.IMonoSslStream.Read(System.Byte[],System.Int32,System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">一个 <see cref="T:System.Byte" /> 数组，该数组接收从此流读取的字节。</param>
        <param name="offset">
          <see cref="T:System.Int32" />，它包含 <c>buffer</c> 中从零开始的位置，从该位置开始存储从此流读取的数据。</param>
        <param name="count">
          <see cref="T:System.Int32" />，包含要从此流读取的最大字节数。</param>
        <summary>读取此流中的数据并将其存储在指定的数组中。</summary>
        <returns>
          <see cref="T:System.Int32" /> 值，该值指定读取的字节数。 如果再也没有要读取的数据，将返回 0。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 该方法读取的最多`count`字节从流将其存储在`buffer`开始`offset`。 无法执行多个同时进行的读取的操作。  
  
 不能调用此方法，直到您已成功通过身份验证。 若要进行身份验证的调用一个<xref:System.Net.Security.SslStream.AuthenticateAsClient%2A>，或<xref:System.Net.Security.SslStream.BeginAuthenticateAsClient%2A>， <xref:System.Net.Security.SslStream.AuthenticateAsServer%2A>，<xref:System.Net.Security.SslStream.BeginAuthenticateAsServer%2A>方法。  
  
 若要以异步方式执行此操作，请使用<xref:System.Net.Security.SslStream.BeginRead%2A>方法。  
  
   
  
## Examples  
 下面的代码示例演示如何读取从<xref:System.Net.Security.SslStream>。  
  
 [!code-cpp[NclSslClientSync#6](~/samples/snippets/cpp/VS_Snippets_Remoting/NclSslClientSync/CPP/clientsync.cpp#6)]
 [!code-csharp[NclSslClientSync#6](~/samples/snippets/csharp/VS_Snippets_Remoting/NclSslClientSync/CS/clientsync.cs#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="offset" />
          <paramref name="&lt;" />
          <paramref name="0" />.  
  
 <paramref name="-or-" /><paramref name="offset" /> &gt; <paramref name="buffer" /> 的长度。  -或-  <paramref name="offset" /> + count &gt; <paramref name="buffer" /> 的长度。</exception>
        <exception cref="T:System.IO.IOException">读操作失败。 检查内部异常（如果存在）以确定失败的原因。</exception>
        <exception cref="T:System.NotSupportedException">已存在一个正在执行的读取操作。</exception>
        <exception cref="T:System.ObjectDisposedException">此对象已关闭。</exception>
        <exception cref="T:System.InvalidOperationException">未进行身份验证。</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadTimeout">
      <MemberSignature Language="C#" Value="public override int ReadTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ReadTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.SslStream.ReadTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property ReadTimeout As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int ReadTimeout { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.ReadTimeout : int with get, set" Usage="System.Net.Security.SslStream.ReadTimeout" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Mono.Net.Security.IMonoSslStream.ReadTimeout</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置读操作阻止等待数据的时间。</summary>
        <value>
          <see cref="T:System.Int32" />，指定同步读操作失败前经过的时间。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此属性返回通过调用返回的值<xref:System.IO.Stream.ReadTimeout%2A>对基础流。 当设置此属性，<xref:System.IO.Stream.ReadTimeout%2A>对基础流的值设置为指定的值。  
  
 基础流是否<xref:System.Net.Sockets.NetworkStream>，<xref:System.Net.Security.SslStream.ReadTimeout%2A>以毫秒为单位并将设置为<xref:System.Threading.Timeout.Infinite>默认情况下，因此，它读取操作就不会超时。  
  
   
  
## Examples  
 下面的代码示例演示如何设置此属性的值。  
  
 [!code-cpp[NclSslServerSync#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NclSslServerSync/CPP/NclSslServerSync.cpp#1)]
 [!code-csharp[NclSslServerSync#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NclSslServerSync/CS/serversync.cs#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoteCertificate">
      <MemberSignature Language="C#" Value="public virtual System.Security.Cryptography.X509Certificates.X509Certificate RemoteCertificate { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Cryptography.X509Certificates.X509Certificate RemoteCertificate" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.SslStream.RemoteCertificate" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property RemoteCertificate As X509Certificate" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Security::Cryptography::X509Certificates::X509Certificate ^ RemoteCertificate { System::Security::Cryptography::X509Certificates::X509Certificate ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.RemoteCertificate : System.Security.Cryptography.X509Certificates.X509Certificate" Usage="System.Net.Security.SslStream.RemoteCertificate" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Mono.Net.Security.IMonoSslStream.RemoteCertificate</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.X509Certificates.X509Certificate</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取用于对远程终结点进行身份验证的证书。</summary>
        <value>一个 X509Certificate 对象，它表示为身份验证提供的证书；或者，如果没有提供证书，则为 <see langword="null" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下面的代码示例演示如何显示此属性返回的证书。  
  
 [!code-cpp[NclSslServerSync#6](~/samples/snippets/cpp/VS_Snippets_Remoting/NclSslServerSync/CPP/NclSslServerSync.cpp#6)]
 [!code-csharp[NclSslServerSync#6](~/samples/snippets/csharp/VS_Snippets_Remoting/NclSslServerSync/CS/serversync.cs#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">身份验证失败或没有进行身份验证。</exception>
      </Docs>
    </Member>
    <Member MemberName="Seek">
      <MemberSignature Language="C#" Value="public override long Seek (long offset, System.IO.SeekOrigin origin);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int64 Seek(int64 offset, valuetype System.IO.SeekOrigin origin) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.SslStream.Seek(System.Int64,System.IO.SeekOrigin)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Seek (offset As Long, origin As SeekOrigin) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override long Seek(long offset, System::IO::SeekOrigin origin);" />
      <MemberSignature Language="F#" Value="override this.Seek : int64 * System.IO.SeekOrigin -&gt; int64" Usage="sslStream.Seek (offset, origin)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="offset" Type="System.Int64" />
        <Parameter Name="origin" Type="System.IO.SeekOrigin" />
      </Parameters>
      <Docs>
        <param name="offset">忽略此值。</param>
        <param name="origin">忽略此值。</param>
        <summary>引发 <see cref="T:System.NotSupportedException" />。</summary>
        <returns>总是引发 <see cref="T:System.NotSupportedException" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 请勿调用此方法。 它被继承，但不是受<xref:System.Net.Security.SslStream>类。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <see cref="T:System.Net.Security.SslStream" /> 对象不支持查找。</exception>
      </Docs>
    </Member>
    <Member MemberName="SetLength">
      <MemberSignature Language="C#" Value="public override void SetLength (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void SetLength(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.SslStream.SetLength(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub SetLength (value As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void SetLength(long value);" />
      <MemberSignature Language="F#" Value="override this.SetLength : int64 -&gt; unit" Usage="sslStream.SetLength value" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Mono.Net.Security.IMonoSslStream.SetLength(System.Int64)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value">
          <see cref="T:System.Int64" /> 值，该值指定流的长度。</param>
        <summary>设置基础流的长度。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法将调用<xref:System.IO.Stream.SetLength%2A?displayProperty=nameWithType>时，指定对基础流这<xref:System.Net.Security.SslStream>已创建。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ShutdownAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task ShutdownAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task ShutdownAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.SslStream.ShutdownAsync" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ShutdownAsync () As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task ^ ShutdownAsync();" />
      <MemberSignature Language="F#" Value="abstract member ShutdownAsync : unit -&gt; System.Threading.Tasks.Task&#xA;override this.ShutdownAsync : unit -&gt; System.Threading.Tasks.Task" Usage="sslStream.ShutdownAsync " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>关闭此 SslStream。</summary>
        <returns>表示异步操作的任务对象。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SslProtocol">
      <MemberSignature Language="C#" Value="public virtual System.Security.Authentication.SslProtocols SslProtocol { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Security.Authentication.SslProtocols SslProtocol" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.SslStream.SslProtocol" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property SslProtocol As SslProtocols" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Security::Authentication::SslProtocols SslProtocol { System::Security::Authentication::SslProtocols get(); };" />
      <MemberSignature Language="F#" Value="member this.SslProtocol : System.Security.Authentication.SslProtocols" Usage="System.Net.Security.SslStream.SslProtocol" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Mono.Net.Security.IMonoSslStream.SslProtocol</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Authentication.SslProtocols</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示用于对此连接进行身份验证的安全协议。</summary>
        <value>代表用于身份验证的协议的 <see cref="T:System.Security.Authentication.SslProtocols" /> 值。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 指定支持的安全协议时<xref:System.Net.Security.SslStream>创建。 如果没有安全协议传递给构造函数，使用创建该实例<xref:System.Security.Authentication.SslProtocols.Default>。 根据客户端和服务器支持的协议选择实际用于身份验证的协议。  
  
   
  
## Examples  
 以下示例显示指定的流的安全属性。  
  
 [!code-cpp[NclSslServerSync#3](~/samples/snippets/cpp/VS_Snippets_Remoting/NclSslServerSync/CPP/NclSslServerSync.cpp#3)]
 [!code-csharp[NclSslServerSync#3](~/samples/snippets/csharp/VS_Snippets_Remoting/NclSslServerSync/CS/serversync.cs#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TransportContext">
      <MemberSignature Language="C#" Value="public System.Net.TransportContext TransportContext { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.TransportContext TransportContext" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.SslStream.TransportContext" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TransportContext As TransportContext" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::TransportContext ^ TransportContext { System::Net::TransportContext ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.TransportContext : System.Net.TransportContext" Usage="System.Net.Security.SslStream.TransportContext" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Mono.Net.Security.IMonoSslStream.TransportContext</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.TransportContext</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取用于采用扩展保护的身份验证的 <see cref="T:System.Net.TransportContext" />。</summary>
        <value>一个 <see cref="T:System.Net.TransportContext" /> 对象，它包含用于扩展保护的通道绑定令牌 (CBT)。</value>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.Security.Authentication.ExtendedProtection.ChannelBinding" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Write">
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>将数据写入此流。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public void Write (byte[] buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Write(unsigned int8[] buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.SslStream.Write(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub Write (buffer As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Write(cli::array &lt;System::Byte&gt; ^ buffer);" />
      <MemberSignature Language="F#" Value="override this.Write : byte[] -&gt; unit" Usage="sslStream.Write buffer" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Mono.Net.Security.IMonoSslStream.Write(System.Byte[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="buffer">一个 <see cref="T:System.Byte" /> 数组，该数组提供要写入流中的字节。</param>
        <summary>将指定的数据写入此流。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法会阻止该操作完成时。 若要阻止阻塞该操作完成时，使用<xref:System.Net.Security.SslStream.BeginWrite%2A>方法。  
  
 不能调用此方法，直到您已成功通过身份验证。 若要进行身份验证的调用一个<xref:System.Net.Security.SslStream.AuthenticateAsClient%2A>，或<xref:System.Net.Security.SslStream.BeginAuthenticateAsClient%2A>， <xref:System.Net.Security.SslStream.AuthenticateAsServer%2A>，<xref:System.Net.Security.SslStream.BeginAuthenticateAsServer%2A>方法。  
  
 <xref:System.Net.Security.SslStream>类不支持多个同时进行写入操作。  
  
   
  
## Examples  
 下面的代码示例演示如何写入经过身份验证的<xref:System.Net.Security.SslStream>。  
  
 [!code-cpp[NclSslServerSync#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NclSslServerSync/CPP/NclSslServerSync.cpp#1)]
 [!code-csharp[NclSslServerSync#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NclSslServerSync/CS/serversync.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.IO.IOException">写操作失败。</exception>
        <exception cref="T:System.NotSupportedException">已存在一个正在执行的写操作。</exception>
        <exception cref="T:System.ObjectDisposedException">此对象已关闭。</exception>
        <exception cref="T:System.InvalidOperationException">未进行身份验证。</exception>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public override void Write (byte[] buffer, int offset, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Write(unsigned int8[] buffer, int32 offset, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.SslStream.Write(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Write (buffer As Byte(), offset As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Write(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count);" />
      <MemberSignature Language="F#" Value="override this.Write : byte[] * int * int -&gt; unit" Usage="sslStream.Write (buffer, offset, count)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Mono.Net.Security.IMonoSslStream.Write(System.Byte[],System.Int32,System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">一个 <see cref="T:System.Byte" /> 数组，该数组提供要写入流中的字节。</param>
        <param name="offset">
          <see cref="T:System.Int32" />，它包含 <c>buffer</c> 中从零开始的位置，从该位置开始读取要写入流中的字节。</param>
        <param name="count">
          <see cref="T:System.Int32" />，包含要从 <c>buffer</c> 中读取的字节数。</param>
        <summary>使用指定的缓冲区和偏移将指定数目的 <see cref="T:System.Byte" /> 写入基础流。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法会阻止该操作完成时。 若要防止在操作完成该操作完成后，使用<xref:System.Net.Security.SslStream.BeginWrite%2A>方法。  
  
 不能调用此方法，直到您已成功通过身份验证。 若要进行身份验证的调用一个<xref:System.Net.Security.SslStream.AuthenticateAsClient%2A>，或<xref:System.Net.Security.SslStream.BeginAuthenticateAsClient%2A>， <xref:System.Net.Security.SslStream.AuthenticateAsServer%2A>，<xref:System.Net.Security.SslStream.BeginAuthenticateAsServer%2A>方法。  
  
 <xref:System.Net.Security.SslStream>类不支持多个同时进行写入操作。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="offset" />
          <paramref name="&lt;" />
          <paramref name="0" />.  
  
 <paramref name="-or-" /><paramref name="offset" /> &gt; <paramref name="buffer" /> 的长度。  -或-  <paramref name="offset" /> + count &gt; <paramref name="buffer" /> 的长度。</exception>
        <exception cref="T:System.IO.IOException">写操作失败。</exception>
        <exception cref="T:System.NotSupportedException">已存在一个正在执行的写操作。</exception>
        <exception cref="T:System.ObjectDisposedException">此对象已关闭。</exception>
        <exception cref="T:System.InvalidOperationException">未进行身份验证。</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteTimeout">
      <MemberSignature Language="C#" Value="public override int WriteTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 WriteTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.SslStream.WriteTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property WriteTimeout As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int WriteTimeout { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.WriteTimeout : int with get, set" Usage="System.Net.Security.SslStream.WriteTimeout" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Mono.Net.Security.IMonoSslStream.WriteTimeout</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置写操作阻止等待数据的时间。</summary>
        <value>
          <see cref="T:System.Int32" />，指定同步写操作失败前经过的时间。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此属性返回通过调用返回的值<xref:System.IO.Stream.WriteTimeout%2A>对基础流。 对于集合运算指定的值设置<xref:System.IO.Stream.WriteTimeout%2A>基础流上的值。  
  
 基础流是否<xref:System.Net.Sockets.NetworkStream>，<xref:System.Net.Security.SslStream.WriteTimeout%2A>以毫秒为单位并将设置为<xref:System.Threading.Timeout.Infinite>默认情况下，这样写操作就不会超时。  
  
   
  
## Examples  
 下面的代码示例演示如何设置此属性的值。  
  
 [!code-cpp[NclSslServerSync#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NclSslServerSync/CPP/NclSslServerSync.cpp#1)]
 [!code-csharp[NclSslServerSync#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NclSslServerSync/CS/serversync.cs#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>