<Type Name="HttpWebRequest" FullName="System.Net.HttpWebRequest">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="ee23b22d09b71a5e9846468337a5e386b92bdc30" />
    <Meta Name="ms.sourcegitcommit" Value="0ec122ee5f3681159b8460ab15b409fd6e3d3ae0" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-CN" />
    <Meta Name="ms.lasthandoff" Value="10/04/2018" />
    <Meta Name="ms.locfileid" Value="48742353" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class HttpWebRequest : System.Net.WebRequest, System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable HttpWebRequest extends System.Net.WebRequest implements class System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="DocId" Value="T:System.Net.HttpWebRequest" />
  <TypeSignature Language="VB.NET" Value="Public Class HttpWebRequest&#xA;Inherits WebRequest&#xA;Implements ISerializable" />
  <TypeSignature Language="C++ CLI" Value="public ref class HttpWebRequest : System::Net::WebRequest, System::Runtime::Serialization::ISerializable" />
  <TypeSignature Language="F#" Value="type HttpWebRequest = class&#xA;    inherit WebRequest&#xA;    interface ISerializable" />
  <AssemblyInfo>
    <AssemblyName>System.Net.Requests</AssemblyName>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Net</AssemblyName>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Net.WebRequest</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.ISerializable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.Runtime.CompilerServices.FriendAccessAllowed</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>提供 <see cref="T:System.Net.WebRequest" /> 类的 HTTP 特定的实现。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest>类提供支持的属性和方法中定义<xref:System.Net.WebRequest>以及其他属性和方法，使用户直接通过 HTTP 与服务器交互。  
  
 不要使用<xref:System.Net.HttpWebRequest.%23ctor%2A>构造函数。 使用<xref:System.Net.WebRequest.Create%2A?displayProperty=nameWithType>方法初始化新<xref:System.Net.HttpWebRequest>对象。 如果方案的统一资源标识符 (URI) 是`http://`或`https://`，<xref:System.Net.WebRequest.Create%2A>返回<xref:System.Net.HttpWebRequest>对象。  
  
 <xref:System.Net.HttpWebRequest.GetResponse%2A>方法中指定的资源发出同步请求<xref:System.Net.HttpWebRequest.RequestUri%2A>属性，并返回<xref:System.Net.HttpWebResponse>包含响应对象。 可以使用返回的流接收的响应数据<xref:System.Net.HttpWebResponse.GetResponseStream%2A>。 如果关闭响应对象或响应流时，剩余数据将作废。 将耗尽剩余的数据并关闭流的响应对象，如果以下条件成立时，将为后续请求重新使用套接字： 它是保持活动状态或通过管线传输请求，只有少量的数据需要接收，或在较短时间间隔内收到剩余数据。 如果没有提到条件保存或超出消耗时间，将关闭套接字。 为保持活动状态或通过管道传递的连接，我们强烈建议在应用程序直到 EOF 读取流。 这可确保将生成更好的性能和更低的使用的资源的后续请求重复使用套接字。  
  
 如果想要将数据发送到的资源<xref:System.Net.HttpWebRequest.GetRequestStream%2A>方法将返回<xref:System.IO.Stream>对象，用于将数据发送。 <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A>和<xref:System.Net.HttpWebRequest.EndGetRequestStream%2A>方法提供对发送数据流的异步访问。  
  
 客户端身份验证与<xref:System.Net.HttpWebRequest>，客户端证书必须安装在我的当前用户的证书存储。  
  
 <xref:System.Net.HttpWebRequest>类将引发<xref:System.Net.WebException>访问资源时出现错误时。 <xref:System.Net.WebException.Status%2A?displayProperty=nameWithType>属性包含<xref:System.Net.WebExceptionStatus>值，该值指示错误的源。 当<xref:System.Net.WebException.Status%2A?displayProperty=nameWithType>是<xref:System.Net.WebExceptionStatus.ProtocolError?displayProperty=nameWithType>，则<xref:System.Net.WebException.Response%2A>属性包含<xref:System.Net.HttpWebResponse>从资源接收。  
  
 <xref:System.Net.HttpWebRequest> 公开常见 HTTP 标头值作为属性发送到 Internet 资源，由方法，或设置由系统;下表包含的完整列表。 您可以在设置其他标头<xref:System.Net.HttpWebRequest.Headers%2A>属性作为名称/值对。 请注意服务器和缓存可能会更改或在请求过程中添加标头。  
  
 下表列出了通过属性或方法或系统设置的 HTTP 标头。  
  
|Header|通过设置|  
|------------|------------|  
|接受|通过设置<xref:System.Net.HttpWebRequest.Accept%2A>属性。|  
|连接|通过设置<xref:System.Net.HttpWebRequest.Connection%2A>属性，<xref:System.Net.HttpWebRequest.KeepAlive%2A>属性。|  
|内容长度|通过设置<xref:System.Net.HttpWebRequest.ContentLength%2A>属性。|  
|Content-Type|通过设置<xref:System.Net.HttpWebRequest.ContentType%2A>属性。|  
|期望|通过设置<xref:System.Net.HttpWebRequest.Expect%2A>属性。|  
|日期|设置当前日期到系统。|  
|Host|设置为当前主机信息系统。|  
|如果-修改-自|通过设置<xref:System.Net.HttpWebRequest.IfModifiedSince%2A>属性。|  
|范围|通过设置<xref:System.Net.HttpWebRequest.AddRange%2A>方法。|  
|引用站点|通过设置<xref:System.Net.HttpWebRequest.Referer%2A>属性。|  
|传输编码|通过设置<xref:System.Net.HttpWebRequest.TransferEncoding%2A>属性 (<xref:System.Net.HttpWebRequest.SendChunked%2A>属性必须为`true`)。|  
|用户代理|通过设置<xref:System.Net.HttpWebRequest.UserAgent%2A>属性。|  
  
> [!NOTE]
>  <xref:System.Net.HttpWebRequest> 已自动注册。 不需要调用<xref:System.Net.WebRequest.RegisterPrefix%2A>方法来注册<xref:System.Net.HttpWebRequest?displayProperty=nameWithType>之前使用 Uri 开头`http://`或`https://`。  
  
 在本地计算机或应用程序配置文件可以指定使用默认代理。 如果<xref:System.Net.HttpWebRequest.Proxy%2A>指定属性，然后从的代理设置<xref:System.Net.HttpWebRequest.Proxy%2A>属性重写在本地计算机或应用程序配置文件和<xref:System.Net.HttpWebRequest>实例将使用指定的代理设置。 如果未指定代理配置文件中，<xref:System.Net.HttpWebRequest.Proxy%2A>属性未指定，<xref:System.Net.HttpWebRequest>类使用继承自 Internet 资源管理器在本地计算机上的代理设置。 如果没有在 Internet Explorer 代理设置，该请求是直接发送到服务器。  
  
 <xref:System.Net.HttpWebRequest>类继承自 Internet 资源管理器以不同的方式不是直接通过 Internet Explorer 分析跳过列表的通配符字符与分析代理跳过列表。 例如，<xref:System.Net.HttpWebRequest>类分析的正则表达式的"nt *"从 Internet 资源管理器的跳过列表"nt。 $"。 这不同于 Internet Explorer 的本机行为。 因此的 URL"`http://intxxxxx`"将绕过代理帐户使用<xref:System.Net.HttpWebRequest>类，但将不使用 Internet Explorer 使用代理。  
  
> [!NOTE]
>  框架缓存 SSL 会话，因为它们创建并尝试再次使用的会话缓存适用于新的请求，在可能的情况。 在尝试以重复使用的 SSL 会话时，框架将使用的第一个元素<xref:System.Net.HttpWebRequest.ClientCertificates%2A>（如果没有一个），或尝试重复使用匿名会话，如果<xref:System.Net.HttpWebRequest.ClientCertificates%2A>为空。  
  
> [!NOTE]
>  出于安全原因，默认情况下禁用了 cookie。 如果你想要使用 cookie，则使用<xref:System.Net.HttpWebRequest.CookieContainer%2A>属性，以便启用 cookie。  
  
 .NET Framework 4.6 包括一个新的安全功能，将阻止不安全的密码和哈希算法的连接。 默认情况下，使用 TLS/SSL 通过 HttpClient、 HttpWebRequest、 FTPClient，SmtpClient、 SslStream 等 Api 和面向.NET Framework 4.6 的应用程序获得更安全的行为。  
  
 开发人员可能想要选择退出此行为以便保持与带 RC4 服务及其现有 SSL3 服务或 TLS 互操作性。 [这篇文章](https://support.microsoft.com/kb/3069494)介绍了如何修改你的代码，以便禁用新行为。  
  
   
  
## Examples  
 下面的代码示例将创建<xref:System.Net.HttpWebRequest>uri http://www.contoso.com/。  
  
 [!code-cpp[Classic HttpWebRequest Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic HttpWebRequest Example/CPP/source.cpp#1)]
 [!code-csharp[Classic HttpWebRequest Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic HttpWebRequest Example/CS/source.cs#1)]
 [!code-vb[Classic HttpWebRequest Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic HttpWebRequest Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <permission cref="T:System.Net.WebPermission">若要访问请求的 URI 或请求重定向到任何 URI。 关联的枚举： <see cref="F:System.Net.NetworkAccess.Connect" /></permission>
    <related type="Article" href="http://msdn.microsoft.com/library/9d663c4b-07b4-4f6f-9b12-efbd3630354f">DefaultProxy 元素 （网络设置）</related>
    <related type="Article" href="http://msdn.microsoft.com/library/8bf0b428-5a21-4299-8d6e-bf8251fd978a">版本 3.5 SP1 中对 HTTPWebRequest 的 NTLM 身份验证的更改</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>初始化 <see cref="T:System.Net.HttpWebRequest" /> 类的新实例。 这些构造函数已过时；请参阅“备注”部分，了解详细信息。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

同时<xref:System.Net.HttpWebRequest>构造函数已过时，并且不应使用。 调用<xref:System.Net.WebRequest.CreateHttp%2A?displayProperty=nameWithType>方法初始化新<xref:System.Net.HttpWebRequest>对象。     
  
      ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public HttpWebRequest ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; HttpWebRequest();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("This API supports the .NET Framework infrastructure and is not intended to be used directly from your code.", true)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>初始化 <see cref="T:System.Net.HttpWebRequest" /> 类的新实例。 此构造函数已过时。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public HttpWebRequest (Uri uri);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Uri uri) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.#ctor(System.Uri)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; HttpWebRequest(Uri ^ uri);" />
      <MemberSignature Language="F#" Value="new System.Net.HttpWebRequest : Uri -&gt; System.Net.HttpWebRequest" Usage="new System.Net.HttpWebRequest uri" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="uri" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="uri">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected HttpWebRequest (System.Runtime.Serialization.SerializationInfo serializationInfo, System.Runtime.Serialization.StreamingContext streamingContext);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.Runtime.Serialization.SerializationInfo serializationInfo, valuetype System.Runtime.Serialization.StreamingContext streamingContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; HttpWebRequest(System::Runtime::Serialization::SerializationInfo ^ serializationInfo, System::Runtime::Serialization::StreamingContext streamingContext);" />
      <MemberSignature Language="F#" Value="new System.Net.HttpWebRequest : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; System.Net.HttpWebRequest" Usage="new System.Net.HttpWebRequest (serializationInfo, streamingContext)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Serialization is obsoleted for this type", false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8">
          <AttributeName>System.Obsolete("Serialization is obsoleted for this type.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="serializationInfo" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="streamingContext" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="serializationInfo">包含序列化新 <see cref="T:System.Net.HttpWebRequest" /> 对象所需信息的 <see cref="T:System.Runtime.Serialization.SerializationInfo" /> 对象。</param>
        <param name="streamingContext">包含与新 <see cref="T:System.Net.HttpWebRequest" /> 对象关联的序列化流的源和目标的 <see cref="T:System.Runtime.Serialization.StreamingContext" /> 对象。</param>
        <summary>从 <see cref="T:System.Net.HttpWebRequest" /> 和 <see cref="T:System.Runtime.Serialization.SerializationInfo" /> 类的指定实例初始化 <see cref="T:System.Runtime.Serialization.StreamingContext" /> 类的新实例。 此构造函数已过时。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用序列化时，必须在完全信任模式下运行应用程序。  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Net.WebPermission">无限制地访问网络资源。 关联的枚举： <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
        <related type="Article" href="~/docs/standard/serialization/xml-and-soap-serialization.md">XML 和 SOAP 序列化</related>
      </Docs>
    </Member>
    <Member MemberName="Abort">
      <MemberSignature Language="C#" Value="public override void Abort ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Abort() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.Abort" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Abort ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Abort();" />
      <MemberSignature Language="F#" Value="override this.Abort : unit -&gt; unit" Usage="httpWebRequest.Abort " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>取消对 Internet 资源的请求。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.Abort%2A>方法取消对资源的请求。 取消请求后，调用<xref:System.Net.HttpWebRequest.GetResponse%2A>， <xref:System.Net.HttpWebRequest.BeginGetResponse%2A>， <xref:System.Net.HttpWebRequest.EndGetResponse%2A>， <xref:System.Net.HttpWebRequest.GetRequestStream%2A>， <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A>，或<xref:System.Net.HttpWebRequest.EndGetRequestStream%2A>方法使<xref:System.Net.WebException>与<xref:System.Net.WebException.Status%2A>属性设置为<xref:System.Net.WebExceptionStatus.RequestCanceled>。  
  
 <xref:System.Net.HttpWebRequest.Abort%2A>方法以同步方式执行对指定的回调<xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A>或<xref:System.Net.HttpWebRequest.BeginGetResponse%2A>方法如果<xref:System.Net.HttpWebRequest.Abort%2A>未完成这些操作时调用方法。 这可能导致潜在的死锁问题。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅[网络跟踪](http://msdn.microsoft.com/library/e993b7c3-087f-45d8-9c02-9dded936d804)。  
  
   
  
## Examples  
 对于异步请求，它是客户端应用程序来实现其自己的超时机制的责任。 下面的代码示例演示如何执行此操作。  
  
 [!code-cpp[System.Net.HttpWebRequest.BeginGetResponse#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.HttpWebRequest.BeginGetResponse/CPP/begingetresponse.cpp#1)]
 [!code-csharp[System.Net.HttpWebRequest.BeginGetResponse#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.HttpWebRequest.BeginGetResponse/CS/begingetresponse.cs#1)]
 [!code-vb[System.Net.HttpWebRequest.BeginGetResponse#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.HttpWebRequest.BeginGetResponse/VB/begingetresponse.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Accept">
      <MemberSignature Language="C#" Value="public string Accept { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Accept" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Accept" />
      <MemberSignature Language="VB.NET" Value="Public Property Accept As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Accept { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Accept : string with get, set" Usage="System.Net.HttpWebRequest.Accept" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置 <see langword="Accept" /> HTTP 标头的值。</summary>
        <value>
          <see langword="Accept" /> HTTP 标头的值。 默认值为 <see langword="null" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要清除`Accept`HTTP 标头，设置<xref:System.Net.HttpWebRequest.Accept%2A>属性设置为`null`。  
  
> [!NOTE]
>  此属性的值存储在 <xref:System.Net.WebHeaderCollection> 中。 如果设置了 WebHeaderCollection，则该属性值将丢失。  
  
   
  
## Examples  
 下面的代码示例设置<xref:System.Net.HttpWebRequest.Accept%2A>属性。  
  
 [!code-cpp[HttpWebRequest_Accept#1](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_Accept/CPP/httpwebrequest_accept.cpp#1)]
 [!code-csharp[HttpWebRequest_Accept#1](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_Accept/CS/httpwebrequest_accept.cs#1)]
 [!code-vb[HttpWebRequest_Accept#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_Accept/VB/httpwebrequest_accept.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AddRange">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>向请求添加范围标头。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 由于 HTTP 的所有实体都都包含在 HTTP 消息作为字节序列，是对 HTTP 的任何实体有意义的字节范围概念。 但是，并非所有客户端和服务器必须支持字节范围操作。  
  
 请求的范围标头允许客户端请求它仅想要接收的字节指定范围的某些部分中的 HTTP 实体。 服务器不需要支持范围标头请求。  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddRange">
      <MemberSignature Language="C#" Value="public void AddRange (int range);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddRange(int32 range) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.AddRange(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddRange (range As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddRange(int range);" />
      <MemberSignature Language="F#" Value="member this.AddRange : int -&gt; unit" Usage="httpWebRequest.AddRange range" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="range" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="range">范围的开始点或结束点。</param>
        <summary>向请求添加从请求数据的开始处或结束处的特定范围的字节范围标头。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.AddRange%2A?displayProperty=nameWithType>方法将字节范围标头添加到请求。  
  
 如果`range`是正数，`range`参数指定的范围的起始点。 服务器应开始发送数据从`range`参数指定到末尾的 HTTP 实体中的数据。  
  
 如果`range`为负，`range`参数指定的范围的结束点。 服务器应该开始将数据发送到 HTTP 实体中的数据开始从`range`指定的参数。  
  
 由于 HTTP 的所有实体都都包含在 HTTP 消息作为字节序列，是对 HTTP 的任何实体有意义的字节范围概念。 但是，并非所有客户端和服务器必须支持字节范围操作。  
  
 请求的范围标头允许客户端请求它仅想要接收的字节指定范围的某些部分中的 HTTP 实体。 服务器不需要支持范围标头请求。  
  
 在请求服务器发送前 100 个字节 （从开头到字节位置 99） 将如下所示的 HTTP 协议请求中的范围标头的示例：  
  
 `Range: bytes=0-99\r\n\r\n`  
  
 此示例中，为`range`参数应为-99 之间。  
  
 HTTP 服务器指示支持的范围标头与 Accept-ranges 标头。 支持字节范围的服务器的 Accept-ranges 标头的示例将如下所示：  
  
 `Accept-Ranges: bytes\r\n\r\n`  
  
 Accept-ranges 标头未收到来自服务器的响应的标头中，如果服务器不支持范围标头。 从服务器不支持范围，但可以识别 Accept-ranges 标头，Accept-ranges 标头的示例将如下所示：  
  
 `Accept-Ranges: none\r\n\r\n`  
  
 从接收时响应范围请求，分析和可通过上的属性仅与整个请求相关联的 HTTP 标头<xref:System.Net.HttpWebResponse>类。 在响应中返回与每个范围关联的标题。  
  
   
  
## Examples  
 下面的代码示例将添加到请求的范围标头。  
  
 [!code-cpp[System.Net.HttpWebRequest.AddRange#1](~/samples/snippets/cpp/VS_Snippets_Misc/system.net.httpwebrequest.addrange/cpp/source.cpp#1)]
 [!code-csharp[System.Net.HttpWebRequest.AddRange#1](~/samples/snippets/csharp/VS_Snippets_Misc/system.net.httpwebrequest.addrange/cs/source.cs#1)]
 [!code-vb[System.Net.HttpWebRequest.AddRange#1](~/samples/snippets/visualbasic/VS_Snippets_Misc/system.net.httpwebrequest.addrange/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="rangeSpecifier" /> 无效。</exception>
        <exception cref="T:System.InvalidOperationException">无法添加范围标头。</exception>
        <altmember cref="Overload:System.Net.HttpWebRequest.AddRange" />
      </Docs>
    </Member>
    <Member MemberName="AddRange">
      <MemberSignature Language="C#" Value="public void AddRange (long range);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddRange(int64 range) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.AddRange(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddRange (range As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddRange(long range);" />
      <MemberSignature Language="F#" Value="member this.AddRange : int64 -&gt; unit" Usage="httpWebRequest.AddRange range" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="range" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="range">范围的开始点或结束点。</param>
        <summary>向请求添加从请求数据的开始处或结束处的特定范围的字节范围标头。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.AddRange%2A?displayProperty=nameWithType>方法将字节范围标头添加到请求。  
  
 如果`range`是正数，`range`参数指定的范围的起始点。 服务器应开始发送数据从`range`参数指定到末尾的 HTTP 实体中的数据。  
  
 如果`range`为负，`range`参数指定的范围的结束点。 服务器应该开始将数据发送到 HTTP 实体中的数据开始从`range`指定的参数。  
  
 由于 HTTP 的所有实体都都包含在 HTTP 消息作为字节序列，是对 HTTP 的任何实体有意义的字节范围概念。 但是，并非所有客户端和服务器必须支持字节范围操作。  
  
 请求的范围标头允许客户端请求它仅想要接收的字节指定范围的某些部分中的 HTTP 实体。 服务器不需要支持范围标头请求。  
  
 在请求服务器发送前 100 个字节 （从开头到字节位置 99） 将如下所示的 HTTP 协议请求中的范围标头的示例：  
  
 `Range: bytes=0-99\r\n\r\n`  
  
 此示例中，为`range`参数应为-99 之间。  
  
 HTTP 服务器指示支持的范围标头与 Accept-ranges 标头。 支持字节范围的服务器的 Accept-ranges 标头的示例将如下所示：  
  
 `Accept-Ranges: bytes\r\n\r\n`  
  
 Accept-ranges 标头未收到来自服务器的响应的标头中，如果服务器不支持范围标头。 从服务器不支持范围，但可以识别 Accept-ranges 标头，Accept-ranges 标头的示例将如下所示：  
  
 `Accept-Ranges: none\r\n\r\n`  
  
 从接收时响应范围请求，分析和可通过上的属性仅与整个请求相关联的 HTTP 标头<xref:System.Net.HttpWebResponse>类。 在响应中返回与每个范围关联的标题。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="rangeSpecifier" /> 无效。</exception>
        <exception cref="T:System.InvalidOperationException">无法添加范围标头。</exception>
        <altmember cref="Overload:System.Net.HttpWebRequest.AddRange" />
      </Docs>
    </Member>
    <Member MemberName="AddRange">
      <MemberSignature Language="C#" Value="public void AddRange (int from, int to);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddRange(int32 from, int32 to) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.AddRange(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddRange (from As Integer, to As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddRange(int from, int to);" />
      <MemberSignature Language="F#" Value="member this.AddRange : int * int -&gt; unit" Usage="httpWebRequest.AddRange (from, to)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="from" Type="System.Int32" />
        <Parameter Name="to" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="from">开始发送数据的位置。</param>
        <param name="to">停止发送数据的位置。</param>
        <summary>向请求添加指定范围的字节范围标头。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.AddRange%2A?displayProperty=nameWithType>方法将字节范围标头添加到请求。  
  
 由于 HTTP 的所有实体都都包含在 HTTP 消息作为字节序列，是对 HTTP 的任何实体有意义的字节范围概念。 但是，并非所有客户端和服务器必须支持字节范围操作。  
  
 请求的范围标头允许客户端请求它仅想要接收的字节指定范围的某些部分中的 HTTP 实体。 服务器不需要支持范围标头请求。  
  
 请求前 100 个字节会通过 HTTP 协议请求中的范围标头的示例应如下所示：  
  
 `Range: bytes=0-99\r\n\r\n`  
  
 对于本例，请`from`参数将被指定为 0 和`to`参数会被指定为 99。 范围说明符将自动设置为"bytes"中，此方法。  
  
 HTTP 服务器指示支持的范围标头与 Accept-ranges 标头。 支持字节范围的服务器的 Accept-ranges 标头的示例将如下所示：  
  
 `Accept-Ranges: bytes\r\n\r\n`  
  
 Accept-ranges 标头未收到来自服务器的响应的标头中，如果服务器不支持范围标头。 从服务器不支持范围，但可以识别 Accept-ranges 标头，Accept-ranges 标头的示例将如下所示：  
  
 `Accept-Ranges: none\r\n\r\n`  
  
 从接收时响应范围请求，分析和可通过上的属性仅与整个请求相关联的 HTTP 标头<xref:System.Net.HttpWebResponse>类。 在响应中返回与每个范围关联的标题。  
  
   
  
## Examples  
 下面的代码示例将添加到请求的范围标头。  
  
 [!code-cpp[System.Net.HttpWebRequest.AddRange2#1](~/samples/snippets/cpp/VS_Snippets_Misc/system.net.httpwebrequest.addrange2/cpp/source.cpp#1)]
 [!code-csharp[System.Net.HttpWebRequest.AddRange2#1](~/samples/snippets/csharp/VS_Snippets_Misc/system.net.httpwebrequest.addrange2/cs/source.cs#1)]
 [!code-vb[System.Net.HttpWebRequest.AddRange2#1](~/samples/snippets/visualbasic/VS_Snippets_Misc/system.net.httpwebrequest.addrange2/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="rangeSpecifier" /> 无效。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="from" /> 大于 <paramref name="to" />  
  
或 
 <paramref name="from" /> 或 <paramref name="to" /> 小于 0。</exception>
        <exception cref="T:System.InvalidOperationException">无法添加范围标头。</exception>
        <altmember cref="Overload:System.Net.HttpWebRequest.AddRange" />
      </Docs>
    </Member>
    <Member MemberName="AddRange">
      <MemberSignature Language="C#" Value="public void AddRange (long from, long to);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddRange(int64 from, int64 to) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.AddRange(System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddRange (from As Long, to As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddRange(long from, long to);" />
      <MemberSignature Language="F#" Value="member this.AddRange : int64 * int64 -&gt; unit" Usage="httpWebRequest.AddRange (from, to)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="from" Type="System.Int64" />
        <Parameter Name="to" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="from">开始发送数据的位置。</param>
        <param name="to">停止发送数据的位置。</param>
        <summary>向请求添加指定范围的字节范围标头。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.AddRange%2A?displayProperty=nameWithType>方法将字节范围标头添加到请求。  
  
 由于 HTTP 的所有实体都都包含在 HTTP 消息作为字节序列，是对 HTTP 的任何实体有意义的字节范围概念。 但是，并非所有客户端和服务器必须支持字节范围操作。  
  
 请求的范围标头允许客户端请求它仅想要接收的字节指定范围的某些部分中的 HTTP 实体。 服务器不需要支持范围标头请求。  
  
 请求前 100 个字节会通过 HTTP 协议请求中的范围标头的示例应如下所示：  
  
 `Range: bytes=0-99\r\n\r\n`  
  
 对于本例，请`from`参数将被指定为 0 和`to`参数会被指定为 99。 范围说明符将自动设置为"bytes"中，此方法。  
  
 HTTP 服务器指示支持的范围标头与 Accept-ranges 标头。 支持字节范围的服务器的 Accept-ranges 标头的示例将如下所示：  
  
 `Accept-Ranges: bytes\r\n\r\n`  
  
 Accept-ranges 标头未收到来自服务器的响应的标头中，如果服务器不支持范围标头。 从服务器不支持范围，但可以识别 Accept-ranges 标头，Accept-ranges 标头的示例将如下所示：  
  
 `Accept-Ranges: none\r\n\r\n`  
  
 从接收时响应范围请求，分析和可通过上的属性仅与整个请求相关联的 HTTP 标头<xref:System.Net.HttpWebResponse>类。 在响应中返回与每个范围关联的标题。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="rangeSpecifier" /> 无效。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="from" /> 大于 <paramref name="to" />  
  
或 
 <paramref name="from" /> 或 <paramref name="to" /> 小于 0。</exception>
        <exception cref="T:System.InvalidOperationException">无法添加范围标头。</exception>
        <altmember cref="Overload:System.Net.HttpWebRequest.AddRange" />
      </Docs>
    </Member>
    <Member MemberName="AddRange">
      <MemberSignature Language="C#" Value="public void AddRange (string rangeSpecifier, int range);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddRange(string rangeSpecifier, int32 range) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.AddRange(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddRange (rangeSpecifier As String, range As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddRange(System::String ^ rangeSpecifier, int range);" />
      <MemberSignature Language="F#" Value="member this.AddRange : string * int -&gt; unit" Usage="httpWebRequest.AddRange (rangeSpecifier, range)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rangeSpecifier" Type="System.String" />
        <Parameter Name="range" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="rangeSpecifier">范围说明。</param>
        <param name="range">范围的开始点或结束点。</param>
        <summary>向请求添加从请求数据的开始处或结束处计算的特定范围的 Range 标头。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.AddRange%2A?displayProperty=nameWithType>方法向请求添加范围标头。  
  
 如果`range`是正数，`range`参数指定的范围的起始点。 服务器应开始发送数据从`range`参数指定到末尾的 HTTP 实体中的数据。  
  
 如果`range`为负，`range`参数指定的范围的结束点。 服务器应该开始将数据发送到 HTTP 实体中的数据开始从`range`指定的参数。  
  
 由于 HTTP 的所有实体都都包含在 HTTP 消息作为字节序列，是对 HTTP 的任何实体有意义的字节范围概念。 但是，并非所有客户端和服务器必须支持字节范围操作。  
  
 请求的范围标头允许客户端请求它仅想要接收的字节指定范围的某些部分中的 HTTP 实体。 服务器不需要支持范围标头请求。  
  
 `rangeSpecifier`参数将通常被指定为"bytes"，因为这是唯一的大多数 HTTP 服务器识别的范围说明符。 设置`rangeSpecifier`对某些其他字符串的参数可支持除字节数 （由 IETF RFC 2616 中定义的字节范围说明符） 以外的自定义范围说明符。  
  
 请求前 100 个字节会通过 HTTP 协议请求中的范围标头的示例应如下所示：  
  
 `Range: bytes=-99\r\n\r\n`  
  
 对于本例，请`rangeSpecifier`参数将被指定为"bytes"和`range`参数应为-99 之间。  
  
 HTTP 服务器指示支持的范围标头包含在响应中 Accept-ranges 标头。 支持字节范围的服务器的 Accept-ranges 标头的示例将如下所示：  
  
 `Accept-Ranges: bytes\r\n\r\n`  
  
 Accept-ranges 标头未收到来自服务器的响应的标头中，如果服务器不支持范围标头。 从服务器不支持范围，但可以识别 Accept-ranges 标头，Accept-ranges 标头的示例将如下所示：  
  
 `Accept-Ranges: none\r\n\r\n`  
  
 从接收时响应范围请求，分析和可通过上的属性仅与整个请求相关联的 HTTP 标头<xref:System.Net.HttpWebResponse>类。 在响应中返回与每个范围关联的标题。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rangeSpecifier" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="rangeSpecifier" /> 无效。</exception>
        <exception cref="T:System.InvalidOperationException">无法添加范围标头。</exception>
        <altmember cref="Overload:System.Net.HttpWebRequest.AddRange" />
      </Docs>
    </Member>
    <Member MemberName="AddRange">
      <MemberSignature Language="C#" Value="public void AddRange (string rangeSpecifier, long range);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddRange(string rangeSpecifier, int64 range) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.AddRange(System.String,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddRange (rangeSpecifier As String, range As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddRange(System::String ^ rangeSpecifier, long range);" />
      <MemberSignature Language="F#" Value="member this.AddRange : string * int64 -&gt; unit" Usage="httpWebRequest.AddRange (rangeSpecifier, range)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rangeSpecifier" Type="System.String" />
        <Parameter Name="range" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="rangeSpecifier">范围说明。</param>
        <param name="range">范围的开始点或结束点。</param>
        <summary>向请求添加从请求数据的开始处或结束处计算的特定范围的 Range 标头。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.AddRange%2A?displayProperty=nameWithType>方法向请求添加范围标头。  
  
 如果`range`是正数，`range`参数指定的范围的起始点。 服务器应开始发送数据从`range`参数指定到末尾的 HTTP 实体中的数据。  
  
 如果`range`为负，`range`参数指定的范围的结束点。 服务器应该开始将数据发送到 HTTP 实体中的数据开始从`range`指定的参数。  
  
 由于 HTTP 的所有实体都都包含在 HTTP 消息作为字节序列，是对 HTTP 的任何实体有意义的字节范围概念。 但是，并非所有客户端和服务器必须支持字节范围操作。  
  
 请求的范围标头允许客户端请求它仅想要接收的字节指定范围的某些部分中的 HTTP 实体。 服务器不需要支持范围标头请求。  
  
 `rangeSpecifier`参数将通常被指定为"bytes"，因为这是唯一的大多数 HTTP 服务器识别的范围说明符。 设置`rangeSpecifier`对某些其他字符串的参数可支持除字节数 （由 IETF RFC 2616 中定义的字节范围说明符） 以外的自定义范围说明符。  
  
 请求前 100 个字节会通过 HTTP 协议请求中的范围标头的示例应如下所示：  
  
 `Range: bytes=-99\r\n\r\n`  
  
 对于本例，请`rangeSpecifier`参数将被指定为"bytes"和`range`参数应为-99 之间。  
  
 HTTP 服务器指示支持的范围标头包含在响应中 Accept-ranges 标头。 支持字节范围的服务器的 Accept-ranges 标头的示例将如下所示：  
  
 `Accept-Ranges: bytes\r\n\r\n`  
  
 Accept-ranges 标头未收到来自服务器的响应的标头中，如果服务器不支持范围标头。 从服务器不支持范围，但可以识别 Accept-ranges 标头，Accept-ranges 标头的示例将如下所示：  
  
 `Accept-Ranges: none\r\n\r\n`  
  
 从接收时响应范围请求，分析和可通过上的属性仅与整个请求相关联的 HTTP 标头<xref:System.Net.HttpWebResponse>类。 在响应中返回与每个范围关联的标题。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rangeSpecifier" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="rangeSpecifier" /> 无效。</exception>
        <exception cref="T:System.InvalidOperationException">无法添加范围标头。</exception>
        <altmember cref="Overload:System.Net.HttpWebRequest.AddRange" />
      </Docs>
    </Member>
    <Member MemberName="AddRange">
      <MemberSignature Language="C#" Value="public void AddRange (string rangeSpecifier, int from, int to);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddRange(string rangeSpecifier, int32 from, int32 to) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.AddRange(System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddRange (rangeSpecifier As String, from As Integer, to As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddRange(System::String ^ rangeSpecifier, int from, int to);" />
      <MemberSignature Language="F#" Value="member this.AddRange : string * int * int -&gt; unit" Usage="httpWebRequest.AddRange (rangeSpecifier, from, to)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rangeSpecifier" Type="System.String" />
        <Parameter Name="from" Type="System.Int32" />
        <Parameter Name="to" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="rangeSpecifier">范围说明。</param>
        <param name="from">开始发送数据的位置。</param>
        <param name="to">停止发送数据的位置。</param>
        <summary>向请求添加指定范围的范围标头。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.AddRange%2A?displayProperty=nameWithType>方法向请求添加范围标头。  
  
 由于 HTTP 的所有实体都都包含在 HTTP 消息作为字节序列，是对 HTTP 的任何实体有意义的字节范围概念。 但是，并非所有客户端和服务器必须支持字节范围操作。  
  
 请求的范围标头允许客户端请求它仅想要接收的字节指定范围的某些部分中的 HTTP 实体。 服务器不需要支持范围标头请求。  
  
 `rangeSpecifier`参数将通常被指定为"bytes"，因为这是唯一的大多数 HTTP 服务器识别的范围说明符。 设置`rangeSpecifier`对某些其他字符串的参数可支持除字节数 （由 IETF RFC 2616 中定义的字节范围说明符） 以外的自定义范围说明符。  
  
 请求前 100 个字节会通过 HTTP 协议请求中的范围标头的示例应如下所示：  
  
 `Range: bytes=0-99\r\n\r\n`  
  
 对于本例，请`rangeSpecifier`参数将被指定为"bytes"，`from`参数应为 0，和`to`参数应为 99。  
  
 HTTP 服务器指示支持的范围标头包含在响应中 Accept-ranges 标头。 支持字节范围的服务器的 Accept-ranges 标头的示例将如下所示：  
  
 `Accept-Ranges: bytes\r\n\r\n`  
  
 Accept-ranges 标头中指定的字符串是将中通过指定范围说明符`rangeSpecifier`此方法的参数。  
  
 Accept-ranges 标头未收到来自服务器的响应的标头中，如果服务器不支持范围标头。 从服务器不支持范围，但可以识别 Accept-ranges 标头，Accept-ranges 标头的示例将如下所示：  
  
 `Accept-Ranges: none\r\n\r\n`  
  
 从接收时响应范围请求，分析和可通过上的属性仅与整个请求相关联的 HTTP 标头<xref:System.Net.HttpWebResponse>类。 在响应中返回与每个范围关联的标题。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rangeSpecifier" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="from" /> 大于 <paramref name="to" />  
  
或 
 <paramref name="from" /> 或 <paramref name="to" /> 小于 0。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="rangeSpecifier" /> 无效。</exception>
        <exception cref="T:System.InvalidOperationException">无法添加范围标头。</exception>
        <altmember cref="Overload:System.Net.HttpWebRequest.AddRange" />
      </Docs>
    </Member>
    <Member MemberName="AddRange">
      <MemberSignature Language="C#" Value="public void AddRange (string rangeSpecifier, long from, long to);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddRange(string rangeSpecifier, int64 from, int64 to) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.AddRange(System.String,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddRange (rangeSpecifier As String, from As Long, to As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddRange(System::String ^ rangeSpecifier, long from, long to);" />
      <MemberSignature Language="F#" Value="member this.AddRange : string * int64 * int64 -&gt; unit" Usage="httpWebRequest.AddRange (rangeSpecifier, from, to)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rangeSpecifier" Type="System.String" />
        <Parameter Name="from" Type="System.Int64" />
        <Parameter Name="to" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="rangeSpecifier">范围说明。</param>
        <param name="from">开始发送数据的位置。</param>
        <param name="to">停止发送数据的位置。</param>
        <summary>向请求添加指定范围的范围标头。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.AddRange%2A?displayProperty=nameWithType>方法向请求添加范围标头。  
  
 由于 HTTP 的所有实体都都包含在 HTTP 消息作为字节序列，是对 HTTP 的任何实体有意义的字节范围概念。 但是，并非所有客户端和服务器必须支持字节范围操作。  
  
 请求的范围标头允许客户端请求它仅想要接收的字节指定范围的某些部分中的 HTTP 实体。 服务器不需要支持范围标头请求。  
  
 `rangeSpecifier`参数将通常被指定为"bytes"，因为这是唯一的大多数 HTTP 服务器识别的范围说明符。 设置`rangeSpecifier`对某些其他字符串的参数可支持除字节数 （由 IETF RFC 2616 中定义的字节范围说明符） 以外的自定义范围说明符。  
  
 请求前 100 个字节会通过 HTTP 协议请求中的范围标头的示例应如下所示：  
  
 `Range: bytes=0-99\r\n\r\n`  
  
 对于本例，请`rangeSpecifier`参数将被指定为"bytes"，`from`参数应为 0，和`to`参数应为 99。  
  
 HTTP 服务器指示支持的范围标头包含在响应中 Accept-ranges 标头。 支持字节范围的服务器的 Accept-ranges 标头的示例将如下所示：  
  
 `Accept-Ranges: bytes\r\n\r\n`  
  
 Accept-ranges 标头中指定的字符串是将中通过指定范围说明符`rangeSpecifier`此方法的参数。  
  
 Accept-ranges 标头未收到来自服务器的响应的标头中，如果服务器不支持范围标头。 从服务器不支持范围，但可以识别 Accept-ranges 标头，Accept-ranges 标头的示例将如下所示：  
  
 `Accept-Ranges: none\r\n\r\n`  
  
 从接收时响应范围请求，分析和可通过上的属性仅与整个请求相关联的 HTTP 标头<xref:System.Net.HttpWebResponse>类。 在响应中返回与每个范围关联的标题。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rangeSpecifier" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="from" /> 大于 <paramref name="to" />  
  
或 
 <paramref name="from" /> 或 <paramref name="to" /> 小于 0。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="rangeSpecifier" /> 无效。</exception>
        <exception cref="T:System.InvalidOperationException">无法添加范围标头。</exception>
        <altmember cref="Overload:System.Net.HttpWebRequest.AddRange" />
      </Docs>
    </Member>
    <Member MemberName="Address">
      <MemberSignature Language="C#" Value="public Uri Address { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Uri Address" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Address" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Address As Uri" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Uri ^ Address { Uri ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Address : Uri" Usage="System.Net.HttpWebRequest.Address" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Uri</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取实际响应请求的 Internet 资源的统一资源标识符 (URI)。</summary>
        <value>标识实际对请求作出响应的 Internet 资源的 <see cref="T:System.Uri" />。 默认值是供 <see cref="M:System.Net.WebRequest.Create(System.String)" /> 方法用来初始化请求的 URI。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.Address%2A>在请求期间发生的任何重定向完成后，将属性设置为 URI。  
  
 原始请求的 URI 保留在<xref:System.Net.HttpWebRequest.RequestUri%2A>属性。  
  
   
  
## Examples  
 下面的代码示例检查以查看是否<xref:System.Net.HttpWebRequest>对象`req`已重定向到其他位置，以完成请求，并设置的值`hasChanged`变量`true`如果请求被重定向; 否则为`hasChanged`设置为`false`。  
  
 [!code-cpp[Classic HttpWebRequest.RequestUri Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic HttpWebRequest.RequestUri Example/CPP/source.cpp#1)]
 [!code-csharp[Classic HttpWebRequest.RequestUri Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic HttpWebRequest.RequestUri Example/CS/source.cs#1)]
 [!code-vb[Classic HttpWebRequest.RequestUri Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic HttpWebRequest.RequestUri Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AllowAutoRedirect">
      <MemberSignature Language="C#" Value="public virtual bool AllowAutoRedirect { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AllowAutoRedirect" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.AllowAutoRedirect" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property AllowAutoRedirect As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool AllowAutoRedirect { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AllowAutoRedirect : bool with get, set" Usage="System.Net.HttpWebRequest.AllowAutoRedirect" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值指示请求是否应跟随重定向响应。</summary>
        <value>如果请求应自动遵循来自 Internet 资源的重定向响应，则为 <see langword="true" />；否则为 <see langword="false" />。 默认值为 <see langword="true" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 设置<xref:System.Net.HttpWebRequest.AllowAutoRedirect%2A>到`true`如果你想要到新位置的资源自动遵循 HTTP 重定向标头的请求。 要遵循的重定向的最大数目设置<xref:System.Net.HttpWebRequest.MaximumAutomaticRedirections%2A>属性。  
  
 如果<xref:System.Net.HttpWebRequest.AllowAutoRedirect%2A>设置为`false`，所有响应的 HTTP 状态代码从 300 到 399 都返回到应用程序。  
  
 在自动重定向清除授权标头和<xref:System.Net.HttpWebRequest>会自动尝试到重定向的位置重新进行身份验证。 在实践中，这意味着，应用程序不能自定义身份验证将信息放到授权标头是否可能会遇到重定向。 相反，应用程序必须实现和注册自定义身份验证模块。 <xref:System.Net.AuthenticationManager?displayProperty=nameWithType>和相关的类用于实现自定义身份验证模块。 <xref:System.Net.AuthenticationManager.Register%2A?displayProperty=nameWithType>方法注册的自定义身份验证模块。  
  
   
  
## Examples  
 下面的代码示例使用<xref:System.Net.HttpWebRequest.AllowAutoRedirect%2A>属性，以允许跟随重定向响应的请求。  
  
 [!code-cpp[HttpWebRequest_AllowAutoRedirect#2](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_AllowAutoRedirect/CPP/httpwebrequest_allowautoredirect.cpp#2)]
 [!code-csharp[HttpWebRequest_AllowAutoRedirect#2](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_AllowAutoRedirect/CS/httpwebrequest_allowautoredirect.cs#2)]
 [!code-vb[HttpWebRequest_AllowAutoRedirect#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_AllowAutoRedirect/VB/httpwebrequest_allowautoredirect.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AllowReadStreamBuffering">
      <MemberSignature Language="C#" Value="public virtual bool AllowReadStreamBuffering { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AllowReadStreamBuffering" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.AllowReadStreamBuffering" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property AllowReadStreamBuffering As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool AllowReadStreamBuffering { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AllowReadStreamBuffering : bool with get, set" Usage="System.Net.HttpWebRequest.AllowReadStreamBuffering" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值指示是否对从 Internet 资源接收的数据进行缓冲处理。</summary>
        <value>如果为 <see langword="true" />，则启用对从 Internet 资源接收的数据进行缓冲处理；如果为 <see langword="false" />，则禁用缓冲处理。 默认值为 <see langword="false" />。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AllowWriteStreamBuffering">
      <MemberSignature Language="C#" Value="public virtual bool AllowWriteStreamBuffering { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AllowWriteStreamBuffering" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.AllowWriteStreamBuffering" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property AllowWriteStreamBuffering As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool AllowWriteStreamBuffering { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AllowWriteStreamBuffering : bool with get, set" Usage="System.Net.HttpWebRequest.AllowWriteStreamBuffering" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值指示是否对发送到 Internet 资源的数据进行缓冲处理。</summary>
        <value>如果为 <see langword="true" />，则允许对发送到 Internet 资源的数据进行缓冲处理；如果为 <see langword="false" />，则禁用缓冲处理。 默认值为 <see langword="true" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当<xref:System.Net.HttpWebRequest.AllowWriteStreamBuffering%2A>是`true`，在内存中缓冲数据，因此它已准备好重新发送重定向或身份验证请求。  
  
   
  
## Examples  
 下面的代码示例使用<xref:System.Net.HttpWebRequest.AllowWriteStreamBuffering%2A>属性禁用缓冲处理的数据。  
  
 [!code-cpp[HttpWebRequest_AllowWriteStreamBuffering#1](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_AllowWriteStreamBuffering/CPP/httpwebrequest_allowwritestreambuffering.cpp#1)]
 [!code-csharp[HttpWebRequest_AllowWriteStreamBuffering#1](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_AllowWriteStreamBuffering/CS/httpwebrequest_allowwritestreambuffering.cs#1)]
 [!code-vb[HttpWebRequest_AllowWriteStreamBuffering#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_AllowWriteStreamBuffering/VB/httpwebrequest_allowwritestreambuffering.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>设置<see cref="P:System.Net.HttpWebRequest.AllowWriteStreamBuffering" />到<see langword="true" />上传大型数据集，因为数据缓冲区可能会使用所有可用内存时可能会导致性能问题。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="AutomaticDecompression">
      <MemberSignature Language="C#" Value="public System.Net.DecompressionMethods AutomaticDecompression { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Net.DecompressionMethods AutomaticDecompression" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.AutomaticDecompression" />
      <MemberSignature Language="VB.NET" Value="Public Property AutomaticDecompression As DecompressionMethods" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::DecompressionMethods AutomaticDecompression { System::Net::DecompressionMethods get(); void set(System::Net::DecompressionMethods value); };" />
      <MemberSignature Language="F#" Value="member this.AutomaticDecompression : System.Net.DecompressionMethods with get, set" Usage="System.Net.HttpWebRequest.AutomaticDecompression" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.DecompressionMethods</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置所使用的解压缩类型。</summary>
        <value>一个<see cref="T:System.Net.DecompressionMethods" />对象，指示使用的解压缩类型。</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">对象的当前状态不允许设置此属性。</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginGetRequestStream">
      <MemberSignature Language="C#" Value="public override IAsyncResult BeginGetRequestStream (AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IAsyncResult BeginGetRequestStream(class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.BeginGetRequestStream(System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function BeginGetRequestStream (callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override IAsyncResult ^ BeginGetRequestStream(AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="override this.BeginGetRequestStream : AsyncCallback * obj -&gt; IAsyncResult" Usage="httpWebRequest.BeginGetRequestStream (callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="callback">
          <see cref="T:System.AsyncCallback" /> 委托。</param>
        <param name="state">此请求的状态对象。</param>
        <summary>开始对用于写入数据的 <see cref="T:System.IO.Stream" /> 对象执行异步请求。</summary>
        <returns>引用该异步请求的 <see cref="T:System.IAsyncResult" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A>方法启动用于将数据发送用于流的异步请求<xref:System.Net.HttpWebRequest>。 异步回调方法使用<xref:System.Net.HttpWebRequest.EndGetRequestStream%2A>方法以返回实际的流。  
  
 <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A>方法需要执行一些同步安装程序任务，此方法才会异步完成 （DNS 解析、 代理检测和 TCP 套接字连接，例如）。 因此，调用此方法应永远不会在用户界面 (UI) 线程上因为这可能需要相当长的时间 （最多几分钟时间，具体取决于网络设置） 才能完成，将引发错误异常之前的初始同步设置任务或该方法成功。  
  
 若要了解有关线程池的详细信息，请参阅[托管的线程池](~/docs/standard/threading/the-managed-thread-pool.md)。  
  
> [!NOTE]
>  你的应用程序不能混合同步和异步方法对特定请求。 如果您调用<xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A>方法，则必须使用<xref:System.Net.HttpWebRequest.BeginGetResponse%2A>方法以检索响应。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅[在.NET Framework 中进行网络跟踪](~/docs/framework/network-programming/network-tracing.md)。  
  
   
  
## Examples  
 下面的代码示例使用<xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A>进行的流实例的异步请求的方法。  
  
 [!code-cpp[HttpWebRequest_BeginGetRequestStream#2](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_BeginGetRequestStream/CPP/httpwebrequest_begingetrequeststream.cpp#2)]
 [!code-csharp[HttpWebRequest_BeginGetRequestStream#2](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_BeginGetRequestStream/CS/httpwebrequest_begingetrequeststream.cs#2)]
 [!code-vb[HttpWebRequest_BeginGetRequestStream#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_BeginGetRequestStream/VB/httpwebrequest_begingetrequeststream.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.ProtocolViolationException">
          <see cref="P:System.Net.HttpWebRequest.Method" /> 属性为 GET 或 HEAD。  
  
或 
 <see cref="P:System.Net.HttpWebRequest.KeepAlive" /> 为 <see langword="true" />，<see cref="P:System.Net.HttpWebRequest.AllowWriteStreamBuffering" /> 为 <see langword="false" />，<see cref="P:System.Net.HttpWebRequest.ContentLength" /> 为 -1，<see cref="P:System.Net.HttpWebRequest.SendChunked" /> 为 <see langword="false" />，<see cref="P:System.Net.HttpWebRequest.Method" /> 为 POST 或 PUT。</exception>
        <exception cref="T:System.InvalidOperationException">对 <see cref="M:System.Net.HttpWebRequest.BeginGetRequestStream(System.AsyncCallback,System.Object)" /> 的前一次调用正在使用流  
  
或 
 将 <see cref="P:System.Net.HttpWebRequest.TransferEncoding" /> 设置为一个值，且 <see cref="P:System.Net.HttpWebRequest.SendChunked" /> 为 <see langword="false" />。  
  
或 
线程池中线程即将耗尽。</exception>
        <exception cref="T:System.NotSupportedException">请求缓存验证程序指示对此请求的响应可从缓存中提供；但是，写入数据的请求不得使用缓存。 如果你正在使用错误实现的自定义缓存验证程序，则会发生此异常。</exception>
        <exception cref="T:System.Net.WebException">之前已调用 <see cref="M:System.Net.HttpWebRequest.Abort" />。</exception>
        <exception cref="T:System.ObjectDisposedException">在 .NET Compact Framework 应用程序中，未正确获得和关闭一个内容长度为零的请求流。 有关处理内容长度为零的请求的详细信息，请参阅 [.NET Compact Framework 中的网络编程](https://msdn.microsoft.com/subscriptions/downloads/1afx2b0f\(v=vs.80\).aspx)。</exception>
        <related type="Article" href="http://msdn.microsoft.com/library/9d663c4b-07b4-4f6f-9b12-efbd3630354f">DefaultProxy 元素 （网络设置）</related>
      </Docs>
    </Member>
    <Member MemberName="BeginGetResponse">
      <MemberSignature Language="C#" Value="public override IAsyncResult BeginGetResponse (AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IAsyncResult BeginGetResponse(class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.BeginGetResponse(System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function BeginGetResponse (callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override IAsyncResult ^ BeginGetResponse(AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="override this.BeginGetResponse : AsyncCallback * obj -&gt; IAsyncResult" Usage="httpWebRequest.BeginGetResponse (callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="callback">
          <see cref="T:System.AsyncCallback" /> 委托</param>
        <param name="state">此请求的状态对象。</param>
        <summary>开始对 Internet 资源的异步请求。</summary>
        <returns>引用对响应的异步请求的 <see cref="T:System.IAsyncResult" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.BeginGetResponse%2A>方法启动响应的异步请求从 Internet 资源。 异步回调方法使用<xref:System.Net.HttpWebRequest.EndGetResponse%2A>方法返回的实际<xref:System.Net.WebResponse>。  
  
 一个<xref:System.Net.ProtocolViolationException>上设置的属性时，某些情况下将引发<xref:System.Net.HttpWebRequest>类是冲突。 如果应用程序设置，会发生此异常<xref:System.Net.HttpWebRequest.ContentLength%2A>属性和<xref:System.Net.HttpWebRequest.SendChunked%2A>属性设置为`true`，然后将发送 HTTP GET 请求。 如果应用程序尝试向发送分块请求仅支持 HTTP 1.0 协议的服务器不支持此操作，会发生此异常。 如果应用程序尝试发送数据，而设置不会发生此异常<xref:System.Net.HttpWebRequest.ContentLength%2A>属性或<xref:System.Net.HttpWebRequest.SendChunked%2A>是`false`禁用缓冲，并且 keepalive 连接上 (<xref:System.Net.HttpWebRequest.KeepAlive%2A>属性是`true`)`.`  
  
 如果<xref:System.Net.WebException>是引发，使用<xref:System.Net.WebException.Response%2A>和<xref:System.Net.WebException.Status%2A>异常来确定来自服务器的响应的属性。  
  
 <xref:System.Net.HttpWebRequest.BeginGetResponse%2A>方法需要执行一些同步安装程序任务，此方法才会异步完成 （DNS 解析、 代理检测和 TCP 套接字连接，例如）。 因此，调用此方法应永远不会在用户界面 (UI) 线程上因为这可能需要相当长的时间 （最多几分钟时间，具体取决于网络设置） 才能完成，将引发错误异常之前的初始同步设置任务或该方法成功。  
  
 若要了解有关线程池的详细信息，请参阅[托管的线程池](~/docs/standard/threading/the-managed-thread-pool.md)。  
  
> [!NOTE]
>  你的应用程序不能混合同步和异步方法对特定请求。 如果您调用<xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A>方法，则必须使用<xref:System.Net.HttpWebRequest.BeginGetResponse%2A>方法以检索响应。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅[ &#91; \<topic://conUsingNetworkTracing >&#93;](http://msdn.microsoft.com/library/e993b7c3-087f-45d8-9c02-9dded936d804)。  
  
   
  
## Examples  
 下面的代码示例使用<xref:System.Net.HttpWebRequest.BeginGetResponse%2A>进行 Internet 资源的异步请求的方法。  
  
> [!NOTE]
>  对于异步请求，它是客户端应用程序来实现其自己的超时机制的责任。 下面的代码示例演示如何执行此操作。  
  
 [!code-cpp[System.Net.HttpWebRequest.BeginGetResponse#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.HttpWebRequest.BeginGetResponse/CPP/begingetresponse.cpp#1)]
 [!code-csharp[System.Net.HttpWebRequest.BeginGetResponse#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.HttpWebRequest.BeginGetResponse/CS/begingetresponse.cs#1)]
 [!code-vb[System.Net.HttpWebRequest.BeginGetResponse#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.HttpWebRequest.BeginGetResponse/VB/begingetresponse.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">流正由上一个 <see cref="M:System.Net.HttpWebRequest.BeginGetResponse(System.AsyncCallback,System.Object)" /> 调用使用  
  
或 
 将 <see cref="P:System.Net.HttpWebRequest.TransferEncoding" /> 设置为一个值，且 <see cref="P:System.Net.HttpWebRequest.SendChunked" /> 为 <see langword="false" />。  
  
或 
线程池中线程即将耗尽。</exception>
        <exception cref="T:System.Net.ProtocolViolationException">
          <see cref="P:System.Net.HttpWebRequest.Method" /> 为 GET 或 HEAD，且 <see cref="P:System.Net.HttpWebRequest.ContentLength" /> 大于零或 <see cref="P:System.Net.HttpWebRequest.SendChunked" /> 为 <see langword="true" />。  
  
或 
 <see cref="P:System.Net.HttpWebRequest.KeepAlive" /> 为 <see langword="true" />，<see cref="P:System.Net.HttpWebRequest.AllowWriteStreamBuffering" /> 为 <see langword="false" />，同时 <see cref="P:System.Net.HttpWebRequest.ContentLength" /> 为 -1，<see cref="P:System.Net.HttpWebRequest.SendChunked" /> 为 <see langword="false" />，或者 <see cref="P:System.Net.HttpWebRequest.Method" /> 为 POST 或 PUT。  
  
或 
该 <see cref="T:System.Net.HttpWebRequest" /> 具有实体，但不用调用 <see cref="M:System.Net.HttpWebRequest.BeginGetResponse(System.AsyncCallback,System.Object)" /> 方法调用 <see cref="M:System.Net.HttpWebRequest.BeginGetRequestStream(System.AsyncCallback,System.Object)" /> 方法。  
  
或 
<see cref="P:System.Net.HttpWebRequest.ContentLength" /> 大于零，但应用程序不会写入所有承诺的数据。</exception>
        <exception cref="T:System.Net.WebException">之前已调用 <see cref="M:System.Net.HttpWebRequest.Abort" />。</exception>
        <related type="Article" href="http://msdn.microsoft.com/library/9d663c4b-07b4-4f6f-9b12-efbd3630354f">DefaultProxy 元素 （网络设置）</related>
      </Docs>
    </Member>
    <Member MemberName="ClientCertificates">
      <MemberSignature Language="C#" Value="public System.Security.Cryptography.X509Certificates.X509CertificateCollection ClientCertificates { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Cryptography.X509Certificates.X509CertificateCollection ClientCertificates" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.ClientCertificates" />
      <MemberSignature Language="VB.NET" Value="Public Property ClientCertificates As X509CertificateCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::Cryptography::X509Certificates::X509CertificateCollection ^ ClientCertificates { System::Security::Cryptography::X509Certificates::X509CertificateCollection ^ get(); void set(System::Security::Cryptography::X509Certificates::X509CertificateCollection ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ClientCertificates : System.Security.Cryptography.X509Certificates.X509CertificateCollection with get, set" Usage="System.Net.HttpWebRequest.ClientCertificates" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.X509Certificates.X509CertificateCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置与此请求关联的安全证书集合。</summary>
        <value>
          <see cref="T:System.Security.Cryptography.X509Certificates.X509CertificateCollection" />，包含与此请求关联的安全证书。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 应用程序可以将证书添加到集合，但可能不具有访问权限。 若要使用集合中包含的证书，则应用程序必须颁发证书的实体的相同访问权限。  
  
> [!NOTE]
>  框架缓存 SSL 会话，因为它们创建并尝试再次使用的会话缓存适用于新的请求，在可能的情况。 在尝试以重复使用的 SSL 会话时，框架将使用的第一个元素<xref:System.Net.HttpWebRequest.ClientCertificates%2A>（如果没有一个），或尝试重复使用匿名会话，如果<xref:System.Net.HttpWebRequest.ClientCertificates%2A>为空。  
  
> [!NOTE]
>  出于性能原因，不应添加到客户端证书<xref:System.Net.HttpWebRequest>除非你知道该服务器将要求提供它。  
>   
>  有关代码示例演示如何枚举在客户端证书存储中的证书，请参阅<xref:System.Security.Cryptography.X509Certificates.X509Certificate2Collection>类。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">为集运算指定的值为 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="Connection">
      <MemberSignature Language="C#" Value="public string Connection { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Connection" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Connection" />
      <MemberSignature Language="VB.NET" Value="Public Property Connection As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Connection { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Connection : string with get, set" Usage="System.Net.HttpWebRequest.Connection" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置 <see langword="Connection" /> HTTP 标头的值。</summary>
        <value>
          <see langword="Connection" /> HTTP 标头的值。 默认值为 <see langword="null" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 请求将发送<xref:System.Net.HttpWebRequest.Connection%2A>属性设置为 Internet 资源，作为`Connection`HTTP 标头。 如果的值<xref:System.Net.HttpWebRequest.KeepAlive%2A>属性是`true`、"保持活动状态"值追加到末尾`Connection`标头。  
  
 若要清除`Connection`HTTP 标头，设置<xref:System.Net.HttpWebRequest.Connection%2A>属性设置为`null`。  
  
 更改<xref:System.Net.HttpWebRequest.Connection%2A>属性已通过调用已启动的请求后<xref:System.Net.HttpWebRequest.GetRequestStream%2A>， <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A>， <xref:System.Net.HttpWebRequest.GetResponse%2A>，或<xref:System.Net.HttpWebRequest.BeginGetResponse%2A>方法，则会引发<xref:System.InvalidOperationException>。  
  
> [!NOTE]
>  此属性的值存储在 <xref:System.Net.WebHeaderCollection> 中。 如果设置了 WebHeaderCollection，则该属性值将丢失。  
  
   
  
## Examples  
 下面的代码示例使用<xref:System.Net.HttpWebRequest.Connection%2A>属性来设置连接 HTTP 标头的值。  
  
 [!code-cpp[HttpWebRequest_Connection#1](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_Connection/CPP/httpwebrequest_connection.cpp#1)]
 [!code-csharp[HttpWebRequest_Connection#1](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_Connection/CS/httpwebrequest_connection.cs#1)]
 [!code-vb[HttpWebRequest_Connection#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_Connection/VB/httpwebrequest_connection.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <see cref="P:System.Net.HttpWebRequest.Connection" /> 的值设置为保持连接或关闭。</exception>
      </Docs>
    </Member>
    <Member MemberName="ConnectionGroupName">
      <MemberSignature Language="C#" Value="public override string ConnectionGroupName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ConnectionGroupName" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.ConnectionGroupName" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property ConnectionGroupName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ ConnectionGroupName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ConnectionGroupName : string with get, set" Usage="System.Net.HttpWebRequest.ConnectionGroupName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置请求的连接组的名称。</summary>
        <value>该请求的连接组的名称。 默认值为 <see langword="null" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.ConnectionGroupName%2A>属性使您能够将请求与连接组相关联。 当你的应用程序发出请求到一台服务器对于不同的用户，例如从数据库服务器中检索客户信息的网站时，这很有用。  
  
   
  
## Examples  
 下面的代码示例演示如何使用用户信息以形成连接组，前提假设变量`username`， `password`，和`domain`之前调用此代码由应用程序设置。  
  
 [!code-cpp[Classic HttpWebRequest.ConnectionGroupName Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic HttpWebRequest.ConnectionGroupName Example/CPP/source.cpp#1)]
 [!code-csharp[Classic HttpWebRequest.ConnectionGroupName Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic HttpWebRequest.ConnectionGroupName Example/CS/source.cs#1)]
 [!code-vb[Classic HttpWebRequest.ConnectionGroupName Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic HttpWebRequest.ConnectionGroupName Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>每个连接组创建其他连接的服务器。 这可能会导致超出设置的连接数<see cref="P:System.Net.ServicePoint.ConnectionLimit" />属性为该服务器。</para>
        </block>
        <altmember cref="P:System.Net.Configuration.ConnectionManagementElement.MaxConnection" />
        <altmember cref="P:System.Net.WebRequest.ConnectionGroupName" />
        <related type="Article" href="~/docs/framework/network-programming/connection-grouping.md">连接分组</related>
      </Docs>
    </Member>
    <Member MemberName="ContentLength">
      <MemberSignature Language="C#" Value="public override long ContentLength { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 ContentLength" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.ContentLength" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property ContentLength As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property long ContentLength { long get(); void set(long value); };" />
      <MemberSignature Language="F#" Value="member this.ContentLength : int64 with get, set" Usage="System.Net.HttpWebRequest.ContentLength" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置 <see langword="Content-length" /> HTTP 标头。</summary>
        <value>要发送到 Internet 资源的数据的字节数。 默认值为 -1，该值指示尚未设置该属性，并且没有要发送的请求数据。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.ContentLength%2A>属性包含的值将作为发送`Content-length`与请求的 HTTP 标头。  
  
 在-1 之外的任何值<xref:System.Net.HttpWebRequest.ContentLength%2A>属性指示该请求将数据上传并允许将数据上传的方法中设置<xref:System.Net.HttpWebRequest.Method%2A>属性。  
  
 之后<xref:System.Net.HttpWebRequest.ContentLength%2A>属性设置为一个值，该数目的字节数必须写入到通过调用返回的请求流<xref:System.Net.HttpWebRequest.GetRequestStream%2A>方法和 / 或<xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A>和<xref:System.Net.HttpWebRequest.EndGetRequestStream%2A>方法。  
  
> [!NOTE]
>  此属性的值存储在 <xref:System.Net.WebHeaderCollection> 中。 如果设置了 WebHeaderCollection，则该属性值将丢失。  
  
   
  
## Examples  
 下面的代码示例设置<xref:System.Net.HttpWebRequest.ContentLength%2A>属性设置为发布的字符串的长度。  
  
 [!code-cpp[HttpWebRequest_ContentLength#4](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_ContentLength/CPP/httpwebrequest_contentlength.cpp#4)]
 [!code-csharp[HttpWebRequest_ContentLength#4](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_ContentLength/CS/httpwebrequest_contentlength.cs#4)]
 [!code-vb[HttpWebRequest_ContentLength#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_ContentLength/VB/httpwebrequest_contentlength.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">已通过调用 <see cref="M:System.Net.HttpWebRequest.GetRequestStream" />、<see cref="M:System.Net.HttpWebRequest.BeginGetRequestStream(System.AsyncCallback,System.Object)" />、<see cref="M:System.Net.HttpWebRequest.GetResponse" /> 或 <see cref="M:System.Net.HttpWebRequest.BeginGetResponse(System.AsyncCallback,System.Object)" /> 方法启动请求。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">新的 <see cref="P:System.Net.HttpWebRequest.ContentLength" /> 值小于 0。</exception>
      </Docs>
    </Member>
    <Member MemberName="ContentType">
      <MemberSignature Language="C#" Value="public override string ContentType { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ContentType" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.ContentType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property ContentType As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ ContentType { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ContentType : string with get, set" Usage="System.Net.HttpWebRequest.ContentType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置 <see langword="Content-type" /> HTTP 标头的值。</summary>
        <value>
          <see langword="Content-type" /> HTTP 标头的值。 默认值为 <see langword="null" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.ContentType%2A>属性包含请求的媒体类型。 分配给值<xref:System.Net.HttpWebRequest.ContentType%2A>属性替换任何现有内容时请求将发送`Content-type`HTTP 标头。  
  
 若要清除`Content-type`HTTP 标头，设置<xref:System.Net.HttpWebRequest.ContentType%2A>属性设置为`null`。  
  
> [!NOTE]
>  此属性的值存储在<xref:System.Net.WebHeaderCollection>。 如果<xref:System.Net.WebHeaderCollection>，则属性值将丢失。  
  
   
  
## Examples  
 下面的代码示例设置<xref:System.Net.HttpWebRequest.ContentType%2A>属性。  
  
 [!code-cpp[HttpWebRequest_ContentLength#1](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_ContentLength/CPP/httpwebrequest_contentlength.cpp#1)]
 [!code-csharp[HttpWebRequest_ContentLength#1](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_ContentLength/CS/httpwebrequest_contentlength.cs#1)]
 [!code-vb[HttpWebRequest_ContentLength#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_ContentLength/VB/httpwebrequest_contentlength.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContinueDelegate">
      <MemberSignature Language="C#" Value="public System.Net.HttpContinueDelegate ContinueDelegate { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.HttpContinueDelegate ContinueDelegate" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.ContinueDelegate" />
      <MemberSignature Language="VB.NET" Value="Public Property ContinueDelegate As HttpContinueDelegate" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::HttpContinueDelegate ^ ContinueDelegate { System::Net::HttpContinueDelegate ^ get(); void set(System::Net::HttpContinueDelegate ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ContinueDelegate : System.Net.HttpContinueDelegate with get, set" Usage="System.Net.HttpWebRequest.ContinueDelegate" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.HttpContinueDelegate</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置当从 Internet 资源接收到 HTTP 100-continue 响应时调用的委托方法。</summary>
        <value>实现回调方法的委托，该方法在从 Internet 资源返回 HTTP Continue 响应时执行。 默认值为 <see langword="null" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.ContinueDelegate%2A>属性指定当客户端接收到一个 100 时要调用的回调方法-继续响应。  
  
 当<xref:System.Net.HttpWebRequest.ContinueDelegate%2A>属性设置，则客户端调用该委托每当协议类型的响应<xref:System.Net.HttpStatusCode.Continue?displayProperty=nameWithType>(100) 接收。 这是很有用，如果希望客户端以显示从 Internet 资源接收数据的状态。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Net.Configuration.HttpWebRequestElement.MaximumUnauthorizedUploadLength" />
      </Docs>
    </Member>
    <Member MemberName="ContinueTimeout">
      <MemberSignature Language="C#" Value="public int ContinueTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ContinueTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.ContinueTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Property ContinueTimeout As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ContinueTimeout { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.ContinueTimeout : int with get, set" Usage="System.Net.HttpWebRequest.ContinueTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置在接收到来自服务器的 100-Continue 之前要等待的超时（以毫秒为单位）。</summary>
        <value>在接收到 100-Continue 之前要等待的超时（以毫秒为单位）。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果 100-继续在超时过期，可以发送的实体正文之前收到响应。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CookieContainer">
      <MemberSignature Language="C#" Value="public virtual System.Net.CookieContainer CookieContainer { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.CookieContainer CookieContainer" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.CookieContainer" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property CookieContainer As CookieContainer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Net::CookieContainer ^ CookieContainer { System::Net::CookieContainer ^ get(); void set(System::Net::CookieContainer ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CookieContainer : System.Net.CookieContainer with get, set" Usage="System.Net.HttpWebRequest.CookieContainer" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.CookieContainer</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置与此请求关联的 Cookie。</summary>
        <value>包含与此请求关联的 Cookie 的 <see cref="T:System.Net.CookieContainer" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.CookieContainer%2A>属性提供的实例<xref:System.Net.CookieContainer>类，该类包含与此请求关联的 cookie。  
  
 <xref:System.Net.HttpWebRequest.CookieContainer%2A> 是`null`默认情况下。 必须将分配<xref:System.Net.CookieContainer>对象的属性中返回 cookie<xref:System.Net.HttpWebResponse.Cookies%2A>的属性<xref:System.Net.HttpWebResponse>返回的<xref:System.Net.HttpWebRequest.GetResponse%2A>方法。  
  
> [!NOTE]
>  出于安全原因，默认情况下禁用了 cookie。 如果你想要使用 cookie，则使用<xref:System.Net.HttpWebRequest.CookieContainer%2A>属性，以便启用 cookie。  
  
   
  
## Examples  
 下面的代码示例将请求发送到的 URL，并显示在响应中返回的 cookie。  
  
 [!code-cpp[NCLCookies#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLCookies/CPP/cookiessnippets.cpp#1)]
 [!code-csharp[NCLCookies#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLCookies/CS/cookiessnippets.cs#1)]
 [!code-vb[NCLCookies#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLCookies/VB/cookiessnippets.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.CookieContainer" />
      </Docs>
    </Member>
    <Member MemberName="Credentials">
      <MemberSignature Language="C#" Value="public override System.Net.ICredentials Credentials { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.ICredentials Credentials" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Credentials" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Credentials As ICredentials" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Net::ICredentials ^ Credentials { System::Net::ICredentials ^ get(); void set(System::Net::ICredentials ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Credentials : System.Net.ICredentials with get, set" Usage="System.Net.HttpWebRequest.Credentials" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.ICredentials</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置请求的身份验证信息。</summary>
        <value>包含与该请求关联的身份验证凭据的 <see cref="T:System.Net.ICredentials" />。 默认值为 <see langword="null" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.Credentials%2A>属性包含身份验证的信息来标识请求的创建者。 <xref:System.Net.HttpWebRequest.Credentials%2A>属性可以是<xref:System.Net.NetworkCredential>，而在哪些情况下，用户、 密码和域中包含的信息<xref:System.Net.NetworkCredential>对象用于进行身份验证请求，也可以是<xref:System.Net.CredentialCache>，在这种情况下统一资源请求的标识符 (URI) 用于确定要用于对请求进行身份验证用户、 密码和域信息。  
  
 在大多数客户端方案中，应使用<xref:System.Net.CredentialCache.DefaultCredentials%2A>属性，其中包含当前登录用户的凭据。 若要执行此操作，设置<xref:System.Net.WebClient.UseDefaultCredentials%2A>属性设置为`true`而不是设置此属性。  
  
 如果<xref:System.Net.HttpWebRequest>类用于在中间层应用程序，如 ASP.NET 应用程序中的凭据<xref:System.Net.CredentialCache.DefaultCredentials%2A>属性属于运行 ASP 页面 （服务器端的凭据） 的帐户。 通常情况下，将此属性设置为客户端的名义发出请求的凭据。  
  
> [!NOTE]
>  不能使用 NTLM 身份验证方案模拟其他用户。 必须专门配置 Kerberos 以支持使用模拟功能。  
  
 若要限制对一个或多个身份验证方法的 HttpWebRequest，使用<xref:System.Net.CredentialCache>类，并将你的凭据绑定到一个或多个身份验证方案  
  
 支持的身份验证方案包括摘要式、 协商、 Kerberos、 NTLM 和 Basic。  
  
 出于安全原因，操作时自动重定向，你想要包括在中的重定向将凭据存储<xref:System.Net.CredentialCache>并将其分配给此属性。 此属性将自动设置为`null`在重定向，如果它包含所有非时<xref:System.Net.CredentialCache>。 具有此属性的值自动设置为`null`在这些情况下阻止凭据发送到任何非预期的目标。
  
## Examples  
 下面的代码示例设置请求的凭据。  
  
 [!code-cpp[NCLResponse1#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLResponse1/CPP/httpwebrequest1.cpp#1)]
 [!code-csharp[NCLResponse1#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLResponse1/CS/httpwebrequest1.cs#1)]
 [!code-vb[NCLResponse1#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLResponse1/VB/httpwebrequest1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Date">
      <MemberSignature Language="C#" Value="public DateTime Date { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime Date" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Date" />
      <MemberSignature Language="VB.NET" Value="Public Property Date As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property DateTime Date { DateTime get(); void set(DateTime value); };" />
      <MemberSignature Language="F#" Value="member this.Date : DateTime with get, set" Usage="System.Net.HttpWebRequest.Date" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置要在 HTTP 请求中使用的 <see langword="Date" /> HTTP 标头值。</summary>
        <value>HTTP 请求中的 Date 标头值。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果日期标头`null`，则返回值将设置为<xref:System.DateTime.MinValue?displayProperty=nameWithType>。  
  
 <xref:System.Net.HttpWebRequest.Date%2A>属性是一种标准<xref:System.DateTime?displayProperty=nameWithType>对象，并可以包含<xref:System.DateTimeKind?displayProperty=nameWithType>字段<xref:System.DateTimeKind.Local?displayProperty=nameWithType>， <xref:System.DateTimeKind.Utc?displayProperty=nameWithType>，或<xref:System.DateTimeKind.Unspecified?displayProperty=nameWithType>。 使用时，可以设置任何类型的时间<xref:System.Net.HttpWebRequest.Date%2A>属性。 如果<xref:System.DateTimeKind.Unspecified?displayProperty=nameWithType>设置或检索<xref:System.Net.HttpWebRequest.Date%2A>属性被假定为<xref:System.DateTimeKind.Local?displayProperty=nameWithType>（本地时间）。  
  
 中的类<xref:System.Net>命名空间始终将其写出<xref:System.Net.HttpWebRequest.Date%2A>使用格林威治标准时间 (Utc) 格式的标准窗体中传输时线路上的属性。  
  
 如果<xref:System.Net.HttpWebRequest.Date%2A>属性设置为<xref:System.DateTime.MinValue?displayProperty=nameWithType>，然后`Date`HTTP 标头已从<xref:System.Net.HttpWebRequest.Headers%2A>属性和<xref:System.Net.WebHeaderCollection>。  
  
 如果<xref:System.Net.HttpWebRequest.Date%2A>属性是<xref:System.DateTime.MinValue?displayProperty=nameWithType>，这指示`Date`HTTP 标头未包含在<xref:System.Net.HttpWebRequest.Headers%2A>属性和<xref:System.Net.WebHeaderCollection>。  
  
> [!NOTE]
>  此属性的值存储在 <xref:System.Net.WebHeaderCollection> 中。 如果设置了 WebHeaderCollection，则该属性值将丢失。  
  
 如果<xref:System.Net.HttpWebRequest.Date%2A>设置和尝试发送<xref:System.Net.HttpWebRequest>没有正文，则<xref:System.Net.ProtocolViolationException?displayProperty=nameWithType>将引发<xref:System.Net.HttpWebRequest.BeginGetResponse%2A>， <xref:System.Net.HttpWebRequest.GetResponse%2A>，并<xref:System.Net.HttpWebRequest.EndGetResponse%2A>方法。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultCachePolicy">
      <MemberSignature Language="C#" Value="public static System.Net.Cache.RequestCachePolicy DefaultCachePolicy { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Net.Cache.RequestCachePolicy DefaultCachePolicy" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.DefaultCachePolicy" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property DefaultCachePolicy As RequestCachePolicy" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Net::Cache::RequestCachePolicy ^ DefaultCachePolicy { System::Net::Cache::RequestCachePolicy ^ get(); void set(System::Net::Cache::RequestCachePolicy ^ value); };" />
      <MemberSignature Language="F#" Value="member this.DefaultCachePolicy : System.Net.Cache.RequestCachePolicy with get, set" Usage="System.Net.HttpWebRequest.DefaultCachePolicy" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.Cache.RequestCachePolicy</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置此请求的默认缓存策略。</summary>
        <value>一个 <see cref="T:System.Net.Cache.HttpRequestCachePolicy" />，它指定当没有其他策略适用时对此请求有效的缓存策略。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 设置此属性注册为 HTTP 和 HTTPS 方案指定的策略。 如果此策略用于此请求：  
  
 没有任何<xref:System.Net.WebRequest.CachePolicy%2A?displayProperty=nameWithType>为此请求指定的属性。  
  
 \- 或 -  
  
 计算机和应用程序配置文件不会指定为统一资源标识符 (URI) 适用的缓存策略用于创建此请求。  
  
 缓存策略确定是否可以从缓存而不是将请求发送给资源主机计算机执行所请求的资源。  
  
 如果资源的响应流是检索并读取到流的末尾时，资源的副本才会添加到缓存。 嗯，另一请求相同的资源可以使用缓存的副本，具体取决于此请求的缓存策略级别。  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Net.WebPermission">无限制地访问网络资源。 关联的枚举： <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
        <altmember cref="T:System.Net.Cache.RequestCachePolicy" />
        <altmember cref="T:System.Net.Cache.HttpRequestCacheLevel" />
        <altmember cref="T:System.Net.Cache.RequestCacheLevel" />
        <altmember cref="P:System.Net.WebRequest.CachePolicy" />
      </Docs>
    </Member>
    <Member MemberName="DefaultMaximumErrorResponseLength">
      <MemberSignature Language="C#" Value="public static int DefaultMaximumErrorResponseLength { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 DefaultMaximumErrorResponseLength" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.DefaultMaximumErrorResponseLength" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property DefaultMaximumErrorResponseLength As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int DefaultMaximumErrorResponseLength { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.DefaultMaximumErrorResponseLength : int with get, set" Usage="System.Net.HttpWebRequest.DefaultMaximumErrorResponseLength" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置 HTTP 错误响应的默认最大长度。</summary>
        <value>HTTP 错误响应的默认最大长度。</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">值小于 0 并且不等于 -1。</exception>
      </Docs>
    </Member>
    <Member MemberName="DefaultMaximumResponseHeadersLength">
      <MemberSignature Language="C#" Value="public static int DefaultMaximumResponseHeadersLength { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 DefaultMaximumResponseHeadersLength" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.DefaultMaximumResponseHeadersLength" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property DefaultMaximumResponseHeadersLength As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int DefaultMaximumResponseHeadersLength { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.DefaultMaximumResponseHeadersLength : int with get, set" Usage="System.Net.HttpWebRequest.DefaultMaximumResponseHeadersLength" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO("Use this")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置 <see cref="P:System.Net.HttpWebRequest.MaximumResponseHeadersLength" /> 属性的默认值。</summary>
        <value>接收的响应标头的默认最大长度，以 KB（1024 字节）为单位。 默认配置文件将此值设置为 64 KB。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 响应状态行和 HTTP 协议的一部分收到的任何额外的控制字符，将收到响应标头的长度。 值为-1 表示接收; 的响应标头中施加任何限制一个值为 0 表示所有请求会都失败。  
  
 此外可以在配置文件中更改此值。 此属性的影响可以通过设置重写<xref:System.Net.HttpWebRequest.MaximumResponseHeadersLength%2A>的实例上的属性<xref:System.Net.HttpWebRequest>类。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">该值不等于 -1 且小于 0。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="EndGetRequestStream">
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>结束对用来写入数据的 <see cref="T:System.IO.Stream" /> 对象的异步请求。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="EndGetRequestStream">
      <MemberSignature Language="C#" Value="public override System.IO.Stream EndGetRequestStream (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IO.Stream EndGetRequestStream(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.EndGetRequestStream(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function EndGetRequestStream (asyncResult As IAsyncResult) As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::IO::Stream ^ EndGetRequestStream(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="override this.EndGetRequestStream : IAsyncResult -&gt; System.IO.Stream" Usage="httpWebRequest.EndGetRequestStream asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">对流的挂起请求。</param>
        <summary>结束对用来写入数据的 <see cref="T:System.IO.Stream" /> 对象的异步请求。</summary>
        <returns>用于写入请求数据的 <see cref="T:System.IO.Stream" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.EndGetRequestStream%2A>方法完成启动的流的异步请求<xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A>方法。 之后<xref:System.IO.Stream>返回对象，因此可以将数据与<xref:System.Net.HttpWebRequest>通过使用<xref:System.IO.Stream.Write%2A?displayProperty=nameWithType>方法。  
  
> [!NOTE]
>  必须设置的值<xref:System.Net.HttpWebRequest.ContentLength%2A>之前向流写入数据的属性。  
  
> [!CAUTION]
>  必须调用<xref:System.IO.Stream.Close%2A?displayProperty=nameWithType>方法来关闭流并释放以供重复使用的连接。 关闭流失败会导致应用程序运行完连接。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅[在.NET Framework 中进行网络跟踪](~/docs/framework/network-programming/network-tracing.md)。  
  
   
  
## Examples  
 下面的代码示例使用<xref:System.Net.HttpWebRequest.EndGetRequestStream%2A>方法来结束的流实例的异步请求。  
  
 [!code-cpp[HttpWebRequest_BeginGetRequestStream#2](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_BeginGetRequestStream/CPP/httpwebrequest_begingetrequeststream.cpp#2)]
 [!code-csharp[HttpWebRequest_BeginGetRequestStream#2](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_BeginGetRequestStream/CS/httpwebrequest_begingetrequeststream.cs#2)]
 [!code-vb[HttpWebRequest_BeginGetRequestStream#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_BeginGetRequestStream/VB/httpwebrequest_begingetrequeststream.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="asyncResult" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.IO.IOException">请求未完成，没有可用的流。</exception>
        <exception cref="T:System.ArgumentException">当前实例没有从对 <see cref="M:System.Net.HttpWebRequest.BeginGetRequestStream(System.AsyncCallback,System.Object)" /> 的调用返回 <paramref name="asyncResult" />。</exception>
        <exception cref="T:System.InvalidOperationException">以前使用 <paramref name="asyncResult" /> 调用过此方法。</exception>
        <exception cref="T:System.Net.WebException">之前已调用 <see cref="M:System.Net.HttpWebRequest.Abort" />。  
  
或 
处理请求时出错。</exception>
      </Docs>
    </Member>
    <Member MemberName="EndGetRequestStream">
      <MemberSignature Language="C#" Value="public System.IO.Stream EndGetRequestStream (IAsyncResult asyncResult, out System.Net.TransportContext context);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Stream EndGetRequestStream(class System.IAsyncResult asyncResult, [out] class System.Net.TransportContext&amp; context) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.EndGetRequestStream(System.IAsyncResult,System.Net.TransportContext@)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndGetRequestStream (asyncResult As IAsyncResult, ByRef context As TransportContext) As Stream" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Stream ^ EndGetRequestStream(IAsyncResult ^ asyncResult, [Runtime::InteropServices::Out] System::Net::TransportContext ^ % context);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8" />
      <MemberSignature Language="C#" Value="public System.IO.Stream EndGetRequestStream (IAsyncResult asyncResult, out System.Net.TransportContext transportContext);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Stream EndGetRequestStream(class System.IAsyncResult asyncResult, [out] class System.Net.TransportContext&amp; transportContext) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function EndGetRequestStream (asyncResult As IAsyncResult, ByRef transportContext As TransportContext) As Stream" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Stream ^ EndGetRequestStream(IAsyncResult ^ asyncResult, [Runtime::InteropServices::Out] System::Net::TransportContext ^ % transportContext);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="override this.EndGetRequestStream : IAsyncResult *  -&gt; System.IO.Stream" Usage="httpWebRequest.EndGetRequestStream (asyncResult, transportContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" />
        <Parameter Name="context" Type="System.Net.TransportContext" RefType="out" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8" />
        <Parameter Name="transportContext" Type="System.Net.TransportContext" RefType="out" Index="1" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="asyncResult">对流的挂起请求。</param>
        <param name="context">
          <see cref="T:System.Net.TransportContext" /> 的 <see cref="T:System.IO.Stream" />。</param>
        <param name="transportContext">
          <see cref="T:System.Net.TransportContext" /> 的 <see cref="T:System.IO.Stream" />。</param>
        <summary>结束对用于写入数据的 <see cref="T:System.IO.Stream" /> 对象的异步请求，并输出与该流关联的 <see cref="T:System.Net.TransportContext" />。</summary>
        <returns>用于写入请求数据的 <see cref="T:System.IO.Stream" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.EndGetRequestStream%2A>方法完成启动的流的异步请求<xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A>方法，并输出<xref:System.Net.TransportContext>与流关联。 之后<xref:System.IO.Stream>返回对象，因此可以将数据与<xref:System.Net.HttpWebRequest>通过使用<xref:System.IO.Stream.Write%2A?displayProperty=nameWithType>方法。  
  
 使用集成的 Windows 身份验证和扩展保护某些应用程序可能需要查询使用的传输层<xref:System.Net.HttpWebRequest>以从基础的 TLS 通道检索的通道绑定令牌 (CBT)。 <xref:System.Net.HttpWebRequest.GetRequestStream%2A>方法提供访问此信息具有请求正文的 HTTP 方法 (`POST`和`PUT`请求)。 这才被需要在应用程序实现自己的身份验证并需要有权 CBT。  
  
> [!NOTE]
>  如果应用程序需要的值设置<xref:System.Net.HttpWebRequest.ContentLength%2A>属性，则这必须在检索流，并向其中写入数据之前完成。  
  
> [!CAUTION]
>  必须调用<xref:System.IO.Stream.Close%2A?displayProperty=nameWithType>方法来关闭流并释放以供重复使用的连接。 关闭流失败会导致应用程序运行完连接。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅[在.NET Framework 中进行网络跟踪](~/docs/framework/network-programming/network-tracing.md)。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">当前实例没有从对 <see cref="M:System.Net.HttpWebRequest.BeginGetRequestStream(System.AsyncCallback,System.Object)" /> 的调用返回 <paramref name="asyncResult" />。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="asyncResult" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">以前使用 <paramref name="asyncResult" /> 调用过此方法。</exception>
        <exception cref="T:System.IO.IOException">请求未完成，没有可用的流。</exception>
        <exception cref="T:System.Net.WebException">之前已调用 <see cref="M:System.Net.HttpWebRequest.Abort" />。  
  
或 
处理请求时出错。</exception>
        <altmember cref="T:System.Net.TransportContext" />
        <altmember cref="M:System.Net.TransportContext.GetChannelBinding(System.Security.Authentication.ExtendedProtection.ChannelBindingKind)" />
        <altmember cref="N:System.Security.Authentication.ExtendedProtection" />
        <altmember cref="T:System.Security.Authentication.ExtendedProtection.ChannelBinding" />
        <related type="Article" href="~/docs/framework/network-programming/integrated-windows-authentication-with-extended-protection.md">带有扩展保护的集成 Windows 身份验证</related>
      </Docs>
    </Member>
    <Member MemberName="EndGetResponse">
      <MemberSignature Language="C#" Value="public override System.Net.WebResponse EndGetResponse (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Net.WebResponse EndGetResponse(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.EndGetResponse(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function EndGetResponse (asyncResult As IAsyncResult) As WebResponse" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Net::WebResponse ^ EndGetResponse(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="override this.EndGetResponse : IAsyncResult -&gt; System.Net.WebResponse" Usage="httpWebRequest.EndGetResponse asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.WebResponse</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">对响应的挂起请求。</param>
        <summary>结束对 Internet 资源的异步请求。</summary>
        <returns>包含来自 Internet 资源的响应的 <see cref="T:System.Net.WebResponse" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.EndGetResponse%2A>方法完成通过调用启动的 Internet 资源的异步请求<xref:System.Net.HttpWebRequest.BeginGetResponse%2A>方法。  
  
> [!CAUTION]
>  必须调用<xref:System.Net.HttpWebResponse.Close%2A>方法来关闭流并释放该连接。 如果不这样做可能会导致应用程序运行完连接。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅[在.NET Framework 中进行网络跟踪](~/docs/framework/network-programming/network-tracing.md)。  
  
   
  
## Examples  
 下面的代码示例使用<xref:System.Net.HttpWebRequest.EndGetResponse%2A>方法来结束对 Internet 资源的异步请求。  
  
 [!code-cpp[HttpWebRequest_BeginGetResponse#2](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_BeginGetResponse/CPP/httpwebrequest_begingetresponse.cpp#2)]
 [!code-csharp[HttpWebRequest_BeginGetResponse#2](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_BeginGetResponse/CS/httpwebrequest_begingetresponse.cs#2)]
 [!code-vb[HttpWebRequest_BeginGetResponse#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_BeginGetResponse/VB/httpwebrequest_begingetresponse.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="asyncResult" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">之前已使用 <paramref name="asyncResult." /> 调用了此方法  
  
或 
<see cref="P:System.Net.HttpWebRequest.ContentLength" /> 属性大于 0，但数据尚未写入到请求流。</exception>
        <exception cref="T:System.Net.WebException">之前已调用 <see cref="M:System.Net.HttpWebRequest.Abort" />。  
  
或 
处理请求时出错。</exception>
        <exception cref="T:System.ArgumentException">当前实例没有从对 <see cref="M:System.Net.HttpWebRequest.BeginGetResponse(System.AsyncCallback,System.Object)" /> 的调用返回 <paramref name="asyncResult" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="Expect">
      <MemberSignature Language="C#" Value="public string Expect { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Expect" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Expect" />
      <MemberSignature Language="VB.NET" Value="Public Property Expect As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Expect { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Expect : string with get, set" Usage="System.Net.HttpWebRequest.Expect" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置 <see langword="Expect" /> HTTP 标头的值。</summary>
        <value>
          <see langword="Expect" />HTTP 标头的内容。 默认值为 <see langword="null" />。  
  
 <block subset="none" type="note"><para>  
 此属性的值存储在 <see cref="T:System.Net.WebHeaderCollection" /> 中。 如果设置了 WebHeaderCollection，则该属性值将丢失。  
  
</para></block></value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">
          <see langword="Expect" /> 被设置为一个包含“100-continue”（作为子字符串）的字符串。</exception>
        <altmember cref="P:System.Net.Configuration.HttpWebRequestElement.MaximumUnauthorizedUploadLength" />
        <related type="Article" href="http://msdn.microsoft.com/library/9d663c4b-07b4-4f6f-9b12-efbd3630354f">DefaultProxy 元素 （网络设置）</related>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="httpWebRequest.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetObjectData">
      <MemberSignature Language="C#" Value="protected override void GetObjectData (System.Runtime.Serialization.SerializationInfo serializationInfo, System.Runtime.Serialization.StreamingContext streamingContext);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void GetObjectData(class System.Runtime.Serialization.SerializationInfo serializationInfo, valuetype System.Runtime.Serialization.StreamingContext streamingContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void GetObjectData(System::Runtime::Serialization::SerializationInfo ^ serializationInfo, System::Runtime::Serialization::StreamingContext streamingContext);" />
      <MemberSignature Language="F#" Value="override this.GetObjectData : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; unit" Usage="httpWebRequest.GetObjectData (serializationInfo, streamingContext)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1">
          <AttributeName>System.Obsolete("Serialization is obsoleted for this type.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="serializationInfo" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="streamingContext" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="serializationInfo">要填充数据的 <see cref="T:System.Runtime.Serialization.SerializationInfo" />。</param>
        <param name="streamingContext">用于指定该序列化的目标的 <see cref="T:System.Runtime.Serialization.StreamingContext" />。</param>
        <summary>使用序列化目标对象时所需的数据填充 <see cref="T:System.Runtime.Serialization.SerializationInfo" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 中包含的任何对象<xref:System.Runtime.Serialization.SerializationInfo>会自动跟踪和格式化程序序列化。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetRequestStream">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>获取用于写入请求数据的 <see cref="T:System.IO.Stream" /> 对象。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetRequestStream">
      <MemberSignature Language="C#" Value="public override System.IO.Stream GetRequestStream ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IO.Stream GetRequestStream() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.GetRequestStream" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetRequestStream () As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::IO::Stream ^ GetRequestStream();" />
      <MemberSignature Language="F#" Value="override this.GetRequestStream : unit -&gt; System.IO.Stream" Usage="httpWebRequest.GetRequestStream " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>获取用于写入请求数据的 <see cref="T:System.IO.Stream" /> 对象。</summary>
        <returns>用于写入请求数据的 <see cref="T:System.IO.Stream" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.GetRequestStream%2A>方法返回的流，用于将数据发送用于<xref:System.Net.HttpWebRequest>。 之后<xref:System.IO.Stream>返回对象，因此可以将数据与<xref:System.Net.HttpWebRequest>通过使用<xref:System.IO.Stream.Write%2A?displayProperty=nameWithType>方法。  
  
 如果应用程序需要的值设置<xref:System.Net.HttpWebRequest.ContentLength%2A>属性，则这必须在检索流之前完成。  
  
 必须调用<xref:System.IO.Stream.Close%2A?displayProperty=nameWithType>方法来关闭流并释放以供重复使用的连接。 关闭流失败会导致应用程序运行完连接。  
  
> [!NOTE]
>  你的应用程序不能混合同步和异步方法对特定请求。 如果您调用<xref:System.Net.HttpWebRequest.GetRequestStream%2A>方法，则必须使用<xref:System.Net.HttpWebRequest.GetResponse%2A>方法以检索响应。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅[在.NET Framework 中进行网络跟踪](~/docs/framework/network-programming/network-tracing.md)。  
  
   
  
## Examples  
 下面的代码示例使用<xref:System.Net.HttpWebRequest.GetRequestStream%2A>方法返回的流实例。  
  
 [!code-cpp[HttpWebRequest_ContentLength#4](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_ContentLength/CPP/httpwebrequest_contentlength.cpp#4)]
 [!code-csharp[HttpWebRequest_ContentLength#4](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_ContentLength/CS/httpwebrequest_contentlength.cs#4)]
 [!code-vb[HttpWebRequest_ContentLength#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_ContentLength/VB/httpwebrequest_contentlength.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.ProtocolViolationException">
          <see cref="P:System.Net.HttpWebRequest.Method" /> 属性为 GET 或 HEAD。  
  
或 
 <see cref="P:System.Net.HttpWebRequest.KeepAlive" /> 为 <see langword="true" />，<see cref="P:System.Net.HttpWebRequest.AllowWriteStreamBuffering" /> 为 <see langword="false" />，<see cref="P:System.Net.HttpWebRequest.ContentLength" /> 为 -1，<see cref="P:System.Net.HttpWebRequest.SendChunked" /> 为 <see langword="false" />，<see cref="P:System.Net.HttpWebRequest.Method" /> 为 POST 或 PUT。</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="M:System.Net.HttpWebRequest.GetRequestStream" /> 方法被调用多次。  
  
或 
 将 <see cref="P:System.Net.HttpWebRequest.TransferEncoding" /> 设置为一个值，且 <see cref="P:System.Net.HttpWebRequest.SendChunked" /> 为 <see langword="false" />。</exception>
        <exception cref="T:System.NotSupportedException">请求缓存验证程序指示对此请求的响应可从缓存中提供；但是，写入数据的请求不得使用缓存。 如果你正在使用错误实现的自定义缓存验证程序，则会发生此异常。</exception>
        <exception cref="T:System.Net.WebException">之前已调用 <see cref="M:System.Net.HttpWebRequest.Abort" />。  
  
或 
请求的超时期限到期。  
  
或 
处理请求时出错。</exception>
        <exception cref="T:System.ObjectDisposedException">在 .NET Compact Framework 应用程序中，未正确获得和关闭一个内容长度为零的请求流。 有关处理内容长度为零的请求的详细信息，请参阅 [.NET Compact Framework 中的网络编程](https://msdn.microsoft.com/subscriptions/downloads/1afx2b0f\(v=vs.80\).aspx)。</exception>
        <related type="Article" href="http://msdn.microsoft.com/library/9d663c4b-07b4-4f6f-9b12-efbd3630354f">DefaultProxy 元素 （网络设置）</related>
      </Docs>
    </Member>
    <Member MemberName="GetRequestStream">
      <MemberSignature Language="C#" Value="public System.IO.Stream GetRequestStream (out System.Net.TransportContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Stream GetRequestStream([out] class System.Net.TransportContext&amp; context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.GetRequestStream(System.Net.TransportContext@)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetRequestStream (ByRef context As TransportContext) As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Stream ^ GetRequestStream([Runtime::InteropServices::Out] System::Net::TransportContext ^ % context);" />
      <MemberSignature Language="F#" Value="override this.GetRequestStream :  -&gt; System.IO.Stream" Usage="httpWebRequest.GetRequestStream context" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="context" Type="System.Net.TransportContext" RefType="out" />
      </Parameters>
      <Docs>
        <param name="context">
          <see cref="T:System.Net.TransportContext" /> 的 <see cref="T:System.IO.Stream" />。</param>
        <summary>获取用于写入请求数据的 <see cref="T:System.IO.Stream" /> 对象，并输出与该流关联的 <see cref="T:System.Net.TransportContext" />。</summary>
        <returns>用于写入请求数据的 <see cref="T:System.IO.Stream" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.GetRequestStream%2A>方法返回的流，用于将数据发送用于<xref:System.Net.HttpWebRequest>，并输出<xref:System.Net.TransportContext>与流关联。 之后<xref:System.IO.Stream>返回对象，因此可以将数据与<xref:System.Net.HttpWebRequest>通过使用<xref:System.IO.Stream.Write%2A?displayProperty=nameWithType>方法。  
  
 使用集成的 Windows 身份验证和扩展保护某些应用程序可能需要查询使用的传输层<xref:System.Net.HttpWebRequest>以从基础的 TLS 通道检索的通道绑定令牌 (CBT)。 <xref:System.Net.HttpWebRequest.GetRequestStream%2A>方法提供访问此信息具有请求正文的 HTTP 方法 (`POST`和`PUT`请求)。 这才被需要在应用程序实现自己的身份验证并需要有权 CBT。  
  
 如果应用程序需要的值设置<xref:System.Net.HttpWebRequest.ContentLength%2A>属性，则这必须在检索流之前完成。  
  
 必须调用<xref:System.IO.Stream.Close%2A?displayProperty=nameWithType>方法来关闭流并释放以供重复使用的连接。 关闭流失败会导致应用程序运行完连接。  
  
> [!NOTE]
>  你的应用程序不能混合同步和异步方法对特定请求。 如果您调用<xref:System.Net.HttpWebRequest.GetRequestStream%2A>方法，则必须使用<xref:System.Net.HttpWebRequest.GetResponse%2A>方法以检索响应。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅[在.NET Framework 中进行网络跟踪](~/docs/framework/network-programming/network-tracing.md)。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Exception">
          <see cref="M:System.Net.HttpWebRequest.GetRequestStream" /> 方法无法获取 <see cref="T:System.IO.Stream" />。</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="M:System.Net.HttpWebRequest.GetRequestStream" /> 方法被调用多次。  
  
或 
 将 <see cref="P:System.Net.HttpWebRequest.TransferEncoding" /> 设置为一个值，且 <see cref="P:System.Net.HttpWebRequest.SendChunked" /> 为 <see langword="false" />。</exception>
        <exception cref="T:System.NotSupportedException">请求缓存验证程序指示对此请求的响应可从缓存中提供；但是，写入数据的请求不得使用缓存。 如果你正在使用错误实现的自定义缓存验证程序，则会发生此异常。</exception>
        <exception cref="T:System.Net.ProtocolViolationException">
          <see cref="P:System.Net.HttpWebRequest.Method" /> 属性为 GET 或 HEAD。  
  
或 
 <see cref="P:System.Net.HttpWebRequest.KeepAlive" /> 为 <see langword="true" />，<see cref="P:System.Net.HttpWebRequest.AllowWriteStreamBuffering" /> 为 <see langword="false" />，<see cref="P:System.Net.HttpWebRequest.ContentLength" /> 为 -1，<see cref="P:System.Net.HttpWebRequest.SendChunked" /> 为 <see langword="false" />，<see cref="P:System.Net.HttpWebRequest.Method" /> 为 POST 或 PUT。</exception>
        <exception cref="T:System.Net.WebException">之前已调用 <see cref="M:System.Net.HttpWebRequest.Abort" />。  
  
或 
请求的超时期限到期。  
  
或 
处理请求时出错。</exception>
        <altmember cref="T:System.Net.TransportContext" />
        <altmember cref="M:System.Net.TransportContext.GetChannelBinding(System.Security.Authentication.ExtendedProtection.ChannelBindingKind)" />
        <altmember cref="N:System.Security.Authentication.ExtendedProtection" />
        <altmember cref="T:System.Security.Authentication.ExtendedProtection.ChannelBinding" />
        <related type="Article" href="~/docs/framework/network-programming/integrated-windows-authentication-with-extended-protection.md">带有扩展保护的集成 Windows 身份验证</related>
      </Docs>
    </Member>
    <Member MemberName="GetResponse">
      <MemberSignature Language="C#" Value="public override System.Net.WebResponse GetResponse ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Net.WebResponse GetResponse() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.GetResponse" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetResponse () As WebResponse" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Net::WebResponse ^ GetResponse();" />
      <MemberSignature Language="F#" Value="override this.GetResponse : unit -&gt; System.Net.WebResponse" Usage="httpWebRequest.GetResponse " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.WebResponse</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回来自 Internet 资源的响应。</summary>
        <returns>包含来自 Internet 资源的响应的 <see cref="T:System.Net.WebResponse" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.GetResponse%2A>方法将返回<xref:System.Net.WebResponse>对象，其中包含来自 Internet 资源的响应。 返回的实际实例<xref:System.Net.HttpWebResponse>，并可以类型转换为该类的访问特定于 HTTP 的属性。  
  
 一个<xref:System.Net.ProtocolViolationException>上设置的属性时，某些情况下将引发<xref:System.Net.HttpWebRequest>类是冲突。 如果应用程序设置，会发生此异常<xref:System.Net.HttpWebRequest.ContentLength%2A>属性和<xref:System.Net.HttpWebRequest.SendChunked%2A>属性设置为`true`，然后将发送 HTTP GET 请求。 如果应用程序尝试向发送分块请求仅支持 HTTP 1.0 协议的服务器不支持此操作，会发生此异常。 如果应用程序尝试发送数据，而设置不会发生此异常<xref:System.Net.HttpWebRequest.ContentLength%2A>属性或<xref:System.Net.HttpWebRequest.SendChunked%2A>是`false`禁用缓冲，并且 keepalive 连接上 (<xref:System.Net.HttpWebRequest.KeepAlive%2A>属性是`true`)`.`  
  
> [!CAUTION]
>  必须调用<xref:System.Net.HttpWebResponse.Close%2A>方法来关闭流并释放该连接。 如果不这样做可能会导致应用程序运行完连接。  
  
 使用 POST 方法时，必须获取请求流、 写入数据发布，并关闭流。 此方法阻止等待内容发布;如果没有超时设置，并且不提供无限期地调用的线程阻止的内容。  
  
> [!NOTE]
>  多次调用<xref:System.Net.HttpWebRequest.GetResponse%2A>返回相同的响应对象中; 请求不重新颁发。  
  
> [!NOTE]
>  你的应用程序不能混合同步和异步方法对特定请求。 如果您调用<xref:System.Net.HttpWebRequest.GetRequestStream%2A>方法，则必须使用<xref:System.Net.HttpWebRequest.GetResponse%2A>方法以检索响应。  
  
> [!NOTE]
>  如果<xref:System.Net.WebException>是引发，使用<xref:System.Net.WebException.Response%2A>和<xref:System.Net.WebException.Status%2A>异常来确定来自服务器的响应的属性。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅[在.NET Framework 中进行网络跟踪](~/docs/framework/network-programming/network-tracing.md)。  
  
> [!NOTE]
>  出于安全原因，默认情况下禁用了 cookie。 如果想要使用 cookie，则使用<xref:System.Net.HttpWebRequest.CookieContainer%2A>属性，以便启用 cookie。  
  
   
  
## Examples  
 下面的代码示例获取请求的响应。  
  
 [!code-cpp[NCLResponse1#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLResponse1/CPP/httpwebrequest1.cpp#1)]
 [!code-csharp[NCLResponse1#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLResponse1/CS/httpwebrequest1.cs#1)]
 [!code-vb[NCLResponse1#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLResponse1/VB/httpwebrequest1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">流正由上一个 <see cref="M:System.Net.HttpWebRequest.BeginGetResponse(System.AsyncCallback,System.Object)" /> 调用使用。  
  
或 
 将 <see cref="P:System.Net.HttpWebRequest.TransferEncoding" /> 设置为一个值，且 <see cref="P:System.Net.HttpWebRequest.SendChunked" /> 为 <see langword="false" />。</exception>
        <exception cref="T:System.Net.ProtocolViolationException">
          <see cref="P:System.Net.HttpWebRequest.Method" /> 为 GET 或 HEAD，并且或者 <see cref="P:System.Net.HttpWebRequest.ContentLength" /> 大于或等于零，或者 <see cref="P:System.Net.HttpWebRequest.SendChunked" /> 为 <see langword="true" />。  
  
或 
 <see cref="P:System.Net.HttpWebRequest.KeepAlive" /> 为 <see langword="true" />，<see cref="P:System.Net.HttpWebRequest.AllowWriteStreamBuffering" /> 为 <see langword="false" />，<see cref="P:System.Net.HttpWebRequest.ContentLength" /> 为 -1，<see cref="P:System.Net.HttpWebRequest.SendChunked" /> 为 <see langword="false" />，<see cref="P:System.Net.HttpWebRequest.Method" /> 为 POST 或 PUT。  
  
或 
该 <see cref="T:System.Net.HttpWebRequest" /> 具有实体，但不用调用 <see cref="M:System.Net.HttpWebRequest.GetResponse" /> 方法调用 <see cref="M:System.Net.HttpWebRequest.GetRequestStream" /> 方法。  
  
或 
<see cref="P:System.Net.HttpWebRequest.ContentLength" /> 大于零，但应用程序不会写入所有承诺的数据。</exception>
        <exception cref="T:System.NotSupportedException">请求缓存验证程序表示对此请求的响应可从缓存中提供；但是该请求包含要发送到服务器的数据。 发送数据的请求不可使用缓存。 如果你正在使用错误实现的自定义缓存验证程序，则会发生此异常。</exception>
        <exception cref="T:System.Net.WebException">之前已调用 <see cref="M:System.Net.HttpWebRequest.Abort" />。  
  
或 
请求的超时期限到期。  
  
或 
处理请求时出错。</exception>
        <altmember cref="P:System.Net.HttpWebRequest.Timeout" />
        <related type="Article" href="http://msdn.microsoft.com/library/9d663c4b-07b4-4f6f-9b12-efbd3630354f">DefaultProxy 元素 （网络设置）</related>
      </Docs>
    </Member>
    <Member MemberName="HaveResponse">
      <MemberSignature Language="C#" Value="public virtual bool HaveResponse { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HaveResponse" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.HaveResponse" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property HaveResponse As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool HaveResponse { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.HaveResponse : bool" Usage="System.Net.HttpWebRequest.HaveResponse" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示是否收到了来自 Internet 资源的响应。</summary>
        <value>如果接收到了响应，则为 <see langword="true" />，否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下面的代码示例检查<xref:System.Net.HttpWebRequest.HaveResponse%2A>属性来确定是否已从 Internet 资源接收响应。  
  
 [!code-cpp[Httpwebrequest_HaveResponse#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Httpwebrequest_HaveResponse/CPP/httpwebrequest_haveresponse.cpp#1)]
 [!code-csharp[Httpwebrequest_HaveResponse#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Httpwebrequest_HaveResponse/CS/httpwebrequest_haveresponse.cs#1)]
 [!code-vb[Httpwebrequest_HaveResponse#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Httpwebrequest_HaveResponse/VB/httpwebrequest_haveresponse.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Headers">
      <MemberSignature Language="C#" Value="public override System.Net.WebHeaderCollection Headers { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.WebHeaderCollection Headers" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Headers" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Headers As WebHeaderCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Net::WebHeaderCollection ^ Headers { System::Net::WebHeaderCollection ^ get(); void set(System::Net::WebHeaderCollection ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Headers : System.Net.WebHeaderCollection with get, set" Usage="System.Net.HttpWebRequest.Headers" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.WebHeaderCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>指定构成 HTTP 标头的名称/值对的集合。</summary>
        <value>包含构成 HTTP 请求标头的名称/值对的 <see cref="T:System.Net.WebHeaderCollection" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.Headers%2A>集合包含与请求关联的协议标头。 下表列出了不会存储在 HTTP 标头<xref:System.Net.HttpWebRequest.Headers%2A>集合而是由系统设置或设置由属性或方法。  
  
|Header|通过设置|  
|------------|------------|  
|接受|通过设置<xref:System.Net.HttpWebRequest.Accept%2A>属性。|  
|连接|通过设置<xref:System.Net.HttpWebRequest.Connection%2A>属性和<xref:System.Net.HttpWebRequest.KeepAlive%2A>属性。|  
|内容长度|通过设置<xref:System.Net.HttpWebRequest.ContentLength%2A>属性。|  
|Content-Type|通过设置<xref:System.Net.HttpWebRequest.ContentType%2A>属性。|  
|期望|通过设置<xref:System.Net.HttpWebRequest.Expect%2A>属性。|  
|日期|通过设置<xref:System.Net.HttpWebRequest.Date%2A>属性。|  
|Host|通过设置<xref:System.Net.HttpWebRequest.Host%2A>属性。|  
|如果-修改-自|通过设置<xref:System.Net.HttpWebRequest.IfModifiedSince%2A>属性。|  
|范围|通过设置<xref:System.Net.HttpWebRequest.AddRange%2A>方法。|  
|引用站点|通过设置<xref:System.Net.HttpWebRequest.Referer%2A>属性。|  
|传输编码|通过设置<xref:System.Net.HttpWebRequest.TransferEncoding%2A>属性 (<xref:System.Net.HttpWebRequest.SendChunked%2A>属性必须为 true)。|  
|用户代理|通过设置<xref:System.Net.HttpWebRequest.UserAgent%2A>属性。|  
  
 <xref:System.Net.WebHeaderCollection.Add%2A>方法会抛出<xref:System.ArgumentException>如果尝试设置这些受保护的标头之一。  
  
 更改<xref:System.Net.HttpWebRequest.Headers%2A>属性已通过调用已启动的请求后<xref:System.Net.HttpWebRequest.GetRequestStream%2A>， <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A>， <xref:System.Net.HttpWebRequest.GetResponse%2A>，或<xref:System.Net.HttpWebRequest.BeginGetResponse%2A>方法，则会引发<xref:System.InvalidOperationException>。  
  
 不应假定，标头值将保持不变，，因为 Web 服务器和缓存可能会更改或向 Web 请求添加标头。  
  
   
  
## Examples  
 下面的代码示例使用<xref:System.Net.HttpWebRequest.Headers%2A>属性打印到控制台的 HTTP 标头名称/值对。  
  
 [!code-cpp[HttpWebRequest_Headers#1](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_Headers/CPP/httpwebrequest_headers.cpp#1)]
 [!code-csharp[HttpWebRequest_Headers#1](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_Headers/CS/httpwebrequest_headers.cs#1)]
 [!code-vb[HttpWebRequest_Headers#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_Headers/VB/httpwebrequest_headers.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">已通过调用 <see cref="M:System.Net.HttpWebRequest.GetRequestStream" />、<see cref="M:System.Net.HttpWebRequest.BeginGetRequestStream(System.AsyncCallback,System.Object)" />、<see cref="M:System.Net.HttpWebRequest.GetResponse" /> 或 <see cref="M:System.Net.HttpWebRequest.BeginGetResponse(System.AsyncCallback,System.Object)" /> 方法启动请求。</exception>
      </Docs>
    </Member>
    <Member MemberName="Host">
      <MemberSignature Language="C#" Value="public string Host { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Host" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Host" />
      <MemberSignature Language="VB.NET" Value="Public Property Host As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Host { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Host : string with get, set" Usage="System.Net.HttpWebRequest.Host" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置要在 HTTP 请求中独立于请求 URI 使用的 Host 标头值。</summary>
        <value>HTTP 请求中的 Host 标头值。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.Host%2A>属性可以用于将主机设置独立于请求 URI 的 HTTP 请求中要使用的标头值。 <xref:System.Net.HttpWebRequest.Host%2A>属性可以包含主机名和一个可选的端口号。 主机标头不带端口信息意味着服务请求 （端口 80 用于 HTTP URL，例如） 的默认端口。  
  
 指定主机和端口的格式必须遵循 14.23 小节中的 RFC2616 IETF 发布的规则。 示例演示如何满足这些要求指定端口 8080 是以下值以查找<xref:System.Net.HttpWebRequest.Host%2A>属性：  
  
 `www.contoso.com:8080`  
  
 使用<xref:System.Net.HttpWebRequest.Host%2A>属性来显式指定自定义的主机标头值还会影响缓存的区域、 cookie 和身份验证。 当应用程序提供了有关特定的 URI 前缀的凭据时，该应用程序将需要确保使用包含的值的主机标头，不是在 URI 中的目标服务器的 URI。 使用缓存资源时的密钥使用主机标头值而不是请求 URI。 Cookie 存储在<xref:System.Net.CookieContainer>和服务器的域名以逻辑方式分组。 如果应用程序指定主机标头，此值将用作域。  
  
 如果<xref:System.Net.HttpWebRequest.Host%2A>属性未设置，则要在 HTTP 请求中使用的主机标头值基于在请求 URI 上。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">无法将 Host 标头设置为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">无法将 Host 标头设置为无效值。</exception>
        <exception cref="T:System.InvalidOperationException">无法在已开始发送 <see cref="T:System.Net.HttpWebRequest" /> 之后设置 Host 标头。</exception>
      </Docs>
    </Member>
    <Member MemberName="IfModifiedSince">
      <MemberSignature Language="C#" Value="public DateTime IfModifiedSince { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime IfModifiedSince" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.IfModifiedSince" />
      <MemberSignature Language="VB.NET" Value="Public Property IfModifiedSince As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property DateTime IfModifiedSince { DateTime get(); void set(DateTime value); };" />
      <MemberSignature Language="F#" Value="member this.IfModifiedSince : DateTime with get, set" Usage="System.Net.HttpWebRequest.IfModifiedSince" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置 <see langword="If-Modified-Since" /> HTTP 标头的值。</summary>
        <value>包含 <see langword="If-Modified-Since" />HTTP 标头内容的 <see cref="T:System.DateTime" />。 默认值是当前日期和时间。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.IfModifiedSince%2A>属性是一种标准<xref:System.DateTime?displayProperty=nameWithType>对象，并可以包含<xref:System.DateTimeKind?displayProperty=nameWithType>字段<xref:System.DateTimeKind.Local?displayProperty=nameWithType>， <xref:System.DateTimeKind.Utc?displayProperty=nameWithType>，或<xref:System.DateTimeKind.Unspecified?displayProperty=nameWithType>。 使用时，可以设置任何类型的时间<xref:System.Net.HttpWebRequest.IfModifiedSince%2A>属性。 如果<xref:System.DateTimeKind.Unspecified?displayProperty=nameWithType>设置或检索<xref:System.Net.HttpWebRequest.IfModifiedSince%2A>属性被假定为<xref:System.DateTimeKind.Local?displayProperty=nameWithType>（本地时间）。  
  
 中的类<xref:System.Net>命名空间始终将其写出<xref:System.Net.HttpWebRequest.IfModifiedSince%2A>使用格林威治标准时间 (Utc) 格式的标准窗体中传输时线路上的属性。  
  
 如果<xref:System.Net.HttpWebRequest.IfModifiedSince%2A>属性设置为<xref:System.DateTime.MinValue?displayProperty=nameWithType>，然后`If-Modified-Since`HTTP 标头已从<xref:System.Net.HttpWebRequest.Headers%2A>属性和<xref:System.Net.WebHeaderCollection>。  
  
 如果<xref:System.Net.HttpWebRequest.IfModifiedSince%2A>属性是<xref:System.DateTime.MinValue?displayProperty=nameWithType>，这指示`If-Modified-Since`HTTP 标头未包含在<xref:System.Net.HttpWebRequest.Headers%2A>属性和<xref:System.Net.WebHeaderCollection>。  
  
> [!NOTE]
>  此属性的值存储在 <xref:System.Net.WebHeaderCollection> 中。 如果设置了 WebHeaderCollection，则该属性值将丢失。  
  
   
  
## Examples  
 下面的代码示例检查<xref:System.Net.HttpWebRequest.IfModifiedSince%2A>属性。  
  
 [!code-cpp[HttpWebRequest_IfModifiedSince#1](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_IfModifiedSince/CPP/httpwebrequest_ifmodifiedsince.cpp#1)]
 [!code-csharp[HttpWebRequest_IfModifiedSince#1](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_IfModifiedSince/CS/httpwebrequest_ifmodifiedsince.cs#1)]
 [!code-vb[HttpWebRequest_IfModifiedSince#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_IfModifiedSince/VB/httpwebrequest_ifmodifiedsince.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="KeepAlive">
      <MemberSignature Language="C#" Value="public bool KeepAlive { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool KeepAlive" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.KeepAlive" />
      <MemberSignature Language="VB.NET" Value="Public Property KeepAlive As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool KeepAlive { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.KeepAlive : bool with get, set" Usage="System.Net.HttpWebRequest.KeepAlive" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值指示是否与 Internet 资源建立持续型连接。</summary>
        <value>如果对 Internet 资源的请求所包含的 <see langword="true" /> HTTP 标头带有 Keep-alive 这一值，则为 <see langword="Connection" />；否则为 <see langword="false" />。 默认值为 <see langword="true" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 将此属性设置为`true`发送`Connection`保持活动状态的值的 HTTP 标头。 应用程序使用<xref:System.Net.HttpWebRequest.KeepAlive%2A>指示持久连接的首选项。 当<xref:System.Net.HttpWebRequest.KeepAlive%2A>属性是`true`，应用程序建立持久连接到支持它们的服务器。  
  
> [!NOTE]
>  使用 HTTP/1.1，保持活动状态时，在默认情况下。 设置<xref:System.Net.HttpWebRequest.KeepAlive%2A>到`false`可能会导致发送`Connection: Close`到服务器的标头。  
  
   
  
## Examples  
 下面的代码示例设置<xref:System.Net.HttpWebRequest.KeepAlive%2A>属性设置为`false`以免建立与 Internet 资源的持续性连接。  
  
 [!code-cpp[HttpWebRequest_Connection#1](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_Connection/CPP/httpwebrequest_connection.cpp#1)]
 [!code-csharp[HttpWebRequest_Connection#1](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_Connection/CS/httpwebrequest_connection.cs#1)]
 [!code-vb[HttpWebRequest_Connection#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_Connection/VB/httpwebrequest_connection.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MaximumAutomaticRedirections">
      <MemberSignature Language="C#" Value="public int MaximumAutomaticRedirections { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MaximumAutomaticRedirections" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.MaximumAutomaticRedirections" />
      <MemberSignature Language="VB.NET" Value="Public Property MaximumAutomaticRedirections As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int MaximumAutomaticRedirections { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.MaximumAutomaticRedirections : int with get, set" Usage="System.Net.HttpWebRequest.MaximumAutomaticRedirections" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置请求将跟随的重定向的最大数目。</summary>
        <value>请求将跟随的重定向响应的最大数目。 默认值为 50。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.MaximumAutomaticRedirections%2A>属性设置为请求时要执行的重定向的最大数目<xref:System.Net.HttpWebRequest.AllowAutoRedirect%2A>属性是`true`。  
  
   
  
## Examples  
 下面的代码示例设置此属性的值。  
  
 [!code-cpp[NCLResponse1#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLResponse1/CPP/httpwebrequest1.cpp#1)]
 [!code-csharp[NCLResponse1#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLResponse1/CS/httpwebrequest1.cs#1)]
 [!code-vb[NCLResponse1#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLResponse1/VB/httpwebrequest1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">值设置为 0 或更小。</exception>
      </Docs>
    </Member>
    <Member MemberName="MaximumResponseHeadersLength">
      <MemberSignature Language="C#" Value="public int MaximumResponseHeadersLength { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MaximumResponseHeadersLength" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.MaximumResponseHeadersLength" />
      <MemberSignature Language="VB.NET" Value="Public Property MaximumResponseHeadersLength As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int MaximumResponseHeadersLength { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.MaximumResponseHeadersLength : int with get, set" Usage="System.Net.HttpWebRequest.MaximumResponseHeadersLength" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO("Use this")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置响应标头允许的最大长度。</summary>
        <value>响应标头的长度，以 KB（1024 字节）为单位。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 响应标头的长度包括响应状态行和 HTTP 协议的一部分收到的任何额外的控制字符。 值为-1 表示没有限制强加于响应标头;一个值为 0 表示所有请求会都失败。  
  
 如果<xref:System.Net.HttpWebRequest.MaximumResponseHeadersLength%2A>未显式设置属性，则默认值为<xref:System.Net.HttpWebRequest.DefaultMaximumResponseHeadersLength%2A>属性。  
  
 如果收到的响应标头的长度超出的值<xref:System.Net.HttpWebRequest.MaximumResponseHeadersLength%2A>属性，<xref:System.Net.HttpWebRequest.EndGetResponse%2A>或<xref:System.Net.HttpWebRequest.GetResponse%2A>方法将引发<xref:System.Net.WebException>与<xref:System.Net.WebException.Status%2A>属性设置为<xref:System.Net.WebExceptionStatus.MessageLengthLimitExceeded>。  
  
   
  
## Examples  
 下面的代码示例设置此属性的值。  
  
 [!code-cpp[NCLResponse1#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLResponse1/CPP/httpwebrequest1.cpp#1)]
 [!code-csharp[NCLResponse1#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLResponse1/CS/httpwebrequest1.cs#1)]
 [!code-vb[NCLResponse1#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLResponse1/VB/httpwebrequest1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">已提交请求后设置属性。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">值小于 0 并且不等于 -1。</exception>
      </Docs>
    </Member>
    <Member MemberName="MediaType">
      <MemberSignature Language="C#" Value="public string MediaType { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string MediaType" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.MediaType" />
      <MemberSignature Language="VB.NET" Value="Public Property MediaType As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ MediaType { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.MediaType : string with get, set" Usage="System.Net.HttpWebRequest.MediaType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置请求的媒体类型。</summary>
        <value>请求的媒体类型。 默认值为 <see langword="null" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 值<xref:System.Net.HttpWebRequest.MediaType%2A>属性会影响<xref:System.Net.HttpWebResponse.CharacterSet%2A>属性。 当您将设置<xref:System.Net.HttpWebRequest.MediaType%2A>在请求中，相应的媒体类型从列表中选择的字符集在响应中返回`Content-type`HTTP 标头。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Method">
      <MemberSignature Language="C#" Value="public override string Method { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Method" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Method" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Method As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Method { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Method : string with get, set" Usage="System.Net.HttpWebRequest.Method" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置请求的方法。</summary>
        <value>用于联系 Internet 资源的请求方法。 默认值为 GET。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.Method%2A>属性可以设置为任何 HTTP 1.1 协议谓词： GET、 HEAD、 POST、 PUT、 删除，跟踪或选项。  
  
 如果<xref:System.Net.HttpWebRequest.ContentLength%2A>属性设置为任何值，而-1<xref:System.Net.HttpWebRequest.Method%2A>属性必须设置为将数据上传的协议属性。  
  
   
  
## Examples  
 下面的代码示例设置<xref:System.Net.HttpWebRequest.Method%2A>属性设置为 POST。  
  
 [!code-cpp[HttpWebRequest_ContentLength#4](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_ContentLength/CPP/httpwebrequest_contentlength.cpp#4)]
 [!code-csharp[HttpWebRequest_ContentLength#4](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_ContentLength/CS/httpwebrequest_contentlength.cs#4)]
 [!code-vb[HttpWebRequest_ContentLength#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_ContentLength/VB/httpwebrequest_contentlength.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">未提供任何方法。  
  
或 
方法字符串包含无效字符。</exception>
      </Docs>
    </Member>
    <Member MemberName="Pipelined">
      <MemberSignature Language="C#" Value="public bool Pipelined { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Pipelined" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Pipelined" />
      <MemberSignature Language="VB.NET" Value="Public Property Pipelined As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Pipelined { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Pipelined : bool with get, set" Usage="System.Net.HttpWebRequest.Pipelined" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值指示是否通过管线将请求传输到 Internet 资源。</summary>
        <value>如果通过管线传输请求，则为 <see langword="true" />；否则为 <see langword="false" />。 默认值为 <see langword="true" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 应用程序使用<xref:System.Net.HttpWebRequest.Pipelined%2A>属性指示管道连接的首选项。 当<xref:System.Net.HttpWebRequest.Pipelined%2A>是`true`，应用程序进行管道的连接到支持它们的服务器。  
  
 管道的连接进行时，才<xref:System.Net.HttpWebRequest.KeepAlive%2A>属性也为`true`。  
  
   
  
## Examples  
 下面的代码示例将的值打印<xref:System.Net.HttpWebRequest.Pipelined%2A>属性到控制台。  
  
 [!code-cpp[HttpWebRequest_PipeLined#1](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_PipeLined/CPP/httpwebrequest_pipelined.cpp#1)]
 [!code-csharp[HttpWebRequest_PipeLined#1](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_PipeLined/CS/httpwebrequest_pipelined.cs#1)]
 [!code-vb[HttpWebRequest_PipeLined#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_PipeLined/VB/httpwebrequest_pipelined.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreAuthenticate">
      <MemberSignature Language="C#" Value="public override bool PreAuthenticate { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool PreAuthenticate" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.PreAuthenticate" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property PreAuthenticate As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool PreAuthenticate { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.PreAuthenticate : bool with get, set" Usage="System.Net.HttpWebRequest.PreAuthenticate" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值指示是否随请求发送一个 Authorization 标头。</summary>
        <value>
          <see langword="true" /> 表示在发生身份验证之后随请求一起发送 HTTP 授权标头；否则为 <see langword="false" />。 默认值为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 对特定的客户端请求后<xref:System.Uri>成功进行身份验证，如果<xref:System.Net.HttpWebRequest.PreAuthenticate%2A>是`true`并在提供凭据，在 Authorization 标头与每个请求发送到任何<xref:System.Uri>相匹配的特定<xref:System.Uri>直到最后一个正斜杠。 因此，如果客户端请求已成功通过特定<xref:System.Uri>包含如下内容：  
  
 `http://www.contoso.com/firstpath/`  
  
 然后进行预身份验证的授权标头与每个请求发送到以下任一<xref:System.Uri>实例：  
  
 `http://www.contoso.com/firstpath/`  
  
 `http://www.contoso.com/firstpath/default`  
  
 `http://www.contoso.com/firstpath/default.html`  
  
 `http://www.contoso.com/firstpath/sample.html`  
  
 但是，在 Authorization 标头是未随请求一起发送到以下任一<xref:System.Uri>实例：  
  
 `http://www.contoso.com/`  
  
 `http://www.contoso.com/firstpath`  
  
 `http://www.contoso.com/secondpath/`  
  
 如果客户端请求到特定<xref:System.Uri>是不成功进行身份验证，请求使用标准身份验证过程。  
  
 第一个请求，除了<xref:System.Net.WebRequest.PreAuthenticate%2A>属性指示是否将发送到的后续请求使用的身份验证信息<xref:System.Uri>相匹配的特定于<xref:System.Uri>直到而无需等待最后一个正斜杠服务器的质询。  
  
 客户端和服务器之间的以下对话框说明了此属性的效果。 该对话框假设基本身份验证正在使用中。  
  
 <xref:System.Net.HttpWebRequest.PreAuthenticate%2A> 是`false`:  
  
 客户端： GET someUrl  
  
 服务器： 401 Www-authenticate 的 Basic  
  
 使用授权标头获取客户端：  
  
 服务器： 200 确定  
  
 客户端： GET someUrl  
  
 服务器： 401 Www-authenticate 的 Basic  
  
 使用授权标头获取客户端：  
  
 服务器： 200 确定  
  
 <xref:System.Net.HttpWebRequest.PreAuthenticate%2A> 是`true`:  
  
 客户端： GET someUrl  
  
 服务器： 401 Www-authenticate 的 Basic  
  
 使用授权标头获取客户端：  
  
 服务器： 200 确定  
  
 客户端： 获取 someUrl 与授权标头  
  
 如果身份验证方案不支持预身份验证，则忽略此属性的值。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ProtocolVersion">
      <MemberSignature Language="C#" Value="public Version ProtocolVersion { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Version ProtocolVersion" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.ProtocolVersion" />
      <MemberSignature Language="VB.NET" Value="Public Property ProtocolVersion As Version" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Version ^ ProtocolVersion { Version ^ get(); void set(Version ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ProtocolVersion : Version with get, set" Usage="System.Net.HttpWebRequest.ProtocolVersion" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Version</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置用于请求的 HTTP 版本。</summary>
        <value>用于请求的 HTTP 版本。 默认值为 <see cref="F:System.Net.HttpVersion.Version11" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest>类支持版本 1.0 和 1.1 版 HTTP。 设置<xref:System.Net.HttpWebRequest.ProtocolVersion%2A>与另一个版本将引发异常。  
  
> [!NOTE]
>  若要设置当前请求的 HTTP 版本，请使用<xref:System.Net.HttpVersion.Version10>并<xref:System.Net.HttpVersion.Version11>的字段<xref:System.Net.HttpVersion>类。  
  
   
  
## Examples  
 下面的代码示例设置<xref:System.Net.HttpWebRequest.ProtocolVersion%2A>属性。  
  
 [!code-cpp[HttpWebRequest_ProtocolVersion#1](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_ProtocolVersion/CPP/httpwebrequest_protocolversion.cpp#1)]
 [!code-csharp[HttpWebRequest_ProtocolVersion#1](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_ProtocolVersion/CS/httpwebrequest_protocolversion.cs#1)]
 [!code-vb[HttpWebRequest_ProtocolVersion#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_ProtocolVersion/VB/httpwebrequest_protocolversion.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">HTTP 版本设置为 1.0 或 1.1 以外的值。</exception>
      </Docs>
    </Member>
    <Member MemberName="Proxy">
      <MemberSignature Language="C#" Value="public override System.Net.IWebProxy Proxy { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.IWebProxy Proxy" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Proxy" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Proxy As IWebProxy" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Net::IWebProxy ^ Proxy { System::Net::IWebProxy ^ get(); void set(System::Net::IWebProxy ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Proxy : System.Net.IWebProxy with get, set" Usage="System.Net.HttpWebRequest.Proxy" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.IWebProxy</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置请求的代理信息。</summary>
        <value>用于代理请求的 <see cref="T:System.Net.IWebProxy" /> 对象。 默认值通过调用 <see cref="P:System.Net.GlobalProxySelection.Select" /> 属性设置。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.Proxy%2A>属性标识<xref:System.Net.WebProxy>对象，用于处理对 Internet 资源的请求。 若要指定应使用任何代理，请设置<xref:System.Net.HttpWebRequest.Proxy%2A>属性设置为返回的代理实例<xref:System.Net.GlobalProxySelection.GetEmptyWebProxy%2A?displayProperty=nameWithType>方法。  
  
 在本地计算机或应用程序配置文件可以指定使用默认代理。 如果<xref:System.Net.HttpWebRequest.Proxy%2A>指定属性，然后从的代理设置<xref:System.Net.HttpWebRequest.Proxy%2A>属性重写在本地计算机或应用程序配置文件和<xref:System.Net.HttpWebRequest>实例将使用指定的代理设置。 如果未指定代理配置文件中，<xref:System.Net.HttpWebRequest.Proxy%2A>属性未指定，<xref:System.Net.HttpWebRequest>类使用继承自 Internet 资源管理器在本地计算机上的代理设置。 如果没有在 Internet Explorer 代理设置，该请求是直接发送到服务器。  
  
 <xref:System.Net.HttpWebRequest>类分析包含通配符字符的代理跳过列表继承从 Internet 资源管理器相同直接通过 Internet Explorer 分析时跳过列表。 例如，<xref:System.Net.HttpWebRequest>类将正则表达式的分析的"nt *"从 Internet 资源管理器的跳过列表"nt。\*"。 因此的 URL"`http://nt.com`"将绕过代理帐户使用<xref:System.Net.HttpWebRequest>类并使用 Internet Explorer。  
  
 <xref:System.Net.HttpWebRequest>类支持绕过本地代理。 类会视为目标为本地如果满足以下条件之一：  
  
-   目标包含平面名称 （在 URL 中没有句点）。  
  
-   目标包含与环回地址 (<xref:System.Net.IPAddress.Loopback>或<xref:System.Net.IPAddress.IPv6Loopback>) 或目标包含<xref:System.Net.IPAddress>分配给本地计算机。  
  
-   目标的域后缀匹配本地计算机的域后缀 (<xref:System.Net.NetworkInformation.IPGlobalProperties.DomainName%2A>)。  
  
 更改<xref:System.Net.HttpWebRequest.Proxy%2A>属性已通过调用已启动的请求后<xref:System.Net.HttpWebRequest.GetRequestStream%2A>， <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A>， <xref:System.Net.HttpWebRequest.GetResponse%2A>，或<xref:System.Net.HttpWebRequest.BeginGetResponse%2A>方法，则会引发<xref:System.InvalidOperationException>。 有关代理元素的信息，请参阅[ \&l t; defaultProxy\&g t;元素 （网络设置）](~/docs/framework/configure-apps/file-schema/network/defaultproxy-element-network-settings.md)。  
  
   
  
## Examples  
 下面的代码示例使用<xref:System.Net.HttpWebRequest.Proxy%2A>方法以获取请求的代理信息。  
  
 [!code-cpp[Httpwebrequest_proxy#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Httpwebrequest_proxy/CPP/httpwebrequest_proxy.cpp#1)]
 [!code-csharp[Httpwebrequest_proxy#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Httpwebrequest_proxy/CS/httpwebrequest_proxy.cs#1)]
 [!code-vb[Httpwebrequest_proxy#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Httpwebrequest_proxy/VB/httpwebrequest_proxy.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">将 <see cref="P:System.Net.HttpWebRequest.Proxy" /> 设置为 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">已通过调用 <see cref="M:System.Net.HttpWebRequest.GetRequestStream" />、<see cref="M:System.Net.HttpWebRequest.BeginGetRequestStream(System.AsyncCallback,System.Object)" />、<see cref="M:System.Net.HttpWebRequest.GetResponse" /> 或 <see cref="M:System.Net.HttpWebRequest.BeginGetResponse(System.AsyncCallback,System.Object)" /> 启动了该请求。</exception>
        <exception cref="T:System.Security.SecurityException">调用方无权执行所请求的操作。</exception>
        <permission cref="T:System.Net.WebPermission">获取或设置<see cref="P:System.Net.HttpWebRequest.Proxy" />属性。 关联的枚举： <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
        <related type="Article" href="http://msdn.microsoft.com/library/9d663c4b-07b4-4f6f-9b12-efbd3630354f">DefaultProxy 元素 （网络设置）</related>
        <related type="Article" href="http://msdn.microsoft.com/library/bb707c72-eed2-4a82-8800-c9e68df2fd4f">配置 Internet 应用程序</related>
        <related type="Article" href="http://msdn.microsoft.com/library/353c0a8b-4cee-44f6-8e65-60e286743df9">代理配置</related>
        <related type="Article" href="http://msdn.microsoft.com/library/fcd9c3bd-93de-4c92-8ff3-837327ad18de">自动代理检测</related>
      </Docs>
    </Member>
    <Member MemberName="ReadWriteTimeout">
      <MemberSignature Language="C#" Value="public int ReadWriteTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ReadWriteTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.ReadWriteTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Property ReadWriteTimeout As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ReadWriteTimeout { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.ReadWriteTimeout : int with get, set" Usage="System.Net.HttpWebRequest.ReadWriteTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置写入或读取流时的超时（以毫秒为单位）。</summary>
        <value>在写入超时或读取超时之前的毫秒数。默认值为 300,000 毫秒（5 分钟）。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.ReadWriteTimeout%2A>写入到返回的流时使用属性<xref:System.Net.HttpWebRequest.GetRequestStream%2A>方法或在读取返回的流<xref:System.Net.HttpWebResponse.GetResponseStream%2A>方法。  
  
 具体而言，<xref:System.Net.HttpWebRequest.ReadWriteTimeout%2A>属性控制的超时<xref:System.IO.Stream.Read%2A>方法，用于读取返回的流<xref:System.Net.HttpWebResponse.GetResponseStream%2A>方法，并为<xref:System.IO.Stream.Write%2A>方法，用于写入到流返回的<xref:System.Net.HttpWebRequest.GetRequestStream%2A>方法。  
  
 若要指定要等待的时间完成请求的时间量，请使用<xref:System.Net.HttpWebRequest.Timeout%2A>属性。  
  
   
  
## Examples  
 下面的代码示例演示如何设置 <xref:System.Net.HttpWebRequest.ReadWriteTimeout%2A> 属性。  
  
 [!code-csharp[Classic HttpWebRequest Example#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic HttpWebRequest Example/CS/source.cs#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">已发送请求。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">为 Set 操作指定的值小于等于零，并且不等于 <see cref="F:System.Threading.Timeout.Infinite" /></exception>
        <altmember cref="P:System.Net.HttpWebRequest.Timeout" />
      </Docs>
    </Member>
    <Member MemberName="Referer">
      <MemberSignature Language="C#" Value="public string Referer { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Referer" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Referer" />
      <MemberSignature Language="VB.NET" Value="Public Property Referer As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Referer { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Referer : string with get, set" Usage="System.Net.HttpWebRequest.Referer" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置 <see langword="Referer" /> HTTP 标头的值。</summary>
        <value>
          <see langword="Referer" /> HTTP 标头的值。 默认值为 <see langword="null" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果<xref:System.Net.HttpWebRequest.AllowAutoRedirect%2A>属性是`true`，则<xref:System.Net.HttpWebRequest.Referer%2A>请求重定向到另一个站点时自动设置属性。  
  
 若要清除`Referer`HTTP 标头，设置<xref:System.Net.HttpWebRequest.Referer%2A>属性设置为`null`。  
  
> [!NOTE]
>  此属性的值存储在 <xref:System.Net.WebHeaderCollection> 中。 如果设置了 WebHeaderCollection，则该属性值将丢失。  
  
   
  
## Examples  
 下面的代码示例设置<xref:System.Net.HttpWebRequest.Referer%2A>属性。  
  
 [!code-cpp[HttpWebRequest_Referer#1](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_Referer/CPP/httpwebrequest_referer.cpp#1)]
 [!code-csharp[HttpWebRequest_Referer#1](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_Referer/CS/httpwebrequest_referer.cs#1)]
 [!code-vb[HttpWebRequest_Referer#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_Referer/VB/httpwebrequest_referer.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RequestUri">
      <MemberSignature Language="C#" Value="public override Uri RequestUri { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Uri RequestUri" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.RequestUri" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property RequestUri As Uri" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Uri ^ RequestUri { Uri ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.RequestUri : Uri" Usage="System.Net.HttpWebRequest.RequestUri" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Uri</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取请求的原始统一资源标识符 (URI)。</summary>
        <value>一个 <see cref="T:System.Uri" />，其中包含传递给 <see cref="M:System.Net.WebRequest.Create(System.String)" /> 方法的 Internet 资源的 URI。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Uri>对象传递给<xref:System.Net.HttpWebRequest>通过调用<xref:System.Net.WebRequest.Create%2A?displayProperty=nameWithType>。  
  
 跟随重定向标头不会更改<xref:System.Net.HttpWebRequest.RequestUri%2A>属性。 若要获取实际响应此请求的 URI，请检查<xref:System.Net.HttpWebRequest.Address%2A>属性。  
  
   
  
## Examples  
 下面的代码示例检查以查看是否<xref:System.Net.HttpWebRequest>对象`req`已重定向到其他位置，以完成请求，并设置的值`hasChanged`变量`true`如果请求重定向; 否则为`hasChanged`设置为`false`。  
  
 [!code-cpp[Classic HttpWebRequest.RequestUri Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic HttpWebRequest.RequestUri Example/CPP/source.cpp#1)]
 [!code-csharp[Classic HttpWebRequest.RequestUri Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic HttpWebRequest.RequestUri Example/CS/source.cs#1)]
 [!code-vb[Classic HttpWebRequest.RequestUri Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic HttpWebRequest.RequestUri Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SendChunked">
      <MemberSignature Language="C#" Value="public bool SendChunked { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SendChunked" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.SendChunked" />
      <MemberSignature Language="VB.NET" Value="Public Property SendChunked As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool SendChunked { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.SendChunked : bool with get, set" Usage="System.Net.HttpWebRequest.SendChunked" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值指示是否将数据分段发送到 Internet 资源。</summary>
        <value>如果为 <see langword="true" />，则将数据分段发送到 Internet 资源；否则为 <see langword="false" />。 默认值为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当<xref:System.Net.HttpWebRequest.SendChunked%2A>是`true`，请求将数据发送到分段的 Internet 资源。 Internet 资源必须支持接收成块的数据。  
  
 更改<xref:System.Net.HttpWebRequest.SendChunked%2A>属性已通过调用已启动的请求后<xref:System.Net.HttpWebRequest.GetRequestStream%2A>， <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A>， <xref:System.Net.HttpWebRequest.GetResponse%2A>，或<xref:System.Net.HttpWebRequest.BeginGetResponse%2A>方法，则会引发<xref:System.InvalidOperationException>。  
  
   
  
## Examples  
 下面的代码示例设置<xref:System.Net.HttpWebRequest.SendChunked%2A>属性设置为`true`，以便可以将数据发送到 Internet 资源的段中。  
  
 [!code-cpp[HttpWebRequest_SendChunked#2](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_SendChunked/CPP/httpwebrequest_sendchunked.cpp#2)]
 [!code-csharp[HttpWebRequest_SendChunked#2](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_SendChunked/CS/httpwebrequest_sendchunked.cs#2)]
 [!code-vb[HttpWebRequest_SendChunked#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_SendChunked/VB/httpwebrequest_sendchunked.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">已通过调用 <see cref="M:System.Net.HttpWebRequest.GetRequestStream" />、<see cref="M:System.Net.HttpWebRequest.BeginGetRequestStream(System.AsyncCallback,System.Object)" />、<see cref="M:System.Net.HttpWebRequest.GetResponse" /> 或 <see cref="M:System.Net.HttpWebRequest.BeginGetResponse(System.AsyncCallback,System.Object)" /> 方法启动请求。</exception>
      </Docs>
    </Member>
    <Member MemberName="ServerCertificateValidationCallback">
      <MemberSignature Language="C#" Value="public System.Net.Security.RemoteCertificateValidationCallback ServerCertificateValidationCallback { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.Security.RemoteCertificateValidationCallback ServerCertificateValidationCallback" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.ServerCertificateValidationCallback" />
      <MemberSignature Language="VB.NET" Value="Public Property ServerCertificateValidationCallback As RemoteCertificateValidationCallback" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::Security::RemoteCertificateValidationCallback ^ ServerCertificateValidationCallback { System::Net::Security::RemoteCertificateValidationCallback ^ get(); void set(System::Net::Security::RemoteCertificateValidationCallback ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ServerCertificateValidationCallback : System.Net.Security.RemoteCertificateValidationCallback with get, set" Usage="System.Net.HttpWebRequest.ServerCertificateValidationCallback" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Security.RemoteCertificateValidationCallback</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置用于验证服务器证书的回调函数。</summary>
        <value>用于验证服务器证书的回调函数。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 默认值是不设置任何回调函数和<xref:System.Net.HttpWebRequest.ServerCertificateValidationCallback%2A>属性是`null`。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ServicePoint">
      <MemberSignature Language="C#" Value="public System.Net.ServicePoint ServicePoint { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.ServicePoint ServicePoint" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.ServicePoint" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ServicePoint As ServicePoint" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::ServicePoint ^ ServicePoint { System::Net::ServicePoint ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ServicePoint : System.Net.ServicePoint" Usage="System.Net.HttpWebRequest.ServicePoint" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.ServicePoint</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取用于请求的服务点。</summary>
        <value>表示与 Internet 资源的网络连接的 <see cref="T:System.Net.ServicePoint" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.ServicePoint.Address%2A?displayProperty=nameWithType>属性可能不同于<xref:System.Net.HttpWebRequest.Address%2A?displayProperty=nameWithType>如果将请求重定向。  
  
   
  
## Examples  
 [!code-cpp[System.Net.ServicePoint#6](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.ServicePoint/CPP/servicepoint.cpp#6)]
 [!code-csharp[System.Net.ServicePoint#6](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.ServicePoint/CS/servicepoint.cs#6)]
 [!code-vb[System.Net.ServicePoint#6](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.ServicePoint/VB/servicepoint.vb#6)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SupportsCookieContainer">
      <MemberSignature Language="C#" Value="public virtual bool SupportsCookieContainer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SupportsCookieContainer" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.SupportsCookieContainer" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property SupportsCookieContainer As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool SupportsCookieContainer { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.SupportsCookieContainer : bool" Usage="System.Net.HttpWebRequest.SupportsCookieContainer" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示请求是否为 <see cref="T:System.Net.CookieContainer" /> 提供支持。</summary>
        <value>
          <see langword="true" /> 如果该请求提供的支持<see cref="T:System.Net.CookieContainer" />; 否则为<see langword="false" />。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.Serialization.ISerializable.GetObjectData">
      <MemberSignature Language="C#" Value="void ISerializable.GetObjectData (System.Runtime.Serialization.SerializationInfo serializationInfo, System.Runtime.Serialization.StreamingContext streamingContext);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.Serialization.ISerializable.GetObjectData(class System.Runtime.Serialization.SerializationInfo serializationInfo, valuetype System.Runtime.Serialization.StreamingContext streamingContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.System#Runtime#Serialization#ISerializable#GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.Serialization.ISerializable.GetObjectData(System::Runtime::Serialization::SerializationInfo ^ serializationInfo, System::Runtime::Serialization::StreamingContext streamingContext) = System::Runtime::Serialization::ISerializable::GetObjectData;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1">
          <AttributeName>System.Obsolete("Serialization is obsoleted for this type.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="serializationInfo" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="streamingContext" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="serializationInfo">要填充数据的 <see cref="T:System.Runtime.Serialization.SerializationInfo" />。</param>
        <param name="streamingContext">用于指定该序列化的目标的 <see cref="T:System.Runtime.Serialization.StreamingContext" />。</param>
        <summary>使用将目标对象序列化所需的数据填充 <see cref="T:System.Runtime.Serialization.SerializationInfo" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 中包含的任何对象<xref:System.Runtime.Serialization.SerializationInfo>会自动跟踪和格式化程序序列化。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Timeout">
      <MemberSignature Language="C#" Value="public override int Timeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Timeout" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Timeout" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Timeout As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int Timeout { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.Timeout : int with get, set" Usage="System.Net.HttpWebRequest.Timeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置 <see cref="M:System.Net.HttpWebRequest.GetResponse" /> 和 <see cref="M:System.Net.HttpWebRequest.GetRequestStream" /> 方法的超时值（以毫秒为单位）。</summary>
        <value>请求超时前等待的毫秒数。默认值是 100,000 毫秒（100 秒）。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.Timeout%2A> 是与发出后续的同步请求的毫秒数<xref:System.Net.HttpWebRequest.GetResponse%2A>方法等待响应，和<xref:System.Net.HttpWebRequest.GetRequestStream%2A>方法等待流。 <xref:System.Net.HttpWebRequest.Timeout%2A>适用于整个请求和响应，不单独对<xref:System.Net.HttpWebRequest.GetRequestStream%2A>和<xref:System.Net.HttpWebRequest.GetResponse%2A>方法调用。 如果在超时期间内未返回该资源，请求将引发<xref:System.Net.WebException>与<xref:System.Net.WebException.Status%2A>属性设置为<xref:System.Net.WebExceptionStatus.Timeout?displayProperty=nameWithType>。  
  
 <xref:System.Net.HttpWebRequest.Timeout%2A>属性必须设置之前<xref:System.Net.HttpWebRequest.GetRequestStream%2A>或<xref:System.Net.HttpWebRequest.GetResponse%2A>调用方法。 更改<xref:System.Net.HttpWebRequest.Timeout%2A>属性后调用<xref:System.Net.HttpWebRequest.GetRequestStream%2A>或<xref:System.Net.HttpWebRequest.GetResponse%2A>方法不起作用  
  
 <xref:System.Net.HttpWebRequest.Timeout%2A>属性具有与发出异步请求不会影响<xref:System.Net.HttpWebRequest.BeginGetResponse%2A>或<xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A>方法。  
  
> [!CAUTION]
>  对于异步请求，客户端应用程序实现其自己的超时机制。 中的示例，请参阅<xref:System.Net.HttpWebRequest.BeginGetResponse%2A>方法。  
  
 若要指定的时间来等待读取或写入操作超时，请使用<xref:System.Net.HttpWebRequest.ReadWriteTimeout%2A>属性。  
  
 域名系统 (DNS) 查询可能需要最多 15 秒钟才能返回或超时时间。如果你的请求包含需要解析的主机名，并设置<xref:System.Net.FileWebRequest.Timeout%2A>的值不超过 15 秒，可能需要花费 15 秒或更长时间才<xref:System.Net.WebException>引发来指示你的请求超时。  
  
   
  
## Examples  
 下面的代码示例设置<xref:System.Net.HttpWebRequest.Timeout%2A>属性的<xref:System.Net.HttpWebRequest>对象。  
  
 [!code-cpp[HttpWebRequest_Timeout#1](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_Timeout/CPP/httpwebrequest_timeout.cpp#1)]
 [!code-csharp[HttpWebRequest_Timeout#1](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_Timeout/CS/httpwebrequest_timeout.cs#1)]
 [!code-vb[HttpWebRequest_Timeout#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_Timeout/VB/httpwebrequest_timeout.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">指定的值小于零，并且不为 <see cref="F:System.Threading.Timeout.Infinite" />。</exception>
        <altmember cref="P:System.Net.HttpWebRequest.ReadWriteTimeout" />
      </Docs>
    </Member>
    <Member MemberName="TransferEncoding">
      <MemberSignature Language="C#" Value="public string TransferEncoding { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string TransferEncoding" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.TransferEncoding" />
      <MemberSignature Language="VB.NET" Value="Public Property TransferEncoding As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ TransferEncoding { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.TransferEncoding : string with get, set" Usage="System.Net.HttpWebRequest.TransferEncoding" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置 <see langword="Transfer-encoding" /> HTTP 标头的值。</summary>
        <value>
          <see langword="Transfer-encoding" /> HTTP 标头的值。 默认值为 <see langword="null" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 可以设置前<xref:System.Net.HttpWebRequest.TransferEncoding%2A>属性，必须先设置<xref:System.Net.HttpWebRequest.SendChunked%2A>属性设置为`true`。 清除<xref:System.Net.HttpWebRequest.TransferEncoding%2A>通过将其设置为`null`的值不起<xref:System.Net.HttpWebRequest.SendChunked%2A>。  
  
 分配给值<xref:System.Net.HttpWebRequest.TransferEncoding%2A>属性替换任何现有内容。  
  
> [!NOTE]
>  此属性的值存储在 <xref:System.Net.WebHeaderCollection> 中。 如果设置了 WebHeaderCollection，则该属性值将丢失。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">当 <see cref="P:System.Net.HttpWebRequest.TransferEncoding" /> 为 <see langword="false" /> 时设置 <see cref="P:System.Net.HttpWebRequest.SendChunked" />。</exception>
        <exception cref="T:System.ArgumentException">
          <see cref="P:System.Net.HttpWebRequest.TransferEncoding" /> 被设置为值“Chunked”。</exception>
      </Docs>
    </Member>
    <Member MemberName="UnsafeAuthenticatedConnectionSharing">
      <MemberSignature Language="C#" Value="public bool UnsafeAuthenticatedConnectionSharing { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UnsafeAuthenticatedConnectionSharing" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.UnsafeAuthenticatedConnectionSharing" />
      <MemberSignature Language="VB.NET" Value="Public Property UnsafeAuthenticatedConnectionSharing As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UnsafeAuthenticatedConnectionSharing { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.UnsafeAuthenticatedConnectionSharing : bool with get, set" Usage="System.Net.HttpWebRequest.UnsafeAuthenticatedConnectionSharing" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值指示是否允许经过高速 NTLM 身份验证的连接共享。</summary>
        <value>
          <see langword="true" /> 表示使经过身份验证的连接保持打开状态；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此属性的默认值是`false`，这将导致当前连接的请求完成后关闭。 每次它会发出新请求时，你的应用程序必须经过身份验证序列。  
  
 如果此属性设置为`true`，用于检索响应的连接保持打开状态后执行身份验证。 在这种情况下，其他请求具有此属性设置为`true`可以使用该连接而无需重新进行身份验证。 换而言之，如果一个连接已经过身份验证的用户 A，用户 B 可能重复使用 A 的连接;根据用户 A.的凭据实现用户 B 的请求  
  
> [!CAUTION]
>  因为它是应用程序可以使用而无需进行身份验证的连接，您需要确保没有任何管理漏洞在你的系统时此属性设置为`true`。 如果你的应用程序将请求发送多个用户 （模拟多个用户帐户） 和依赖于身份验证来保护资源，未设置此属性`true`除非你使用连接组，如下所述。  
  
 可能需要考虑启用此机制，如果您有性能问题和集成 Windows 身份验证的 Web 服务器上运行你的应用程序。  
  
 启用此设置将使系统面临安全风险。 如果您设置<xref:System.Net.HttpWebRequest.UnsafeAuthenticatedConnectionSharing%2A>属性设置为`true`确保采取以下预防措施：  
  
-   使用<xref:System.Net.HttpWebRequest.ConnectionGroupName%2A>属性来管理不同的用户的连接。 这将避免连接的使用可能由未经身份验证应用程序。 例如，用户 A 应具有唯一的连接组名称不同于用户 b。这提供了一层隔离每个用户帐户。  
  
-   为了帮助避免连接被利用的受保护环境中运行应用程序。  
  
 如果您控制后端服务器，也可以考虑关闭身份验证持久性。 这将提高性能一定程度上，但更安全。 有关更多详细信息，搜索上的 MSDN library 中的 AuthPersistence [ http://msdn.microsoft.com/library ](http://msdn.microsoft.com/library)。  
  
> [!NOTE]
>  如果这两个<xref:System.Net.WebRequest.PreAuthenticate%2A>并<xref:System.Net.HttpWebRequest.UnsafeAuthenticatedConnectionSharing%2A>设置为`true`，每个请求发送来自不安全的池，但具有一个授权标头使用的连接。  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Net.WebPermission">设置此属性需要不受限制的 Web 权限。</permission>
      </Docs>
    </Member>
    <Member MemberName="UseDefaultCredentials">
      <MemberSignature Language="C#" Value="public override bool UseDefaultCredentials { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UseDefaultCredentials" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.UseDefaultCredentials" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property UseDefaultCredentials As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool UseDefaultCredentials { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.UseDefaultCredentials : bool with get, set" Usage="System.Net.HttpWebRequest.UseDefaultCredentials" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个 <see cref="T:System.Boolean" /> 值，该值控制默认凭据是否随请求一起发送。</summary>
        <value>如果使用默认凭据，则为 <see langword="true" />；否则为 <see langword="false" />。 默认值为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 将此属性设置为`true`时发出此请求<xref:System.Net.HttpWebRequest>对象应，如果请求服务器进行身份验证使用当前登录用户的凭据。 对于客户端应用程序，这是在大多数情况下所需的行为。 对于中间层应用程序，如 ASP.NET 应用程序，而不是使用此属性，通常会设置<xref:System.Net.HttpWebRequest.Credentials%2A>属性设置为客户端的名义发出请求的凭据。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">你试图在发送请求后设置该属性。</exception>
      </Docs>
    </Member>
    <Member MemberName="UserAgent">
      <MemberSignature Language="C#" Value="public string UserAgent { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string UserAgent" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.UserAgent" />
      <MemberSignature Language="VB.NET" Value="Public Property UserAgent As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ UserAgent { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.UserAgent : string with get, set" Usage="System.Net.HttpWebRequest.UserAgent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置 <see langword="User-agent" /> HTTP 标头的值。</summary>
        <value>
          <see langword="User-agent" /> HTTP 标头的值。 默认值为 <see langword="null" />。  
  
 <block subset="none" type="note"><para>  
 此属性的值存储在 <see cref="T:System.Net.WebHeaderCollection" /> 中。 如果设置了 WebHeaderCollection，则该属性值将丢失。  
  
</para></block></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下面的代码示例设置<xref:System.Net.HttpWebRequest.UserAgent%2A>属性。  
  
 [!code-cpp[HttpWebRequest_UserAgent#1](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_UserAgent/CPP/httpwebrequest_useragent.cpp#1)]
 [!code-csharp[HttpWebRequest_UserAgent#1](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_UserAgent/CS/httpwebrequest_useragent.cs#1)]
 [!code-vb[HttpWebRequest_UserAgent#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_UserAgent/VB/httpwebrequest_useragent.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>