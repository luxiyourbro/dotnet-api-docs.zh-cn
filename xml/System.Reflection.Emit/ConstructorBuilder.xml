<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="ConstructorBuilder.xml" source-language="en-US" target-language="zh-CN">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-15c36f0" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">02cd5861-7ce2-4a82-b358-31f8435a0ac5025ceef4595d3f427e86addba94956b845850041.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">025ceef4595d3f427e86addba94956b845850041</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/03/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netcore-1.0,netcore-1.1,netcore-2.0,netcore-2.1,netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7,xamarinandroid-7.1,xamarinios-10.8,xamarinmac-3.0</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.Reflection.Emit.ConstructorBuilder">
          <source>Defines and represents a constructor of a dynamic class.</source>
          <target state="translated">定义并表示动态类的构造函数。</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.ConstructorBuilder">
          <source><ph id="ph1">&lt;xref:System.Reflection.Emit.ConstructorBuilder&gt;</ph> is used to fully describe a constructor in Microsoft intermediate language (MSIL), including the name, attributes, signature, and constructor body.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.Emit.ConstructorBuilder&gt;</ph> 用于完全描述 Microsoft 中间语言 (MSIL) 中的构造函数包括名称、 属性、 签名和构造函数主体。</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.ConstructorBuilder">
          <source>It is used in conjunction with the <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> class to create classes at run time.</source>
          <target state="translated">结合使用<ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph>类在运行时创建类。</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.ConstructorBuilder">
          <source>Call <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.DefineConstructor%2A&gt;</ph> to get an instance of <ph id="ph2">&lt;xref:System.Reflection.Emit.ConstructorBuilder&gt;</ph>.</source>
          <target state="translated">调用<ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.DefineConstructor%2A&gt;</ph>要获取其实例的<ph id="ph2">&lt;xref:System.Reflection.Emit.ConstructorBuilder&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.ConstructorBuilder">
          <source>If you do not define a constructor for your dynamic type, a default constructor is provided automatically, and it calls the default constructor of the base class.</source>
          <target state="translated">如果为动态类型未定义构造函数，自动提供默认构造函数，它会调用基类的默认构造函数。</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.ConstructorBuilder">
          <source>If you use <ph id="ph1">&lt;xref:System.Reflection.Emit.ConstructorBuilder&gt;</ph> to define a constructor for your dynamic type, a default constructor is not provided.</source>
          <target state="translated">如果你使用<ph id="ph1">&lt;xref:System.Reflection.Emit.ConstructorBuilder&gt;</ph>定义为动态类型的构造函数，默认构造函数未提供。</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.ConstructorBuilder">
          <source>You have the following options for providing a default constructor in addition to the constructor you defined:</source>
          <target state="translated">必须提供默认构造函数除了你定义的构造函数的以下选项：</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.ConstructorBuilder">
          <source>If you want a default constructor that simply calls the default constructor of the base class, you can use the <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.DefineDefaultConstructor%2A?displayProperty=nameWithType&gt;</ph> method to create one (and optionally restrict access to it).</source>
          <target state="translated">如果你希望只需调用基类的默认构造函数的默认构造函数，则可以使用<ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.DefineDefaultConstructor%2A?displayProperty=nameWithType&gt;</ph>方法来创建一个 （也可以将访问限制到它）。</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.ConstructorBuilder">
          <source>Do not provide an implementation for this default constructor.</source>
          <target state="translated">不提供此默认构造函数的实现。</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.ConstructorBuilder">
          <source>If you do, an exception is thrown when you try to use the constructor.</source>
          <target state="translated">如果这样做，当你尝试使用构造函数时，将引发异常。</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.ConstructorBuilder">
          <source>No exception is thrown when the <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A?displayProperty=nameWithType&gt;</ph> method is called.</source>
          <target state="translated">不引发异常时<ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A?displayProperty=nameWithType&gt;</ph>调用方法。</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.ConstructorBuilder">
          <source>If you want a default constructor that does something more than simply calling the default constructor of the base class, or that calls another constructor of the base class, or that does something else entirely, you must use the <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.DefineConstructor%2A?displayProperty=nameWithType&gt;</ph> method to create a <ph id="ph2">&lt;xref:System.Reflection.Emit.ConstructorBuilder&gt;</ph>, and provide your own implementation.</source>
          <target state="translated">如果你希望默认构造函数来执行多个只需调用基类的默认构造函数或调用另一个构造函数的基类，或执行其他操作完全，必须使用<ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.DefineConstructor%2A?displayProperty=nameWithType&gt;</ph>方法来创建<ph id="ph2">&lt;xref:System.Reflection.Emit.ConstructorBuilder&gt;</ph>，并提供您自己的实现。</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.ConstructorBuilder">
          <source>The following code sample illustrates the contextual usage of a <ph id="ph1">`ConstructorBuilder`</ph>.</source>
          <target state="translated">下面的代码示例演示的上下文用法<ph id="ph1">`ConstructorBuilder`</ph>。</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ConstructorBuilder.AddDeclarativeSecurity(System.Security.Permissions.SecurityAction,System.Security.PermissionSet)">
          <source>The security action to be taken, such as Demand, Assert, and so on.</source>
          <target state="translated">要执行的安全操作，例如 Demand、Assert 等。</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ConstructorBuilder.AddDeclarativeSecurity(System.Security.Permissions.SecurityAction,System.Security.PermissionSet)">
          <source>The set of permissions the action applies to.</source>
          <target state="translated">应用此操作的权限集。</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ConstructorBuilder.AddDeclarativeSecurity(System.Security.Permissions.SecurityAction,System.Security.PermissionSet)">
          <source>Adds declarative security to this constructor.</source>
          <target state="translated">将声明性安全添加到此构造函数。</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ConstructorBuilder.AddDeclarativeSecurity(System.Security.Permissions.SecurityAction,System.Security.PermissionSet)">
          <source><ph id="ph1">&lt;xref:System.Reflection.Emit.ConstructorBuilder.AddDeclarativeSecurity%2A&gt;</ph> can be called several times, with each call specifying a security action (such as <ph id="ph2">`Demand`</ph>, <ph id="ph3">`Assert`</ph>, and <ph id="ph4">`Deny`</ph>) and a set of permissions that the action applies to.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.Emit.ConstructorBuilder.AddDeclarativeSecurity%2A&gt;</ph> 可以调用多次，每次调用指定的安全操作 (如<ph id="ph2">`Demand`</ph>， <ph id="ph3">`Assert`</ph>，和<ph id="ph4">`Deny`</ph>) 和一组应用此操作的权限。</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ConstructorBuilder.AddDeclarativeSecurity(System.Security.Permissions.SecurityAction,System.Security.PermissionSet)">
          <source>In the .NET Framework versions 1.0, 1.1, and 2.0, the declarative security attributes applied to a constructor by using this method are stored in the old XML metadata format.</source>
          <target state="translated">在.NET Framework 版本 1.0、 1.1 和 2.0 中，通过使用此方法应用于构造函数的声明性安全属性存储在旧的 XML 元数据格式。</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ConstructorBuilder.AddDeclarativeSecurity(System.Security.Permissions.SecurityAction,System.Security.PermissionSet)">
          <source>See Emitting Declarative Security Attributes.</source>
          <target state="translated">请参阅发出的声明性安全属性。</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ConstructorBuilder.AddDeclarativeSecurity(System.Security.Permissions.SecurityAction,System.Security.PermissionSet)">
          <source>The following code sample illustrates the use of <ph id="ph1">`AddDeclarativeSecurity`</ph>.</source>
          <target state="translated">下面的代码示例演示如何使用<ph id="ph1">`AddDeclarativeSecurity`</ph>。</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ConstructorBuilder.AddDeclarativeSecurity(System.Security.Permissions.SecurityAction,System.Security.PermissionSet)">
          <source><ph id="ph1">&lt;paramref name="action" /&gt;</ph> is invalid (RequestMinimum, RequestOptional, and RequestRefuse are invalid).</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="action" /&gt;</ph> 无效（RequestMinimum、RequestOptional 和 RequestRefuse 无效）。</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ConstructorBuilder.AddDeclarativeSecurity(System.Security.Permissions.SecurityAction,System.Security.PermissionSet)">
          <source>The containing type has been previously created using <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph>.</source>
          <target state="translated">之前已使用 <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph> 创建包含类型。</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ConstructorBuilder.AddDeclarativeSecurity(System.Security.Permissions.SecurityAction,System.Security.PermissionSet)">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ConstructorBuilder.AddDeclarativeSecurity(System.Security.Permissions.SecurityAction,System.Security.PermissionSet)">
          <source>The permission set <ph id="ph1">&lt;paramref name="pset" /&gt;</ph> contains an action that was added earlier by <ph id="ph2">&lt;see langword="AddDeclarativeSecurity" /&gt;</ph>.</source>
          <target state="translated">权限集 <ph id="ph1">&lt;paramref name="pset" /&gt;</ph> 包含之前由 <ph id="ph2">&lt;see langword="AddDeclarativeSecurity" /&gt;</ph> 添加的操作。</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ConstructorBuilder.AddDeclarativeSecurity(System.Security.Permissions.SecurityAction,System.Security.PermissionSet)">
          <source><ph id="ph1">&lt;paramref name="pset" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="pset" /&gt;</ph> 为 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.ConstructorBuilder.Attributes">
          <source>Retrieves the attributes for this constructor.</source>
          <target state="translated">检索此构造函数的属性。</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.ConstructorBuilder.Attributes">
          <source>Returns the attributes for this constructor.</source>
          <target state="translated">返回此构造函数的属性。</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.ConstructorBuilder.Attributes">
          <source>The following code sample illustrates the use of <ph id="ph1">`Attributes`</ph>.</source>
          <target state="translated">下面的代码示例演示如何使用<ph id="ph1">`Attributes`</ph>。</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.ConstructorBuilder.CallingConvention">
          <source>Gets a <ph id="ph1">&lt;see cref="T:System.Reflection.CallingConventions" /&gt;</ph> value that depends on whether the declaring type is generic.</source>
          <target state="translated">获取一个 <ph id="ph1">&lt;see cref="T:System.Reflection.CallingConventions" /&gt;</ph> 值，该值取决于声明类型是否为泛型。</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.ConstructorBuilder.CallingConvention">
          <source><ph id="ph1">&lt;see cref="F:System.Reflection.CallingConventions.HasThis" /&gt;</ph> if the declaring type is generic; otherwise, <ph id="ph2">&lt;see cref="F:System.Reflection.CallingConventions.Standard" /&gt;</ph>.</source>
          <target state="translated">如果声明类型为泛型，则为 <ph id="ph1">&lt;see cref="F:System.Reflection.CallingConventions.HasThis" /&gt;</ph>；否则为 <ph id="ph2">&lt;see cref="F:System.Reflection.CallingConventions.Standard" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.ConstructorBuilder.DeclaringType">
          <source>Retrieves a reference to the <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> object for the type that declares this member.</source>
          <target state="translated">检索对声明此成员的类型的 <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> 对象的引用。</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.ConstructorBuilder.DeclaringType">
          <source>Returns the <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> object for the type that declares this member.</source>
          <target state="translated">返回声明此成员的类型的 <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> 对象。</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.ConstructorBuilder.DeclaringType">
          <source>A member of a class (or interface) is either declared or inherited from a base class (or interface).</source>
          <target state="translated">类 （或接口） 的成员声明或继承自基类 （或接口）。</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.ConstructorBuilder.DeclaringType">
          <source>The following code sample illustrates the use of <ph id="ph1">`DeclaringType`</ph>.</source>
          <target state="translated">下面的代码示例演示如何使用<ph id="ph1">`DeclaringType`</ph>。</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ConstructorBuilder.DefineParameter(System.Int32,System.Reflection.ParameterAttributes,System.String)">
          <source>The position of the parameter in the parameter list.</source>
          <target state="translated">参数在参数列表中的位置。</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ConstructorBuilder.DefineParameter(System.Int32,System.Reflection.ParameterAttributes,System.String)">
          <source>Parameters are indexed beginning with the number 1 for the first parameter.</source>
          <target state="translated">通过第一个参数以数字 1 开头对参数编制索引。</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ConstructorBuilder.DefineParameter(System.Int32,System.Reflection.ParameterAttributes,System.String)">
          <source>The attributes of the parameter.</source>
          <target state="translated">参数的属性。</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ConstructorBuilder.DefineParameter(System.Int32,System.Reflection.ParameterAttributes,System.String)">
          <source>The name of the parameter.</source>
          <target state="translated">参数的名称。</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ConstructorBuilder.DefineParameter(System.Int32,System.Reflection.ParameterAttributes,System.String)">
          <source>The name can be the null string.</source>
          <target state="translated">名称可以是空字符串。</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ConstructorBuilder.DefineParameter(System.Int32,System.Reflection.ParameterAttributes,System.String)">
          <source>Defines a parameter of this constructor.</source>
          <target state="translated">定义此构造函数的参数。</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ConstructorBuilder.DefineParameter(System.Int32,System.Reflection.ParameterAttributes,System.String)">
          <source>Returns a <ph id="ph1">&lt;see langword="ParameterBuilder" /&gt;</ph> object that represents the new parameter of this constructor.</source>
          <target state="translated">返回 <ph id="ph1">&lt;see langword="ParameterBuilder" /&gt;</ph> 对象，它表示此构造函数的新参数。</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ConstructorBuilder.DefineParameter(System.Int32,System.Reflection.ParameterAttributes,System.String)">
          <source>If you specify 0 (zero) for <ph id="ph1">`iSequence`</ph>, this method returns a <ph id="ph2">&lt;xref:System.Reflection.Emit.ParameterBuilder&gt;</ph> instead of throwing an exception.</source>
          <target state="translated">如果指定 0 （零） <ph id="ph1">`iSequence`</ph>，此方法返回<ph id="ph2">&lt;xref:System.Reflection.Emit.ParameterBuilder&gt;</ph>而不是引发异常。</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ConstructorBuilder.DefineParameter(System.Int32,System.Reflection.ParameterAttributes,System.String)">
          <source>There is nothing useful that you can do with this <ph id="ph1">&lt;xref:System.Reflection.Emit.ParameterBuilder&gt;</ph>.</source>
          <target state="translated">无需进行任何可供你执行与此<ph id="ph1">&lt;xref:System.Reflection.Emit.ParameterBuilder&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ConstructorBuilder.DefineParameter(System.Int32,System.Reflection.ParameterAttributes,System.String)">
          <source><ph id="ph1">&lt;paramref name="iSequence" /&gt;</ph> is less than 0 (zero), or it is greater than the number of parameters of the constructor.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="iSequence" /&gt;</ph> 小于 0（零）或大于此构造函数的参数数目。</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ConstructorBuilder.DefineParameter(System.Int32,System.Reflection.ParameterAttributes,System.String)">
          <source>The containing type has been created using <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph>.</source>
          <target state="translated">已使用 <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph> 创建包含类型。</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" uid="T:System.Reflection.Emit.ConstructorBuilder">
          <source>Returns the custom attributes defined for this constructor.</source>
          <target state="translated">返回为此构造函数定义的自定义属性。</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ConstructorBuilder.GetCustomAttributes(System.Boolean)">
          <source>Controls inheritance of custom attributes from base classes.</source>
          <target state="translated">基类中自定义属性的控件继承。</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ConstructorBuilder.GetCustomAttributes(System.Boolean)">
          <source>This parameter is ignored.</source>
          <target state="translated">忽略此参数。</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ConstructorBuilder.GetCustomAttributes(System.Boolean)">
          <source>Returns all the custom attributes defined for this constructor.</source>
          <target state="translated">返回为此构造函数定义的所有自定义属性。</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ConstructorBuilder.GetCustomAttributes(System.Boolean)">
          <source>Returns an array of objects representing all the custom attributes of the constructor represented by this <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.ConstructorBuilder" /&gt;</ph> instance.</source>
          <target state="translated">返回对象的数组，表示由此 <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.ConstructorBuilder" /&gt;</ph> 实例表示的构造函数的所有自定义属性。</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ConstructorBuilder.GetCustomAttributes(System.Boolean)">
          <source>The <ph id="ph1">`inherit`</ph> parameter is ignored because a class never inherits constructors from base classes.</source>
          <target state="translated"><ph id="ph1">`inherit`</ph>参数将被忽略，因为类永远不会继承自基类的构造函数。</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ConstructorBuilder.GetCustomAttributes(System.Boolean)">
          <source>To get the custom attributes, finish building the type by calling <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A&gt;</ph>, retrieve the constructor by calling the <ph id="ph2">&lt;xref:System.Type.GetConstructor%2A&gt;</ph> method on the returned type, and then call the <ph id="ph3">&lt;xref:System.Reflection.MemberInfo.GetCustomAttributes%2A&gt;</ph> method on the returned <ph id="ph4">&lt;xref:System.Reflection.ConstructorInfo&gt;</ph>.</source>
          <target state="translated">若要获取的自定义特性，完成类型的生成通过调用<ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A&gt;</ph>，检索构造函数通过调用<ph id="ph2">&lt;xref:System.Type.GetConstructor%2A&gt;</ph>方法返回的类型，然后调用<ph id="ph3">&lt;xref:System.Reflection.MemberInfo.GetCustomAttributes%2A&gt;</ph>方法返回的<ph id="ph4">&lt;xref:System.Reflection.ConstructorInfo&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ConstructorBuilder.GetCustomAttributes(System.Boolean)">
          <source>This method is not currently supported.</source>
          <target state="translated">目前尚不支持此方法。</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ConstructorBuilder.GetCustomAttributes(System.Type,System.Boolean)">
          <source>The custom attribute type.</source>
          <target state="translated">自定义属性类型。</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ConstructorBuilder.GetCustomAttributes(System.Type,System.Boolean)">
          <source>Controls inheritance of custom attributes from base classes.</source>
          <target state="translated">基类中自定义属性的控件继承。</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ConstructorBuilder.GetCustomAttributes(System.Type,System.Boolean)">
          <source>This parameter is ignored.</source>
          <target state="translated">忽略此参数。</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ConstructorBuilder.GetCustomAttributes(System.Type,System.Boolean)">
          <source>Returns the custom attributes identified by the given type.</source>
          <target state="translated">返回由给定类型标识的自定义属性。</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ConstructorBuilder.GetCustomAttributes(System.Type,System.Boolean)">
          <source>Returns an array of type <ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph> representing the attributes of this constructor.</source>
          <target state="translated">返回表示此构造函数的特性的 <ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph> 类型数组。</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ConstructorBuilder.GetCustomAttributes(System.Type,System.Boolean)">
          <source>The <ph id="ph1">`inherit`</ph> parameter is ignored because a class never inherits constructors from base classes.</source>
          <target state="translated"><ph id="ph1">`inherit`</ph>参数将被忽略，因为类永远不会继承自基类的构造函数。</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ConstructorBuilder.GetCustomAttributes(System.Type,System.Boolean)">
          <source>To get the custom attributes, finish building the type by calling <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A&gt;</ph>, retrieve the constructor by calling the <ph id="ph2">&lt;xref:System.Type.GetConstructor%2A&gt;</ph> method on the returned type, and then call the <ph id="ph3">&lt;xref:System.Reflection.MemberInfo.GetCustomAttributes%2A&gt;</ph> method on the returned <ph id="ph4">&lt;xref:System.Reflection.ConstructorInfo&gt;</ph>.</source>
          <target state="translated">若要获取的自定义特性，完成类型的生成通过调用<ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A&gt;</ph>，检索构造函数通过调用<ph id="ph2">&lt;xref:System.Type.GetConstructor%2A&gt;</ph>方法返回的类型，然后调用<ph id="ph3">&lt;xref:System.Reflection.MemberInfo.GetCustomAttributes%2A&gt;</ph>方法返回的<ph id="ph4">&lt;xref:System.Reflection.ConstructorInfo&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ConstructorBuilder.GetCustomAttributes(System.Type,System.Boolean)">
          <source>This method is not currently supported.</source>
          <target state="translated">目前尚不支持此方法。</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" uid="T:System.Reflection.Emit.ConstructorBuilder">
          <source>Gets an <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.ILGenerator" /&gt;</ph> that can be used to emit a method body for this constructor.</source>
          <target state="translated">获取可以用来为此构造函数发出方法体的 <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.ILGenerator" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ConstructorBuilder.GetILGenerator">
          <source>Gets an <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.ILGenerator" /&gt;</ph> for this constructor.</source>
          <target state="translated">获取此构造函数的 <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.ILGenerator" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ConstructorBuilder.GetILGenerator">
          <source>Returns an <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.ILGenerator" /&gt;</ph> object for this constructor.</source>
          <target state="translated">返回此构造函数的 <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.ILGenerator" /&gt;</ph> 对象。</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ConstructorBuilder.GetILGenerator">
          <source>The runtime generates the code for default constructors.</source>
          <target state="translated">运行时生成默认构造函数的代码。</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ConstructorBuilder.GetILGenerator">
          <source>Therefore, if an attempt is made to obtain an <ph id="ph1">`ILGenerator`</ph>, an exception will be thrown.</source>
          <target state="translated">因此，如果尝试获取<ph id="ph1">`ILGenerator`</ph>，将引发异常。</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ConstructorBuilder.GetILGenerator">
          <source>The following code sample illustrates the use of the <ph id="ph1">`GetILGenerator`</ph> method.</source>
          <target state="translated">下面的代码示例演示如何使用<ph id="ph1">`GetILGenerator`</ph>方法。</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ConstructorBuilder.GetILGenerator">
          <source>The constructor is a default constructor.</source>
          <target state="translated">该构造函数是默认构造函数。</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ConstructorBuilder.GetILGenerator">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ConstructorBuilder.GetILGenerator">
          <source>The constructor has <ph id="ph1">&lt;see cref="T:System.Reflection.MethodAttributes" /&gt;</ph> or <ph id="ph2">&lt;see cref="T:System.Reflection.MethodImplAttributes" /&gt;</ph> flags indicating that it should not have a method body.</source>
          <target state="translated">该构造函数具有 <ph id="ph1">&lt;see cref="T:System.Reflection.MethodAttributes" /&gt;</ph> 或 <ph id="ph2">&lt;see cref="T:System.Reflection.MethodImplAttributes" /&gt;</ph> 标志，指示其不能包含方法体。</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ConstructorBuilder.GetILGenerator(System.Int32)">
          <source>The size of the MSIL stream, in bytes.</source>
          <target state="translated">MSIL 流的大小（以字节为单位）。</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ConstructorBuilder.GetILGenerator(System.Int32)">
          <source>Gets an <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.ILGenerator" /&gt;</ph> object, with the specified MSIL stream size, that can be used to build a method body for this constructor.</source>
          <target state="translated">获取具有指定 MSIL 流大小的 <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.ILGenerator" /&gt;</ph> 对象，它可以用来生成此构造函数的方法体。</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ConstructorBuilder.GetILGenerator(System.Int32)">
          <source>An <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.ILGenerator" /&gt;</ph> for this constructor.</source>
          <target state="translated">用于此构造函数的 <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.ILGenerator" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ConstructorBuilder.GetILGenerator(System.Int32)">
          <source>The runtime generates the code for default constructors.</source>
          <target state="translated">运行时生成默认构造函数的代码。</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ConstructorBuilder.GetILGenerator(System.Int32)">
          <source>Therefore, if an attempt is made to obtain an <ph id="ph1">`ILGenerator`</ph> for a default constructor, an exception is thrown.</source>
          <target state="translated">因此，如果尝试获取<ph id="ph1">`ILGenerator`</ph>为默认构造函数，将引发异常。</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ConstructorBuilder.GetILGenerator(System.Int32)">
          <source>The constructor is a default constructor.</source>
          <target state="translated">该构造函数是默认构造函数。</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ConstructorBuilder.GetILGenerator(System.Int32)">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ConstructorBuilder.GetILGenerator(System.Int32)">
          <source>The constructor has <ph id="ph1">&lt;see cref="T:System.Reflection.MethodAttributes" /&gt;</ph> or <ph id="ph2">&lt;see cref="T:System.Reflection.MethodImplAttributes" /&gt;</ph> flags indicating that it should not have a method body.</source>
          <target state="translated">该构造函数具有 <ph id="ph1">&lt;see cref="T:System.Reflection.MethodAttributes" /&gt;</ph> 或 <ph id="ph2">&lt;see cref="T:System.Reflection.MethodImplAttributes" /&gt;</ph> 标志，指示其不能包含方法体。</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ConstructorBuilder.GetMethodImplementationFlags">
          <source>Returns the method implementation flags for this constructor.</source>
          <target state="translated">返回此构造函数的方法实现标志。</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ConstructorBuilder.GetMethodImplementationFlags">
          <source>The method implementation flags for this constructor.</source>
          <target state="translated">此构造函数的方法实现标志。</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ConstructorBuilder.GetMethodImplementationFlags">
          <source>The following code sample illustrates the use of <ph id="ph1">`GetMethodImplementationFlags`</ph>.</source>
          <target state="translated">下面的代码示例演示如何使用<ph id="ph1">`GetMethodImplementationFlags`</ph>。</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ConstructorBuilder.GetModule">
          <source>Returns a reference to the module that contains this constructor.</source>
          <target state="translated">返回包含此构造函数的模块的引用。</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ConstructorBuilder.GetModule">
          <source>The module that contains this constructor.</source>
          <target state="translated">包含此构造函数的模块。</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ConstructorBuilder.GetModule">
          <source>The following code sample illustrates the usage of <ph id="ph1">`GetModule`</ph>.</source>
          <target state="translated">下面的代码示例阐释了的用法<ph id="ph1">`GetModule`</ph>。</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ConstructorBuilder.GetParameters">
          <source>Returns the parameters of this constructor.</source>
          <target state="translated">返回此构造函数的参数。</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ConstructorBuilder.GetParameters">
          <source>Returns an array of <ph id="ph1">&lt;see cref="T:System.Reflection.ParameterInfo" /&gt;</ph> objects that represent the parameters of this constructor.</source>
          <target state="translated">返回表示此构造函数的参数的 <ph id="ph1">&lt;see cref="T:System.Reflection.ParameterInfo" /&gt;</ph> 对象的数组。</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ConstructorBuilder.GetParameters">
          <source>This property is not supported until after the <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A?displayProperty=nameWithType&gt;</ph> method has been called.</source>
          <target state="translated">之前，不支持此属性后<ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A?displayProperty=nameWithType&gt;</ph>调用方法。</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ConstructorBuilder.GetParameters">
          <source>In the .NET Framework versions 1.0 and 1.1, <ph id="ph1">&lt;xref:System.InvalidOperationException&gt;</ph> is thrown.</source>
          <target state="translated">在.NET framework 1.0 和 1.1 中，<ph id="ph1">&lt;xref:System.InvalidOperationException&gt;</ph>引发。</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ConstructorBuilder.GetParameters">
          <source>In the .NET Framework version 2.0, <ph id="ph1">&lt;xref:System.NotSupportedException&gt;</ph> is thrown.</source>
          <target state="translated">在.NET Framework 2.0 版中，<ph id="ph1">&lt;xref:System.NotSupportedException&gt;</ph>引发。</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ConstructorBuilder.GetParameters">
          <source>The code sample illustrates the use of <ph id="ph1">`GetParameters`</ph>.</source>
          <target state="translated">代码示例演示如何使用<ph id="ph1">`GetParameters`</ph>。</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ConstructorBuilder.GetParameters">
          <source><ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph> has not been called on this constructor's type, in the .NET Framework versions 1.0 and 1.1.</source>
          <target state="translated">在 .NET framework 1.0 和 1.1 版中，尚未在此构造函数的类型上调用 <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ConstructorBuilder.GetParameters">
          <source><ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph> has not been called on this constructor's type, in the .NET Framework version 2.0.</source>
          <target state="translated">在 .NET Framework 2.0 版中，尚未在此构造函数的类型上调用 <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ConstructorBuilder.GetToken">
          <source>Returns the <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.MethodToken" /&gt;</ph> that represents the token for this constructor.</source>
          <target state="translated">返回表示此构造函数的标记的 <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.MethodToken" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ConstructorBuilder.GetToken">
          <source>Returns the <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.MethodToken" /&gt;</ph> of this constructor.</source>
          <target state="translated">返回此构造函数的 <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.MethodToken" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ConstructorBuilder.GetToken">
          <source>This code sample illustrates the use of <ph id="ph1">`GetToken`</ph>.</source>
          <target state="translated">此代码示例演示如何使用<ph id="ph1">`GetToken`</ph>。</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.ConstructorBuilder.InitLocals">
          <source>Gets or sets whether the local variables in this constructor should be zero-initialized.</source>
          <target state="translated">获取或设置在此构造函数中的本地变量是否应初始化为零。</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.ConstructorBuilder.InitLocals">
          <source>Read/write.</source>
          <target state="translated">读/写。</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.ConstructorBuilder.InitLocals">
          <source>Gets or sets whether the local variables in this constructor should be zero-initialized.</source>
          <target state="translated">获取或设置在此构造函数中的本地变量是否应初始化为零。</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve" uid="T:System.Reflection.Emit.ConstructorBuilder">
          <source>Invokes the constructor dynamically reflected by this instance.</source>
          <target state="translated">调用此实例动态反射的构造函数。</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ConstructorBuilder.Invoke(System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>This must be a bit flag from <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph>, such as InvokeMethod, NonPublic, and so on.</source>
          <target state="translated">这必须是来自 <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> 的位标志，例如 InvokeMethod、NonPublic 等。</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ConstructorBuilder.Invoke(System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>An object that enables the binding, coercion of argument types, invocation of members, and retrieval of <ph id="ph1">&lt;see langword="MemberInfo" /&gt;</ph> objects using reflection.</source>
          <target state="translated">一个对象，它使用反射启用绑定、参数类型的强制、成员的调用和 <ph id="ph1">&lt;see langword="MemberInfo" /&gt;</ph> 对象的检索。</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ConstructorBuilder.Invoke(System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>If binder is <ph id="ph1">&lt;see langword="null" /&gt;</ph>, the default binder is used.</source>
          <target state="translated">如果 binder 为 <ph id="ph1">&lt;see langword="null" /&gt;</ph>，则使用默认活页夹。</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ConstructorBuilder.Invoke(System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>See <ph id="ph1">&lt;see cref="T:System.Reflection.Binder" /&gt;</ph>.</source>
          <target state="translated">请参阅 <ph id="ph1">&lt;see cref="T:System.Reflection.Binder" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ConstructorBuilder.Invoke(System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>An argument list.</source>
          <target state="translated">自变量列表。</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ConstructorBuilder.Invoke(System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>This is an array of arguments with the same number, order, and type as the parameters of the constructor to be invoked.</source>
          <target state="translated">此自变量数组在数量、顺序和类型方面必须与要调用的构造函数的参数相同。</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ConstructorBuilder.Invoke(System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>If there are no parameters this should be <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">如果不存在任何参数，则应为 <ph id="ph1">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ConstructorBuilder.Invoke(System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>An instance of <ph id="ph1">&lt;see cref="T:System.Globalization.CultureInfo" /&gt;</ph> used to govern the coercion of types.</source>
          <target state="translated">用于控制类型强制的 <ph id="ph1">&lt;see cref="T:System.Globalization.CultureInfo" /&gt;</ph> 的实例。</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ConstructorBuilder.Invoke(System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>If this is null, the <ph id="ph1">&lt;see cref="T:System.Globalization.CultureInfo" /&gt;</ph> for the current thread is used.</source>
          <target state="translated">如果这是 NULL，则使用当前线程的 <ph id="ph1">&lt;see cref="T:System.Globalization.CultureInfo" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ConstructorBuilder.Invoke(System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>(For example, this is necessary to convert a <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> that represents 1000 to a <ph id="ph2">&lt;see cref="T:System.Double" /&gt;</ph> value, since 1000 is represented differently by different cultures.)</source>
          <target state="translated">（这对于某些转换很必要，例如，将表示 1000 的 <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> 转换为 <ph id="ph2">&lt;see cref="T:System.Double" /&gt;</ph> 值，因为不同的区域性以不同的形式表示 1000。）</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ConstructorBuilder.Invoke(System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>Invokes the constructor dynamically reflected by this instance on the given object, passing along the specified parameters, and under the constraints of the given binder.</source>
          <target state="translated">调用由给定对象上的此实例动态反映的构造函数，传递指定的参数，并受给定绑定器的约束。</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ConstructorBuilder.Invoke(System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>Returns an <ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph> that is the return value of the invoked constructor.</source>
          <target state="translated">返回 <ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph>，它是已调用的构造函数的返回值。</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ConstructorBuilder.Invoke(System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>If the constructor has no parameters, the value of the <ph id="ph1">`parameters`</ph> parameter should be <ph id="ph2">`null`</ph>.</source>
          <target state="translated">如果构造函数具有任何参数的值<ph id="ph1">`parameters`</ph>参数应为<ph id="ph2">`null`</ph>。</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ConstructorBuilder.Invoke(System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>Otherwise, the number, type, and order of elements in the <ph id="ph1">`parameters`</ph> array should be identical to the number, type, and order of parameters for the constructor reflected by this instance.</source>
          <target state="translated">否则为数量、 类型和中的元素顺序<ph id="ph1">`parameters`</ph>数组应的数量、 类型和此实例反射的构造函数参数的顺序相同。</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ConstructorBuilder.Invoke(System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>For example, if the constructor reflected by this instance is declared as public class taking two strings, then the <ph id="ph1">`parameters`</ph> parameter should be an array of <ph id="ph2">&lt;xref:System.Object&gt;</ph> with length 2.</source>
          <target state="translated">例如，如果此实例反射的构造函数被声明为公共类采用两个字符串，则<ph id="ph1">`parameters`</ph>参数应是数组的<ph id="ph2">&lt;xref:System.Object&gt;</ph>长度为 2。</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ConstructorBuilder.Invoke(System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>Access restrictions are ignored for fully-trusted code.</source>
          <target state="translated">访问限制会忽略完全受信任的代码。</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ConstructorBuilder.Invoke(System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>That is, private constructors, methods, fields, and properties can be accessed and invoked using Reflection whenever the code is fully trusted.</source>
          <target state="translated">即私有构造函数、 方法、 字段和属性可以访问和使用反射，只要完全受信任代码调用。</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ConstructorBuilder.Invoke(System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>This method is not currently supported.</source>
          <target state="translated">目前尚不支持此方法。</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ConstructorBuilder.Invoke(System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>You can retrieve the constructor using <ph id="ph1">&lt;see cref="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" /&gt;</ph> and call <ph id="ph2">&lt;see cref="M:System.Reflection.ConstructorInfo.Invoke(System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)" /&gt;</ph> on the returned <ph id="ph3">&lt;see cref="T:System.Reflection.ConstructorInfo" /&gt;</ph>.</source>
          <target state="translated">可以使用 <ph id="ph1">&lt;see cref="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" /&gt;</ph> 检索构造函数，并对返回的 <ph id="ph2">&lt;see cref="M:System.Reflection.ConstructorInfo.Invoke(System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)" /&gt;</ph> 调用 <ph id="ph3">&lt;see cref="T:System.Reflection.ConstructorInfo" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ConstructorBuilder.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>The object that needs to be reinitialized.</source>
          <target state="translated">需要重新初始化的对象。</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ConstructorBuilder.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>One of the <ph id="ph1">&lt;see langword="BindingFlags" /&gt;</ph> values that specifies the type of binding that is desired.</source>
          <target state="translated">指定所需绑定类型的 <ph id="ph1">&lt;see langword="BindingFlags" /&gt;</ph> 值之一。</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ConstructorBuilder.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>A <ph id="ph1">&lt;see langword="Binder" /&gt;</ph> that defines a set of properties and enables the binding, coercion of argument types, and invocation of members using reflection.</source>
          <target state="translated">一个 <ph id="ph1">&lt;see langword="Binder" /&gt;</ph>，它定义一组属性并通过反射来启用绑定、自变量类型强制转换和成员调用。</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ConstructorBuilder.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>If <bpt id="p1">&lt;c&gt;</bpt>binder<ept id="p1">&lt;/c&gt;</ept> is <ph id="ph1">&lt;see langword="null" /&gt;</ph>, then Binder.DefaultBinding is used.</source>
          <target state="translated">如果 <bpt id="p1">&lt;c&gt;</bpt>binder<ept id="p1">&lt;/c&gt;</ept> 为 <ph id="ph1">&lt;see langword="null" /&gt;</ph>，则使用 Binder.DefaultBinding。</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ConstructorBuilder.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>An argument list.</source>
          <target state="translated">自变量列表。</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ConstructorBuilder.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>This is an array of arguments with the same number, order, and type as the parameters of the constructor to be invoked.</source>
          <target state="translated">此参数数组在数量、顺序和类型方面必须与要调用的构造函数的参数相同。</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ConstructorBuilder.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>If there are no parameters, this should be a null reference (<ph id="ph1">&lt;see langword="Nothing" /&gt;</ph> in Visual Basic).</source>
          <target state="translated">如果没有参数，则应为一个 null 引用（在 Visual Basic 中为 <ph id="ph1">&lt;see langword="Nothing" /&gt;</ph>）。</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ConstructorBuilder.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Globalization.CultureInfo" /&gt;</ph> used to govern the coercion of types.</source>
          <target state="translated">用于控制类型强制转换的 <ph id="ph1">&lt;see cref="T:System.Globalization.CultureInfo" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ConstructorBuilder.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>If this is null, the <ph id="ph1">&lt;see cref="T:System.Globalization.CultureInfo" /&gt;</ph> for the current thread is used.</source>
          <target state="translated">如果这是 NULL，则使用当前线程的 <ph id="ph1">&lt;see cref="T:System.Globalization.CultureInfo" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ConstructorBuilder.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>Dynamically invokes the constructor reflected by this instance with the specified arguments, under the constraints of the specified <ph id="ph1">&lt;see langword="Binder" /&gt;</ph>.</source>
          <target state="translated">在指定 <ph id="ph1">&lt;see langword="Binder" /&gt;</ph> 的约束下，用指定的参数动态调用此实例反映的构造函数。</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ConstructorBuilder.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>An instance of the class associated with the constructor.</source>
          <target state="translated">与构造函数关联的类的实例。</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ConstructorBuilder.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>The number, type, and order of elements in the parameters array should be identical to the number, type, and order of parameters for the constructor reflected by this instance.</source>
          <target state="translated">数量、 类型和参数数组中的元素的顺序应等于数量、 类型和此实例反射的构造函数的参数顺序。</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ConstructorBuilder.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>Before calling the constructor, <ph id="ph1">`Invoke`</ph> ensures that the caller has access permission, and that the parameters are of the correct number, order and type.</source>
          <target state="translated">在调用构造函数中之前,<ph id="ph1">`Invoke`</ph>可确保调用方具有访问权限，以及参数是否正确数目、 顺序和类型。</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ConstructorBuilder.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>Access restrictions are ignored for fully-trusted code.</source>
          <target state="translated">访问限制会忽略完全受信任的代码。</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ConstructorBuilder.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>That is, private constructors, methods, fields, and properties can be accessed and invoked using Reflection whenever the code is fully trusted.</source>
          <target state="translated">即私有构造函数、 方法、 字段和属性可以访问和使用反射，只要完全受信任代码调用。</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ConstructorBuilder.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>This method is not currently supported.</source>
          <target state="translated">目前尚不支持此方法。</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ConstructorBuilder.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>You can retrieve the constructor using <ph id="ph1">&lt;see cref="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" /&gt;</ph> and call <ph id="ph2">&lt;see cref="M:System.Reflection.ConstructorInfo.Invoke(System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)" /&gt;</ph> on the returned <ph id="ph3">&lt;see cref="T:System.Reflection.ConstructorInfo" /&gt;</ph>.</source>
          <target state="translated">可以使用 <ph id="ph1">&lt;see cref="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" /&gt;</ph> 检索构造函数，并对返回的 <ph id="ph2">&lt;see cref="M:System.Reflection.ConstructorInfo.Invoke(System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)" /&gt;</ph> 调用 <ph id="ph3">&lt;see cref="T:System.Reflection.ConstructorInfo" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ConstructorBuilder.IsDefined(System.Type,System.Boolean)">
          <source>A custom attribute type.</source>
          <target state="translated">自定义属性类型。</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ConstructorBuilder.IsDefined(System.Type,System.Boolean)">
          <source>Controls inheritance of custom attributes from base classes.</source>
          <target state="translated">基类中自定义属性的控件继承。</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ConstructorBuilder.IsDefined(System.Type,System.Boolean)">
          <source>This parameter is ignored.</source>
          <target state="translated">忽略此参数。</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ConstructorBuilder.IsDefined(System.Type,System.Boolean)">
          <source>Checks if the specified custom attribute type is defined.</source>
          <target state="translated">检查是否定义了指定的自定义属性类型。</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ConstructorBuilder.IsDefined(System.Type,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the specified custom attribute type is defined; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">如果定义了指定的自定义属性类型，则为 <ph id="ph1">&lt;see langword="true" /&gt;</ph>；否则为 <ph id="ph2">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ConstructorBuilder.IsDefined(System.Type,System.Boolean)">
          <source>See the metadata specification for details on how to format <ph id="ph1">`binaryAttribute`</ph>.</source>
          <target state="translated">请参阅上设置格式的方式的详细信息的元数据规范<ph id="ph1">`binaryAttribute`</ph>。</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ConstructorBuilder.IsDefined(System.Type,System.Boolean)">
          <source>This method is not currently supported.</source>
          <target state="translated">目前尚不支持此方法。</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ConstructorBuilder.IsDefined(System.Type,System.Boolean)">
          <source>You can retrieve the constructor using <ph id="ph1">&lt;see cref="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" /&gt;</ph> and call <ph id="ph2">&lt;see cref="M:System.Reflection.MemberInfo.IsDefined(System.Type,System.Boolean)" /&gt;</ph> on the returned <ph id="ph3">&lt;see cref="T:System.Reflection.ConstructorInfo" /&gt;</ph>.</source>
          <target state="translated">可以使用 <ph id="ph1">&lt;see cref="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" /&gt;</ph> 检索构造函数，并对返回的 <ph id="ph2">&lt;see cref="M:System.Reflection.MemberInfo.IsDefined(System.Type,System.Boolean)" /&gt;</ph> 调用 <ph id="ph3">&lt;see cref="T:System.Reflection.ConstructorInfo" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.ConstructorBuilder.MethodHandle">
          <source>Retrieves the internal handle for the method.</source>
          <target state="translated">检索此方法的内部句柄。</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.ConstructorBuilder.MethodHandle">
          <source>Use this handle to access the underlying metadata handle.</source>
          <target state="translated">使用此句柄来访问基础元数据句柄。</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.ConstructorBuilder.MethodHandle">
          <source>Returns the internal handle for the method.</source>
          <target state="translated">返回此方法的内部句柄。</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.ConstructorBuilder.MethodHandle">
          <source>Use this handle to access the underlying metadata handle.</source>
          <target state="translated">使用此句柄来访问基础元数据句柄。</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.ConstructorBuilder.MethodHandle">
          <source>This property is not supported on this class.</source>
          <target state="translated">此类不支持此属性。</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.ConstructorBuilder.Module">
          <source>Gets the dynamic module in which this constructor is defined.</source>
          <target state="translated">获取在其中定义此构造函数的动态模块。</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.ConstructorBuilder.Module">
          <source>A <ph id="ph1">&lt;see cref="T:System.Reflection.Module" /&gt;</ph> object that represents the dynamic module in which this constructor is defined.</source>
          <target state="translated">一个 <ph id="ph1">&lt;see cref="T:System.Reflection.Module" /&gt;</ph> 对象，表示定义此构造函数的动态模块。</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.ConstructorBuilder.Module">
          <source>This property returns the same value as the <ph id="ph1">&lt;xref:System.Reflection.Emit.ConstructorBuilder.GetModule%2A&gt;</ph> method.</source>
          <target state="translated">此属性返回相同的值<ph id="ph1">&lt;xref:System.Reflection.Emit.ConstructorBuilder.GetModule%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.ConstructorBuilder.Name">
          <source>Retrieves the name of this constructor.</source>
          <target state="translated">检索此构造函数的名称。</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.ConstructorBuilder.Name">
          <source>Returns the name of this constructor.</source>
          <target state="translated">返回此构造函数的名称。</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.ConstructorBuilder.Name">
          <source>The following code sample illustrates the use of <ph id="ph1">`Name`</ph>.</source>
          <target state="translated">下面的代码示例演示如何使用<ph id="ph1">`Name`</ph>。</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.ConstructorBuilder.ReflectedType">
          <source>Holds a reference to the <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> object from which this object was obtained.</source>
          <target state="translated">保存对从中获取该对象的 <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> 对象的引用。</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.ConstructorBuilder.ReflectedType">
          <source>Returns the <ph id="ph1">&lt;see langword="Type" /&gt;</ph> object from which this object was obtained.</source>
          <target state="translated">返回从中获取该对象的 <ph id="ph1">&lt;see langword="Type" /&gt;</ph> 对象。</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.ConstructorBuilder.ReflectedType">
          <source>A <ph id="ph1">&lt;xref:System.Reflection.Emit.ConstructorBuilder&gt;</ph> object represents a constructor on a particular class.</source>
          <target state="translated">A<ph id="ph1">&lt;xref:System.Reflection.Emit.ConstructorBuilder&gt;</ph>对象表示特定类的构造函数。</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.ConstructorBuilder.ReflectedType">
          <source>In order to obtain a <ph id="ph1">&lt;xref:System.Reflection.ConstructorInfo&gt;</ph> object, the <ph id="ph2">&lt;xref:System.Type&gt;</ph> object that represents the class that supports the constructor is queried.</source>
          <target state="translated">为了获取<ph id="ph1">&lt;xref:System.Reflection.ConstructorInfo&gt;</ph>对象，<ph id="ph2">&lt;xref:System.Type&gt;</ph>查询表示支持构造函数的类的对象。</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.ConstructorBuilder.ReflectedType">
          <source>This property holds a reference to that <ph id="ph1">&lt;xref:System.Type&gt;</ph> object.</source>
          <target state="translated">此属性包含对程序的引用<ph id="ph1">&lt;xref:System.Type&gt;</ph>对象。</target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.ConstructorBuilder.ReturnType">
          <source>Gets <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">获取 <ph id="ph1">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.ConstructorBuilder.ReturnType">
          <source>Returns <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">返回 <ph id="ph1">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.ConstructorBuilder.ReturnType">
          <source>This property might be removed in a future version.</source>
          <target state="translated">可能的未来版本中移除此属性。</target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve" uid="T:System.Reflection.Emit.ConstructorBuilder">
          <source>Sets a custom attribute.</source>
          <target state="translated">设置自定义属性。</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ConstructorBuilder.SetCustomAttribute(System.Reflection.Emit.CustomAttributeBuilder)">
          <source>An instance of a helper class to define the custom attribute.</source>
          <target state="translated">用于定义自定义属性的帮助程序类的一个实例。</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ConstructorBuilder.SetCustomAttribute(System.Reflection.Emit.CustomAttributeBuilder)">
          <source>Set a custom attribute using a custom attribute builder.</source>
          <target state="translated">使用自定义属性生成器设置自定义属性。</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ConstructorBuilder.SetCustomAttribute(System.Reflection.Emit.CustomAttributeBuilder)">
          <source>The following code sample illustrates the use of <ph id="ph1">`SetCustomAttribute`</ph> of the context of a <ph id="ph2">&lt;xref:System.Reflection.Emit.ConstructorBuilder&gt;</ph>, passing a <ph id="ph3">&lt;xref:System.Reflection.Emit.CustomAttributeBuilder&gt;</ph>.</source>
          <target state="translated">下面的代码示例演示如何使用<ph id="ph1">`SetCustomAttribute`</ph>的上下文的<ph id="ph2">&lt;xref:System.Reflection.Emit.ConstructorBuilder&gt;</ph>，并传递<ph id="ph3">&lt;xref:System.Reflection.Emit.CustomAttributeBuilder&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ConstructorBuilder.SetCustomAttribute(System.Reflection.Emit.CustomAttributeBuilder)">
          <source><ph id="ph1">&lt;paramref name="customBuilder" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="customBuilder" /&gt;</ph> 为 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ConstructorBuilder.SetCustomAttribute(System.Reflection.ConstructorInfo,System.Byte[])">
          <source>The constructor for the custom attribute.</source>
          <target state="translated">自定义属性的构造函数。</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ConstructorBuilder.SetCustomAttribute(System.Reflection.ConstructorInfo,System.Byte[])">
          <source>A byte blob representing the attributes.</source>
          <target state="translated">表示属性的字节 blob。</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ConstructorBuilder.SetCustomAttribute(System.Reflection.ConstructorInfo,System.Byte[])">
          <source>Set a custom attribute using a specified custom attribute blob.</source>
          <target state="translated">使用指定的自定义属性 blob 设置自定义属性。</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ConstructorBuilder.SetCustomAttribute(System.Reflection.ConstructorInfo,System.Byte[])">
          <source>See the metadata specification in the ECMA Partition II documentation for details on how to format <ph id="ph1">`binaryAttribute`</ph>.</source>
          <target state="translated">有关如何设置格式，请参阅 ECMA 第 ii 部分文档，有关详细信息中的元数据规范<ph id="ph1">`binaryAttribute`</ph>。</target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ConstructorBuilder.SetCustomAttribute(System.Reflection.ConstructorInfo,System.Byte[])">
          <source>The documentation is available online; see <bpt id="p1">[</bpt>ECMA C# and Common Language Infrastructure Standards<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=99212)</ept> on MSDN and <bpt id="p2">[</bpt>Standard ECMA-335 - Common Language Infrastructure (CLI)<ept id="p2">](http://go.microsoft.com/fwlink/?LinkID=65552)</ept> on the Ecma International Web site.</source>
          <target state="translated">可联机获取该文档；请参阅 MSDN 上的 <bpt id="p1">[</bpt>ECMA C# 和公共语言基础结构标准<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=99212)</ept>和 Ecma International 网站上的<bpt id="p2">[</bpt>标准 ECMA-335 - 公共语言基础结构 (CLI)<ept id="p2">](http://go.microsoft.com/fwlink/?LinkID=65552)</ept>。</target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ConstructorBuilder.SetCustomAttribute(System.Reflection.ConstructorInfo,System.Byte[])">
          <source>The following code sample illustrates the use of <ph id="ph1">`SetCustomAttribute`</ph> of the context of a <ph id="ph2">&lt;xref:System.Reflection.Emit.ConstructorBuilder&gt;</ph>, passing a byte blob.</source>
          <target state="translated">下面的代码示例演示如何使用<ph id="ph1">`SetCustomAttribute`</ph>的上下文的<ph id="ph2">&lt;xref:System.Reflection.Emit.ConstructorBuilder&gt;</ph>，传递的字节 blob。</target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ConstructorBuilder.SetCustomAttribute(System.Reflection.ConstructorInfo,System.Byte[])">
          <source><ph id="ph1">&lt;paramref name="con" /&gt;</ph> or <ph id="ph2">&lt;paramref name="binaryAttribute" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="con" /&gt;</ph> 或 <ph id="ph2">&lt;paramref name="binaryAttribute" /&gt;</ph> 为 <ph id="ph3">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ConstructorBuilder.SetImplementationFlags(System.Reflection.MethodImplAttributes)">
          <source>The method implementation flags.</source>
          <target state="translated">方法实现标志。</target>       </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ConstructorBuilder.SetImplementationFlags(System.Reflection.MethodImplAttributes)">
          <source>Sets the method implementation flags for this constructor.</source>
          <target state="translated">设置此构造函数的方法实现标志。</target>       </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ConstructorBuilder.SetImplementationFlags(System.Reflection.MethodImplAttributes)">
          <source>The following code sample illustrates the use of <ph id="ph1">`SetImplementationFlags`</ph>.</source>
          <target state="translated">下面的代码示例演示如何使用<ph id="ph1">`SetImplementationFlags`</ph>。</target>       </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ConstructorBuilder.SetImplementationFlags(System.Reflection.MethodImplAttributes)">
          <source>The containing type has been created using <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph>.</source>
          <target state="translated">已使用 <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph> 创建包含类型。</target>       </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ConstructorBuilder.SetMethodBody(System.Byte[],System.Int32,System.Byte[],System.Collections.Generic.IEnumerable{System.Reflection.Emit.ExceptionHandler},System.Collections.Generic.IEnumerable{System.Int32})">
          <source>An array that contains valid MSIL instructions.</source>
          <target state="translated">包含有效 MSIL 指令的数组。</target>       </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ConstructorBuilder.SetMethodBody(System.Byte[],System.Int32,System.Byte[],System.Collections.Generic.IEnumerable{System.Reflection.Emit.ExceptionHandler},System.Collections.Generic.IEnumerable{System.Int32})">
          <source>The maximum stack evaluation depth.</source>
          <target state="translated">最大堆栈评估深度。</target>       </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ConstructorBuilder.SetMethodBody(System.Byte[],System.Int32,System.Byte[],System.Collections.Generic.IEnumerable{System.Reflection.Emit.ExceptionHandler},System.Collections.Generic.IEnumerable{System.Int32})">
          <source>An array of bytes that contain the serialized local variable structure.</source>
          <target state="translated">包含序列化本地变量结构的字节数组。</target>       </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ConstructorBuilder.SetMethodBody(System.Byte[],System.Int32,System.Byte[],System.Collections.Generic.IEnumerable{System.Reflection.Emit.ExceptionHandler},System.Collections.Generic.IEnumerable{System.Int32})">
          <source>Specify <ph id="ph1">&lt;see langword="null" /&gt;</ph> if the constructor has no local variables.</source>
          <target state="translated">如果构造函数没有局部变量，请指定 <ph id="ph1">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ConstructorBuilder.SetMethodBody(System.Byte[],System.Int32,System.Byte[],System.Collections.Generic.IEnumerable{System.Reflection.Emit.ExceptionHandler},System.Collections.Generic.IEnumerable{System.Int32})">
          <source>A collection that contains the exception handlers for the constructor.</source>
          <target state="translated">包含此构造函数的异常处理程序的集合。</target>       </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ConstructorBuilder.SetMethodBody(System.Byte[],System.Int32,System.Byte[],System.Collections.Generic.IEnumerable{System.Reflection.Emit.ExceptionHandler},System.Collections.Generic.IEnumerable{System.Int32})">
          <source>Specify <ph id="ph1">&lt;see langword="null" /&gt;</ph> if the constructor has no exception handlers.</source>
          <target state="translated">如果构造函数没有异常管理器，请指定 <ph id="ph1">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ConstructorBuilder.SetMethodBody(System.Byte[],System.Int32,System.Byte[],System.Collections.Generic.IEnumerable{System.Reflection.Emit.ExceptionHandler},System.Collections.Generic.IEnumerable{System.Int32})">
          <source>A collection of values that represent offsets in <bpt id="p1">&lt;c&gt;</bpt>il<ept id="p1">&lt;/c&gt;</ept>, each of which specifies the beginning of a token that may be modified.</source>
          <target state="translated">表示 <bpt id="p1">&lt;c&gt;</bpt>il<ept id="p1">&lt;/c&gt;</ept> 中的偏移量的值的集合，其中的每个值指定可以修改的令牌起始点。</target>       </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ConstructorBuilder.SetMethodBody(System.Byte[],System.Int32,System.Byte[],System.Collections.Generic.IEnumerable{System.Reflection.Emit.ExceptionHandler},System.Collections.Generic.IEnumerable{System.Int32})">
          <source>Specify <ph id="ph1">&lt;see langword="null" /&gt;</ph> if the constructor has no tokens that have to be modified.</source>
          <target state="translated">如果构造函数没有必须修改的标记，请指定 <ph id="ph1">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ConstructorBuilder.SetMethodBody(System.Byte[],System.Int32,System.Byte[],System.Collections.Generic.IEnumerable{System.Reflection.Emit.ExceptionHandler},System.Collections.Generic.IEnumerable{System.Int32})">
          <source>Creates the body of the constructor by using a specified byte array of Microsoft intermediate language (MSIL) instructions.</source>
          <target state="translated">通过使用指定的 Microsoft 中间语言 (MSIL) 指令字节数组创建构造函数的主体。</target>       </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ConstructorBuilder.SetMethodBody(System.Byte[],System.Int32,System.Byte[],System.Collections.Generic.IEnumerable{System.Reflection.Emit.ExceptionHandler},System.Collections.Generic.IEnumerable{System.Int32})">
          <source><ph id="ph1">&lt;paramref name="il" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="il" /&gt;</ph> 为 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ConstructorBuilder.SetMethodBody(System.Byte[],System.Int32,System.Byte[],System.Collections.Generic.IEnumerable{System.Reflection.Emit.ExceptionHandler},System.Collections.Generic.IEnumerable{System.Int32})">
          <source><ph id="ph1">&lt;paramref name="maxStack" /&gt;</ph> is negative.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="maxStack" /&gt;</ph> 为负数。</target>       </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ConstructorBuilder.SetMethodBody(System.Byte[],System.Int32,System.Byte[],System.Collections.Generic.IEnumerable{System.Reflection.Emit.ExceptionHandler},System.Collections.Generic.IEnumerable{System.Int32})">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ConstructorBuilder.SetMethodBody(System.Byte[],System.Int32,System.Byte[],System.Collections.Generic.IEnumerable{System.Reflection.Emit.ExceptionHandler},System.Collections.Generic.IEnumerable{System.Int32})">
          <source>One of <ph id="ph1">&lt;paramref name="exceptionHandlers" /&gt;</ph> specifies an offset outside of <ph id="ph2">&lt;paramref name="il" /&gt;</ph>.</source>
          <target state="translated">其中一个 <ph id="ph1">&lt;paramref name="exceptionHandlers" /&gt;</ph> 指定 <ph id="ph2">&lt;paramref name="il" /&gt;</ph> 外部的偏移量。</target>       </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ConstructorBuilder.SetMethodBody(System.Byte[],System.Int32,System.Byte[],System.Collections.Generic.IEnumerable{System.Reflection.Emit.ExceptionHandler},System.Collections.Generic.IEnumerable{System.Int32})">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ConstructorBuilder.SetMethodBody(System.Byte[],System.Int32,System.Byte[],System.Collections.Generic.IEnumerable{System.Reflection.Emit.ExceptionHandler},System.Collections.Generic.IEnumerable{System.Int32})">
          <source>One of <ph id="ph1">&lt;paramref name="tokenFixups" /&gt;</ph> specifies an offset that is outside the <ph id="ph2">&lt;paramref name="il" /&gt;</ph> array.</source>
          <target state="translated">其中一个 <ph id="ph1">&lt;paramref name="tokenFixups" /&gt;</ph> 指定 <ph id="ph2">&lt;paramref name="il" /&gt;</ph> 数组外部的偏移量。</target>       </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ConstructorBuilder.SetMethodBody(System.Byte[],System.Int32,System.Byte[],System.Collections.Generic.IEnumerable{System.Reflection.Emit.ExceptionHandler},System.Collections.Generic.IEnumerable{System.Int32})">
          <source>The containing type was previously created using the <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph> method.</source>
          <target state="translated">该包含类型是以前使用 <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph> 方法创建的。</target>       </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ConstructorBuilder.SetMethodBody(System.Byte[],System.Int32,System.Byte[],System.Collections.Generic.IEnumerable{System.Reflection.Emit.ExceptionHandler},System.Collections.Generic.IEnumerable{System.Int32})">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ConstructorBuilder.SetMethodBody(System.Byte[],System.Int32,System.Byte[],System.Collections.Generic.IEnumerable{System.Reflection.Emit.ExceptionHandler},System.Collections.Generic.IEnumerable{System.Int32})">
          <source>This method was called previously on this <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.ConstructorBuilder" /&gt;</ph> object.</source>
          <target state="translated">之前已在此 <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.ConstructorBuilder" /&gt;</ph> 对象上调用过此方法。</target>       </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ConstructorBuilder.SetSymCustomAttribute(System.String,System.Byte[])">
          <source>The name of the custom attribute.</source>
          <target state="translated">自定义属性的名称。</target>       </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ConstructorBuilder.SetSymCustomAttribute(System.String,System.Byte[])">
          <source>The value of the custom attribute.</source>
          <target state="translated">自定义特性的值。</target>       </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ConstructorBuilder.SetSymCustomAttribute(System.String,System.Byte[])">
          <source>Sets this constructor's custom attribute associated with symbolic information.</source>
          <target state="translated">设置此构造函数与符号信息关联的自定义属性。</target>       </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ConstructorBuilder.SetSymCustomAttribute(System.String,System.Byte[])">
          <source>The following code sample illustrates the use of <ph id="ph1">`SetSymCustomAttributes`</ph>.</source>
          <target state="translated">下面的代码示例演示如何使用<ph id="ph1">`SetSymCustomAttributes`</ph>。</target>       </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ConstructorBuilder.SetSymCustomAttribute(System.String,System.Byte[])">
          <source>The containing type has been created using <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph>.</source>
          <target state="translated">已使用 <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph> 创建包含类型。</target>       </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ConstructorBuilder.SetSymCustomAttribute(System.String,System.Byte[])">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ConstructorBuilder.SetSymCustomAttribute(System.String,System.Byte[])">
          <source>The module does not have a symbol writer defined.</source>
          <target state="translated">模块没有定义符号编写器。</target>       </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ConstructorBuilder.SetSymCustomAttribute(System.String,System.Byte[])">
          <source>For example, the module is not a debug module.</source>
          <target state="translated">例如，模块不是调试模块。</target>       </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.ConstructorBuilder.Signature">
          <source>Retrieves the signature of the field in the form of a string.</source>
          <target state="translated">检索字符串形式的字段的签名。</target>       </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.ConstructorBuilder.Signature">
          <source>Returns the signature of the field.</source>
          <target state="translated">返回字段的签名。</target>       </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ConstructorBuilder.System#Runtime#InteropServices#_ConstructorBuilder#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>Reserved for future use.</source>
          <target state="translated">留待将来使用。</target>       </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ConstructorBuilder.System#Runtime#InteropServices#_ConstructorBuilder#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>Must be IID_NULL.</source>
          <target state="translated">必须为 IID_NULL。</target>       </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ConstructorBuilder.System#Runtime#InteropServices#_ConstructorBuilder#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>Passed-in array of names to be mapped.</source>
          <target state="translated">要映射的名称的传入数组。</target>       </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ConstructorBuilder.System#Runtime#InteropServices#_ConstructorBuilder#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>Count of the names to be mapped.</source>
          <target state="translated">要映射的名称的计数。</target>       </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ConstructorBuilder.System#Runtime#InteropServices#_ConstructorBuilder#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>The locale context in which to interpret the names.</source>
          <target state="translated">要在其中解释名称的区域设置上下文。</target>       </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ConstructorBuilder.System#Runtime#InteropServices#_ConstructorBuilder#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>Caller-allocated array which receives the IDs corresponding to the names.</source>
          <target state="translated">调用方分配的数组，用于接收与名称对应的 ID。</target>       </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ConstructorBuilder.System#Runtime#InteropServices#_ConstructorBuilder#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>Maps a set of names to a corresponding set of dispatch identifiers.</source>
          <target state="translated">将一组名称映射为对应的一组调度标识符。</target>       </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ConstructorBuilder.System#Runtime#InteropServices#_ConstructorBuilder#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>This method is for access to managed classes from unmanaged code, and should not be called from managed code.</source>
          <target state="translated">此方法用于访问托管类从非托管代码，不应从托管代码调用。</target>       </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ConstructorBuilder.System#Runtime#InteropServices#_ConstructorBuilder#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>For more information about <ph id="ph1">`IDispatch::GetIDsOfNames`</ph>, see the MSDN Library.</source>
          <target state="translated">有关详细信息<ph id="ph1">`IDispatch::GetIDsOfNames`</ph>，请参阅 MSDN 库。</target>       </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ConstructorBuilder.System#Runtime#InteropServices#_ConstructorBuilder#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>Late-bound access using the COM <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> interface is not supported.</source>
          <target state="translated">不支持使用 COM <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> 接口的后期绑定访问。</target>       </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ConstructorBuilder.System#Runtime#InteropServices#_ConstructorBuilder#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)">
          <source>The type information to return.</source>
          <target state="translated">要返回的类型信息。</target>       </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ConstructorBuilder.System#Runtime#InteropServices#_ConstructorBuilder#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)">
          <source>The locale identifier for the type information.</source>
          <target state="translated">类型信息的区域设置标识符。</target>       </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ConstructorBuilder.System#Runtime#InteropServices#_ConstructorBuilder#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)">
          <source>Receives a pointer to the requested type information object.</source>
          <target state="translated">接收一个指针，指向请求的类型信息对象。</target>       </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ConstructorBuilder.System#Runtime#InteropServices#_ConstructorBuilder#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)">
          <source>Retrieves the type information for an object, which can then be used to get the type information for an interface.</source>
          <target state="translated">检索对象的类型信息，然后可以使用该信息获取接口的类型信息。</target>       </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ConstructorBuilder.System#Runtime#InteropServices#_ConstructorBuilder#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)">
          <source>This method is for access to managed classes from unmanaged code, and should not be called from managed code.</source>
          <target state="translated">此方法用于访问托管类从非托管代码，不应从托管代码调用。</target>       </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ConstructorBuilder.System#Runtime#InteropServices#_ConstructorBuilder#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)">
          <source>For more information about <ph id="ph1">`IDispatch::GetTypeInfo`</ph>, see the MSDN Library.</source>
          <target state="translated">有关详细信息<ph id="ph1">`IDispatch::GetTypeInfo`</ph>，请参阅 MSDN 库。</target>       </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ConstructorBuilder.System#Runtime#InteropServices#_ConstructorBuilder#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)">
          <source>Late-bound access using the COM <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> interface is not supported.</source>
          <target state="translated">不支持使用 COM <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> 接口的后期绑定访问。</target>       </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ConstructorBuilder.System#Runtime#InteropServices#_ConstructorBuilder#GetTypeInfoCount(System.UInt32@)">
          <source>Points to a location that receives the number of type information interfaces provided by the object.</source>
          <target state="translated">指向一个位置，该位置接收对象提供的类型信息接口的数量。</target>       </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ConstructorBuilder.System#Runtime#InteropServices#_ConstructorBuilder#GetTypeInfoCount(System.UInt32@)">
          <source>Retrieves the number of type information interfaces that an object provides (either 0 or 1).</source>
          <target state="translated">检索对象提供的类型信息接口的数量（0 或 1）。</target>       </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ConstructorBuilder.System#Runtime#InteropServices#_ConstructorBuilder#GetTypeInfoCount(System.UInt32@)">
          <source>This method is for access to managed classes from unmanaged code, and should not be called from managed code.</source>
          <target state="translated">此方法用于访问托管类从非托管代码，不应从托管代码调用。</target>       </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ConstructorBuilder.System#Runtime#InteropServices#_ConstructorBuilder#GetTypeInfoCount(System.UInt32@)">
          <source>For more information about <ph id="ph1">`IDispatch::GetTypeInfoCount`</ph>, see the MSDN Library.</source>
          <target state="translated">有关详细信息<ph id="ph1">`IDispatch::GetTypeInfoCount`</ph>，请参阅 MSDN 库。</target>       </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ConstructorBuilder.System#Runtime#InteropServices#_ConstructorBuilder#GetTypeInfoCount(System.UInt32@)">
          <source>Late-bound access using the COM <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> interface is not supported.</source>
          <target state="translated">不支持使用 COM <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> 接口的后期绑定访问。</target>       </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ConstructorBuilder.System#Runtime#InteropServices#_ConstructorBuilder#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Identifies the member.</source>
          <target state="translated">标识成员。</target>       </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ConstructorBuilder.System#Runtime#InteropServices#_ConstructorBuilder#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Reserved for future use.</source>
          <target state="translated">留待将来使用。</target>       </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ConstructorBuilder.System#Runtime#InteropServices#_ConstructorBuilder#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Must be IID_NULL.</source>
          <target state="translated">必须为 IID_NULL。</target>       </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ConstructorBuilder.System#Runtime#InteropServices#_ConstructorBuilder#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>The locale context in which to interpret arguments.</source>
          <target state="translated">要在其中解释参数的区域设置上下文。</target>       </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ConstructorBuilder.System#Runtime#InteropServices#_ConstructorBuilder#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Flags describing the context of the call.</source>
          <target state="translated">描述调用的上下文的标志。</target>       </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ConstructorBuilder.System#Runtime#InteropServices#_ConstructorBuilder#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Pointer to a structure containing an array of arguments, an array of argument DISPIDs for named arguments, and counts for the number of elements in the arrays.</source>
          <target state="translated">指向一个结构的指针，该结构包含一个自变量数组、一个命名自变量的 DISPID 自变量数组和数组中元素数的计数。</target>       </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ConstructorBuilder.System#Runtime#InteropServices#_ConstructorBuilder#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Pointer to the location where the result is to be stored.</source>
          <target state="translated">指向要存储结果的位置的指针。</target>       </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ConstructorBuilder.System#Runtime#InteropServices#_ConstructorBuilder#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Pointer to a structure that contains exception information.</source>
          <target state="translated">指向一个包含异常信息的结构的指针。</target>       </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ConstructorBuilder.System#Runtime#InteropServices#_ConstructorBuilder#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>The index of the first argument that has an error.</source>
          <target state="translated">第一个出错自变量的索引。</target>       </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ConstructorBuilder.System#Runtime#InteropServices#_ConstructorBuilder#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Provides access to properties and methods exposed by an object.</source>
          <target state="translated">提供对某一对象公开的属性和方法的访问。</target>       </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ConstructorBuilder.System#Runtime#InteropServices#_ConstructorBuilder#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>This method is for access to managed classes from unmanaged code, and should not be called from managed code.</source>
          <target state="translated">此方法用于访问托管类从非托管代码，不应从托管代码调用。</target>       </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ConstructorBuilder.System#Runtime#InteropServices#_ConstructorBuilder#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>For more information about <ph id="ph1">`IDispatch::Invoke`</ph>, see the MSDN Library.</source>
          <target state="translated">有关详细信息<ph id="ph1">`IDispatch::Invoke`</ph>，请参阅 MSDN 库。</target>       </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ConstructorBuilder.System#Runtime#InteropServices#_ConstructorBuilder#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Late-bound access using the COM <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> interface is not supported.</source>
          <target state="translated">不支持使用 COM <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> 接口的后期绑定访问。</target>       </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ConstructorBuilder.ToString">
          <source>Returns this <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.ConstructorBuilder" /&gt;</ph> instance as a <ph id="ph2">&lt;see cref="T:System.String" /&gt;</ph>.</source>
          <target state="translated">将此 <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.ConstructorBuilder" /&gt;</ph> 实例作为 <ph id="ph2">&lt;see cref="T:System.String" /&gt;</ph> 返回。</target>       </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ConstructorBuilder.ToString">
          <source>Returns a <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> containing the name, attributes, and exceptions of this constructor, followed by the current Microsoft intermediate language (MSIL) stream.</source>
          <target state="translated">返回包含此构造函数的名称、属性和异常的 <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph>，后跟当前 Microsoft 中间语言 (MSIL) 流。</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>