<Type Name="ILGenerator" FullName="System.Reflection.Emit.ILGenerator">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="f555c749f770021cd4238861db39d8970da03e78" />
    <Meta Name="ms.sourcegitcommit" Value="5a49536d99d2d0b54e4cb7280870903e043272df" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-CN" />
    <Meta Name="ms.lasthandoff" Value="07/03/2018" />
    <Meta Name="ms.locfileid" Value="37474499" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class ILGenerator : System.Runtime.InteropServices._ILGenerator" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi beforefieldinit ILGenerator extends System.Object implements class System.Runtime.InteropServices._ILGenerator" />
  <TypeSignature Language="DocId" Value="T:System.Reflection.Emit.ILGenerator" />
  <TypeSignature Language="VB.NET" Value="Public Class ILGenerator&#xA;Implements _ILGenerator" />
  <TypeSignature Language="C++ CLI" Value="public ref class ILGenerator : System::Runtime::InteropServices::_ILGenerator" />
  <TypeSignature Language="F#" Value="type ILGenerator = class&#xA;    interface _ILGenerator" />
  <AssemblyInfo>
    <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.3.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Runtime.InteropServices._ILGenerator</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.None)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComDefaultInterface(typeof(System.Runtime.InteropServices._ILGenerator))</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Generates Microsoft intermediate language (MSIL) instructions.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Reflection.Emit.ILGenerator> 用于在动态程序集中生成方法体的方法和构造函数 (由<xref:System.Reflection.Emit.MethodBuilder>和<xref:System.Reflection.Emit.ConstructorBuilder>类) 和独立的动态方法 (由<xref:System.Reflection.Emit.DynamicMethod>类)。 若要获取<xref:System.Reflection.Emit.ILGenerator>，使用<xref:System.Reflection.Emit.ConstructorBuilder.GetILGenerator%2A?displayProperty=nameWithType>， <xref:System.Reflection.Emit.DynamicMethod.GetILGenerator%2A?displayProperty=nameWithType>，和<xref:System.Reflection.Emit.MethodBuilder.GetILGenerator%2A?displayProperty=nameWithType>方法。  
  
 MSIL 用作实时 (JIT) 编译器的输入。  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="BeginCatchBlock">
      <MemberSignature Language="C#" Value="public virtual void BeginCatchBlock (Type exceptionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void BeginCatchBlock(class System.Type exceptionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ILGenerator.BeginCatchBlock(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub BeginCatchBlock (exceptionType As Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void BeginCatchBlock(Type ^ exceptionType);" />
      <MemberSignature Language="F#" Value="abstract member BeginCatchBlock : Type -&gt; unit&#xA;override this.BeginCatchBlock : Type -&gt; unit" Usage="iLGenerator.BeginCatchBlock exceptionType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="exceptionType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="exceptionType">The <see cref="T:System.Type" /> object that represents the exception.</param>
        <summary>Begins a catch block.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 发出到当前的异常块的末尾的分支指令。  
  
> [!NOTE]
>  如果筛选器异常块返回`constant exception_execute_handler`（请参阅公共语言基础结构指令集的文档），为参数`BeginCatchBlock`未选中。  
  
   
  
## Examples  
 下面的代码示例演示的上下文用法`BeginCatchBlock`方法。  
  
 [!code-cpp[System.Reflection.Emit.ILGenerator.ThrowException Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.ThrowException Example/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit.ILGenerator.ThrowException Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.ThrowException Example/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit.ILGenerator.ThrowException Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.ThrowException Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">The catch block is within a filtered exception.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="exceptionType" /> is <see langword="null" />, and the exception filter block has not returned a value that indicates that finally blocks should be run until this catch block is located.</exception>
        <exception cref="T:System.NotSupportedException">The Microsoft intermediate language (MSIL) being generated is not currently in an exception block.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginExceptFilterBlock">
      <MemberSignature Language="C#" Value="public virtual void BeginExceptFilterBlock ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void BeginExceptFilterBlock() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ILGenerator.BeginExceptFilterBlock" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub BeginExceptFilterBlock ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void BeginExceptFilterBlock();" />
      <MemberSignature Language="F#" Value="abstract member BeginExceptFilterBlock : unit -&gt; unit&#xA;override this.BeginExceptFilterBlock : unit -&gt; unit" Usage="iLGenerator.BeginExceptFilterBlock " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Begins an exception block for a filtered exception.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 发出到当前的异常块的末尾的分支指令。  
  
 如果当前<xref:System.Reflection.Emit.ILGenerator>与关联<xref:System.Reflection.Emit.DynamicMethod>不支持对象，发出筛选后的异常块。 <xref:System.Reflection.Emit.DynamicILInfo> 可用于构造动态方法使用筛选异常块。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">The Microsoft intermediate language (MSIL) being generated is not currently in an exception block.  -or-  This <see cref="T:System.Reflection.Emit.ILGenerator" /> belongs to a <see cref="T:System.Reflection.Emit.DynamicMethod" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginExceptionBlock">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.Emit.Label BeginExceptionBlock ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Reflection.Emit.Label BeginExceptionBlock() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ILGenerator.BeginExceptionBlock" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function BeginExceptionBlock () As Label" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Emit::Label BeginExceptionBlock();" />
      <MemberSignature Language="F#" Value="abstract member BeginExceptionBlock : unit -&gt; System.Reflection.Emit.Label&#xA;override this.BeginExceptionBlock : unit -&gt; System.Reflection.Emit.Label" Usage="iLGenerator.BeginExceptionBlock " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.Label</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Begins an exception block for a non-filtered exception.</summary>
        <returns>The label for the end of the block. This will leave you in the correct place to execute finally blocks or to finish the try.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 创建异常块记录一些信息，而不会实际发出到流上的任何 Microsoft 中间语言 (MSIL)。  
  
   
  
## Examples  
 下面的代码示例演示的上下文用法`BeginExceptionBlock`方法。  
  
 [!code-cpp[System.Reflection.Emit.ILGenerator.ThrowException Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.ThrowException Example/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit.ILGenerator.ThrowException Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.ThrowException Example/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit.ILGenerator.ThrowException Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.ThrowException Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginFaultBlock">
      <MemberSignature Language="C#" Value="public virtual void BeginFaultBlock ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void BeginFaultBlock() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ILGenerator.BeginFaultBlock" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub BeginFaultBlock ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void BeginFaultBlock();" />
      <MemberSignature Language="F#" Value="abstract member BeginFaultBlock : unit -&gt; unit&#xA;override this.BeginFaultBlock : unit -&gt; unit" Usage="iLGenerator.BeginFaultBlock " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Begins an exception fault block in the Microsoft intermediate language (MSIL) stream.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果当前<xref:System.Reflection.Emit.ILGenerator>与关联<xref:System.Reflection.Emit.DynamicMethod>不支持对象，发出异常错误块。 <xref:System.Reflection.Emit.DynamicILInfo> 可用于构造使用异常错误块的动态方法。  
  
   
  
## Examples  
 下面的代码示例演示如何使用`BeginFaultBlock`。  
  
 [!code-cpp[ILGenerator_BeginFaultBlock#1](~/samples/snippets/cpp/VS_Snippets_CLR/ILGenerator_BeginFaultBlock/CPP/ilgenerator_beginfaultblock.cpp#1)]
 [!code-csharp[ILGenerator_BeginFaultBlock#1](~/samples/snippets/csharp/VS_Snippets_CLR/ILGenerator_BeginFaultBlock/CS/ilgenerator_beginfaultblock.cs#1)]
 [!code-vb[ILGenerator_BeginFaultBlock#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ILGenerator_BeginFaultBlock/VB/ilgenerator_beginfaultblock.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">The MSIL being generated is not currently in an exception block.  -or-  This <see cref="T:System.Reflection.Emit.ILGenerator" /> belongs to a <see cref="T:System.Reflection.Emit.DynamicMethod" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginFinallyBlock">
      <MemberSignature Language="C#" Value="public virtual void BeginFinallyBlock ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void BeginFinallyBlock() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ILGenerator.BeginFinallyBlock" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub BeginFinallyBlock ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void BeginFinallyBlock();" />
      <MemberSignature Language="F#" Value="abstract member BeginFinallyBlock : unit -&gt; unit&#xA;override this.BeginFinallyBlock : unit -&gt; unit" Usage="iLGenerator.BeginFinallyBlock " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Begins a finally block in the Microsoft intermediate language (MSIL) instruction stream.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下面的代码示例演示如何使用`BeginFinallyBlock`。  
  
 [!code-cpp[ILGenerator_BeginFinallyBlock_2#2](~/samples/snippets/cpp/VS_Snippets_CLR/ILGenerator_BeginFinallyBlock_2/CPP/ILGenerator_BeginFinallyBlock_2.cpp#2)]
 [!code-csharp[ILGenerator_BeginFinallyBlock_2#2](~/samples/snippets/csharp/VS_Snippets_CLR/ILGenerator_BeginFinallyBlock_2/CS/ilgenerator_beginfinallyblock_2.cs#2)]
 [!code-vb[ILGenerator_BeginFinallyBlock_2#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/ILGenerator_BeginFinallyBlock_2/VB/ilgenerator_beginfinallyblock_2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">The MSIL being generated is not currently in an exception block.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginScope">
      <MemberSignature Language="C#" Value="public virtual void BeginScope ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void BeginScope() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ILGenerator.BeginScope" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub BeginScope ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void BeginScope();" />
      <MemberSignature Language="F#" Value="abstract member BeginScope : unit -&gt; unit&#xA;override this.BeginScope : unit -&gt; unit" Usage="iLGenerator.BeginScope " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Begins a lexical scope.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用此方法来发出符号信息。 声明后的本地变量<xref:System.Reflection.Emit.ILGenerator.BeginScope%2A>直到相应范围<xref:System.Reflection.Emit.ILGenerator.EndScope%2A>调用。  
  
 如果当前<xref:System.Reflection.Emit.ILGenerator>与关联<xref:System.Reflection.Emit.DynamicMethod>对象，它不支持的符号化信息。  
  
   
  
## Examples  
 下面的代码示例演示如何使用`BeginScope`和`EndScope`。  
  
 [!code-cpp[ILGenerator_Begin_EndScope#2](~/samples/snippets/cpp/VS_Snippets_CLR/ILGenerator_Begin_EndScope/CPP/ilgenerator_begin_endscope.cpp#2)]
 [!code-csharp[ILGenerator_Begin_EndScope#2](~/samples/snippets/csharp/VS_Snippets_CLR/ILGenerator_Begin_EndScope/CS/ilgenerator_begin_endscope.cs#2)]
 [!code-vb[ILGenerator_Begin_EndScope#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/ILGenerator_Begin_EndScope/VB/ilgenerator_begin_endscope.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">This <see cref="T:System.Reflection.Emit.ILGenerator" /> belongs to a <see cref="T:System.Reflection.Emit.DynamicMethod" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="DeclareLocal">
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Declares a local variable.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DeclareLocal">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.Emit.LocalBuilder DeclareLocal (Type localType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Emit.LocalBuilder DeclareLocal(class System.Type localType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ILGenerator.DeclareLocal(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function DeclareLocal (localType As Type) As LocalBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Emit::LocalBuilder ^ DeclareLocal(Type ^ localType);" />
      <MemberSignature Language="F#" Value="abstract member DeclareLocal : Type -&gt; System.Reflection.Emit.LocalBuilder&#xA;override this.DeclareLocal : Type -&gt; System.Reflection.Emit.LocalBuilder" Usage="iLGenerator.DeclareLocal localType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.LocalBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="localType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="localType">A <see cref="T:System.Type" /> object that represents the type of the local variable.</param>
        <summary>Declares a local variable of the specified type.</summary>
        <returns>The declared local variable.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在当前词法范围内; 创建本地变量例如，如果代码中发出`for`循环 (`For` Visual Basic 中的循环)，变量的作用域是循环。  
  
 使用此重载创建的本地变量不固定。 若要创建固定的变量中以供使用非托管指针，请使用<xref:System.Reflection.Emit.ILGenerator.DeclareLocal%28System.Type%2CSystem.Boolean%29>方法重载。  
  
   
  
## Examples  
 下面的代码示例演示如何将`DeclareLocal`方法。 此代码的一个更大的代码示例摘自<xref:System.Reflection.Emit.LocalBuilder>类。  
  
 [!code-cpp[LocalBuilder_Sample_SetLocalSymInfo#2](~/samples/snippets/cpp/VS_Snippets_CLR/LocalBuilder_Sample_SetLocalSymInfo/CPP/localbuilder_sample_4.cpp#2)]
 [!code-csharp[LocalBuilder_Sample_SetLocalSymInfo#2](~/samples/snippets/csharp/VS_Snippets_CLR/LocalBuilder_Sample_SetLocalSymInfo/CS/localbuilder_sample_4.cs#2)]
 [!code-vb[LocalBuilder_Sample_SetLocalSymInfo#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/LocalBuilder_Sample_SetLocalSymInfo/VB/localbuilder_sample_4.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="localType" /> is <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">The containing type has been created by the <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> method.</exception>
      </Docs>
    </Member>
    <Member MemberName="DeclareLocal">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.Emit.LocalBuilder DeclareLocal (Type localType, bool pinned);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Emit.LocalBuilder DeclareLocal(class System.Type localType, bool pinned) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ILGenerator.DeclareLocal(System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function DeclareLocal (localType As Type, pinned As Boolean) As LocalBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Emit::LocalBuilder ^ DeclareLocal(Type ^ localType, bool pinned);" />
      <MemberSignature Language="F#" Value="abstract member DeclareLocal : Type * bool -&gt; System.Reflection.Emit.LocalBuilder&#xA;override this.DeclareLocal : Type * bool -&gt; System.Reflection.Emit.LocalBuilder" Usage="iLGenerator.DeclareLocal (localType, pinned)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.LocalBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="localType" Type="System.Type" />
        <Parameter Name="pinned" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="localType">A <see cref="T:System.Type" /> object that represents the type of the local variable.</param>
        <param name="pinned">
          <see langword="true" /> to pin the object in memory; otherwise, <see langword="false" />.</param>
        <summary>Declares a local variable of the specified type, optionally pinning the object referred to by the variable.</summary>
        <returns>A <see cref="T:System.Reflection.Emit.LocalBuilder" /> object that represents the local variable.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在当前词法范围内; 创建本地变量例如，如果代码中发出`for`循环 (`For` Visual Basic 中的循环)，变量的作用域是循环。  
  
 不安全代码中，必须将固定对象，可以通过非托管指针引用。 尽管引用的对象已固定，垃圾回收无法移动它。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="localType" /> is <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">The containing type has been created by the <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> method.  -or-  The method body of the enclosing method has been created by the <see cref="M:System.Reflection.Emit.MethodBuilder.CreateMethodBody(System.Byte[],System.Int32)" /> method.</exception>
        <exception cref="T:System.NotSupportedException">The method with which this <see cref="T:System.Reflection.Emit.ILGenerator" /> is associated is not represented by a <see cref="T:System.Reflection.Emit.MethodBuilder" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineLabel">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.Emit.Label DefineLabel ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Reflection.Emit.Label DefineLabel() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ILGenerator.DefineLabel" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function DefineLabel () As Label" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Emit::Label DefineLabel();" />
      <MemberSignature Language="F#" Value="abstract member DefineLabel : unit -&gt; System.Reflection.Emit.Label&#xA;override this.DefineLabel : unit -&gt; System.Reflection.Emit.Label" Usage="iLGenerator.DefineLabel " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.Label</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Declares a new label.</summary>
        <returns>Returns a new label that can be used as a token for branching.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要设置流中的标签的位置，必须调用<xref:System.Reflection.Emit.ILGenerator.MarkLabel%2A>。  
  
 这只是一个标记并不表示流中的任何特定位置。  
  
   
  
## Examples  
 下面的代码示例演示的上下文用法`DefineLabel`方法。  
  
 [!code-cpp[System.Reflection.Emit.Label Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.Label Example/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit.Label Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.Label Example/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit.Label Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.Label Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Emit">
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Puts an instruction onto the Microsoft Intermediate Language (MSIL) stream for the just-in-time (JIT) compiler.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Emit">
      <MemberSignature Language="C#" Value="public virtual void Emit (System.Reflection.Emit.OpCode opcode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Emit(valuetype System.Reflection.Emit.OpCode opcode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Emit(System::Reflection::Emit::OpCode opcode);" />
      <MemberSignature Language="F#" Value="abstract member Emit : System.Reflection.Emit.OpCode -&gt; unit&#xA;override this.Emit : System.Reflection.Emit.OpCode -&gt; unit" Usage="iLGenerator.Emit opcode" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="opcode" Type="System.Reflection.Emit.OpCode" />
      </Parameters>
      <Docs>
        <param name="opcode">The Microsoft Intermediate Language (MSIL) instruction to be put onto the stream.</param>
        <summary>Puts the specified instruction onto the stream of instructions.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果`opcode`参数需要一个实参，调用方必须确保参数长度匹配的声明的参数的长度。 否则，结果将不可预测。 例如，如果发出指令需要一个 2 字节的操作数，调用方提供一个 4 字节的操作数，则运行时将发出到指令流的两个其他字节。 这些额外的字节将<xref:System.Reflection.Emit.OpCodes.Nop>说明。  
  
 中定义的指令值<xref:System.Reflection.Emit.OpCodes>。  
  
   
  
## Examples  
 下面的代码示例演示如何使用`Emit`生成的实例通过 MSIL 输出<xref:System.Reflection.Emit.ILGenerator>。  
  
 [!code-cpp[System.Reflection.Emit.ILGenerator.Emit Example 2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.Emit Example 2/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit.ILGenerator.Emit Example 2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.Emit Example 2/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit.ILGenerator.Emit Example 2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.Emit Example 2/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Emit">
      <MemberSignature Language="C#" Value="public virtual void Emit (System.Reflection.Emit.OpCode opcode, byte arg);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Emit(valuetype System.Reflection.Emit.OpCode opcode, unsigned int8 arg) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode,System.Byte)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Emit(System::Reflection::Emit::OpCode opcode, System::Byte arg);" />
      <MemberSignature Language="F#" Value="abstract member Emit : System.Reflection.Emit.OpCode * byte -&gt; unit&#xA;override this.Emit : System.Reflection.Emit.OpCode * byte -&gt; unit" Usage="iLGenerator.Emit (opcode, arg)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="opcode" Type="System.Reflection.Emit.OpCode" />
        <Parameter Name="arg" Type="System.Byte" />
      </Parameters>
      <Docs>
        <param name="opcode">The MSIL instruction to be put onto the stream.</param>
        <param name="arg">The character argument pushed onto the stream immediately after the instruction.</param>
        <summary>Puts the specified instruction and character argument onto the Microsoft intermediate language (MSIL) stream of instructions.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 中定义的指令值`OpCodes`枚举。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Emit">
      <MemberSignature Language="C#" Value="public virtual void Emit (System.Reflection.Emit.OpCode opcode, double arg);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Emit(valuetype System.Reflection.Emit.OpCode opcode, float64 arg) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode,System.Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Emit(System::Reflection::Emit::OpCode opcode, double arg);" />
      <MemberSignature Language="F#" Value="abstract member Emit : System.Reflection.Emit.OpCode * double -&gt; unit&#xA;override this.Emit : System.Reflection.Emit.OpCode * double -&gt; unit" Usage="iLGenerator.Emit (opcode, arg)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="opcode" Type="System.Reflection.Emit.OpCode" />
        <Parameter Name="arg" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="opcode">The MSIL instruction to be put onto the stream. Defined in the <see langword="OpCodes" /> enumeration.</param>
        <param name="arg">The numerical argument pushed onto the stream immediately after the instruction.</param>
        <summary>Puts the specified instruction and numerical argument onto the Microsoft intermediate language (MSIL) stream of instructions.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 中定义的指令值`OpCodes`枚举。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Emit">
      <MemberSignature Language="C#" Value="public virtual void Emit (System.Reflection.Emit.OpCode opcode, short arg);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Emit(valuetype System.Reflection.Emit.OpCode opcode, int16 arg) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode,System.Int16)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Emit(System::Reflection::Emit::OpCode opcode, short arg);" />
      <MemberSignature Language="F#" Value="abstract member Emit : System.Reflection.Emit.OpCode * int16 -&gt; unit&#xA;override this.Emit : System.Reflection.Emit.OpCode * int16 -&gt; unit" Usage="iLGenerator.Emit (opcode, arg)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="opcode" Type="System.Reflection.Emit.OpCode" />
        <Parameter Name="arg" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="opcode">The MSIL instruction to be emitted onto the stream.</param>
        <param name="arg">The <see langword="Int" /> argument pushed onto the stream immediately after the instruction.</param>
        <summary>Puts the specified instruction and numerical argument onto the Microsoft intermediate language (MSIL) stream of instructions.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 中定义的指令值`OpCodes`枚举。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Emit">
      <MemberSignature Language="C#" Value="public virtual void Emit (System.Reflection.Emit.OpCode opcode, int arg);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Emit(valuetype System.Reflection.Emit.OpCode opcode, int32 arg) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Emit(System::Reflection::Emit::OpCode opcode, int arg);" />
      <MemberSignature Language="F#" Value="abstract member Emit : System.Reflection.Emit.OpCode * int -&gt; unit&#xA;override this.Emit : System.Reflection.Emit.OpCode * int -&gt; unit" Usage="iLGenerator.Emit (opcode, arg)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="opcode" Type="System.Reflection.Emit.OpCode" />
        <Parameter Name="arg" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="opcode">The MSIL instruction to be put onto the stream.</param>
        <param name="arg">The numerical argument pushed onto the stream immediately after the instruction.</param>
        <summary>Puts the specified instruction and numerical argument onto the Microsoft intermediate language (MSIL) stream of instructions.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 中定义的指令值`OpCodes`枚举。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Emit">
      <MemberSignature Language="C#" Value="public virtual void Emit (System.Reflection.Emit.OpCode opcode, long arg);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Emit(valuetype System.Reflection.Emit.OpCode opcode, int64 arg) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode,System.Int64)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Emit(System::Reflection::Emit::OpCode opcode, long arg);" />
      <MemberSignature Language="F#" Value="abstract member Emit : System.Reflection.Emit.OpCode * int64 -&gt; unit&#xA;override this.Emit : System.Reflection.Emit.OpCode * int64 -&gt; unit" Usage="iLGenerator.Emit (opcode, arg)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="opcode" Type="System.Reflection.Emit.OpCode" />
        <Parameter Name="arg" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="opcode">The MSIL instruction to be put onto the stream.</param>
        <param name="arg">The numerical argument pushed onto the stream immediately after the instruction.</param>
        <summary>Puts the specified instruction and numerical argument onto the Microsoft intermediate language (MSIL) stream of instructions.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 中定义的指令值`OpCodes`枚举。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Emit">
      <MemberSignature Language="C#" Value="public virtual void Emit (System.Reflection.Emit.OpCode opcode, System.Reflection.ConstructorInfo con);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Emit(valuetype System.Reflection.Emit.OpCode opcode, class System.Reflection.ConstructorInfo con) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode,System.Reflection.ConstructorInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Emit(System::Reflection::Emit::OpCode opcode, System::Reflection::ConstructorInfo ^ con);" />
      <MemberSignature Language="F#" Value="abstract member Emit : System.Reflection.Emit.OpCode * System.Reflection.ConstructorInfo -&gt; unit&#xA;override this.Emit : System.Reflection.Emit.OpCode * System.Reflection.ConstructorInfo -&gt; unit" Usage="iLGenerator.Emit (opcode, con)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="opcode" Type="System.Reflection.Emit.OpCode" />
        <Parameter Name="con" Type="System.Reflection.ConstructorInfo" />
      </Parameters>
      <Docs>
        <param name="opcode">The MSIL instruction to be emitted onto the stream.</param>
        <param name="con">A <see langword="ConstructorInfo" /> representing a constructor.</param>
        <summary>Puts the specified instruction and metadata token for the specified constructor onto the Microsoft intermediate language (MSIL) stream of instructions.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 中定义的指令值`OpCodes`枚举。  
  
 位置`con`记录，以便在指令流时可以进行修补如有必要将模块持续到可移植可执行 (PE) 文件。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="con" /> is <see langword="null" />. This exception is new in the [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)].</exception>
      </Docs>
    </Member>
    <Member MemberName="Emit">
      <MemberSignature Language="C#" Value="public virtual void Emit (System.Reflection.Emit.OpCode opcode, System.Reflection.Emit.Label label);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Emit(valuetype System.Reflection.Emit.OpCode opcode, valuetype System.Reflection.Emit.Label label) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode,System.Reflection.Emit.Label)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Emit(System::Reflection::Emit::OpCode opcode, System::Reflection::Emit::Label label);" />
      <MemberSignature Language="F#" Value="abstract member Emit : System.Reflection.Emit.OpCode * System.Reflection.Emit.Label -&gt; unit&#xA;override this.Emit : System.Reflection.Emit.OpCode * System.Reflection.Emit.Label -&gt; unit" Usage="iLGenerator.Emit (opcode, label)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="opcode" Type="System.Reflection.Emit.OpCode" />
        <Parameter Name="label" Type="System.Reflection.Emit.Label" />
      </Parameters>
      <Docs>
        <param name="opcode">The MSIL instruction to be emitted onto the stream.</param>
        <param name="label">The label to which to branch from this location.</param>
        <summary>Puts the specified instruction onto the Microsoft intermediate language (MSIL) stream and leaves space to include a label when fixes are done.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 中定义的指令值`OpCodes`枚举。  
  
 使用创建标签<xref:System.Reflection.Emit.ILGenerator.DefineLabel%2A>，并且它们将流内的位置固定使用<xref:System.Reflection.Emit.ILGenerator.MarkLabel%2A>。 如果使用单字节指令，则标签可以表示最多 127 个字节流的跳转。 `opcode` 必须代表分支指令。 分支是相对的说明，因为`label`在修复过程将替换到分支的正确偏移量。  
  
   
  
## Examples  
 下面的代码示例阐释如何创建具有跳转表的动态方法。 跳转表使用一个数组生成<xref:System.Reflection.Emit.Label>。  
  
 [!code-cpp[System.Reflection.Emit.ILGenerator.Emit Example 2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.Emit Example 2/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit.ILGenerator.Emit Example 2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.Emit Example 2/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit.ILGenerator.Emit Example 2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.Emit Example 2/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Emit">
      <MemberSignature Language="C#" Value="public virtual void Emit (System.Reflection.Emit.OpCode opcode, System.Reflection.Emit.Label[] labels);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Emit(valuetype System.Reflection.Emit.OpCode opcode, valuetype System.Reflection.Emit.Label[] labels) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode,System.Reflection.Emit.Label[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Emit(System::Reflection::Emit::OpCode opcode, cli::array &lt;System::Reflection::Emit::Label&gt; ^ labels);" />
      <MemberSignature Language="F#" Value="abstract member Emit : System.Reflection.Emit.OpCode * System.Reflection.Emit.Label[] -&gt; unit&#xA;override this.Emit : System.Reflection.Emit.OpCode * System.Reflection.Emit.Label[] -&gt; unit" Usage="iLGenerator.Emit (opcode, labels)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="opcode" Type="System.Reflection.Emit.OpCode" />
        <Parameter Name="labels" Type="System.Reflection.Emit.Label[]" />
      </Parameters>
      <Docs>
        <param name="opcode">The MSIL instruction to be emitted onto the stream.</param>
        <param name="labels">The array of label objects to which to branch from this location. All of the labels will be used.</param>
        <summary>Puts the specified instruction onto the Microsoft intermediate language (MSIL) stream and leaves space to include a label when fixes are done.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 发出的交换机表。  
  
 中定义的指令值`OpCodes`枚举。  
  
 使用创建标签<xref:System.Reflection.Emit.ILGenerator.DefineLabel%2A>，并且它们将流内的位置固定使用<xref:System.Reflection.Emit.ILGenerator.MarkLabel%2A>。 如果使用单字节指令，则标签可以表示最多 127 个字节流的跳转。 `opcode` 必须代表分支指令。 分支是相对的说明，因为`label`在修复过程将替换到分支的正确偏移量。  
  
   
  
## Examples  
 下面的代码示例阐释如何创建具有跳转表的动态方法。 跳转表使用一个数组生成<xref:System.Reflection.Emit.Label>。  
  
 [!code-cpp[System.Reflection.Emit.ILGenerator.Emit Example 2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.Emit Example 2/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit.ILGenerator.Emit Example 2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.Emit Example 2/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit.ILGenerator.Emit Example 2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.Emit Example 2/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="con" /> is <see langword="null" />. This exception is new in the [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)].</exception>
      </Docs>
    </Member>
    <Member MemberName="Emit">
      <MemberSignature Language="C#" Value="public virtual void Emit (System.Reflection.Emit.OpCode opcode, System.Reflection.Emit.LocalBuilder local);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Emit(valuetype System.Reflection.Emit.OpCode opcode, class System.Reflection.Emit.LocalBuilder local) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode,System.Reflection.Emit.LocalBuilder)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Emit(System::Reflection::Emit::OpCode opcode, System::Reflection::Emit::LocalBuilder ^ local);" />
      <MemberSignature Language="F#" Value="abstract member Emit : System.Reflection.Emit.OpCode * System.Reflection.Emit.LocalBuilder -&gt; unit&#xA;override this.Emit : System.Reflection.Emit.OpCode * System.Reflection.Emit.LocalBuilder -&gt; unit" Usage="iLGenerator.Emit (opcode, local)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="opcode" Type="System.Reflection.Emit.OpCode" />
        <Parameter Name="local" Type="System.Reflection.Emit.LocalBuilder" />
      </Parameters>
      <Docs>
        <param name="opcode">The MSIL instruction to be emitted onto the stream.</param>
        <param name="local">A local variable.</param>
        <summary>Puts the specified instruction onto the Microsoft intermediate language (MSIL) stream followed by the index of the given local variable.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 中定义的指令值`OpCodes`枚举。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">The parent method of the <paramref name="local" /> parameter does not match the method associated with this <see cref="T:System.Reflection.Emit.ILGenerator" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="local" /> is <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="opcode" /> is a single-byte instruction, and <paramref name="local" /> represents a local variable with an index greater than <see langword="Byte.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Emit">
      <MemberSignature Language="C#" Value="public virtual void Emit (System.Reflection.Emit.OpCode opcode, System.Reflection.Emit.SignatureHelper signature);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Emit(valuetype System.Reflection.Emit.OpCode opcode, class System.Reflection.Emit.SignatureHelper signature) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode,System.Reflection.Emit.SignatureHelper)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Emit(System::Reflection::Emit::OpCode opcode, System::Reflection::Emit::SignatureHelper ^ signature);" />
      <MemberSignature Language="F#" Value="abstract member Emit : System.Reflection.Emit.OpCode * System.Reflection.Emit.SignatureHelper -&gt; unit&#xA;override this.Emit : System.Reflection.Emit.OpCode * System.Reflection.Emit.SignatureHelper -&gt; unit" Usage="iLGenerator.Emit (opcode, signature)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="opcode" Type="System.Reflection.Emit.OpCode" />
        <Parameter Name="signature" Type="System.Reflection.Emit.SignatureHelper" />
      </Parameters>
      <Docs>
        <param name="opcode">The MSIL instruction to be emitted onto the stream.</param>
        <param name="signature">A helper for constructing a signature token.</param>
        <summary>Puts the specified instruction and a signature token onto the Microsoft intermediate language (MSIL) stream of instructions.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 中定义的指令值`OpCodes`枚举。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="signature" /> is <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Emit">
      <MemberSignature Language="C#" Value="public virtual void Emit (System.Reflection.Emit.OpCode opcode, System.Reflection.FieldInfo field);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Emit(valuetype System.Reflection.Emit.OpCode opcode, class System.Reflection.FieldInfo field) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode,System.Reflection.FieldInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Emit(System::Reflection::Emit::OpCode opcode, System::Reflection::FieldInfo ^ field);" />
      <MemberSignature Language="F#" Value="abstract member Emit : System.Reflection.Emit.OpCode * System.Reflection.FieldInfo -&gt; unit&#xA;override this.Emit : System.Reflection.Emit.OpCode * System.Reflection.FieldInfo -&gt; unit" Usage="iLGenerator.Emit (opcode, field)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="opcode" Type="System.Reflection.Emit.OpCode" />
        <Parameter Name="field" Type="System.Reflection.FieldInfo" />
      </Parameters>
      <Docs>
        <param name="opcode">The MSIL instruction to be emitted onto the stream.</param>
        <param name="field">A <see langword="FieldInfo" /> representing a field.</param>
        <summary>Puts the specified instruction and metadata token for the specified field onto the Microsoft intermediate language (MSIL) stream of instructions.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 中定义的指令值`OpCodes`枚举。 位置`field`记录，以便在指令流时可以进行修补如有必要将模块持续到可移植可执行 (PE) 文件。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Emit">
      <MemberSignature Language="C#" Value="public virtual void Emit (System.Reflection.Emit.OpCode opcode, System.Reflection.MethodInfo meth);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Emit(valuetype System.Reflection.Emit.OpCode opcode, class System.Reflection.MethodInfo meth) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Emit(System::Reflection::Emit::OpCode opcode, System::Reflection::MethodInfo ^ meth);" />
      <MemberSignature Language="F#" Value="abstract member Emit : System.Reflection.Emit.OpCode * System.Reflection.MethodInfo -&gt; unit&#xA;override this.Emit : System.Reflection.Emit.OpCode * System.Reflection.MethodInfo -&gt; unit" Usage="iLGenerator.Emit (opcode, meth)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="opcode" Type="System.Reflection.Emit.OpCode" />
        <Parameter Name="meth" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="opcode">The MSIL instruction to be emitted onto the stream.</param>
        <param name="meth">A <see langword="MethodInfo" /> representing a method.</param>
        <summary>Puts the specified instruction onto the Microsoft intermediate language (MSIL) stream followed by the metadata token for the given method.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 中定义的指令值`OpCodes`枚举。  
  
 位置`meth`记录，以便在指令流时可以进行修补如有必要将模块持续到可移植可执行 (PE) 文件。  
  
 如果`meth`表示泛型方法，它必须是泛型方法定义。 也就是说，其[MethodInfo.IsGenericMethodDefinition](xref:System.Reflection.MethodBase.IsGenericMethodDefinition)属性必须为`true`。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="meth" /> is <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="meth" /> is a generic method for which the <see cref="P:System.Reflection.MethodBase.IsGenericMethodDefinition" /> property is <see langword="false" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Emit">
      <MemberSignature Language="C#" Value="public void Emit (System.Reflection.Emit.OpCode opcode, sbyte arg);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Emit(valuetype System.Reflection.Emit.OpCode opcode, int8 arg) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode,System.SByte)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Emit(System::Reflection::Emit::OpCode opcode, System::SByte arg);" />
      <MemberSignature Language="F#" Value="member this.Emit : System.Reflection.Emit.OpCode * sbyte -&gt; unit" Usage="iLGenerator.Emit (opcode, arg)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="opcode" Type="System.Reflection.Emit.OpCode" />
        <Parameter Name="arg" Type="System.SByte" />
      </Parameters>
      <Docs>
        <param name="opcode">The MSIL instruction to be put onto the stream.</param>
        <param name="arg">The character argument pushed onto the stream immediately after the instruction.</param>
        <summary>Puts the specified instruction and character argument onto the Microsoft intermediate language (MSIL) stream of instructions.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 中定义的指令值`OpCodes`枚举。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Emit">
      <MemberSignature Language="C#" Value="public virtual void Emit (System.Reflection.Emit.OpCode opcode, float arg);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Emit(valuetype System.Reflection.Emit.OpCode opcode, float32 arg) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode,System.Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Emit(System::Reflection::Emit::OpCode opcode, float arg);" />
      <MemberSignature Language="F#" Value="abstract member Emit : System.Reflection.Emit.OpCode * single -&gt; unit&#xA;override this.Emit : System.Reflection.Emit.OpCode * single -&gt; unit" Usage="iLGenerator.Emit (opcode, arg)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="opcode" Type="System.Reflection.Emit.OpCode" />
        <Parameter Name="arg" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="opcode">The MSIL instruction to be put onto the stream.</param>
        <param name="arg">The <see langword="Single" /> argument pushed onto the stream immediately after the instruction.</param>
        <summary>Puts the specified instruction and numerical argument onto the Microsoft intermediate language (MSIL) stream of instructions.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 中定义的指令值`OpCodes`枚举。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Emit">
      <MemberSignature Language="C#" Value="public virtual void Emit (System.Reflection.Emit.OpCode opcode, string str);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Emit(valuetype System.Reflection.Emit.OpCode opcode, string str) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Emit(System::Reflection::Emit::OpCode opcode, System::String ^ str);" />
      <MemberSignature Language="F#" Value="abstract member Emit : System.Reflection.Emit.OpCode * string -&gt; unit&#xA;override this.Emit : System.Reflection.Emit.OpCode * string -&gt; unit" Usage="iLGenerator.Emit (opcode, str)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="opcode" Type="System.Reflection.Emit.OpCode" />
        <Parameter Name="str" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="opcode">The MSIL instruction to be emitted onto the stream.</param>
        <param name="str">The <see langword="String" /> to be emitted.</param>
        <summary>Puts the specified instruction onto the Microsoft intermediate language (MSIL) stream followed by the metadata token for the given string.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 中定义的指令值`OpCodes`枚举。 位置`str`如果模块保存到可移植可执行 (PE) 文件，则为将来进行修正操作记录。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Emit">
      <MemberSignature Language="C#" Value="public virtual void Emit (System.Reflection.Emit.OpCode opcode, Type cls);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Emit(valuetype System.Reflection.Emit.OpCode opcode, class System.Type cls) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Emit(System::Reflection::Emit::OpCode opcode, Type ^ cls);" />
      <MemberSignature Language="F#" Value="abstract member Emit : System.Reflection.Emit.OpCode * Type -&gt; unit&#xA;override this.Emit : System.Reflection.Emit.OpCode * Type -&gt; unit" Usage="iLGenerator.Emit (opcode, cls)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="opcode" Type="System.Reflection.Emit.OpCode" />
        <Parameter Name="cls" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="opcode">The MSIL instruction to be put onto the stream.</param>
        <param name="cls">A <see langword="Type" />.</param>
        <summary>Puts the specified instruction onto the Microsoft intermediate language (MSIL) stream followed by the metadata token for the given type.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 中定义的指令值`OpCodes`枚举。 位置`cls`记录，以便在保存到可移植可执行 (PE) 文件的模块时可以对标记进行必要的修补。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="cls" /> is <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="EmitCall">
      <MemberSignature Language="C#" Value="public virtual void EmitCall (System.Reflection.Emit.OpCode opcode, System.Reflection.MethodInfo methodInfo, Type[] optionalParameterTypes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EmitCall(valuetype System.Reflection.Emit.OpCode opcode, class System.Reflection.MethodInfo methodInfo, class System.Type[] optionalParameterTypes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ILGenerator.EmitCall(System.Reflection.Emit.OpCode,System.Reflection.MethodInfo,System.Type[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void EmitCall(System::Reflection::Emit::OpCode opcode, System::Reflection::MethodInfo ^ methodInfo, cli::array &lt;Type ^&gt; ^ optionalParameterTypes);" />
      <MemberSignature Language="F#" Value="abstract member EmitCall : System.Reflection.Emit.OpCode * System.Reflection.MethodInfo * Type[] -&gt; unit&#xA;override this.EmitCall : System.Reflection.Emit.OpCode * System.Reflection.MethodInfo * Type[] -&gt; unit" Usage="iLGenerator.EmitCall (opcode, methodInfo, optionalParameterTypes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="opcode" Type="System.Reflection.Emit.OpCode" />
        <Parameter Name="methodInfo" Type="System.Reflection.MethodInfo" />
        <Parameter Name="optionalParameterTypes" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="opcode">The MSIL instruction to be emitted onto the stream. Must be <see cref="F:System.Reflection.Emit.OpCodes.Call" />, <see cref="F:System.Reflection.Emit.OpCodes.Callvirt" />, or <see cref="F:System.Reflection.Emit.OpCodes.Newobj" />.</param>
        <param name="methodInfo">The <see langword="varargs" /> method to be called.</param>
        <param name="optionalParameterTypes">The types of the optional arguments if the method is a <see langword="varargs" /> method; otherwise, <see langword="null" />.</param>
        <summary>Puts a <see langword="call" /> or <see langword="callvirt" /> instruction onto the Microsoft intermediate language (MSIL) stream to call a <see langword="varargs" /> method.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Reflection.Emit.ILGenerator.EmitCall%2A>方法用来发出调用`varargs`方法的任何重载均是<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法，它指定变量的参数的参数类型。  
  
 若要发出对不使用的方法的调用<xref:System.Reflection.CallingConventions.VarArgs>调用约定，使用<xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%2CSystem.Reflection.MethodInfo%29>方法重载。  
  
## <a name="version-information"></a>版本信息  
 从.NET Framework 2.0 版中，开始<xref:System.Reflection.Emit.ILGenerator.EmitCall%2A>方法不会引发异常时的方法的不是指定可选参数类型`varargs`。 <xref:System.InvalidProgramException> 执行调用时引发。  
  
   
  
## Examples  
 下面的代码示例发出两种方法`varargs`方法，并调用的方法，`varargs`方法。 `EmitCall`方法用来发出调用`varargs`方法。  
  
 [!code-cpp[Emit.ArgIterator#1](~/samples/snippets/cpp/VS_Snippets_CLR/Emit.ArgIterator/cpp/source.cpp#1)]
 [!code-csharp[Emit.ArgIterator#1](~/samples/snippets/csharp/VS_Snippets_CLR/Emit.ArgIterator/cs/source.cs#1)]
 [!code-vb[Emit.ArgIterator#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Emit.ArgIterator/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="opcode" /> does not specify a method call.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="methodInfo" /> is <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">The calling convention for the method is not <see langword="varargs" />, but optional parameter types are supplied. This exception is thrown in the .NET Framework versions 1.0 and 1.1, In subsequent versions, no exception is thrown.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="EmitCalli">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Puts a <see cref="F:System.Reflection.Emit.OpCodes.Calli" /> instruction onto the Microsoft intermediate language (MSIL) stream.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="EmitCalli">
      <MemberSignature Language="C#" Value="public virtual void EmitCalli (System.Reflection.Emit.OpCode opcode, System.Runtime.InteropServices.CallingConvention unmanagedCallConv, Type returnType, Type[] parameterTypes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EmitCalli(valuetype System.Reflection.Emit.OpCode opcode, valuetype System.Runtime.InteropServices.CallingConvention unmanagedCallConv, class System.Type returnType, class System.Type[] parameterTypes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ILGenerator.EmitCalli(System.Reflection.Emit.OpCode,System.Runtime.InteropServices.CallingConvention,System.Type,System.Type[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void EmitCalli(System::Reflection::Emit::OpCode opcode, System::Runtime::InteropServices::CallingConvention unmanagedCallConv, Type ^ returnType, cli::array &lt;Type ^&gt; ^ parameterTypes);" />
      <MemberSignature Language="F#" Value="abstract member EmitCalli : System.Reflection.Emit.OpCode * System.Runtime.InteropServices.CallingConvention * Type * Type[] -&gt; unit&#xA;override this.EmitCalli : System.Reflection.Emit.OpCode * System.Runtime.InteropServices.CallingConvention * Type * Type[] -&gt; unit" Usage="iLGenerator.EmitCalli (opcode, unmanagedCallConv, returnType, parameterTypes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="opcode" Type="System.Reflection.Emit.OpCode" />
        <Parameter Name="unmanagedCallConv" Type="System.Runtime.InteropServices.CallingConvention" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="opcode">The MSIL instruction to be emitted onto the stream. Must be <see cref="F:System.Reflection.Emit.OpCodes.Calli" />.</param>
        <param name="unmanagedCallConv">The unmanaged calling convention to be used.</param>
        <param name="returnType">The <see cref="T:System.Type" /> of the result.</param>
        <param name="parameterTypes">The types of the required arguments to the instruction.</param>
        <summary>Puts a <see cref="F:System.Reflection.Emit.OpCodes.Calli" /> instruction onto the Microsoft intermediate language (MSIL) stream, specifying an unmanaged calling convention for the indirect call.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用<xref:System.Reflection.Emit.ILGenerator.EmitCalli%2A>放置<xref:System.Reflection.Emit.OpCodes.Calli>指令放到流。 不要使用<xref:System.Reflection.Emit.ILGenerator.Emit%2A>。  
  
   
  
## Examples  
 下面的代码示例演示如何上下文使用<xref:System.Reflection.Emit.ILGenerator.EmitCalli%2A>方法来调用非托管的类型方法，则动态类的外部。  
  
 [!code-cpp[System.Reflection.Emit.ILGenerator.EmitCalli Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.EmitCalli Example/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit.ILGenerator.EmitCalli Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.EmitCalli Example/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit.ILGenerator.EmitCalli Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.EmitCalli Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EmitCalli">
      <MemberSignature Language="C#" Value="public virtual void EmitCalli (System.Reflection.Emit.OpCode opcode, System.Reflection.CallingConventions callingConvention, Type returnType, Type[] parameterTypes, Type[] optionalParameterTypes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EmitCalli(valuetype System.Reflection.Emit.OpCode opcode, valuetype System.Reflection.CallingConventions callingConvention, class System.Type returnType, class System.Type[] parameterTypes, class System.Type[] optionalParameterTypes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ILGenerator.EmitCalli(System.Reflection.Emit.OpCode,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void EmitCalli(System::Reflection::Emit::OpCode opcode, System::Reflection::CallingConventions callingConvention, Type ^ returnType, cli::array &lt;Type ^&gt; ^ parameterTypes, cli::array &lt;Type ^&gt; ^ optionalParameterTypes);" />
      <MemberSignature Language="F#" Value="abstract member EmitCalli : System.Reflection.Emit.OpCode * System.Reflection.CallingConventions * Type * Type[] * Type[] -&gt; unit&#xA;override this.EmitCalli : System.Reflection.Emit.OpCode * System.Reflection.CallingConventions * Type * Type[] * Type[] -&gt; unit" Usage="iLGenerator.EmitCalli (opcode, callingConvention, returnType, parameterTypes, optionalParameterTypes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="opcode" Type="System.Reflection.Emit.OpCode" />
        <Parameter Name="callingConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
        <Parameter Name="optionalParameterTypes" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="opcode">The MSIL instruction to be emitted onto the stream. Must be <see cref="F:System.Reflection.Emit.OpCodes.Calli" />.</param>
        <param name="callingConvention">The managed calling convention to be used.</param>
        <param name="returnType">The <see cref="T:System.Type" /> of the result.</param>
        <param name="parameterTypes">The types of the required arguments to the instruction.</param>
        <param name="optionalParameterTypes">The types of the optional arguments for <see langword="varargs" /> calls.</param>
        <summary>Puts a <see cref="F:System.Reflection.Emit.OpCodes.Calli" /> instruction onto the Microsoft intermediate language (MSIL) stream, specifying a managed calling convention for the indirect call.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用<xref:System.Reflection.Emit.ILGenerator.EmitCalli%2A>放置<xref:System.Reflection.Emit.OpCodes.Calli>指令放到流。 不要使用<xref:System.Reflection.Emit.ILGenerator.Emit%2A>。  
  
 如果`optionalParameterTypes`指定了可选参数`callingConvention`必须包括<xref:System.Reflection.CallingConventions.VarArgs?displayProperty=nameWithType>标志。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="optionalParameterTypes" /> is not <see langword="null" />, but <paramref name="callingConvention" /> does not include the <see cref="F:System.Reflection.CallingConventions.VarArgs" /> flag.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="EmitWriteLine">
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Helper functions to emit a call to <see cref="M:System.Console.WriteLine" /> with different types of values.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="EmitWriteLine">
      <MemberSignature Language="C#" Value="public virtual void EmitWriteLine (System.Reflection.Emit.LocalBuilder localBuilder);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EmitWriteLine(class System.Reflection.Emit.LocalBuilder localBuilder) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ILGenerator.EmitWriteLine(System.Reflection.Emit.LocalBuilder)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void EmitWriteLine(System::Reflection::Emit::LocalBuilder ^ localBuilder);" />
      <MemberSignature Language="F#" Value="abstract member EmitWriteLine : System.Reflection.Emit.LocalBuilder -&gt; unit&#xA;override this.EmitWriteLine : System.Reflection.Emit.LocalBuilder -&gt; unit" Usage="iLGenerator.EmitWriteLine localBuilder" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="localBuilder" Type="System.Reflection.Emit.LocalBuilder" />
      </Parameters>
      <Docs>
        <param name="localBuilder">The local variable whose value is to be written to the console.</param>
        <summary>Emits the Microsoft intermediate language (MSIL) necessary to call <see cref="Overload:System.Console.WriteLine" /> with the given local variable.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 类型`localBuilder`必须匹配的重载的参数类型<xref:System.Console.WriteLine%2A?displayProperty=nameWithType>方法。  
  
   
  
## Examples  
 下面的代码示例演示的上下文用法<xref:System.Reflection.Emit.ILGenerator.EmitWriteLine%2A>方法将字符串写入控制台中的动态方法。  
  
 [!code-cpp[System.Reflection.Emit.ILGenerator.OpCodes Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.OpCodes Example/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit.ILGenerator.OpCodes Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.OpCodes Example/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit.ILGenerator.OpCodes Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.OpCodes Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">The type of <paramref name="localBuilder" /> is <see cref="T:System.Reflection.Emit.TypeBuilder" /> or <see cref="T:System.Reflection.Emit.EnumBuilder" />, which are not supported.  -or-  There is no overload of <see cref="Overload:System.Console.WriteLine" /> that accepts the type of <paramref name="localBuilder" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="localBuilder" /> is <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="EmitWriteLine">
      <MemberSignature Language="C#" Value="public virtual void EmitWriteLine (System.Reflection.FieldInfo fld);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EmitWriteLine(class System.Reflection.FieldInfo fld) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ILGenerator.EmitWriteLine(System.Reflection.FieldInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub EmitWriteLine (fld As FieldInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void EmitWriteLine(System::Reflection::FieldInfo ^ fld);" />
      <MemberSignature Language="F#" Value="abstract member EmitWriteLine : System.Reflection.FieldInfo -&gt; unit&#xA;override this.EmitWriteLine : System.Reflection.FieldInfo -&gt; unit" Usage="iLGenerator.EmitWriteLine fld" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fld" Type="System.Reflection.FieldInfo" />
      </Parameters>
      <Docs>
        <param name="fld">The field whose value is to be written to the console.</param>
        <summary>Emits the Microsoft intermediate language (MSIL) necessary to call <see cref="Overload:System.Console.WriteLine" /> with the given field.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 类型`fld`必须匹配的重载的参数类型<xref:System.Console.WriteLine%2A?displayProperty=nameWithType>方法。  
  
   
  
## Examples  
 下面的代码示例演示如何使用<xref:System.Reflection.Emit.ILGenerator.EmitWriteLine%2A>方法将字符串写入控制台中的动态方法。  
  
 [!code-cpp[System.Reflection.Emit.ILGenerator.OpCodes Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.OpCodes Example/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit.ILGenerator.OpCodes Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.OpCodes Example/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit.ILGenerator.OpCodes Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.OpCodes Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">There is no overload of the <see cref="Overload:System.Console.WriteLine" /> method that accepts the type of the specified field.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="fld" /> is <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">The type of the field is <see cref="T:System.Reflection.Emit.TypeBuilder" /> or <see cref="T:System.Reflection.Emit.EnumBuilder" />, which are not supported.</exception>
      </Docs>
    </Member>
    <Member MemberName="EmitWriteLine">
      <MemberSignature Language="C#" Value="public virtual void EmitWriteLine (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EmitWriteLine(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ILGenerator.EmitWriteLine(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub EmitWriteLine (value As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void EmitWriteLine(System::String ^ value);" />
      <MemberSignature Language="F#" Value="abstract member EmitWriteLine : string -&gt; unit&#xA;override this.EmitWriteLine : string -&gt; unit" Usage="iLGenerator.EmitWriteLine value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">The string to be printed.</param>
        <summary>Emits the Microsoft intermediate language (MSIL) to call <see cref="Overload:System.Console.WriteLine" /> with a string.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 字符串必须具有已定义。  
  
   
  
## Examples  
 下面的代码示例演示的上下文用法`EmitWriteLine`方法将字符串写入控制台中的动态方法。  
  
 [!code-cpp[System.Reflection.Emit.ILGenerator.OpCodes Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.OpCodes Example/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit.ILGenerator.OpCodes Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.OpCodes Example/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit.ILGenerator.OpCodes Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.OpCodes Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EndExceptionBlock">
      <MemberSignature Language="C#" Value="public virtual void EndExceptionBlock ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EndExceptionBlock() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ILGenerator.EndExceptionBlock" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub EndExceptionBlock ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void EndExceptionBlock();" />
      <MemberSignature Language="F#" Value="abstract member EndExceptionBlock : unit -&gt; unit&#xA;override this.EndExceptionBlock : unit -&gt; unit" Usage="iLGenerator.EndExceptionBlock " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ends an exception block.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下面的代码示例演示的上下文用法`EndExceptionBlock`方法。  
  
 [!code-cpp[System.Reflection.Emit.ILGenerator.ThrowException Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.ThrowException Example/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit.ILGenerator.ThrowException Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.ThrowException Example/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit.ILGenerator.ThrowException Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.ThrowException Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The end exception block occurs in an unexpected place in the code stream.</exception>
        <exception cref="T:System.NotSupportedException">The Microsoft intermediate language (MSIL) being generated is not currently in an exception block.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndScope">
      <MemberSignature Language="C#" Value="public virtual void EndScope ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EndScope() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ILGenerator.EndScope" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub EndScope ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void EndScope();" />
      <MemberSignature Language="F#" Value="abstract member EndScope : unit -&gt; unit&#xA;override this.EndScope : unit -&gt; unit" Usage="iLGenerator.EndScope " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ends a lexical scope.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用此方法来发出符号信息。 它用于<xref:System.Reflection.Emit.ILGenerator.BeginScope%2A>。  
  
 如果当前<xref:System.Reflection.Emit.ILGenerator>与关联<xref:System.Reflection.Emit.DynamicMethod>对象，它不支持的符号化信息。  
  
   
  
## Examples  
 下面的代码示例演示如何使用`BeginScope`和`EndScope`。  
  
 [!code-cpp[ILGenerator_Begin_EndScope#2](~/samples/snippets/cpp/VS_Snippets_CLR/ILGenerator_Begin_EndScope/CPP/ilgenerator_begin_endscope.cpp#2)]
 [!code-csharp[ILGenerator_Begin_EndScope#2](~/samples/snippets/csharp/VS_Snippets_CLR/ILGenerator_Begin_EndScope/CS/ilgenerator_begin_endscope.cs#2)]
 [!code-vb[ILGenerator_Begin_EndScope#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/ILGenerator_Begin_EndScope/VB/ilgenerator_begin_endscope.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">This <see cref="T:System.Reflection.Emit.ILGenerator" /> belongs to a <see cref="T:System.Reflection.Emit.DynamicMethod" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ILOffset">
      <MemberSignature Language="C#" Value="public virtual int ILOffset { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ILOffset" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.ILGenerator.ILOffset" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property ILOffset As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int ILOffset { int get(); };" />
      <MemberSignature Language="F#" Value="member this.ILOffset : int" Usage="System.Reflection.Emit.ILGenerator.ILOffset" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the current offset, in bytes, in the Microsoft intermediate language (MSIL) stream that is being emitted by the <see cref="T:System.Reflection.Emit.ILGenerator" />.</summary>
        <value>下一条指令将在发出 MSIL 流中的偏移量。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法是透明的且可以从部分受信任代码调用。  
  
 如果<xref:System.Reflection.Emit.ILGenerator.ILOffset%2A>之前已发出任何 MSIL 指令，则在访问属性，则返回 0 （零）。  
  
 当在为动态语言生成 MSIL 时，此属性可用于将 MSIL 流中的偏移量映射到源的代码行号。 生成的信息可用于引发异常时提供堆栈跟踪。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MarkLabel">
      <MemberSignature Language="C#" Value="public virtual void MarkLabel (System.Reflection.Emit.Label loc);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void MarkLabel(valuetype System.Reflection.Emit.Label loc) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ILGenerator.MarkLabel(System.Reflection.Emit.Label)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub MarkLabel (loc As Label)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void MarkLabel(System::Reflection::Emit::Label loc);" />
      <MemberSignature Language="F#" Value="abstract member MarkLabel : System.Reflection.Emit.Label -&gt; unit&#xA;override this.MarkLabel : System.Reflection.Emit.Label -&gt; unit" Usage="iLGenerator.MarkLabel loc" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="loc" Type="System.Reflection.Emit.Label" />
      </Parameters>
      <Docs>
        <param name="loc">The label for which to set an index.</param>
        <summary>Marks the Microsoft intermediate language (MSIL) stream's current position with the given label.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 不能超过一次定义标签。  
  
   
  
## Examples  
 下面的代码示例演示的上下文用法`MarkLabel`实现分支中的动态方法的 MSIL。  
  
 [!code-cpp[System.Reflection.Emit.ILGenerator.Emit Example 2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.Emit Example 2/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit.ILGenerator.Emit Example 2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.Emit Example 2/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit.ILGenerator.Emit Example 2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.Emit Example 2/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="loc" /> represents an invalid index into the label array.  -or-  An index for <paramref name="loc" /> has already been defined.</exception>
      </Docs>
    </Member>
    <Member MemberName="MarkSequencePoint">
      <MemberSignature Language="C#" Value="public virtual void MarkSequencePoint (System.Diagnostics.SymbolStore.ISymbolDocumentWriter document, int startLine, int startColumn, int endLine, int endColumn);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void MarkSequencePoint(class System.Diagnostics.SymbolStore.ISymbolDocumentWriter document, int32 startLine, int32 startColumn, int32 endLine, int32 endColumn) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ILGenerator.MarkSequencePoint(System.Diagnostics.SymbolStore.ISymbolDocumentWriter,System.Int32,System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub MarkSequencePoint (document As ISymbolDocumentWriter, startLine As Integer, startColumn As Integer, endLine As Integer, endColumn As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void MarkSequencePoint(System::Diagnostics::SymbolStore::ISymbolDocumentWriter ^ document, int startLine, int startColumn, int endLine, int endColumn);" />
      <MemberSignature Language="F#" Value="abstract member MarkSequencePoint : System.Diagnostics.SymbolStore.ISymbolDocumentWriter * int * int * int * int -&gt; unit&#xA;override this.MarkSequencePoint : System.Diagnostics.SymbolStore.ISymbolDocumentWriter * int * int * int * int -&gt; unit" Usage="iLGenerator.MarkSequencePoint (document, startLine, startColumn, endLine, endColumn)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="document" Type="System.Diagnostics.SymbolStore.ISymbolDocumentWriter" />
        <Parameter Name="startLine" Type="System.Int32" />
        <Parameter Name="startColumn" Type="System.Int32" />
        <Parameter Name="endLine" Type="System.Int32" />
        <Parameter Name="endColumn" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="document">The document for which the sequence point is being defined.</param>
        <param name="startLine">The line where the sequence point begins.</param>
        <param name="startColumn">The column in the line where the sequence point begins.</param>
        <param name="endLine">The line where the sequence point ends.</param>
        <param name="endColumn">The column in the line where the sequence point ends.</param>
        <summary>Marks a sequence point in the Microsoft intermediate language (MSIL) stream.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 行号从 1 编制索引。 列被索引为 0。  
  
 符号化信息通常包含每个源行的至少一个 MSIL 偏移量。 当实时 (JIT) 编译器要编译方法时，它会请求分析服务提供应保留的 MSIL 偏移量列表。 这些 MSIL 偏移量称为*序列点*。  
  
 如果当前<xref:System.Reflection.Emit.ILGenerator>与关联<xref:System.Reflection.Emit.DynamicMethod>对象，它不支持的符号化信息。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startLine" /> or <paramref name="endLine" /> is &lt;= 0.</exception>
        <exception cref="T:System.NotSupportedException">This <see cref="T:System.Reflection.Emit.ILGenerator" /> belongs to a <see cref="T:System.Reflection.Emit.DynamicMethod" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._ILGenerator.GetIDsOfNames">
      <MemberSignature Language="C#" Value="void _ILGenerator.GetIDsOfNames (ref Guid riid, IntPtr rgszNames, uint cNames, uint lcid, IntPtr rgDispId);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._ILGenerator.GetIDsOfNames([in]valuetype System.Guid&amp; riid, native int rgszNames, unsigned int32 cNames, unsigned int32 lcid, native int rgDispId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ILGenerator.System#Runtime#InteropServices#_ILGenerator#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetIDsOfNames (ByRef riid As Guid, rgszNames As IntPtr, cNames As UInteger, lcid As UInteger, rgDispId As IntPtr) Implements _ILGenerator.GetIDsOfNames" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._ILGenerator.GetIDsOfNames(Guid % riid, IntPtr rgszNames, System::UInt32 cNames, System::UInt32 lcid, IntPtr rgDispId) = System::Runtime::InteropServices::_ILGenerator::GetIDsOfNames;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._ILGenerator.GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="riid" Type="System.Guid&amp;" RefType="ref" />
        <Parameter Name="rgszNames" Type="System.IntPtr" />
        <Parameter Name="cNames" Type="System.UInt32" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="rgDispId" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="riid">Reserved for future use. Must be IID_NULL.</param>
        <param name="rgszNames">Passed-in array of names to be mapped.</param>
        <param name="cNames">Count of the names to be mapped.</param>
        <param name="lcid">The locale context in which to interpret the names.</param>
        <param name="rgDispId">Caller-allocated array that receives the IDs corresponding to the names.</param>
        <summary>Maps a set of names to a corresponding set of dispatch identifiers.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法是用于从非托管代码访问的托管的类，并不应从托管代码调用。 有关详细信息`IDispatch::GetIDsOfNames`，请参阅 MSDN 库。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">The method is called late-bound using the COM <c>IDispatch</c> interface.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._ILGenerator.GetTypeInfo">
      <MemberSignature Language="C#" Value="void _ILGenerator.GetTypeInfo (uint iTInfo, uint lcid, IntPtr ppTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._ILGenerator.GetTypeInfo(unsigned int32 iTInfo, unsigned int32 lcid, native int ppTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ILGenerator.System#Runtime#InteropServices#_ILGenerator#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfo (iTInfo As UInteger, lcid As UInteger, ppTInfo As IntPtr) Implements _ILGenerator.GetTypeInfo" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._ILGenerator.GetTypeInfo(System::UInt32 iTInfo, System::UInt32 lcid, IntPtr ppTInfo) = System::Runtime::InteropServices::_ILGenerator::GetTypeInfo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._ILGenerator.GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="iTInfo" Type="System.UInt32" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="ppTInfo" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="iTInfo">The type information to return.</param>
        <param name="lcid">The locale identifier for the type information.</param>
        <param name="ppTInfo">Receives a pointer to the requested type information object.</param>
        <summary>Retrieves the type information for an object, which can then be used to get the type information for an interface.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法是用于从非托管代码访问的托管的类，并不应从托管代码调用。 有关详细信息`IDispatch::GetTypeInfo`，请参阅 MSDN 库。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">The method is called late-bound using the COM <c>IDispatch</c> interface.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._ILGenerator.GetTypeInfoCount">
      <MemberSignature Language="C#" Value="void _ILGenerator.GetTypeInfoCount (out uint pcTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._ILGenerator.GetTypeInfoCount([out] unsigned int32&amp; pcTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ILGenerator.System#Runtime#InteropServices#_ILGenerator#GetTypeInfoCount(System.UInt32@)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfoCount (ByRef pcTInfo As UInteger) Implements _ILGenerator.GetTypeInfoCount" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._ILGenerator.GetTypeInfoCount([Runtime::InteropServices::Out] System::UInt32 % pcTInfo) = System::Runtime::InteropServices::_ILGenerator::GetTypeInfoCount;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._ILGenerator.GetTypeInfoCount(System.UInt32@)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pcTInfo" Type="System.UInt32&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="pcTInfo">Points to a location that receives the number of type information interfaces provided by the object.</param>
        <summary>Retrieves the number of type information interfaces that an object provides (either 0 or 1).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法是用于从非托管代码访问的托管的类，并不应从托管代码调用。 有关详细信息`IDispatch::GetTypeInfoCount`，请参阅 MSDN 库。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">The method is called late-bound using the COM <c>IDispatch</c> interface.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._ILGenerator.Invoke">
      <MemberSignature Language="C#" Value="void _ILGenerator.Invoke (uint dispIdMember, ref Guid riid, uint lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._ILGenerator.Invoke(unsigned int32 dispIdMember, [in]valuetype System.Guid&amp; riid, unsigned int32 lcid, int16 wFlags, native int pDispParams, native int pVarResult, native int pExcepInfo, native int puArgErr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ILGenerator.System#Runtime#InteropServices#_ILGenerator#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub Invoke (dispIdMember As UInteger, ByRef riid As Guid, lcid As UInteger, wFlags As Short, pDispParams As IntPtr, pVarResult As IntPtr, pExcepInfo As IntPtr, puArgErr As IntPtr) Implements _ILGenerator.Invoke" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._ILGenerator.Invoke(System::UInt32 dispIdMember, Guid % riid, System::UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr) = System::Runtime::InteropServices::_ILGenerator::Invoke;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._ILGenerator.Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dispIdMember" Type="System.UInt32" />
        <Parameter Name="riid" Type="System.Guid&amp;" RefType="ref" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="wFlags" Type="System.Int16" />
        <Parameter Name="pDispParams" Type="System.IntPtr" />
        <Parameter Name="pVarResult" Type="System.IntPtr" />
        <Parameter Name="pExcepInfo" Type="System.IntPtr" />
        <Parameter Name="puArgErr" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="dispIdMember">Identifies the member.</param>
        <param name="riid">Reserved for future use. Must be IID_NULL.</param>
        <param name="lcid">The locale context in which to interpret arguments.</param>
        <param name="wFlags">Flags describing the context of the call.</param>
        <param name="pDispParams">Pointer to a structure containing an array of arguments, an array of argument DISPIDs for named arguments, and counts for the number of elements in the arrays.</param>
        <param name="pVarResult">Pointer to the location where the result is to be stored.</param>
        <param name="pExcepInfo">Pointer to a structure that contains exception information.</param>
        <param name="puArgErr">The index of the first argument that has an error.</param>
        <summary>Provides access to properties and methods exposed by an object.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法是用于从非托管代码访问的托管的类，并不应从托管代码调用。 有关详细信息`IDispatch::Invoke`，请参阅 MSDN 库。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">The method is called late-bound using the COM <c>IDispatch</c> interface.</exception>
      </Docs>
    </Member>
    <Member MemberName="ThrowException">
      <MemberSignature Language="C#" Value="public virtual void ThrowException (Type excType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ThrowException(class System.Type excType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ILGenerator.ThrowException(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub ThrowException (excType As Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ThrowException(Type ^ excType);" />
      <MemberSignature Language="F#" Value="abstract member ThrowException : Type -&gt; unit&#xA;override this.ThrowException : Type -&gt; unit" Usage="iLGenerator.ThrowException excType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="excType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="excType">The class of the type of exception to throw.</param>
        <summary>Emits an instruction to throw an exception.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下面的代码示例演示如何上下文使用`ThrowException`引发异常的动态方法的 msil。  
  
 [!code-cpp[System.Reflection.Emit.ILGenerator.ThrowException Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.ThrowException Example/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit.ILGenerator.ThrowException Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.ThrowException Example/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit.ILGenerator.ThrowException Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.ThrowException Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="excType" /> is not the <see cref="T:System.Exception" /> class or a derived class of <see cref="T:System.Exception" />.  -or-  The type does not have a default constructor.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="excType" /> is <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="UsingNamespace">
      <MemberSignature Language="C#" Value="public virtual void UsingNamespace (string usingNamespace);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void UsingNamespace(string usingNamespace) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ILGenerator.UsingNamespace(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub UsingNamespace (usingNamespace As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void UsingNamespace(System::String ^ usingNamespace);" />
      <MemberSignature Language="F#" Value="abstract member UsingNamespace : string -&gt; unit&#xA;override this.UsingNamespace : string -&gt; unit" Usage="iLGenerator.UsingNamespace usingNamespace" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="usingNamespace" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="usingNamespace">The namespace to be used in evaluating locals and watches for the current active lexical scope</param>
        <summary>Specifies the namespace to be used in evaluating locals and watches for the current active lexical scope.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果当前<xref:System.Reflection.Emit.ILGenerator>与关联<xref:System.Reflection.Emit.DynamicMethod>对象，不支持此方法。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Length of <paramref name="usingNamespace" /> is zero.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="usingNamespace" /> is <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">This <see cref="T:System.Reflection.Emit.ILGenerator" /> belongs to a <see cref="T:System.Reflection.Emit.DynamicMethod" />.</exception>
      </Docs>
    </Member>
  </Members>
</Type>