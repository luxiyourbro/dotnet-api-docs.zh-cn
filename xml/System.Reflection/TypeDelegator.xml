<Type Name="TypeDelegator" FullName="System.Reflection.TypeDelegator">
  <TypeSignature Language="C#" Value="public class TypeDelegator : System.Reflection.TypeInfo" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit TypeDelegator extends System.Reflection.TypeInfo" />
  <TypeSignature Language="DocId" Value="T:System.Reflection.TypeDelegator" />
  <TypeSignature Language="VB.NET" Value="Public Class TypeDelegator&#xA;Inherits TypeInfo" />
  <TypeSignature Language="C++ CLI" Value="public ref class TypeDelegator : System::Reflection::TypeInfo" />
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Reflection.TypeInfo</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><span data-ttu-id="fcc41-101">包装 <see cref="T:System.Type" /> 对象并将所有方法委托给该 <see langword="Type" />。</span><span class="sxs-lookup"><span data-stu-id="fcc41-101">Wraps a <see cref="T:System.Type" /> object and delegates methods to that <see langword="Type" />.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="fcc41-102">从此类型派生，重写你必须提供自定义项中，这些成员加上所需的程序和由尚未实现的任意成员<xref:System.Reflection.TypeDelegator>。</span><span class="sxs-lookup"><span data-stu-id="fcc41-102">Derive from this type and override only those members you have to provide customization in, plus any members that are required by your program and not already implemented by <xref:System.Reflection.TypeDelegator>.</span></span>  
  
 <span data-ttu-id="fcc41-103"><xref:System.Reflection.TypeDelegator> 派生自<xref:System.Type?displayProperty=nameWithType>并实现的大多数属性和方法的<xref:System.Type>。</span><span class="sxs-lookup"><span data-stu-id="fcc41-103"><xref:System.Reflection.TypeDelegator> derives from <xref:System.Type?displayProperty=nameWithType> and implements most of the properties and methods of <xref:System.Type>.</span></span> <span data-ttu-id="fcc41-104">每个成员实现，<xref:System.Reflection.TypeDelegator>自动委托给内部的相应成员<xref:System.Type>对象，它提供作为构造函数的自变量。</span><span class="sxs-lookup"><span data-stu-id="fcc41-104">For each member it implements, <xref:System.Reflection.TypeDelegator> automatically delegates to the corresponding member of an internal <xref:System.Type> object, which is supplied as an argument to the constructor.</span></span> <span data-ttu-id="fcc41-105">此内部<xref:System.Type>对象被公开到派生类`protected`<xref:System.Reflection.TypeDelegator.typeImpl>字段。</span><span class="sxs-lookup"><span data-stu-id="fcc41-105">This internal <xref:System.Type> object is exposed to deriving classes by the `protected`<xref:System.Reflection.TypeDelegator.typeImpl> field.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="fcc41-106">某些成员<xref:System.Reflection.TypeDelegator>具有实现，即使这些成员本身只是继承自<xref:System.Type>。</span><span class="sxs-lookup"><span data-stu-id="fcc41-106">Some members of <xref:System.Reflection.TypeDelegator> have implementations even though the members themselves are simply inherited from <xref:System.Type>.</span></span> <span data-ttu-id="fcc41-107">在这些情况下，提供了该实现通过被重写`protected`具有以"以 Impl"结尾的名称的方法。</span><span class="sxs-lookup"><span data-stu-id="fcc41-107">In these cases, the implementation is provided by an overridden `protected` method that has a name that ends in "Impl".</span></span> <span data-ttu-id="fcc41-108">例如，实现的所有重载<xref:System.Reflection.TypeDelegator.GetMethods%2A>提供方法通过重写<xref:System.Reflection.TypeDelegator.GetMethodImpl%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="fcc41-108">For example, the implementation for all overloads of the <xref:System.Reflection.TypeDelegator.GetMethods%2A> method is supplied by the overridden <xref:System.Reflection.TypeDelegator.GetMethodImpl%2A> method.</span></span> <span data-ttu-id="fcc41-109">实现继承属性，如<xref:System.Type.IsPublic%2A>和<xref:System.Type.IsNestedAssembly%2A>提供通过重写<xref:System.Reflection.TypeDelegator.GetAttributeFlagsImpl%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="fcc41-109">The implementation for inherited properties such as <xref:System.Type.IsPublic%2A> and <xref:System.Type.IsNestedAssembly%2A> is provided by the overridden <xref:System.Reflection.TypeDelegator.GetAttributeFlagsImpl%2A> method.</span></span>  
  
 <span data-ttu-id="fcc41-110">派生类可以提供的公共构造函数的<xref:System.Type>对象作为其参数并只需将该对象传递到<xref:System.Reflection.TypeDelegator.%23ctor%28System.Type%29>构造函数，也可以设置内部<xref:System.Type>以某种其他方式的对象。</span><span class="sxs-lookup"><span data-stu-id="fcc41-110">Deriving classes can provide a public constructor that takes a <xref:System.Type> object as its parameter and simply passes that object to the <xref:System.Reflection.TypeDelegator.%23ctor%28System.Type%29> constructor, or can set the internal <xref:System.Type> object in some other way.</span></span>  
  
 <span data-ttu-id="fcc41-111">如果派生的类将使用未实现成员<xref:System.Reflection.TypeDelegator>，它必须重写该成员，并提供一个实现。</span><span class="sxs-lookup"><span data-stu-id="fcc41-111">If a deriving class uses a member that is not implemented by <xref:System.Reflection.TypeDelegator>, it must override that member and provide an implementation.</span></span> <span data-ttu-id="fcc41-112">最简单的实现是在内部调用的对应成员<xref:System.Type>由公开对象<xref:System.Reflection.TypeDelegator.typeImpl>字段，但你可以提供你的应用程序要求任何实现。</span><span class="sxs-lookup"><span data-stu-id="fcc41-112">The simplest implementation is to call the corresponding member on the internal <xref:System.Type> object exposed by the <xref:System.Reflection.TypeDelegator.typeImpl> field, but you can provide any implementation your application requires.</span></span> <span data-ttu-id="fcc41-113">不需要重写这些成员，如果它们不由你的应用程序或库函数你应用程序的调用 (例如，通过<xref:System.CodeDom.CodeTypeReference.%23ctor%28System.Type%29?displayProperty=nameWithType>构造函数)。</span><span class="sxs-lookup"><span data-stu-id="fcc41-113">It is not necessary to override these members if they are not used by your application or by library functions your application calls (for example, by the <xref:System.CodeDom.CodeTypeReference.%23ctor%28System.Type%29?displayProperty=nameWithType> constructor).</span></span>  
  
 <span data-ttu-id="fcc41-114">以下虚拟方法 (`Overridable`在 Visual Basic 中的方法) 的<xref:System.Type>不由实现<xref:System.Reflection.TypeDelegator>: <xref:System.Type.MakeGenericType%2A>， <xref:System.Type.GetGenericTypeDefinition%2A>， <xref:System.Type.GetGenericArguments%2A>， <xref:System.Type.GetGenericParameterConstraints%2A>， <xref:System.Type.MakeArrayType%2A>， <xref:System.Type.MakeByRefType%2A>， <xref:System.Type.MakePointerType%2A>, <xref:System.Type.GetEnumNames%2A>, <xref:System.Type.GetEnumValues%2A>, <xref:System.Type.GetEnumUnderlyingType%2A>, <xref:System.Type.GetTypeCodeImpl%2A>, <xref:System.Type.IsEnumDefined%2A>, <xref:System.Type.IsEquivalentTo%2A>.</span><span class="sxs-lookup"><span data-stu-id="fcc41-114">The following virtual methods (`Overridable` methods in Visual Basic) of <xref:System.Type> are not implemented by <xref:System.Reflection.TypeDelegator>: <xref:System.Type.MakeGenericType%2A>, <xref:System.Type.GetGenericTypeDefinition%2A>, <xref:System.Type.GetGenericArguments%2A>, <xref:System.Type.GetGenericParameterConstraints%2A>, <xref:System.Type.MakeArrayType%2A>, <xref:System.Type.MakeByRefType%2A>, <xref:System.Type.MakePointerType%2A>, <xref:System.Type.GetEnumNames%2A>, <xref:System.Type.GetEnumValues%2A>, <xref:System.Type.GetEnumUnderlyingType%2A>, <xref:System.Type.GetTypeCodeImpl%2A>, <xref:System.Type.IsEnumDefined%2A>, <xref:System.Type.IsEquivalentTo%2A>.</span></span>  
  
 <span data-ttu-id="fcc41-115">以下虚拟属性 (`Overridable`属性在 Visual Basic 中的) 的<xref:System.Type>不由实现<xref:System.Reflection.TypeDelegator>: <xref:System.Type.IsGenericType%2A>， <xref:System.Type.IsGenericTypeDefinition%2A>， <xref:System.Type.IsGenericParameter%2A>， <xref:System.Type.ContainsGenericParameters%2A>， <xref:System.Type.DeclaringMethod%2A>， <xref:System.Type.GenericParameterAttributes%2A>， <xref:System.Type.GenericParameterPosition%2A>, <xref:System.Type.IsSecurityCritical%2A>, <xref:System.Type.IsSecuritySafeCritical%2A>, <xref:System.Type.IsSecurityTransparent%2A>.</span><span class="sxs-lookup"><span data-stu-id="fcc41-115">The following virtual properties (`Overridable` properties in Visual Basic) of <xref:System.Type> are not implemented by <xref:System.Reflection.TypeDelegator>: <xref:System.Type.IsGenericType%2A>, <xref:System.Type.IsGenericTypeDefinition%2A>, <xref:System.Type.IsGenericParameter%2A>, <xref:System.Type.ContainsGenericParameters%2A>, <xref:System.Type.DeclaringMethod%2A>, <xref:System.Type.GenericParameterAttributes%2A>, <xref:System.Type.GenericParameterPosition%2A>, <xref:System.Type.IsSecurityCritical%2A>, <xref:System.Type.IsSecuritySafeCritical%2A>, <xref:System.Type.IsSecurityTransparent%2A>.</span></span>  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="fcc41-116">初始化 <see cref="T:System.Reflection.TypeDelegator" /> 类的新实例。</span><span class="sxs-lookup"><span data-stu-id="fcc41-116">Initializes a new instance of the <see cref="T:System.Reflection.TypeDelegator" /> class.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected TypeDelegator ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.TypeDelegator.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; TypeDelegator();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="fcc41-117">使用默认属性初始化 <see cref="T:System.Reflection.TypeDelegator" /> 类的新实例。</span><span class="sxs-lookup"><span data-stu-id="fcc41-117">Initializes a new instance of the <see cref="T:System.Reflection.TypeDelegator" /> class with default properties.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public TypeDelegator (Type delegatingType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Type delegatingType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.TypeDelegator.#ctor(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (delegatingType As Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; TypeDelegator(Type ^ delegatingType);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="delegatingType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="delegatingType"><span data-ttu-id="fcc41-118"><see cref="T:System.Type" /> 类的实例，它封装对对象方法的调用。</span><span class="sxs-lookup"><span data-stu-id="fcc41-118">The instance of the class <see cref="T:System.Type" /> that encapsulates the call to the method of an object.</span></span></param>
        <summary><span data-ttu-id="fcc41-119">在指定封装实例的情况下，初始化 <see cref="T:System.Reflection.TypeDelegator" /> 类的新实例。</span><span class="sxs-lookup"><span data-stu-id="fcc41-119">Initializes a new instance of the <see cref="T:System.Reflection.TypeDelegator" /> class specifying the encapsulating instance.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="fcc41-120">此构造函数调用从一个类来生成基于委托`Type`为定义该方法的类的对象。</span><span class="sxs-lookup"><span data-stu-id="fcc41-120">This constructor is called from a class to generate a delegate based upon the `Type` object for the class defining the method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="fcc41-121"><paramref name="delegatingType" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="fcc41-121"><paramref name="delegatingType" /> is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Assembly">
      <MemberSignature Language="C#" Value="public override System.Reflection.Assembly Assembly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.Assembly Assembly" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.TypeDelegator.Assembly" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Assembly As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::Assembly ^ Assembly { System::Reflection::Assembly ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="fcc41-122">获取已实现类型的程序集。</span><span class="sxs-lookup"><span data-stu-id="fcc41-122">Gets the assembly of the implemented type.</span></span></summary>
        <value><span data-ttu-id="fcc41-123">表示已实现类型的程序集的 <see cref="T:System.Reflection.Assembly" /> 对象。</span><span class="sxs-lookup"><span data-stu-id="fcc41-123">An <see cref="T:System.Reflection.Assembly" /> object representing the assembly of the implemented type.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="fcc41-124">程序集是公共语言运行时中的部署单元。</span><span class="sxs-lookup"><span data-stu-id="fcc41-124">Assemblies are the deployment units in the common language runtime.</span></span> <span data-ttu-id="fcc41-125">程序集建立解析请求的命名空间，并确定哪些资源向外部公开，这是可从程序集内访问。</span><span class="sxs-lookup"><span data-stu-id="fcc41-125">Assemblies establish the namespace for resolving requests and determine which resources are exposed externally and which are accessible from within the assembly.</span></span> <span data-ttu-id="fcc41-126">公共语言运行时可以确定，并找到任何正在运行的对象的程序集。</span><span class="sxs-lookup"><span data-stu-id="fcc41-126">The common language runtime can determine and locate the assembly for any running object.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AssemblyQualifiedName">
      <MemberSignature Language="C#" Value="public override string AssemblyQualifiedName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string AssemblyQualifiedName" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.TypeDelegator.AssemblyQualifiedName" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property AssemblyQualifiedName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ AssemblyQualifiedName { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="fcc41-127">获取程序集的完全限定名。</span><span class="sxs-lookup"><span data-stu-id="fcc41-127">Gets the assembly's fully qualified name.</span></span></summary>
        <value><span data-ttu-id="fcc41-128">包含程序集的完全限定名的 <see langword="String" />。</span><span class="sxs-lookup"><span data-stu-id="fcc41-128">A <see langword="String" /> containing the assembly's fully qualified name.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BaseType">
      <MemberSignature Language="C#" Value="public override Type BaseType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type BaseType" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.TypeDelegator.BaseType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property BaseType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ BaseType { Type ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="fcc41-129">获取当前类型的基类型。</span><span class="sxs-lookup"><span data-stu-id="fcc41-129">Gets the base type for the current type.</span></span></summary>
        <value><span data-ttu-id="fcc41-130">类型的基类型。</span><span class="sxs-lookup"><span data-stu-id="fcc41-130">The base type for a type.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="fcc41-131">基类型是此类型直接从中继承的类型。</span><span class="sxs-lookup"><span data-stu-id="fcc41-131">The base type is the type from which this type directly inherits.</span></span> <span data-ttu-id="fcc41-132">由于<xref:System.Object>类类型是所有其他类型的最终基类，它是不具有基类型的唯一类型。</span><span class="sxs-lookup"><span data-stu-id="fcc41-132">Since the <xref:System.Object> class type is the ultimate base class of all the other types, it is the only type that does not have a base type.</span></span> <span data-ttu-id="fcc41-133">在这种情况下，`null`作为的基类型返回`Object`类型。</span><span class="sxs-lookup"><span data-stu-id="fcc41-133">In this case, `null` is returned as the base type of the `Object` type.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FullName">
      <MemberSignature Language="C#" Value="public override string FullName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string FullName" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.TypeDelegator.FullName" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property FullName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ FullName { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="fcc41-134">获取已实现类型的完全限定名。</span><span class="sxs-lookup"><span data-stu-id="fcc41-134">Gets the fully qualified name of the implemented type.</span></span></summary>
        <value><span data-ttu-id="fcc41-135">包含类型的完全限定名的 <see langword="String" />。</span><span class="sxs-lookup"><span data-stu-id="fcc41-135">A <see langword="String" /> containing the type's fully qualified name.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="fcc41-136">包含当前的完全限定的名称的字符串`TypeDelegator`。</span><span class="sxs-lookup"><span data-stu-id="fcc41-136">A string containing the fully qualified name of the current `TypeDelegator`.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetAttributeFlagsImpl">
      <MemberSignature Language="C#" Value="protected override System.Reflection.TypeAttributes GetAttributeFlagsImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance valuetype System.Reflection.TypeAttributes GetAttributeFlagsImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.TypeDelegator.GetAttributeFlagsImpl" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function GetAttributeFlagsImpl () As TypeAttributes" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Reflection::TypeAttributes GetAttributeFlagsImpl();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.TypeAttributes</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="fcc41-137">获取分配给 <see langword="TypeDelegator" /> 的属性。</span><span class="sxs-lookup"><span data-stu-id="fcc41-137">Gets the attributes assigned to the <see langword="TypeDelegator" />.</span></span></summary>
        <returns><span data-ttu-id="fcc41-138">表示实现属性标志的 <see langword="TypeAttributes" /> 对象。</span><span class="sxs-lookup"><span data-stu-id="fcc41-138">A <see langword="TypeAttributes" /> object representing the implementation attribute flags.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="fcc41-139">此方法可以用于确定如果`TypeDelegator`是抽象、 公共的等等。</span><span class="sxs-lookup"><span data-stu-id="fcc41-139">This method can be used to determine if the `TypeDelegator` is abstract, public, and so on.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="GetConstructorImpl">
      <MemberSignature Language="C#" Value="protected override System.Reflection.ConstructorInfo GetConstructorImpl (System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Reflection.ConstructorInfo GetConstructorImpl(valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, valuetype System.Reflection.CallingConventions callConvention, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.TypeDelegator.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Reflection::ConstructorInfo ^ GetConstructorImpl(System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, System::Reflection::CallingConventions callConvention, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="callConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="bindingAttr"><span data-ttu-id="fcc41-140">影响执行搜索的方式的位掩码。</span><span class="sxs-lookup"><span data-stu-id="fcc41-140">A bitmask that affects the way in which the search is conducted.</span></span> <span data-ttu-id="fcc41-141">该值是零个或多个来自 <see cref="T:System.Reflection.BindingFlags" /> 的位标志的组合。</span><span class="sxs-lookup"><span data-stu-id="fcc41-141">The value is a combination of zero or more bit flags from <see cref="T:System.Reflection.BindingFlags" />.</span></span></param>
        <param name="binder"><span data-ttu-id="fcc41-142">一个对象，它使用反射启用绑定、参数类型的强制、成员的调用和 <see langword="MemberInfo" /> 对象的检索。</span><span class="sxs-lookup"><span data-stu-id="fcc41-142">An object that enables the binding, coercion of argument types, invocation of members, and retrieval of <see langword="MemberInfo" /> objects using reflection.</span></span> <span data-ttu-id="fcc41-143">如果 <c>binder</c> 为 <see langword="null" />，则使用默认活页夹。</span><span class="sxs-lookup"><span data-stu-id="fcc41-143">If <c>binder</c> is <see langword="null" />, the default binder is used.</span></span></param>
        <param name="callConvention"><span data-ttu-id="fcc41-144">调用约定。</span><span class="sxs-lookup"><span data-stu-id="fcc41-144">The calling conventions.</span></span></param>
        <param name="types"><span data-ttu-id="fcc41-145"><see langword="Type" /> 类型的数组，包含参数数量、顺序和类型的列表。</span><span class="sxs-lookup"><span data-stu-id="fcc41-145">An array of type <see langword="Type" /> containing a list of the parameter number, order, and types.</span></span> <span data-ttu-id="fcc41-146">类型不能为 <see langword="null" />；使用相应的 <see langword="GetMethod" /> 方法或空数组搜索不带参数的方法。</span><span class="sxs-lookup"><span data-stu-id="fcc41-146">Types cannot be <see langword="null" />; use an appropriate <see langword="GetMethod" /> method or an empty array to search for a method without parameters.</span></span></param>
        <param name="modifiers"><span data-ttu-id="fcc41-147"><see langword="ParameterModifier" /> 类型的数组，它与 <c>types</c> 数组的长度相同，其元素表示与要获取的方法的参数关联的属性。</span><span class="sxs-lookup"><span data-stu-id="fcc41-147">An array of type <see langword="ParameterModifier" /> having the same length as the <c>types</c> array, whose elements represent the attributes associated with the parameters of the method to get.</span></span></param>
        <summary><span data-ttu-id="fcc41-148">获取实现 <see langword="TypeDelegator" /> 的构造函数。</span><span class="sxs-lookup"><span data-stu-id="fcc41-148">Gets the constructor that implemented the <see langword="TypeDelegator" />.</span></span></summary>
        <returns><span data-ttu-id="fcc41-149">此方法的匹配指定判据的 <see langword="ConstructorInfo" /> 对象；如果无法找到匹配项，则为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="fcc41-149">A <see langword="ConstructorInfo" /> object for the method that matches the specified criteria, or <see langword="null" /> if a match cannot be found.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="fcc41-150">`callConvention`参数指示的入口点的调用约定。</span><span class="sxs-lookup"><span data-stu-id="fcc41-150">The `callConvention` parameter indicates the calling convention for the entry point.</span></span> <span data-ttu-id="fcc41-151">如果指定不调用约定，则默认<xref:System.Reflection.CallingConventions>值`Standard`使用。</span><span class="sxs-lookup"><span data-stu-id="fcc41-151">If no calling convention is specified, a default <xref:System.Reflection.CallingConventions> value of `Standard` is used.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.CallingConventions" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.Binder" />
      </Docs>
    </Member>
    <Member MemberName="GetConstructors">
      <MemberSignature Language="C#" Value="public override System.Reflection.ConstructorInfo[] GetConstructors (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.ConstructorInfo[] GetConstructors(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.TypeDelegator.GetConstructors(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetConstructors (bindingAttr As BindingFlags) As ConstructorInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Reflection::ConstructorInfo ^&gt; ^ GetConstructors(System::Reflection::BindingFlags bindingAttr);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr"><span data-ttu-id="fcc41-152">影响执行搜索的方式的位掩码。</span><span class="sxs-lookup"><span data-stu-id="fcc41-152">A bitmask that affects the way in which the search is conducted.</span></span> <span data-ttu-id="fcc41-153">该值是零个或多个来自 <see cref="T:System.Reflection.BindingFlags" /> 的位标志的组合。</span><span class="sxs-lookup"><span data-stu-id="fcc41-153">The value is a combination of zero or more bit flags from <see cref="T:System.Reflection.BindingFlags" />.</span></span></param>
        <summary><span data-ttu-id="fcc41-154">返回 <see cref="T:System.Reflection.ConstructorInfo" /> 对象的数组，这些对象表示为当前 <see cref="T:System.Reflection.TypeDelegator" /> 包装的类型定义的构造函数。</span><span class="sxs-lookup"><span data-stu-id="fcc41-154">Returns an array of <see cref="T:System.Reflection.ConstructorInfo" /> objects representing constructors defined for the type wrapped by the current <see cref="T:System.Reflection.TypeDelegator" />.</span></span></summary>
        <returns><span data-ttu-id="fcc41-155"><see langword="ConstructorInfo" /> 类型的数组，包含为此类定义的指定的构造函数。</span><span class="sxs-lookup"><span data-stu-id="fcc41-155">An array of type <see langword="ConstructorInfo" /> containing the specified constructors defined for this class.</span></span> <span data-ttu-id="fcc41-156">如果未定义任何构造函数，则返回一个空数组。</span><span class="sxs-lookup"><span data-stu-id="fcc41-156">If no constructors are defined, an empty array is returned.</span></span> <span data-ttu-id="fcc41-157">根据指定参数的值，只返回公共构造函数或同时返回公共和非公共构造函数。</span><span class="sxs-lookup"><span data-stu-id="fcc41-157">Depending on the value of a specified parameter, only public constructors or both public and non-public constructors will be returned.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="fcc41-158">类初始值设定项是仅可通过提供`GetMember`， `GetMembers`， `FindMembers`，和`GetConstructors`。</span><span class="sxs-lookup"><span data-stu-id="fcc41-158">Class initializers are available only through `GetMember`, `GetMembers`, `FindMembers`, and `GetConstructors`.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetCustomAttributes">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="fcc41-159">返回为此类型定义的所有自定义属性。</span><span class="sxs-lookup"><span data-stu-id="fcc41-159">Returns all the custom attributes defined for this type.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetCustomAttributes">
      <MemberSignature Language="C#" Value="public override object[] GetCustomAttributes (bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance object[] GetCustomAttributes(bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.TypeDelegator.GetCustomAttributes(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetCustomAttributes (inherit As Boolean) As Object()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Object ^&gt; ^ GetCustomAttributes(bool inherit);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="inherit"><span data-ttu-id="fcc41-160">指定是否搜索此类型的继承链以查找这些属性。</span><span class="sxs-lookup"><span data-stu-id="fcc41-160">Specifies whether to search this type's inheritance chain to find the attributes.</span></span></param>
        <summary><span data-ttu-id="fcc41-161">返回为此类型定义的所有自定义属性，并指定是否搜索此类型的继承链。</span><span class="sxs-lookup"><span data-stu-id="fcc41-161">Returns all the custom attributes defined for this type, specifying whether to search the type's inheritance chain.</span></span></summary>
        <returns><span data-ttu-id="fcc41-162">一个包含为此类型定义的所有自定义属性的对象数组。</span><span class="sxs-lookup"><span data-stu-id="fcc41-162">An array of objects containing all the custom attributes defined for this type.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.TypeLoadException"><span data-ttu-id="fcc41-163">无法加载自定义属性类型。</span><span class="sxs-lookup"><span data-stu-id="fcc41-163">A custom attribute type cannot be loaded.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetCustomAttributes">
      <MemberSignature Language="C#" Value="public override object[] GetCustomAttributes (Type attributeType, bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance object[] GetCustomAttributes(class System.Type attributeType, bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.TypeDelegator.GetCustomAttributes(System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetCustomAttributes (attributeType As Type, inherit As Boolean) As Object()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Object ^&gt; ^ GetCustomAttributes(Type ^ attributeType, bool inherit);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributeType" Type="System.Type" />
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="attributeType"><span data-ttu-id="fcc41-164">由类型标识的自定义属性数组。</span><span class="sxs-lookup"><span data-stu-id="fcc41-164">An array of custom attributes identified by type.</span></span></param>
        <param name="inherit"><span data-ttu-id="fcc41-165">指定是否搜索此类型的继承链以查找这些属性。</span><span class="sxs-lookup"><span data-stu-id="fcc41-165">Specifies whether to search this type's inheritance chain to find the attributes.</span></span></param>
        <summary><span data-ttu-id="fcc41-166">返回由类型标识的自定义属性数组。</span><span class="sxs-lookup"><span data-stu-id="fcc41-166">Returns an array of custom attributes identified by type.</span></span></summary>
        <returns><span data-ttu-id="fcc41-167">一个对象数组，包含此类型中定义的与 <paramref name="attributeType" /> 参数匹配的自定义属性，并指定是否搜索此类型的继承链；如果在此类型上未定义自定义属性，则为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="fcc41-167">An array of objects containing the custom attributes defined in this type that match the <paramref name="attributeType" /> parameter, specifying whether to search the type's inheritance chain, or <see langword="null" /> if no custom attributes are defined on this type.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="fcc41-168"><paramref name="attributeType" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="fcc41-168"><paramref name="attributeType" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.TypeLoadException"><span data-ttu-id="fcc41-169">无法加载自定义属性类型。</span><span class="sxs-lookup"><span data-stu-id="fcc41-169">A custom attribute type cannot be loaded.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetElementType">
      <MemberSignature Language="C#" Value="public override Type GetElementType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Type GetElementType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.TypeDelegator.GetElementType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetElementType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override Type ^ GetElementType();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="fcc41-170">返回由当前数组、指针或 ByRef 包含或引用的对象的 <see cref="T:System.Type" />。</span><span class="sxs-lookup"><span data-stu-id="fcc41-170">Returns the <see cref="T:System.Type" /> of the object encompassed or referred to by the current array, pointer or ByRef.</span></span></summary>
        <returns><span data-ttu-id="fcc41-171">由当前数组、指针或 <see langword="ByRef" /> 包含或引用的对象的 <see cref="T:System.Type" />；如果当前 <see cref="T:System.Type" /> 不是数组、指针或 <see langword="null" />，则为 <see langword="ByRef" />。</span><span class="sxs-lookup"><span data-stu-id="fcc41-171">The <see cref="T:System.Type" /> of the object encompassed or referred to by the current array, pointer or <see langword="ByRef" />, or <see langword="null" /> if the current <see cref="T:System.Type" /> is not an array, a pointer or a <see langword="ByRef" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetEvent">
      <MemberSignature Language="C#" Value="public override System.Reflection.EventInfo GetEvent (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.EventInfo GetEvent(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.TypeDelegator.GetEvent(System.String,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetEvent (name As String, bindingAttr As BindingFlags) As EventInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Reflection::EventInfo ^ GetEvent(System::String ^ name, System::Reflection::BindingFlags bindingAttr);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.EventInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="fcc41-172">要获取的事件的名称。</span><span class="sxs-lookup"><span data-stu-id="fcc41-172">The name of the event to get.</span></span></param>
        <param name="bindingAttr"><span data-ttu-id="fcc41-173">影响执行搜索的方式的位掩码。</span><span class="sxs-lookup"><span data-stu-id="fcc41-173">A bitmask that affects the way in which the search is conducted.</span></span> <span data-ttu-id="fcc41-174">该值是零个或多个来自 <see cref="T:System.Reflection.BindingFlags" /> 的位标志的组合。</span><span class="sxs-lookup"><span data-stu-id="fcc41-174">The value is a combination of zero or more bit flags from <see cref="T:System.Reflection.BindingFlags" />.</span></span></param>
        <summary><span data-ttu-id="fcc41-175">返回指定事件。</span><span class="sxs-lookup"><span data-stu-id="fcc41-175">Returns the specified event.</span></span></summary>
        <returns><span data-ttu-id="fcc41-176"><see cref="T:System.Reflection.EventInfo" /> 对象，表示由此类型声明或继承的具有指定名称的事件。</span><span class="sxs-lookup"><span data-stu-id="fcc41-176">An <see cref="T:System.Reflection.EventInfo" /> object representing the event declared or inherited by this type with the specified name.</span></span> <span data-ttu-id="fcc41-177">如果未找到此类事件，则此方法返回 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="fcc41-177">This method returns <see langword="null" /> if no such event is found.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="fcc41-178">如果`bindingAttr`是<xref:System.Reflection.BindingFlags>。`IgnoreCase`、 用例`name`参数将被忽略。</span><span class="sxs-lookup"><span data-stu-id="fcc41-178">If `bindingAttr` is <xref:System.Reflection.BindingFlags>.`IgnoreCase`, the case of the `name` parameter is ignored.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="fcc41-179"><paramref name="name" /> 参数为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="fcc41-179">The <paramref name="name" /> parameter is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetEvents">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="fcc41-180">返回 <see cref="T:System.Reflection.EventInfo" /> 对象的数组，这些对象表示由当前 <see langword="TypeDelegator" /> 声明或继承的所有公共事件。</span><span class="sxs-lookup"><span data-stu-id="fcc41-180">Returns an array of <see cref="T:System.Reflection.EventInfo" /> objects representing all the public events declared or inherited by the current <see langword="TypeDelegator" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetEvents">
      <MemberSignature Language="C#" Value="public override System.Reflection.EventInfo[] GetEvents ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.EventInfo[] GetEvents() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.TypeDelegator.GetEvents" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetEvents () As EventInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Reflection::EventInfo ^&gt; ^ GetEvents();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.EventInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="fcc41-181">返回 <see cref="T:System.Reflection.EventInfo" /> 对象的数组，这些对象表示由当前 <see langword="TypeDelegator" /> 声明或继承的所有公共事件。</span><span class="sxs-lookup"><span data-stu-id="fcc41-181">Returns an array of <see cref="T:System.Reflection.EventInfo" /> objects representing all the public events declared or inherited by the current <see langword="TypeDelegator" />.</span></span></summary>
        <returns><span data-ttu-id="fcc41-182">返回 <see langword="EventInfo" /> 类型的数组，该数组包含由当前类型声明或继承的所有事件。</span><span class="sxs-lookup"><span data-stu-id="fcc41-182">Returns an array of type <see langword="EventInfo" /> containing all the events declared or inherited by the current type.</span></span> <span data-ttu-id="fcc41-183">如果没有事件，则返回空数组。</span><span class="sxs-lookup"><span data-stu-id="fcc41-183">If there are no events, an empty array is returned.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetEvents">
      <MemberSignature Language="C#" Value="public override System.Reflection.EventInfo[] GetEvents (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.EventInfo[] GetEvents(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.TypeDelegator.GetEvents(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetEvents (bindingAttr As BindingFlags) As EventInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Reflection::EventInfo ^&gt; ^ GetEvents(System::Reflection::BindingFlags bindingAttr);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.EventInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr"><span data-ttu-id="fcc41-184">影响执行搜索的方式的位掩码。</span><span class="sxs-lookup"><span data-stu-id="fcc41-184">A bitmask that affects the way in which the search is conducted.</span></span> <span data-ttu-id="fcc41-185">该值是零个或多个来自 <see cref="T:System.Reflection.BindingFlags" /> 的位标志的组合。</span><span class="sxs-lookup"><span data-stu-id="fcc41-185">The value is a combination of zero or more bit flags from <see cref="T:System.Reflection.BindingFlags" />.</span></span></param>
        <summary><span data-ttu-id="fcc41-186">返回 <paramref name="bindingAttr" /> 中指定的由当前 <see langword="TypeDelegator" /> 声明或继承的事件。</span><span class="sxs-lookup"><span data-stu-id="fcc41-186">Returns the events specified in <paramref name="bindingAttr" /> that are declared or inherited by the current <see langword="TypeDelegator" />.</span></span></summary>
        <returns><span data-ttu-id="fcc41-187"><see langword="EventInfo" /> 类型的数组，包含 <paramref name="bindingAttr" /> 中指定的事件。</span><span class="sxs-lookup"><span data-stu-id="fcc41-187">An array of type <see langword="EventInfo" /> containing the events specified in <paramref name="bindingAttr" />.</span></span> <span data-ttu-id="fcc41-188">如果没有事件，则返回空数组。</span><span class="sxs-lookup"><span data-stu-id="fcc41-188">If there are no events, an empty array is returned.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetField">
      <MemberSignature Language="C#" Value="public override System.Reflection.FieldInfo GetField (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.FieldInfo GetField(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.TypeDelegator.GetField(System.String,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetField (name As String, bindingAttr As BindingFlags) As FieldInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Reflection::FieldInfo ^ GetField(System::String ^ name, System::Reflection::BindingFlags bindingAttr);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="fcc41-189">要查找的字段的名称。</span><span class="sxs-lookup"><span data-stu-id="fcc41-189">The name of the field to find.</span></span></param>
        <param name="bindingAttr"><span data-ttu-id="fcc41-190">影响执行搜索的方式的位掩码。</span><span class="sxs-lookup"><span data-stu-id="fcc41-190">A bitmask that affects the way in which the search is conducted.</span></span> <span data-ttu-id="fcc41-191">该值是零个或多个来自 <see cref="T:System.Reflection.BindingFlags" /> 的位标志的组合。</span><span class="sxs-lookup"><span data-stu-id="fcc41-191">The value is a combination of zero or more bit flags from <see cref="T:System.Reflection.BindingFlags" />.</span></span></param>
        <summary><span data-ttu-id="fcc41-192">返回 <see cref="T:System.Reflection.FieldInfo" /> 对象，该对象表示具有指定名称的字段。</span><span class="sxs-lookup"><span data-stu-id="fcc41-192">Returns a <see cref="T:System.Reflection.FieldInfo" /> object representing the field with the specified name.</span></span></summary>
        <returns><span data-ttu-id="fcc41-193"><see langword="FieldInfo" /> 对象，表示由此 <see langword="TypeDelegator" /> 声明或继承的具有指定名称的字段。</span><span class="sxs-lookup"><span data-stu-id="fcc41-193">A <see langword="FieldInfo" /> object representing the field declared or inherited by this <see langword="TypeDelegator" /> with the specified name.</span></span> <span data-ttu-id="fcc41-194">如果未找到这样的字段，则返回 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="fcc41-194">Returns <see langword="null" /> if no such field is found.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="fcc41-195">使用`bindingAttr`的<xref:System.Reflection.BindingFlags>。非公开返回所有的公共和非公共字段。</span><span class="sxs-lookup"><span data-stu-id="fcc41-195">Use a `bindingAttr` of <xref:System.Reflection.BindingFlags>.NonPublic to return all public and nonpublic fields.</span></span> <span data-ttu-id="fcc41-196">使用`BindingFlags.IgnoreCase`若要忽略的字段，这种情况，如搜索不区分大小写，默认情况下。</span><span class="sxs-lookup"><span data-stu-id="fcc41-196">Use `BindingFlags.IgnoreCase` to ignore the case of the fields, as the search is case-sensitive by default.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="fcc41-197"><paramref name="name" /> 参数为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="fcc41-197">The <paramref name="name" /> parameter is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetFields">
      <MemberSignature Language="C#" Value="public override System.Reflection.FieldInfo[] GetFields (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.FieldInfo[] GetFields(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.TypeDelegator.GetFields(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetFields (bindingAttr As BindingFlags) As FieldInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Reflection::FieldInfo ^&gt; ^ GetFields(System::Reflection::BindingFlags bindingAttr);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr"><span data-ttu-id="fcc41-198">影响执行搜索的方式的位掩码。</span><span class="sxs-lookup"><span data-stu-id="fcc41-198">A bitmask that affects the way in which the search is conducted.</span></span> <span data-ttu-id="fcc41-199">该值是零个或多个来自 <see cref="T:System.Reflection.BindingFlags" /> 的位标志的组合。</span><span class="sxs-lookup"><span data-stu-id="fcc41-199">The value is a combination of zero or more bit flags from <see cref="T:System.Reflection.BindingFlags" />.</span></span></param>
        <summary><span data-ttu-id="fcc41-200">返回 <see cref="T:System.Reflection.FieldInfo" /> 对象的数组，这些对象表示为当前 <see cref="T:System.Reflection.TypeDelegator" /> 包装的类型定义的数据字段。</span><span class="sxs-lookup"><span data-stu-id="fcc41-200">Returns an array of <see cref="T:System.Reflection.FieldInfo" /> objects representing the data fields defined for the type wrapped by the current <see cref="T:System.Reflection.TypeDelegator" />.</span></span></summary>
        <returns><span data-ttu-id="fcc41-201"><see langword="FieldInfo" /> 类型的数组，包含由当前 <see langword="TypeDelegator" /> 声明或继承的字段。</span><span class="sxs-lookup"><span data-stu-id="fcc41-201">An array of type <see langword="FieldInfo" /> containing the fields declared or inherited by the current <see langword="TypeDelegator" />.</span></span> <span data-ttu-id="fcc41-202">如果没有匹配的字段，则返回空数组。</span><span class="sxs-lookup"><span data-stu-id="fcc41-202">An empty array is returned if there are no matched fields.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="fcc41-203"><xref:System.Reflection.TypeDelegator.GetFields%2A>方法不返回字段按特定的顺序，如按字母顺序排列或声明顺序排列。</span><span class="sxs-lookup"><span data-stu-id="fcc41-203">The <xref:System.Reflection.TypeDelegator.GetFields%2A> method does not return fields in a particular order, such as alphabetical or declaration order.</span></span> <span data-ttu-id="fcc41-204">因为该顺序可能会变化，你的代码必须不依赖于字段的返回顺序。</span><span class="sxs-lookup"><span data-stu-id="fcc41-204">Your code must not depend on the order in which fields are returned, because that order can vary.</span></span>  
  
 <span data-ttu-id="fcc41-205">使用`bindingAttr`的<xref:System.Reflection.BindingFlags>。非公开返回所有的公共和非公共字段。</span><span class="sxs-lookup"><span data-stu-id="fcc41-205">Use a `bindingAttr` of <xref:System.Reflection.BindingFlags>.NonPublic to return all public and nonpublic fields.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetInterface">
      <MemberSignature Language="C#" Value="public override Type GetInterface (string name, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Type GetInterface(string name, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.TypeDelegator.GetInterface(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetInterface (name As String, ignoreCase As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override Type ^ GetInterface(System::String ^ name, bool ignoreCase);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="fcc41-206">由当前类实现的接口的完全限定名。</span><span class="sxs-lookup"><span data-stu-id="fcc41-206">The fully qualified name of the interface implemented by the current class.</span></span></param>
        <param name="ignoreCase">
          <span data-ttu-id="fcc41-207">如果忽略大小写，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="fcc41-207"><see langword="true" /> if the case is to be ignored; otherwise, <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="fcc41-208">返回由当前 <see cref="T:System.Reflection.TypeDelegator" /> 包装的类型实现的指定接口。</span><span class="sxs-lookup"><span data-stu-id="fcc41-208">Returns the specified interface implemented by the type wrapped by the current <see cref="T:System.Reflection.TypeDelegator" />.</span></span></summary>
        <returns><span data-ttu-id="fcc41-209"><see langword="Type" /> 对象，表示由当前类（直接或间接）实现的具有匹配指定名称的完全限定名的接口。</span><span class="sxs-lookup"><span data-stu-id="fcc41-209">A <see langword="Type" /> object representing the interface implemented (directly or indirectly) by the current class with the fully qualified name matching the specified name.</span></span> <span data-ttu-id="fcc41-210">如果未找到匹配名称的接口，则返回 null。</span><span class="sxs-lookup"><span data-stu-id="fcc41-210">If no interface that matches name is found, null is returned.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="fcc41-211"><paramref name="name" /> 参数为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="fcc41-211">The <paramref name="name" /> parameter is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetInterfaceMap">
      <MemberSignature Language="C#" Value="public override System.Reflection.InterfaceMapping GetInterfaceMap (Type interfaceType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance valuetype System.Reflection.InterfaceMapping GetInterfaceMap(class System.Type interfaceType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.TypeDelegator.GetInterfaceMap(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetInterfaceMap (interfaceType As Type) As InterfaceMapping" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Reflection::InterfaceMapping GetInterfaceMap(Type ^ interfaceType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.InterfaceMapping</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="interfaceType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="interfaceType"><span data-ttu-id="fcc41-212">要检索其映射的接口的 <see cref="T:System.Type" />。</span><span class="sxs-lookup"><span data-stu-id="fcc41-212">The <see cref="T:System.Type" /> of the interface to retrieve a mapping of.</span></span></param>
        <summary><span data-ttu-id="fcc41-213">返回指定接口类型的接口映射。</span><span class="sxs-lookup"><span data-stu-id="fcc41-213">Returns an interface mapping for the specified interface type.</span></span></summary>
        <returns><span data-ttu-id="fcc41-214">表示 <paramref name="interfaceType" /> 的接口映射的 <see cref="T:System.Reflection.InterfaceMapping" /> 对象。</span><span class="sxs-lookup"><span data-stu-id="fcc41-214">An <see cref="T:System.Reflection.InterfaceMapping" /> object representing the interface mapping for <paramref name="interfaceType" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="fcc41-215">接口映射表示接口到实现该接口的类上的实际方法的映射方式。</span><span class="sxs-lookup"><span data-stu-id="fcc41-215">The interface map denotes how an interface is mapped into the actual methods on a class that implements that interface.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.InterfaceMapping" />
      </Docs>
    </Member>
    <Member MemberName="GetInterfaces">
      <MemberSignature Language="C#" Value="public override Type[] GetInterfaces ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Type[] GetInterfaces() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.TypeDelegator.GetInterfaces" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetInterfaces () As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;Type ^&gt; ^ GetInterfaces();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="fcc41-216">返回在当前类及其基类上实现的所有接口。</span><span class="sxs-lookup"><span data-stu-id="fcc41-216">Returns all the interfaces implemented on the current class and its base classes.</span></span></summary>
        <returns><span data-ttu-id="fcc41-217"><see langword="Type" /> 类型的数组，包含在当前类及其基类上实现的所有接口。</span><span class="sxs-lookup"><span data-stu-id="fcc41-217">An array of type <see langword="Type" /> containing all the interfaces implemented on the current class and its base classes.</span></span> <span data-ttu-id="fcc41-218">如果未定义任何内容，则返回一个空数组。</span><span class="sxs-lookup"><span data-stu-id="fcc41-218">If none are defined, an empty array is returned.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMember">
      <MemberSignature Language="C#" Value="public override System.Reflection.MemberInfo[] GetMember (string name, System.Reflection.MemberTypes type, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.MemberInfo[] GetMember(string name, valuetype System.Reflection.MemberTypes type, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.TypeDelegator.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetMember (name As String, type As MemberTypes, bindingAttr As BindingFlags) As MemberInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Reflection::MemberInfo ^&gt; ^ GetMember(System::String ^ name, System::Reflection::MemberTypes type, System::Reflection::BindingFlags bindingAttr);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="type" Type="System.Reflection.MemberTypes" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="fcc41-219">要获取的成员名称。</span><span class="sxs-lookup"><span data-stu-id="fcc41-219">The name of the member to get.</span></span></param>
        <param name="type"><span data-ttu-id="fcc41-220">影响执行搜索的方式的位掩码。</span><span class="sxs-lookup"><span data-stu-id="fcc41-220">A bitmask that affects the way in which the search is conducted.</span></span> <span data-ttu-id="fcc41-221">该值是零个或多个来自 <see cref="T:System.Reflection.BindingFlags" /> 的位标志的组合。</span><span class="sxs-lookup"><span data-stu-id="fcc41-221">The value is a combination of zero or more bit flags from <see cref="T:System.Reflection.BindingFlags" />.</span></span></param>
        <param name="bindingAttr"><span data-ttu-id="fcc41-222">要获取的成员类型。</span><span class="sxs-lookup"><span data-stu-id="fcc41-222">The type of members to get.</span></span></param>
        <summary><span data-ttu-id="fcc41-223">返回由给定的 <paramref name="name" />、<paramref name="type" /> 和 <paramref name="bindingAttr" /> 指定的成员（属性、方法、构造函数、字段、事件和嵌套类型）。</span><span class="sxs-lookup"><span data-stu-id="fcc41-223">Returns members (properties, methods, constructors, fields, events, and nested types) specified by the given <paramref name="name" />, <paramref name="type" />, and <paramref name="bindingAttr" />.</span></span></summary>
        <returns><span data-ttu-id="fcc41-224"><see langword="MemberInfo" /> 类型的数组，包含当前类及其基类的符合指定条件的所有成员。</span><span class="sxs-lookup"><span data-stu-id="fcc41-224">An array of type <see langword="MemberInfo" /> containing all the members of the current class and its base class meeting the specified criteria.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="fcc41-225">如果`bindingAttr`是<xref:System.Reflection.BindingFlags>。非公开的所有成员将被都视为。</span><span class="sxs-lookup"><span data-stu-id="fcc41-225">If `bindingAttr` is <xref:System.Reflection.BindingFlags>.NonPublic, all the members will be considered.</span></span> <span data-ttu-id="fcc41-226">如果没有匹配项，则返回一个空数组。</span><span class="sxs-lookup"><span data-stu-id="fcc41-226">If there are no matches, an empty array is returned.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="fcc41-227"><paramref name="name" /> 参数为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="fcc41-227">The <paramref name="name" /> parameter is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetMembers">
      <MemberSignature Language="C#" Value="public override System.Reflection.MemberInfo[] GetMembers (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.MemberInfo[] GetMembers(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.TypeDelegator.GetMembers(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetMembers (bindingAttr As BindingFlags) As MemberInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Reflection::MemberInfo ^&gt; ^ GetMembers(System::Reflection::BindingFlags bindingAttr);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr"><span data-ttu-id="fcc41-228">影响执行搜索的方式的位掩码。</span><span class="sxs-lookup"><span data-stu-id="fcc41-228">A bitmask that affects the way in which the search is conducted.</span></span> <span data-ttu-id="fcc41-229">该值是零个或多个来自 <see cref="T:System.Reflection.BindingFlags" /> 的位标志的组合。</span><span class="sxs-lookup"><span data-stu-id="fcc41-229">The value is a combination of zero or more bit flags from <see cref="T:System.Reflection.BindingFlags" />.</span></span></param>
        <summary><span data-ttu-id="fcc41-230">返回由 <paramref name="bindingAttr" /> 指定的成员。</span><span class="sxs-lookup"><span data-stu-id="fcc41-230">Returns members specified by <paramref name="bindingAttr" />.</span></span></summary>
        <returns><span data-ttu-id="fcc41-231"><see langword="MemberInfo" /> 类型的数组，包含当前类及其基类的符合 <paramref name="bindingAttr" /> 筛选器的所有成员。</span><span class="sxs-lookup"><span data-stu-id="fcc41-231">An array of type <see langword="MemberInfo" /> containing all the members of the current class and its base classes that meet the <paramref name="bindingAttr" /> filter.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="fcc41-232">如果`bindingAttr`是<xref:System.Reflection.BindingFlags>。非公开的所有成员将被都视为。</span><span class="sxs-lookup"><span data-stu-id="fcc41-232">If `bindingAttr` is <xref:System.Reflection.BindingFlags>.NonPublic, all the members will be considered.</span></span> <span data-ttu-id="fcc41-233">如果没有匹配项，则返回一个空数组。</span><span class="sxs-lookup"><span data-stu-id="fcc41-233">If there are no matches, an empty array is returned.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMethodImpl">
      <MemberSignature Language="C#" Value="protected override System.Reflection.MethodInfo GetMethodImpl (string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Reflection.MethodInfo GetMethodImpl(string name, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, valuetype System.Reflection.CallingConventions callConvention, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.TypeDelegator.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Reflection::MethodInfo ^ GetMethodImpl(System::String ^ name, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, System::Reflection::CallingConventions callConvention, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="callConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="fcc41-234">方法名。</span><span class="sxs-lookup"><span data-stu-id="fcc41-234">The method name.</span></span></param>
        <param name="bindingAttr"><span data-ttu-id="fcc41-235">影响执行搜索的方式的位掩码。</span><span class="sxs-lookup"><span data-stu-id="fcc41-235">A bitmask that affects the way in which the search is conducted.</span></span> <span data-ttu-id="fcc41-236">该值是零个或多个来自 <see cref="T:System.Reflection.BindingFlags" /> 的位标志的组合。</span><span class="sxs-lookup"><span data-stu-id="fcc41-236">The value is a combination of zero or more bit flags from <see cref="T:System.Reflection.BindingFlags" />.</span></span></param>
        <param name="binder"><span data-ttu-id="fcc41-237">一个对象，它使用反射启用绑定、参数类型的强制、成员的调用和 <see langword="MemberInfo" /> 对象的检索。</span><span class="sxs-lookup"><span data-stu-id="fcc41-237">An object that enables the binding, coercion of argument types, invocation of members, and retrieval of <see langword="MemberInfo" /> objects using reflection.</span></span> <span data-ttu-id="fcc41-238">如果 <c>binder</c> 为 <see langword="null" />，则使用默认活页夹。</span><span class="sxs-lookup"><span data-stu-id="fcc41-238">If <c>binder</c> is <see langword="null" />, the default binder is used.</span></span></param>
        <param name="callConvention"><span data-ttu-id="fcc41-239">调用约定。</span><span class="sxs-lookup"><span data-stu-id="fcc41-239">The calling conventions.</span></span></param>
        <param name="types"><span data-ttu-id="fcc41-240"><see langword="Type" /> 类型的数组，包含参数数量、顺序和类型的列表。</span><span class="sxs-lookup"><span data-stu-id="fcc41-240">An array of type <see langword="Type" /> containing a list of the parameter number, order, and types.</span></span> <span data-ttu-id="fcc41-241">类型不能为 <see langword="null" />；使用相应的 <see langword="GetMethod" /> 方法或空数组搜索不带参数的方法。</span><span class="sxs-lookup"><span data-stu-id="fcc41-241">Types cannot be <see langword="null" />; use an appropriate <see langword="GetMethod" /> method or an empty array to search for a method without parameters.</span></span></param>
        <param name="modifiers"><span data-ttu-id="fcc41-242"><see langword="ParameterModifier" /> 类型的数组，它与 <c>types</c> 数组的长度相同，其元素表示与要获取的方法的参数关联的属性。</span><span class="sxs-lookup"><span data-stu-id="fcc41-242">An array of type <see langword="ParameterModifier" /> having the same length as the <c>types</c> array, whose elements represent the attributes associated with the parameters of the method to get.</span></span></param>
        <summary><span data-ttu-id="fcc41-243">用指定的绑定约束和指定的调用约定，搜索参数与指定的自变量类型及修饰符相匹配的指定方法。</span><span class="sxs-lookup"><span data-stu-id="fcc41-243">Searches for the specified method whose parameters match the specified argument types and modifiers, using the specified binding constraints and the specified calling convention.</span></span></summary>
        <returns><span data-ttu-id="fcc41-244">匹配指定条件的实现方法的 <see langword="MethodInfoInfo" /> 对象；如果无法找到匹配项，则为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="fcc41-244">A <see langword="MethodInfoInfo" /> object for the implementation method that matches the specified criteria, or <see langword="null" /> if a match cannot be found.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="fcc41-245">`callConvention`参数指示的入口点的调用约定。</span><span class="sxs-lookup"><span data-stu-id="fcc41-245">The `callConvention` parameter indicates the calling convention for the entry point.</span></span> <span data-ttu-id="fcc41-246">如果没有<xref:System.Reflection.CallingConventions>指定，则默认`CallingConventions`值`Standard`使用。</span><span class="sxs-lookup"><span data-stu-id="fcc41-246">If no <xref:System.Reflection.CallingConventions> is specified, a default `CallingConventions` value of `Standard` is used.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.CallingConventions" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.Binder" />
      </Docs>
    </Member>
    <Member MemberName="GetMethods">
      <MemberSignature Language="C#" Value="public override System.Reflection.MethodInfo[] GetMethods (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.MethodInfo[] GetMethods(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.TypeDelegator.GetMethods(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetMethods (bindingAttr As BindingFlags) As MethodInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Reflection::MethodInfo ^&gt; ^ GetMethods(System::Reflection::BindingFlags bindingAttr);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr"><span data-ttu-id="fcc41-247">影响执行搜索的方式的位掩码。</span><span class="sxs-lookup"><span data-stu-id="fcc41-247">A bitmask that affects the way in which the search is conducted.</span></span> <span data-ttu-id="fcc41-248">该值是零个或多个来自 <see cref="T:System.Reflection.BindingFlags" /> 的位标志的组合。</span><span class="sxs-lookup"><span data-stu-id="fcc41-248">The value is a combination of zero or more bit flags from <see cref="T:System.Reflection.BindingFlags" />.</span></span></param>
        <summary><span data-ttu-id="fcc41-249">返回 <see cref="T:System.Reflection.MethodInfo" /> 对象的数组，这些对象表示由当前 <see cref="T:System.Reflection.TypeDelegator" /> 包装的类型的指定方法。</span><span class="sxs-lookup"><span data-stu-id="fcc41-249">Returns an array of <see cref="T:System.Reflection.MethodInfo" /> objects representing specified methods of the type wrapped by the current <see cref="T:System.Reflection.TypeDelegator" />.</span></span></summary>
        <returns><span data-ttu-id="fcc41-250"><see langword="MethodInfo" /> 对象的数组，表示在此 <see langword="TypeDelegator" /> 上定义的方法。</span><span class="sxs-lookup"><span data-stu-id="fcc41-250">An array of <see langword="MethodInfo" /> objects representing the methods defined on this <see langword="TypeDelegator" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetNestedType">
      <MemberSignature Language="C#" Value="public override Type GetNestedType (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Type GetNestedType(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.TypeDelegator.GetNestedType(System.String,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetNestedType (name As String, bindingAttr As BindingFlags) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override Type ^ GetNestedType(System::String ^ name, System::Reflection::BindingFlags bindingAttr);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="fcc41-251">嵌套类型的名称。</span><span class="sxs-lookup"><span data-stu-id="fcc41-251">The nested type's name.</span></span></param>
        <param name="bindingAttr"><span data-ttu-id="fcc41-252">影响执行搜索的方式的位掩码。</span><span class="sxs-lookup"><span data-stu-id="fcc41-252">A bitmask that affects the way in which the search is conducted.</span></span> <span data-ttu-id="fcc41-253">该值是零个或多个来自 <see cref="T:System.Reflection.BindingFlags" /> 的位标志的组合。</span><span class="sxs-lookup"><span data-stu-id="fcc41-253">The value is a combination of zero or more bit flags from <see cref="T:System.Reflection.BindingFlags" />.</span></span></param>
        <summary><span data-ttu-id="fcc41-254">返回由 <paramref name="name" /> 指定的嵌套类型，并且该嵌套类型是在 <paramref name="bindingAttr" /> 中指定的、由当前 <see cref="T:System.Reflection.TypeDelegator" /> 表示的类型来声明或继承。</span><span class="sxs-lookup"><span data-stu-id="fcc41-254">Returns a nested type specified by <paramref name="name" /> and in <paramref name="bindingAttr" /> that are declared or inherited by the type represented by the current <see cref="T:System.Reflection.TypeDelegator" />.</span></span></summary>
        <returns><span data-ttu-id="fcc41-255">表示嵌套类型的 <see langword="Type" /> 对象。</span><span class="sxs-lookup"><span data-stu-id="fcc41-255">A <see langword="Type" /> object representing the nested type.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="fcc41-256"><paramref name="name" /> 参数为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="fcc41-256">The <paramref name="name" /> parameter is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetNestedTypes">
      <MemberSignature Language="C#" Value="public override Type[] GetNestedTypes (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Type[] GetNestedTypes(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.TypeDelegator.GetNestedTypes(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetNestedTypes (bindingAttr As BindingFlags) As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;Type ^&gt; ^ GetNestedTypes(System::Reflection::BindingFlags bindingAttr);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr"><span data-ttu-id="fcc41-257">影响执行搜索的方式的位掩码。</span><span class="sxs-lookup"><span data-stu-id="fcc41-257">A bitmask that affects the way in which the search is conducted.</span></span> <span data-ttu-id="fcc41-258">该值是零个或多个来自 <see cref="T:System.Reflection.BindingFlags" /> 的位标志的组合。</span><span class="sxs-lookup"><span data-stu-id="fcc41-258">The value is a combination of zero or more bit flags from <see cref="T:System.Reflection.BindingFlags" />.</span></span></param>
        <summary><span data-ttu-id="fcc41-259">返回嵌套类型，这些嵌套类型是在 <paramref name="bindingAttr" /> 中指定的，并且由当前 <see cref="T:System.Reflection.TypeDelegator" /> 包装的类型来声明或继承。</span><span class="sxs-lookup"><span data-stu-id="fcc41-259">Returns the nested types specified in <paramref name="bindingAttr" /> that are declared or inherited by the type wrapped by the current <see cref="T:System.Reflection.TypeDelegator" />.</span></span></summary>
        <returns><span data-ttu-id="fcc41-260">包含嵌套类型的 <see langword="Type" /> 类型数组。</span><span class="sxs-lookup"><span data-stu-id="fcc41-260">An array of type <see langword="Type" /> containing the nested types.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetProperties">
      <MemberSignature Language="C#" Value="public override System.Reflection.PropertyInfo[] GetProperties (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.PropertyInfo[] GetProperties(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.TypeDelegator.GetProperties(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetProperties (bindingAttr As BindingFlags) As PropertyInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Reflection::PropertyInfo ^&gt; ^ GetProperties(System::Reflection::BindingFlags bindingAttr);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr"><span data-ttu-id="fcc41-261">影响执行搜索的方式的位掩码。</span><span class="sxs-lookup"><span data-stu-id="fcc41-261">A bitmask that affects the way in which the search is conducted.</span></span> <span data-ttu-id="fcc41-262">该值是零个或多个来自 <see cref="T:System.Reflection.BindingFlags" /> 的位标志的组合。</span><span class="sxs-lookup"><span data-stu-id="fcc41-262">The value is a combination of zero or more bit flags from <see cref="T:System.Reflection.BindingFlags" />.</span></span></param>
        <summary><span data-ttu-id="fcc41-263">返回 <see cref="T:System.Reflection.PropertyInfo" /> 对象的数组，这些对象表示由当前 <see cref="T:System.Reflection.TypeDelegator" /> 包装的类型的属性。</span><span class="sxs-lookup"><span data-stu-id="fcc41-263">Returns an array of <see cref="T:System.Reflection.PropertyInfo" /> objects representing properties of the type wrapped by the current <see cref="T:System.Reflection.TypeDelegator" />.</span></span></summary>
        <returns><span data-ttu-id="fcc41-264"><see langword="PropertyInfo" /> 对象的数组，表示在此 <see langword="TypeDelegator" /> 上定义的属性。</span><span class="sxs-lookup"><span data-stu-id="fcc41-264">An array of <see langword="PropertyInfo" /> objects representing properties defined on this <see langword="TypeDelegator" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetPropertyImpl">
      <MemberSignature Language="C#" Value="protected override System.Reflection.PropertyInfo GetPropertyImpl (string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, Type returnType, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Reflection.PropertyInfo GetPropertyImpl(string name, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, class System.Type returnType, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.TypeDelegator.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Reflection::PropertyInfo ^ GetPropertyImpl(System::String ^ name, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, Type ^ returnType, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="fcc41-265">要获取的属性。</span><span class="sxs-lookup"><span data-stu-id="fcc41-265">The property to get.</span></span></param>
        <param name="bindingAttr"><span data-ttu-id="fcc41-266">影响执行搜索的方式的位掩码。</span><span class="sxs-lookup"><span data-stu-id="fcc41-266">A bitmask that affects the way in which the search is conducted.</span></span> <span data-ttu-id="fcc41-267">该值是零个或多个来自 <see cref="T:System.Reflection.BindingFlags" /> 的位标志的组合。</span><span class="sxs-lookup"><span data-stu-id="fcc41-267">The value is a combination of zero or more bit flags from <see cref="T:System.Reflection.BindingFlags" />.</span></span></param>
        <param name="binder"><span data-ttu-id="fcc41-268">一个对象，它启用绑定、对参数类型的强制、对成员的调用，以及通过反射对 <see langword="MemberInfo" /> 对象的检索。</span><span class="sxs-lookup"><span data-stu-id="fcc41-268">An object that enables the binding, coercion of argument types, invocation of members, and retrieval of <see langword="MemberInfo" /> objects via reflection.</span></span> <span data-ttu-id="fcc41-269">如果 <c>binder</c> 为 <see langword="null" />，则使用默认活页夹。</span><span class="sxs-lookup"><span data-stu-id="fcc41-269">If <c>binder</c> is <see langword="null" />, the default binder is used.</span></span> <span data-ttu-id="fcc41-270">请参阅 <see cref="T:System.Reflection.Binder" />。</span><span class="sxs-lookup"><span data-stu-id="fcc41-270">See <see cref="T:System.Reflection.Binder" />.</span></span></param>
        <param name="returnType"><span data-ttu-id="fcc41-271">属性的返回类型。</span><span class="sxs-lookup"><span data-stu-id="fcc41-271">The return type of the property.</span></span></param>
        <param name="types"><span data-ttu-id="fcc41-272">参数类型的列表。</span><span class="sxs-lookup"><span data-stu-id="fcc41-272">A list of parameter types.</span></span> <span data-ttu-id="fcc41-273">此列表表示参数的数目、顺序和类型。</span><span class="sxs-lookup"><span data-stu-id="fcc41-273">The list represents the number, order, and types of the parameters.</span></span> <span data-ttu-id="fcc41-274">类型不能为 null；使用相应的 <see langword="GetMethod" /> 方法或空数组搜索不带参数的方法。</span><span class="sxs-lookup"><span data-stu-id="fcc41-274">Types cannot be null; use an appropriate <see langword="GetMethod" /> method or an empty array to search for a method without parameters.</span></span></param>
        <param name="modifiers"><span data-ttu-id="fcc41-275">长度与 types 相同的数组，其元素表示与要获取的方法参数关联的属性。</span><span class="sxs-lookup"><span data-stu-id="fcc41-275">An array of the same length as types with elements that represent the attributes associated with the parameters of the method to get.</span></span></param>
        <summary><span data-ttu-id="fcc41-276">当在派生类中重写时，使用指定的绑定约束搜索其参数与指定的自变量类型和修饰符匹配的指定属性。</span><span class="sxs-lookup"><span data-stu-id="fcc41-276">When overridden in a derived class, searches for the specified property whose parameters match the specified argument types and modifiers, using the specified binding constraints.</span></span></summary>
        <returns><span data-ttu-id="fcc41-277">此属性的匹配指定条件的 <see cref="T:System.Reflection.PropertyInfo" /> 对象；如果无法找到匹配，则为 null。</span><span class="sxs-lookup"><span data-stu-id="fcc41-277">A <see cref="T:System.Reflection.PropertyInfo" /> object for the property that matches the specified criteria, or null if a match cannot be found.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GUID">
      <MemberSignature Language="C#" Value="public override Guid GUID { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Guid GUID" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.TypeDelegator.GUID" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property GUID As Guid" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Guid GUID { Guid get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Guid</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="fcc41-278">获取已实现类型的 GUID（全局唯一标识符）。</span><span class="sxs-lookup"><span data-stu-id="fcc41-278">Gets the GUID (globally unique identifier) of the implemented type.</span></span></summary>
        <value><span data-ttu-id="fcc41-279">一个 GUID。</span><span class="sxs-lookup"><span data-stu-id="fcc41-279">A GUID.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="fcc41-280">GUID （全局唯一标识符） 是用于标识类或接口的 128 位唯一标识字符串。</span><span class="sxs-lookup"><span data-stu-id="fcc41-280">The GUID (globally unique identifier) is a 128-bit unique identification string used to identify a class or an interface.</span></span> <span data-ttu-id="fcc41-281">它是主要适用于 Microsoft.NET Framework 和 COM 之间的互操作性</span><span class="sxs-lookup"><span data-stu-id="fcc41-281">It is primarily useful for interoperability between the Microsoft .NET Framework and COM.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Guid" />
      </Docs>
    </Member>
    <Member MemberName="HasElementTypeImpl">
      <MemberSignature Language="C#" Value="protected override bool HasElementTypeImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance bool HasElementTypeImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.TypeDelegator.HasElementTypeImpl" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function HasElementTypeImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override bool HasElementTypeImpl();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="fcc41-282">获取一个值，该值指示当前 <see cref="T:System.Type" /> 是否包含或引用其他类型，即当前 <see cref="T:System.Type" /> 是数组、指针还是 ByRef。</span><span class="sxs-lookup"><span data-stu-id="fcc41-282">Gets a value indicating whether the current <see cref="T:System.Type" /> encompasses or refers to another type; that is, whether the current <see cref="T:System.Type" /> is an array, a pointer or a ByRef.</span></span></summary>
        <returns>
          <span data-ttu-id="fcc41-283">如果 <see cref="T:System.Type" /> 是数组、指针或 ByRef，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="fcc41-283"><see langword="true" /> if the <see cref="T:System.Type" /> is an array, a pointer or a ByRef; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="InvokeMember">
      <MemberSignature Language="C#" Value="public override object InvokeMember (string name, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, object target, object[] args, System.Reflection.ParameterModifier[] modifiers, System.Globalization.CultureInfo culture, string[] namedParameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance object InvokeMember(string name, valuetype System.Reflection.BindingFlags invokeAttr, class System.Reflection.Binder binder, object target, object[] args, valuetype System.Reflection.ParameterModifier[] modifiers, class System.Globalization.CultureInfo culture, string[] namedParameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.TypeDelegator.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Object ^ InvokeMember(System::String ^ name, System::Reflection::BindingFlags invokeAttr, System::Reflection::Binder ^ binder, System::Object ^ target, cli::array &lt;System::Object ^&gt; ^ args, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::String ^&gt; ^ namedParameters);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="invokeAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="target" Type="System.Object" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="namedParameters" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="fcc41-284">要调用的成员的名称。</span><span class="sxs-lookup"><span data-stu-id="fcc41-284">The name of the member to invoke.</span></span> <span data-ttu-id="fcc41-285">这可能是一个构造函数、方法、属性或字段。</span><span class="sxs-lookup"><span data-stu-id="fcc41-285">This may be a constructor, method, property, or field.</span></span> <span data-ttu-id="fcc41-286">如果传递了空字符串 ("")，则调用默认成员。</span><span class="sxs-lookup"><span data-stu-id="fcc41-286">If an empty string ("") is passed, the default member is invoked.</span></span></param>
        <param name="invokeAttr"><span data-ttu-id="fcc41-287">调用属性。</span><span class="sxs-lookup"><span data-stu-id="fcc41-287">The invocation attribute.</span></span> <span data-ttu-id="fcc41-288">这必须是下列之一：<see cref="T:System.Reflection.BindingFlags" />、<see langword="InvokeMethod" />、<see langword="CreateInstance" />、<see langword="Static" />、<see langword="GetField" />、<see langword="SetField" />、<see langword="GetProperty" /> 或 <see langword="SetProperty" />。</span><span class="sxs-lookup"><span data-stu-id="fcc41-288">This must be one of the following <see cref="T:System.Reflection.BindingFlags" /> : <see langword="InvokeMethod" />, <see langword="CreateInstance" />, <see langword="Static" />, <see langword="GetField" />, <see langword="SetField" />, <see langword="GetProperty" />, or <see langword="SetProperty" />.</span></span> <span data-ttu-id="fcc41-289">必须指定合适的调用属性。</span><span class="sxs-lookup"><span data-stu-id="fcc41-289">A suitable invocation attribute must be specified.</span></span> <span data-ttu-id="fcc41-290">如果要调用静态成员，则必须设置 <see langword="Static" /> 标志。</span><span class="sxs-lookup"><span data-stu-id="fcc41-290">If a static member is to be invoked, the <see langword="Static" /> flag must be set.</span></span></param>
        <param name="binder"><span data-ttu-id="fcc41-291">一个对象，它启用绑定、对参数类型的强制、对成员的调用，以及通过反射对 <see langword="MemberInfo" /> 对象的检索。</span><span class="sxs-lookup"><span data-stu-id="fcc41-291">An object that enables the binding, coercion of argument types, invocation of members, and retrieval of <see langword="MemberInfo" /> objects via reflection.</span></span> <span data-ttu-id="fcc41-292">如果 <c>binder</c> 为 <see langword="null" />，则使用默认活页夹。</span><span class="sxs-lookup"><span data-stu-id="fcc41-292">If <c>binder</c> is <see langword="null" />, the default binder is used.</span></span> <span data-ttu-id="fcc41-293">请参阅 <see cref="T:System.Reflection.Binder" />。</span><span class="sxs-lookup"><span data-stu-id="fcc41-293">See <see cref="T:System.Reflection.Binder" />.</span></span></param>
        <param name="target"><span data-ttu-id="fcc41-294">对其调用指定成员的对象。</span><span class="sxs-lookup"><span data-stu-id="fcc41-294">The object on which to invoke the specified member.</span></span></param>
        <param name="args"><span data-ttu-id="fcc41-295"><see langword="Object" /> 类型的数组，包含要调用的成员参数的数目、顺序和类型。</span><span class="sxs-lookup"><span data-stu-id="fcc41-295">An array of type <see langword="Object" /> that contains the number, order, and type of the parameters of the member to be invoked.</span></span> <span data-ttu-id="fcc41-296">如果 <c>args</c> 包含未初始化的 <see langword="Object" />，则它被视为空，用默认联编程序可将它扩展为 0、0.0 或一个字符串。</span><span class="sxs-lookup"><span data-stu-id="fcc41-296">If <c>args</c> contains an uninitialized <see langword="Object" />, it is treated as empty, which, with the default binder, can be widened to 0, 0.0 or a string.</span></span></param>
        <param name="modifiers"><span data-ttu-id="fcc41-297"><see langword="ParameterModifer" /> 类型的数组，其长度与 <c>args</c> 相同，其元素表示与要调用的成员参数关联的属性。</span><span class="sxs-lookup"><span data-stu-id="fcc41-297">An array of type <see langword="ParameterModifer" /> that is the same length as <c>args</c>, with elements that represent the attributes associated with the arguments of the member to be invoked.</span></span> <span data-ttu-id="fcc41-298">参数在成员的签名中有与其关联的属性。</span><span class="sxs-lookup"><span data-stu-id="fcc41-298">A parameter has attributes associated with it in the member's signature.</span></span> <span data-ttu-id="fcc41-299">对于 ByRef，请使用 <see langword="ParameterModifer.ByRef" />；对于空，请使用 <see langword="ParameterModifer.None" />。</span><span class="sxs-lookup"><span data-stu-id="fcc41-299">For ByRef, use <see langword="ParameterModifer.ByRef" />, and for none, use <see langword="ParameterModifer.None" />.</span></span> <span data-ttu-id="fcc41-300">默认联编程序执行与这些内容的精确匹配。</span><span class="sxs-lookup"><span data-stu-id="fcc41-300">The default binder does exact matching on these.</span></span> <span data-ttu-id="fcc41-301"><see langword="In" /> 和 <see langword="InOut" /> 这样的属性不用于绑定，可以使用 <see langword="ParameterInfo" /> 查看它们。</span><span class="sxs-lookup"><span data-stu-id="fcc41-301">Attributes such as <see langword="In" /> and <see langword="InOut" /> are not used in binding, and can be viewed using <see langword="ParameterInfo" />.</span></span></param>
        <param name="culture"><span data-ttu-id="fcc41-302">用于控制类型强制的 <see langword="CultureInfo" /> 的实例。</span><span class="sxs-lookup"><span data-stu-id="fcc41-302">An instance of <see langword="CultureInfo" /> used to govern the coercion of types.</span></span> <span data-ttu-id="fcc41-303">类型强制在某些情况下是必要的，例如将表示 1000 的字符串转换为 <see langword="Double" /> 值，因为不同的区域性表示 1000 的方式不同。</span><span class="sxs-lookup"><span data-stu-id="fcc41-303">This is necessary, for example, to convert a string that represents 1000 to a <see langword="Double" /> value, since 1000 is represented differently by different cultures.</span></span> <span data-ttu-id="fcc41-304">如果 <c>culture</c> 为 <see langword="null" />，则将 <see langword="CultureInfo" /> 用于当前线程的 <see langword="CultureInfo" />。</span><span class="sxs-lookup"><span data-stu-id="fcc41-304">If <c>culture</c> is <see langword="null" />, the <see langword="CultureInfo" /> for the current thread's <see langword="CultureInfo" /> is used.</span></span></param>
        <param name="namedParameters"><span data-ttu-id="fcc41-305"><see langword="String" /> 类型的数组，包含与 <c>args</c> 数组匹配的参数名（从元素零开始）。</span><span class="sxs-lookup"><span data-stu-id="fcc41-305">An array of type <see langword="String" /> containing parameter names that match up, starting at element zero, with the <c>args</c> array.</span></span> <span data-ttu-id="fcc41-306">数组中不能有空缺。</span><span class="sxs-lookup"><span data-stu-id="fcc41-306">There must be no holes in the array.</span></span> <span data-ttu-id="fcc41-307">如果 <c>args</c>.</span><span class="sxs-lookup"><span data-stu-id="fcc41-307">If <c>args</c>.</span></span> <span data-ttu-id="fcc41-308"><see langword="Length" /> 大于 <c>namedParameters</c>.</span><span class="sxs-lookup"><span data-stu-id="fcc41-308"><see langword="Length" /> is greater than <c>namedParameters</c>.</span></span> <span data-ttu-id="fcc41-309"><see langword="Length" />，则按顺序填充剩余的参数。</span><span class="sxs-lookup"><span data-stu-id="fcc41-309"><see langword="Length" />, the remaining parameters are filled in order.</span></span></param>
        <summary><span data-ttu-id="fcc41-310">调用指定的成员。</span><span class="sxs-lookup"><span data-stu-id="fcc41-310">Invokes the specified member.</span></span> <span data-ttu-id="fcc41-311">在指定的活页夹和调用属性的约束下，要调用的方法必须为可访问，并且提供与指定的自变量列表最具体的匹配。</span><span class="sxs-lookup"><span data-stu-id="fcc41-311">The method that is to be invoked must be accessible and provide the most specific match with the specified argument list, under the constraints of the specified binder and invocation attributes.</span></span></summary>
        <returns><span data-ttu-id="fcc41-312">表示被调用成员的返回值的 <see langword="Object" />。</span><span class="sxs-lookup"><span data-stu-id="fcc41-312">An <see langword="Object" /> representing the return value of the invoked member.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="fcc41-313">如果这两个以下条件为真，则将调用一个方法：</span><span class="sxs-lookup"><span data-stu-id="fcc41-313">A method will be invoked if both the following conditions are true:</span></span>  
  
-   <span data-ttu-id="fcc41-314">（除非成员上定义了默认自变量），方法声明中的参数的数目等于在指定的参数列表中的参数的数目。</span><span class="sxs-lookup"><span data-stu-id="fcc41-314">The number of parameters in the method declaration equals the number of arguments in the specified argument list (unless default arguments are defined on the member).</span></span>  
  
-   <span data-ttu-id="fcc41-315">每个自变量的类型可以转换由参数的类型联编程序。</span><span class="sxs-lookup"><span data-stu-id="fcc41-315">The type of each arguments can be converted by the binder to the type of the parameter.</span></span>  
  
 <span data-ttu-id="fcc41-316">联编程序将查找所有匹配的方法。</span><span class="sxs-lookup"><span data-stu-id="fcc41-316">The binder will find all the matching methods.</span></span> <span data-ttu-id="fcc41-317">这些方法找到基于请求的绑定类型 (`BindingFlags.MethodInvoke`， `BindingFlags.GetProperties`，依次类推)。</span><span class="sxs-lookup"><span data-stu-id="fcc41-317">These methods are found based upon the type of binding requested (`BindingFlags.MethodInvoke`, `BindingFlags.GetProperties`, and so on).</span></span> <span data-ttu-id="fcc41-318">按名称、 数量的参数和一组绑定器中定义的搜索修饰符进行筛选的方法集。</span><span class="sxs-lookup"><span data-stu-id="fcc41-318">The set of methods is filtered by the name, number of arguments, and a set of search modifiers defined in the binder.</span></span>  
  
 <span data-ttu-id="fcc41-319">选择方法后，将调用它。</span><span class="sxs-lookup"><span data-stu-id="fcc41-319">After the method is selected, it will be invoked.</span></span> <span data-ttu-id="fcc41-320">此时，检查可访问性。</span><span class="sxs-lookup"><span data-stu-id="fcc41-320">Accessibility is checked at that point.</span></span> <span data-ttu-id="fcc41-321">搜索可能基于与该方法关联的可访问性属性来控制搜索哪些方法集。</span><span class="sxs-lookup"><span data-stu-id="fcc41-321">The search may control which set of methods are searched based upon the accessibility attribute associated with the method.</span></span> <span data-ttu-id="fcc41-322"><xref:System.Reflection.Binder.BindToMethod%2A?displayProperty=nameWithType>方法负责选择要调用的方法。</span><span class="sxs-lookup"><span data-stu-id="fcc41-322">The <xref:System.Reflection.Binder.BindToMethod%2A?displayProperty=nameWithType> method is responsible for selecting the method to be invoked.</span></span> <span data-ttu-id="fcc41-323">默认的联编程序选择最精确的匹配。</span><span class="sxs-lookup"><span data-stu-id="fcc41-323">The default binder selects the most specific match.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="fcc41-324">访问限制会忽略完全受信任的代码。</span><span class="sxs-lookup"><span data-stu-id="fcc41-324">Access restrictions are ignored for fully trusted code.</span></span> <span data-ttu-id="fcc41-325">即私有构造函数、 方法、 字段和属性可以访问和使用反射，只要完全受信任代码调用。</span><span class="sxs-lookup"><span data-stu-id="fcc41-325">That is, private constructors, methods, fields, and properties can be accessed and invoked using reflection whenever the code is fully trusted.</span></span>  
  
 <span data-ttu-id="fcc41-326">目前，`InvokeMember`对 Microsoft.NET Framework 反射语义执行，其中每种类型的对象。</span><span class="sxs-lookup"><span data-stu-id="fcc41-326">Currently, `InvokeMember` performs the Microsoft .NET Framework reflection semantics for every type of object.</span></span>  
  
 <span data-ttu-id="fcc41-327">如果按名称指定的成员是一个数组和`BindingFlags.GetField`上设置标志`invokeAttr`、`args`数组指定其值是要返回的元素。</span><span class="sxs-lookup"><span data-stu-id="fcc41-327">If the member specified by name is an array and the `BindingFlags.GetField` flag is set on `invokeAttr`, the `args` array specifies the elements whose values are to be returned.</span></span> <span data-ttu-id="fcc41-328">例如，以下调用通过`Type`对象`t`返回的字符串数组 MyArray，这是调用对象的成员的第一个元素的值：</span><span class="sxs-lookup"><span data-stu-id="fcc41-328">For example, the following call through `Type` object `t` returns the value of the first element of the string array MyArray, which is a member of the calling object:</span></span>  
  
 `String ret = (String) t.InvokeMember ("MyArray", BindingFlags.GetField, null, this, new Variant[]{0});`  
  
 <span data-ttu-id="fcc41-329">你可以使用`InvokeMember`设置成员数组的一个或多个元素。</span><span class="sxs-lookup"><span data-stu-id="fcc41-329">You can use `InvokeMember` to set one or more elements of a member array.</span></span> <span data-ttu-id="fcc41-330">所有元素都设置为相同的值。</span><span class="sxs-lookup"><span data-stu-id="fcc41-330">All elements are set to the same value.</span></span> <span data-ttu-id="fcc41-331">`args`数组必须进行格式设置，如下所示：</span><span class="sxs-lookup"><span data-stu-id="fcc41-331">The `args` array must be formatted as follows:</span></span>  
  
```  
{index1,  
    index2,, value}  
```  
  
 <span data-ttu-id="fcc41-332">例如，若要设置 MyArray 的第一个成员上一示例中，语法是，如下所示：</span><span class="sxs-lookup"><span data-stu-id="fcc41-332">For example, to set the first member of MyArray from the previous example, the syntax is as follows:</span></span>  
  
```csharp  
t.InvokeMember ("MyArray", BindingFlags.SetField, null, this, new  
    Variant[]{0,"Updated"});  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Globalization.CultureInfo" />
      </Docs>
    </Member>
    <Member MemberName="IsArrayImpl">
      <MemberSignature Language="C#" Value="protected override bool IsArrayImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance bool IsArrayImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.TypeDelegator.IsArrayImpl" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function IsArrayImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override bool IsArrayImpl();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="fcc41-333">返回一个值，该值指示 <see cref="T:System.Type" /> 是否为数组。</span><span class="sxs-lookup"><span data-stu-id="fcc41-333">Returns a value that indicates whether the <see cref="T:System.Type" /> is an array.</span></span></summary>
        <returns>
          <span data-ttu-id="fcc41-334">如果 <see langword="true" /> 是数组，则为 <see cref="T:System.Type" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="fcc41-334"><see langword="true" /> if the <see cref="T:System.Type" /> is an array; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsAssignableFrom">
      <MemberSignature Language="C#" Value="public override bool IsAssignableFrom (System.Reflection.TypeInfo typeInfo);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool IsAssignableFrom(class System.Reflection.TypeInfo typeInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.TypeDelegator.IsAssignableFrom(System.Reflection.TypeInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool IsAssignableFrom(System::Reflection::TypeInfo ^ typeInfo);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeInfo" Type="System.Reflection.TypeInfo" />
      </Parameters>
      <Docs>
        <param name="typeInfo"><span data-ttu-id="fcc41-335">要检查的类型。</span><span class="sxs-lookup"><span data-stu-id="fcc41-335">The type to check.</span></span></param>
        <summary><span data-ttu-id="fcc41-336">返回一个值，该值指示指定类型是否可分配给此类型。</span><span class="sxs-lookup"><span data-stu-id="fcc41-336">Returns a value that indicates whether the specified type can be assigned to this type.</span></span></summary>
        <returns>
          <span data-ttu-id="fcc41-337">如果可以将指定类型分配给此类型，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="fcc41-337"><see langword="true" /> if the specified type can be assigned to this type; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsByRefImpl">
      <MemberSignature Language="C#" Value="protected override bool IsByRefImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance bool IsByRefImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.TypeDelegator.IsByRefImpl" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function IsByRefImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override bool IsByRefImpl();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="fcc41-338">返回指示 <see cref="T:System.Type" /> 是否由引用传递的值。</span><span class="sxs-lookup"><span data-stu-id="fcc41-338">Returns a value that indicates whether the <see cref="T:System.Type" /> is passed by reference.</span></span></summary>
        <returns>
          <span data-ttu-id="fcc41-339">如果 <see cref="T:System.Type" /> 按引用传递，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="fcc41-339"><see langword="true" /> if the <see cref="T:System.Type" /> is passed by reference; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsByRefLike">
      <MemberSignature Language="C#" Value="public override bool IsByRefLike { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsByRefLike" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.TypeDelegator.IsByRefLike" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsByRefLike As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsByRefLike { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsCOMObjectImpl">
      <MemberSignature Language="C#" Value="protected override bool IsCOMObjectImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance bool IsCOMObjectImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.TypeDelegator.IsCOMObjectImpl" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function IsCOMObjectImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override bool IsCOMObjectImpl();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="fcc41-340">返回一个值，该值指示 <see cref="T:System.Type" /> 是否为 COM 对象。</span><span class="sxs-lookup"><span data-stu-id="fcc41-340">Returns a value that indicates whether the <see cref="T:System.Type" /> is a COM object.</span></span></summary>
        <returns>
          <span data-ttu-id="fcc41-341">如果 <see langword="true" /> 为 COM 对象，则为 <see cref="T:System.Type" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="fcc41-341"><see langword="true" /> if the <see cref="T:System.Type" /> is a COM object; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsConstructedGenericType">
      <MemberSignature Language="C#" Value="public override bool IsConstructedGenericType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsConstructedGenericType" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.TypeDelegator.IsConstructedGenericType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsConstructedGenericType As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsConstructedGenericType { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="fcc41-342">获取指示此对象是否表示构造的泛型类型的值。</span><span class="sxs-lookup"><span data-stu-id="fcc41-342">Gets a value that indicates whether this object represents a constructed generic type.</span></span></summary>
        <value>
          <span data-ttu-id="fcc41-343">如果此对象表示构造泛型类型，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="fcc41-343"><see langword="true" /> if this object represents a constructed generic type; otherwise, <see langword="false" />.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsDefined">
      <MemberSignature Language="C#" Value="public override bool IsDefined (Type attributeType, bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool IsDefined(class System.Type attributeType, bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.TypeDelegator.IsDefined(System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function IsDefined (attributeType As Type, inherit As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool IsDefined(Type ^ attributeType, bool inherit);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributeType" Type="System.Type" />
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="attributeType"><span data-ttu-id="fcc41-344">指定是否搜索此类型的继承链以查找这些属性。</span><span class="sxs-lookup"><span data-stu-id="fcc41-344">Specifies whether to search this type's inheritance chain to find the attributes.</span></span></param>
        <param name="inherit"><span data-ttu-id="fcc41-345">由类型标识的自定义属性数组。</span><span class="sxs-lookup"><span data-stu-id="fcc41-345">An array of custom attributes identified by type.</span></span></param>
        <summary><span data-ttu-id="fcc41-346">指示是否定义由 <paramref name="attributeType" /> 标识的自定义属性。</span><span class="sxs-lookup"><span data-stu-id="fcc41-346">Indicates whether a custom attribute identified by <paramref name="attributeType" /> is defined.</span></span></summary>
        <returns>
          <span data-ttu-id="fcc41-347">如果定义由 <paramref name="attributeType" /> 标识的自定义属性，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="fcc41-347"><see langword="true" /> if a custom attribute identified by <paramref name="attributeType" /> is defined; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="fcc41-348"><paramref name="attributeType" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="fcc41-348"><paramref name="attributeType" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Reflection.ReflectionTypeLoadException"><span data-ttu-id="fcc41-349">无法加载自定义特性类型。</span><span class="sxs-lookup"><span data-stu-id="fcc41-349">The custom attribute type cannot be loaded.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="IsGenericMethodParameter">
      <MemberSignature Language="C#" Value="public override bool IsGenericMethodParameter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGenericMethodParameter" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.TypeDelegator.IsGenericMethodParameter" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsGenericMethodParameter As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsGenericMethodParameter { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsGenericTypeParameter">
      <MemberSignature Language="C#" Value="public override bool IsGenericTypeParameter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGenericTypeParameter" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.TypeDelegator.IsGenericTypeParameter" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsGenericTypeParameter As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsGenericTypeParameter { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsPointerImpl">
      <MemberSignature Language="C#" Value="protected override bool IsPointerImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance bool IsPointerImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.TypeDelegator.IsPointerImpl" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function IsPointerImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override bool IsPointerImpl();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="fcc41-350">返回一个值，该值指示 <see cref="T:System.Type" /> 是否为指针。</span><span class="sxs-lookup"><span data-stu-id="fcc41-350">Returns a value that indicates whether the <see cref="T:System.Type" /> is a pointer.</span></span></summary>
        <returns>
          <span data-ttu-id="fcc41-351">如果 <see cref="T:System.Type" /> 是指针，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="fcc41-351"><see langword="true" /> if the <see cref="T:System.Type" /> is a pointer; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsPrimitiveImpl">
      <MemberSignature Language="C#" Value="protected override bool IsPrimitiveImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance bool IsPrimitiveImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.TypeDelegator.IsPrimitiveImpl" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function IsPrimitiveImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override bool IsPrimitiveImpl();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="fcc41-352">返回一个值，该值指示 <see cref="T:System.Type" /> 是否为基元类型之一。</span><span class="sxs-lookup"><span data-stu-id="fcc41-352">Returns a value that indicates whether the <see cref="T:System.Type" /> is one of the primitive types.</span></span></summary>
        <returns>
          <span data-ttu-id="fcc41-353">如果 <see langword="true" /> 为基元类型之一，则为 <see cref="T:System.Type" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="fcc41-353"><see langword="true" /> if the <see cref="T:System.Type" /> is one of the primitive types; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsSZArray">
      <MemberSignature Language="C#" Value="public override bool IsSZArray { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSZArray" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.TypeDelegator.IsSZArray" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsSZArray As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSZArray { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsTypeDefinition">
      <MemberSignature Language="C#" Value="public override bool IsTypeDefinition { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsTypeDefinition" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.TypeDelegator.IsTypeDefinition" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsTypeDefinition As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsTypeDefinition { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsValueTypeImpl">
      <MemberSignature Language="C#" Value="protected override bool IsValueTypeImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance bool IsValueTypeImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.TypeDelegator.IsValueTypeImpl" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function IsValueTypeImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override bool IsValueTypeImpl();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="fcc41-354">返回一个值，该值指示此类型是否为值类型（即不是类或接口）。</span><span class="sxs-lookup"><span data-stu-id="fcc41-354">Returns a value that indicates whether the type is a value type; that is, not a class or an interface.</span></span></summary>
        <returns>
          <span data-ttu-id="fcc41-355">如果该类型是值类型，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="fcc41-355"><see langword="true" /> if the type is a value type; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsVariableBoundArray">
      <MemberSignature Language="C#" Value="public override bool IsVariableBoundArray { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsVariableBoundArray" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.TypeDelegator.IsVariableBoundArray" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsVariableBoundArray As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsVariableBoundArray { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MetadataToken">
      <MemberSignature Language="C#" Value="public override int MetadataToken { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MetadataToken" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.TypeDelegator.MetadataToken" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property MetadataToken As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int MetadataToken { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="fcc41-356">获取一个标识元数据中的此实体的值。</span><span class="sxs-lookup"><span data-stu-id="fcc41-356">Gets a value that identifies this entity in metadata.</span></span></summary>
        <value><span data-ttu-id="fcc41-357">一个值，与模块一起来唯一标识元数据中的此实体。</span><span class="sxs-lookup"><span data-stu-id="fcc41-357">A value which, in combination with the module, uniquely identifies this entity in metadata.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="fcc41-358">使用此属性获取的令牌可以传递到非托管的反射 API。</span><span class="sxs-lookup"><span data-stu-id="fcc41-358">The tokens obtained using this property can be passed to the unmanaged reflection API.</span></span> <span data-ttu-id="fcc41-359">有关详细信息，请参阅[非托管的反射 API](http://msdn.microsoft.com/library/0c5bb9de-0cf6-438d-ba47-134e6c775fb8)。</span><span class="sxs-lookup"><span data-stu-id="fcc41-359">For more information, see [Unmanaged Reflection API](http://msdn.microsoft.com/library/0c5bb9de-0cf6-438d-ba47-134e6c775fb8).</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Module">
      <MemberSignature Language="C#" Value="public override System.Reflection.Module Module { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.Module Module" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.TypeDelegator.Module" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Module As Module" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::Module ^ Module { System::Reflection::Module ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Module</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="fcc41-360">获取包含已实现类型的模块。</span><span class="sxs-lookup"><span data-stu-id="fcc41-360">Gets the module that contains the implemented type.</span></span></summary>
        <value><span data-ttu-id="fcc41-361">表示已实现类型的模块的 <see cref="T:System.Reflection.Module" /> 对象。</span><span class="sxs-lookup"><span data-stu-id="fcc41-361">A <see cref="T:System.Reflection.Module" /> object representing the module of the implemented type.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="fcc41-362">模块是一个可加载的单元可以包含类型声明和实现。</span><span class="sxs-lookup"><span data-stu-id="fcc41-362">A module is a loadable unit that can contain type declarations and implementations.</span></span> <span data-ttu-id="fcc41-363">模块包含足够的信息来启用公共语言运行时在模块加载时找到所有实现位。</span><span class="sxs-lookup"><span data-stu-id="fcc41-363">Modules contain enough information to enable the common language runtime to locate all implementation bits when the module is loaded.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public override string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.TypeDelegator.Name" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Name { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="fcc41-364">获取移除了路径的已实现类型的名称。</span><span class="sxs-lookup"><span data-stu-id="fcc41-364">Gets the name of the implemented type, with the path removed.</span></span></summary>
        <value><span data-ttu-id="fcc41-365">包含类型的非限定名的 <see langword="String" />。</span><span class="sxs-lookup"><span data-stu-id="fcc41-365">A <see langword="String" /> containing the type's non-qualified name.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="fcc41-366">包含当前 `TypeDelegator` 名称的字符串。</span><span class="sxs-lookup"><span data-stu-id="fcc41-366">A string containing the name of the current `TypeDelegator`.</span></span> <span data-ttu-id="fcc41-367">返回只是简单名称，不是完全限定名称。</span><span class="sxs-lookup"><span data-stu-id="fcc41-367">Only the simple name, not the fully qualified name, is returned.</span></span> <span data-ttu-id="fcc41-368">若要获取的名称和路径，请使用<xref:System.Reflection.TypeDelegator.FullName%2A>。</span><span class="sxs-lookup"><span data-stu-id="fcc41-368">To get the name and the path, use <xref:System.Reflection.TypeDelegator.FullName%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Namespace">
      <MemberSignature Language="C#" Value="public override string Namespace { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Namespace" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.TypeDelegator.Namespace" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Namespace As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Namespace { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="fcc41-369">获取已实现类型的命名空间。</span><span class="sxs-lookup"><span data-stu-id="fcc41-369">Gets the namespace of the implemented type.</span></span></summary>
        <value><span data-ttu-id="fcc41-370">包含类型的命名空间的 <see langword="String" />。</span><span class="sxs-lookup"><span data-stu-id="fcc41-370">A <see langword="String" /> containing the type's namespace.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="fcc41-371">此属性获取包含当前的命名空间的字符串`TypeDelegator`。</span><span class="sxs-lookup"><span data-stu-id="fcc41-371">This property gets a string containing the namespace of the current `TypeDelegator`.</span></span> <span data-ttu-id="fcc41-372">例如，如果`TypeDelegator`是<xref:System.Reflection.TypeFilter>，返回的命名空间是<xref:System.Reflection>。</span><span class="sxs-lookup"><span data-stu-id="fcc41-372">For example, if the `TypeDelegator` is <xref:System.Reflection.TypeFilter>, the returned namespace is <xref:System.Reflection>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TypeHandle">
      <MemberSignature Language="C#" Value="public override RuntimeTypeHandle TypeHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.RuntimeTypeHandle TypeHandle" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.TypeDelegator.TypeHandle" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property TypeHandle As RuntimeTypeHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property RuntimeTypeHandle TypeHandle { RuntimeTypeHandle get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.RuntimeTypeHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="fcc41-373">获取已实现类型的内部元数据表示形式的句柄。</span><span class="sxs-lookup"><span data-stu-id="fcc41-373">Gets a handle to the internal metadata representation of an implemented type.</span></span></summary>
        <value><span data-ttu-id="fcc41-374"><see langword="RuntimeTypeHandle" /> 对象。</span><span class="sxs-lookup"><span data-stu-id="fcc41-374">A <see langword="RuntimeTypeHandle" /> object.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="fcc41-375">类型句柄是与每个类型相关联的唯一整数值。</span><span class="sxs-lookup"><span data-stu-id="fcc41-375">A type handle is a unique integer value associated with each type.</span></span> <span data-ttu-id="fcc41-376">在运行时句柄是唯一的。</span><span class="sxs-lookup"><span data-stu-id="fcc41-376">The handle is unique during the runtime.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.RuntimeTypeHandle" />
      </Docs>
    </Member>
    <Member MemberName="typeImpl">
      <MemberSignature Language="C#" Value="protected Type typeImpl;" />
      <MemberSignature Language="ILAsm" Value=".field family class System.Type typeImpl" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.TypeDelegator.typeImpl" />
      <MemberSignature Language="VB.NET" Value="Protected typeImpl As Type " />
      <MemberSignature Language="C++ CLI" Value="protected: Type ^ typeImpl;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="fcc41-377">一个指示类型信息的值。</span><span class="sxs-lookup"><span data-stu-id="fcc41-377">A value indicating type information.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UnderlyingSystemType">
      <MemberSignature Language="C#" Value="public override Type UnderlyingSystemType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type UnderlyingSystemType" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.TypeDelegator.UnderlyingSystemType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property UnderlyingSystemType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ UnderlyingSystemType { Type ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="fcc41-378">获取表示已实现类型的基础 <see cref="T:System.Type" />。</span><span class="sxs-lookup"><span data-stu-id="fcc41-378">Gets the underlying <see cref="T:System.Type" /> that represents the implemented type.</span></span></summary>
        <value><span data-ttu-id="fcc41-379">基础类型。</span><span class="sxs-lookup"><span data-stu-id="fcc41-379">The underlying type.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>