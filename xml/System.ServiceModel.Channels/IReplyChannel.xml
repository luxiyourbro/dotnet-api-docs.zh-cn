<Type Name="IReplyChannel" FullName="System.ServiceModel.Channels.IReplyChannel">
  <TypeSignature Language="C#" Value="public interface IReplyChannel : System.ServiceModel.Channels.IChannel" />
  <TypeSignature Language="ILAsm" Value=".class public interface auto ansi abstract IReplyChannel implements class System.ServiceModel.Channels.IChannel, class System.ServiceModel.ICommunicationObject" />
  <TypeSignature Language="DocId" Value="T:System.ServiceModel.Channels.IReplyChannel" />
  <TypeSignature Language="VB.NET" Value="Public Interface IReplyChannel&#xA;Implements IChannel" />
  <TypeSignature Language="C++ CLI" Value="public interface class IReplyChannel : System::ServiceModel::Channels::IChannel" />
  <AssemblyInfo>
    <AssemblyName>System.ServiceModel</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ServiceModel.Channels.IChannel</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary><span data-ttu-id="3f1e3-101">定义一个接口，通道必须实现该接口，才能成为消息传递终结点之间的请求-回复通信的接收端。</span><span class="sxs-lookup"><span data-stu-id="3f1e3-101">Defines the interface that a channel must implement to be on the receiving side of a request-reply communication between messaging endpoints.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3f1e3-102"><xref:System.ServiceModel.Channels.IReplyChannel> 接口包含 <xref:System.ServiceModel.Channels.IReplyChannel.ReceiveRequest%2A> 方法的同步和异步版本，返回一个 <xref:System.ServiceModel.Channels.RequestContext>，用于构造接收的请求的回复。</span><span class="sxs-lookup"><span data-stu-id="3f1e3-102">The <xref:System.ServiceModel.Channels.IReplyChannel> interface includes synchronous and asynchronous variants of a <xref:System.ServiceModel.Channels.IReplyChannel.ReceiveRequest%2A> method return an <xref:System.ServiceModel.Channels.RequestContext> that can be used to construct replies to received requests.</span></span>  
  
 <span data-ttu-id="3f1e3-103">协定包含接收、试图接收和等待消息功能的同步和异步版本。</span><span class="sxs-lookup"><span data-stu-id="3f1e3-103">The contract includes synchronous and asynchronous variants of receive, try-to-receive and wait-for-a-message functionality.</span></span>  
  
 <span data-ttu-id="3f1e3-104"><xref:System.ServiceModel.Channels.IReplyChannel> 不一定绑定到单个发送方。</span><span class="sxs-lookup"><span data-stu-id="3f1e3-104">An <xref:System.ServiceModel.Channels.IReplyChannel> is not necessarily bound to a single sender.</span></span> <span data-ttu-id="3f1e3-105">其他通道和通道接口提供发送方和回复通道之间的关联，但基协定没有这样的限制。</span><span class="sxs-lookup"><span data-stu-id="3f1e3-105">Other channels and channel interfaces provide correlation between the sender and the reply channel, but the base contract makes no such restriction.</span></span>  
  
 <span data-ttu-id="3f1e3-106">提取模式与 <xref:System.ServiceModel.Channels.IReplyChannel> 一起用于接收消息。</span><span class="sxs-lookup"><span data-stu-id="3f1e3-106">The pull model is used with an <xref:System.ServiceModel.Channels.IReplyChannel> to receive messages.</span></span> <span data-ttu-id="3f1e3-107">此模式的操作方式是先调用 <xref:System.ServiceModel.Channels.IReplyChannel.ReceiveRequest%2A>（或其变化版本之一），然后等待消息到达。</span><span class="sxs-lookup"><span data-stu-id="3f1e3-107">This model consists of calling <xref:System.ServiceModel.Channels.IReplyChannel.ReceiveRequest%2A> (or one of its variants) and then waiting for a message to arrive.</span></span>  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName="BeginReceiveRequest">
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="3f1e3-108">开始用于接收可用请求的异步操作。</span><span class="sxs-lookup"><span data-stu-id="3f1e3-108">Begins an asynchronous operation to receive an available request.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginReceiveRequest">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceiveRequest (AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginReceiveRequest(class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.IReplyChannel.BeginReceiveRequest(System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginReceiveRequest (callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceiveRequest(AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="callback"><span data-ttu-id="3f1e3-109"><see cref="T:System.AsyncCallback" /> 委托，接收请求操作完成的异步接收的通知。</span><span class="sxs-lookup"><span data-stu-id="3f1e3-109">The <see cref="T:System.AsyncCallback" /> delegate that receives the notification of the asynchronous receive that a request operation completes.</span></span></param>
        <param name="state"><span data-ttu-id="3f1e3-110">一个由应用程序指定的对象，它包含与请求操作的异步接收相关联的状态信息。</span><span class="sxs-lookup"><span data-stu-id="3f1e3-110">An object, specified by the application, that contains state information associated with the asynchronous receive of a request operation.</span></span></param>
        <summary><span data-ttu-id="3f1e3-111">开始用于接收可用请求的异步操作，该操作具有默认的超时值。</span><span class="sxs-lookup"><span data-stu-id="3f1e3-111">Begins an asynchronous operation to receive an available request with a default timeout.</span></span></summary>
        <returns><span data-ttu-id="3f1e3-112">引用请求的异步接收的 <see cref="T:System.IAsyncResult" />。</span><span class="sxs-lookup"><span data-stu-id="3f1e3-112">The <see cref="T:System.IAsyncResult" /> that references the asynchronous reception of the request.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3f1e3-113"><xref:System.ServiceModel.Channels.IReplyChannel.BeginReceiveRequest%28System.AsyncCallback%2CSystem.Object%29>方法实现调用的标准模式<xref:System.ServiceModel.Channels.IReplyChannel.ReceiveRequest>以异步方式。</span><span class="sxs-lookup"><span data-stu-id="3f1e3-113">The <xref:System.ServiceModel.Channels.IReplyChannel.BeginReceiveRequest%28System.AsyncCallback%2CSystem.Object%29> method implements the standard pattern for invoking <xref:System.ServiceModel.Channels.IReplyChannel.ReceiveRequest> asynchronously.</span></span> <span data-ttu-id="3f1e3-114">默认超时值为 1 分钟。</span><span class="sxs-lookup"><span data-stu-id="3f1e3-114">The default timeout is 1 minute.</span></span> <span data-ttu-id="3f1e3-115">如果在用于配置连接的绑定上设置有接收超时值，则会使用该值。</span><span class="sxs-lookup"><span data-stu-id="3f1e3-115">If a receive timeout is set on the binding used to configure the connection, then that value is used.</span></span> <span data-ttu-id="3f1e3-116">如果要在调用中指定一个显式的超时值，以重写前面提到的其他超时值，应使用 <xref:System.ServiceModel.Channels.IReplyChannel.BeginReceiveRequest%28System.TimeSpan%2CSystem.AsyncCallback%2CSystem.Object%29>。</span><span class="sxs-lookup"><span data-stu-id="3f1e3-116">Use <xref:System.ServiceModel.Channels.IReplyChannel.BeginReceiveRequest%28System.TimeSpan%2CSystem.AsyncCallback%2CSystem.Object%29> if you want to specify an explicit timeout with the call that overrides these other values.</span></span>  
  
 <span data-ttu-id="3f1e3-117">如果接收的请求消息大于使用的绑定所允许的最大消息大小，则将引发 <xref:System.ServiceModel.QuotaExceededException>。</span><span class="sxs-lookup"><span data-stu-id="3f1e3-117">If the request message received is larger that the maximum message size allowed by the binding being used, a <xref:System.ServiceModel.QuotaExceededException> is thrown.</span></span> <span data-ttu-id="3f1e3-118">最大消息大小由 <xref:System.ServiceModel.Channels.TransportBindingElement.MaxReceivedMessageSize%2A> 属性设置。</span><span class="sxs-lookup"><span data-stu-id="3f1e3-118">The maximum message size is set by the <xref:System.ServiceModel.Channels.TransportBindingElement.MaxReceivedMessageSize%2A> property.</span></span> <span data-ttu-id="3f1e3-119">默认值为 65536 个字节。</span><span class="sxs-lookup"><span data-stu-id="3f1e3-119">The default value is 65536 bytes.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3f1e3-120">下面的代码演示如何实现此方法：</span><span class="sxs-lookup"><span data-stu-id="3f1e3-120">The following code illustrates how to implement this method:</span></span>  
  
 [!code-csharp[S_UE_MessageInterceptor#1](~/samples/snippets/csharp/VS_Snippets_CFX/s_ue_messageinterceptor/cs/interceptingchannellistener.cs#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginReceiveRequest">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceiveRequest (TimeSpan timeout, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginReceiveRequest(valuetype System.TimeSpan timeout, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.IReplyChannel.BeginReceiveRequest(System.TimeSpan,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginReceiveRequest (timeout As TimeSpan, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceiveRequest(TimeSpan timeout, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="timeout"><span data-ttu-id="3f1e3-121"><see cref="T:System.TimeSpan" />，指定等待接收可用请求的时间间隔。</span><span class="sxs-lookup"><span data-stu-id="3f1e3-121">The <see cref="T:System.TimeSpan" /> that specifies the interval of time to wait for the reception of an available request.</span></span></param>
        <param name="callback"><span data-ttu-id="3f1e3-122"><see cref="T:System.AsyncCallback" /> 委托，接收请求操作完成的异步接收的通知。</span><span class="sxs-lookup"><span data-stu-id="3f1e3-122">The <see cref="T:System.AsyncCallback" /> delegate that receives the notification of the asynchronous receive that a request operation completes.</span></span></param>
        <param name="state"><span data-ttu-id="3f1e3-123">一个由应用程序指定的对象，它包含与请求操作的异步接收相关联的状态信息。</span><span class="sxs-lookup"><span data-stu-id="3f1e3-123">An object, specified by the application, that contains state information associated with the asynchronous receive of a request operation.</span></span></param>
        <summary><span data-ttu-id="3f1e3-124">开始用于接收可用请求的异步操作，该操作具有指定的超时值。</span><span class="sxs-lookup"><span data-stu-id="3f1e3-124">Begins an asynchronous operation to receive an available request with a specified timeout.</span></span></summary>
        <returns><span data-ttu-id="3f1e3-125">引用请求的异步接收的 <see cref="T:System.IAsyncResult" />。</span><span class="sxs-lookup"><span data-stu-id="3f1e3-125">The <see cref="T:System.IAsyncResult" /> that references the asynchronous reception of the request.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3f1e3-126"><xref:System.ServiceModel.Channels.IReplyChannel.BeginReceiveRequest%28System.TimeSpan%2CSystem.AsyncCallback%2CSystem.Object%29>方法实现调用的标准模式<xref:System.ServiceModel.Channels.IReplyChannel.ReceiveRequest%28System.TimeSpan%29>以异步方式。</span><span class="sxs-lookup"><span data-stu-id="3f1e3-126">The <xref:System.ServiceModel.Channels.IReplyChannel.BeginReceiveRequest%28System.TimeSpan%2CSystem.AsyncCallback%2CSystem.Object%29> method implements the standard pattern for invoking <xref:System.ServiceModel.Channels.IReplyChannel.ReceiveRequest%28System.TimeSpan%29> asynchronously.</span></span> <span data-ttu-id="3f1e3-127">此方法上设置的超时值重写在用于配置连接的绑定上设置的接收超时值。</span><span class="sxs-lookup"><span data-stu-id="3f1e3-127">The timeout set on this method overrides a receive timeout set on the binding that is used to configure the connection.</span></span>  
  
 <span data-ttu-id="3f1e3-128">如果接收的请求消息大于使用的绑定所允许的最大消息大小，则将引发 <xref:System.ServiceModel.QuotaExceededException>。</span><span class="sxs-lookup"><span data-stu-id="3f1e3-128">If the request message received is larger that the maximum message size allowed by the binding being used, a <xref:System.ServiceModel.QuotaExceededException> is thrown.</span></span> <span data-ttu-id="3f1e3-129">最大消息大小由 <xref:System.ServiceModel.Channels.TransportBindingElement.MaxReceivedMessageSize%2A> 属性设置。</span><span class="sxs-lookup"><span data-stu-id="3f1e3-129">The maximum message size is set by the <xref:System.ServiceModel.Channels.TransportBindingElement.MaxReceivedMessageSize%2A> property.</span></span> <span data-ttu-id="3f1e3-130">默认值为 65536 个字节。</span><span class="sxs-lookup"><span data-stu-id="3f1e3-130">The default value is 65536 bytes.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3f1e3-131">下面的代码演示如何实现此方法：</span><span class="sxs-lookup"><span data-stu-id="3f1e3-131">The following code illustrates how to implement this method:</span></span>  
  
 [!code-csharp[S_UE_MessageInterceptor#2](~/samples/snippets/csharp/VS_Snippets_CFX/s_ue_messageinterceptor/cs/interceptingchannellistener.cs#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginTryReceiveRequest">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginTryReceiveRequest (TimeSpan timeout, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginTryReceiveRequest(valuetype System.TimeSpan timeout, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.IReplyChannel.BeginTryReceiveRequest(System.TimeSpan,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginTryReceiveRequest (timeout As TimeSpan, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginTryReceiveRequest(TimeSpan timeout, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="timeout"><span data-ttu-id="3f1e3-132">一个 <see cref="T:System.TimeSpan" />，指定接收请求操作的完成时限，在此时限之后操作将超时并返回 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="3f1e3-132">The <see cref="T:System.TimeSpan" /> that specifies how long the receive request operation has to complete before timing out and returning <see langword="false" />.</span></span></param>
        <param name="callback"><span data-ttu-id="3f1e3-133"><see cref="T:System.AsyncCallback" /> 委托，接收请求操作完成的异步接收的通知。</span><span class="sxs-lookup"><span data-stu-id="3f1e3-133">The <see cref="T:System.AsyncCallback" /> delegate that receives the notification of the asynchronous receive that a request operation completes.</span></span></param>
        <param name="state"><span data-ttu-id="3f1e3-134">一个由应用程序指定的对象，它包含与请求操作的异步接收相关联的状态信息。</span><span class="sxs-lookup"><span data-stu-id="3f1e3-134">An object, specified by the application, that contains state information associated with the asynchronous receive of a request operation.</span></span></param>
        <summary><span data-ttu-id="3f1e3-135">开始用于接收请求消息的异步操作，该操作具有指定的超时值和状态对象与之关联。</span><span class="sxs-lookup"><span data-stu-id="3f1e3-135">Begins an asynchronous operation to receive a request message that has a specified time out and state object associated with it.</span></span></summary>
        <returns><span data-ttu-id="3f1e3-136">引用该异步接收请求操作的 <see cref="T:System.IAsyncResult" />。</span><span class="sxs-lookup"><span data-stu-id="3f1e3-136">The <see cref="T:System.IAsyncResult" /> that references the asynchronous receive request operation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3f1e3-137">如果需要应用程序处理继续进行而不等待，则使用异步 <xref:System.ServiceModel.Channels.IReplyChannel.BeginTryReceiveRequest%28System.TimeSpan%2CSystem.AsyncCallback%2CSystem.Object%29> 方法。</span><span class="sxs-lookup"><span data-stu-id="3f1e3-137">Use the asynchronous <xref:System.ServiceModel.Channels.IReplyChannel.BeginTryReceiveRequest%28System.TimeSpan%2CSystem.AsyncCallback%2CSystem.Object%29> method when you need the application processing to continue without waiting.</span></span> <span data-ttu-id="3f1e3-138">如果当前线程在回复请求消息时可以被阻塞，或者一直被阻塞到超出超时间隔，则使用同步 <xref:System.ServiceModel.Channels.IReplyChannel.TryReceiveRequest%28System.TimeSpan%2CSystem.ServiceModel.Channels.RequestContext%40%29> 方法之一。</span><span class="sxs-lookup"><span data-stu-id="3f1e3-138">Use one of the synchronous <xref:System.ServiceModel.Channels.IReplyChannel.TryReceiveRequest%28System.TimeSpan%2CSystem.ServiceModel.Channels.RequestContext%40%29> methods when it is acceptable for the current thread to be blocked while it replies to the request message or until the timeout interval is exceeded.</span></span>  
  
 <span data-ttu-id="3f1e3-139">此方法通过回调为操作接收事件处理程序标识的通知。</span><span class="sxs-lookup"><span data-stu-id="3f1e3-139">This method receives notification, through a callback, of the identity of the event handler for the operation.</span></span> <span data-ttu-id="3f1e3-140">直到通道中出现消息时或发生超时时才完成操作。</span><span class="sxs-lookup"><span data-stu-id="3f1e3-140">The operation is not complete until either a message becomes available in the channel or the time out occurs.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3f1e3-141">下面的代码演示如何实现此方法：</span><span class="sxs-lookup"><span data-stu-id="3f1e3-141">The following code illustrates how to implement this method:</span></span>  
  
 [!code-csharp[S_UE_MessageInterceptor#5](~/samples/snippets/csharp/VS_Snippets_CFX/s_ue_messageinterceptor/cs/interceptingchannellistener.cs#5)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para><span data-ttu-id="3f1e3-142">如果超出指定的 <see langword="false" />，此操作返回 <paramref name="timeout" />。</span><span class="sxs-lookup"><span data-stu-id="3f1e3-142">The operation returns <see langword="false" /> if the specified <paramref name="timeout" /> is exceeded.</span></span></para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="BeginWaitForRequest">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginWaitForRequest (TimeSpan timeout, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginWaitForRequest(valuetype System.TimeSpan timeout, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.IReplyChannel.BeginWaitForRequest(System.TimeSpan,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginWaitForRequest (timeout As TimeSpan, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginWaitForRequest(TimeSpan timeout, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="timeout"><span data-ttu-id="3f1e3-143"><see cref="T:System.TimeSpan" />，指定等待接收可用请求的时间间隔。</span><span class="sxs-lookup"><span data-stu-id="3f1e3-143">The <see cref="T:System.TimeSpan" /> that specifies the interval of time to wait for the reception of an available request.</span></span></param>
        <param name="callback"><span data-ttu-id="3f1e3-144"><see cref="T:System.AsyncCallback" /> 委托，接收请求操作完成的异步接收的通知。</span><span class="sxs-lookup"><span data-stu-id="3f1e3-144">The <see cref="T:System.AsyncCallback" /> delegate that receives the notification of the asynchronous receive that a request operation completes.</span></span></param>
        <param name="state"><span data-ttu-id="3f1e3-145">一个由应用程序指定的对象，它包含与请求操作的异步接收相关联的状态信息。</span><span class="sxs-lookup"><span data-stu-id="3f1e3-145">An object, specified by the application, that contains state information associated with the asynchronous receive of a request operation.</span></span></param>
        <summary><span data-ttu-id="3f1e3-146">开始具有关联的指定超时值和状态对象的异步请求操作。</span><span class="sxs-lookup"><span data-stu-id="3f1e3-146">Begins an asynchronous request operation that has a specified time out and state object associated with it.</span></span></summary>
        <returns><span data-ttu-id="3f1e3-147">引用等待请求消息到达的异步操作的 <see cref="T:System.IAsyncResult" />。</span><span class="sxs-lookup"><span data-stu-id="3f1e3-147">The <see cref="T:System.IAsyncResult" /> that references the asynchronous operation to wait for a request message to arrive.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3f1e3-148">如果当前线程在等待请求消息到达队列时可以被阻塞，则使用同步 <xref:System.ServiceModel.Channels.IReplyChannel.WaitForRequest%28System.TimeSpan%29> 方法。</span><span class="sxs-lookup"><span data-stu-id="3f1e3-148">Use the synchronous <xref:System.ServiceModel.Channels.IReplyChannel.WaitForRequest%28System.TimeSpan%29> method when it is acceptable for the current thread to be blocked while it waits for a request message to arrive in the queue.</span></span> <span data-ttu-id="3f1e3-149">该线程最多被阻塞 `timeout` 指定的时间长度。</span><span class="sxs-lookup"><span data-stu-id="3f1e3-149">The thread is blocked up to the specified `timeout`.</span></span>  
  
 <span data-ttu-id="3f1e3-150">此方法通过回调为操作接收事件处理程序标识的通知。</span><span class="sxs-lookup"><span data-stu-id="3f1e3-150">This method receives notification, through a callback, of the identity of the event handler for the operation.</span></span> <span data-ttu-id="3f1e3-151">直到通道中出现请求消息时或发生超时时才完成操作。</span><span class="sxs-lookup"><span data-stu-id="3f1e3-151">The operation is not complete until either a request message becomes available in the channel or the time out occurs.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3f1e3-152">下面的代码演示如何实现此方法：</span><span class="sxs-lookup"><span data-stu-id="3f1e3-152">The following code illustrates how to implement this method:</span></span>  
  
 [!code-csharp[S_UE_MessageInterceptor#10](~/samples/snippets/csharp/VS_Snippets_CFX/s_ue_messageinterceptor/cs/interceptingchannellistener.cs#10)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para><span data-ttu-id="3f1e3-153">如果超出指定的 <see langword="false" />，此操作返回 <paramref name="timeout" />。</span><span class="sxs-lookup"><span data-stu-id="3f1e3-153">The operation returns <see langword="false" /> if the specified <paramref name="timeout" /> is exceeded.</span></span></para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="EndReceiveRequest">
      <MemberSignature Language="C#" Value="public System.ServiceModel.Channels.RequestContext EndReceiveRequest (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.ServiceModel.Channels.RequestContext EndReceiveRequest(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.IReplyChannel.EndReceiveRequest(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndReceiveRequest (result As IAsyncResult) As RequestContext" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::ServiceModel::Channels::RequestContext ^ EndReceiveRequest(IAsyncResult ^ result);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ServiceModel.Channels.RequestContext</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result"><span data-ttu-id="3f1e3-154">通过调用 <see cref="T:System.IAsyncResult" /> 方法返回的 <see cref="Overload:System.ServiceModel.Channels.IInputChannel.BeginReceive" />。</span><span class="sxs-lookup"><span data-stu-id="3f1e3-154">The <see cref="T:System.IAsyncResult" /> returned by a call to the <see cref="Overload:System.ServiceModel.Channels.IInputChannel.BeginReceive" /> method.</span></span></param>
        <summary><span data-ttu-id="3f1e3-155">完成用于接收可用请求的异步操作。</span><span class="sxs-lookup"><span data-stu-id="3f1e3-155">Completes an asynchronous operation to receive an available request.</span></span></summary>
        <returns><span data-ttu-id="3f1e3-156">用于构造请求的回复的 <see cref="T:System.ServiceModel.Channels.RequestContext" />。</span><span class="sxs-lookup"><span data-stu-id="3f1e3-156">The <see cref="T:System.ServiceModel.Channels.RequestContext" /> used to construct a reply to the request.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3f1e3-157">如果接收的请求消息大于使用的绑定所允许的最大消息大小，则将引发 <xref:System.ServiceModel.QuotaExceededException>。</span><span class="sxs-lookup"><span data-stu-id="3f1e3-157">If the request message received is larger that the maximum message size allowed by the binding being used, a <xref:System.ServiceModel.QuotaExceededException> is thrown.</span></span> <span data-ttu-id="3f1e3-158">最大消息大小由 <xref:System.ServiceModel.Channels.TransportBindingElement.MaxReceivedMessageSize%2A> 属性设置。</span><span class="sxs-lookup"><span data-stu-id="3f1e3-158">The maximum message size is set by the <xref:System.ServiceModel.Channels.TransportBindingElement.MaxReceivedMessageSize%2A> property.</span></span> <span data-ttu-id="3f1e3-159">默认值为 65536 个字节。</span><span class="sxs-lookup"><span data-stu-id="3f1e3-159">The default value is 65536 bytes.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3f1e3-160">下面的代码演示如何实现此方法：</span><span class="sxs-lookup"><span data-stu-id="3f1e3-160">The following code illustrates how to implement this method:</span></span>  
  
 [!code-csharp[S_UE_MessageInterceptor#3](~/samples/snippets/csharp/VS_Snippets_CFX/s_ue_messageinterceptor/cs/interceptingchannellistener.cs#3)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para><span data-ttu-id="3f1e3-161">如果在操作完成前超出指定的 <see cref="T:System.TimeoutException" />，则此操作应引发 <paramref name="timeout" />。</span><span class="sxs-lookup"><span data-stu-id="3f1e3-161">The operation should throw a <see cref="T:System.TimeoutException" /> if the specified <paramref name="timeout" /> is exceeded before the operation is completed.</span></span></para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="EndTryReceiveRequest">
      <MemberSignature Language="C#" Value="public bool EndTryReceiveRequest (IAsyncResult result, out System.ServiceModel.Channels.RequestContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool EndTryReceiveRequest(class System.IAsyncResult result, [out] class System.ServiceModel.Channels.RequestContext&amp; context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.IReplyChannel.EndTryReceiveRequest(System.IAsyncResult,System.ServiceModel.Channels.RequestContext@)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndTryReceiveRequest (result As IAsyncResult, ByRef context As RequestContext) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool EndTryReceiveRequest(IAsyncResult ^ result, [Runtime::InteropServices::Out] System::ServiceModel::Channels::RequestContext ^ % context);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
        <Parameter Name="context" Type="System.ServiceModel.Channels.RequestContext&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="result"><span data-ttu-id="3f1e3-162">通过调用 <see cref="T:System.IAsyncResult" /> 方法返回的 <see cref="M:System.ServiceModel.Channels.IReplyChannel.BeginTryReceiveRequest(System.TimeSpan,System.AsyncCallback,System.Object)" />。</span><span class="sxs-lookup"><span data-stu-id="3f1e3-162">The <see cref="T:System.IAsyncResult" /> returned by a call to the <see cref="M:System.ServiceModel.Channels.IReplyChannel.BeginTryReceiveRequest(System.TimeSpan,System.AsyncCallback,System.Object)" /> method.</span></span></param>
        <param name="context"><span data-ttu-id="3f1e3-163">接收到的 <see cref="T:System.ServiceModel.Channels.RequestContext" />。</span><span class="sxs-lookup"><span data-stu-id="3f1e3-163">The <see cref="T:System.ServiceModel.Channels.RequestContext" /> received.</span></span></param>
        <summary><span data-ttu-id="3f1e3-164">完成用于接收请求消息的指定异步操作。</span><span class="sxs-lookup"><span data-stu-id="3f1e3-164">Completes the specified asynchronous operation to receive a request message.</span></span></summary>
        <returns>
          <span data-ttu-id="3f1e3-165">如果在经历指定的时间间隔之前接收到请求消息，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="3f1e3-165"><see langword="true" /> if a request message is received before the specified interval of time elapses; otherwise <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="3f1e3-166">下面的代码演示如何实现此方法：</span><span class="sxs-lookup"><span data-stu-id="3f1e3-166">The following code illustrates how to implement this method:</span></span>  
  
 [!code-csharp[S_UE_MessageInterceptor#6](~/samples/snippets/csharp/VS_Snippets_CFX/s_ue_messageinterceptor/cs/interceptingchannellistener.cs#6)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EndWaitForRequest">
      <MemberSignature Language="C#" Value="public bool EndWaitForRequest (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool EndWaitForRequest(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.IReplyChannel.EndWaitForRequest(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndWaitForRequest (result As IAsyncResult) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool EndWaitForRequest(IAsyncResult ^ result);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result"><span data-ttu-id="3f1e3-167"><see cref="T:System.IAsyncResult" />，标识要完成的 <see cref="M:System.ServiceModel.Channels.IReplyChannel.BeginWaitForRequest(System.TimeSpan,System.AsyncCallback,System.Object)" /> 操作，并且从它检索最终结果。</span><span class="sxs-lookup"><span data-stu-id="3f1e3-167">The <see cref="T:System.IAsyncResult" /> that identifies the <see cref="M:System.ServiceModel.Channels.IReplyChannel.BeginWaitForRequest(System.TimeSpan,System.AsyncCallback,System.Object)" /> operation to finish, and from which to retrieve an end result.</span></span></param>
        <summary><span data-ttu-id="3f1e3-168">完成指定的异步等待请求消息操作。</span><span class="sxs-lookup"><span data-stu-id="3f1e3-168">Completes the specified asynchronous wait-for-a-request message operation.</span></span></summary>
        <returns>
          <span data-ttu-id="3f1e3-169">如果在经历指定的时间间隔之前接收到请求，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="3f1e3-169"><see langword="true" /> if a request is received before the specified interval of time elapses; otherwise <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="3f1e3-170">下面的代码演示如何实现此方法：</span><span class="sxs-lookup"><span data-stu-id="3f1e3-170">The following code illustrates how to implement this method:</span></span>  
  
 [!code-csharp[S_UE_MessageInterceptor#11](~/samples/snippets/csharp/VS_Snippets_CFX/s_ue_messageinterceptor/cs/interceptingchannellistener.cs#11)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LocalAddress">
      <MemberSignature Language="C#" Value="public System.ServiceModel.EndpointAddress LocalAddress { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ServiceModel.EndpointAddress LocalAddress" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Channels.IReplyChannel.LocalAddress" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LocalAddress As EndpointAddress" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ServiceModel::EndpointAddress ^ LocalAddress { System::ServiceModel::EndpointAddress ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ServiceModel.EndpointAddress</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3f1e3-171">获取回复通道接收消息的地址。</span><span class="sxs-lookup"><span data-stu-id="3f1e3-171">Gets the address on which this reply channel receives messages.</span></span></summary>
        <value><span data-ttu-id="3f1e3-172">回复通道接收消息的 <see cref="T:System.ServiceModel.EndpointAddress" />。</span><span class="sxs-lookup"><span data-stu-id="3f1e3-172">The <see cref="T:System.ServiceModel.EndpointAddress" /> on which this reply channel receives messages.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="3f1e3-173">下面的代码演示如何实现此属性：</span><span class="sxs-lookup"><span data-stu-id="3f1e3-173">The following code illustrates how to implement this property:</span></span>  
  
 [!code-csharp[S_UE_MessageInterceptor#0](~/samples/snippets/csharp/VS_Snippets_CFX/s_ue_messageinterceptor/cs/interceptingchannellistener.cs#0)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReceiveRequest">
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="3f1e3-174">如果有可用的上下文，则返回接收到的请求的上下文。</span><span class="sxs-lookup"><span data-stu-id="3f1e3-174">Returns the context of the request received, if one is available</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReceiveRequest">
      <MemberSignature Language="C#" Value="public System.ServiceModel.Channels.RequestContext ReceiveRequest ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.ServiceModel.Channels.RequestContext ReceiveRequest() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.IReplyChannel.ReceiveRequest" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveRequest () As RequestContext" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::ServiceModel::Channels::RequestContext ^ ReceiveRequest();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ServiceModel.Channels.RequestContext</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="3f1e3-175">如果有可用的上下文，则返回接收到的请求的上下文。</span><span class="sxs-lookup"><span data-stu-id="3f1e3-175">Returns the context of the request received, if one is available.</span></span> <span data-ttu-id="3f1e3-176">如果没有可用的上下文，则等到有可用上下文为止。</span><span class="sxs-lookup"><span data-stu-id="3f1e3-176">If a context is not available, waits until there is one available.</span></span></summary>
        <returns><span data-ttu-id="3f1e3-177">用于构造回复的 <see cref="T:System.ServiceModel.Channels.RequestContext" />。</span><span class="sxs-lookup"><span data-stu-id="3f1e3-177">The <see cref="T:System.ServiceModel.Channels.RequestContext" /> used to construct replies.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3f1e3-178"><xref:System.ServiceModel.Channels.RequestContext> 包装请求消息和用于回复该消息的机制。</span><span class="sxs-lookup"><span data-stu-id="3f1e3-178"><xref:System.ServiceModel.Channels.RequestContext> encapsulates the request message and a mechanism for replying to that message.</span></span>  
  
 <span data-ttu-id="3f1e3-179"><xref:System.ServiceModel.Channels.IReplyChannel.ReceiveRequest%2A> 可以被多次调用或并发调用。</span><span class="sxs-lookup"><span data-stu-id="3f1e3-179"><xref:System.ServiceModel.Channels.IReplyChannel.ReceiveRequest%2A> can be called multiple times or concurrently.</span></span> <span data-ttu-id="3f1e3-180">对于每个接收的请求，仅完成一次 <xref:System.ServiceModel.Channels.IReplyChannel.ReceiveRequest%2A> 调用。</span><span class="sxs-lookup"><span data-stu-id="3f1e3-180">Only one <xref:System.ServiceModel.Channels.IReplyChannel.ReceiveRequest%2A> call completes per request received.</span></span>  
  
 <span data-ttu-id="3f1e3-181">如果接收的请求消息大于使用的绑定所允许的最大消息大小，则将引发 <xref:System.ServiceModel.QuotaExceededException>。</span><span class="sxs-lookup"><span data-stu-id="3f1e3-181">If the request message received is larger that the maximum message size allowed by the binding being used, a <xref:System.ServiceModel.QuotaExceededException> is thrown.</span></span> <span data-ttu-id="3f1e3-182">最大消息大小由 <xref:System.ServiceModel.Channels.TransportBindingElement.MaxReceivedMessageSize%2A> 属性设置。</span><span class="sxs-lookup"><span data-stu-id="3f1e3-182">The maximum message size is set by the <xref:System.ServiceModel.Channels.TransportBindingElement.MaxReceivedMessageSize%2A> property.</span></span> <span data-ttu-id="3f1e3-183">默认值为 65536 个字节。</span><span class="sxs-lookup"><span data-stu-id="3f1e3-183">The default value is 65536 bytes.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3f1e3-184">下面的代码演示如何实现此方法：</span><span class="sxs-lookup"><span data-stu-id="3f1e3-184">The following code illustrates how to implement this method:</span></span>  
  
 [!code-csharp[S_UE_MessageInterceptor#7](~/samples/snippets/csharp/VS_Snippets_CFX/s_ue_messageinterceptor/cs/interceptingchannellistener.cs#7)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReceiveRequest">
      <MemberSignature Language="C#" Value="public System.ServiceModel.Channels.RequestContext ReceiveRequest (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.ServiceModel.Channels.RequestContext ReceiveRequest(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.IReplyChannel.ReceiveRequest(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveRequest (timeout As TimeSpan) As RequestContext" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::ServiceModel::Channels::RequestContext ^ ReceiveRequest(TimeSpan timeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ServiceModel.Channels.RequestContext</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout"><span data-ttu-id="3f1e3-185">一个 <see cref="T:System.TimeSpan" />，指定接收请求操作的完成时限，在此时限之后操作将超时并返回 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="3f1e3-185">The <see cref="T:System.TimeSpan" /> that specifies how long the receive of a request operation has to complete before timing out and returning <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="3f1e3-186">如果有可用的上下文，则返回接收到的请求的上下文。</span><span class="sxs-lookup"><span data-stu-id="3f1e3-186">Returns the context of the request received, if one is available.</span></span> <span data-ttu-id="3f1e3-187">如果没有可用的上下文，则等到有可用上下文为止。</span><span class="sxs-lookup"><span data-stu-id="3f1e3-187">If a context is not available, waits until there is one available.</span></span></summary>
        <returns><span data-ttu-id="3f1e3-188">用于构造回复的 <see cref="T:System.ServiceModel.Channels.RequestContext" />。</span><span class="sxs-lookup"><span data-stu-id="3f1e3-188">The <see cref="T:System.ServiceModel.Channels.RequestContext" /> used to construct replies.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3f1e3-189"><xref:System.ServiceModel.Channels.RequestContext> 包装请求消息和用于回复该消息的机制。</span><span class="sxs-lookup"><span data-stu-id="3f1e3-189"><xref:System.ServiceModel.Channels.RequestContext> encapsulates the request message and a mechanism for replying to that message.</span></span>  
  
 <span data-ttu-id="3f1e3-190"><xref:System.ServiceModel.Channels.IReplyChannel.ReceiveRequest%2A> 可以被多次调用或并发调用。</span><span class="sxs-lookup"><span data-stu-id="3f1e3-190"><xref:System.ServiceModel.Channels.IReplyChannel.ReceiveRequest%2A> can be called multiple times or concurrently.</span></span> <span data-ttu-id="3f1e3-191">对于每个接收的请求，仅完成一次 <xref:System.ServiceModel.Channels.IReplyChannel.ReceiveRequest%2A> 调用。</span><span class="sxs-lookup"><span data-stu-id="3f1e3-191">Only one <xref:System.ServiceModel.Channels.IReplyChannel.ReceiveRequest%2A> call completes per request received.</span></span>  
  
 <span data-ttu-id="3f1e3-192">如果接收的请求消息大于使用的绑定所允许的最大消息大小，则将引发 <xref:System.ServiceModel.QuotaExceededException>。</span><span class="sxs-lookup"><span data-stu-id="3f1e3-192">If the request message received is larger that the maximum message size allowed by the binding being used, a <xref:System.ServiceModel.QuotaExceededException> is thrown.</span></span> <span data-ttu-id="3f1e3-193">最大消息大小由 <xref:System.ServiceModel.Channels.TransportBindingElement.MaxReceivedMessageSize%2A> 属性设置。</span><span class="sxs-lookup"><span data-stu-id="3f1e3-193">The maximum message size is set by the <xref:System.ServiceModel.Channels.TransportBindingElement.MaxReceivedMessageSize%2A> property.</span></span> <span data-ttu-id="3f1e3-194">默认值为 65536 个字节。</span><span class="sxs-lookup"><span data-stu-id="3f1e3-194">The default value is 65536 bytes.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3f1e3-195">下面的代码演示如何实现此方法：</span><span class="sxs-lookup"><span data-stu-id="3f1e3-195">The following code illustrates how to implement this method:</span></span>  
  
 [!code-csharp[S_UE_MessageInterceptor#8](~/samples/snippets/csharp/VS_Snippets_CFX/s_ue_messageinterceptor/cs/interceptingchannellistener.cs#8)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryReceiveRequest">
      <MemberSignature Language="C#" Value="public bool TryReceiveRequest (TimeSpan timeout, out System.ServiceModel.Channels.RequestContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool TryReceiveRequest(valuetype System.TimeSpan timeout, [out] class System.ServiceModel.Channels.RequestContext&amp; context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.IReplyChannel.TryReceiveRequest(System.TimeSpan,System.ServiceModel.Channels.RequestContext@)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryReceiveRequest (timeout As TimeSpan, ByRef context As RequestContext) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryReceiveRequest(TimeSpan timeout, [Runtime::InteropServices::Out] System::ServiceModel::Channels::RequestContext ^ % context);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="context" Type="System.ServiceModel.Channels.RequestContext&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="timeout"><span data-ttu-id="3f1e3-196">一个 <see cref="T:System.TimeSpan" />，指定接收请求操作的完成时限，在此时限之后操作将超时并返回 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="3f1e3-196">The <see cref="T:System.TimeSpan" /> that specifies how long the receive of a request operation has to complete before timing out and returning <see langword="false" />.</span></span></param>
        <param name="context"><span data-ttu-id="3f1e3-197">接收到的 <see cref="T:System.ServiceModel.Channels.RequestContext" />。</span><span class="sxs-lookup"><span data-stu-id="3f1e3-197">The <see cref="T:System.ServiceModel.Channels.RequestContext" /> received.</span></span></param>
        <summary><span data-ttu-id="3f1e3-198">返回一个值，该值指示是否在经历指定的时间间隔之前接收到请求。</span><span class="sxs-lookup"><span data-stu-id="3f1e3-198">Returns a value that indicates whether a request is received before a specified interval of time elapses.</span></span></summary>
        <returns>
          <span data-ttu-id="3f1e3-199">如果在经历指定的时间间隔之前接收到请求消息，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="3f1e3-199"><see langword="true" /> if a request message is received before the specified interval of time elapses; otherwise <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3f1e3-200">如果当前线程在等待请求消息到达队列时可以被阻塞，则使用 <xref:System.ServiceModel.Channels.IReplyChannel.TryReceiveRequest%28System.TimeSpan%2CSystem.ServiceModel.Channels.RequestContext%40%29>。</span><span class="sxs-lookup"><span data-stu-id="3f1e3-200">Use <xref:System.ServiceModel.Channels.IReplyChannel.TryReceiveRequest%28System.TimeSpan%2CSystem.ServiceModel.Channels.RequestContext%40%29> when it is acceptable for the current thread to be blocked while it waits for a request message to arrive in the queue.</span></span> <span data-ttu-id="3f1e3-201">该线程最多被阻塞 `timeout` 指定的时间长度。</span><span class="sxs-lookup"><span data-stu-id="3f1e3-201">The thread is blocked up to the specified `timeout`.</span></span> <span data-ttu-id="3f1e3-202">如果需要应用程序处理继续进行而不等待，则使用异步 <xref:System.ServiceModel.Channels.IReplyChannel.BeginTryReceiveRequest%28System.TimeSpan%2CSystem.AsyncCallback%2CSystem.Object%29> 方法。</span><span class="sxs-lookup"><span data-stu-id="3f1e3-202">If you need the application processing to continue without waiting, use the asynchronous <xref:System.ServiceModel.Channels.IReplyChannel.BeginTryReceiveRequest%28System.TimeSpan%2CSystem.AsyncCallback%2CSystem.Object%29> method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3f1e3-203">下面的代码演示如何实现此方法：</span><span class="sxs-lookup"><span data-stu-id="3f1e3-203">The following code illustrates how to implement this method:</span></span>  
  
 [!code-csharp[S_UE_MessageInterceptor#4](~/samples/snippets/csharp/VS_Snippets_CFX/s_ue_messageinterceptor/cs/interceptingchannellistener.cs#4)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para><span data-ttu-id="3f1e3-204">如果超出指定的 <see langword="false" />，此操作返回 <paramref name="timeout" />。</span><span class="sxs-lookup"><span data-stu-id="3f1e3-204">The operation returns <see langword="false" /> if the specified <paramref name="timeout" /> is exceeded.</span></span></para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="WaitForRequest">
      <MemberSignature Language="C#" Value="public bool WaitForRequest (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool WaitForRequest(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.IReplyChannel.WaitForRequest(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function WaitForRequest (timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool WaitForRequest(TimeSpan timeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout"><span data-ttu-id="3f1e3-205">一个 <see cref="T:System.TimeSpan" />，指定请求操作的完成时限，在此时限之后操作将超时并返回 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="3f1e3-205">The <see cref="T:System.TimeSpan" /> that specifies how long a request operation has to complete before timing out and returning <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="3f1e3-206">返回一个值，该值指示是否在经历指定的时间间隔之前接收到请求消息。</span><span class="sxs-lookup"><span data-stu-id="3f1e3-206">Returns a value that indicates whether a request message is received before a specified interval of time elapses.</span></span></summary>
        <returns>
          <span data-ttu-id="3f1e3-207">如果在经历指定的时间间隔之前接收到请求，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="3f1e3-207"><see langword="true" /> if a request is received before the specified interval of time elapses; otherwise <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3f1e3-208">调用 <xref:System.ServiceModel.Channels.IReplyChannel.WaitForRequest%28System.TimeSpan%29> 不会导致以任何方式接收或处理请求消息。</span><span class="sxs-lookup"><span data-stu-id="3f1e3-208">Calling <xref:System.ServiceModel.Channels.IReplyChannel.WaitForRequest%28System.TimeSpan%29> does not result in a request message being received or processed in any way.</span></span>  
  
 <span data-ttu-id="3f1e3-209"><xref:System.ServiceModel.Channels.IReplyChannel.BeginWaitForRequest%28System.TimeSpan%2CSystem.AsyncCallback%2CSystem.Object%29> 方法主要用于用户要使用事务接收消息的事务处理方案。</span><span class="sxs-lookup"><span data-stu-id="3f1e3-209">The <xref:System.ServiceModel.Channels.IReplyChannel.BeginWaitForRequest%28System.TimeSpan%2CSystem.AsyncCallback%2CSystem.Object%29> method exists primarily for transacted scenarios where the user wants to receive the message using a transaction.</span></span> <span data-ttu-id="3f1e3-210">在通常只需要为此使用 <xref:System.ServiceModel.Channels.IReplyChannel.ReceiveRequest%2A> 时，用户必须创建事务，然后调用 <xref:System.ServiceModel.Channels.IReplyChannel.ReceiveRequest%2A> 并希望消息在事务超时前到达，但这可能不可行。</span><span class="sxs-lookup"><span data-stu-id="3f1e3-210">When using just <xref:System.ServiceModel.Channels.IReplyChannel.ReceiveRequest%2A> normally for this, the user must create the transaction, and then call <xref:System.ServiceModel.Channels.IReplyChannel.ReceiveRequest%2A> and hope the message arrives before the transaction times out, which may not be possible.</span></span>  
  
 <span data-ttu-id="3f1e3-211">用户可以改为调用 <xref:System.ServiceModel.Channels.IReplyChannel.WaitForRequest%28System.TimeSpan%29> 并指定超时值（甚至是无限超时值），接着在消息到达时，可以打开事务，调用 <xref:System.ServiceModel.Channels.IReplyChannel.ReceiveRequest%2A> 并确信它们能在事务过期前取回消息。</span><span class="sxs-lookup"><span data-stu-id="3f1e3-211">Instead, the user can call <xref:System.ServiceModel.Channels.IReplyChannel.WaitForRequest%28System.TimeSpan%29> and specify the time out (even infinite), then when a message arrives they can open the transaction, call <xref:System.ServiceModel.Channels.IReplyChannel.ReceiveRequest%2A> and be confident that they can get the message back before the transaction expires.</span></span>  
  
 <span data-ttu-id="3f1e3-212">如果当前线程在等待消息到达队列时可以被阻塞，则使用 <xref:System.ServiceModel.Channels.IReplyChannel.WaitForRequest%28System.TimeSpan%29>。</span><span class="sxs-lookup"><span data-stu-id="3f1e3-212">Use <xref:System.ServiceModel.Channels.IReplyChannel.WaitForRequest%28System.TimeSpan%29> when it is acceptable for the current thread to be blocked while it waits for a message to arrive in the queue.</span></span> <span data-ttu-id="3f1e3-213">该线程最多被阻塞 `timeout` 指定的时间长度。</span><span class="sxs-lookup"><span data-stu-id="3f1e3-213">The thread is blocked up to the specified `timeout`.</span></span> <span data-ttu-id="3f1e3-214">如果需要应用程序处理继续进行而不等待，则使用异步 <xref:System.ServiceModel.Channels.IReplyChannel.BeginWaitForRequest%28System.TimeSpan%2CSystem.AsyncCallback%2CSystem.Object%29> 方法。</span><span class="sxs-lookup"><span data-stu-id="3f1e3-214">If you need the application processing to continue without waiting, use the asynchronous <xref:System.ServiceModel.Channels.IReplyChannel.BeginWaitForRequest%28System.TimeSpan%2CSystem.AsyncCallback%2CSystem.Object%29> method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3f1e3-215">下面的代码演示如何实现此方法：</span><span class="sxs-lookup"><span data-stu-id="3f1e3-215">The following code illustrates how to implement this method:</span></span>  
  
 [!code-csharp[S_UE_MessageInterceptor#9](~/samples/snippets/csharp/VS_Snippets_CFX/s_ue_messageinterceptor/cs/interceptingchannellistener.cs#9)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para><span data-ttu-id="3f1e3-216">如果超出指定的 <see langword="false" />，此操作返回 <paramref name="timeout" />。</span><span class="sxs-lookup"><span data-stu-id="3f1e3-216">The operation returns <see langword="false" /> if the specified <paramref name="timeout" /> is exceeded.</span></span></para>
        </block>
      </Docs>
    </Member>
  </Members>
</Type>