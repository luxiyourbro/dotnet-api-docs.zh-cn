<Type Name="MsmqBindingElementBase" FullName="System.ServiceModel.Channels.MsmqBindingElementBase">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="1b610f2bca30cb09c03c5512b442e872ec2ac896" />
    <Meta Name="ms.sourcegitcommit" Value="cc0c87a2e12b0fb9ba9ecdd3d4950f0572524db8" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-CN" />
    <Meta Name="ms.lasthandoff" Value="05/03/2018" />
    <Meta Name="ms.locfileid" Value="32694137" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class MsmqBindingElementBase : System.ServiceModel.Channels.TransportBindingElement, System.ServiceModel.Channels.ITransactedBindingElement, System.ServiceModel.Description.IPolicyExportExtension, System.ServiceModel.Description.IWsdlExportExtension" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit MsmqBindingElementBase extends System.ServiceModel.Channels.TransportBindingElement implements class System.ServiceModel.Channels.ITransactedBindingElement, class System.ServiceModel.Description.IPolicyExportExtension, class System.ServiceModel.Description.IWsdlExportExtension" />
  <TypeSignature Language="DocId" Value="T:System.ServiceModel.Channels.MsmqBindingElementBase" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class MsmqBindingElementBase&#xA;Inherits TransportBindingElement&#xA;Implements IPolicyExportExtension, ITransactedBindingElement, IWsdlExportExtension" />
  <TypeSignature Language="C++ CLI" Value="public ref class MsmqBindingElementBase abstract : System::ServiceModel::Channels::TransportBindingElement, System::ServiceModel::Channels::ITransactedBindingElement, System::ServiceModel::Description::IPolicyExportExtension, System::ServiceModel::Description::IWsdlExportExtension" />
  <AssemblyInfo>
    <AssemblyName>System.ServiceModel</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ServiceModel.Channels.TransportBindingElement</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ServiceModel.Channels.ITransactedBindingElement</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.ServiceModel.Description.IPolicyExportExtension</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.ServiceModel.Description.IWsdlExportExtension</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>
      <see cref="T:System.ServiceModel.MsmqIntegration.MsmqIntegrationBindingElement" /> 和 <see cref="T:System.ServiceModel.Channels.MsmqTransportBindingElement" /> 的基类。</summary>
    <remarks>To be added.</remarks>
  </Docs>
  <Members>
    <Member MemberName="CustomDeadLetterQueue">
      <MemberSignature Language="C#" Value="public Uri CustomDeadLetterQueue { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Uri CustomDeadLetterQueue" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Channels.MsmqBindingElementBase.CustomDeadLetterQueue" />
      <MemberSignature Language="VB.NET" Value="Public Property CustomDeadLetterQueue As Uri" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Uri ^ CustomDeadLetterQueue { Uri ^ get(); void set(Uri ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Uri</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个 <see cref="T:System.Uri" />，过期消息或未能传递的消息将在该 Uri 标识的自定义死信队列中进行发送。</summary>
        <value>自定义死信队列的 URI。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 死信队列是由发送应用程序的队列管理器管理的队列，可以存储未能传递或已过期的消息。 使用 <xref:System.ServiceModel.Channels.MsmqBindingElementBase.CustomDeadLetterQueue%2A> 属性可以指定自定义死信队列，而不必使用默认的系统级死信队列。  
  
 <xref:System.ServiceModel.Channels.MsmqBindingElementBase.CustomDeadLetterQueue%2A> 指定的 URI 必须使用 `net.msmq scheme`。  
  
 如果 <xref:System.ServiceModel.Channels.MsmqBindingElementBase.DeadLetterQueue%2A> 设置为 <xref:System.ServiceModel.DeadLetterQueue.None> 或 <xref:System.ServiceModel.DeadLetterQueue.System>，则 <xref:System.ServiceModel.Channels.MsmqBindingElementBase.CustomDeadLetterQueue%2A> 必须设置为 `null`。 如果 <xref:System.ServiceModel.Channels.MsmqBindingElementBase.CustomDeadLetterQueue%2A> 不为 `null`，则 <xref:System.ServiceModel.Channels.MsmqBindingElementBase.DeadLetterQueue%2A> 必须设置为 <xref:System.ServiceModel.DeadLetterQueue.Custom>。  
  
 <xref:System.ServiceModel.Channels.MsmqBindingElementBase.CustomDeadLetterQueue%2A> 属性只能在 [!INCLUDE[wv](~/includes/wv-md.md)] 或更高版本的操作系统上设置。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DeadLetterQueue">
      <MemberSignature Language="C#" Value="public System.ServiceModel.DeadLetterQueue DeadLetterQueue { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.ServiceModel.DeadLetterQueue DeadLetterQueue" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Channels.MsmqBindingElementBase.DeadLetterQueue" />
      <MemberSignature Language="VB.NET" Value="Public Property DeadLetterQueue As DeadLetterQueue" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ServiceModel::DeadLetterQueue DeadLetterQueue { System::ServiceModel::DeadLetterQueue get(); void set(System::ServiceModel::DeadLetterQueue value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ServiceModel.DeadLetterQueue</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置此绑定的 <see cref="T:System.ServiceModel.DeadLetterQueue" /> 设置。</summary>
        <value>要使用的死信队列（如果有的话）的类型。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 死信队列是由发送应用程序的队列管理器管理的队列，可以存储未能传递或已过期的消息。 造成消息未能到达接收应用程序的原因包括：  
  
-   事务性消息被发送到非事务性队列中。  
  
-   非事务性消息被发送到事务性队列中。  
  
-   未经身份验证的消息被发送到仅接受经过身份验证的消息的队列中。  
  
-   未加密的消息被发送到仅接受加密消息的队列中。  
  
-   消息在传递给接收方之前过期。  
  
-   超出了目标计算机的消息存储配额或目标队列的存储配额，或者在消息到达时目标计算机上没有可用的存储空间。  
  
-   发件人没有[访问权限](http://go.microsoft.com/fwlink/?LinkId=96167)所需的消息放入目标队列。  
  
-   附加在消息上的数字签名无效。  
  
-   加密的消息不能由目标队列管理器解密。  
  
-   目标队列在检索消息之前被清除或删除。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">该值不在 <see cref="T:System.ServiceModel.DeadLetterQueue" /> 中定义的值范围之内。</exception>
      </Docs>
    </Member>
    <Member MemberName="Durable">
      <MemberSignature Language="C#" Value="public bool Durable { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Durable" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Channels.MsmqBindingElementBase.Durable" />
      <MemberSignature Language="VB.NET" Value="Public Property Durable As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Durable { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值指定随此绑定发送的消息是持久的还是可变的。</summary>
        <value>
          如果此绑定处理的消息是持久的，则为 <see langword="true" />；如果这些消息是可变的，则为 <see langword="false" />。 默认值为 <see langword="true" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果此属性设置为 `true`，则消息是持久的；否则，消息是可变的。 即使队列管理器崩溃，持久性消息也不会丢失。 此属性的默认值为 `true`。 如果要求一次性保证（<xref:System.ServiceModel.Channels.MsmqBindingElementBase.ExactlyOnce%2A> 设置为 `true`），此属性必须设置为 `true`。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ExactlyOnce">
      <MemberSignature Language="C#" Value="public bool ExactlyOnce { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ExactlyOnce" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Channels.MsmqBindingElementBase.ExactlyOnce" />
      <MemberSignature Language="VB.NET" Value="Public Property ExactlyOnce As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ExactlyOnce { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值指定随此绑定发送的消息是否具有一次性保证。</summary>
        <value>
          如果随此绑定发送的消息具有一次性保证，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当 <xref:System.ServiceModel.Channels.MsmqBindingElementBase.ExactlyOnce%2A> 设置为 `true` 时，指示消息队列 (MSMQ) 会确保将发送的消息传递到接收消息队列一次且只有一次，如果传递失败，则会根据 `DeadLetterQueue` 属性设置，将消息发送到死信队列。 若要将 <xref:System.ServiceModel.Channels.MsmqBindingElementBase.ExactlyOnce%2A> 设置为 `true`，则要求队列为事务性队列。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetProperty&lt;T&gt;">
      <MemberSignature Language="C#" Value="public override T GetProperty&lt;T&gt; (System.ServiceModel.Channels.BindingContext context) where T : class;" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance !!T GetProperty&lt;class T&gt;(class System.ServiceModel.Channels.BindingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.MsmqBindingElementBase.GetProperty``1(System.ServiceModel.Channels.BindingContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetProperty(Of T As Class) (context As BindingContext) As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : class override T GetProperty(System::ServiceModel::Channels::BindingContext ^ context);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="context" Type="System.ServiceModel.Channels.BindingContext" />
      </Parameters>
      <Docs>
        <typeparam name="T">属性的类型。</typeparam>
        <param name="context">绑定元素的 <see cref="T:System.ServiceModel.Channels.BindingContext" />。</param>
        <summary>在派生类中重写时，为提供的绑定上下文检索指定类型的对象。</summary>
        <returns>类型 <paramref name="T" /> 的对象。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 可检索来自该元素的功能和保护要求。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">上下文为 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="MaxRetryCycles">
      <MemberSignature Language="C#" Value="public int MaxRetryCycles { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MaxRetryCycles" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Channels.MsmqBindingElementBase.MaxRetryCycles" />
      <MemberSignature Language="VB.NET" Value="Public Property MaxRetryCycles As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int MaxRetryCycles { int get(); void set(int value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置尝试向接收应用程序传递消息的最大重试周期数。</summary>
        <value>一个值，指定将消息传输到病毒消息队列之前的重试周期数。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 重试周期是指将消息从重试队列传输到应用程序队列以尝试向应用程序传递的时间。 若立即重试失败次数达到 <xref:System.ServiceModel.Configuration.MsmqBindingElementBase.ReceiveRetryCount%2A> 指定的值，消息则被放到重试队列中。 `MaxRetryCycles` 指定重试周期数，它不包含第一次发送消息的尝试。 最多会进行 (1 + MaxRetryCycles) * (ReceiveRetryCount + 1) 次传递消息的尝试。 例如，如果 ReceiveRetryCount 为 0，且 MaxRetryCycles 为 1，则最多将进行两次传递消息的尝试。 此属性只能在 [!INCLUDE[wv](~/includes/wv-md.md)] 或更高版本的操作系统上使用。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">值小于零。</exception>
      </Docs>
    </Member>
    <Member MemberName="MsmqTransportSecurity">
      <MemberSignature Language="C#" Value="public System.ServiceModel.MsmqTransportSecurity MsmqTransportSecurity { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ServiceModel.MsmqTransportSecurity MsmqTransportSecurity" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Channels.MsmqBindingElementBase.MsmqTransportSecurity" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MsmqTransportSecurity As MsmqTransportSecurity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ServiceModel::MsmqTransportSecurity ^ MsmqTransportSecurity { System::ServiceModel::MsmqTransportSecurity ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ServiceModel.MsmqTransportSecurity</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取与此绑定元素关联的 <see cref="T:System.ServiceModel.MsmqTransportSecurity" />。</summary>
        <value>与此绑定元素关联的 <see cref="T:System.ServiceModel.MsmqTransportSecurity" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ServiceModel.MsmqTransportSecurity> 可包装 MSMQ 集成传输的安全设置。 MSMQ 集成传输和排队传输的设置是相同的。 使用 <xref:System.ServiceModel.MsmqTransportSecurity> 可以设置身份验证模式、加密算法、安全哈希算法和保护级别。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReceiveContextEnabled">
      <MemberSignature Language="C#" Value="public bool ReceiveContextEnabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ReceiveContextEnabled" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Channels.MsmqBindingElementBase.ReceiveContextEnabled" />
      <MemberSignature Language="VB.NET" Value="Public Property ReceiveContextEnabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ReceiveContextEnabled { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个指示是否请求接收上下文行为的值。</summary>
        <value>
          如果此绑定支持接收上下文行为，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReceiveErrorHandling">
      <MemberSignature Language="C#" Value="public System.ServiceModel.ReceiveErrorHandling ReceiveErrorHandling { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.ServiceModel.ReceiveErrorHandling ReceiveErrorHandling" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Channels.MsmqBindingElementBase.ReceiveErrorHandling" />
      <MemberSignature Language="VB.NET" Value="Public Property ReceiveErrorHandling As ReceiveErrorHandling" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ServiceModel::ReceiveErrorHandling ReceiveErrorHandling { System::ServiceModel::ReceiveErrorHandling get(); void set(System::ServiceModel::ReceiveErrorHandling value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ServiceModel.ReceiveErrorHandling</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个枚举值，该值指定如何处理病毒消息和其他无法调度的消息。</summary>
        <value>一个 <see cref="T:System.ServiceModel.ReceiveErrorHandling" /> 值，指定如何处理病毒消息和其他无法调度的消息。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当此属性设置为 <xref:System.ServiceModel.ReceiveErrorHandling.Fault> 时，通道侦听器会出错，并且会跟踪和引发一个 <xref:System.ServiceModel.ProtocolException>（它包装一个 <xref:System.ServiceModel.MsmqPoisonMessageException>）。 消息会留在队列中，并且必须通过某种手动方法移除。 <xref:System.ServiceModel.MsmqPoisonMessageException> 包含一个 <xref:System.ServiceModel.MsmqPoisonMessageException.MessageLookupId%2A>，它可用于标识有问题的消息并将其从病毒消息队列中手动移除。  
  
 当此属性设置为 <xref:System.ServiceModel.ReceiveErrorHandling.Drop> 时，就会丢弃消息。  
  
 当此属性设置为 <xref:System.ServiceModel.ReceiveErrorHandling.Reject> 时，会将一个否定确认发送到客户端，并从病毒消息队列中移除消息。 此选项仅在“消息队列 4.0”(Message Queuing 4.0) 中可用。  
  
 当设置为 <xref:System.ServiceModel.ReceiveErrorHandling.Move> 时，会将消息移动到最后一个病毒子队列。 此选项仅在“消息队列 4.0”(Message Queuing 4.0) 中可用。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">该值不在 <see cref="T:System.ServiceModel.ReceiveErrorHandling" /> 中定义的值范围之内。</exception>
      </Docs>
    </Member>
    <Member MemberName="ReceiveRetryCount">
      <MemberSignature Language="C#" Value="public int ReceiveRetryCount { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ReceiveRetryCount" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Channels.MsmqBindingElementBase.ReceiveRetryCount" />
      <MemberSignature Language="VB.NET" Value="Public Property ReceiveRetryCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ReceiveRetryCount { int get(); void set(int value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置队列管理器在将消息传输到重试队列前可尝试发送该消息的最大次数。</summary>
        <value>一个值，指定队列管理器在将消息传输到重试队列前应尝试发送该消息的最大次数。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果达到尝试传递的最大次数且应用程序仍未处理消息，则会将消息发送到重试队列，以便在将来某个时刻重新进行传递。 将消息传输回发送队列之前的时间量由 <xref:System.ServiceModel.Channels.MsmqBindingElementBase.RetryCycleDelay%2A> 控制。 如果重试周期达到 MaxRetryCycles 值，则根据 <xref:System.ServiceModel.Channels.MsmqBindingElementBase.ReceiveErrorHandling%2A> 属性值调度此消息。  
  
 有关详细信息，请参阅 <xref:System.ServiceModel.Channels.MsmqBindingElementBase.MaxRetryCycles%2A> 和 <xref:System.ServiceModel.Channels.MsmqBindingElementBase.RetryCycleDelay%2A>。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">值小于零。</exception>
      </Docs>
    </Member>
    <Member MemberName="RetryCycleDelay">
      <MemberSignature Language="C#" Value="public TimeSpan RetryCycleDelay { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan RetryCycleDelay" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Channels.MsmqBindingElementBase.RetryCycleDelay" />
      <MemberSignature Language="VB.NET" Value="Public Property RetryCycleDelay As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TimeSpan RetryCycleDelay { TimeSpan get(); void set(TimeSpan value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值指定在尝试传递无法传递的消息时，尝试另一个重试周期之前应等待的时间。</summary>
        <value>一个 <see cref="T:System.TimeSpan" />，指定在开始下一个尝试传递到接收应用程序的周期前等待的时间间隔。 默认值为 30（分钟）。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 单个重试周期会重复尝试将消息传递给接收应用程序（由 <xref:System.ServiceModel.Configuration.MsmqBindingElementBase.MaxRetryCycles%2A> 属性指定）。 如果所有尝试都失败，则会将消息放回到重试队列中。 此属性指定在将消息传输到应用程序队列以便进入另一个重试周期之前，消息保留在重试队列中的时长。 此属性只能在 [!INCLUDE[wv](~/includes/wv-md.md)] 或更高版本的操作系统上使用。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">该值不可为无穷大，并且要大于 Int32.MaxValue 毫秒。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.ServiceModel.Description.IPolicyExportExtension.ExportPolicy">
      <MemberSignature Language="C#" Value="void IPolicyExportExtension.ExportPolicy (System.ServiceModel.Description.MetadataExporter exporter, System.ServiceModel.Description.PolicyConversionContext context);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.ServiceModel.Description.IPolicyExportExtension.ExportPolicy(class System.ServiceModel.Description.MetadataExporter exporter, class System.ServiceModel.Description.PolicyConversionContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.MsmqBindingElementBase.System#ServiceModel#Description#IPolicyExportExtension#ExportPolicy(System.ServiceModel.Description.MetadataExporter,System.ServiceModel.Description.PolicyConversionContext)" />
      <MemberSignature Language="VB.NET" Value="Sub ExportPolicy (exporter As MetadataExporter, context As PolicyConversionContext) Implements IPolicyExportExtension.ExportPolicy" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.ServiceModel.Description.IPolicyExportExtension.ExportPolicy(System::ServiceModel::Description::MetadataExporter ^ exporter, System::ServiceModel::Description::PolicyConversionContext ^ context) = System::ServiceModel::Description::IPolicyExportExtension::ExportPolicy;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ServiceModel.Description.IPolicyExportExtension.ExportPolicy(System.ServiceModel.Description.MetadataExporter,System.ServiceModel.Description.PolicyConversionContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="exporter" Type="System.ServiceModel.Description.MetadataExporter" />
        <Parameter Name="context" Type="System.ServiceModel.Description.PolicyConversionContext" />
      </Parameters>
      <Docs>
        <param name="exporter">可以用来修改导出过程的 <see cref="T:System.ServiceModel.Description.MetadataExporter" />。</param>
        <param name="context">可以用来插入自定义策略断言的 <see cref="T:System.ServiceModel.Description.PolicyConversionContext" />。</param>
        <summary>导出有关绑定的自定义策略断言。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 有关详情，请参阅<xref:System.ServiceModel.Description.IPolicyExportExtension>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.ServiceModel.Description.IWsdlExportExtension.ExportContract">
      <MemberSignature Language="C#" Value="void IWsdlExportExtension.ExportContract (System.ServiceModel.Description.WsdlExporter exporter, System.ServiceModel.Description.WsdlContractConversionContext context);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.ServiceModel.Description.IWsdlExportExtension.ExportContract(class System.ServiceModel.Description.WsdlExporter exporter, class System.ServiceModel.Description.WsdlContractConversionContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.MsmqBindingElementBase.System#ServiceModel#Description#IWsdlExportExtension#ExportContract(System.ServiceModel.Description.WsdlExporter,System.ServiceModel.Description.WsdlContractConversionContext)" />
      <MemberSignature Language="VB.NET" Value="Sub ExportContract (exporter As WsdlExporter, context As WsdlContractConversionContext) Implements IWsdlExportExtension.ExportContract" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.ServiceModel.Description.IWsdlExportExtension.ExportContract(System::ServiceModel::Description::WsdlExporter ^ exporter, System::ServiceModel::Description::WsdlContractConversionContext ^ context) = System::ServiceModel::Description::IWsdlExportExtension::ExportContract;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ServiceModel.Description.IWsdlExportExtension.ExportContract(System.ServiceModel.Description.WsdlExporter,System.ServiceModel.Description.WsdlContractConversionContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="exporter" Type="System.ServiceModel.Description.WsdlExporter" />
        <Parameter Name="context" Type="System.ServiceModel.Description.WsdlContractConversionContext" />
      </Parameters>
      <Docs>
        <param name="exporter">导出协定信息的 <see cref="T:System.ServiceModel.Description.WsdlExporter" />。</param>
        <param name="context">提供从导出的 WSDL 元素到协定说明的映射。</param>
        <summary>为协定将自定义 Web 服务描述语言 (WSDL) 元素写入到生成的 WSDL 中。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 有关详情，请参阅<xref:System.ServiceModel.Description.IWsdlExportExtension>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.ServiceModel.Description.IWsdlExportExtension.ExportEndpoint">
      <MemberSignature Language="C#" Value="void IWsdlExportExtension.ExportEndpoint (System.ServiceModel.Description.WsdlExporter exporter, System.ServiceModel.Description.WsdlEndpointConversionContext endpointContext);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.ServiceModel.Description.IWsdlExportExtension.ExportEndpoint(class System.ServiceModel.Description.WsdlExporter exporter, class System.ServiceModel.Description.WsdlEndpointConversionContext endpointContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.MsmqBindingElementBase.System#ServiceModel#Description#IWsdlExportExtension#ExportEndpoint(System.ServiceModel.Description.WsdlExporter,System.ServiceModel.Description.WsdlEndpointConversionContext)" />
      <MemberSignature Language="VB.NET" Value="Sub ExportEndpoint (exporter As WsdlExporter, endpointContext As WsdlEndpointConversionContext) Implements IWsdlExportExtension.ExportEndpoint" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.ServiceModel.Description.IWsdlExportExtension.ExportEndpoint(System::ServiceModel::Description::WsdlExporter ^ exporter, System::ServiceModel::Description::WsdlEndpointConversionContext ^ endpointContext) = System::ServiceModel::Description::IWsdlExportExtension::ExportEndpoint;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ServiceModel.Description.IWsdlExportExtension.ExportEndpoint(System.ServiceModel.Description.WsdlExporter,System.ServiceModel.Description.WsdlEndpointConversionContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="exporter" Type="System.ServiceModel.Description.WsdlExporter" />
        <Parameter Name="endpointContext" Type="System.ServiceModel.Description.WsdlEndpointConversionContext" />
      </Parameters>
      <Docs>
        <param name="exporter">导出终结点信息的 <see cref="T:System.ServiceModel.Description.WsdlExporter" />。</param>
        <param name="endpointContext">提供从导出的 WSDL 元素到终结点说明的映射。</param>
        <summary>为终结点将自定义 Web 服务描述语言 (WSDL) 元素写入到生成的 WSDL 中。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 有关详情，请参阅<xref:System.ServiceModel.Description.IWsdlExportExtension>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TimeToLive">
      <MemberSignature Language="C#" Value="public TimeSpan TimeToLive { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan TimeToLive" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Channels.MsmqBindingElementBase.TimeToLive" />
      <MemberSignature Language="VB.NET" Value="Public Property TimeToLive As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TimeSpan TimeToLive { TimeSpan get(); void set(TimeSpan value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值指定消息有效的时长。 过了这段时间之后，会根据 <see langword="DeadLetterQueue" /> 设置将消息放置到死信队列中。</summary>
        <value>一个 <see cref="T:System.TimeSpan" /> 值，它指定消息有效的时长。 默认值为 24 小时。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 排队应用程序以断开连接的方式工作。 这意味着发送和接收应用程序可能不同时运行。因此，发送应用程序所发送的消息可能不会立即受到接收应用程序处理。 有些消息包含只在某个时间段内有效的信息。 这样的消息如果未在这个时间段内传送，则不再包含有用的信息，应予以丢弃。 使用此属性可以指定在将消息传递到应用程序队列之前，应保留该消息的时间限制。 如果在将消息传递到应用程序队列之前，过了此时间限制，则会将消息放置到可用的死信队列中（由 <xref:System.ServiceModel.Configuration.MsmqBindingElementBase.DeadLetterQueue%2A> 属性确定）；否则，会丢弃消息。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">该值不可为无穷大，并且要大于 Int32.MaxValue 毫秒。</exception>
      </Docs>
    </Member>
    <Member MemberName="TransactedReceiveEnabled">
      <MemberSignature Language="C#" Value="public bool TransactedReceiveEnabled { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool TransactedReceiveEnabled" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Channels.MsmqBindingElementBase.TransactedReceiveEnabled" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TransactedReceiveEnabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool TransactedReceiveEnabled { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.ServiceModel.Channels.ITransactedBindingElement.TransactedReceiveEnabled</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指定是否需要使用事务来接收随此绑定发送的消息。</summary>
        <value>
          如果绑定需要使用事务来进行接收操作，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 调度程序会访问此属性来确定是否需要使用事务来进行接收操作。  
  
 在 WCF 中排队的传输返回`true`此属性，当且仅当<xref:System.ServiceModel.Channels.MsmqBindingElementBase.ExactlyOnce%2A>设置为`true`。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UseMsmqTracing">
      <MemberSignature Language="C#" Value="public bool UseMsmqTracing { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UseMsmqTracing" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Channels.MsmqBindingElementBase.UseMsmqTracing" />
      <MemberSignature Language="VB.NET" Value="Public Property UseMsmqTracing As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UseMsmqTracing { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值启用或禁用消息队列 (MSMQ) 内置消息跟踪工具。</summary>
        <value>
          如果应启用消息队列 (MSMQ) 内置消息跟踪，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果 <xref:System.ServiceModel.Configuration.MsmqBindingElementBase.UseMsmqTracing%2A> 设置为 `true`，则排队通道使用消息队列内置消息跟踪工具。 每当消息进入和离开队列管理器时，都会通过此工具将报告消息发送到指定的报告队列。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UseSourceJournal">
      <MemberSignature Language="C#" Value="public bool UseSourceJournal { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UseSourceJournal" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Channels.MsmqBindingElementBase.UseSourceJournal" />
      <MemberSignature Language="VB.NET" Value="Public Property UseSourceJournal As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UseSourceJournal { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值指示是否应将此绑定处理的消息副本存储到源日记队列中。</summary>
        <value>
          如果将此绑定处理的消息复制到源日记队列中，则为 <see langword="true" />；否则为 <see langword="false" />。 默认值为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果排队应用程序要保留已离开源计算机传出队列的消息的记录，则可以将这些消息复制到日记队列。 一旦消息离开传出队列，并且接收到目标计算机已接收该消息的确认后，该消息的副本就会保留在发送计算机的系统日记队列中。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ValidityDuration">
      <MemberSignature Language="C#" Value="public TimeSpan ValidityDuration { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan ValidityDuration" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Channels.MsmqBindingElementBase.ValidityDuration" />
      <MemberSignature Language="VB.NET" Value="Public Property ValidityDuration As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TimeSpan ValidityDuration { TimeSpan get(); void set(TimeSpan value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值指定由接收上下文功能锁定消息的持续时间。</summary>
        <value>将由接收上下文功能锁定消息的持续时间。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 默认值为 5 分钟。 接收上下文将锁定消息以进行检查，直到使用完消息或将其释放回队列。 有效期属性指定在自动将消息释放回队列之前，由接收上下文锁定消息的时长。  
  
> [!IMPORTANT]
>  当 <xref:System.ServiceModel.Channels.MsmqBindingElementBase.ValidityDuration%2A> 对某一消息过期时，如果过期是在事务处理期间发生的，则会随工作流实例一起中止用于其处理的任何事务。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">值小于零或大于 Int32.MaxValue。</exception>
      </Docs>
    </Member>
  </Members>
</Type>