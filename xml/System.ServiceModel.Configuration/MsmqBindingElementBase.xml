<Type Name="MsmqBindingElementBase" FullName="System.ServiceModel.Configuration.MsmqBindingElementBase">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="2ebaf0f46ff0a86c6d7eeb63127581c1c35f9a39" />
    <Meta Name="ms.sourcegitcommit" Value="1b899505ed6d42225f2b3c9150bfdc080d0d1f9b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-CN" />
    <Meta Name="ms.lasthandoff" Value="04/28/2018" />
    <Meta Name="ms.locfileid" Value="32090603" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class MsmqBindingElementBase : System.ServiceModel.Configuration.StandardBindingElement" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit MsmqBindingElementBase extends System.ServiceModel.Configuration.StandardBindingElement" />
  <TypeSignature Language="DocId" Value="T:System.ServiceModel.Configuration.MsmqBindingElementBase" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class MsmqBindingElementBase&#xA;Inherits StandardBindingElement" />
  <TypeSignature Language="C++ CLI" Value="public ref class MsmqBindingElementBase abstract : System::ServiceModel::Configuration::StandardBindingElement" />
  <AssemblyInfo>
    <AssemblyName>System.ServiceModel</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ServiceModel.Configuration.StandardBindingElement</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>提供一个基类，该基类具有 <see cref="T:System.ServiceModel.Configuration.NetMsmqBindingElement" /> 和 <see cref="T:System.ServiceModel.Configuration.MsmqIntegrationBindingElement" /> 类共有的成员。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此类包含配置基于消息队列（也称为 MSMQ）的绑定所需的设置。  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>初始化 <see cref="T:System.ServiceModel.Configuration.MsmqBindingElementBase" /> 类的新实例。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected MsmqBindingElementBase ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Configuration.MsmqBindingElementBase.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; MsmqBindingElementBase();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>初始化 <see cref="T:System.ServiceModel.Configuration.MsmqBindingElementBase" /> 类的新实例。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected MsmqBindingElementBase (string name);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Configuration.MsmqBindingElementBase.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (name As String)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; MsmqBindingElementBase(System::String ^ name);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">绑定的配置名称。 由于此值用于标识此特定绑定，因此应是唯一的。</param>
        <summary>使用指定的名称初始化 <see cref="T:System.ServiceModel.Configuration.MsmqBindingElementBase" /> 类的新实例。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CustomDeadLetterQueue">
      <MemberSignature Language="C#" Value="public Uri CustomDeadLetterQueue { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Uri CustomDeadLetterQueue" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Configuration.MsmqBindingElementBase.CustomDeadLetterQueue" />
      <MemberSignature Language="VB.NET" Value="Public Property CustomDeadLetterQueue As Uri" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Uri ^ CustomDeadLetterQueue { Uri ^ get(); void set(Uri ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Configuration.ConfigurationProperty("customDeadLetterQueue", DefaultValue=Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Uri</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个 <see cref="T:System.Uri" />，过期消息或未能传递的消息将在该 Uri 标识的自定义死信队列中进行发送。</summary>
        <value>一个 <see cref="T:System.Uri" /> 实例，它包含自定义死信队列的 URI。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A*死信队列*是由发送应用程序的队列管理器，用于存储未能传递或已过期的消息队列。 使用 `CustomDeadLetterQueue` 属性可以指定自定义死信队列，而不必使用默认的系统级死信队列。  
  
 <xref:System.ServiceModel.Configuration.MsmqBindingElementBase.CustomDeadLetterQueue%2A> 指定的 URI 必须使用 net.msmq 方案。  
  
 如果 <xref:System.ServiceModel.Configuration.MsmqBindingElementBase.DeadLetterQueue%2A> 设置为 <xref:System.ServiceModel.DeadLetterQueue.None> 或 <xref:System.ServiceModel.DeadLetterQueue.System>，则 <xref:System.ServiceModel.Configuration.MsmqBindingElementBase.CustomDeadLetterQueue%2A> 必须设置为 `null`。 如果 <xref:System.ServiceModel.Configuration.MsmqBindingElementBase.CustomDeadLetterQueue%2A> 不为 `null`，则 <xref:System.ServiceModel.Configuration.MsmqBindingElementBase.DeadLetterQueue%2A> 必须设置为 <xref:System.ServiceModel.DeadLetterQueue.Custom>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DeadLetterQueue">
      <MemberSignature Language="C#" Value="public System.ServiceModel.DeadLetterQueue DeadLetterQueue { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.ServiceModel.DeadLetterQueue DeadLetterQueue" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Configuration.MsmqBindingElementBase.DeadLetterQueue" />
      <MemberSignature Language="VB.NET" Value="Public Property DeadLetterQueue As DeadLetterQueue" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ServiceModel::DeadLetterQueue DeadLetterQueue { System::ServiceModel::DeadLetterQueue get(); void set(System::ServiceModel::DeadLetterQueue value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Configuration.ConfigurationProperty("deadLetterQueue", DefaultValue=Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ServiceModel.DeadLetterQueue</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置此绑定的 <see cref="T:System.ServiceModel.DeadLetterQueue" /> 设置。</summary>
        <value>一个 <see cref="T:System.ServiceModel.DeadLetterQueue" /> 值，指定要使用的死信队列（如果有）的类型。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 *死信队列*是由发送应用程序的队列管理器，用于存储未能传递或已过期的消息队列。 造成消息未能到达接收应用程序的原因包括：  
  
-   事务性消息被发送到非事务性队列中。  
  
-   非事务性消息被发送到事务性队列中。  
  
-   未经身份验证的消息被发送到仅接受经过身份验证的消息的队列中。  
  
-   未加密的消息被发送到仅接受加密消息的队列中。  
  
-   消息在传递给接收方之前过期。  
  
-   超出了目标计算机的消息存储配额或目标队列的存储配额，或者在消息到达时目标计算机上没有可用的存储空间。  
  
-   发件人没有[访问权限](http://go.microsoft.com/fwlink/?LinkID=96167)所需的消息放入目标队列。  
  
-   附加在消息上的数字签名无效。  
  
-   加密的消息不能由目标队列管理器解密。  
  
-   目标队列在检索消息之前被清除或删除。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Durable">
      <MemberSignature Language="C#" Value="public bool Durable { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Durable" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Configuration.MsmqBindingElementBase.Durable" />
      <MemberSignature Language="VB.NET" Value="Public Property Durable As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Durable { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Configuration.ConfigurationProperty("durable", DefaultValue=Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值指定随此绑定发送的消息是持久的还是可变的。</summary>
        <value>
          如果此绑定处理的消息是持久的，则为 <see langword="true" />；如果这些消息是可变的，则为 <see langword="false" />。 默认值为 <see langword="true" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果此属性设置为 `true`，则消息是持久的；否则，消息是可变的。 即使队列管理器崩溃，持久性消息也不会丢失。 此属性的默认值为 `true`。 如果要求一次性保证（<xref:System.ServiceModel.Channels.MsmqBindingElementBase.ExactlyOnce%2A> 设置为 `true`），此属性必须设置为 `true`。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ExactlyOnce">
      <MemberSignature Language="C#" Value="public bool ExactlyOnce { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ExactlyOnce" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Configuration.MsmqBindingElementBase.ExactlyOnce" />
      <MemberSignature Language="VB.NET" Value="Public Property ExactlyOnce As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ExactlyOnce { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Configuration.ConfigurationProperty("exactlyOnce", DefaultValue=Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值指定随此绑定发送的消息是否具有一次性保证。</summary>
        <value>
          如果随此绑定发送的消息具有一次性保证，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ServiceModel.Channels.MsmqBindingElementBase.ExactlyOnce%2A>当设置为`true`，指示消息队列 (也称为 MSMQ) 确保，发送的消息传递到接收的消息队列一次且只有一次。 如果传递失败，将消息发送到死信队列，具体取决于`DeadLetterQueue`属性设置。 若要将 <xref:System.ServiceModel.Channels.MsmqBindingElementBase.ExactlyOnce%2A> 设置为 `true`，则要求队列为事务性队列。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InitializeFrom">
      <MemberSignature Language="C#" Value="protected internal override void InitializeFrom (System.ServiceModel.Channels.Binding binding);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance void InitializeFrom(class System.ServiceModel.Channels.Binding binding) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Configuration.MsmqBindingElementBase.InitializeFrom(System.ServiceModel.Channels.Binding)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override void InitializeFrom(System::ServiceModel::Channels::Binding ^ binding);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binding" Type="System.ServiceModel.Channels.Binding" />
      </Parameters>
      <Docs>
        <param name="binding">一个绑定，包含用于初始化此绑定的设置。</param>
        <summary>使用指定绑定的内容初始化此绑定。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MaxReceivedMessageSize">
      <MemberSignature Language="C#" Value="public long MaxReceivedMessageSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 MaxReceivedMessageSize" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Configuration.MsmqBindingElementBase.MaxReceivedMessageSize" />
      <MemberSignature Language="VB.NET" Value="Public Property MaxReceivedMessageSize As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long MaxReceivedMessageSize { long get(); void set(long value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Configuration.ConfigurationProperty("maxReceivedMessageSize", DefaultValue=Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Configuration.LongValidator(MinValue=0)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值指示允许的最大消息大小（以字节为单位）。</summary>
        <value>允许随此绑定发送或接收的消息的最大大小。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果传入消息大于 <xref:System.ServiceModel.Configuration.MsmqBindingElementBase.MaxReceivedMessageSize%2A>，则会丢弃该消息。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MaxRetryCycles">
      <MemberSignature Language="C#" Value="public int MaxRetryCycles { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MaxRetryCycles" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Configuration.MsmqBindingElementBase.MaxRetryCycles" />
      <MemberSignature Language="VB.NET" Value="Public Property MaxRetryCycles As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int MaxRetryCycles { int get(); void set(int value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Configuration.ConfigurationProperty("maxRetryCycles", DefaultValue=Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Configuration.IntegerValidator(MinValue=0)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置尝试向接收应用程序传递消息的最大重试周期数。</summary>
        <value>将消息传输到病毒消息队列之前要尝试的最大重试周期数。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A*重试周期*是一条消息从重试队列传输到应用程序队列以尝试传递给应用程序时。 若立即重试失败次数达到 <xref:System.ServiceModel.Configuration.MsmqBindingElementBase.ReceiveRetryCount%2A> 指定的值，消息则被放到重试队列中。 <xref:System.ServiceModel.Configuration.MsmqBindingElementBase.MaxRetryCycles%2A> 指定重试周期数，它不包含第一次发送消息的尝试。 最多会进行 (1 + MaxRetryCycles) * (ReceiveRetryCount + 1) 次传递消息的尝试。 例如，如果 ReceiveRetryCount 为 0，且 MaxRetryCycles 为 1，则最多将进行两次传递消息的尝试。 此属性可以在 [!INCLUDE[wv](~/includes/wv-md.md)] 操作系统及其更高版本上使用。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnApplyConfiguration">
      <MemberSignature Language="C#" Value="protected override void OnApplyConfiguration (System.ServiceModel.Channels.Binding binding);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnApplyConfiguration(class System.ServiceModel.Channels.Binding binding) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Configuration.MsmqBindingElementBase.OnApplyConfiguration(System.ServiceModel.Channels.Binding)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnApplyConfiguration(System::ServiceModel::Channels::Binding ^ binding);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binding" Type="System.ServiceModel.Channels.Binding" />
      </Parameters>
      <Docs>
        <param name="binding">一个绑定，包含要应用的设置。</param>
        <summary>在将此绑定的内容应用到指定绑定时调用。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Properties">
      <MemberSignature Language="C#" Value="protected override System.Configuration.ConfigurationPropertyCollection Properties { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Configuration.ConfigurationPropertyCollection Properties" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Configuration.MsmqBindingElementBase.Properties" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides ReadOnly Property Properties As ConfigurationPropertyCollection" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property System::Configuration::ConfigurationPropertyCollection ^ Properties { System::Configuration::ConfigurationPropertyCollection ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Configuration.ConfigurationPropertyCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个 <see cref="T:System.Configuration.ConfigurationPropertyCollection" /> 实例，该实例包含一个 <see cref="T:System.Configuration.ConfigurationProperty" /> 对象集合，这些对象可以是此配置元素的属性或 <see cref="T:System.Configuration.ConfigurationElement" /> 对象。</summary>
        <value>一个 <see cref="T:System.Configuration.ConfigurationPropertyCollection" /> 实例，该实例包含一个 <see cref="T:System.Configuration.ConfigurationProperty" /> 对象集合，这些对象可以是此绑定配置元素的特性或 <see cref="T:System.Configuration.ConfigurationElement" /> 对象。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReceiveContextEnabled">
      <MemberSignature Language="C#" Value="public bool ReceiveContextEnabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ReceiveContextEnabled" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Configuration.MsmqBindingElementBase.ReceiveContextEnabled" />
      <MemberSignature Language="VB.NET" Value="Public Property ReceiveContextEnabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ReceiveContextEnabled { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Configuration.ConfigurationProperty("receiveContextEnabled", DefaultValue=Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值指定是否启用为处理队列中消息的接收上下文。</summary>
        <value>
          如果启用接收上下文来处理队列中的消息，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 启用后，服务可以"扫视"队列的消息以开始处理它，并且，如果发生任何错误并且引发异常，将其保留在队列。 服务还可"锁定"消息以便重试时间以后处理。 ReceiveContext 提供了一种机制来"完成"的消息一次处理，因此可以从队列中移除。 在处理期间，将不再通过网络读取消息并将其重写到队列中，而且各个消息不会在不同的服务实例之间传来传去。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReceiveErrorHandling">
      <MemberSignature Language="C#" Value="public System.ServiceModel.ReceiveErrorHandling ReceiveErrorHandling { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.ServiceModel.ReceiveErrorHandling ReceiveErrorHandling" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Configuration.MsmqBindingElementBase.ReceiveErrorHandling" />
      <MemberSignature Language="VB.NET" Value="Public Property ReceiveErrorHandling As ReceiveErrorHandling" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ServiceModel::ReceiveErrorHandling ReceiveErrorHandling { System::ServiceModel::ReceiveErrorHandling get(); void set(System::ServiceModel::ReceiveErrorHandling value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Configuration.ConfigurationProperty("receiveErrorHandling", DefaultValue=Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ServiceModel.ReceiveErrorHandling</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个枚举值，该值指定如何处理病毒消息和无法调度的消息。</summary>
        <value>一个 <see cref="T:System.ServiceModel.ReceiveErrorHandling" /> 值，指定如何处理病毒消息和无法调度的消息。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当此属性设置为 <xref:System.ServiceModel.ReceiveErrorHandling.Fault> 时，侦听器会出错，并且会跟踪和引发一个 <xref:System.ServiceModel.ProtocolException>（它包装一个 <xref:System.ServiceModel.MsmqPoisonMessageException>）。 消息会留在队列中，必须以手动方式将其移除。 <xref:System.ServiceModel.MsmqPoisonMessageException> 包含一个 <xref:System.ServiceModel.MsmqPoisonMessageException.MessageLookupId%2A>，它可用于识别相关消息并将其从病毒消息队列中手动移除。  
  
 当此属性设置为 <xref:System.ServiceModel.ReceiveErrorHandling.Drop> 时，只是丢弃有问题的消息。  
  
 将此属性设置为 <xref:System.ServiceModel.ReceiveErrorHandling.Reject> 时，会将一个否定确认发送到客户端，并从病毒消息队列中移除消息。 此选项仅在消息队列 (MSMQ) 4.0 中可用。  
  
 将此属性设置为 <xref:System.ServiceModel.ReceiveErrorHandling.Move> 时，会将相关消息移动到最终病毒消息子队列。 此选项仅在消息队列（也称为 MSMQ）4.0 中可用。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReceiveRetryCount">
      <MemberSignature Language="C#" Value="public int ReceiveRetryCount { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ReceiveRetryCount" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Configuration.MsmqBindingElementBase.ReceiveRetryCount" />
      <MemberSignature Language="VB.NET" Value="Public Property ReceiveRetryCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ReceiveRetryCount { int get(); void set(int value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Configuration.ConfigurationProperty("receiveRetryCount", DefaultValue=Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Configuration.IntegerValidator(MinValue=0)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置在应用程序队列到应用程序的消息传输失败时，队列管理器最多可尝试的立即重试次数。</summary>
        <value>队列管理器在将消息传输到重试队列前应该尝试发送该消息的最大次数。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果达到尝试传递的最大次数且应用程序仍未访问消息，则会将消息发送到重试队列，以便在以后重新进行传递。 将消息传输回发送队列之前的时间量由 <xref:System.ServiceModel.Channels.MsmqBindingElementBase.RetryCycleDelay%2A> 控制。 如果重试周期达到 <xref:System.ServiceModel.Channels.MsmqBindingElementBase.MaxRetryCycles%2A> 值，则或者将消息发送到病毒消息队列，或者将否定确认发送回发送方。  
  
 有关详细信息，请参阅 <xref:System.ServiceModel.Channels.MsmqBindingElementBase.MaxRetryCycles%2A> 和 <xref:System.ServiceModel.Channels.MsmqBindingElementBase.RetryCycleDelay%2A>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RetryCycleDelay">
      <MemberSignature Language="C#" Value="public TimeSpan RetryCycleDelay { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan RetryCycleDelay" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Configuration.MsmqBindingElementBase.RetryCycleDelay" />
      <MemberSignature Language="VB.NET" Value="Public Property RetryCycleDelay As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TimeSpan RetryCycleDelay { TimeSpan get(); void set(TimeSpan value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.ServiceModel.Configuration.TimeSpanOrInfiniteConverter))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Configuration.ConfigurationProperty("retryCycleDelay", DefaultValue=Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值指定在尝试传递无法传递的消息时，尝试另一个重试周期之前应等待的时间。</summary>
        <value>一个 <see cref="T:System.TimeSpan" />，指定在开始下一个尝试传递到接收应用程序的周期前等待的时间间隔。 默认值为 30（分钟）。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 单个重试周期会重复尝试将消息传递给接收应用程序（由 <xref:System.ServiceModel.Configuration.MsmqBindingElementBase.MaxRetryCycles%2A> 属性指定）。 如果所有尝试都失败，则会将消息放回到重试队列中。 此属性指定在将消息传输到应用程序队列以便进入另一个重试周期之前，消息保留在重试队列中的时长。 此属性可以在 [!INCLUDE[wv](~/includes/wv-md.md)] 或更高版本的操作系统上使用。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TimeToLive">
      <MemberSignature Language="C#" Value="public TimeSpan TimeToLive { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan TimeToLive" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Configuration.MsmqBindingElementBase.TimeToLive" />
      <MemberSignature Language="VB.NET" Value="Public Property TimeToLive As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TimeSpan TimeToLive { TimeSpan get(); void set(TimeSpan value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.ServiceModel.Configuration.TimeSpanOrInfiniteConverter))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Configuration.ConfigurationProperty("timeToLive", DefaultValue=Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值指定消息有效的时长。 过了这段时间之后，消息会放置到死信队列（如果有）中。</summary>
        <value>一个 <see cref="T:System.TimeSpan" /> 值，它指定消息有效的时长。 默认值为 24 小时。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 根据设计，排队的应用程序以断开连接的方式工作，因此，发送应用程序和接收应用程序可能不会同时运行。 因此，发送应用程序所发送的消息可能不会立即被接收应用程序处理。 有些消息包含只在特定时间段内有效的信息。 如果未在该时间段内传递此消息，则该消息将不再包含有用的信息，应予以丢弃。 使用此属性可以指定在将消息传递到应用程序队列之前，应保留该消息的时间限制。 如果在将消息传递到应用程序队列之前过了此时间限制，则会将消息放到死信队列（如果有，这由 <xref:System.ServiceModel.Configuration.MsmqBindingElementBase.DeadLetterQueue%2A> 属性确定）中；否则，如果没有死信队列，则会丢弃消息。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UseMsmqTracing">
      <MemberSignature Language="C#" Value="public bool UseMsmqTracing { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UseMsmqTracing" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Configuration.MsmqBindingElementBase.UseMsmqTracing" />
      <MemberSignature Language="VB.NET" Value="Public Property UseMsmqTracing As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UseMsmqTracing { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Configuration.ConfigurationProperty("useMsmqTracing", DefaultValue=Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值指示是否使用“消息队列”（也称为 MSMQ）内置消息跟踪工具。</summary>
        <value>
          如果应使用消息队列 (MSMQ) 内置消息跟踪设备，则为 <see langword="true" />；否则为 <see langword="false" />。 默认值为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果 <xref:System.ServiceModel.Configuration.MsmqBindingElementBase.UseMsmqTracing%2A> 设置为 `true`，则排队通道使用消息队列内置消息跟踪工具。 每当消息进入和离开队列管理器时，都会通过此工具将报告消息发送到指定的报告队列。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UseSourceJournal">
      <MemberSignature Language="C#" Value="public bool UseSourceJournal { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UseSourceJournal" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Configuration.MsmqBindingElementBase.UseSourceJournal" />
      <MemberSignature Language="VB.NET" Value="Public Property UseSourceJournal As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UseSourceJournal { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Configuration.ConfigurationProperty("useSourceJournal", DefaultValue=Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值指示是否应将此绑定处理的消息副本存储到源日记队列中。</summary>
        <value>
          如果将此绑定处理的消息复制到源日记队列中，则为 <see langword="true" />；否则为 <see langword="false" />。 默认值为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果排队应用程序要保留已离开源计算机传出队列的消息的记录，则可以将这些消息复制到日记队列。 一旦消息离开传出队列，并且接收到目标计算机已接收该消息的确认后，该消息的副本就会保留在发送计算机的系统日记队列中。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ValidityDuration">
      <MemberSignature Language="C#" Value="public TimeSpan ValidityDuration { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan ValidityDuration" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Configuration.MsmqBindingElementBase.ValidityDuration" />
      <MemberSignature Language="VB.NET" Value="Public Property ValidityDuration As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TimeSpan ValidityDuration { TimeSpan get(); void set(TimeSpan value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.ServiceModel.Configuration.TimeSpanOrInfiniteConverter))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Configuration.ConfigurationProperty("validityDuration", DefaultValue=Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值指示在使用排队通道时的连接超时。</summary>
        <value>与排队通道一起使用时，连接超时。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  当 <xref:System.ServiceModel.Configuration.MsmqBindingElementBase.ValidityDuration%2A> 对某一消息过期时，如果过期是在事务处理期间发生的，则会随工作流实例一起中止用于其处理的任何事务。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>