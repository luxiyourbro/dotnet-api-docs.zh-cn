<Type Name="ClientRuntime" FullName="System.ServiceModel.Dispatcher.ClientRuntime">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="13c9c9a364d2c16952c63ddcb34520a87afb6552" />
    <Meta Name="ms.sourcegitcommit" Value="0d6aa6694f157a08fe52cd25b4d9d3dcf913e812" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-CN" />
    <Meta Name="ms.lasthandoff" Value="10/12/2018" />
    <Meta Name="ms.locfileid" Value="49133157" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class ClientRuntime" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit ClientRuntime extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.ServiceModel.Dispatcher.ClientRuntime" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class ClientRuntime" />
  <TypeSignature Language="C++ CLI" Value="public ref class ClientRuntime sealed" />
  <TypeSignature Language="F#" Value="type ClientRuntime = class" />
  <AssemblyInfo>
    <AssemblyName>System.ServiceModel</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ServiceModel.Dispatcher.ClientRuntimeCompatBase</BaseTypeName>
    <BaseTypeName FrameworkAlternate="xamarinandroid-7.1">System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>表示类的插入点，这些类可以扩展客户端应用程序处理的所有消息的 Windows Communication Foundation (WCF) 客户端对象的功能。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 WCF 客户端对象的扩展是否<xref:System.ServiceModel.ClientBase%601>或<xref:System.ServiceModel.IClientChannel>、 Windows Communication Foundation (WCF) 客户端应用程序使用方法调用转换为出站消息并将传入消息转换为对象并将它们传递给客户端方法的结果。  
  
 <xref:System.ServiceModel.Dispatcher.ClientRuntime> 类是一个扩展点，您可以将截获消息并在所有操作中扩展客户端行为的扩展对象添加到该扩展点。 截获对象可以在特定的约定中处理所有消息，仅处理特定操作的消息，执行自定义通道初始化，以及实现其他自定义客户端应用程序行为。 客户端体系结构的概述，请参阅[WCF 客户端体系结构](~/docs/framework/wcf/feature-details/client-architecture.md)。 有关客户端编程的详细信息，请参阅[使用 WCF 客户端访问服务](~/docs/framework/wcf/feature-details/accessing-services-using-a-client.md)。 有关自定义项和如何执行这些详细信息，请参阅[扩展客户端](~/docs/framework/wcf/extending/extending-clients.md)。  
  
-   <xref:System.ServiceModel.Dispatcher.ClientRuntime.CallbackDispatchRuntime%2A> 属性返回服务启动的回调操作的调度运行时对象。  
  
-   <xref:System.ServiceModel.Dispatcher.ClientRuntime.OperationSelector%2A> 属性接受使用自定义操作选择器对象来控制客户端消息的路由。  
  
-   使用 <xref:System.ServiceModel.Dispatcher.ClientRuntime.ChannelInitializers%2A> 属性可以添加检查或修改客户端通道的通道初始值设定项。  
  
-   <xref:System.ServiceModel.Dispatcher.ClientRuntime.InteractiveChannelInitializers%2A> 属性可用于显示可视化提示，使用户可以在打开通道前选择凭据。  
  
-   <xref:System.ServiceModel.Dispatcher.ClientRuntime.Operations%2A> 属性获取 <xref:System.ServiceModel.Dispatcher.ClientOperation> 对象的集合，您可以将提供特定于该操作的消息的功能的自定义消息拦截器添加到该集合。  
  
-   使用 <xref:System.ServiceModel.Dispatcher.ClientRuntime.ManualAddressing%2A> 属性，应用程序可以关闭某些自动寻址标头来直接控制寻址。  
  
-   使用 <xref:System.ServiceModel.Dispatcher.ClientRuntime.MaxFaultSize%2A> 属性，客户端可以限制客户端接受的错误消息的大小。  
  
-   <xref:System.ServiceModel.Dispatcher.ClientRuntime.MessageInspectors%2A> 属性获取 <xref:System.ServiceModel.Dispatcher.IClientMessageInspector> 对象的集合，您可以将通过客户端的所有消息的自定义消息拦截器添加到这些对象。  
  
-   <xref:System.ServiceModel.Dispatcher.ClientRuntime.UnhandledClientOperation%2A> 属性返回意外消息被传递到的操作。  
  
-   <xref:System.ServiceModel.Dispatcher.ClientRuntime.ValidateMustUnderstand%2A> 属性通知系统它是否应确认标记为 `MustUnderstand` 的 SOAP 标头是否确实已被理解。  
  
-   <xref:System.ServiceModel.Dispatcher.ClientRuntime.Via%2A> 属性设置传输级别的消息的目标的值，来支持中介以及其他方案。  
  
 另外，还有其他多个属性可以检索客户端协定信息：  
  
-   <xref:System.ServiceModel.Dispatcher.ClientRuntime.ContractName%2A>  
  
-   <xref:System.ServiceModel.Dispatcher.ClientRuntime.ContractNamespace%2A>  
  
-   <xref:System.ServiceModel.Dispatcher.ClientRuntime.ContractClientType%2A>  
  
 如果客户端是双工客户端，以下属性还可以检索客户端回调类型以及运行时：  
  
-   <xref:System.ServiceModel.Dispatcher.ClientRuntime.CallbackClientType%2A>  
  
-   <xref:System.ServiceModel.Dispatcher.ClientRuntime.CallbackDispatchRuntime%2A>  
  
   
  
## Examples  
 在下面的代码示例中，<xref:System.ServiceModel.Description.IEndpointBehavior?displayProperty=nameWithType> 通过将 <xref:System.ServiceModel.Dispatcher.IClientMessageInspector?displayProperty=nameWithType> 添加到 <xref:System.ServiceModel.Dispatcher.ClientRuntime.MessageInspectors%2A> 属性，从而将它插入到客户端运行时中。  
  
 [!code-csharp[Interceptors#2](~/samples/snippets/csharp/VS_Snippets_CFX/interceptors/cs/insertingbehaviors.cs#2)]
 [!code-vb[Interceptors#2](~/samples/snippets/visualbasic/VS_Snippets_CFX/interceptors/vb/insertingbehaviors.vb#2)]  
  
 下面的代码示例演示将终结点行为加载到客户端终结点的配置文件。  
  
 [!code-xml[Interceptors#3](~/samples/snippets/csharp/VS_Snippets_CFX/interceptors/cs/client.exe.config#3)]   
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="CallbackClientType">
      <MemberSignature Language="C#" Value="public Type CallbackClientType { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type CallbackClientType" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Dispatcher.ClientRuntime.CallbackClientType" />
      <MemberSignature Language="VB.NET" Value="Public Property CallbackClientType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Type ^ CallbackClientType { Type ^ get(); void set(Type ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CallbackClientType : Type with get, set" Usage="System.ServiceModel.Dispatcher.ClientRuntime.CallbackClientType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置与双工客户端关联的回调协定的类型。</summary>
        <value>表示与双工客户端关联的回调协定的 <see cref="T:System.Type" /> 对象。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CallbackDispatchRuntime">
      <MemberSignature Language="C#" Value="public System.ServiceModel.Dispatcher.DispatchRuntime CallbackDispatchRuntime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ServiceModel.Dispatcher.DispatchRuntime CallbackDispatchRuntime" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Dispatcher.ClientRuntime.CallbackDispatchRuntime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CallbackDispatchRuntime As DispatchRuntime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ServiceModel::Dispatcher::DispatchRuntime ^ CallbackDispatchRuntime { System::ServiceModel::Dispatcher::DispatchRuntime ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CallbackDispatchRuntime : System.ServiceModel.Dispatcher.DispatchRuntime" Usage="System.ServiceModel.Dispatcher.ClientRuntime.CallbackDispatchRuntime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ServiceModel.Dispatcher.DispatchRuntime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取调度服务启动的操作的调度运行时。</summary>
        <value>
          <see cref="T:System.ServiceModel.Dispatcher.DispatchRuntime" /> 对象。 如果协定是双工协定，则调度行为包含服务启动的操作；否则调度行为不包含任何操作。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ChannelInitializers">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.SynchronizedCollection&lt;System.ServiceModel.Dispatcher.IChannelInitializer&gt; ChannelInitializers { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.SynchronizedCollection`1&lt;class System.ServiceModel.Dispatcher.IChannelInitializer&gt; ChannelInitializers" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Dispatcher.ClientRuntime.ChannelInitializers" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ChannelInitializers As SynchronizedCollection(Of IChannelInitializer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::SynchronizedCollection&lt;System::ServiceModel::Dispatcher::IChannelInitializer ^&gt; ^ ChannelInitializers { System::Collections::Generic::SynchronizedCollection&lt;System::ServiceModel::Dispatcher::IChannelInitializer ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ChannelInitializers : System.Collections.Generic.SynchronizedCollection&lt;System.ServiceModel.Dispatcher.IChannelInitializer&gt;" Usage="System.ServiceModel.Dispatcher.ClientRuntime.ChannelInitializers" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.SynchronizedCollection&lt;System.ServiceModel.Dispatcher.IChannelInitializer&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取通道初始值设定项对象的集合，这些对象用于自定义与客户端关联的通道。</summary>
        <value>
          <see cref="T:System.ServiceModel.Dispatcher.IChannelInitializer" /> 实现的集合。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用 <xref:System.ServiceModel.Dispatcher.ClientRuntime.ChannelInitializers%2A> 属性来添加自定义 <xref:System.ServiceModel.Dispatcher.IChannelInitializer> 对象，该对象可以检查创建时与客户端关联的通道，在通道上注册事件，以及使用 <xref:System.ServiceModel.IExtension%601> 将状态与该通道相关联。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ClientMessageInspectors">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.ICollection&lt;System.ServiceModel.Dispatcher.IClientMessageInspector&gt; ClientMessageInspectors { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.ICollection`1&lt;class System.ServiceModel.Dispatcher.IClientMessageInspector&gt; ClientMessageInspectors" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Dispatcher.ClientRuntime.ClientMessageInspectors" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ClientMessageInspectors As ICollection(Of IClientMessageInspector)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::ICollection&lt;System::ServiceModel::Dispatcher::IClientMessageInspector ^&gt; ^ ClientMessageInspectors { System::Collections::Generic::ICollection&lt;System::ServiceModel::Dispatcher::IClientMessageInspector ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ClientMessageInspectors : System.Collections.Generic.ICollection&lt;System.ServiceModel.Dispatcher.IClientMessageInspector&gt;" Usage="System.ServiceModel.Dispatcher.ClientRuntime.ClientMessageInspectors" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.ICollection&lt;System.ServiceModel.Dispatcher.IClientMessageInspector&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取用于查看或修改特殊服务操作消息的消息检查对象的集合。</summary>
        <value>用于查看或修改特定服务操作消息的消息检查器对象的集合。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ClientMessateInspectors 是线程安全集合。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ClientOperations">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.ICollection&lt;System.ServiceModel.Dispatcher.ClientOperation&gt; ClientOperations { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.ICollection`1&lt;class System.ServiceModel.Dispatcher.ClientOperation&gt; ClientOperations" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Dispatcher.ClientRuntime.ClientOperations" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ClientOperations As ICollection(Of ClientOperation)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::ICollection&lt;System::ServiceModel::Dispatcher::ClientOperation ^&gt; ^ ClientOperations { System::Collections::Generic::ICollection&lt;System::ServiceModel::Dispatcher::ClientOperation ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ClientOperations : System.Collections.Generic.ICollection&lt;System.ServiceModel.Dispatcher.ClientOperation&gt;" Usage="System.ServiceModel.Dispatcher.ClientRuntime.ClientOperations" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.ICollection&lt;System.ServiceModel.Dispatcher.ClientOperation&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取用于关联扩展对象的客户操作对象和某种特殊服务操作行为的集合，其中的扩展对象检查和修改消息。</summary>
        <value>用于附加扩展对象的客户操作对象的集合，这些扩展对象可以检查或修改消息和特定服务操作的行为。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ClientOperations 是线程安全集合。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContractClientType">
      <MemberSignature Language="C#" Value="public Type ContractClientType { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type ContractClientType" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Dispatcher.ClientRuntime.ContractClientType" />
      <MemberSignature Language="VB.NET" Value="Public Property ContractClientType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Type ^ ContractClientType { Type ^ get(); void set(Type ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ContractClientType : Type with get, set" Usage="System.ServiceModel.Dispatcher.ClientRuntime.ContractClientType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置与客户端关联的协定的类型。</summary>
        <value>表示与此客户端关联的协定的 <see cref="T:System.Type" /> 对象。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ContractName">
      <MemberSignature Language="C#" Value="public string ContractName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ContractName" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Dispatcher.ClientRuntime.ContractName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ContractName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ContractName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ContractName : string" Usage="System.ServiceModel.Dispatcher.ClientRuntime.ContractName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取与客户端关联的协定的名称。</summary>
        <value>客户端的协定名称。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ContractNamespace">
      <MemberSignature Language="C#" Value="public string ContractNamespace { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ContractNamespace" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Dispatcher.ClientRuntime.ContractNamespace" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ContractNamespace As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ContractNamespace { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ContractNamespace : string" Usage="System.ServiceModel.Dispatcher.ClientRuntime.ContractNamespace" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取与客户端关联的协定的命名空间。</summary>
        <value>与客户端关联的协定的命名空间。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="InteractiveChannelInitializers">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.SynchronizedCollection&lt;System.ServiceModel.Dispatcher.IInteractiveChannelInitializer&gt; InteractiveChannelInitializers { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.SynchronizedCollection`1&lt;class System.ServiceModel.Dispatcher.IInteractiveChannelInitializer&gt; InteractiveChannelInitializers" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Dispatcher.ClientRuntime.InteractiveChannelInitializers" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property InteractiveChannelInitializers As SynchronizedCollection(Of IInteractiveChannelInitializer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::SynchronizedCollection&lt;System::ServiceModel::Dispatcher::IInteractiveChannelInitializer ^&gt; ^ InteractiveChannelInitializers { System::Collections::Generic::SynchronizedCollection&lt;System::ServiceModel::Dispatcher::IInteractiveChannelInitializer ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.InteractiveChannelInitializers : System.Collections.Generic.SynchronizedCollection&lt;System.ServiceModel.Dispatcher.IInteractiveChannelInitializer&gt;" Usage="System.ServiceModel.Dispatcher.ClientRuntime.InteractiveChannelInitializers" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.SynchronizedCollection&lt;System.ServiceModel.Dispatcher.IInteractiveChannelInitializer&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取交互式信道初始化软件的集合。</summary>
        <value>类型为 <see cref="T:System.ServiceModel.Dispatcher.IInteractiveChannelInitializer" /> 的同步集合。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 有关如何使用交互式通道初始值设定项的详细信息，请参阅[使用 WCF 客户端访问服务](~/docs/framework/wcf/feature-details/accessing-services-using-a-client.md)。  
  
   
  
## Examples  
 下面的代码示例演示如何使用的终结点行为来插入交互式通道初始值设定项。  
  
 [!code-csharp[IInteractiveChannelInitializer#10](~/samples/snippets/csharp/VS_Snippets_CFX/iinteractivechannelinitializer/cs/insertingbehaviors.cs#10)]
 [!code-vb[IInteractiveChannelInitializer#10](~/samples/snippets/visualbasic/VS_Snippets_CFX/iinteractivechannelinitializer/vb/insertingbehaviors.vb#10)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ManualAddressing">
      <MemberSignature Language="C#" Value="public bool ManualAddressing { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ManualAddressing" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Dispatcher.ClientRuntime.ManualAddressing" />
      <MemberSignature Language="VB.NET" Value="Public Property ManualAddressing As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ManualAddressing { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.ManualAddressing : bool with get, set" Usage="System.ServiceModel.Dispatcher.ClientRuntime.ManualAddressing" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值指示客户端是否将寻址标头添加到请求-回复消息。</summary>
        <value>如果客户端不添加任何寻址标头，则为 <see langword="true" />；否则为 <see langword="false" />。 默认值为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果要防止客户端将“消息 ID”和“答复”寻址标头添加到请求/响应消息，请将 <xref:System.ServiceModel.Dispatcher.ClientRuntime.ManualAddressing%2A> 属性设置为 `true`，以便您的应用程序可以控制这些标头。  
  
> [!NOTE]
>  如果 <xref:System.ServiceModel.Dispatcher.ClientRuntime.ManualAddressing%2A> 为 `true`，则客户端不支持双工通道上的请求-回复操作。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MaxFaultSize">
      <MemberSignature Language="C#" Value="public int MaxFaultSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MaxFaultSize" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Dispatcher.ClientRuntime.MaxFaultSize" />
      <MemberSignature Language="VB.NET" Value="Public Property MaxFaultSize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int MaxFaultSize { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.MaxFaultSize : int with get, set" Usage="System.ServiceModel.Dispatcher.ClientRuntime.MaxFaultSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置错误的最大大小。</summary>
        <value>一个表示错误的最大大小的整数。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用 <xref:System.ServiceModel.Dispatcher.ClientRuntime.MaxFaultSize%2A> 属性来限制客户端运行时接受的错误消息的大小。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MessageInspectors">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.SynchronizedCollection&lt;System.ServiceModel.Dispatcher.IClientMessageInspector&gt; MessageInspectors { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.SynchronizedCollection`1&lt;class System.ServiceModel.Dispatcher.IClientMessageInspector&gt; MessageInspectors" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Dispatcher.ClientRuntime.MessageInspectors" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MessageInspectors As SynchronizedCollection(Of IClientMessageInspector)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::SynchronizedCollection&lt;System::ServiceModel::Dispatcher::IClientMessageInspector ^&gt; ^ MessageInspectors { System::Collections::Generic::SynchronizedCollection&lt;System::ServiceModel::Dispatcher::IClientMessageInspector ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MessageInspectors : System.Collections.Generic.SynchronizedCollection&lt;System.ServiceModel.Dispatcher.IClientMessageInspector&gt;" Usage="System.ServiceModel.Dispatcher.ClientRuntime.MessageInspectors" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.SynchronizedCollection&lt;System.ServiceModel.Dispatcher.IClientMessageInspector&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取客户端的消息检查器实现的集合。</summary>
        <value>
          <see cref="T:System.ServiceModel.Dispatcher.IClientMessageInspector" /> 实现的集合。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用 <xref:System.ServiceModel.Dispatcher.ClientRuntime.MessageInspectors%2A> 属性可以附加自定义 <xref:System.ServiceModel.Dispatcher.IClientMessageInspector> 实现，以检查或修改流过客户端的所有消息。  
  
   
  
## Examples  
 在下面的代码示例中，<xref:System.ServiceModel.Description.IEndpointBehavior?displayProperty=nameWithType> 通过将 <xref:System.ServiceModel.Dispatcher.IClientMessageInspector?displayProperty=nameWithType> 添加到 <xref:System.ServiceModel.Dispatcher.ClientRuntime.MessageInspectors%2A> 属性，从而将它插入到客户端运行时中。  
  
 [!code-csharp[Interceptors#2](~/samples/snippets/csharp/VS_Snippets_CFX/interceptors/cs/insertingbehaviors.cs#2)]
 [!code-vb[Interceptors#2](~/samples/snippets/visualbasic/VS_Snippets_CFX/interceptors/vb/insertingbehaviors.vb#2)]  
  
 下面的代码示例演示将终结点行为加载到客户端终结点的配置文件。  
  
 [!code-xml[Interceptors#3](~/samples/snippets/csharp/VS_Snippets_CFX/interceptors/cs/client.exe.config#3)]   
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MessageVersionNoneFaultsEnabled">
      <MemberSignature Language="C#" Value="public bool MessageVersionNoneFaultsEnabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool MessageVersionNoneFaultsEnabled" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Dispatcher.ClientRuntime.MessageVersionNoneFaultsEnabled" />
      <MemberSignature Language="VB.NET" Value="Public Property MessageVersionNoneFaultsEnabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool MessageVersionNoneFaultsEnabled { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.MessageVersionNoneFaultsEnabled : bool with get, set" Usage="System.ServiceModel.Dispatcher.ClientRuntime.MessageVersionNoneFaultsEnabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值指示是否设置 MessageVersionNoneFaultsEnabled 属性。</summary>
        <value>如果 MessageVersionNoneFaultsEnabled 属性已设置；则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Operations">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.SynchronizedKeyedCollection&lt;string,System.ServiceModel.Dispatcher.ClientOperation&gt; Operations { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.SynchronizedKeyedCollection`2&lt;string, class System.ServiceModel.Dispatcher.ClientOperation&gt; Operations" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Dispatcher.ClientRuntime.Operations" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Operations As SynchronizedKeyedCollection(Of String, ClientOperation)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::SynchronizedKeyedCollection&lt;System::String ^, System::ServiceModel::Dispatcher::ClientOperation ^&gt; ^ Operations { System::Collections::Generic::SynchronizedKeyedCollection&lt;System::String ^, System::ServiceModel::Dispatcher::ClientOperation ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Operations : System.Collections.Generic.SynchronizedKeyedCollection&lt;string, System.ServiceModel.Dispatcher.ClientOperation&gt;" Usage="System.ServiceModel.Dispatcher.ClientRuntime.Operations" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.SynchronizedKeyedCollection&lt;System.String,System.ServiceModel.Dispatcher.ClientOperation&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取客户端的客户端操作的集合。</summary>
        <value>
          <see cref="T:System.ServiceModel.Dispatcher.ClientOperation" /> 对象的同步集合。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用 <xref:System.ServiceModel.Dispatcher.ClientRuntime.Operations%2A> 属性可以获取此客户端的、可用于附加扩展对象的所有操作的集合，而这些扩展对象可以检查或修改局限于特定操作的消息和行为。 有关详细信息，请参阅<xref:System.ServiceModel.Dispatcher.ClientOperation>。  
  
   
  
## Examples  
 在下面的代码示例中，<xref:System.ServiceModel.Description.IEndpointBehavior?displayProperty=nameWithType> 通过将 <xref:System.ServiceModel.Dispatcher.IParameterInspector?displayProperty=nameWithType> 添加到 <xref:System.ServiceModel.Dispatcher.ClientOperation> 属性中的每个 <xref:System.ServiceModel.Dispatcher.ClientRuntime.Operations%2A>，从而将它插入到客户端运行时中。  
  
 [!code-csharp[Interceptors#2](~/samples/snippets/csharp/VS_Snippets_CFX/interceptors/cs/insertingbehaviors.cs#2)]
 [!code-vb[Interceptors#2](~/samples/snippets/visualbasic/VS_Snippets_CFX/interceptors/vb/insertingbehaviors.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OperationSelector">
      <MemberSignature Language="C#" Value="public System.ServiceModel.Dispatcher.IClientOperationSelector OperationSelector { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ServiceModel.Dispatcher.IClientOperationSelector OperationSelector" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Dispatcher.ClientRuntime.OperationSelector" />
      <MemberSignature Language="VB.NET" Value="Public Property OperationSelector As IClientOperationSelector" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ServiceModel::Dispatcher::IClientOperationSelector ^ OperationSelector { System::ServiceModel::Dispatcher::IClientOperationSelector ^ get(); void set(System::ServiceModel::Dispatcher::IClientOperationSelector ^ value); };" />
      <MemberSignature Language="F#" Value="member this.OperationSelector : System.ServiceModel.Dispatcher.IClientOperationSelector with get, set" Usage="System.ServiceModel.Dispatcher.ClientRuntime.OperationSelector" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ServiceModel.Dispatcher.IClientOperationSelector</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置可用于选择 <see cref="T:System.ServiceModel.Dispatcher.IClientOperationSelector" /> 的一个 <see cref="T:System.ServiceModel.Dispatcher.ClientOperation" /> 实现。</summary>
        <value>选择 <see cref="T:System.ServiceModel.Dispatcher.IClientOperationSelector" /> 的 <see cref="T:System.ServiceModel.Dispatcher.ClientOperation" /> 对象。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用 <xref:System.ServiceModel.Dispatcher.ClientRuntime.OperationSelector%2A> 属性在客户端调用特定方法时修改操作的选择。 默认的算法是将操作方法的 <xref:System.ServiceModel.OperationContractAttribute.Name%2A> 的名称用作关键字，在 <xref:System.ServiceModel.Dispatcher.ClientOperation> 集合中查找 <xref:System.ServiceModel.Dispatcher.ClientRuntime.Operations%2A>。 如果找不到匹配的 <xref:System.ServiceModel.Dispatcher.ClientOperation> 对象，则调用将被调度到 <xref:System.ServiceModel.Dispatcher.ClientOperation> 属性返回的 <xref:System.ServiceModel.Dispatcher.ClientRuntime.UnhandledClientOperation%2A> 对象。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UnhandledClientOperation">
      <MemberSignature Language="C#" Value="public System.ServiceModel.Dispatcher.ClientOperation UnhandledClientOperation { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ServiceModel.Dispatcher.ClientOperation UnhandledClientOperation" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Dispatcher.ClientRuntime.UnhandledClientOperation" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property UnhandledClientOperation As ClientOperation" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ServiceModel::Dispatcher::ClientOperation ^ UnhandledClientOperation { System::ServiceModel::Dispatcher::ClientOperation ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UnhandledClientOperation : System.ServiceModel.Dispatcher.ClientOperation" Usage="System.ServiceModel.Dispatcher.ClientRuntime.UnhandledClientOperation" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ServiceModel.Dispatcher.ClientOperation</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取在 <see cref="T:System.ServiceModel.Dispatcher.ClientOperation" /> 集合中不具有相应的 <see cref="P:System.ServiceModel.Dispatcher.ClientRuntime.Operations" /> 的方法的客户端操作。</summary>
        <value>一个 <see cref="T:System.ServiceModel.Dispatcher.ClientOperation" />，它表示当操作选择器找不到与消息匹配的操作时，当前消息内容被路由到的方法。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ValidateMustUnderstand">
      <MemberSignature Language="C#" Value="public bool ValidateMustUnderstand { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ValidateMustUnderstand" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Dispatcher.ClientRuntime.ValidateMustUnderstand" />
      <MemberSignature Language="VB.NET" Value="Public Property ValidateMustUnderstand As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ValidateMustUnderstand { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.ValidateMustUnderstand : bool with get, set" Usage="System.ServiceModel.Dispatcher.ClientRuntime.ValidateMustUnderstand" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值指定是由系统还是由应用程序强制执行 SOAP <see langword="MustUnderstand" /> 标头处理。</summary>
        <value>如果由系统执行 SOAP 标头 <see langword="true" /> 处理，则为 <see langword="MustUnderstand" />，否则为 <see langword="false" />，这表示由应用程序执行此处理。 默认值为 <see langword="true" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用 <xref:System.ServiceModel.Dispatcher.ClientRuntime.ValidateMustUnderstand%2A> 属性来关闭对到达的消息头强制执行验证。 在正常执行过程中，将消息头与 <xref:System.ServiceModel.Channels.MessageHeaders.UnderstoodHeaders%2A> 属性进行比较，来确认是否由服务显式处理到达的消息。 将此属性设置为 `false` 可以禁用此检查。 当设置为 `false` 时，应用程序必须检查有 MustUnderstand="true" 标记的标头，如果其中一个或多个标头没有被理解，则返回错误。 当应用程序应接受任何返回的 SOAP 消息（例如，使用类型化消息或非类型化消息）以及执行自定义标头处理时，这将很有用。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Via">
      <MemberSignature Language="C#" Value="public Uri Via { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Uri Via" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Dispatcher.ClientRuntime.Via" />
      <MemberSignature Language="VB.NET" Value="Public Property Via As Uri" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Uri ^ Via { Uri ^ get(); void set(Uri ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Via : Uri with get, set" Usage="System.ServiceModel.Dispatcher.ClientRuntime.Via" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Uri</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置用于通过客户端发送消息的传输地址。</summary>
        <value>
          <see cref="T:System.Uri" />，它是传输的目标地址。 默认值为客户端的 <see cref="P:System.ServiceModel.EndpointAddress.Uri" /> 值。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当消息的直接目标不是客户端的 <xref:System.ServiceModel.Dispatcher.ClientRuntime.Via%2A> 时，设置 <xref:System.ServiceModel.EndpointAddress.Uri%2A> 属性来指定消息的传输地址。 这使您可以指定 SOAP 中介，以及处理客户端的 <xref:System.ServiceModel.EndpointAddress.Uri%2A> 属性的值不是逻辑名称的情况。  
  
 <xref:System.ServiceModel.Description.ClientViaBehavior?displayProperty=nameWithType> 在配置文件中设置的就是这个值。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>