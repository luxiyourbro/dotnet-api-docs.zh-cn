<Type Name="FederatedMessageSecurityOverHttp" FullName="System.ServiceModel.FederatedMessageSecurityOverHttp">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="8b252907155a82244d21a81a05ba20ad5f1f834a" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-CN" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36411743" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class FederatedMessageSecurityOverHttp" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit FederatedMessageSecurityOverHttp extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.ServiceModel.FederatedMessageSecurityOverHttp" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class FederatedMessageSecurityOverHttp" />
  <TypeSignature Language="C++ CLI" Value="public ref class FederatedMessageSecurityOverHttp sealed" />
  <TypeSignature Language="F#" Value="type FederatedMessageSecurityOverHttp = class" />
  <AssemblyInfo>
    <AssemblyName>System.ServiceModel</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>配置 <see langword="WSFederationHttpBinding" /> 绑定的消息级安全性。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此类包含的属性可为客户端和服务之间的各个安全配置方面提供控制，包括与服务期望客户端从中检索联合凭据的颁发者相关的详细信息。  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FederatedMessageSecurityOverHttp ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.FederatedMessageSecurityOverHttp.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FederatedMessageSecurityOverHttp();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>初始化 <see cref="T:System.ServiceModel.FederatedMessageSecurityOverHttp" /> 类的新实例。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AlgorithmSuite">
      <MemberSignature Language="C#" Value="public System.ServiceModel.Security.SecurityAlgorithmSuite AlgorithmSuite { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ServiceModel.Security.SecurityAlgorithmSuite AlgorithmSuite" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.FederatedMessageSecurityOverHttp.AlgorithmSuite" />
      <MemberSignature Language="VB.NET" Value="Public Property AlgorithmSuite As SecurityAlgorithmSuite" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ServiceModel::Security::SecurityAlgorithmSuite ^ AlgorithmSuite { System::ServiceModel::Security::SecurityAlgorithmSuite ^ get(); void set(System::ServiceModel::Security::SecurityAlgorithmSuite ^ value); };" />
      <MemberSignature Language="F#" Value="member this.AlgorithmSuite : System.ServiceModel.Security.SecurityAlgorithmSuite with get, set" Usage="System.ServiceModel.FederatedMessageSecurityOverHttp.AlgorithmSuite" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ServiceModel.Security.SecurityAlgorithmSuite</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取和设置指定消息加密算法和密钥换行算法的算法套件。</summary>
        <value>
          <see cref="T:System.ServiceModel.Security.SecurityAlgorithmSuite" />。 默认值为 <see cref="P:System.ServiceModel.Security.SecurityAlgorithmSuite.Basic256" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 返回的 <xref:System.ServiceModel.Security.SecurityAlgorithmSuite> 对象包含大量属性，这些属性指定要在特定条件下使用的安全算法。 它还描述该服务的各种安全功能。  
  
   
  
## Examples  
 下面的代码演示如何从绑定中访问此属性并设置它。  
  
 [!code-csharp[WSFederationHttpSecurity#5](~/samples/snippets/csharp/VS_Snippets_CFX/wsfederationhttpsecurity/cs/source.cs#5)]
 [!code-vb[WSFederationHttpSecurity#5](~/samples/snippets/visualbasic/VS_Snippets_CFX/wsfederationhttpsecurity/vb/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">该值为 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="ClaimTypeRequirements">
      <MemberSignature Language="C#" Value="public System.Collections.ObjectModel.Collection&lt;System.ServiceModel.Security.Tokens.ClaimTypeRequirement&gt; ClaimTypeRequirements { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.ObjectModel.Collection`1&lt;class System.ServiceModel.Security.Tokens.ClaimTypeRequirement&gt; ClaimTypeRequirements" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.FederatedMessageSecurityOverHttp.ClaimTypeRequirements" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ClaimTypeRequirements As Collection(Of ClaimTypeRequirement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::ObjectModel::Collection&lt;System::ServiceModel::Security::Tokens::ClaimTypeRequirement ^&gt; ^ ClaimTypeRequirements { System::Collections::ObjectModel::Collection&lt;System::ServiceModel::Security::Tokens::ClaimTypeRequirement ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ClaimTypeRequirements : System.Collections.ObjectModel.Collection&lt;System.ServiceModel.Security.Tokens.ClaimTypeRequirement&gt;" Usage="System.ServiceModel.FederatedMessageSecurityOverHttp.ClaimTypeRequirements" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.Collection&lt;System.ServiceModel.Security.Tokens.ClaimTypeRequirement&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取此绑定的 <see cref="T:System.ServiceModel.Security.Tokens.ClaimTypeRequirement" /> 实例的集合。</summary>
        <value>一个 <see cref="T:System.Collections.ObjectModel.Collection`1" /> 类型的 <see cref="T:System.ServiceModel.Security.Tokens.ClaimTypeRequirement" />。 默认值为空集合。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 服务使用此属性返回的集合来指定任何必选和可选声明，这些声明必须位于客户端用于访问服务的已颁发令牌中。 如果 WSDL 发布已启用但 WCF 并不要求已颁发的令牌包含指定的声明类型，则服务将会在元数据中公开所需的声明类型。  希望强制显示所需声明类型的服务应该使用授权策略。  
  
 在联合客户端上，此集合包含必选和可选声明的列表，该列表将在客户端请求已颁发令牌时发送给安全令牌服务。  
  
   
  
## Examples  
 下面的代码演示如何从绑定中访问此属性并设置它。  
  
 [!code-csharp[WSFederationHttpSecurity#11](~/samples/snippets/csharp/VS_Snippets_CFX/wsfederationhttpsecurity/cs/source.cs#11)]
 [!code-vb[WSFederationHttpSecurity#11](~/samples/snippets/visualbasic/VS_Snippets_CFX/wsfederationhttpsecurity/vb/source.vb#11)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EstablishSecurityContext">
      <MemberSignature Language="C#" Value="public bool EstablishSecurityContext { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EstablishSecurityContext" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.FederatedMessageSecurityOverHttp.EstablishSecurityContext" />
      <MemberSignature Language="VB.NET" Value="Public Property EstablishSecurityContext As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool EstablishSecurityContext { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.EstablishSecurityContext : bool with get, set" Usage="System.ServiceModel.FederatedMessageSecurityOverHttp.EstablishSecurityContext" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置是否需要放置安全上下文。</summary>
        <value>如果需要放置安全上下文，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IssuedKeyType">
      <MemberSignature Language="C#" Value="public System.IdentityModel.Tokens.SecurityKeyType IssuedKeyType { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.IdentityModel.Tokens.SecurityKeyType IssuedKeyType" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.FederatedMessageSecurityOverHttp.IssuedKeyType" />
      <MemberSignature Language="VB.NET" Value="Public Property IssuedKeyType As SecurityKeyType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IdentityModel::Tokens::SecurityKeyType IssuedKeyType { System::IdentityModel::Tokens::SecurityKeyType get(); void set(System::IdentityModel::Tokens::SecurityKeyType value); };" />
      <MemberSignature Language="F#" Value="member this.IssuedKeyType : System.IdentityModel.Tokens.SecurityKeyType with get, set" Usage="System.ServiceModel.FederatedMessageSecurityOverHttp.IssuedKeyType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Tokens.SecurityKeyType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>指定要颁发的密钥类型。</summary>
        <value>
          <see cref="T:System.IdentityModel.Tokens.SecurityKeyType" />。 默认值为 <see cref="F:System.IdentityModel.Tokens.SecurityKeyType.SymmetricKey" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IdentityModel.Tokens.SecurityKeyType> 的有效值为 <xref:System.IdentityModel.Tokens.SecurityKeyType.SymmetricKey> 和 <xref:System.IdentityModel.Tokens.SecurityKeyType.AsymmetricKey>。  
  
   
  
## Examples  
 下面的代码演示如何从绑定中访问此属性并设置它。  
  
 [!code-csharp[WSFederationHttpSecurity#7](~/samples/snippets/csharp/VS_Snippets_CFX/wsfederationhttpsecurity/cs/source.cs#7)]
 [!code-vb[WSFederationHttpSecurity#7](~/samples/snippets/visualbasic/VS_Snippets_CFX/wsfederationhttpsecurity/vb/source.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">该值不是有效的 <see cref="T:System.IdentityModel.Tokens.SecurityKeyType" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="IssuedTokenType">
      <MemberSignature Language="C#" Value="public string IssuedTokenType { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string IssuedTokenType" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.FederatedMessageSecurityOverHttp.IssuedTokenType" />
      <MemberSignature Language="VB.NET" Value="Public Property IssuedTokenType As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ IssuedTokenType { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.IssuedTokenType : string with get, set" Usage="System.ServiceModel.FederatedMessageSecurityOverHttp.IssuedTokenType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>指定应该由安全令牌服务颁发的令牌类型。</summary>
        <value>要颁发的令牌类型。 默认值为 <see langword="null" />，它会导致 WCF 从 STS 中请求 SAML 安全令牌。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此属性指示服务期望的令牌类型并控制在服务中创建哪个 SecurityTokenAuthenticator。 在客户端上，此属性控制当客户端请求已颁发令牌时要发送到安全令牌服务的类型。  
  
 IssuedTokenType 通常采用 URI 的形式。  
  
   
  
## Examples  
 下面的代码演示如何从绑定中访问此属性并设置它。  
  
 [!code-csharp[WSFederationHttpSecurity#4](~/samples/snippets/csharp/VS_Snippets_CFX/wsfederationhttpsecurity/cs/source.cs#4)]
 [!code-vb[WSFederationHttpSecurity#4](~/samples/snippets/visualbasic/VS_Snippets_CFX/wsfederationhttpsecurity/vb/source.vb#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IssuerAddress">
      <MemberSignature Language="C#" Value="public System.ServiceModel.EndpointAddress IssuerAddress { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ServiceModel.EndpointAddress IssuerAddress" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.FederatedMessageSecurityOverHttp.IssuerAddress" />
      <MemberSignature Language="VB.NET" Value="Public Property IssuerAddress As EndpointAddress" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ServiceModel::EndpointAddress ^ IssuerAddress { System::ServiceModel::EndpointAddress ^ get(); void set(System::ServiceModel::EndpointAddress ^ value); };" />
      <MemberSignature Language="F#" Value="member this.IssuerAddress : System.ServiceModel.EndpointAddress with get, set" Usage="System.ServiceModel.FederatedMessageSecurityOverHttp.IssuerAddress" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ServiceModel.EndpointAddress</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置颁发服务凭据的安全令牌服务的终结点地址。</summary>
        <value>安全令牌服务的 <see cref="T:System.ServiceModel.EndpointAddress" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此地址将用作颁发服务凭据的安全令牌服务的终结点。 如果 WSDL 已启用但不另作他用，则服务会在元数据中公开颁发者的地址。 客户端使用此颁发者地址与安全令牌服务通信。 如果 IssuerAddress 为 Null，客户端可以恢复使用通过 IssuedTokenClientCredential 中的 LocalIssuerAddress 和 LocalIssuerBinding 属性指定的安全令牌服务。  
  
 在某些特定情况下，如果 ClientCredentials.SupportInteractive 为 true，则在客户端上将此值设置为 `null` 或 WS-AddressingIdentity 匿名 URI 将激活 CardSpace。  
  
   
  
## Examples  
 下面的代码演示如何从绑定中访问此属性并设置它。  
  
 [!code-csharp[WSFederationHttpSecurity#8](~/samples/snippets/csharp/VS_Snippets_CFX/wsfederationhttpsecurity/cs/source.cs#8)]
 [!code-vb[WSFederationHttpSecurity#8](~/samples/snippets/visualbasic/VS_Snippets_CFX/wsfederationhttpsecurity/vb/source.vb#8)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IssuerBinding">
      <MemberSignature Language="C#" Value="public System.ServiceModel.Channels.Binding IssuerBinding { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ServiceModel.Channels.Binding IssuerBinding" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.FederatedMessageSecurityOverHttp.IssuerBinding" />
      <MemberSignature Language="VB.NET" Value="Public Property IssuerBinding As Binding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ServiceModel::Channels::Binding ^ IssuerBinding { System::ServiceModel::Channels::Binding ^ get(); void set(System::ServiceModel::Channels::Binding ^ value); };" />
      <MemberSignature Language="F#" Value="member this.IssuerBinding : System.ServiceModel.Channels.Binding with get, set" Usage="System.ServiceModel.FederatedMessageSecurityOverHttp.IssuerBinding" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ServiceModel.Channels.Binding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置当与终结点地址为 <see cref="P:System.ServiceModel.FederatedMessageSecurityOverHttp.IssuerAddress" /> 的安全令牌服务通信时客户端所使用的绑定。</summary>
        <value>与安全令牌服务通信时客户端所使用的 <see cref="T:System.ServiceModel.Channels.Binding" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此属性用于指定在获取服务凭据时客户端要在客户端和安全令牌服务之间使用的绑定。  
  
 请注意，无需在服务中填充此属性，因为它仅供客户端使用。  
  
   
  
## Examples  
 下面的代码演示如何从绑定中访问此属性并设置它。  
  
 [!code-csharp[WSFederationHttpSecurity#9](~/samples/snippets/csharp/VS_Snippets_CFX/wsfederationhttpsecurity/cs/source.cs#9)]
 [!code-vb[WSFederationHttpSecurity#9](~/samples/snippets/visualbasic/VS_Snippets_CFX/wsfederationhttpsecurity/vb/source.vb#9)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IssuerMetadataAddress">
      <MemberSignature Language="C#" Value="public System.ServiceModel.EndpointAddress IssuerMetadataAddress { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ServiceModel.EndpointAddress IssuerMetadataAddress" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.FederatedMessageSecurityOverHttp.IssuerMetadataAddress" />
      <MemberSignature Language="VB.NET" Value="Public Property IssuerMetadataAddress As EndpointAddress" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ServiceModel::EndpointAddress ^ IssuerMetadataAddress { System::ServiceModel::EndpointAddress ^ get(); void set(System::ServiceModel::EndpointAddress ^ value); };" />
      <MemberSignature Language="F#" Value="member this.IssuerMetadataAddress : System.ServiceModel.EndpointAddress with get, set" Usage="System.ServiceModel.FederatedMessageSecurityOverHttp.IssuerMetadataAddress" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ServiceModel.EndpointAddress</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置终结点地址以用于与带外的安全令牌服务通信。</summary>
        <value>在与带外安全令牌服务通信时使用的 <see cref="T:System.ServiceModel.Channels.Binding" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此地址用作颁发带外服务凭据的安全令牌服务的终结点。  
  
   
  
## Examples  
 下面的代码演示如何从绑定中访问此属性并设置它。  
  
 [!code-csharp[WSFederationHttpSecurity#10](~/samples/snippets/csharp/VS_Snippets_CFX/wsfederationhttpsecurity/cs/source.cs#10)]
 [!code-vb[WSFederationHttpSecurity#10](~/samples/snippets/visualbasic/VS_Snippets_CFX/wsfederationhttpsecurity/vb/source.vb#10)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="NegotiateServiceCredential">
      <MemberSignature Language="C#" Value="public bool NegotiateServiceCredential { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool NegotiateServiceCredential" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.FederatedMessageSecurityOverHttp.NegotiateServiceCredential" />
      <MemberSignature Language="VB.NET" Value="Public Property NegotiateServiceCredential As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool NegotiateServiceCredential { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.NegotiateServiceCredential : bool with get, set" Usage="System.ServiceModel.FederatedMessageSecurityOverHttp.NegotiateServiceCredential" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>指定是否已进行消息级 SSL 协商以获取服务的证书。</summary>
        <value>如果已协商服务证书，则为 <see langword="true" />；如果可以在带外使用服务证书，则为 <see langword="false" />。 默认值为 <see langword="true" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此属性指示是否在客户端和服务之间自动协商服务证书。 如果此属性为 `true`，则会进行此类协商。 如果此属性为 `false`，则与服务通信之前必须在客户端指定服务证书。  
  
 服务必须始终指定一个证书。  
  
 如果此属性为 true，则在请求通过 IssuerAddress 和 IssuerBinding 属性指定的安全令牌服务颁布安全令牌之前，将进行服务证书的消息级 SSL 协商。  
  
   
  
## Examples  
 下面的代码演示如何从绑定中访问此属性并设置它。  
  
 [!code-csharp[WSFederationHttpSecurity#6](~/samples/snippets/csharp/VS_Snippets_CFX/wsfederationhttpsecurity/cs/source.cs#6)]
 [!code-vb[WSFederationHttpSecurity#6](~/samples/snippets/visualbasic/VS_Snippets_CFX/wsfederationhttpsecurity/vb/source.vb#6)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeAlgorithmSuite">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeAlgorithmSuite ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeAlgorithmSuite() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.FederatedMessageSecurityOverHttp.ShouldSerializeAlgorithmSuite" />
      <MemberSignature Language="VB.NET" Value="Public Function ShouldSerializeAlgorithmSuite () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ShouldSerializeAlgorithmSuite();" />
      <MemberSignature Language="F#" Value="member this.ShouldSerializeAlgorithmSuite : unit -&gt; bool" Usage="federatedMessageSecurityOverHttp.ShouldSerializeAlgorithmSuite " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回是否应对用于保护 SOAP 级消息的算法套件进行序列化。</summary>
        <returns>如果应对该算法组进行序列化，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeClaimTypeRequirements">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeClaimTypeRequirements ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeClaimTypeRequirements() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.FederatedMessageSecurityOverHttp.ShouldSerializeClaimTypeRequirements" />
      <MemberSignature Language="VB.NET" Value="Public Function ShouldSerializeClaimTypeRequirements () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ShouldSerializeClaimTypeRequirements();" />
      <MemberSignature Language="F#" Value="member this.ShouldSerializeClaimTypeRequirements : unit -&gt; bool" Usage="federatedMessageSecurityOverHttp.ShouldSerializeClaimTypeRequirements " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回是否存在可以序列化的现有声明类型需求。</summary>
        <returns>如果存在要序列化的要求，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeEstablishSecurityContext">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeEstablishSecurityContext ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeEstablishSecurityContext() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.FederatedMessageSecurityOverHttp.ShouldSerializeEstablishSecurityContext" />
      <MemberSignature Language="VB.NET" Value="Public Function ShouldSerializeEstablishSecurityContext () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ShouldSerializeEstablishSecurityContext();" />
      <MemberSignature Language="F#" Value="member this.ShouldSerializeEstablishSecurityContext : unit -&gt; bool" Usage="federatedMessageSecurityOverHttp.ShouldSerializeEstablishSecurityContext " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回一个表明安全上下文是否为默认值以及是否应对其进行序列化的指示。</summary>
        <returns>如果上下文应序列化，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeIssuedKeyType">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeIssuedKeyType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeIssuedKeyType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.FederatedMessageSecurityOverHttp.ShouldSerializeIssuedKeyType" />
      <MemberSignature Language="VB.NET" Value="Public Function ShouldSerializeIssuedKeyType () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ShouldSerializeIssuedKeyType();" />
      <MemberSignature Language="F#" Value="member this.ShouldSerializeIssuedKeyType : unit -&gt; bool" Usage="federatedMessageSecurityOverHttp.ShouldSerializeIssuedKeyType " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回一个表明已颁发的密钥类型是否为默认值以及是否应对其进行序列化的指示。</summary>
        <returns>如果应序列化该类型 ，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeNegotiateServiceCredential">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeNegotiateServiceCredential ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeNegotiateServiceCredential() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.FederatedMessageSecurityOverHttp.ShouldSerializeNegotiateServiceCredential" />
      <MemberSignature Language="VB.NET" Value="Public Function ShouldSerializeNegotiateServiceCredential () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ShouldSerializeNegotiateServiceCredential();" />
      <MemberSignature Language="F#" Value="member this.ShouldSerializeNegotiateServiceCredential : unit -&gt; bool" Usage="federatedMessageSecurityOverHttp.ShouldSerializeNegotiateServiceCredential " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回一个表明服务凭据的协商过程是否为默认过程以及是否应对其进行序列化的指示。</summary>
        <returns>如果应序列化进程，则为 <see langword="true" />；否则，为 <see langword="false" />。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeTokenRequestParameters">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeTokenRequestParameters ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeTokenRequestParameters() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.FederatedMessageSecurityOverHttp.ShouldSerializeTokenRequestParameters" />
      <MemberSignature Language="VB.NET" Value="Public Function ShouldSerializeTokenRequestParameters () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ShouldSerializeTokenRequestParameters();" />
      <MemberSignature Language="F#" Value="member this.ShouldSerializeTokenRequestParameters : unit -&gt; bool" Usage="federatedMessageSecurityOverHttp.ShouldSerializeTokenRequestParameters " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回一个表明是否存在可序列化的现有令牌请求参数的指示。</summary>
        <returns>如果存在要序列化的参数，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TokenRequestParameters">
      <MemberSignature Language="C#" Value="public System.Collections.ObjectModel.Collection&lt;System.Xml.XmlElement&gt; TokenRequestParameters { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.ObjectModel.Collection`1&lt;class System.Xml.XmlElement&gt; TokenRequestParameters" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.FederatedMessageSecurityOverHttp.TokenRequestParameters" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TokenRequestParameters As Collection(Of XmlElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::ObjectModel::Collection&lt;System::Xml::XmlElement ^&gt; ^ TokenRequestParameters { System::Collections::ObjectModel::Collection&lt;System::Xml::XmlElement ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.TokenRequestParameters : System.Collections.ObjectModel.Collection&lt;System.Xml.XmlElement&gt;" Usage="System.ServiceModel.FederatedMessageSecurityOverHttp.TokenRequestParameters" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.Collection&lt;System.Xml.XmlElement&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取请求令牌时要在消息正文中发送到安全令牌服务中的 XML 元素的集合。</summary>
        <value>一个 <see cref="T:System.Collections.ObjectModel.Collection`1" /> 类型的 <see cref="T:System.Xml.XmlElement" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此属性返回的集合可用来指定请求令牌时要在消息正文中发送至安全令牌服务的其他 XML 元素。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>