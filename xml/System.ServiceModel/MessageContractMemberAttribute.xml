<Type Name="MessageContractMemberAttribute" FullName="System.ServiceModel.MessageContractMemberAttribute">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="9212fc608637a253f5a16676534255eb3e980570" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-CN" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30519811" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class MessageContractMemberAttribute : Attribute" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit MessageContractMemberAttribute extends System.Attribute" />
  <TypeSignature Language="DocId" Value="T:System.ServiceModel.MessageContractMemberAttribute" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class MessageContractMemberAttribute&#xA;Inherits Attribute" />
  <TypeSignature Language="C++ CLI" Value="public ref class MessageContractMemberAttribute abstract : Attribute" />
  <AssemblyInfo>
    <AssemblyName>System.ServiceModel</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Attribute</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>
      <span data-ttu-id="d69eb-101">声明 <see cref="T:System.ServiceModel.MessageBodyMemberAttribute" /> 和 <see cref="T:System.ServiceModel.MessageHeaderAttribute" /> 的基成员。</span>
      <span class="sxs-lookup">
        <span data-stu-id="d69eb-101">Declares the base members for <see cref="T:System.ServiceModel.MessageBodyMemberAttribute" /> and <see cref="T:System.ServiceModel.MessageHeaderAttribute" />.</span>
      </span>
    </summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d69eb-102">此类包含对于 SOAP 消息的各部分都通用的属性。</span><span class="sxs-lookup"><span data-stu-id="d69eb-102">This class contains properties common to all parts of a SOAP message.</span></span> <span data-ttu-id="d69eb-103">例如，所有部分都具有名称和命名空间，而且还可能应用了安全性级别。</span><span class="sxs-lookup"><span data-stu-id="d69eb-103">For example, all parts have a name and a namespace, and potentially a level of security applied.</span></span>  
  
 <span data-ttu-id="d69eb-104">在不修改默认 SOAP 信封本身的情况下控制 SOAP 正文内容序列化的信息，请参阅<xref:System.Runtime.Serialization.DataContractAttribute?displayProperty=nameWithType>，[指定服务协定中的数据传输](~/docs/framework/wcf/feature-details/specifying-data-transfer-in-service-contracts.md)，和[使用数据协定](~/docs/framework/wcf/feature-details/using-data-contracts.md)。</span><span class="sxs-lookup"><span data-stu-id="d69eb-104">For information on controlling the serialization of the contents of a SOAP body without modifying the default SOAP envelope itself, see <xref:System.Runtime.Serialization.DataContractAttribute?displayProperty=nameWithType>, [Specifying Data Transfer in Service Contracts](~/docs/framework/wcf/feature-details/specifying-data-transfer-in-service-contracts.md), and [Using Data Contracts](~/docs/framework/wcf/feature-details/using-data-contracts.md).</span></span>  
  
 <span data-ttu-id="d69eb-105">有关创建消息协定的详细信息，请参阅[使用消息协定](~/docs/framework/wcf/feature-details/using-message-contracts.md)。</span><span class="sxs-lookup"><span data-stu-id="d69eb-105">For more information about creating message contracts, see [Using Message Contracts](~/docs/framework/wcf/feature-details/using-message-contracts.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d69eb-106">下面的代码示例演示使用 <xref:System.ServiceModel.MessageContractAttribute>、<xref:System.ServiceModel.MessageHeaderAttribute> 和 <xref:System.ServiceModel.MessageBodyMemberAttribute> 属性（全都从 <xref:System.ServiceModel.MessageContractMemberAttribute> 继承）创建要在操作中使用的自定义类型消息的自定义消息协定。</span><span class="sxs-lookup"><span data-stu-id="d69eb-106">The following code examples demonstrate a custom message contract that uses the <xref:System.ServiceModel.MessageContractAttribute>, <xref:System.ServiceModel.MessageHeaderAttribute>, and <xref:System.ServiceModel.MessageBodyMemberAttribute> attributes (which all inherit from <xref:System.ServiceModel.MessageContractMemberAttribute>)to create custom typed messages to use in operations.</span></span> <span data-ttu-id="d69eb-107">在这种情况下，将有三个成员序列化到 SOAP 消息的正文元素中：`sourceAccount`、`targetAccount` 和 `amount` 值（该值使用名称 `transactionAmount` 序列化到元素中）。</span><span class="sxs-lookup"><span data-stu-id="d69eb-107">In this case, there are three members that are serialized into the body element of the SOAP message: `sourceAccount`, `targetAccount`, and the `amount` value, (which is serialized into an element with the name `transactionAmount`).</span></span> <span data-ttu-id="d69eb-108">此外，`IsAudited` SOAP 标头元素驻留在 `http://schemas.contosobank.com/auditing/2005` 命名空间中，而且还对 `sourceAccount` 进行加密和数字签名。</span><span class="sxs-lookup"><span data-stu-id="d69eb-108">In addition, the `IsAudited` SOAP header element resides in the `http://schemas.contosobank.com/auditing/2005` namespace, and `sourceAccount` is encrypted and digitally signed.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d69eb-109">`Operation` 和 `Account` 类型必须具有数据协定。</span><span class="sxs-lookup"><span data-stu-id="d69eb-109">The `Operation` and `Account` types must have a data contract.</span></span>  
  
```csharp  
[MessageContract]  
public class BankingTransaction  
{  
  [MessageHeader]   
  public Operation operation;  
  [MessageHeader(Namespace="http://schemas.contosobank.com/auditing/2005")]   
  public bool IsAudited;  
  [MessageBody(ProtectionLevel=ProtectionLevel.EncryptAndSign)]   
  public Account sourceAccount;  
  [MessageBody]   
  public Account targetAccount;  
  [MessageBody(Name="transactionAmount")]   
  public int amount;  
```  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected MessageContractMemberAttribute ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.MessageContractMemberAttribute.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; MessageContractMemberAttribute();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="d69eb-110">初始化 <see cref="T:System.ServiceModel.MessageContractMemberAttribute" /> 类的新实例。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d69eb-110">Initializes a new instance of the <see cref="T:System.ServiceModel.MessageContractMemberAttribute" /> class.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="HasProtectionLevel">
      <MemberSignature Language="C#" Value="public bool HasProtectionLevel { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasProtectionLevel" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.MessageContractMemberAttribute.HasProtectionLevel" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HasProtectionLevel As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool HasProtectionLevel { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="d69eb-111">当在派生类中重写时，获取一个指示成员是否具有分配的保护级别的值。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d69eb-111">When overridden in a derived class, gets a value that indicates whether the member has a protection level assigned.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="d69eb-112">如果成员具有保护级别，则为 <see langword="true" />；否则为 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d69eb-112">
              <see langword="true" /> if the member has a protection level; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public string Name { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.MessageContractMemberAttribute.Name" />
      <MemberSignature Language="VB.NET" Value="Public Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Name { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="d69eb-113">指定与此成员对应的元素的名称。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d69eb-113">Specifies the name of the element that corresponds to this member.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="d69eb-114">与此成员对应的元素的名称。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d69eb-114">The name of the element that corresponds to this member.</span>
          </span>
          <span data-ttu-id="d69eb-115">此字符串必须是有效的 XML 元素名称。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d69eb-115">This string must be a valid XML element name.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="d69eb-116">下面的代码示例演示使用 <xref:System.ServiceModel.MessageContractAttribute>、<xref:System.ServiceModel.MessageHeaderAttribute> 和 <xref:System.ServiceModel.MessageBodyMemberAttribute> 属性创建要用作参数的自定义强类型消息的自定义消息协定。</span><span class="sxs-lookup"><span data-stu-id="d69eb-116">The following code examples demonstrate a custom message contract that uses the <xref:System.ServiceModel.MessageContractAttribute>, <xref:System.ServiceModel.MessageHeaderAttribute>, and <xref:System.ServiceModel.MessageBodyMemberAttribute> attributes to create custom, strongly-typed messages to use as parameters.</span></span> <span data-ttu-id="d69eb-117">在这种情况下，将有三个数据成员序列化到 SOAP 消息的正文元素中：`sourceAccount`、`targetAccount` 和 `amount` 值（该值使用名称 `transactionAmount` 序列化到元素中）。</span><span class="sxs-lookup"><span data-stu-id="d69eb-117">In this case, there are three data members that are serialized into the body element of the SOAP message: `sourceAccount`, `targetAccount`, and the `amount` value, (which is serialized into an element with the name `transactionAmount`).</span></span> <span data-ttu-id="d69eb-118">此外，`IsAudited` SOAP 标头元素驻留在 `http://schemas.contosobank.com/auditing/2005` 命名空间中。</span><span class="sxs-lookup"><span data-stu-id="d69eb-118">In addition, the `IsAudited` SOAP header element resides in the `http://schemas.contosobank.com/auditing/2005` namespace.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d69eb-119">`Operation` 和 `Account` 类型也必须具有数据协定。</span><span class="sxs-lookup"><span data-stu-id="d69eb-119">The `Operation` and `Account` types must also have a data contract.</span></span>  
  
```csharp  
[MessageContract]  
public class BankingTransaction  
{  
  [MessageHeader] public Operation operation;  
  [MessageHeader(Namespace="http://schemas.contosobank.com/auditing/2005")] public bool IsAudited;  
  [MessageBody] public Account sourceAccount;  
  [MessageBody] public Account targetAccount;  
  [MessageBody(Name="transactionAmount")] public int amount;  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Namespace">
      <MemberSignature Language="C#" Value="public string Namespace { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Namespace" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.MessageContractMemberAttribute.Namespace" />
      <MemberSignature Language="VB.NET" Value="Public Property Namespace As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Namespace { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="d69eb-120">指定与此成员对应的元素的命名空间。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d69eb-120">Specifies the namespace of the element that corresponds to this member.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="d69eb-121">与此成员对应的元素的命名空间 URI。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d69eb-121">A namespace URI of the element that corresponds to this member.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="d69eb-122">下面的代码示例演示使用 <xref:System.ServiceModel.MessageContractAttribute>、<xref:System.ServiceModel.MessageHeaderAttribute> 和 <xref:System.ServiceModel.MessageBodyMemberAttribute> 属性（全都从 <xref:System.ServiceModel.MessageContractMemberAttribute> 继承）创建要在操作中使用的自定义类型消息的自定义消息协定。</span><span class="sxs-lookup"><span data-stu-id="d69eb-122">The following code examples demonstrate a custom message contract that uses the <xref:System.ServiceModel.MessageContractAttribute>, <xref:System.ServiceModel.MessageHeaderAttribute>, and <xref:System.ServiceModel.MessageBodyMemberAttribute> attributes (which all inherit from <xref:System.ServiceModel.MessageContractMemberAttribute>)to create custom typed messages to use in operations.</span></span> <span data-ttu-id="d69eb-123">在这种情况下，将有三个成员序列化到 SOAP 消息的正文元素中：`sourceAccount`、`targetAccount` 和 `amount` 值（该值使用名称 `transactionAmount` 序列化到元素中）。</span><span class="sxs-lookup"><span data-stu-id="d69eb-123">In this case, there are three members that are serialized into the body element of the SOAP message: `sourceAccount`, `targetAccount`, and the `amount` value, (which is serialized into an element with the name `transactionAmount`).</span></span> <span data-ttu-id="d69eb-124">此外，`IsAudited` SOAP 标头元素驻留在 `http://schemas.contosobank.com/auditing/2005` 命名空间中，而且还对 `sourceAccount` 进行加密和数字签名。</span><span class="sxs-lookup"><span data-stu-id="d69eb-124">In addition, the `IsAudited` SOAP header element resides in the `http://schemas.contosobank.com/auditing/2005` namespace, and `sourceAccount` is encrypted and digitally signed.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d69eb-125">`Operation` 和 `Account` 类型必须具有数据协定。</span><span class="sxs-lookup"><span data-stu-id="d69eb-125">The `Operation` and `Account` types must have a data contract.</span></span>  
  
```csharp  
[MessageContract]  
public class BankingTransaction  
{  
  [MessageHeader] public Operation operation;  
  [MessageHeader(Namespace="http://schemas.contosobank.com/auditing/2005")] public bool IsAudited;  
  [MessageBody] public Account sourceAccount;  
  [MessageBody] public Account targetAccount;  
  [MessageBody(Name="transactionAmount")] public int amount;  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ProtectionLevel">
      <MemberSignature Language="C#" Value="public System.Net.Security.ProtectionLevel ProtectionLevel { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Net.Security.ProtectionLevel ProtectionLevel" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.MessageContractMemberAttribute.ProtectionLevel" />
      <MemberSignature Language="VB.NET" Value="Public Property ProtectionLevel As ProtectionLevel" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::Security::ProtectionLevel ProtectionLevel { System::Net::Security::ProtectionLevel get(); void set(System::Net::Security::ProtectionLevel value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Security.ProtectionLevel</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="d69eb-126">指定该成员是否按原样传输，是否已签名或是否已签名和加密。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d69eb-126">Specifies whether the member is to be transmitted as-is, signed, or signed and encrypted.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="d69eb-127">
            <see cref="T:System.Net.Security.ProtectionLevel" /> 值之一。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d69eb-127">One of the <see cref="T:System.Net.Security.ProtectionLevel" /> values.</span>
          </span>
          <span data-ttu-id="d69eb-128">默认值为 <see cref="F:System.Net.Security.ProtectionLevel.None" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d69eb-128">The default is <see cref="F:System.Net.Security.ProtectionLevel.None" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d69eb-129">若要在 <xref:System.ServiceModel.MessageContractMemberAttribute.ProtectionLevel%2A> 或 <xref:System.ServiceModel.MessageHeaderAttribute> 特性中使用 <xref:System.ServiceModel.MessageBodyMemberAttribute> 属性，则必须正确配置绑定和行为。</span><span class="sxs-lookup"><span data-stu-id="d69eb-129">To make use of the <xref:System.ServiceModel.MessageContractMemberAttribute.ProtectionLevel%2A> property in either the <xref:System.ServiceModel.MessageHeaderAttribute> or <xref:System.ServiceModel.MessageBodyMemberAttribute> attributes you must properly configure the binding and behaviors.</span></span> <span data-ttu-id="d69eb-130">如果在没有正确配置的情况下（例如，在不提供安全凭据的消息部分中使用 <xref:System.Net.Security.ProtectionLevel.Sign?displayProperty=nameWithType>）使用这些安全功能，则会在运行时引发异常。</span><span class="sxs-lookup"><span data-stu-id="d69eb-130">If these security features are used without a proper configuration (for example, using <xref:System.Net.Security.ProtectionLevel.Sign?displayProperty=nameWithType> with a message part without supplying security credentials) an exception is thrown at run time.</span></span>  
  
 <span data-ttu-id="d69eb-131">此外，将分别为每个标头确定其保护级别。</span><span class="sxs-lookup"><span data-stu-id="d69eb-131">In addition, the protection level is determined for each header individually.</span></span> <span data-ttu-id="d69eb-132">但是，无论包含几个正文部分，SOAP 正文都只有一个保护级别。</span><span class="sxs-lookup"><span data-stu-id="d69eb-132">However, the SOAP body has only one protection level, regardless of the number of body parts.</span></span> <span data-ttu-id="d69eb-133">正文的保护级别由所有正文部分的最高 <xref:System.ServiceModel.MessageContractMemberAttribute.ProtectionLevel%2A> 属性值确定。</span><span class="sxs-lookup"><span data-stu-id="d69eb-133">The protection level of the body is determined by the highest <xref:System.ServiceModel.MessageContractMemberAttribute.ProtectionLevel%2A> property value of all the body parts.</span></span> <span data-ttu-id="d69eb-134">例如，请考虑以下类：</span><span class="sxs-lookup"><span data-stu-id="d69eb-134">For example, consider the following class:</span></span>  
  
```csharp  
[MessageContract]  
public class PatientRecord  
{  
   [MessageHeader(ProtectionLevel=None)] public int recordID;  
   [MessageHeader(ProtectionLevel=Sign)] public string patientName;  
   [MessageHeader(ProtectionLevel=EncryptAndSign)] public string SSN;  
   [MessageBody(ProtectionLevel=None)] public string comments;  
   [MessageBody(ProtectionLevel=Sign)] public string diagnosis;  
   [MessageBody(ProtectionLevel=EncryptAndSign)] public string medicalHistory;  
}  
```  
  
 <span data-ttu-id="d69eb-135">在此示例中，`recordID` 标头未受保护，但已对 `patientName` 签名并且对 `SSN` 进行了加密和签名。</span><span class="sxs-lookup"><span data-stu-id="d69eb-135">In this example, the `recordID` header is not protected, `patientName` is signed, and `SSN` is encrypted and signed.</span></span> <span data-ttu-id="d69eb-136">至少有一个正文部分 (`medicalHistory`) 具有 <xref:System.Net.Security.ProtectionLevel.EncryptAndSign?displayProperty=nameWithType>，因此将对整个消息正文进行加密和签名，即使 `comments` 和 `diagnosis` 正文部分指定了较低的保护级别。</span><span class="sxs-lookup"><span data-stu-id="d69eb-136">There is at least one body part, `medicalHistory`, with <xref:System.Net.Security.ProtectionLevel.EncryptAndSign?displayProperty=nameWithType> and thus the entire message body is encrypted and signed, even though the `comments` and `diagnosis` body parts specify lower protection levels.</span></span>  
  
 <span data-ttu-id="d69eb-137">运行时的保护行为是在下列属性中设置的保护级别值的组合。</span><span class="sxs-lookup"><span data-stu-id="d69eb-137">The protection behavior at runtime is the combination of the protection-level values set on the following properties.</span></span> <span data-ttu-id="d69eb-138">这些属性具有层次结构。</span><span class="sxs-lookup"><span data-stu-id="d69eb-138">These properties have a hierarchical structure.</span></span> <span data-ttu-id="d69eb-139">除非已为较窄范围显式设置了某个不同的值，否则设置最外层的值将为所有较窄的范围确定默认设置。</span><span class="sxs-lookup"><span data-stu-id="d69eb-139">Setting the outermost value establishes the default setting for all narrower scopes unless a different value for a narrower scope is explicitly set.</span></span> <span data-ttu-id="d69eb-140">在这种情况下，外层的值将保持所有较窄的范围的默认设置，但特定的设置除外。</span><span class="sxs-lookup"><span data-stu-id="d69eb-140">In this case, the outer value remains the default for all narrower scopes with the exception of that specifically set.</span></span>  
  
 <span data-ttu-id="d69eb-141">例如，如果将 <xref:System.ServiceModel.ServiceContractAttribute.ProtectionLevel%2A?displayProperty=nameWithType> 设置为 <xref:System.Net.Security.ProtectionLevel.EncryptAndSign?displayProperty=nameWithType>，并且其他较窄范围都没有设置保护级别，则会对操作协定中的所有消息进行加密和签名。</span><span class="sxs-lookup"><span data-stu-id="d69eb-141">For example, if <xref:System.ServiceModel.ServiceContractAttribute.ProtectionLevel%2A?displayProperty=nameWithType> is set to <xref:System.Net.Security.ProtectionLevel.EncryptAndSign?displayProperty=nameWithType> and no other narrower scopes have protection level settings, all messages in an operation contract are encrypted and signed.</span></span> <span data-ttu-id="d69eb-142">但是，如果其中一个操作将 <xref:System.ServiceModel.OperationContractAttribute> 设置为 <xref:System.Net.Security.ProtectionLevel.Sign?displayProperty=nameWithType>，那么只会对此操作的消息进行签名，而对协定中的所有其他消息进行加密和签名。</span><span class="sxs-lookup"><span data-stu-id="d69eb-142">If, however, one of those operations has the <xref:System.ServiceModel.OperationContractAttribute> set to <xref:System.Net.Security.ProtectionLevel.Sign?displayProperty=nameWithType>, then the messages for that operation are signed but all other messages in the contract are encrypted and signed.</span></span>  
  
 <span data-ttu-id="d69eb-143">有关保护级别及其假设和范围的详细信息，请参阅[了解保护级别](~/docs/framework/wcf/understanding-protection-level.md)。</span><span class="sxs-lookup"><span data-stu-id="d69eb-143">For details about protection levels and their assumptions and scopes, see [Understanding Protection Level](~/docs/framework/wcf/understanding-protection-level.md).</span></span>  
  
 <span data-ttu-id="d69eb-144">这些值的设置范围是：</span><span class="sxs-lookup"><span data-stu-id="d69eb-144">The scopes at which these values are set are:</span></span>  
  
 <xref:System.ServiceModel.ServiceContractAttribute.ProtectionLevel%2A?displayProperty=nameWithType>  
  
 <xref:System.ServiceModel.OperationContractAttribute.ProtectionLevel%2A?displayProperty=nameWithType>  
  
 <xref:System.ServiceModel.FaultContractAttribute.ProtectionLevel%2A?displayProperty=nameWithType>  
  
 <xref:System.ServiceModel.MessageContractAttribute.ProtectionLevel%2A?displayProperty=nameWithType>  
  
 <span data-ttu-id="d69eb-145"><xref:System.ServiceModel.MessageContractMemberAttribute.ProtectionLevel%2A?displayProperty=nameWithType> 上的 <xref:System.ServiceModel.MessageHeaderAttribute?displayProperty=nameWithType> 属性。</span><span class="sxs-lookup"><span data-stu-id="d69eb-145">The <xref:System.ServiceModel.MessageContractMemberAttribute.ProtectionLevel%2A?displayProperty=nameWithType> property on <xref:System.ServiceModel.MessageHeaderAttribute?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="d69eb-146"><xref:System.ServiceModel.MessageContractMemberAttribute.ProtectionLevel%2A?displayProperty=nameWithType> 上的 <xref:System.ServiceModel.MessageBodyMemberAttribute?displayProperty=nameWithType> 属性。</span><span class="sxs-lookup"><span data-stu-id="d69eb-146">The <xref:System.ServiceModel.MessageContractMemberAttribute.ProtectionLevel%2A?displayProperty=nameWithType> property on <xref:System.ServiceModel.MessageBodyMemberAttribute?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="d69eb-147">当协定上没有显式指定保护级别并且基础绑定支持安全性时（无论处于传输级别还是处于消息级别），整个协定的有效保护级别将为 <xref:System.Net.Security.ProtectionLevel.EncryptAndSign?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="d69eb-147">When there is no protection level explicitly specified on the contract and the underlying binding supports security (whether at the transport or message level), the effective protection level for the whole contract is <xref:System.Net.Security.ProtectionLevel.EncryptAndSign?displayProperty=nameWithType>.</span></span> <span data-ttu-id="d69eb-148">如果绑定不支持安全性（如 <xref:System.ServiceModel.BasicHttpBinding>），则整个协定的有效 <xref:System.Net.Security.ProtectionLevel?displayProperty=nameWithType> 为 <xref:System.Net.Security.ProtectionLevel.None?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="d69eb-148">If the binding does not support security (such as <xref:System.ServiceModel.BasicHttpBinding>), the effective <xref:System.Net.Security.ProtectionLevel?displayProperty=nameWithType> is <xref:System.Net.Security.ProtectionLevel.None?displayProperty=nameWithType> for the whole contract.</span></span> <span data-ttu-id="d69eb-149">因此，根据终结点绑定，即使协定指定了 <xref:System.Net.Security.ProtectionLevel.None?displayProperty=nameWithType>，客户端也可以要求不同的消息或传输级别安全保护。</span><span class="sxs-lookup"><span data-stu-id="d69eb-149">The result is that depending upon the endpoint binding, clients can require different message or transport level security protection even when the contract specifies <xref:System.Net.Security.ProtectionLevel.None?displayProperty=nameWithType>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>