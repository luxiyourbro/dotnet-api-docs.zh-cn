<Type Name="NetTcpBinding" FullName="System.ServiceModel.NetTcpBinding">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="ec5df1c6906ec6079402021a41b04521dfbc536d" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-CN" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36410898" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class NetTcpBinding : System.ServiceModel.Channels.Binding, System.ServiceModel.Channels.IBindingRuntimePreferences" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit NetTcpBinding extends System.ServiceModel.Channels.Binding implements class System.ServiceModel.Channels.IBindingRuntimePreferences" />
  <TypeSignature Language="DocId" Value="T:System.ServiceModel.NetTcpBinding" />
  <TypeSignature Language="VB.NET" Value="Public Class NetTcpBinding&#xA;Inherits Binding&#xA;Implements IBindingRuntimePreferences" />
  <TypeSignature Language="C++ CLI" Value="public ref class NetTcpBinding : System::ServiceModel::Channels::Binding, System::ServiceModel::Channels::IBindingRuntimePreferences" />
  <TypeSignature Language="F#" Value="type NetTcpBinding = class&#xA;    inherit Binding&#xA;    interface IBindingRuntimePreferences" />
  <AssemblyInfo>
    <AssemblyName>System.ServiceModel</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.ServiceModel.NetTcp</AssemblyName>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
    <AssemblyVersion>4.1.2.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ServiceModel.Channels.Binding</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ServiceModel.Channels.IBindingRuntimePreferences</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>一种适合于跨计算机通信的安全可靠的绑定。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 默认情况下，<xref:System.ServiceModel.NetTcpBinding> 会生成一个运行时通信堆栈，该堆栈使用传输安全、用于消息传递的 TCP 和二进制消息编码机制。 此绑定是用于通过 Intranet 进行通信的相应 Windows Communication Foundation (WCF) 系统提供选择。  
  
 默认配置<xref:System.ServiceModel.NetTcpBinding>比提供的配置更快<xref:System.ServiceModel.WSHttpBinding>，但它仅用于 WCF 的通信。 安全行为可通过在构造函数中使用可选的 `securityMode` 参数进行配置。 通过使用可选的 `reliableSessionEnabled` 参数，可以配置 WS-ReliableMessaging 的用法。 但是在默认情况下可靠消息传递为关闭状态。 一般来说，HTTP 系统提供的绑定（如 <xref:System.ServiceModel.WSHttpBinding> 和 <xref:System.ServiceModel.BasicHttpBinding>）是默认配置为打开事项，而 <xref:System.ServiceModel.NetTcpBinding> 绑定是默认配置为关闭事项，因此，您必须选择性加入所需事项才能获取支持，例如获取对一种 WS-* 规范的支持。 这意味着在终结点之间交换消息方面，TCP 的默认配置比 HTTP 绑定的默认配置更快。  
  
> [!WARNING]
>  <xref:System.ServiceModel.NetTcpBinding>使用 TCP 连接池根据服务的托管 DNS 名称和该服务侦听的端口号。 这也适用时客户端提出对在不同的端口的不同服务的调用或在单个进程中承载服务，并共享一个端口。 如果单个客户端调用的多个服务共享端口托管在不同的进程，或者是 WAS / IIS 承载，客户端端池可能会导致问题其中服务 B，从而导致引发异常的重复使用连接到服务 A中止，该连接，创建一个新通道。 若要避免此问题，请使用 CustomBinding 并指定每个服务客户端不同 ConnectionPoolSettings.GroupName 与进行通信。  
  
   
  
## Examples  
 此示例演示如何创建 <xref:System.ServiceModel.NetTcpBinding>，同时设置安全模式和传输凭据类型。  
  
 [!code-csharp[S_UENetTcpBinding#1](~/samples/snippets/csharp/VS_Snippets_CFX/s_uenettcpbinding/cs/source.cs#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>初始化 <see cref="T:System.ServiceModel.NetTcpBinding" /> 类的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 安全行为可通过在构造函数中使用可选的 `securityMode` 参数进行配置。 通过使用可选的 `reliableSessionEnabled` 参数，可以配置 WS-ReliableMessaging 的用法。  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public NetTcpBinding ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.NetTcpBinding.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; NetTcpBinding();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.NetTcp</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>初始化 <see cref="T:System.ServiceModel.NetTcpBinding" /> 类的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 默认情况下，使用传输安全来确保通信的安全（也就是将 <xref:System.ServiceModel.SecurityMode> 的值设置为 <xref:System.ServiceModel.SecurityMode.Transport>）并禁用可靠会话（也就是 <xref:System.ServiceModel.OptionalReliableSession.Enabled%2A> 为 `false`）。  
  
   
  
## Examples  
 此示例演示如何创建 <xref:System.ServiceModel.NetTcpBinding>，同时设置安全模式和传输凭据类型。  
  
 [!code-csharp[S_UENETTCPBINDING#1](~/samples/snippets/csharp/VS_Snippets_CFX/s_uenettcpbinding/cs/source.cs#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public NetTcpBinding (System.ServiceModel.SecurityMode securityMode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.ServiceModel.SecurityMode securityMode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.NetTcpBinding.#ctor(System.ServiceModel.SecurityMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; NetTcpBinding(System::ServiceModel::SecurityMode securityMode);" />
      <MemberSignature Language="F#" Value="new System.ServiceModel.NetTcpBinding : System.ServiceModel.SecurityMode -&gt; System.ServiceModel.NetTcpBinding" Usage="new System.ServiceModel.NetTcpBinding securityMode" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.NetTcp</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="securityMode" Type="System.ServiceModel.SecurityMode" />
      </Parameters>
      <Docs>
        <param name="securityMode">
          <see cref="T:System.ServiceModel.SecurityMode" /> 值，指定与绑定一起使用的安全类型。</param>
        <summary>用所使用的指定安全类型初始化 <see cref="T:System.ServiceModel.NetTcpBinding" /> 类的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要配置安全性，请使用此构造函数。 若要配置安全性并启用可靠会话，请使用 <xref:System.ServiceModel.NetTcpBinding.%23ctor%28System.ServiceModel.SecurityMode%2CSystem.Boolean%29?displayProperty=nameWithType>。  
  
   
  
## Examples  
 此示例演示如何使用安全模式参数创建 <xref:System.ServiceModel.NetTcpBinding>。  
  
 [!code-csharp[S_UENETTCPBINDING#3](~/samples/snippets/csharp/VS_Snippets_CFX/s_uenettcpbinding/cs/source.cs#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public NetTcpBinding (string configurationName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string configurationName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.NetTcpBinding.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (configurationName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; NetTcpBinding(System::String ^ configurationName);" />
      <MemberSignature Language="F#" Value="new System.ServiceModel.NetTcpBinding : string -&gt; System.ServiceModel.NetTcpBinding" Usage="new System.ServiceModel.NetTcpBinding configurationName" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.NetTcp</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="configurationName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="configurationName">
          <see cref="T:System.ServiceModel.NetTcpBinding" /> 的绑定配置名称。</param>
        <summary>使用指定配置名称初始化 <see cref="T:System.ServiceModel.NetTcpBinding" /> 类的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 要初始化配置中的绑定设置时使用此构造函数。  
  
   
  
## Examples  
 此示例演示如何使用 <xref:System.ServiceModel.NetTcpBinding> 参数创建 `configurationName`。  
  
 [!code-csharp[S_UENETTCPBINDING#4](~/samples/snippets/csharp/VS_Snippets_CFX/s_uenettcpbinding/cs/source.cs#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public NetTcpBinding (System.ServiceModel.SecurityMode securityMode, bool reliableSessionEnabled);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.ServiceModel.SecurityMode securityMode, bool reliableSessionEnabled) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.NetTcpBinding.#ctor(System.ServiceModel.SecurityMode,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; NetTcpBinding(System::ServiceModel::SecurityMode securityMode, bool reliableSessionEnabled);" />
      <MemberSignature Language="F#" Value="new System.ServiceModel.NetTcpBinding : System.ServiceModel.SecurityMode * bool -&gt; System.ServiceModel.NetTcpBinding" Usage="new System.ServiceModel.NetTcpBinding (securityMode, reliableSessionEnabled)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="securityMode" Type="System.ServiceModel.SecurityMode" />
        <Parameter Name="reliableSessionEnabled" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="securityMode">
          <see cref="T:System.ServiceModel.SecurityMode" /> 值，指定与绑定一起使用的安全类型。</param>
        <param name="reliableSessionEnabled">如果已启用可靠会话，则为 <see langword="true" />；否则为 <see langword="false" />。</param>
        <summary>用所使用的指定安全类型和一个指示是否显式启用安全会话的值来初始化 <see cref="T:System.ServiceModel.NetTcpBinding" /> 类的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 要配置安全性并启用可靠会话时使用此构造函数。  
  
   
  
## Examples  
 此示例演示如何使用 <xref:System.ServiceModel.NetTcpBinding> 和 `securityMode` 参数创建 `reliableSessionEnabled`。  
  
 [!code-csharp[S_UENETTCPBINDING#5](~/samples/snippets/csharp/VS_Snippets_CFX/s_uenettcpbinding/cs/source.cs#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateBindingElements">
      <MemberSignature Language="C#" Value="public override System.ServiceModel.Channels.BindingElementCollection CreateBindingElements ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.ServiceModel.Channels.BindingElementCollection CreateBindingElements() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.NetTcpBinding.CreateBindingElements" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function CreateBindingElements () As BindingElementCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::ServiceModel::Channels::BindingElementCollection ^ CreateBindingElements();" />
      <MemberSignature Language="F#" Value="override this.CreateBindingElements : unit -&gt; System.ServiceModel.Channels.BindingElementCollection" Usage="netTcpBinding.CreateBindingElements " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.NetTcp</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ServiceModel.Channels.BindingElementCollection</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>为绑定创建一个绑定元素集合。</summary>
        <returns>组成绑定的 <see cref="T:System.Collections.Generic.ICollection`1" /> 类型的 <see cref="T:System.ServiceModel.Channels.BindingElement" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 此示例演示如何使用 <xref:System.ServiceModel.NetTcpBinding.CreateBindingElements%2A> 方法为绑定创建一个绑定元素集合。  
  
 [!code-csharp[S_UENetTcpBinding#20](~/samples/snippets/csharp/VS_Snippets_CFX/s_uenettcpbinding/cs/source.cs#20)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EnvelopeVersion">
      <MemberSignature Language="C#" Value="public System.ServiceModel.EnvelopeVersion EnvelopeVersion { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ServiceModel.EnvelopeVersion EnvelopeVersion" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.NetTcpBinding.EnvelopeVersion" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property EnvelopeVersion As EnvelopeVersion" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ServiceModel::EnvelopeVersion ^ EnvelopeVersion { System::ServiceModel::EnvelopeVersion ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.EnvelopeVersion : System.ServiceModel.EnvelopeVersion" Usage="System.ServiceModel.NetTcpBinding.EnvelopeVersion" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.NetTcp</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ServiceModel.EnvelopeVersion</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取此绑定处理的消息将要使用的 SOAP 版本。</summary>
        <value>与此绑定一起使用的 <see cref="T:System.ServiceModel.EnvelopeVersion" /> 的值。 值为 SOAP 1.2。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 该属性总是返回 SOAP 1.2。 此值不能更改。  
  
   
  
## Examples  
 此示例演示如何获取 <xref:System.ServiceModel.NetTcpBinding.EnvelopeVersion%2A> 值。  
  
 [!code-csharp[S_UENETTCPBINDING#6](~/samples/snippets/csharp/VS_Snippets_CFX/s_uenettcpbinding/cs/source.cs#6)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HostNameComparisonMode">
      <MemberSignature Language="C#" Value="public System.ServiceModel.HostNameComparisonMode HostNameComparisonMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.ServiceModel.HostNameComparisonMode HostNameComparisonMode" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.NetTcpBinding.HostNameComparisonMode" />
      <MemberSignature Language="VB.NET" Value="Public Property HostNameComparisonMode As HostNameComparisonMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ServiceModel::HostNameComparisonMode HostNameComparisonMode { System::ServiceModel::HostNameComparisonMode get(); void set(System::ServiceModel::HostNameComparisonMode value); };" />
      <MemberSignature Language="F#" Value="member this.HostNameComparisonMode : System.ServiceModel.HostNameComparisonMode with get, set" Usage="System.ServiceModel.NetTcpBinding.HostNameComparisonMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ServiceModel.HostNameComparisonMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值指示在对 URI 进行匹配时，是否使用主机名来访问服务。</summary>
        <value>
          <see cref="P:System.ServiceModel.Configuration.WSDualHttpBindingElement.HostNameComparisonMode" /> 值之一，指示在对 URI 进行匹配时，是否使用主机名来访问服务。 默认值为 <see cref="F:System.ServiceModel.HostNameComparisonMode.StrongWildcard" />，表示忽略匹配项中的主机名。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 此示例演示如何获取 <xref:System.ServiceModel.NetTcpBinding.HostNameComparisonMode%2A> 值。  
  
 [!code-csharp[S_UENetTcpBinding#7](~/samples/snippets/csharp/VS_Snippets_CFX/s_uenettcpbinding/cs/source.cs#7)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ListenBacklog">
      <MemberSignature Language="C#" Value="public int ListenBacklog { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ListenBacklog" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.NetTcpBinding.ListenBacklog" />
      <MemberSignature Language="VB.NET" Value="Public Property ListenBacklog As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ListenBacklog { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.ListenBacklog : int with get, set" Usage="System.ServiceModel.NetTcpBinding.ListenBacklog" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置可挂起的最大排队连接请求数。</summary>
        <value>返回挂起的最大排队连接请求数。 默认值为 10。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ServiceModel.Channels.TcpTransportBindingElement.ListenBacklog%2A> 是套接字级别的属性，描述要排队的“挂起接受”请求数。 如果侦听积压工作 (backlog) 队列已满，则会拒绝新的套接字请求。  
  
   
  
## Examples  
 此示例演示如何获取 <xref:System.ServiceModel.NetTcpBinding.ListenBacklog%2A> 值。  
  
 [!code-csharp[S_UENetTcpBinding#8](~/samples/snippets/csharp/VS_Snippets_CFX/s_uenettcpbinding/cs/source.cs#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">该值不能小于零。</exception>
      </Docs>
    </Member>
    <Member MemberName="MaxBufferPoolSize">
      <MemberSignature Language="C#" Value="public long MaxBufferPoolSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 MaxBufferPoolSize" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.NetTcpBinding.MaxBufferPoolSize" />
      <MemberSignature Language="VB.NET" Value="Public Property MaxBufferPoolSize As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long MaxBufferPoolSize { long get(); void set(long value); };" />
      <MemberSignature Language="F#" Value="member this.MaxBufferPoolSize : int64 with get, set" Usage="System.ServiceModel.NetTcpBinding.MaxBufferPoolSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.NetTcp</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置缓冲池允许的最大大小（以字节为单位），该缓冲池用于存储由绑定处理的 TCP 消息。</summary>
        <value>缓冲池允许的最大大小，该缓冲池用于存储由绑定处理的 TCP 消息。 默认值为 524,288 字节。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果接收的数据超过了可进行缓冲处理的数据，则超出缓冲区大小的数据将保留在基础套接字中，直到缓冲区中具有可用于存储剩余数据的空间为止。  
  
   
  
## Examples  
 此示例演示如何获取 <xref:System.ServiceModel.NetTcpBinding.MaxBufferPoolSize%2A> 值。  
  
 [!code-csharp[S_UENetTcpBinding#9](~/samples/snippets/csharp/VS_Snippets_CFX/s_uenettcpbinding/cs/source.cs#9)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MaxBufferSize">
      <MemberSignature Language="C#" Value="public int MaxBufferSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MaxBufferSize" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.NetTcpBinding.MaxBufferSize" />
      <MemberSignature Language="VB.NET" Value="Public Property MaxBufferSize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int MaxBufferSize { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.MaxBufferSize : int with get, set" Usage="System.ServiceModel.NetTcpBinding.MaxBufferSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.NetTcp</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值指定内存中用于存储消息的缓冲区的最大大小（以字节为单位）。</summary>
        <value>内存中用于存储消息的缓冲区的最大大小（以字节为单位）。 默认值为 65,536 字节。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果接收的数据超过了可进行缓冲处理的数据，则超出缓冲区大小的数据将保留在基础套接字中，直到缓冲区中具有可用于存储剩余数据的空间为止。  
  
   
  
## Examples  
 此示例演示如何获取 <xref:System.ServiceModel.NetTcpBinding.MaxBufferSize%2A> 的值。  
  
 [!code-csharp[S_UENetTcpBinding#10](~/samples/snippets/csharp/VS_Snippets_CFX/s_uenettcpbinding/cs/source.cs#10)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MaxConnections">
      <MemberSignature Language="C#" Value="public int MaxConnections { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MaxConnections" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.NetTcpBinding.MaxConnections" />
      <MemberSignature Language="VB.NET" Value="Public Property MaxConnections As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int MaxConnections { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.MaxConnections : int with get, set" Usage="System.ServiceModel.NetTcpBinding.MaxConnections" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值控制客户端上可存入池中以备后续重复使用的最大连接数，以及服务器上可挂起调度的最大连接数。</summary>
        <value>客户端上可存入池中以备后续重复使用的最大连接数；服务器上可挂起调度的最大连接数。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 默认值为 10。  
  
   
  
## Examples  
 此示例演示如何获取 <xref:System.ServiceModel.NetTcpBinding.MaxConnections%2A> 值。  
  
 [!code-csharp[S_UENetTcpBinding#11](~/samples/snippets/csharp/VS_Snippets_CFX/s_uenettcpbinding/cs/source.cs#11)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MaxReceivedMessageSize">
      <MemberSignature Language="C#" Value="public long MaxReceivedMessageSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 MaxReceivedMessageSize" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.NetTcpBinding.MaxReceivedMessageSize" />
      <MemberSignature Language="VB.NET" Value="Public Property MaxReceivedMessageSize As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long MaxReceivedMessageSize { long get(); void set(long value); };" />
      <MemberSignature Language="F#" Value="member this.MaxReceivedMessageSize : int64 with get, set" Usage="System.ServiceModel.NetTcpBinding.MaxReceivedMessageSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.NetTcp</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置绑定可处理的消息最大接收字节大小。</summary>
        <value>绑定可处理的最大接收消息大小（以字节为单位）。 默认值为 65,536 字节。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 此示例演示如何获取 <xref:System.ServiceModel.NetTcpBinding.MaxReceivedMessageSize%2A> 值。  
  
 [!code-csharp[S_UENetTcpBinding#12](~/samples/snippets/csharp/VS_Snippets_CFX/s_uenettcpbinding/cs/source.cs#12)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PortSharingEnabled">
      <MemberSignature Language="C#" Value="public bool PortSharingEnabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool PortSharingEnabled" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.NetTcpBinding.PortSharingEnabled" />
      <MemberSignature Language="VB.NET" Value="Public Property PortSharingEnabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool PortSharingEnabled { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.PortSharingEnabled : bool with get, set" Usage="System.ServiceModel.NetTcpBinding.PortSharingEnabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值指示是否为采用此绑定配置的连接启用 TCP 端口共享。</summary>
        <value>如果启用 TCP 端口共享，则为 <see langword="true" />；否则为 <see langword="false" />。 默认值为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用此设置要求通过将其启动类型更改为手动或自动启用 Windows Communication Foundation (WCF) TCP 端口共享服务。  
  
 有关 TCP 侦听器及其启动方式的详细信息，请参阅<xref:System.Net.Sockets.TcpListener>。  
  
   
  
## Examples  
 此示例演示如何获取 <xref:System.ServiceModel.NetTcpBinding.PortSharingEnabled%2A> 值。  
  
 [!code-csharp[S_UENetTcpBinding#13](~/samples/snippets/csharp/VS_Snippets_CFX/s_uenettcpbinding/cs/source.cs#13)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReaderQuotas">
      <MemberSignature Language="C#" Value="public System.Xml.XmlDictionaryReaderQuotas ReaderQuotas { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xml.XmlDictionaryReaderQuotas ReaderQuotas" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.NetTcpBinding.ReaderQuotas" />
      <MemberSignature Language="VB.NET" Value="Public Property ReaderQuotas As XmlDictionaryReaderQuotas" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xml::XmlDictionaryReaderQuotas ^ ReaderQuotas { System::Xml::XmlDictionaryReaderQuotas ^ get(); void set(System::Xml::XmlDictionaryReaderQuotas ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ReaderQuotas : System.Xml.XmlDictionaryReaderQuotas with get, set" Usage="System.ServiceModel.NetTcpBinding.ReaderQuotas" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.NetTcp</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlDictionaryReaderQuotas</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置可由配置了此绑定的终结点处理的 SOAP 消息的复杂性约束。</summary>
        <value>为交换的 Soap 消息指定复杂性约束的 <see cref="T:System.Xml.XmlDictionaryReaderQuotas" />。 下面的备注部分中提供了这些约束的默认值。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 这些复杂性约束可以抵御某种类型的拒绝服务 (DOS) 攻击，这些攻击试图利用消息复杂性来占用终结点处理资源。 表达这些约束及其默认值的属性如下所示：  
  
-   <xref:System.Xml.XmlDictionaryReaderQuotas.MaxDepth%2A> = 32  
  
-   <xref:System.Xml.XmlDictionaryReaderQuotas.MaxStringContentLength%2A> = 8192  
  
-   <xref:System.Xml.XmlDictionaryReaderQuotas.MaxArrayLength%2A> = 16384  
  
-   <xref:System.Xml.XmlDictionaryReaderQuotas.MaxBytesPerRead%2A> = 4096  
  
-   <xref:System.Xml.XmlDictionaryReaderQuotas.MaxNameTableCharCount%2A> = 16384  
  
   
  
## Examples  
 下面的示例演示如何获取 <xref:System.ServiceModel.NetTcpBinding.ReaderQuotas%2A> 对象。  
  
 [!code-csharp[S_UENetTcpBinding#14](~/samples/snippets/csharp/VS_Snippets_CFX/s_uenettcpbinding/cs/source.cs#14)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReliableSession">
      <MemberSignature Language="C#" Value="public System.ServiceModel.OptionalReliableSession ReliableSession { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ServiceModel.OptionalReliableSession ReliableSession" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.NetTcpBinding.ReliableSession" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ReliableSession As OptionalReliableSession" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ServiceModel::OptionalReliableSession ^ ReliableSession { System::ServiceModel::OptionalReliableSession ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ReliableSession : System.ServiceModel.OptionalReliableSession" Usage="System.ServiceModel.NetTcpBinding.ReliableSession" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ServiceModel.OptionalReliableSession</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个对象，该对象指示是否在通道终结点之间建立可靠会话。</summary>
        <value>一个 <see cref="T:System.ServiceModel.OptionalReliableSession" />，指示是否在通道终结点之间建立 WS-RM 可靠会话。 <see cref="P:System.ServiceModel.OptionalReliableSession.Enabled" /> 的默认值为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 此示例演示如何获取 <xref:System.ServiceModel.NetTcpBinding.ReliableSession%2A> 值。  
  
 [!code-csharp[S_UENetTcpBinding#15](~/samples/snippets/csharp/VS_Snippets_CFX/s_uenettcpbinding/cs/source.cs#15)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Scheme">
      <MemberSignature Language="C#" Value="public override string Scheme { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Scheme" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.NetTcpBinding.Scheme" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Scheme As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Scheme { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Scheme : string" Usage="System.ServiceModel.NetTcpBinding.Scheme" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.NetTcp</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>返回传输的 URI 方案。</summary>
        <value>传输的 URI 方案“net.tcp”。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 该属性用于对基址验证绑定。  
  
   
  
## Examples  
 此示例演示如何获取 <xref:System.ServiceModel.NetTcpBinding.Scheme%2A> 值。  
  
 [!code-csharp[S_UENetTcpBinding#16](~/samples/snippets/csharp/VS_Snippets_CFX/s_uenettcpbinding/cs/source.cs#16)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Security">
      <MemberSignature Language="C#" Value="public System.ServiceModel.NetTcpSecurity Security { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ServiceModel.NetTcpSecurity Security" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.NetTcpBinding.Security" />
      <MemberSignature Language="VB.NET" Value="Public Property Security As NetTcpSecurity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ServiceModel::NetTcpSecurity ^ Security { System::ServiceModel::NetTcpSecurity ^ get(); void set(System::ServiceModel::NetTcpSecurity ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Security : System.ServiceModel.NetTcpSecurity with get, set" Usage="System.ServiceModel.NetTcpBinding.Security" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.NetTcp</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ServiceModel.NetTcpSecurity</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个对象，该对象指定与采用此绑定配置的服务一起使用的安全类型。</summary>
        <value>包含与此绑定一起使用的安全类型的 <see cref="T:System.ServiceModel.NetTcpSecurity" />。 <see langword="NetTCPBinding" /> 的默认安全模式是 <see cref="F:System.ServiceModel.SecurityMode.Transport" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ServiceModel.NetTcpSecurity> 提供可用于 <xref:System.ServiceModel.NetTcpBinding> 的安全类型和设置。  
  
   
  
## Examples  
 此示例演示如何获取 <xref:System.ServiceModel.NetTcpBinding.Security%2A> 值。  
  
 [!code-csharp[S_UENetTcpBinding#17](~/samples/snippets/csharp/VS_Snippets_CFX/s_uenettcpbinding/cs/source.cs#17)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeListenBacklog">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeListenBacklog ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeListenBacklog() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.NetTcpBinding.ShouldSerializeListenBacklog" />
      <MemberSignature Language="VB.NET" Value="Public Function ShouldSerializeListenBacklog () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ShouldSerializeListenBacklog();" />
      <MemberSignature Language="F#" Value="member this.ShouldSerializeListenBacklog : unit -&gt; bool" Usage="netTcpBinding.ShouldSerializeListenBacklog " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回一个值，该值指示 <see cref="P:System.ServiceModel.NetTcpBinding.ListenBacklog" /> 属性是否已更改，不再是默认值且应对其进行序列化。</summary>
        <returns>如果应当序列化 <see cref="P:System.ServiceModel.NetTcpBinding.ListenBacklog" /> 属性值，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeMaxConnections">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeMaxConnections ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeMaxConnections() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.NetTcpBinding.ShouldSerializeMaxConnections" />
      <MemberSignature Language="VB.NET" Value="Public Function ShouldSerializeMaxConnections () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ShouldSerializeMaxConnections();" />
      <MemberSignature Language="F#" Value="member this.ShouldSerializeMaxConnections : unit -&gt; bool" Usage="netTcpBinding.ShouldSerializeMaxConnections " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回一个值，该值指示 <see cref="P:System.ServiceModel.NetTcpBinding.MaxConnections" /> 属性是否已更改，不再是默认值且应对其进行序列化。</summary>
        <returns>如果应当序列化 <see cref="P:System.ServiceModel.NetTcpBinding.MaxConnections" /> 属性值，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeReaderQuotas">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeReaderQuotas ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeReaderQuotas() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.NetTcpBinding.ShouldSerializeReaderQuotas" />
      <MemberSignature Language="VB.NET" Value="Public Function ShouldSerializeReaderQuotas () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ShouldSerializeReaderQuotas();" />
      <MemberSignature Language="F#" Value="member this.ShouldSerializeReaderQuotas : unit -&gt; bool" Usage="netTcpBinding.ShouldSerializeReaderQuotas " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回一个值，该值指示 <see cref="P:System.ServiceModel.NetTcpBinding.ReaderQuotas" /> 属性是否已更改，不再是默认值且应对其进行序列化。</summary>
        <returns>如果应当序列化 <see cref="P:System.ServiceModel.NetTcpBinding.ReaderQuotas" /> 属性值，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeReliableSession">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeReliableSession ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeReliableSession() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.NetTcpBinding.ShouldSerializeReliableSession" />
      <MemberSignature Language="VB.NET" Value="Public Function ShouldSerializeReliableSession () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ShouldSerializeReliableSession();" />
      <MemberSignature Language="F#" Value="member this.ShouldSerializeReliableSession : unit -&gt; bool" Usage="netTcpBinding.ShouldSerializeReliableSession " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回一个值，该值指示 <see cref="P:System.ServiceModel.NetTcpBinding.ReliableSession" /> 属性是否已更改，不再是默认值且应对其进行序列化。</summary>
        <returns>如果应当序列化 <see cref="P:System.ServiceModel.NetTcpBinding.ReliableSession" /> 属性值，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeSecurity">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeSecurity ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeSecurity() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.NetTcpBinding.ShouldSerializeSecurity" />
      <MemberSignature Language="VB.NET" Value="Public Function ShouldSerializeSecurity () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ShouldSerializeSecurity();" />
      <MemberSignature Language="F#" Value="member this.ShouldSerializeSecurity : unit -&gt; bool" Usage="netTcpBinding.ShouldSerializeSecurity " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回一个值，该值指示 <see cref="P:System.ServiceModel.NetTcpBinding.Security" /> 属性是否已更改，不再是默认值且应对其进行序列化。</summary>
        <returns>如果应当序列化 <see cref="P:System.ServiceModel.NetTcpBinding.Security" /> 属性值，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeTransactionProtocol">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeTransactionProtocol ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeTransactionProtocol() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.NetTcpBinding.ShouldSerializeTransactionProtocol" />
      <MemberSignature Language="VB.NET" Value="Public Function ShouldSerializeTransactionProtocol () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ShouldSerializeTransactionProtocol();" />
      <MemberSignature Language="F#" Value="member this.ShouldSerializeTransactionProtocol : unit -&gt; bool" Usage="netTcpBinding.ShouldSerializeTransactionProtocol " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回一个值，该值指示 <see cref="P:System.ServiceModel.NetTcpBinding.TransactionProtocol" /> 属性是否已更改，不再是默认值且应对其进行序列化。</summary>
        <returns>如果应当序列化 <see cref="P:System.ServiceModel.NetTcpBinding.TransactionProtocol" /> 属性值，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.ServiceModel.Channels.IBindingRuntimePreferences.ReceiveSynchronously">
      <MemberSignature Language="C#" Value="bool System.ServiceModel.Channels.IBindingRuntimePreferences.ReceiveSynchronously { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.ServiceModel.Channels.IBindingRuntimePreferences.ReceiveSynchronously" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.NetTcpBinding.System#ServiceModel#Channels#IBindingRuntimePreferences#ReceiveSynchronously" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property ReceiveSynchronously As Boolean Implements IBindingRuntimePreferences.ReceiveSynchronously" />
      <MemberSignature Language="C++ CLI" Value="property bool System.ServiceModel.Channels.IBindingRuntimePreferences.ReceiveSynchronously { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.ServiceModel.NetTcpBinding.System.ServiceModel.Channels.IBindingRuntimePreferences.ReceiveSynchronously" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.ServiceModel.Channels.IBindingRuntimePreferences.ReceiveSynchronously</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示是同步处理传入请求还是异步处理传入请求。</summary>
        <value>如果同步处理传入请求，则为 <see langword="true" />；如果异步处理传入请求，则为 <see langword="false" />。 默认值为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此运行时用于接收消息的行为在服务或客户端应用程序可以使用更改[ &lt;v e&gt;](~/docs/framework/configure-apps/file-schema/wcf/synchronousreceive-element.md)。  
  
   
  
## Examples  
 此示例演示如何获取 <xref:System.ServiceModel.NetTcpBinding.TransferMode%2A> 值。  
  
 [!code-csharp[S_UENetTcpBinding#21](~/samples/snippets/csharp/VS_Snippets_CFX/s_uenettcpbinding/cs/source.cs#21)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TransactionFlow">
      <MemberSignature Language="C#" Value="public bool TransactionFlow { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool TransactionFlow" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.NetTcpBinding.TransactionFlow" />
      <MemberSignature Language="VB.NET" Value="Public Property TransactionFlow As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool TransactionFlow { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.TransactionFlow : bool with get, set" Usage="System.ServiceModel.NetTcpBinding.TransactionFlow" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值确定是否启用事务流。</summary>
        <value>如果启用事务流，则为 <see langword="true" />；否则为 <see langword="false" />。 默认值为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 此示例演示如何获取 <xref:System.ServiceModel.NetTcpBinding.TransactionFlow%2A> 值。  
  
 [!code-csharp[S_UENetTcpBinding#18](~/samples/snippets/csharp/VS_Snippets_CFX/s_uenettcpbinding/cs/source.cs#18)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TransactionProtocol">
      <MemberSignature Language="C#" Value="public System.ServiceModel.TransactionProtocol TransactionProtocol { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ServiceModel.TransactionProtocol TransactionProtocol" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.NetTcpBinding.TransactionProtocol" />
      <MemberSignature Language="VB.NET" Value="Public Property TransactionProtocol As TransactionProtocol" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ServiceModel::TransactionProtocol ^ TransactionProtocol { System::ServiceModel::TransactionProtocol ^ get(); void set(System::ServiceModel::TransactionProtocol ^ value); };" />
      <MemberSignature Language="F#" Value="member this.TransactionProtocol : System.ServiceModel.TransactionProtocol with get, set" Usage="System.ServiceModel.NetTcpBinding.TransactionProtocol" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ServiceModel.TransactionProtocol</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置服务在对事务进行流处理时使用的事务处理协议。</summary>
        <value>服务在对事务进行流处理时使用的 <see cref="T:System.ServiceModel.TransactionProtocol" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 此示例演示如何获取 <xref:System.ServiceModel.NetTcpBinding.TransactionProtocol%2A> 值。  
  
 [!code-csharp[S_UENetTcpBinding#19](~/samples/snippets/csharp/VS_Snippets_CFX/s_uenettcpbinding/cs/source.cs#19)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TransferMode">
      <MemberSignature Language="C#" Value="public System.ServiceModel.TransferMode TransferMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.ServiceModel.TransferMode TransferMode" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.NetTcpBinding.TransferMode" />
      <MemberSignature Language="VB.NET" Value="Public Property TransferMode As TransferMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ServiceModel::TransferMode TransferMode { System::ServiceModel::TransferMode get(); void set(System::ServiceModel::TransferMode value); };" />
      <MemberSignature Language="F#" Value="member this.TransferMode : System.ServiceModel.TransferMode with get, set" Usage="System.ServiceModel.NetTcpBinding.TransferMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.NetTcp</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ServiceModel.TransferMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值指示使用此绑定配置的服务是使用消息传输的流处理模式、缓冲模式还是同时使用这两种模式。</summary>
        <value>
          <see cref="T:System.ServiceModel.TransferMode" /> 值，指示使用此绑定配置的服务是使用消息传输的流处理模式、缓冲模式还是同时使用这两种模式。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 此示例演示如何获取 <xref:System.ServiceModel.NetTcpBinding.TransferMode%2A> 值。  
  
 [!code-csharp[S_UENetTcpBinding#22](~/samples/snippets/csharp/VS_Snippets_CFX/s_uenettcpbinding/cs/source.cs#22)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>