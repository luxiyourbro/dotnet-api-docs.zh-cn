<Type Name="OperationContext" FullName="System.ServiceModel.OperationContext">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="1ad78894eb32deaf77ef33230b5f7ce01173df78" />
    <Meta Name="ms.sourcegitcommit" Value="0d6aa6694f157a08fe52cd25b4d9d3dcf913e812" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-CN" />
    <Meta Name="ms.lasthandoff" Value="10/12/2018" />
    <Meta Name="ms.locfileid" Value="49129127" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class OperationContext : System.ServiceModel.IExtensibleObject&lt;System.ServiceModel.OperationContext&gt;" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit OperationContext extends System.Object implements class System.ServiceModel.IExtensibleObject`1&lt;class System.ServiceModel.OperationContext&gt;" />
  <TypeSignature Language="DocId" Value="T:System.ServiceModel.OperationContext" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class OperationContext&#xA;Implements IExtensibleObject(Of OperationContext)" />
  <TypeSignature Language="C++ CLI" Value="public ref class OperationContext sealed : System::ServiceModel::IExtensibleObject&lt;System::ServiceModel::OperationContext ^&gt;" />
  <TypeSignature Language="F#" Value="type OperationContext = class&#xA;    interface IExtensibleObject&lt;OperationContext&gt;" />
  <AssemblyInfo>
    <AssemblyName>System.ServiceModel</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ServiceModel.IExtensibleObject&lt;System.ServiceModel.OperationContext&gt;</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>提供对服务方法的执行上下文的访问权限。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用服务操作中的 <xref:System.ServiceModel.OperationContext> 访问当前操作执行环境。 特别是，操作上下文用于访问双工服务中的回调通道、存储整个操作部分的额外状态数据、访问传入消息头和属性以及添加传出消息头和属性。  
  
 有关使用扩展存储状态数据的详细信息，请参阅[可扩展对象](~/docs/framework/wcf/extending/extensible-objects.md)。  
  
 <xref:System.ServiceModel.OperationContext> 具有以下属性和方法。  
  
-   <xref:System.ServiceModel.OperationContext.Current%2A> 属性返回表示当前执行上下文的 <xref:System.ServiceModel.OperationContext> 对象。  
  
-   <xref:System.ServiceModel.OperationContext.ServiceSecurityContext%2A> 属性返回执行该方法的安全环境。  
  
-   <xref:System.ServiceModel.OperationContext.EndpointDispatcher%2A> 属性获取操作的 <xref:System.ServiceModel.Dispatcher.EndpointDispatcher?displayProperty=nameWithType>。  
  
-   <xref:System.ServiceModel.OperationContext.Extensions%2A> 属性返回当前 <xref:System.ServiceModel.OperationContext> 的扩展集合。  
  
-   <xref:System.ServiceModel.OperationContext.Host%2A> 属性返回管理服务的 <xref:System.ServiceModel.ServiceHostBase> 对象。  
  
-   <xref:System.ServiceModel.OperationContext.HasSupportingTokens%2A> 属性返回一个值，该值指示方法是否具有支持令牌，如果具有，则 <xref:System.ServiceModel.OperationContext.SupportingTokens%2A> 属性获取这些支持令牌。  
  
-   <xref:System.ServiceModel.OperationContext.IncomingMessageHeaders%2A>、<xref:System.ServiceModel.OperationContext.IncomingMessageProperties%2A> 和 <xref:System.ServiceModel.OperationContext.IncomingMessageVersion%2A> 属性从传入消息中获取这些项。  
  
-   操作完成时激发 <xref:System.ServiceModel.OperationContext.OperationCompleted> 事件。  
  
-   <xref:System.ServiceModel.OperationContext.OutgoingMessageHeaders%2A> 和 <xref:System.ServiceModel.OperationContext.OutgoingMessageProperties%2A> 属性获取出站消息的这些项。  
  
-   <xref:System.ServiceModel.OperationContext.RequestContext%2A> 属性返回方法的 <xref:System.ServiceModel.Channels.RequestContext> 实现。  
  
-   <xref:System.ServiceModel.OperationContext.InstanceContext%2A> 属性返回与操作关联的 <xref:System.ServiceModel.InstanceContext>。  
  
-   <xref:System.ServiceModel.OperationContext.SessionId%2A> 属性返回当前通道和对象的会话标识符。  
  
-   如果是双工通信，<xref:System.ServiceModel.OperationContext.GetCallbackChannel%2A> 方法会将回调通道返回调用方。  
  
-   <xref:System.ServiceModel.OperationContext.SetTransactionComplete%2A> 方法提交当前事务。  
  
   
  
## Examples  
 下面的代码示例使用 <xref:System.ServiceModel.OperationContext.Current%2A> 属性和 <xref:System.ServiceModel.OperationContext.GetCallbackChannel%2A> 方法获取从方法中返回调用方的通道。 此示例中的所有方法都是单向方法，使服务和客户端能够独立地进行双向通信。 在此情况下，示例客户端应用程序在退出前仅需要一次返回调用，但其他客户端（例如 Windows 窗体客户端）可以接收来自服务的任意数量的调用。  
  
 [!code-csharp[SCA.CallbackContract#1](~/samples/snippets/csharp/VS_Snippets_CFX/sca.callbackcontract/cs/services.cs#1)]
 [!code-vb[SCA.CallbackContract#1](~/samples/snippets/visualbasic/VS_Snippets_CFX/sca.callbackcontract/vb/services.vb#1)]  
  
 下列客户端实现 `SampleDuplexHelloCallback` 以接收回调消息。 由于使用了前面示例中的 <xref:System.ServiceModel.ServiceContractAttribute.Name%2A> 属性，导入的回调协定与服务中的回调协定具有不同的名称。 请注意，客户端不对其是否或何时可能收到回调作出任何假设；服务器回调与客户端的出站调用完全无关。  
  
> [!NOTE]
>  有关在客户端方案中使用 <xref:System.ServiceModel.OperationContext> 类的示例，请参见 <xref:System.ServiceModel.OperationContextScope>。  
  
 [!code-csharp[SCA.CallbackContract#3](~/samples/snippets/csharp/VS_Snippets_CFX/sca.callbackcontract/cs/client.cs#3)]
 [!code-vb[SCA.CallbackContract#3](~/samples/snippets/visualbasic/VS_Snippets_CFX/sca.callbackcontract/vb/client.vb#3)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public OperationContext (System.ServiceModel.IContextChannel channel);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.ServiceModel.IContextChannel channel) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.OperationContext.#ctor(System.ServiceModel.IContextChannel)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (channel As IContextChannel)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; OperationContext(System::ServiceModel::IContextChannel ^ channel);" />
      <MemberSignature Language="F#" Value="new System.ServiceModel.OperationContext : System.ServiceModel.IContextChannel -&gt; System.ServiceModel.OperationContext" Usage="new System.ServiceModel.OperationContext channel" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="channel" Type="System.ServiceModel.IContextChannel" />
      </Parameters>
      <Docs>
        <param name="channel">用于创建新客户端 <see cref="T:System.ServiceModel.IContextChannel" /> 的 <see cref="T:System.ServiceModel.OperationContext" />。</param>
        <summary>初始化 <see cref="T:System.ServiceModel.OperationContext" /> 类的新实例，该类使用客户端应用程序中指定的 <see cref="T:System.ServiceModel.IContextChannel" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用 <xref:System.ServiceModel.OperationContext.%23ctor%2A> 构造函数在与代理关联的范围中创建新的操作上下文，以修改出站项（如标头）。  
  
   
  
## Examples  
 下面的示例演示如何使用 <xref:System.ServiceModel.OperationContextScope> 在客户端应用程序中创建新的上下文以向传出消息添加自定义标头。  
  
 [!code-csharp[OperationContextScope#4](~/samples/snippets/csharp/VS_Snippets_CFX/operationcontextscope/cs/client.cs#4)]
 [!code-vb[OperationContextScope#4](~/samples/snippets/visualbasic/VS_Snippets_CFX/operationcontextscope/vb/client.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">通道为 null。</exception>
      </Docs>
    </Member>
    <Member MemberName="Channel">
      <MemberSignature Language="C#" Value="public System.ServiceModel.IContextChannel Channel { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ServiceModel.IContextChannel Channel" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.OperationContext.Channel" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Channel As IContextChannel" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ServiceModel::IContextChannel ^ Channel { System::ServiceModel::IContextChannel ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Channel : System.ServiceModel.IContextChannel" Usage="System.ServiceModel.OperationContext.Channel" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ServiceModel.IContextChannel</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取与当前 <see cref="T:System.ServiceModel.OperationContext" /> 对象关联的通道。</summary>
        <value>一个与当前 <see cref="T:System.ServiceModel.IContextChannel" /> 关联的 <see cref="T:System.ServiceModel.OperationContext" />。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ClaimsPrincipal">
      <MemberSignature Language="C#" Value="public System.Security.Claims.ClaimsPrincipal ClaimsPrincipal { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Claims.ClaimsPrincipal ClaimsPrincipal" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.OperationContext.ClaimsPrincipal" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ClaimsPrincipal As ClaimsPrincipal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::Claims::ClaimsPrincipal ^ ClaimsPrincipal { System::Security::Claims::ClaimsPrincipal ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ClaimsPrincipal : System.Security.Claims.ClaimsPrincipal" Usage="System.ServiceModel.OperationContext.ClaimsPrincipal" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Claims.ClaimsPrincipal</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取与此操作关联的基于声明的主体。</summary>
        <value>声明主体。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Current">
      <MemberSignature Language="C#" Value="public static System.ServiceModel.OperationContext Current { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.ServiceModel.OperationContext Current" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.OperationContext.Current" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property Current As OperationContext" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::ServiceModel::OperationContext ^ Current { System::ServiceModel::OperationContext ^ get(); void set(System::ServiceModel::OperationContext ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Current : System.ServiceModel.OperationContext with get, set" Usage="System.ServiceModel.OperationContext.Current" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ServiceModel.OperationContext</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置当前线程的执行上下文。</summary>
        <value>表示当前方法的消息和执行上下文的 <see cref="T:System.ServiceModel.OperationContext" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用 <xref:System.ServiceModel.OperationContext.Current%2A> 属性获取当前方法的执行和消息上下文。  
  
   
  
## Examples  
 下面的代码示例使用 <xref:System.ServiceModel.OperationContext.Current%2A> 属性和 <xref:System.ServiceModel.OperationContext.GetCallbackChannel%2A> 方法创建从方法中返回调用方的通道。 此示例中的所有方法都是单向方法，使服务和客户端能够独立地进行双向通信。 在此情况下，示例客户端应用程序在退出前仅需要一次返回调用，但其他客户端（例如 Windows 窗体客户端）可以接收来自服务的任意数量的调用。  
  
 [!code-csharp[SCA.CallbackContract#1](~/samples/snippets/csharp/VS_Snippets_CFX/sca.callbackcontract/cs/services.cs#1)]
 [!code-vb[SCA.CallbackContract#1](~/samples/snippets/visualbasic/VS_Snippets_CFX/sca.callbackcontract/vb/services.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EndpointDispatcher">
      <MemberSignature Language="C#" Value="public System.ServiceModel.Dispatcher.EndpointDispatcher EndpointDispatcher { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ServiceModel.Dispatcher.EndpointDispatcher EndpointDispatcher" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.OperationContext.EndpointDispatcher" />
      <MemberSignature Language="VB.NET" Value="Public Property EndpointDispatcher As EndpointDispatcher" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ServiceModel::Dispatcher::EndpointDispatcher ^ EndpointDispatcher { System::ServiceModel::Dispatcher::EndpointDispatcher ^ get(); void set(System::ServiceModel::Dispatcher::EndpointDispatcher ^ value); };" />
      <MemberSignature Language="F#" Value="member this.EndpointDispatcher : System.ServiceModel.Dispatcher.EndpointDispatcher with get, set" Usage="System.ServiceModel.OperationContext.EndpointDispatcher" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ServiceModel.Dispatcher.EndpointDispatcher</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置要检查或修改的终结点的终结点调度程序。</summary>
        <value>要检查或修改的终结点的终结点调度程序。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Extensions">
      <MemberSignature Language="C#" Value="public System.ServiceModel.IExtensionCollection&lt;System.ServiceModel.OperationContext&gt; Extensions { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ServiceModel.IExtensionCollection`1&lt;class System.ServiceModel.OperationContext&gt; Extensions" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.OperationContext.Extensions" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Extensions As IExtensionCollection(Of OperationContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ServiceModel::IExtensionCollection&lt;System::ServiceModel::OperationContext ^&gt; ^ Extensions { System::ServiceModel::IExtensionCollection&lt;System::ServiceModel::OperationContext ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Extensions : System.ServiceModel.IExtensionCollection&lt;System.ServiceModel.OperationContext&gt;" Usage="System.ServiceModel.OperationContext.Extensions" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.ServiceModel.IExtensibleObject`1.Extensions</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ServiceModel.IExtensionCollection&lt;System.ServiceModel.OperationContext&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>从当前消息上下文中获取服务扩展集合。</summary>
        <value>
          <see cref="T:System.ServiceModel.OperationContext" /> 的扩展集合。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用 <xref:System.ServiceModel.OperationContext.Extensions%2A> 属性获取用于修改上下文或添加自定义状态的 <xref:System.ServiceModel.OperationContext> 的所有扩展的集合。 有关扩展的详细信息，请参阅[可扩展对象](~/docs/framework/wcf/extending/extensible-objects.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetCallbackChannel&lt;T&gt;">
      <MemberSignature Language="C#" Value="public T GetCallbackChannel&lt;T&gt; ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance !!T GetCallbackChannel&lt;T&gt;() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.OperationContext.GetCallbackChannel``1" />
      <MemberSignature Language="VB.NET" Value="Public Function GetCallbackChannel(Of T) () As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; T GetCallbackChannel();" />
      <MemberSignature Language="F#" Value="member this.GetCallbackChannel : unit -&gt; 'T" Usage="operationContext.GetCallbackChannel " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters />
      <Docs>
        <typeparam name="T">用于回调到客户端的通道的类型。</typeparam>
        <summary>获取调用当前操作的客户端实例的通道。</summary>
        <returns>一个客户端实例的通道，该客户端实例调用 <see cref="P:System.ServiceModel.ServiceContractAttribute.CallbackContract" /> 属性中指定类型的操作。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 调用 <xref:System.ServiceModel.OperationContext.GetCallbackChannel%2A> 属性以获取通道，使用该通道可以调用调用服务的客户端实例的操作。  
  
   
  
## Examples  
 下面的代码示例使用 <xref:System.ServiceModel.OperationContext.Current%2A> 属性和 <xref:System.ServiceModel.OperationContext.GetCallbackChannel%2A> 方法创建从操作中返回调用方的通道。 此示例中的所有操作都是单向操作，使服务和客户端能够独立地进行双向通信。 在此情况下，示例客户端应用程序在退出前仅需要一次返回调用，但其他客户端（例如 Windows 窗体客户端）可以接收来自服务的任意数量的调用。  
  
 [!code-csharp[SCA.CallbackContract#1](~/samples/snippets/csharp/VS_Snippets_CFX/sca.callbackcontract/cs/services.cs#1)]
 [!code-vb[SCA.CallbackContract#1](~/samples/snippets/visualbasic/VS_Snippets_CFX/sca.callbackcontract/vb/services.vb#1)]  
  
 下列客户端实现 `SampleDuplexHelloCallback` 以接收回调消息。 由于使用了前面示例中的 <xref:System.ServiceModel.ServiceContractAttribute.Name%2A> 属性，导入的回调协定与服务中的回调协定具有不同的名称。 请注意，客户端不对其是否或何时可能收到回调作出任何假设；服务器回调与客户端的出站调用完全无关。  
  
> [!NOTE]
>  有关在客户端方案中使用 <xref:System.ServiceModel.OperationContext> 类的示例，请参见 <xref:System.ServiceModel.OperationContextScope>。  
  
 [!code-csharp[SCA.CallbackContract#3](~/samples/snippets/csharp/VS_Snippets_CFX/sca.callbackcontract/cs/client.cs#3)]
 [!code-vb[SCA.CallbackContract#3](~/samples/snippets/visualbasic/VS_Snippets_CFX/sca.callbackcontract/vb/client.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HasSupportingTokens">
      <MemberSignature Language="C#" Value="public bool HasSupportingTokens { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasSupportingTokens" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.OperationContext.HasSupportingTokens" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HasSupportingTokens As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool HasSupportingTokens { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.HasSupportingTokens : bool" Usage="System.ServiceModel.OperationContext.HasSupportingTokens" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示传入消息是否具有支持令牌。</summary>
        <value>如果传入消息具有支持令牌，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Host">
      <MemberSignature Language="C#" Value="public System.ServiceModel.ServiceHostBase Host { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ServiceModel.ServiceHostBase Host" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.OperationContext.Host" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Host As ServiceHostBase" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ServiceModel::ServiceHostBase ^ Host { System::ServiceModel::ServiceHostBase ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Host : System.ServiceModel.ServiceHostBase" Usage="System.ServiceModel.OperationContext.Host" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ServiceModel.ServiceHostBase</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取当前服务对象的 <see cref="T:System.ServiceModel.ServiceHost" />。</summary>
        <value>
          <see cref="T:System.ServiceModel.ServiceHost" /> 对象。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IncomingMessageHeaders">
      <MemberSignature Language="C#" Value="public System.ServiceModel.Channels.MessageHeaders IncomingMessageHeaders { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ServiceModel.Channels.MessageHeaders IncomingMessageHeaders" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.OperationContext.IncomingMessageHeaders" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IncomingMessageHeaders As MessageHeaders" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ServiceModel::Channels::MessageHeaders ^ IncomingMessageHeaders { System::ServiceModel::Channels::MessageHeaders ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.IncomingMessageHeaders : System.ServiceModel.Channels.MessageHeaders" Usage="System.ServiceModel.OperationContext.IncomingMessageHeaders" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ServiceModel.Channels.MessageHeaders</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取 <see cref="T:System.ServiceModel.OperationContext" /> 的传入消息头。</summary>
        <value>一个包含传入消息头的 <see cref="T:System.ServiceModel.Channels.MessageHeaders" /> 对象。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用此属性检查或修改到达服务操作的请求标头或到达客户端代理的答复标头。  
  
   
  
## Examples  
 下面的代码示例演示如何读取服务操作中的传入消息头。  
  
 [!code-csharp[OperationContextScope#2](~/samples/snippets/csharp/VS_Snippets_CFX/operationcontextscope/cs/services.cs#2)]
 [!code-vb[OperationContextScope#2](~/samples/snippets/visualbasic/VS_Snippets_CFX/operationcontextscope/vb/services.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IncomingMessageProperties">
      <MemberSignature Language="C#" Value="public System.ServiceModel.Channels.MessageProperties IncomingMessageProperties { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ServiceModel.Channels.MessageProperties IncomingMessageProperties" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.OperationContext.IncomingMessageProperties" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IncomingMessageProperties As MessageProperties" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ServiceModel::Channels::MessageProperties ^ IncomingMessageProperties { System::ServiceModel::Channels::MessageProperties ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.IncomingMessageProperties : System.ServiceModel.Channels.MessageProperties" Usage="System.ServiceModel.OperationContext.IncomingMessageProperties" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ServiceModel.Channels.MessageProperties</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取 <see cref="T:System.ServiceModel.OperationContext" /> 中的传入消息的消息属性。</summary>
        <value>一个包含传入消息的消息属性的 <see cref="T:System.ServiceModel.Channels.MessageProperties" /> 对象。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用此属性检查或修改服务操作中请求消息的消息属性或客户端代理中答复消息的消息属性。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IncomingMessageVersion">
      <MemberSignature Language="C#" Value="public System.ServiceModel.Channels.MessageVersion IncomingMessageVersion { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ServiceModel.Channels.MessageVersion IncomingMessageVersion" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.OperationContext.IncomingMessageVersion" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IncomingMessageVersion As MessageVersion" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ServiceModel::Channels::MessageVersion ^ IncomingMessageVersion { System::ServiceModel::Channels::MessageVersion ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.IncomingMessageVersion : System.ServiceModel.Channels.MessageVersion" Usage="System.ServiceModel.OperationContext.IncomingMessageVersion" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ServiceModel.Channels.MessageVersion</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取 <see cref="T:System.ServiceModel.OperationContext" /> 的传入 SOAP 消息版本。</summary>
        <value>传入消息的 SOAP 版本。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用此属性检查到达服务操作的请求消息的 SOAP 版本或到达客户端代理的答复消息的 SOAP 版本。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InstanceContext">
      <MemberSignature Language="C#" Value="public System.ServiceModel.InstanceContext InstanceContext { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ServiceModel.InstanceContext InstanceContext" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.OperationContext.InstanceContext" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property InstanceContext As InstanceContext" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ServiceModel::InstanceContext ^ InstanceContext { System::ServiceModel::InstanceContext ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.InstanceContext : System.ServiceModel.InstanceContext" Usage="System.ServiceModel.OperationContext.InstanceContext" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ServiceModel.InstanceContext</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取管理当前服务实例的 <see cref="T:System.ServiceModel.InstanceContext" /> 对象。</summary>
        <value>当前服务的 <see cref="T:System.ServiceModel.InstanceContext" /> 对象。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用 <xref:System.ServiceModel.OperationContext.InstanceContext%2A> 属性访问管理当前服务对象的运行时对象。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsUserContext">
      <MemberSignature Language="C#" Value="public bool IsUserContext { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsUserContext" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.OperationContext.IsUserContext" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsUserContext As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsUserContext { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsUserContext : bool" Usage="System.ServiceModel.OperationContext.IsUserContext" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>此属性专供系统使用，不应由用户调用。</summary>
        <value>
          <see langword="true" />。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OperationCompleted">
      <MemberSignature Language="C#" Value="public event EventHandler OperationCompleted;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler OperationCompleted" />
      <MemberSignature Language="DocId" Value="E:System.ServiceModel.OperationContext.OperationCompleted" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event OperationCompleted As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ OperationCompleted;" />
      <MemberSignature Language="F#" Value="member this.OperationCompleted : EventHandler " Usage="member this.OperationCompleted : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>操作完成时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果将 <xref:System.ServiceModel.OperationContext.OperationCompleted> 设置为 <xref:System.ServiceModel.OperationBehaviorAttribute.AutoDisposeParameters%2A?displayProperty=nameWithType>，请使用 `false` 事件释放参数或返回值。 通常情况下设置<xref:System.ServiceModel.OperationBehaviorAttribute.AutoDisposeParameters%2A?displayProperty=nameWithType>到`false`以免 WCF 调用<xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType>参数和返回值对象上。  但是，如果某些参数需要保留而其他参数需要释放，则此事件是释放这些参数的最佳位置。  
  
 另外，在双工绑定的情况下，此事件可用于在发出当前操作的答复后在回调通道上发送请求。  
  
> [!NOTE]
>  如果调用方侦听的是 <xref:System.ServiceModel.OperationContext.OperationCompleted?displayProperty=nameWithType> 操作的 <xref:System.ServiceModel.OperationContractAttribute.IsTerminating%2A?displayProperty=nameWithType> 事件，则在收到响应时可能会阻塞。 处理这种情况的正确方法是，当引发 <xref:System.ServiceModel.OperationContext.OperationCompleted> 时在其他线程上调度工作，然后从该事件处理程序立即返回。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OutgoingMessageHeaders">
      <MemberSignature Language="C#" Value="public System.ServiceModel.Channels.MessageHeaders OutgoingMessageHeaders { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ServiceModel.Channels.MessageHeaders OutgoingMessageHeaders" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.OperationContext.OutgoingMessageHeaders" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property OutgoingMessageHeaders As MessageHeaders" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ServiceModel::Channels::MessageHeaders ^ OutgoingMessageHeaders { System::ServiceModel::Channels::MessageHeaders ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.OutgoingMessageHeaders : System.ServiceModel.Channels.MessageHeaders" Usage="System.ServiceModel.OperationContext.OutgoingMessageHeaders" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ServiceModel.Channels.MessageHeaders</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取活动 <see cref="T:System.ServiceModel.OperationContext" /> 的传出消息头。</summary>
        <value>一个 <see cref="T:System.ServiceModel.Channels.MessageHeaders" /> 对象，包含活动 <see cref="T:System.ServiceModel.OperationContext" /> 的出站消息头。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用此属性添加服务操作发送的答复标头或请求标头发送的 WCF 客户端对象。  
  
   
  
## Examples  
 下面的示例演示如何使用 <xref:System.ServiceModel.OperationContextScope> 在客户端应用程序中创建新的上下文以向传出消息添加自定义标头。  
  
 [!code-csharp[OperationContextScope#4](~/samples/snippets/csharp/VS_Snippets_CFX/operationcontextscope/cs/client.cs#4)]
 [!code-vb[OperationContextScope#4](~/samples/snippets/visualbasic/VS_Snippets_CFX/operationcontextscope/vb/client.vb#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OutgoingMessageProperties">
      <MemberSignature Language="C#" Value="public System.ServiceModel.Channels.MessageProperties OutgoingMessageProperties { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ServiceModel.Channels.MessageProperties OutgoingMessageProperties" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.OperationContext.OutgoingMessageProperties" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property OutgoingMessageProperties As MessageProperties" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ServiceModel::Channels::MessageProperties ^ OutgoingMessageProperties { System::ServiceModel::Channels::MessageProperties ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.OutgoingMessageProperties : System.ServiceModel.Channels.MessageProperties" Usage="System.ServiceModel.OperationContext.OutgoingMessageProperties" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ServiceModel.Channels.MessageProperties</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取活动 <see cref="T:System.ServiceModel.OperationContext" /> 中的出站消息的消息属性。</summary>
        <value>一个包含出站消息的消息属性的 <see cref="T:System.ServiceModel.Channels.MessageProperties" /> 对象。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用此属性添加服务操作中答复消息的消息属性或客户端代理中请求消息的消息属性。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RequestContext">
      <MemberSignature Language="C#" Value="public System.ServiceModel.Channels.RequestContext RequestContext { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ServiceModel.Channels.RequestContext RequestContext" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.OperationContext.RequestContext" />
      <MemberSignature Language="VB.NET" Value="Public Property RequestContext As RequestContext" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ServiceModel::Channels::RequestContext ^ RequestContext { System::ServiceModel::Channels::RequestContext ^ get(); void set(System::ServiceModel::Channels::RequestContext ^ value); };" />
      <MemberSignature Language="F#" Value="member this.RequestContext : System.ServiceModel.Channels.RequestContext with get, set" Usage="System.ServiceModel.OperationContext.RequestContext" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ServiceModel.Channels.RequestContext</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置此方法的 <see cref="T:System.ServiceModel.Channels.RequestContext" /> 实现。</summary>
        <value>一个 <see cref="T:System.ServiceModel.Channels.RequestContext" /> 实现，或者为 null（如果没有请求上下文）。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 单向操作没有请求上下文。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ServiceSecurityContext">
      <MemberSignature Language="C#" Value="public System.ServiceModel.ServiceSecurityContext ServiceSecurityContext { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ServiceModel.ServiceSecurityContext ServiceSecurityContext" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.OperationContext.ServiceSecurityContext" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ServiceSecurityContext As ServiceSecurityContext" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ServiceModel::ServiceSecurityContext ^ ServiceSecurityContext { System::ServiceModel::ServiceSecurityContext ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ServiceSecurityContext : System.ServiceModel.ServiceSecurityContext" Usage="System.ServiceModel.OperationContext.ServiceSecurityContext" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ServiceModel.ServiceSecurityContext</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置将在其中执行此方法的 <see cref="T:System.ServiceModel.ServiceSecurityContext" />。</summary>
        <value>
          <see cref="T:System.ServiceModel.ServiceSecurityContext" /> 对象。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SessionId">
      <MemberSignature Language="C#" Value="public string SessionId { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string SessionId" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.OperationContext.SessionId" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SessionId As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ SessionId { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SessionId : string" Usage="System.ServiceModel.OperationContext.SessionId" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取用于标识当前会话的 <see cref="T:System.String" />。</summary>
        <value>会话标识符。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetTransactionComplete">
      <MemberSignature Language="C#" Value="public void SetTransactionComplete ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetTransactionComplete() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.OperationContext.SetTransactionComplete" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetTransactionComplete ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetTransactionComplete();" />
      <MemberSignature Language="F#" Value="member this.SetTransactionComplete : unit -&gt; unit" Usage="operationContext.SetTransactionComplete " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>提交当前正在执行的事务。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 这仅在将 <xref:System.ServiceModel.OperationBehaviorAttribute.TransactionAutoComplete%2A?displayProperty=nameWithType> 设置为 `false` 的操作中才有用。 通常，服务仅对某些操作（而非全部）执行该操作。 如果 <xref:System.ServiceModel.OperationBehaviorAttribute.TransactionAutoComplete%2A?displayProperty=nameWithType> 为 false，则事务会自动完成。 如果无法确定在设计时操作是否需要完成事务，则使用 <xref:System.ServiceModel.OperationContext.SetTransactionComplete%2A>。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">上下文中没有任何事务。</exception>
      </Docs>
    </Member>
    <Member MemberName="SupportingTokens">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.ICollection&lt;System.ServiceModel.Security.SupportingTokenSpecification&gt; SupportingTokens { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.ICollection`1&lt;class System.ServiceModel.Security.SupportingTokenSpecification&gt; SupportingTokens" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.OperationContext.SupportingTokens" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SupportingTokens As ICollection(Of SupportingTokenSpecification)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::ICollection&lt;System::ServiceModel::Security::SupportingTokenSpecification ^&gt; ^ SupportingTokens { System::Collections::Generic::ICollection&lt;System::ServiceModel::Security::SupportingTokenSpecification ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SupportingTokens : System.Collections.Generic.ICollection&lt;System.ServiceModel.Security.SupportingTokenSpecification&gt;" Usage="System.ServiceModel.OperationContext.SupportingTokens" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.ICollection&lt;System.ServiceModel.Security.SupportingTokenSpecification&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个 <see cref="T:System.Collections.Generic.ICollection`1" /> 类型的 <see cref="T:System.IdentityModel.Tokens.SecurityToken" />。</summary>
        <value>安全令牌集合。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>