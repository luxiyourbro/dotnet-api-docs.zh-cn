<Type Name="OperationContractAttribute" FullName="System.ServiceModel.OperationContractAttribute">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="73c4498ef4eb2c4124673169e0bcb322433730f5" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-CN" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36610308" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class OperationContractAttribute : Attribute" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit OperationContractAttribute extends System.Attribute" />
  <TypeSignature Language="DocId" Value="T:System.ServiceModel.OperationContractAttribute" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class OperationContractAttribute&#xA;Inherits Attribute" />
  <TypeSignature Language="C++ CLI" Value="public ref class OperationContractAttribute sealed : Attribute" />
  <TypeSignature Language="F#" Value="type OperationContractAttribute = class&#xA;    inherit Attribute" />
  <AssemblyInfo>
    <AssemblyName>System.ServiceModel</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Attribute</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.AttributeUsage(System.AttributeTargets.Method)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Indicates that a method defines an operation that is part of a service contract in a Windows Communication Foundation (WCF) application.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 将 <xref:System.ServiceModel.OperationContractAttribute> 应用于方法，以指示该方法实现作为服务协定（由 <xref:System.ServiceModel.ServiceContractAttribute> 属性指定）一部分的服务操作。  
  
 使用 <xref:System.ServiceModel.OperationContractAttribute> 属性控制该操作的结构以及以元数据表示的值：  
  
-   <xref:System.ServiceModel.OperationContractAttribute.Action%2A> 属性指定唯一标识该操作的操作。 WCF 请求将消息调度给基于这些文件的操作的方法。  
  
-   <xref:System.ServiceModel.OperationContractAttribute.AsyncPattern%2A> 属性指示使用 Begin/End 方法对可以实现或异步调用该操作。  
  
-   <xref:System.ServiceModel.OperationContractAttribute.HasProtectionLevel%2A> 属性指示是否已显式设置 <xref:System.ServiceModel.OperationContractAttribute.ProtectionLevel%2A> 属性。  
  
-   <xref:System.ServiceModel.OperationContractAttribute.IsOneWay%2A> 属性指示该操作只包含单个输入消息。 该操作没有关联的输出消息。  
  
-   <xref:System.ServiceModel.OperationContractAttribute.IsInitiating%2A> 属性指定该操作是否可以是会话中的初始操作。  
  
-   <xref:System.ServiceModel.OperationContractAttribute.IsTerminating%2A>属性指定是否试图终止当前会话在操作完成之后 WCF。  
  
-   <xref:System.ServiceModel.OperationContractAttribute.ProtectionLevel%2A> 属性指定运行时操作要求的消息级安全性。  
  
-   <xref:System.ServiceModel.OperationContractAttribute.ReplyAction%2A> 属性指定该操作答复消息的操作。  
  
 <xref:System.ServiceModel.OperationContractAttribute> 属性声明方法是服务协定中的操作。 只有具有 <xref:System.ServiceModel.OperationContractAttribute> 属性的方法可作为服务操作公开。 不含有 <xref:System.ServiceModel.OperationContractAttribute> 标记的所有方法的服务协定不公开任何操作。  
  
 <xref:System.ServiceModel.OperationContractAttribute.AsyncPattern%2A>属性指示一对`Begin` \< *methodName*> 和`End` \< *methodName*> 方法构成单个操作以异步方式实现 （不管在客户端或服务）。 异步实现操作的服务功能是服务实现详细信息，并且不会在元数据中（如 Web 服务描述语言 (WSDL)）公开。  
  
 同样，客户端可选择异步调用与实现服务方法无关的操作。 如果服务方法需要花些时间才可将信息直接返回至客户端但又必须这样做时，建议在客户端异步调用服务操作。 有关详细信息，请参阅<xref:System.ServiceModel.OperationContractAttribute.AsyncPattern%2A>。  
  
 <xref:System.ServiceModel.OperationContractAttribute.IsOneWay%2A> 属性指示方法根本不返回任何值，包括空基础响应消息。 这种类型的方法对通知或事件样式通信十分有用。 但这种方法不能返回答复消息，因此该方法的声明必须返回 `void`。  
  
> [!IMPORTANT]
>  当以编程方式检索此属性中的信息存储，使用<xref:System.ServiceModel.Description.ContractDescription>类而不是反射。  
  
> [!NOTE]
>  如果 <xref:System.ServiceModel.OperationContractAttribute.IsOneWay%2A> 属性设置为 `false`（默认值），即使返回 `void` 的方法也是基础消息级别的双向方法。 在此种情况下，基础结构将创建并发送一条空消息，以向调用方指示该方法已返回内容。 使用此方法使应用程序和基础结构可以将错误信息（如 SOAP 错误）发送回客户端。 将 <xref:System.ServiceModel.OperationContractAttribute.IsOneWay%2A> 设置为 `true` 是阻止创建和调度答复消息的唯一方法。 有关详细信息，请参阅[单向服务](~/docs/framework/wcf/feature-details/one-way-services.md)。  
  
 <xref:System.ServiceModel.OperationContractAttribute.Action%2A> 和 <xref:System.ServiceModel.OperationContractAttribute.ReplyAction%2A> 属性不仅可用于修改 SOAP 消息的默认操作，也可用于为无法识别的消息创建处理程序，或为直接消息编程禁用添加操作。 使用 <xref:System.ServiceModel.OperationContractAttribute.IsInitiating%2A> 属性以防止客户端在进行其他操作前调用特定的服务操作。 使用<xref:System.ServiceModel.OperationContractAttribute.IsTerminating%2A>属性具有 WCF 客户端调用特定服务操作后，关闭信道。 有关详细信息，请参阅[使用会话](~/docs/framework/wcf/using-sessions.md)。  
  
 <xref:System.ServiceModel.OperationContractAttribute.ProtectionLevel%2A> 属性使您可以在操作协定中指定该操作消息是否已签名和/或已加密。 如果绑定无法提供协定中要求的安全级别，则运行时将引发异常。 有关详细信息，请参阅<xref:System.ServiceModel.OperationContractAttribute.ProtectionLevel%2A>和[了解保护级别](~/docs/framework/wcf/understanding-protection-level.md)。  
  
   
  
## Examples  
 下面的代码示例演示只有一个操作的简单服务协定。  
  
 [!code-csharp[OperationContractAttribute#1](~/samples/snippets/csharp/VS_Snippets_CFX/operationcontractattribute/cs/services.cs#1)]
 [!code-vb[OperationContractAttribute#1](~/samples/snippets/visualbasic/VS_Snippets_CFX/operationcontractattribute/vb/services.vb#1)]  
  
 下面的示例演示了一个服务，该服务实现指定三个操作的隐式服务协定。 其中两个操作是双向操作，即无论返回值是什么，它们都将基础响应消息返回至调用方。 第三个操作接收一个调用（基础入站消息），但不返回任何基础响应消息。  
  
```csharp  
[ServiceContractAttribute]  
public class OneAndTwoWay  
{  
  // The client waits until a response message appears.  
  [OperationContractAttribute]  
  public int MethodOne (int x, out int y)  
  {  
    y = 34;  
    return 0;  
  }  
  
  // The client waits until an empty response message appears.  
  [OperationContractAttribute]  
  public void MethodTwo (int x)  
  {  
    return;  
  }  
  
  // The client returns as soon as an outbound message  
  // is dispatched to the service; no response  
  // message is generated or sent from the service.  
  [OperationContractAttribute(IsOneWay=true)]  
  public void MethodThree (int x)  
  {  
    return;  
  }  
}  
```  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public OperationContractAttribute ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.OperationContractAttribute.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; OperationContractAttribute();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initializes a new instance of the <see cref="T:System.ServiceModel.OperationContractAttribute" /> class.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Action">
      <MemberSignature Language="C#" Value="public string Action { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Action" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.OperationContractAttribute.Action" />
      <MemberSignature Language="VB.NET" Value="Public Property Action As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Action { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Action : string with get, set" Usage="System.ServiceModel.OperationContractAttribute.Action" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the WS-Addressing action of the request message.</summary>
        <value>生成 WS-Addressing Action 标头时要使用的操作。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用<xref:System.ServiceModel.OperationContractAttribute.Action%2A>属性来控制该方法的操作的输入消息。 由于 WCF 使用此操作来调度传入消息和相应的方法，在该协定操作中使用的消息必须具有唯一的操作。 默认操作值是协定命名空间的组合 (默认值是"http://tempuri.org/")，（接口名称或类名称，如果使用没有显式服务接口） 的协定名称、 操作名称和一个附加字符串 ("Response") 如果消息是一个相关的响应。 您可以使用 <xref:System.ServiceModel.OperationContractAttribute.Action%2A> 属性重写该默认值。  
  
 若要指示服务操作可处理该服务接收的所有消息，但又不能定向到服务操作，请指定值“*”（星号）。 这种类型的操作（称为不匹配的消息处理程序）必须具有下列方法签名之一，否则会引发 <xref:System.InvalidOperationException>：  
  
-   该服务操作只能接受一个 <xref:System.ServiceModel.Channels.Message> 对象，并且返回一个 <xref:System.ServiceModel.Channels.Message> 对象。  
  
-   该服务操作只能接受一个 <xref:System.ServiceModel.Channels.Message> 对象，并且不返回任何内容（即返回 `void`）。  
  
> [!NOTE]
>  服务协定只能有一个 <xref:System.ServiceModel.OperationContractAttribute.Action%2A> 属性设置为“*”的服务操作。 服务类实现的相同侦听 uri 所承载的服务任何的协定组可以具有多个服务操作<xref:System.ServiceModel.OperationContractAttribute.Action%2A>属性设置为"\*"时<xref:System.ServiceModel.OperationContractAttribute.IsInitiating%2A>属性设置为`false`。 但是，只有其中一个服务操作可以让<xref:System.ServiceModel.OperationContractAttribute.Action%2A>属性设置为"\*"和<xref:System.ServiceModel.OperationContractAttribute.IsInitiating%2A>属性设置为 true。 有关更多详细信息，请参阅 <xref:System.ServiceModel.OperationContractAttribute.IsInitiating%2A>。  
  
   
  
## Examples  
 下面的示例演示了一个服务，该服务使用 <xref:System.ServiceModel.OperationContractAttribute.Action%2A> 和 <xref:System.ServiceModel.OperationContractAttribute.ReplyAction%2A> 属性显式控制输入和输出（或答复）消息的 SOAP 操作，并使用 <xref:System.ServiceModel.OperationContractAttribute.Name%2A> 属性控制元数据中操作的名称。 最后，应用程序还会使用值为“*”的 <xref:System.ServiceModel.OperationContractAttribute.Action%2A> 指示处理无法识别的消息的方法。  
  
 [!code-csharp[OperationContractAttribute_Properties#1](~/samples/snippets/csharp/VS_Snippets_CFX/operationcontractattribute_properties/cs/services.cs#1)]
 [!code-vb[OperationContractAttribute_Properties#1](~/samples/snippets/visualbasic/VS_Snippets_CFX/operationcontractattribute_properties/vb/services.vb#1)]  
  
 实现该协定的服务发送类似以下示例的消息：  
  
 [!code-csharp[OperationContractAttribute_Properties#2](~/samples/snippets/csharp/VS_Snippets_CFX/operationcontractattribute_properties/cs/services.cs#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">The value is <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="AsyncPattern">
      <MemberSignature Language="C#" Value="public bool AsyncPattern { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AsyncPattern" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.OperationContractAttribute.AsyncPattern" />
      <MemberSignature Language="VB.NET" Value="Public Property AsyncPattern As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AsyncPattern { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AsyncPattern : bool with get, set" Usage="System.ServiceModel.OperationContractAttribute.AsyncPattern" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Indicates that an operation is implemented asynchronously using a <see langword="Begin" />&lt;*methodName*&gt; and <see langword="End" />&lt;*methodName*&gt; method pair in a service contract.</summary>
        <value>
          <see langword="true" /> 如果<see langword="Begin" /> &lt;* methodName *&gt;方法匹配由<see langword="End" /> &lt;* methodName *&gt;方法和可视为通过以作为异步实现操作的基础结构在服务接口; 上的方法对否则为<see langword="false" />。 默认值为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用 <xref:System.ServiceModel.OperationContractAttribute.AsyncPattern%2A> 属性生成可在服务器和/或客户端异步调用的服务操作。 <xref:System.ServiceModel.OperationContractAttribute.AsyncPattern%2A> 属性通知运行库 `Begin` 方法有一个符合 .NET Framework 异步方法设计模式的匹配的 `End` 方法。 生成用以实现服务操作的服务器异步方法可增强服务器的可伸缩性和性能，而不会影响服务的客户端。如果服务操作在执行完可异步执行的较长操作后，必须将某些内容返回至客户端，建议使用此方法。  
  
 这不会影响客户端，因为服务器上的异步方法对是实现详细信息，该信息不会影响操作的基础 Web 服务描述语言 (WSDL) 描述。 此类方法向客户端显示为单个操作随`<input>`和关联`<output>`消息。 WCF 自动将路由到的入站的消息`Begin` \< *methodName*> 方法并将路由的结果`End` \< *methodName*> 调用到出站消息。 因此，客户端信道可将方法对表示为单个同步操作或一个异步操作对。 客户端表示形式在任何情况下都不会以任何方式影响服务器上的异步实现。  
  
 客户端协定可使用 <xref:System.ServiceModel.OperationContractAttribute.AsyncPattern%2A> 属性指示异步方法对，即客户端可使用该方法对异步调用操作。 通常情况下，客户端应用程序使用[ServiceModel 元数据实用工具 (Svcutil.exe)](~/docs/framework/wcf/servicemodel-metadata-utility-tool-svcutil-exe.md)工具和`/async`选项以生成`Begin` \< *methodName*>和`End` \< *methodName*> 客户端可以使用异步方式调用操作的方法对。  
  
> [!NOTE]
>  如果服务操作具有异步和同步两个版本，则服务上的默认行为是调用同步版本。  
  
   
  
## Examples  
 下面的代码示例演示服务协定的客户端信道，该协定包含 `Add` 的同步版本和异步版本。 如果客户端使用协定接口，则 `BeginAdd` 和 `Add` 操作都会调用服务器上可能同步也可能不同步的方法。 如果该协定用于实现服务，则默认将传入请求调度至同步方法。  
  
```csharp  
[ServiceContract]  
public interface IAddTwoNumbers  
{  
    // If the asynchronous method pair  
    // appears on the client channel, the client can call   
    // them asynchronously to prevent blocking.  
    [OperationContract (AsyncPattern=true)]  
    IAsyncResult BeginAdd(int a, int b, AsyncCallback cb, AsyncState s);  
  
    [OperationContract]  
    int EndAdd(IAsyncResult r);  
  
    // This is a synchronous version of the BeginAdd/EndAdd pair.  
    // It appears in the client channel code by default.   
    [OperationContract]  
    int Add(int a, int b);  
   }  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HasProtectionLevel">
      <MemberSignature Language="C#" Value="public bool HasProtectionLevel { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasProtectionLevel" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.OperationContractAttribute.HasProtectionLevel" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HasProtectionLevel As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool HasProtectionLevel { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.HasProtectionLevel : bool" Usage="System.ServiceModel.OperationContractAttribute.HasProtectionLevel" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value that indicates whether the messages for this operation must be encrypted, signed, or both.</summary>
        <value>如果 <see langword="true" /> 属性设置为除 <see cref="P:System.ServiceModel.OperationContractAttribute.ProtectionLevel" /> 以外的任何值，则为 <see cref="F:System.Net.Security.ProtectionLevel.None" />；否则为 <see langword="false" />。 默认值为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用 <xref:System.ServiceModel.OperationContractAttribute.HasProtectionLevel%2A> 属性确定此操作的消息是否需要特定的保护级别。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsInitiating">
      <MemberSignature Language="C#" Value="public bool IsInitiating { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsInitiating" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.OperationContractAttribute.IsInitiating" />
      <MemberSignature Language="VB.NET" Value="Public Property IsInitiating As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsInitiating { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.IsInitiating : bool with get, set" Usage="System.ServiceModel.OperationContractAttribute.IsInitiating" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a value that indicates whether the method implements an operation that can initiate a session on the server (if such a session exists).</summary>
        <value>如果允许操作启动服务器上的会话，则为 <see langword="true" />；否则为 <see langword="false" />。 默认值为 <see langword="true" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ServiceModel.OperationContractAttribute.IsInitiating%2A> 属性控制操作是否可以是创建会话时调用的第一个操作。  
  
> [!NOTE]
>  <xref:System.ServiceModel.ServiceContractAttribute.SessionMode%2A?displayProperty=nameWithType> 的值必须为 <xref:System.ServiceModel.SessionMode.Allowed> 或 <xref:System.ServiceModel.SessionMode.Required> 且使用的绑定必须要求或允许会话，<xref:System.ServiceModel.OperationContractAttribute.IsInitiating%2A> 属性才能正常工作。  
  
 默认为 `true`，这意味着操作可以是通道上调用的第一个操作。 除了调用该方法之外，后续的调用对于启动方法无效。 不会创建其他任何会话。 如果协定不使用会话，则将 <xref:System.ServiceModel.OperationContractAttribute.IsInitiating%2A> 设置为 `false` 会被忽略。  
  
 通常，将 <xref:System.ServiceModel.OperationContractAttribute.IsInitiating%2A> 设置为 `false` 可强制客户端在调用此方法之前，调用服务上的另一个方法。 例如，如果您的服务具有一系列取决于订单 ID 号的操作，可将一个 <xref:System.ServiceModel.OperationContractAttribute.IsInitiating%2A> 服务操作的 `true` 设置为 `GetOrderId`，并将所有其他的服务操作设置为 `false`。 这将确保使用由该服务公开的其他方法之前，每个新的客户端都获得一个订单 ID。  
  
> [!NOTE]
>  <xref:System.ServiceModel.OperationContractAttribute.IsInitiating%2A> 和 <xref:System.ServiceModel.OperationContractAttribute.Action%2A> 属性之间存在交互操作。 服务协定只能有一个 <xref:System.ServiceModel.OperationContractAttribute.Action%2A> 属性设置为“*”的服务操作。 承载在相同的侦听 URI 所服务类实现的服务任何的协定组可以具有多个服务操作<xref:System.ServiceModel.OperationContractAttribute.Action%2A>属性设置为"\*"时<xref:System.ServiceModel.OperationContractAttribute.IsInitiating%2A>属性设置为`false`。 但是，这些服务方法之一可以有<xref:System.ServiceModel.OperationContractAttribute.Action%2A>属性设置为"\*"和<xref:System.ServiceModel.OperationContractAttribute.IsInitiating%2A>属性设置为`true`。  
  
 如果服务收到非启动操作的消息，则该服务返回 ActionNotSupported SOAP 错误。 客户端将这种情况当作 <xref:System.ServiceModel.FaultException>。 如果客户端首先调用非启动操作，则客户端运行库会引发 <xref:System.InvalidOperationException?displayProperty=nameWithType>。  
  
 有关详细信息，请参阅[使用会话](~/docs/framework/wcf/using-sessions.md)。  
  
   
  
## Examples  
 下面的示例演示了一个服务，该服务实现指定三种方法的服务协定。 该服务需要会话。 如果调用方第一次调用的是除 `MethodOne` 以外的任何操作，则会拒绝该信道并且会引发异常。 调用方通过调用 `MethodOne` 启动会话时，可通过调用 `MethodThree` 随时终止通信会话。 在会话期间，可任意调用 `MethodTwo`。  
  
```csharp  
[ServiceContract(SessionMode=SessionMode.Required)]  
public class InitializeAndTerminateService  
{  
  [OperationContract(  
    IsOneWay=true,  
    IsInitiating=true,  
    IsTerminating=false  
  )]  
  public void MethodOne()  
  {  
    return;  
  }  
  
  [OperationContract(  
    IsInitiating=false,  
    IsTerminating=false  
  )]  
  public int MethodTwo(int x, out int y)  
  {  
    y = 34;  
    return 0;  
  }  
  
  [OperationContract(  
    IsOneWay=true,  
    IsInitiating=false,  
    IsTerminating=true  
  )]  
  public void MethodThree()  
  {  
    return;  
  }  
}  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsOneWay">
      <MemberSignature Language="C#" Value="public bool IsOneWay { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsOneWay" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.OperationContractAttribute.IsOneWay" />
      <MemberSignature Language="VB.NET" Value="Public Property IsOneWay As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsOneWay { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.IsOneWay : bool with get, set" Usage="System.ServiceModel.OperationContractAttribute.IsOneWay" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a value that indicates whether an operation returns a reply message.</summary>
        <value>如果该方法收到请求消息，但未返回任何答复消息，则为 <see langword="true" />；否则为 <see langword="false" />。 默认值为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用 <xref:System.ServiceModel.OperationContractAttribute.IsOneWay%2A> 属性指示操作不返回答复消息。 这种类型的操作对通知或事件样式通信十分有用，特别是双向通信。 如果不等待基础响应消息，则单向操作的调用方在处理请求消息时无法直接检测错误。 （使用可靠的信道和单向操作的服务应用程序可在信道级别检测消息传递失败。 有关详细信息，请参阅[可靠会话概述](~/docs/framework/wcf/feature-details/reliable-sessions-overview.md)。)  
  
 在面向双工（或双向）服务的应用程序中，客户端和服务器相互独立地通信，并且客户端信道可使用其方法中的 <xref:System.ServiceModel.OperationContractAttribute.IsOneWay%2A> 属性指示服务可单向调用客户端（该客户端可作为事件处理）。 这不会返回调用或生成消息，因为该服务不需要任何响应消息。  
  
 如果 <xref:System.ServiceModel.OperationContractAttribute.IsOneWay%2A> 属性设置为 `false`（默认值），即使返回 `void` 的方法也会生成答复消息。 在此种情况下，基础结构将创建并发送一条空消息，以向调用方指示该方法已返回内容。 （使用此方法使基础结构可以将 SOAP 错误发送回客户端。）将 <xref:System.ServiceModel.OperationContractAttribute.IsOneWay%2A> 设置为 `true` 是取消创建和调度响应消息的唯一方法。  
  
 单向方法不得返回一个值或具有 `ref` 或 `out` 参数；否则将引发 <xref:System.InvalidOperationException?displayProperty=nameWithType> 异常。  
  
 指定操作是单向操作，只表示它没有响应消息。 如果无法建立连接、出站消息非常大或该服务无法足够快地读取入站信息，则可能会阻止。 如果客户端要求非阻止调用，则会生成 <xref:System.ServiceModel.OperationContractAttribute.AsyncPattern%2A> 操作。 有关详细信息，请参阅[单向服务](~/docs/framework/wcf/feature-details/one-way-services.md)和[使用 WCF 客户端访问服务](~/docs/framework/wcf/feature-details/accessing-services-using-a-client.md)。  
  
   
  
## Examples  
 下面的示例演示了一个服务，该服务实现指定三个操作的服务协定。 其中两种方法实现双向操作，即无论返回值是什么，它们都将基础响应消息返回至调用方。 第三种方法实现一个操作，该操作接收一个调用（基础入站消息），但不返回任何基础响应消息。  
  
```csharp  
[ServiceContract]  
public class OneAndTwoWay  
{  
  // The client waits until a response message appears.  
  [OperationContract]  
  public int MethodOne (int x, out int y)  
  {  
    y = 34;  
    return 0;  
  }  
  
  // The client waits until an empty response message appears.  
  [OperationContract]  
  public void MethodTwo (int x)  
  {  
    return;  
  }  
  
  // The client returns as soon as an outbound message  
  // is queued for dispatch to the service; no response  
  // message is generated or sent.  
  [OperationContract(IsOneWay=true)]  
  public void MethodThree (int x)  
  {  
    return;  
  }  
}  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsTerminating">
      <MemberSignature Language="C#" Value="public bool IsTerminating { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsTerminating" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.OperationContractAttribute.IsTerminating" />
      <MemberSignature Language="VB.NET" Value="Public Property IsTerminating As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsTerminating { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.IsTerminating : bool with get, set" Usage="System.ServiceModel.OperationContractAttribute.IsTerminating" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a value that indicates whether the service operation causes the server to close the session after the reply message, if any, is sent.</summary>
        <value>如果该操作会导致服务器关闭会话，则为 <see langword="true" />；否则为 <see langword="false" />。 默认值为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用 <xref:System.ServiceModel.OperationContractAttribute.IsTerminating%2A> 属性指示调用服务操作可终止通信会话。  
  
 在客户端应用程序，值为<xref:System.ServiceModel.OperationContractAttribute.IsTerminating%2A>设置为`true`指示 WCF 在答复到达后，关闭信道。  
  
 在服务中，如果客户端在该期间内不关闭信道，则将会设置计时器并中止信道。  
  
 有关使用此属性的会话的详细信息，请参阅[使用会话](~/docs/framework/wcf/using-sessions.md)。  
  
> [!NOTE]
>  如果调用方侦听的是 <xref:System.ServiceModel.OperationContext.OperationCompleted?displayProperty=nameWithType> 操作的 <xref:System.ServiceModel.OperationContractAttribute.IsTerminating%2A?displayProperty=nameWithType> 事件，则在收到响应时可能会阻塞。 处理这种情况的正确方法是，当引发 <xref:System.ServiceModel.OperationContext.OperationCompleted> 时在其他线程上调度工作，然后从该事件处理程序立即返回。  
  
   
  
## Examples  
 下面的示例演示了一个服务，该服务实现指定三个操作的服务协定。 该服务需要有状态连接。 如果调用方第一次调用的是除 `MethodOne` 以外的任何操作，则会拒绝该信道并且会引发异常。 调用方通过调用 `MethodOne` 启动会话时，可通过调用 `MethodThree` 随时终止通信会话。 在会话期间，可任意调用 `MethodTwo`。  
  
```csharp  
[ServiceContractAttribute(SessionMode=SessionMode.Required)]  
public class InitializeAndTerminateService  
{  
  [OperationContract(  
    IsOneWay=true,  
    IsInitiating=true,  
    IsTerminating=false  
  )]  
  public void MethodOne()  
  {  
    return;  
  }  
  
  [OperationContract(  
    IsInitiating=false,  
    IsTerminating=false  
  )]  
  public int MethodTwo(int x, out int y)  
  {  
    y = 34;  
    return 0;  
  }  
  
  [OperationContract(  
    IsOneWay=true,  
    IsInitiating=false  
    IsTerminating=true  
  )]  
  public void MethodThree()  
  {  
    return;  
  }  
}  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public string Name { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.OperationContractAttribute.Name" />
      <MemberSignature Language="VB.NET" Value="Public Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Name { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Name : string with get, set" Usage="System.ServiceModel.OperationContractAttribute.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the name of the operation.</summary>
        <value>操作的名称。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用<xref:System.ServiceModel.OperationContractAttribute.Name%2A>属性来重写 <`operation`> WSDL 中的元素名称。 默认的操作名称为实现方法的名称。  
  
   
  
## Examples  
 下面的代码示例使用 <xref:System.ServiceModel.OperationContractAttribute.Name%2A> 属性声明在元数据中公开的操作名称。  
  
 [!code-csharp[OperationContractAttribute_Properties#1](~/samples/snippets/csharp/VS_Snippets_CFX/operationcontractattribute_properties/cs/services.cs#1)]
 [!code-vb[OperationContractAttribute_Properties#1](~/samples/snippets/visualbasic/VS_Snippets_CFX/operationcontractattribute_properties/vb/services.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <see cref="P:System.ServiceModel.OperationContractAttribute.Name" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">The value is an empty string.</exception>
      </Docs>
    </Member>
    <Member MemberName="ProtectionLevel">
      <MemberSignature Language="C#" Value="public System.Net.Security.ProtectionLevel ProtectionLevel { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Net.Security.ProtectionLevel ProtectionLevel" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.OperationContractAttribute.ProtectionLevel" />
      <MemberSignature Language="VB.NET" Value="Public Property ProtectionLevel As ProtectionLevel" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::Security::ProtectionLevel ProtectionLevel { System::Net::Security::ProtectionLevel get(); void set(System::Net::Security::ProtectionLevel value); };" />
      <MemberSignature Language="F#" Value="member this.ProtectionLevel : System.Net.Security.ProtectionLevel with get, set" Usage="System.ServiceModel.OperationContractAttribute.ProtectionLevel" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Security.ProtectionLevel</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a value that specifies whether the messages of an operation must be encrypted, signed, or both.</summary>
        <value>
          <see cref="T:System.Net.Security.ProtectionLevel" /> 值之一。 默认值为 <see cref="F:System.Net.Security.ProtectionLevel.None" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用 <xref:System.ServiceModel.OperationContractAttribute.ProtectionLevel%2A> 属性控制是否必须对操作消息进行加密和/或签名。 除非较窄范围重写此处设置的值，否则此值是为此操作指定的所有消息的默认值。  
  
 请记住，运行时的保护行为是在下列属性中设置的保护级别值的组合，这一点很重要。 这些属性具有层次结构。 除非已为较窄范围显式设置了某个不同的值，否则设置最外层的值将为所有较窄的范围确定默认设置。 在这种情况下，外层的值将保持所有较窄的范围的默认设置，但特定的设置除外。  
  
 例如，如果将 <xref:System.ServiceModel.ServiceContractAttribute.ProtectionLevel%2A?displayProperty=nameWithType> 设置为 <xref:System.Net.Security.ProtectionLevel.EncryptAndSign?displayProperty=nameWithType>，并且其他较窄范围都没有设置保护级别，则会对操作协定中的所有消息进行加密和签名。 但是，如果其中一个操作将 <xref:System.ServiceModel.OperationContractAttribute.ProtectionLevel%2A> 设置为 <xref:System.Net.Security.ProtectionLevel.Sign?displayProperty=nameWithType>，那么只会对此操作的消息进行签名，而对协定中的所有其他消息进行加密和签名。  
  
 有关保护级别及其假设和范围的详细信息，请参阅[了解保护级别](~/docs/framework/wcf/understanding-protection-level.md)。  
  
 这些值的设置范围是：  
  
 <xref:System.ServiceModel.ServiceContractAttribute.ProtectionLevel%2A?displayProperty=nameWithType>  
  
 <xref:System.ServiceModel.OperationContractAttribute.ProtectionLevel%2A?displayProperty=nameWithType>  
  
 <xref:System.ServiceModel.FaultContractAttribute.ProtectionLevel%2A?displayProperty=nameWithType>  
  
 <xref:System.ServiceModel.MessageContractAttribute.ProtectionLevel%2A?displayProperty=nameWithType>  
  
 <xref:System.ServiceModel.MessageContractMemberAttribute.ProtectionLevel%2A?displayProperty=nameWithType> 上的 <xref:System.ServiceModel.MessageHeaderAttribute?displayProperty=nameWithType> 属性。  
  
 <xref:System.ServiceModel.MessageContractMemberAttribute.ProtectionLevel%2A?displayProperty=nameWithType> 上的 <xref:System.ServiceModel.MessageBodyMemberAttribute?displayProperty=nameWithType> 属性。  
  
 当协定上没有显式指定保护级别并且基础绑定支持安全性时（无论处于传输级别还是处于消息级别），整个协定的有效保护级别将为 <xref:System.Net.Security.ProtectionLevel.EncryptAndSign?displayProperty=nameWithType>。 如果绑定不支持安全性（如 <xref:System.ServiceModel.BasicHttpBinding>），则整个协定的有效 <xref:System.Net.Security.ProtectionLevel?displayProperty=nameWithType> 为 <xref:System.Net.Security.ProtectionLevel.None?displayProperty=nameWithType>。 因此，根据终结点绑定，即使协定指定了 <xref:System.Net.Security.ProtectionLevel.None?displayProperty=nameWithType>，客户端也可以要求不同的消息或传输级别安全保护。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">The value is not one of the <see cref="T:System.Net.Security.ProtectionLevel" /> values.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReplyAction">
      <MemberSignature Language="C#" Value="public string ReplyAction { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ReplyAction" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.OperationContractAttribute.ReplyAction" />
      <MemberSignature Language="VB.NET" Value="Public Property ReplyAction As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ReplyAction { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ReplyAction : string with get, set" Usage="System.ServiceModel.OperationContractAttribute.ReplyAction" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the value of the SOAP action for the reply message of the operation.</summary>
        <value>用于答复消息的 SOAP 操作的值。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 除指定答复消息操作标头的特定值以外，还可以指定字符串“*”（星号）。 在服务中指定星号可指示 WCF 不能添加到消息中，如果你直接对编程消息会十分有用的答复操作。 客户端应用程序中指定星号可指示 WCF 不验证答复操作。  
  
   
  
## Examples  
 下面的示例演示了一个服务，该服务使用 <xref:System.ServiceModel.OperationContractAttribute.Action%2A> 和 <xref:System.ServiceModel.OperationContractAttribute.ReplyAction%2A> 属性显式控制输入和输出（或答复）消息的 SOAP 操作。 它还使用 <xref:System.ServiceModel.OperationContractAttribute.Name%2A> 属性声明在元数据中公开的操作名称。  
  
 [!code-csharp[OperationContractAttribute_Properties#1](~/samples/snippets/csharp/VS_Snippets_CFX/operationcontractattribute_properties/cs/services.cs#1)]
 [!code-vb[OperationContractAttribute_Properties#1](~/samples/snippets/visualbasic/VS_Snippets_CFX/operationcontractattribute_properties/vb/services.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <see cref="P:System.ServiceModel.OperationContractAttribute.ReplyAction" /> is <see langword="null" />.</exception>
      </Docs>
    </Member>
  </Members>
</Type>