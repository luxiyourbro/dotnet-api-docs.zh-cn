<Type Name="StringBuilder" FullName="System.Text.StringBuilder">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="68ced1dc453efaf4e152c451e7c5446f89d298fc" />
    <Meta Name="ms.sourcegitcommit" Value="434f60616a9793fa8436744549fc856e94f7a648" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-CN" />
    <Meta Name="ms.lasthandoff" Value="08/25/2018" />
    <Meta Name="ms.locfileid" Value="39998808" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class StringBuilder : System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi serializable sealed beforefieldinit StringBuilder extends System.Object implements class System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="DocId" Value="T:System.Text.StringBuilder" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class StringBuilder&#xA;Implements ISerializable" />
  <TypeSignature Language="C++ CLI" Value="public ref class StringBuilder sealed : System::Runtime::Serialization::ISerializable" />
  <TypeSignature Language="F#" Value="type StringBuilder = class&#xA;    interface ISerializable" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.ISerializable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>表示可变字符字符串。 此类不能被继承。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此类表示其值是可变的字符序列的类似字符串的对象。  
  
 本节内容：  
  
-   [字符串和 StringBuilder 类型](#StringAndSB)  
  
-   [StringBuilder 的工作原理](#HowWorks)  
  
-   [内存分配](#Memory)  
  
-   [实例化 StringBuilder 对象](#Instantiating)  
  
-   [调用 StringBuilder 方法](#Calling)  
  
-   [执行 StringBuilder 操作](#Operations)  
  
    -   [循环访问 StringBuilder 字符](#Iterating)  
  
    -   [将文本添加到 StringBuilder 对象](#Adding)  
  
    -   [从 StringBuilder 对象中删除文本](#Deleting)  
  
    -   [修改 StringBuilder 对象中的文本](#Modifying)  
  
-   [StringBuilder 对象中搜索的文本](#Searching)  
  
-   [将 StringBuilder 对象转换为字符串](#Converting)  
  
<a name="StringAndSB"></a>   
## <a name="the-string-and-stringbuilder-types"></a>字符串和 StringBuilder 类型  
 尽管<xref:System.Text.StringBuilder>和<xref:System.String>二者都表示序列的字符，它们的实现方式有所不同。 <xref:System.String> 是不可变类型。 也就是说，每个操作，它可修改<xref:System.String>对象实际上会创建一个新的字符串。  
  
 例如，在调用<xref:System.String.Concat%2A?displayProperty=nameWithType>方法在下面的 C# 示例显示名为的字符串变量的值更改`value`。 事实上，<xref:System.String.Concat%2A>方法将返回`value`对象具有不同的值和从地址`value`传递给方法的对象。 请注意，必须使用编译该示例`/unsafe`编译器选项。  
  
 [!code-csharp[System.Text.StringBuilder.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/immutability2.cs#1)]  
  
 对于执行广泛的字符串操作 （例如修改在循环中多次的字符串的应用） 的例程，重复修改字符串可以精确对显著的性能产生负面影响。 替代方法是使用<xref:System.Text.StringBuilder>，它是一个可变字符串类。 可变性意味着，一旦创建类的实例后，它可以修改通过追加、 删除、 替换或插入字符。 一个<xref:System.Text.StringBuilder>对象维护一个缓冲区以容纳扩展到字符串。 新数据追加到缓冲区，如果空间不可用;否则为分配新的、 更大的缓冲区、 原始缓冲区中的数据复制到新的缓冲区，并随后会将新数据追加到新的缓冲区。  
  
> [!IMPORTANT]
>  尽管<xref:System.Text.StringBuilder>类通常提供更好的性能比<xref:System.String>类，您应该不会自动替换<xref:System.String>与<xref:System.Text.StringBuilder>每当你想要操作的字符串。 性能取决于字符串，并将其分配新字符串、 执行您的应用程序的系统和操作的类型的内存量的大小。 您应该准备好测试应用程序以确定是否<xref:System.Text.StringBuilder>实际上提供了显著改善性能。  
  
 请考虑使用<xref:System.String>类在这些情况下：  
  
-   当您的应用程序将对字符串进行的更改数很小。 在这些情况下，<xref:System.Text.StringBuilder>可能可以忽略不计的产品/服务或对任何性能改进<xref:System.String>。  
  
-   当正在执行固定的数量的串联操作中，尤其是对于字符串文本。 在这种情况下，编译器可能将合并到单个操作的串联操作。  
  
-   当必须执行广泛的搜索操作时要构建您的字符串。 <xref:System.Text.StringBuilder>类缺少搜索方法，如`IndexOf`或`StartsWith`。 您必须将转换<xref:System.Text.StringBuilder>对象传递给<xref:System.String>为这些操作，这可以抵消性能受益于使用<xref:System.Text.StringBuilder>。 有关详细信息，请参阅[StringBuilder 对象中搜索的文本](#Searching)部分。  
  
 请考虑使用<xref:System.Text.StringBuilder>类在这些情况下：  
  
-   如果期望您的应用程序在设计时 （例如，在使用一个循环来连接包含用户输入的字符串的随机数字时） 对字符串进行的更改数未知。  
  
-   当您希望对字符串进行大量更改您的应用程序。  
  
<a name="HowWorks"></a>   
## <a name="how-stringbuilder-works"></a>StringBuilder 的工作原理  
 <xref:System.Text.StringBuilder.Length%2A?displayProperty=nameWithType>属性指示的字符数<xref:System.Text.StringBuilder>当前包含的对象。 如果您添加到字符<xref:System.Text.StringBuilder>对象，直至等于的大小，其长度增加<xref:System.Text.StringBuilder.Capacity%2A?displayProperty=nameWithType>属性，定义的对象可包含的字符数。 如果添加了字符数导致的长度<xref:System.Text.StringBuilder>对象超过其当前容量、 新的内存分配，值<xref:System.Text.StringBuilder.Capacity%2A>加倍属性时，新的字符添加到<xref:System.Text.StringBuilder>对象，并且其<xref:System.Text.StringBuilder.Length%2A>调整属性。 额外的内存<xref:System.Text.StringBuilder>直到它达到定义的值动态分配对象<xref:System.Text.StringBuilder.MaxCapacity%2A?displayProperty=nameWithType>属性。 当达到最大容量时，可以为分配任何进一步的内存<xref:System.Text.StringBuilder>对象，并尝试添加字符或扩展到超过其最大容量引发任一<xref:System.ArgumentOutOfRangeException>或<xref:System.OutOfMemoryException>异常。  
  
 下面的示例演示如何<xref:System.Text.StringBuilder>对象分配新内存，并动态地增加其容量，随着分配给该对象的字符串的扩展。 该代码会创建<xref:System.Text.StringBuilder>对象通过调用其默认 （无参数） 构造函数。 此对象的默认容量为 16 个字符，其最大容量为超过 20 亿个字符。 将字符串追加"这一个句子"。 导致新的内存分配，因为字符串长度 （19 个字符） 超过默认容量<xref:System.Text.StringBuilder>对象。 对象的容量加倍为 32 个字符、 添加新字符串，并且对象的长度现在等于 19 个字符。 代码然后将字符串追加"这是其他句子"。 值<xref:System.Text.StringBuilder>对象 11 次。 每当追加操作导致的长度<xref:System.Text.StringBuilder>对象超出其容量，其现有的容量增加一倍和<xref:System.Text.StringBuilder.Append%2A>操作成功。  
  
 [!code-csharp[System.Text.StringBuilder.Class#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/default1.cs#3)]
 [!code-vb[System.Text.StringBuilder.Class#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/default1.vb#3)]  
  
<a name="Memory"></a>   
## <a name="memory-allocation"></a>内存分配  
 默认容量<xref:System.Text.StringBuilder>对象是 16 个字符，其默认最大容量是<xref:System.Int32.MaxValue?displayProperty=nameWithType>。 如果调用使用这些默认值<xref:System.Text.StringBuilder.%23ctor>和<xref:System.Text.StringBuilder.%23ctor%28System.String%29>构造函数。  
  
 您可以显式定义的初始容量<xref:System.Text.StringBuilder>对象中的以下方法：  
  
-   通过调用任一<xref:System.Text.StringBuilder>构造函数包含`capacity`参数创建对象时。  
  
-   通过显式分配到一个新值<xref:System.Text.StringBuilder.Capacity%2A?displayProperty=nameWithType>要扩展的现有属性<xref:System.Text.StringBuilder>对象。 请注意，该属性将引发异常的新容量是否小于现有容量或大于<xref:System.Text.StringBuilder>对象的最大容量。  
  
-   通过调用<xref:System.Text.StringBuilder.EnsureCapacity%2A?displayProperty=nameWithType>方法为新容量。 新的容量不能大于<xref:System.Text.StringBuilder>对象的最大容量。 但是，与分配到不同<xref:System.Text.StringBuilder.Capacity%2A>属性，<xref:System.Text.StringBuilder.EnsureCapacity%2A>不会引发异常，如果所需的新容量小于现有容量; 在这种情况下，该方法调用不起作用。  
  
 如果字符串的长度分配给<xref:System.Text.StringBuilder>构造函数调用中的对象超过默认的容量或指定的容量<xref:System.Text.StringBuilder.Capacity%2A>属性设置为与指定的字符串的长度`value`参数。  
  
 您可以显式定义的最大容量<xref:System.Text.StringBuilder>对象通过调用<xref:System.Text.StringBuilder.%23ctor%28System.Int32%2CSystem.Int32%29>构造函数。 不能通过将分配到一个新值更改的最大容量<xref:System.Text.StringBuilder.MaxCapacity%2A>属性，因为它是只读的。  
  
 如上一节所示，只要现有容量是不足、 其他内存分配的和容量<xref:System.Text.StringBuilder>对象定义的值为双精度型值<xref:System.Text.StringBuilder.MaxCapacity%2A>属性。  
  
 一般情况下，默认的容量和最大容量就足够了对于大多数应用程序。 您可以考虑设置在以下情况下的这些值：  
  
-   如果最终大小的<xref:System.Text.StringBuilder>对象很可能变得非常大，通常超过几兆字节。 在这种情况下，可能有一些性能受益于设置初始<xref:System.Text.StringBuilder.Capacity%2A>为非常高的值，以消除了过多内存重新分配需要的属性。  
  
-   如果您的应用程序具有有限的内存的系统上运行。 在这种情况下，可能想要设置，请考虑<xref:System.Text.StringBuilder.MaxCapacity%2A>属性设置为小于<xref:System.Int32.MaxValue?displayProperty=nameWithType>如果您的应用程序处理可能导致其在内存受限的环境中执行的大型字符串。  
  
<a name="Instantiating"></a>   
## <a name="instantiating-a-stringbuilder-object"></a>实例化 StringBuilder 对象  
 实例化<xref:System.Text.StringBuilder>对象通过调用其六个的重载的类构造下, 表列出了这些函数之一。 三个构造函数实例化<xref:System.Text.StringBuilder>对象，其值为空字符串，但设置其<xref:System.Text.StringBuilder.Capacity%2A>和<xref:System.Text.StringBuilder.MaxCapacity%2A>值以不同的方式。 剩余的三个构造函数定义<xref:System.Text.StringBuilder>具有特定的字符串值和容量的对象。 两个三个构造函数使用的默认最大容量<xref:System.Int32.MaxValue?displayProperty=nameWithType>，而第三个可用于设置最大容量。  
  
|构造函数|字符串值|容量|最大容量|  
|-----------------|------------------|--------------|----------------------|  
|<xref:System.Text.StringBuilder.%23ctor>|<xref:System.String.Empty?displayProperty=nameWithType>|16|<xref:System.Int32.MaxValue?displayProperty=nameWithType>|  
|<xref:System.Text.StringBuilder.%23ctor%28System.Int32%29>|<xref:System.String.Empty?displayProperty=nameWithType>|通过定义`capacity`参数|<xref:System.Int32.MaxValue?displayProperty=nameWithType>|  
|<xref:System.Text.StringBuilder.%23ctor%28System.Int32%2CSystem.Int32%29>|<xref:System.String.Empty?displayProperty=nameWithType>|通过定义`capacity`参数|通过定义`maxCapacity`参数|  
|<xref:System.Text.StringBuilder.%23ctor%28System.String%29>|通过定义`value`参数|16 或`value`。 <xref:System.String.Length%2A>更多|<xref:System.Int32.MaxValue?displayProperty=nameWithType>|  
|<xref:System.Text.StringBuilder.%23ctor%28System.String%2CSystem.Int32%29>|通过定义`value`参数|定义由`capacity`参数或`value`。 <xref:System.String.Length%2A>两者中较大。|<xref:System.Int32.MaxValue?displayProperty=nameWithType>|  
|<xref:System.Text.StringBuilder.%23ctor%28System.String%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%29>|通过定义`value`。 <xref:System.String.Substring%2A>(`startIndex`, `length`)|定义由`capacity`参数或`value`。 <xref:System.String.Length%2A>两者中较大。|通过定义`maxCapacity`参数|  
  
 下面的示例使用三个构造函数重载来实例化<xref:System.Text.StringBuilder>对象。  
  
 [!code-csharp[System.Text.StringBuilder.Class#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/instantiate1.cs#6)]
 [!code-vb[System.Text.StringBuilder.Class#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/instantiate1.vb#6)]  
  
<a name="Calling"></a>   
## <a name="calling-stringbuilder-methods"></a>调用 StringBuilder 方法  
 在修改字符串的方法的大多数<xref:System.Text.StringBuilder>实例返回到该同一实例的引用。 这使您可以调用<xref:System.Text.StringBuilder>两种方法中的方法：  
  
-   可以进行单个方法调用，并忽略返回值，如以下示例所示。  
  
     [!code-csharp[System.Text.StringBuilder.Class#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/call1.cs#4)]
     [!code-vb[System.Text.StringBuilder.Class#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/call1.vb#4)]  
  
-   单个语句中，可以进行一系列方法调用。 这会非常方便，如果你想要编写用于链接在连续的操作的单个语句。 下面的示例将上一示例中的三个方法调用合并到一行代码。  
  
     [!code-csharp[System.Text.StringBuilder.Class#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/call2.cs#5)]
     [!code-vb[System.Text.StringBuilder.Class#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/call2.vb#5)]  
  
<a name="Operations"></a>   
## <a name="performing-stringbuilder-operations"></a>执行 StringBuilder 操作  
 可以使用的方法<xref:System.Text.StringBuilder>类来循环访问、 添加、 删除或修改中的字符<xref:System.Text.StringBuilder>对象。  
  
<a name="Iterating"></a>   
### <a name="iterating-stringbuilder-characters"></a>循环访问 StringBuilder 字符  
 您可以访问中的字符<xref:System.Text.StringBuilder>对象使用<xref:System.Text.StringBuilder.Chars%2A?displayProperty=nameWithType>属性。 在 C# 中，<xref:System.Text.StringBuilder.Chars%2A>是一个索引器; 在 Visual Basic 中，它是默认属性的<xref:System.Text.StringBuilder>类。 这使您可以设置或检索个别字符使用它们的索引，而无需显式引用<xref:System.Text.StringBuilder.Chars%2A>属性。 中的字符<xref:System.Text.StringBuilder>对象从索引 0 （零） 开始，继续索引<xref:System.Text.StringBuilder.Length%2A>-1。  
  
 下面的示例演示<xref:System.Text.StringBuilder.Chars%2A>属性。 将追加到 10 个随机数字<xref:System.Text.StringBuilder>对象，然后循环访问每个字符。 如果该字符的 Unicode 类别是<xref:System.Globalization.UnicodeCategory.DecimalDigitNumber?displayProperty=nameWithType>，它按 1 递减数 （或如果其值为 0 的数字更改为 9）。 该示例显示的内容<xref:System.Text.StringBuilder>对象同时之前和之后的单个字符的值已更改。  
  
 [!code-csharp[System.Text.StringBuilder.Class#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/chars1.cs#7)]
 [!code-vb[System.Text.StringBuilder.Class#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/chars1.vb#7)]  

[!INCLUDE[stringbuilder-performance-note](~/includes/stringbuilder-perf-note.md)]
  
<a name="Adding"></a>   
### <a name="adding-text-to-a-stringbuilder-object"></a>将文本添加到 StringBuilder 对象  
 <xref:System.Text.StringBuilder>类包括以下方法来扩展的内容<xref:System.Text.StringBuilder>对象：  
  
-   <xref:System.Text.StringBuilder.Append%2A>方法将追加字符串、 一个子字符串、 字符数组、 字符数组的一部分的单个字符重复多次，或的字符串表示形式的基元数据类型更改为<xref:System.Text.StringBuilder>对象。  
  
-   <xref:System.Text.StringBuilder.AppendLine%2A>方法将行终止符或行终止符字符串追加<xref:System.Text.StringBuilder>对象。  
  
-   <xref:System.Text.StringBuilder.AppendFormat%2A>方法将追加到<xref:System.Text.StringBuilder>对象。 字符串表示形式的结果字符串中包含的对象可以反映当前系统区域性或指定的区域性的格式设置约定。  
  
-   <xref:System.Text.StringBuilder.Insert%2A>方法插入一个字符串，子字符串，字符串的多个重复的字符数组、 字符数组的部分或基元数据的字符串表示形式中指定位置处键入<xref:System.Text.StringBuilder>对象。 按从零开始的索引定义位置。  
  
 下面的示例使用<xref:System.Text.StringBuilder.Append%2A>， <xref:System.Text.StringBuilder.AppendLine%2A>， <xref:System.Text.StringBuilder.AppendFormat%2A>，和<xref:System.Text.StringBuilder.Insert%2A>方法以展开的文本<xref:System.Text.StringBuilder>对象。  
  
 [!code-csharp[System.Text.StringBuilder.Class#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/expand1.cs#9)]
 [!code-vb[System.Text.StringBuilder.Class#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/expand1.vb#9)]  
  
<a name="Deleting"></a>   
### <a name="deleting-text-from-a-stringbuilder-object"></a>从 StringBuilder 对象中删除文本  
 <xref:System.Text.StringBuilder>类包括可以减少的当前大小的方法<xref:System.Text.StringBuilder>实例。 <xref:System.Text.StringBuilder.Clear%2A>方法中删除所有字符，并设置<xref:System.Text.StringBuilder.Length%2A>属性设置为零。 <xref:System.Text.StringBuilder.Remove%2A>方法中删除指定的数量的特定索引位置开始的字符。 此外，从末尾删除字符<xref:System.Text.StringBuilder>对象通过设置其<xref:System.Text.StringBuilder.Length%2A>属性的值小于当前实例的长度。  
  
 以下示例将删除的某些从文本<xref:System.Text.StringBuilder>对象，显示其生成的容量、 最大容量和长度属性值，然后调用<xref:System.Text.StringBuilder.Clear%2A>方法来删除中的所有字符<xref:System.Text.StringBuilder>对象。  
  
 [!code-csharp[System.Text.StringBuilder.Class#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/delete1.cs#10)]
 [!code-vb[System.Text.StringBuilder.Class#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/delete1.vb#10)]  
  
<a name="Modifying"></a>   
### <a name="modifying-the-text-in-a-stringbuilder-object"></a>修改 StringBuilder 对象中的文本  
 <xref:System.Text.StringBuilder.Replace%2A?displayProperty=nameWithType>方法替换所有出现的字符或字符串中整个<xref:System.Text.StringBuilder>对象或在特定的字符范围内。 下面的示例使用<xref:System.Text.StringBuilder.Replace%2A>方法中使用问号 （？） 替换所有感叹号 （！）<xref:System.Text.StringBuilder>对象。  
  
 [!code-csharp[System.Text.StringBuilder.Class#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/replace1.cs#11)]
 [!code-vb[System.Text.StringBuilder.Class#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/replace1.vb#11)]  
  
<a name="Searching"></a>   
## <a name="searching-the-text-in-a-stringbuilder-object"></a>StringBuilder 对象中搜索的文本  
 <xref:System.Text.StringBuilder>类不包括方法类似于<xref:System.String.Contains%2A?displayProperty=nameWithType>， <xref:System.String.IndexOf%2A?displayProperty=nameWithType>，和<xref:System.String.StartsWith%2A?displayProperty=nameWithType>提供的方法<xref:System.String>类，该类，您可以搜索特定字符或子字符串的对象。 确定是否存在或启动的子字符串的字符位置需要您搜索<xref:System.String>使用字符串搜索方法或正则表达式方法的值。 有四种方法来实现此类搜索，如下表所示。  
  
|技术|专业人员|缺点|  
|---------------|----------|----------|  
|将它们添加到之前搜索的字符串值<xref:System.Text.StringBuilder>对象。|可用于确定是否存在某个子字符串。|不能使用子字符串的索引位置很重要。|  
|调用<xref:System.Text.StringBuilder.ToString%2A>并搜索返回<xref:System.String>对象。|易于使用如果分配到的所有文本<xref:System.Text.StringBuilder>对象，并开始对其进行修改。|重复调用不便于<xref:System.Text.StringBuilder.ToString%2A>如果您必须进行修改的所有文本都添加到之前<xref:System.Text.StringBuilder>对象。<br /><br /> 您必须记得从末尾<xref:System.Text.StringBuilder>对象的文本，如果您要做的更改。|  
|使用<xref:System.Text.StringBuilder.Chars%2A>属性按顺序搜索的字符范围。|如果您关心的单个字符或小的子字符串，这很有用。|如果要搜索的字符数较大，或者搜索逻辑很复杂繁琐。<br /><br />已变得非常大而通过重复进行方法调用的对象的性能非常不佳的结果。  |  
|将转换<xref:System.Text.StringBuilder>对象传递给<xref:System.String>对象，并在执行修改<xref:System.String>对象。|如果修改的数量较少时很有用。|求反的性能优势<xref:System.Text.StringBuilder>类如果的修改量很大。|  
  
 让我们看一下中更详细地介绍这些技术。  
  
-   如果搜索的目标是确定是否存在某个特定的子字符串的 （即，如果您不感兴趣子字符串的位置），可以搜索字符串之前将它们存储在<xref:System.Text.StringBuilder>对象。 下面的示例提供了一种可能实现。 它定义`StringBuilderFinder`类的构造函数传递的引用<xref:System.Text.StringBuilder>对象和要在字符串中找到的子字符串。 在这种情况下，此示例尝试确定是否记录的温度华氏或摄氏温度，并将相应的介绍性文本添加到的开头<xref:System.Text.StringBuilder>对象。 随机数生成器用于选择包含摄氏度或华氏度中的数据的数组。  
  
     [!code-csharp[System.Text.StringBuilder.Class#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/pattern1.cs#12)]
     [!code-vb[System.Text.StringBuilder.Class#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/pattern1.vb#12)]  
  
-   调用<xref:System.Text.StringBuilder.ToString%2A?displayProperty=nameWithType>方法将转换<xref:System.Text.StringBuilder>对象传递给<xref:System.String>对象。 可以使用类似于方法搜索字符串<xref:System.String.LastIndexOf%2A?displayProperty=nameWithType>或<xref:System.String.StartsWith%2A?displayProperty=nameWithType>，也可以使用正则表达式和<xref:System.Text.RegularExpressions.Regex>类来搜索的模式。 因为这两<xref:System.Text.StringBuilder>和<xref:System.String>对象使用 utf-16 编码用于存储字符，子字符串的索引位置的字符和正则表达式匹配项是在这两个对象相同。 这使您可以使用<xref:System.Text.StringBuilder>方法，以便可以在同一位置中找到该文本的更改<xref:System.String>对象。  
  
    > [!NOTE]
    >  如果采用这种方法，你应从结尾处起作用<xref:System.Text.StringBuilder>对象到其开始，因此无需重复转换<xref:System.Text.StringBuilder>为字符串的对象。  
  
     下面的示例阐释了这种方法。 它将存储在英语字母表中的每个字母的四个匹配项<xref:System.Text.StringBuilder>对象。 然后将转换为文本<xref:System.String>对象，并使用正则表达式来标识每个四个字符序列的起始位置。 最后，它将添加下划线前除第一个序列，每个四个字符序列，并将转换为大写的序列的第一个字符。  
  
     [!code-csharp[System.Text.StringBuilder.Class#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/pattern2.cs#13)]
     [!code-vb[System.Text.StringBuilder.Class#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/pattern2.vb#13)]  
  
-   使用<xref:System.Text.StringBuilder.Chars%2A?displayProperty=nameWithType>属性按顺序搜索中的字符范围<xref:System.Text.StringBuilder>对象。 如果要在其中搜索的字符数很大或搜索逻辑是特别复杂，这种方法可能不可行。 逐字符基于索引的访问对性能产生影响非常大，chunked<xref:System.Text.StringBuilder>对象，请参阅的文档<xref:System.Text.StringBuilder.Chars%2A?displayProperty=nameWithType>属性。 
  
     下面的示例在功能上与前面的示例相同，但在实现中不同。 它使用<xref:System.Text.StringBuilder.Chars%2A>属性来检测何时更改字符值，将在该位置处插入下划线，并将新序列中的第一个字符转换为大写。  
  
     [!code-csharp[System.Text.StringBuilder.Class#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/pattern3.cs#14)]
     [!code-vb[System.Text.StringBuilder.Class#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/pattern3.vb#14)]  
  
-   存储中的所有未修改的文本<xref:System.Text.StringBuilder>对象，请调用<xref:System.Text.StringBuilder.ToString%2A?displayProperty=nameWithType>方法将转换<xref:System.Text.StringBuilder>对象传递给<xref:System.String>对象，并执行上所做的修改<xref:System.String>对象。 如果您有仅几个修改; 可以使用此方法否则，使用不可变的字符串的成本可能会抵消使用的性能好处<xref:System.Text.StringBuilder>对象。  
  
     下面的示例是在功能上与前两个示例相同，但在实现中不同。 它会创建<xref:System.Text.StringBuilder>对象，将其转换为<xref:System.String>对象，然后再使用正则表达式对字符串执行剩余的所有修改。 <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.MatchEvaluator%29?displayProperty=nameWithType>方法使用 lambda 表达式，对每个匹配项执行替换。  
  
     [!code-csharp[System.Text.StringBuilder.Class#15](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/pattern4.cs#15)]
     [!code-vb[System.Text.StringBuilder.Class#15](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/pattern4.vb#15)]  
  
<a name="Converting"></a>   
## <a name="converting-the-stringbuilder-object-to-a-string"></a>将 StringBuilder 对象转换为字符串  
 必须先将 <xref:System.Text.StringBuilder> 对象转换为 <xref:System.String> 对象，然后才能将 <xref:System.Text.StringBuilder> 对象表示的字符串传递给包含 <xref:System.String> 参数的方法，或在用户界面中显示它。 通过调用来执行此转换<xref:System.Text.StringBuilder.ToString%2A?displayProperty=nameWithType>方法。 有关说明，请参阅上述示例中，后者调用<xref:System.Text.StringBuilder.ToString%2A>方法将<xref:System.Text.StringBuilder>对象为字符串，以便它可以传递到正则表达式方法。  
  
   
  
## Examples  
 下面的示例演示如何调用定义的方法的许多<xref:System.Text.StringBuilder>类。  
  
 [!code-cpp[StringBuilder#1](~/samples/snippets/cpp/VS_Snippets_CLR/StringBuilder/cpp/StringBuilder.cpp#1)]
 [!code-csharp[StringBuilder#1](~/samples/snippets/csharp/VS_Snippets_CLR/StringBuilder/CS/StringBuilder.cs#1)]
 [!code-vb[StringBuilder#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/StringBuilder/VB/StringBuilder.vb#1)]  
  
 ]]></format>
    </remarks>
    <block subset="none" type="usage">
      <para>中[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]和[!INCLUDE[net_v45](~/includes/net-v45-md.md)]，当您实例化<see cref="T:System.Text.StringBuilder" />对象通过调用<see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" />构造函数，长度和容量<see cref="T:System.Text.StringBuilder" />实例可以增长到的值超过其<see cref="P:System.Text.StringBuilder.MaxCapacity" />属性。发生这种情况尤其是当您调用<see cref="M:System.Text.StringBuilder.Append(System.String)" />和<see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" />追加小型字符串的方法。</para>
    </block>
    <altmember cref="T:System.String" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>初始化 <see cref="T:System.Text.StringBuilder" /> 类的新实例。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StringBuilder ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; StringBuilder();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>初始化 <see cref="T:System.Text.StringBuilder" /> 类的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此实例的字符串值设置为<xref:System.String.Empty?displayProperty=nameWithType>，和容量设置为特定于实现的默认容量。  
  
   
  
## Examples  
 下面的示例演示如何调用<xref:System.Text.StringBuilder.%23ctor%2A>不带任何参数的构造函数。  
  
 [!code-cpp[System.Text.StringBuilder.Constructors#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CPP/constructors.cpp#1)]
 [!code-csharp[System.Text.StringBuilder.Constructors#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CS/constructors.cs#1)]
 [!code-vb[System.Text.StringBuilder.Constructors#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/VB/Form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StringBuilder (int capacity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 capacity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.#ctor(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (capacity As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; StringBuilder(int capacity);" />
      <MemberSignature Language="F#" Value="new System.Text.StringBuilder : int -&gt; System.Text.StringBuilder" Usage="new System.Text.StringBuilder capacity" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="capacity" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="capacity">此实例的建议起始大小。</param>
        <summary>使用指定的容量初始化 <see cref="T:System.Text.StringBuilder" /> 类的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `capacity`参数定义的最大可以存储在当前实例所分配的内存中的字符数。 其值分配给<xref:System.Text.StringBuilder.Capacity%2A>属性。 如果要存储在当前实例中的字符数超过了此`capacity`值，<xref:System.Text.StringBuilder>对象分配额外的内存来存储它们。  
  
 此实例的字符串值设置为<xref:System.String.Empty?displayProperty=nameWithType>。 如果`capacity`为零，使用特定于实现的默认容量。  
  
   
  
## Examples  
 下面的示例演示如何调用<xref:System.Text.StringBuilder.%23ctor%2A>构造函数使用指定的容量。  
  
 [!code-cpp[System.Text.StringBuilder.Constructors#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CPP/constructors.cpp#3)]
 [!code-csharp[System.Text.StringBuilder.Constructors#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CS/constructors.cs#3)]
 [!code-vb[System.Text.StringBuilder.Constructors#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/VB/Form1.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="capacity" /> 小于零。</exception>
        <altmember cref="P:System.Text.StringBuilder.Capacity" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StringBuilder (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; StringBuilder(System::String ^ value);" />
      <MemberSignature Language="F#" Value="new System.Text.StringBuilder : string -&gt; System.Text.StringBuilder" Usage="new System.Text.StringBuilder value" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">用于初始化实例值的字符串。 如果 <c>value</c> 为 <see langword="null" />，则新的 <see cref="T:System.Text.StringBuilder" /> 将包含空字符串（即，包含 <see cref="F:System.String.Empty" />）。</param>
        <summary>使用指定的字符串初始化 <see cref="T:System.Text.StringBuilder" /> 类的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果 `value` 为 `null`，则新的 <xref:System.Text.StringBuilder> 将包含空字符串（即包含 <xref:System.String.Empty>）。  
  
   
  
## Examples  
 下面的示例演示如何调用<xref:System.Text.StringBuilder.%23ctor%2A>构造函数使用指定的字符串。  
  
 [!code-cpp[System.Text.StringBuilder.Constructors#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CPP/constructors.cpp#4)]
 [!code-csharp[System.Text.StringBuilder.Constructors#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CS/constructors.cs#4)]
 [!code-vb[System.Text.StringBuilder.Constructors#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/VB/Form1.vb#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StringBuilder (int capacity, int maxCapacity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 capacity, int32 maxCapacity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (capacity As Integer, maxCapacity As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; StringBuilder(int capacity, int maxCapacity);" />
      <MemberSignature Language="F#" Value="new System.Text.StringBuilder : int * int -&gt; System.Text.StringBuilder" Usage="new System.Text.StringBuilder (capacity, maxCapacity)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="capacity" Type="System.Int32" />
        <Parameter Name="maxCapacity" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="capacity">
          <see cref="T:System.Text.StringBuilder" /> 的建议起始大小。</param>
        <param name="maxCapacity">当前字符串可包含的最大字符数。</param>
        <summary>初始化 <see cref="T:System.Text.StringBuilder" /> 类的新实例，该类起始于指定容量并且可增长到指定的最大容量。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `capacity`参数定义的最大可以存储在当前实例所分配的内存中的字符数。 其值分配给<xref:System.Text.StringBuilder.Capacity%2A>属性。 如果要存储在当前实例中的字符数超过了此`capacity`值，<xref:System.Text.StringBuilder>对象分配额外的内存来存储它们。  
  
 如果`capacity`为零，使用特定于实现的默认容量。  
  
 `maxCapacity`属性定义最大的当前实例可容纳的字符数。 其值分配给<xref:System.Text.StringBuilder.MaxCapacity%2A>属性。 如果要存储在当前实例中的字符数超过了此`maxCapacity`值，<xref:System.Text.StringBuilder>对象不会分配更多内存，但会引发异常。  
  
   
  
## Examples  
 下面的示例演示如何调用<xref:System.Text.StringBuilder.%23ctor%2A>构造函数使用指定的容量和最大容量。  
  
 [!code-cpp[System.Text.StringBuilder.Constructors#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CPP/constructors.cpp#5)]
 [!code-csharp[System.Text.StringBuilder.Constructors#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CS/constructors.cs#5)]
 [!code-vb[System.Text.StringBuilder.Constructors#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/VB/Form1.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="maxCapacity" /> 小于一，<paramref name="capacity" /> 小于零，或 <paramref name="capacity" /> 大于 <paramref name="maxCapacity" />。</exception>
        <block subset="none" type="usage">
          <para>中[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]和[!INCLUDE[net_v45](~/includes/net-v45-md.md)]，当您实例化<see cref="T:System.Text.StringBuilder" />对象通过调用<see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" />构造函数，长度和容量<see cref="T:System.Text.StringBuilder" />实例可以增长到的值超过其<see cref="P:System.Text.StringBuilder.MaxCapacity" />属性。发生这种情况尤其是当您调用<see cref="M:System.Text.StringBuilder.Append(System.String)" />和<see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" />追加小型字符串的方法。</para>
        </block>
        <altmember cref="P:System.Text.StringBuilder.Capacity" />
        <altmember cref="P:System.Text.StringBuilder.MaxCapacity" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StringBuilder (string value, int capacity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string value, int32 capacity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.#ctor(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As String, capacity As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; StringBuilder(System::String ^ value, int capacity);" />
      <MemberSignature Language="F#" Value="new System.Text.StringBuilder : string * int -&gt; System.Text.StringBuilder" Usage="new System.Text.StringBuilder (value, capacity)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="capacity" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">用于初始化实例值的字符串。 如果 <c>value</c> 为 <see langword="null" />，则新的 <see cref="T:System.Text.StringBuilder" /> 将包含空字符串（即，包含 <see cref="F:System.String.Empty" />）。</param>
        <param name="capacity">
          <see cref="T:System.Text.StringBuilder" /> 的建议起始大小。</param>
        <summary>使用指定的字符串和容量初始化 <see cref="T:System.Text.StringBuilder" /> 类的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `capacity`参数定义的最大可以存储在当前实例所分配的内存中的字符数。 其值分配给<xref:System.Text.StringBuilder.Capacity%2A>属性。 如果要存储在当前实例中的字符数超过了此`capacity`值，<xref:System.Text.StringBuilder>对象分配额外的内存来存储它们。  
  
 如果`capacity`为零，使用特定于实现的默认容量。  
  
   
  
## Examples  
 下面的示例演示如何调用<xref:System.Text.StringBuilder.%23ctor%2A>构造函数使用的初始字符串和指定的容量。  
  
 [!code-cpp[System.Text.StringBuilder.Constructors#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CPP/constructors.cpp#7)]
 [!code-csharp[System.Text.StringBuilder.Constructors#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CS/constructors.cs#7)]
 [!code-vb[System.Text.StringBuilder.Constructors#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/VB/Form1.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="capacity" /> 小于零。</exception>
        <altmember cref="P:System.Text.StringBuilder.Capacity" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StringBuilder (string value, int startIndex, int length, int capacity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string value, int32 startIndex, int32 length, int32 capacity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.#ctor(System.String,System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As String, startIndex As Integer, length As Integer, capacity As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; StringBuilder(System::String ^ value, int startIndex, int length, int capacity);" />
      <MemberSignature Language="F#" Value="new System.Text.StringBuilder : string * int * int * int -&gt; System.Text.StringBuilder" Usage="new System.Text.StringBuilder (value, startIndex, length, capacity)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="capacity" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">字符串包含用于初始化此实例值的子字符串。 如果 <c>value</c> 为 <see langword="null" />，则新的 <see cref="T:System.Text.StringBuilder" /> 将包含空字符串（即，包含 <see cref="F:System.String.Empty" />）。</param>
        <param name="startIndex">
          <c>value</c> 中子字符串开始的位置。</param>
        <param name="length">子字符串中的字符数。</param>
        <param name="capacity">
          <see cref="T:System.Text.StringBuilder" /> 的建议起始大小。</param>
        <summary>从指定的子字符串和容量初始化 <see cref="T:System.Text.StringBuilder" /> 类的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `capacity`参数定义的最大可以存储在当前实例所分配的内存中的字符数。 其值分配给<xref:System.Text.StringBuilder.Capacity%2A>属性。 如果要存储在当前实例中的字符数超过了此`capacity`值，<xref:System.Text.StringBuilder>对象分配额外的内存来存储它们。  
  
 如果`capacity`为零，使用特定于实现的默认容量。  
  
   
  
## Examples  
 下面的示例演示如何调用<xref:System.Text.StringBuilder.%23ctor%2A>构造函数使用指定的字符串。  
  
 [!code-cpp[System.Text.StringBuilder.Constructors#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CPP/constructors.cpp#6)]
 [!code-csharp[System.Text.StringBuilder.Constructors#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CS/constructors.cs#6)]
 [!code-vb[System.Text.StringBuilder.Constructors#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/VB/Form1.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="capacity" /> 小于零。  
  
或 
 <paramref name="startIndex" /> 加上 <paramref name="length" /> 不是 <paramref name="value" /> 中的位置。</exception>
        <altmember cref="P:System.Text.StringBuilder.Capacity" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Append">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>向此实例追加指定对象的字符串表示形式。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (bool value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(bool value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Boolean) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(bool value);" />
      <MemberSignature Language="F#" Value="member this.Append : bool -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="value">要追加的布尔值。</param>
        <summary>向此实例追加指定的布尔值的字符串表示形式。</summary>
        <returns>完成追加操作后对此实例的引用。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.StringBuilder.Append%28System.Boolean%29>方法修改此类的现有实例; 它不返回新的类实例。 因此，您可以调用方法或属性上现有的引用并不需要将返回值赋给<xref:System.Text.StringBuilder>对象，如以下示例所示。  
  
 [!code-csharp[System.Text.StringBuilder.Append#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append2.cs#2)]
 [!code-vb[System.Text.StringBuilder.Append#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append2.vb#2)]  
  
 <xref:System.Text.StringBuilder.Append%28System.Boolean%29>方法调用<xref:System.Boolean.ToString?displayProperty=nameWithType>方法获取的字符串表示形式`value`。 根据需要调整此实例的容量。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">增大此实例的值将超过 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</exception>
        <block subset="none" type="usage">
          <para>中[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]和[!INCLUDE[net_v45](~/includes/net-v45-md.md)]，当您实例化<see cref="T:System.Text.StringBuilder" />对象通过调用<see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" />构造函数，长度和容量<see cref="T:System.Text.StringBuilder" />实例可以增长到的值超过其<see cref="P:System.Text.StringBuilder.MaxCapacity" />属性。发生这种情况尤其是当您调用<see cref="M:System.Text.StringBuilder.Append(System.String)" />和<see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" />追加小型字符串的方法。</para>
        </block>
        <altmember cref="T:System.Boolean" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (byte value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(unsigned int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Byte)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Byte) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(System::Byte value);" />
      <MemberSignature Language="F#" Value="member this.Append : byte -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Byte" />
      </Parameters>
      <Docs>
        <param name="value">要追加的值。</param>
        <summary>向此实例追加指定的 8 位无符号整数的字符串表示形式。</summary>
        <returns>完成追加操作后对此实例的引用。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.StringBuilder.Append%28System.Byte%29>方法修改此类的现有实例; 它不返回新的类实例。 因此，您可以调用方法或属性上现有的引用并不需要将返回值赋给<xref:System.Text.StringBuilder>对象，如以下示例所示。  
  
 [!code-csharp[System.Text.StringBuilder.Append#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append2.cs#3)]
 [!code-vb[System.Text.StringBuilder.Append#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append2.vb#3)]  
  
 <xref:System.Text.StringBuilder.Append%28System.Byte%29>方法调用<xref:System.Byte.ToString%28System.IFormatProvider%29>方法获取的字符串表示形式`value`为当前区域性。 若要控制的格式`value`，调用<xref:System.Text.StringBuilder.AppendFormat%2A>方法。  
  
 根据需要调整此实例的容量。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">增大此实例的值将超过 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</exception>
        <block subset="none" type="usage">
          <para>中[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]和[!INCLUDE[net_v45](~/includes/net-v45-md.md)]，当您实例化<see cref="T:System.Text.StringBuilder" />对象通过调用<see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" />构造函数，长度和容量<see cref="T:System.Text.StringBuilder" />实例可以增长到的值超过其<see cref="P:System.Text.StringBuilder.MaxCapacity" />属性。发生这种情况尤其是当您调用<see cref="M:System.Text.StringBuilder.Append(System.String)" />和<see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" />追加小型字符串的方法。</para>
        </block>
        <altmember cref="T:System.Byte" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (char value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(char value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Char) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(char value);" />
      <MemberSignature Language="F#" Value="member this.Append : char -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="value">要追加的 UTF 16 编码的代码单元。</param>
        <summary>将指定的 <see cref="T:System.Char" /> 对象的字符串表示形式追加到此实例。</summary>
        <returns>完成追加操作后对此实例的引用。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.StringBuilder.Append%28System.Char%29>方法修改此类的现有实例; 它不返回新的类实例。 因此，您可以调用方法或属性上现有的引用并不需要将返回值赋给<xref:System.Text.StringBuilder>对象，如以下示例所示。  
  
 [!code-csharp[System.Text.StringBuilder.Append#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append2.cs#4)]
 [!code-vb[System.Text.StringBuilder.Append#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append2.vb#4)]  
  
 根据需要调整此实例的容量。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">增大此实例的值将超过 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</exception>
        <block subset="none" type="usage">
          <para>中[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]和[!INCLUDE[net_v45](~/includes/net-v45-md.md)]，当您实例化<see cref="T:System.Text.StringBuilder" />对象通过调用<see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" />构造函数，长度和容量<see cref="T:System.Text.StringBuilder" />实例可以增长到的值超过其<see cref="P:System.Text.StringBuilder.MaxCapacity" />属性。发生这种情况尤其是当您调用<see cref="M:System.Text.StringBuilder.Append(System.String)" />和<see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" />追加小型字符串的方法。</para>
        </block>
        <altmember cref="T:System.Char" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (char[] value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(char[] value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Char()) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(cli::array &lt;char&gt; ^ value);" />
      <MemberSignature Language="F#" Value="member this.Append : char[] -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char[]" />
      </Parameters>
      <Docs>
        <param name="value">要追加的字符数组。</param>
        <summary>向此实例追加指定数组中的 Unicode 字符的字符串表示形式。</summary>
        <returns>完成追加操作后对此实例的引用。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法将指定数组中的所有字符都追加到当前实例的相同顺序出现在`value`。 如果`value`是`null`，不进行任何更改。  
  
 <xref:System.Text.StringBuilder.Append%28System.Char%5B%5D%29>方法修改此类的现有实例; 它不返回新的类实例。 因此，您可以调用方法或属性上现有的引用并不需要将返回值赋给<xref:System.Text.StringBuilder>对象，如以下示例所示。  
  
 [!code-csharp[System.Text.StringBuilder.Append#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append2.cs#6)]
 [!code-vb[System.Text.StringBuilder.Append#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append2.vb#6)]  
  
 根据需要调整此实例的容量。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">增大此实例的值将超过 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</exception>
        <block subset="none" type="usage">
          <para>中[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]和[!INCLUDE[net_v45](~/includes/net-v45-md.md)]，当您实例化<see cref="T:System.Text.StringBuilder" />对象通过调用<see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" />构造函数，长度和容量<see cref="T:System.Text.StringBuilder" />实例可以增长到的值超过其<see cref="P:System.Text.StringBuilder.MaxCapacity" />属性。发生这种情况尤其是当您调用<see cref="M:System.Text.StringBuilder.Append(System.String)" />和<see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" />追加小型字符串的方法。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (decimal value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(valuetype System.Decimal value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Decimal)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Decimal) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(System::Decimal value);" />
      <MemberSignature Language="F#" Value="member this.Append : decimal -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="value">要追加的值。</param>
        <summary>向此实例追加指定的十进制数的字符串表示形式。</summary>
        <returns>完成追加操作后对此实例的引用。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.StringBuilder.Append%28System.Decimal%29>方法修改此类的现有实例; 它不返回新的类实例。 因此，您可以调用方法或属性上现有的引用并不需要将返回值赋给<xref:System.Text.StringBuilder>对象，如以下示例所示。  
  
 [!code-csharp[System.Text.StringBuilder.Append#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append2.cs#8)]
 [!code-vb[System.Text.StringBuilder.Append#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append2.vb#8)]  
  
 <xref:System.Text.StringBuilder.Append%28System.Decimal%29>方法调用<xref:System.Decimal.ToString%28System.IFormatProvider%29?displayProperty=nameWithType>方法获取的字符串表示形式`value`为当前区域性。 若要控制的格式`value`，调用<xref:System.Text.StringBuilder.AppendFormat%2A>方法。  
  
 根据需要调整此实例的容量。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">增大此实例的值将超过 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</exception>
        <block subset="none" type="usage">
          <para>中[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]和[!INCLUDE[net_v45](~/includes/net-v45-md.md)]，当您实例化<see cref="T:System.Text.StringBuilder" />对象通过调用<see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" />构造函数，长度和容量<see cref="T:System.Text.StringBuilder" />实例可以增长到的值超过其<see cref="P:System.Text.StringBuilder.MaxCapacity" />属性。发生这种情况尤其是当您调用<see cref="M:System.Text.StringBuilder.Append(System.String)" />和<see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" />追加小型字符串的方法。</para>
        </block>
        <altmember cref="T:System.Decimal" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (double value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Double) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(double value);" />
      <MemberSignature Language="F#" Value="member this.Append : double -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="value">要追加的值。</param>
        <summary>向此实例追加指定的双精度浮点数的字符串表示形式。</summary>
        <returns>完成追加操作后对此实例的引用。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.StringBuilder.Append%28System.Double%29>方法修改此类的现有实例; 它不返回新的类实例。 因此，您可以调用方法或属性上现有的引用并不需要将返回值赋给<xref:System.Text.StringBuilder>对象，如以下示例所示。  
  
 [!code-csharp[System.Text.StringBuilder.Append#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append2.cs#9)]
 [!code-vb[System.Text.StringBuilder.Append#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append2.vb#9)]  
  
 <xref:System.Text.StringBuilder.Append%28System.Double%29>方法调用<xref:System.Double.ToString%28System.IFormatProvider%29?displayProperty=nameWithType>方法获取的字符串表示形式`value`为当前区域性。 若要控制的格式`value`，调用<xref:System.Text.StringBuilder.AppendFormat%2A>方法。  
  
 根据需要调整此实例的容量。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">增大此实例的值将超过 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</exception>
        <block subset="none" type="usage">
          <para>中[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]和[!INCLUDE[net_v45](~/includes/net-v45-md.md)]，当您实例化<see cref="T:System.Text.StringBuilder" />对象通过调用<see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" />构造函数，长度和容量<see cref="T:System.Text.StringBuilder" />实例可以增长到的值超过其<see cref="P:System.Text.StringBuilder.MaxCapacity" />属性。发生这种情况尤其是当您调用<see cref="M:System.Text.StringBuilder.Append(System.String)" />和<see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" />追加小型字符串的方法。</para>
        </block>
        <altmember cref="T:System.Double" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (short value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Int16)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Short) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(short value);" />
      <MemberSignature Language="F#" Value="member this.Append : int16 -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="value">要追加的值。</param>
        <summary>向此实例追加指定的 16 位有符号整数的字符串表示形式。</summary>
        <returns>完成追加操作后对此实例的引用。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.StringBuilder.Append%28System.Int16%29>方法修改此类的现有实例; 它不返回新的类实例。 因此，您可以调用方法或属性上现有的引用并不需要将返回值赋给<xref:System.Text.StringBuilder>对象，如以下示例所示。  
  
 [!code-csharp[System.Text.StringBuilder.Append#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append3.cs#10)]
 [!code-vb[System.Text.StringBuilder.Append#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append3.vb#10)]  
  
 <xref:System.Text.StringBuilder.Append%28System.Int16%29>方法调用<xref:System.Int16.ToString%28System.IFormatProvider%29?displayProperty=nameWithType>方法获取的字符串表示形式`value`为当前区域性。 若要控制的格式`value`，调用<xref:System.Text.StringBuilder.AppendFormat%2A>方法。  
  
 根据需要调整此实例的容量。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">增大此实例的值将超过 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</exception>
        <block subset="none" type="usage">
          <para>中[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]和[!INCLUDE[net_v45](~/includes/net-v45-md.md)]，当您实例化<see cref="T:System.Text.StringBuilder" />对象通过调用<see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" />构造函数，长度和容量<see cref="T:System.Text.StringBuilder" />实例可以增长到的值超过其<see cref="P:System.Text.StringBuilder.MaxCapacity" />属性。发生这种情况尤其是当您调用<see cref="M:System.Text.StringBuilder.Append(System.String)" />和<see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" />追加小型字符串的方法。</para>
        </block>
        <altmember cref="T:System.Int16" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (int value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Integer) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(int value);" />
      <MemberSignature Language="F#" Value="member this.Append : int -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">要追加的值。</param>
        <summary>向此实例追加指定的 32 位有符号整数的字符串表示形式。</summary>
        <returns>完成追加操作后对此实例的引用。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.StringBuilder.Append%28System.Int32%29>方法修改此类的现有实例; 它不返回新的类实例。 因此，您可以调用方法或属性上现有的引用并不需要将返回值赋给<xref:System.Text.StringBuilder>对象，如以下示例所示。  
  
 [!code-csharp[System.Text.StringBuilder.Append#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append3.cs#11)]
 [!code-vb[System.Text.StringBuilder.Append#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append3.vb#11)]  
  
 <xref:System.Text.StringBuilder.Append%28System.Int32%29>方法调用<xref:System.Int32.ToString%28System.IFormatProvider%29?displayProperty=nameWithType>方法获取的字符串表示形式`value`为当前区域性。 若要控制的格式`value`，调用<xref:System.Text.StringBuilder.AppendFormat%2A>方法。  
  
 根据需要调整此实例的容量。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">增大此实例的值将超过 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</exception>
        <block subset="none" type="usage">
          <para>中[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]和[!INCLUDE[net_v45](~/includes/net-v45-md.md)]，当您实例化<see cref="T:System.Text.StringBuilder" />对象通过调用<see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" />构造函数，长度和容量<see cref="T:System.Text.StringBuilder" />实例可以增长到的值超过其<see cref="P:System.Text.StringBuilder.MaxCapacity" />属性。发生这种情况尤其是当您调用<see cref="M:System.Text.StringBuilder.Append(System.String)" />和<see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" />追加小型字符串的方法。</para>
        </block>
        <altmember cref="T:System.Int32" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Long) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(long value);" />
      <MemberSignature Language="F#" Value="member this.Append : int64 -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value">要追加的值。</param>
        <summary>向此实例追加指定的 64 位有符号整数的字符串表示形式。</summary>
        <returns>完成追加操作后对此实例的引用。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.StringBuilder.Append%28System.Int64%29>方法修改此类的现有实例; 它不返回新的类实例。 因此，您可以调用方法或属性上现有的引用并不需要将返回值赋给<xref:System.Text.StringBuilder>对象，如以下示例所示。  
  
 [!code-csharp[System.Text.StringBuilder.Append#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append3.cs#12)]
 [!code-vb[System.Text.StringBuilder.Append#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append3.vb#12)]  
  
 <xref:System.Text.StringBuilder.Append%28System.Int64%29>方法调用<xref:System.Int64.ToString%28System.IFormatProvider%29?displayProperty=nameWithType>若要获取的字符串表示形式`value`为当前区域性。 若要控制的格式`value`，调用<xref:System.Text.StringBuilder.AppendFormat%2A>方法。  
  
 根据需要调整此实例的容量。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">增大此实例的值将超过 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</exception>
        <block subset="none" type="usage">
          <para>中[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]和[!INCLUDE[net_v45](~/includes/net-v45-md.md)]，当您实例化<see cref="T:System.Text.StringBuilder" />对象通过调用<see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" />构造函数，长度和容量<see cref="T:System.Text.StringBuilder" />实例可以增长到的值超过其<see cref="P:System.Text.StringBuilder.MaxCapacity" />属性。发生这种情况尤其是当您调用<see cref="M:System.Text.StringBuilder.Append(System.String)" />和<see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" />追加小型字符串的方法。</para>
        </block>
        <altmember cref="T:System.Int64" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Object) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="member this.Append : obj -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">要追加的对象。</param>
        <summary>向此实例追加指定对象的字符串表示形式。</summary>
        <returns>完成追加操作后对此实例的引用。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.StringBuilder.Append%28System.Object%29>方法修改此类的现有实例; 它不返回新的类实例。 因此，您可以调用方法或属性上现有的引用并不需要将返回值赋给<xref:System.Text.StringBuilder>对象，如以下示例所示。 它定义`Dog`类中，创建`Dog`对象，并调用三<xref:System.Text.StringBuilder.Append%2A>方法来创建一个字符串，包含狗的名称和基础结构提供支持。  
  
 [!code-csharp[System.Text.Stringbuilder.Append#18](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append4.cs#18)]
 [!code-vb[System.Text.Stringbuilder.Append#18](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append4.vb#18)]  
  
 <xref:System.Text.StringBuilder.Append%28System.Object%29>方法调用<xref:System.Object.ToString%2A?displayProperty=nameWithType>方法获取的字符串表示形式`value`。 如果`value`是`null`，对进行任何更改<xref:System.Text.StringBuilder>对象。  
  
 根据需要调整此实例的容量。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">增大此实例的值将超过 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</exception>
        <block subset="none" type="usage">
          <para>中[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]和[!INCLUDE[net_v45](~/includes/net-v45-md.md)]，当您实例化<see cref="T:System.Text.StringBuilder" />对象通过调用<see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" />构造函数，长度和容量<see cref="T:System.Text.StringBuilder" />实例可以增长到的值超过其<see cref="P:System.Text.StringBuilder.MaxCapacity" />属性。发生这种情况尤其是当您调用<see cref="M:System.Text.StringBuilder.Append(System.String)" />和<see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" />追加小型字符串的方法。</para>
        </block>
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (ReadOnlySpan&lt;char&gt; value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(valuetype System.ReadOnlySpan`1&lt;char&gt; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As ReadOnlySpan(Of Char)) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(ReadOnlySpan&lt;char&gt; value);" />
      <MemberSignature Language="F#" Value="member this.Append : ReadOnlySpan&lt;char&gt; -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (sbyte value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.SByte)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As SByte) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(System::SByte value);" />
      <MemberSignature Language="F#" Value="member this.Append : sbyte -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.SByte" />
      </Parameters>
      <Docs>
        <param name="value">要追加的值。</param>
        <summary>向此实例追加指定的 8 位有符号整数的字符串表示形式。</summary>
        <returns>完成追加操作后对此实例的引用。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.StringBuilder.Append%28System.SByte%29>方法修改此类的现有实例; 它不返回新的类实例。 因此，您可以调用方法或属性上现有的引用并不需要将返回值赋给<xref:System.Text.StringBuilder>对象，如以下示例所示。  
  
 [!code-csharp[System.Text.StringBuilder.Append#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append3.cs#13)]
 [!code-vb[System.Text.StringBuilder.Append#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append3.vb#13)]  
  
 <xref:System.Text.StringBuilder.Append%28System.SByte%29>方法调用<xref:System.SByte.ToString%28System.IFormatProvider%29?displayProperty=nameWithType>方法获取的字符串表示形式`value`为当前区域性。 若要控制的格式`value`，调用<xref:System.Text.StringBuilder.AppendFormat%2A>方法。  
  
 根据需要调整此实例的容量。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">增大此实例的值将超过 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</exception>
        <block subset="none" type="usage">
          <para>中[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]和[!INCLUDE[net_v45](~/includes/net-v45-md.md)]，当您实例化<see cref="T:System.Text.StringBuilder" />对象通过调用<see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" />构造函数，长度和容量<see cref="T:System.Text.StringBuilder" />实例可以增长到的值超过其<see cref="P:System.Text.StringBuilder.MaxCapacity" />属性。发生这种情况尤其是当您调用<see cref="M:System.Text.StringBuilder.Append(System.String)" />和<see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" />追加小型字符串的方法。</para>
        </block>
        <altmember cref="T:System.SByte" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (float value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(float32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Single) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(float value);" />
      <MemberSignature Language="F#" Value="member this.Append : single -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="value">要追加的值。</param>
        <summary>向此实例追加指定的单精度浮点数的字符串表示形式。</summary>
        <returns>完成追加操作后对此实例的引用。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.StringBuilder.Append%28System.Single%29>方法修改此类的现有实例; 它不返回新的类实例。 因此，您可以调用方法或属性上现有的引用并不需要将返回值赋给<xref:System.Text.StringBuilder>对象，如以下示例所示。  
  
 [!code-csharp[System.Text.StringBuilder.Append#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append3.cs#14)]
 [!code-vb[System.Text.StringBuilder.Append#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append3.vb#14)]  
  
 <xref:System.Text.StringBuilder.Append%28System.Single%29>方法调用<xref:System.Single.ToString%2A?displayProperty=nameWithType>方法获取的字符串表示形式`value`为当前区域性。 若要控制的格式`value`，调用<xref:System.Text.StringBuilder.AppendFormat%2A>方法。  
  
 根据需要调整此实例的容量。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">增大此实例的值将超过 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</exception>
        <block subset="none" type="usage">
          <para>中[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]和[!INCLUDE[net_v45](~/includes/net-v45-md.md)]，当您实例化<see cref="T:System.Text.StringBuilder" />对象通过调用<see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" />构造函数，长度和容量<see cref="T:System.Text.StringBuilder" />实例可以增长到的值超过其<see cref="P:System.Text.StringBuilder.MaxCapacity" />属性。发生这种情况尤其是当您调用<see cref="M:System.Text.StringBuilder.Append(System.String)" />和<see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" />追加小型字符串的方法。</para>
        </block>
        <altmember cref="T:System.Single" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As String) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.Append : string -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">要追加的字符串。</param>
        <summary>向此实例追加指定字符串的副本。</summary>
        <returns>完成追加操作后对此实例的引用。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.StringBuilder.Append%28System.String%29>方法修改此类的现有实例; 它不返回新的类实例。 因此，您可以调用方法或属性上现有的引用并不需要将返回值赋给<xref:System.Text.StringBuilder>对象，如以下示例所示。  
  
 [!code-csharp[System.Text.StringBuilder.Append#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append2.cs#2)]
 [!code-vb[System.Text.StringBuilder.Append#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append2.vb#2)]  
  
 如果`value`是`null`，不进行任何更改。  
  
 根据需要调整此实例的容量。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">增大此实例的值将超过 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</exception>
        <block subset="none" type="usage">
          <para>中[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]和[!INCLUDE[net_v45](~/includes/net-v45-md.md)]，当您实例化<see cref="T:System.Text.StringBuilder" />对象通过调用<see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" />构造函数，长度和容量<see cref="T:System.Text.StringBuilder" />实例可以增长到的值超过其<see cref="P:System.Text.StringBuilder.MaxCapacity" />属性。发生这种情况尤其是当您调用<see cref="M:System.Text.StringBuilder.Append(System.String)" />和<see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" />追加小型字符串的方法。</para>
        </block>
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (System.Text.StringBuilder value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(class System.Text.StringBuilder value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Text.StringBuilder)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As StringBuilder) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(System::Text::StringBuilder ^ value);" />
      <MemberSignature Language="F#" Value="member this.Append : System.Text.StringBuilder -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Text.StringBuilder" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (ushort value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(unsigned int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.UInt16)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As UShort) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(System::UInt16 value);" />
      <MemberSignature Language="F#" Value="member this.Append : uint16 -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt16" />
      </Parameters>
      <Docs>
        <param name="value">要追加的值。</param>
        <summary>向此实例追加指定的 16 位无符号整数的字符串表示形式。</summary>
        <returns>完成追加操作后对此实例的引用。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.StringBuilder.Append%28System.UInt16%29>方法修改此类的现有实例; 它不返回新的类实例。 因此，您可以调用方法或属性上现有的引用并不需要将返回值赋给<xref:System.Text.StringBuilder>对象，如以下示例所示。  
  
 [!code-csharp[System.Text.StringBuilder.Append#15](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append3.cs#15)]
 [!code-vb[System.Text.StringBuilder.Append#15](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append3.vb#15)]  
  
 <xref:System.Text.StringBuilder.Append%28System.UInt16%29>方法调用<xref:System.UInt16.ToString%28System.IFormatProvider%29?displayProperty=nameWithType>方法获取的字符串表示形式`value`。 若要控制的格式`value`，调用<xref:System.Text.StringBuilder.AppendFormat%2A>方法。  
  
 根据需要调整此实例的容量。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">增大此实例的值将超过 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</exception>
        <block subset="none" type="usage">
          <para>中[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]和[!INCLUDE[net_v45](~/includes/net-v45-md.md)]，当您实例化<see cref="T:System.Text.StringBuilder" />对象通过调用<see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" />构造函数，长度和容量<see cref="T:System.Text.StringBuilder" />实例可以增长到的值超过其<see cref="P:System.Text.StringBuilder.MaxCapacity" />属性。发生这种情况尤其是当您调用<see cref="M:System.Text.StringBuilder.Append(System.String)" />和<see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" />追加小型字符串的方法。</para>
        </block>
        <altmember cref="T:System.UInt16" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (uint value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(unsigned int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.UInt32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As UInteger) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(System::UInt32 value);" />
      <MemberSignature Language="F#" Value="member this.Append : uint32 -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt32" />
      </Parameters>
      <Docs>
        <param name="value">要追加的值。</param>
        <summary>向此实例追加指定的 32 位无符号整数的字符串表示形式。</summary>
        <returns>完成追加操作后对此实例的引用。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.StringBuilder.Append%28System.UInt32%29>方法修改此类的现有实例; 它不返回新的类实例。 因此，您可以调用方法或属性上现有的引用并不需要将返回值赋给<xref:System.Text.StringBuilder>对象，如以下示例所示。  
  
 [!code-csharp[System.Text.StringBuilder.Append#16](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append3.cs#16)]
 [!code-vb[System.Text.StringBuilder.Append#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append3.vb#16)]  
  
 <xref:System.Text.StringBuilder.Append%28System.UInt32%29>调用<xref:System.UInt32.ToString%2A?displayProperty=nameWithType>方法获取的字符串表示形式`value`为当前区域性。 若要控制的格式`value`，调用<xref:System.Text.StringBuilder.AppendFormat%2A>方法。  
  
 根据需要调整此实例的容量。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">增大此实例的值将超过 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</exception>
        <block subset="none" type="usage">
          <para>中[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]和[!INCLUDE[net_v45](~/includes/net-v45-md.md)]，当您实例化<see cref="T:System.Text.StringBuilder" />对象通过调用<see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" />构造函数，长度和容量<see cref="T:System.Text.StringBuilder" />实例可以增长到的值超过其<see cref="P:System.Text.StringBuilder.MaxCapacity" />属性。发生这种情况尤其是当您调用<see cref="M:System.Text.StringBuilder.Append(System.String)" />和<see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" />追加小型字符串的方法。</para>
        </block>
        <altmember cref="T:System.UInt32" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (ulong value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(unsigned int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As ULong) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(System::UInt64 value);" />
      <MemberSignature Language="F#" Value="member this.Append : uint64 -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="value">要追加的值。</param>
        <summary>向此实例追加指定的 64 位无符号整数的字符串表示形式。</summary>
        <returns>完成追加操作后对此实例的引用。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.StringBuilder.Append%28System.UInt64%29>方法修改此类的现有实例; 它不返回新的类实例。 因此，您可以调用方法或属性上现有的引用并不需要将返回值赋给<xref:System.Text.StringBuilder>对象，如以下示例所示。  
  
 [!code-csharp[System.Text.StringBuilder.Append#17](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append3.cs#17)]
 [!code-vb[System.Text.StringBuilder.Append#17](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append3.vb#17)]  
  
 <xref:System.Text.StringBuilder.Append%28System.UInt64%29>方法调用<xref:System.UInt64.ToString%28System.IFormatProvider%29?displayProperty=nameWithType>方法获取的字符串表示形式`value`为当前区域性。 若要控制的格式`value`，调用<xref:System.Text.StringBuilder.AppendFormat%2A>方法。  
  
 根据需要调整此实例的容量。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">增大此实例的值将超过 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</exception>
        <block subset="none" type="usage">
          <para>中[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]和[!INCLUDE[net_v45](~/includes/net-v45-md.md)]，当您实例化<see cref="T:System.Text.StringBuilder" />对象通过调用<see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" />构造函数，长度和容量<see cref="T:System.Text.StringBuilder" />实例可以增长到的值超过其<see cref="P:System.Text.StringBuilder.MaxCapacity" />属性。发生这种情况尤其是当您调用<see cref="M:System.Text.StringBuilder.Append(System.String)" />和<see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" />追加小型字符串的方法。</para>
        </block>
        <altmember cref="T:System.UInt64" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (char value, int repeatCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(char value, int32 repeatCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Char,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Char, repeatCount As Integer) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(char value, int repeatCount);" />
      <MemberSignature Language="F#" Value="member this.Append : char * int -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append (value, repeatCount)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
        <Parameter Name="repeatCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">要追加的字符。</param>
        <param name="repeatCount">要追加 <c>value</c> 的次数。</param>
        <summary>向此实例追加 Unicode 字符的字符串表示形式指定数目的副本。</summary>
        <returns>完成追加操作后对此实例的引用。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.StringBuilder.Append%28System.Char%2CSystem.Int32%29>方法修改此类的现有实例; 它不返回新的类实例。 因此，您可以调用方法或属性上现有的引用并不需要将返回值赋给<xref:System.Text.StringBuilder>对象，如以下示例所示。  
  
 [!code-csharp[System.Text.StringBuilder.Append#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append2.cs#5)]
 [!code-vb[System.Text.StringBuilder.Append#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append2.vb#5)]  
  
 根据需要调整此实例的容量。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="repeatCount" /> 小于零。  
  
或 
增大此实例的值将超过 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</exception>
        <exception cref="T:System.OutOfMemoryException">内存不足。</exception>
        <block subset="none" type="usage">
          <para>中[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]和[!INCLUDE[net_v45](~/includes/net-v45-md.md)]，当您实例化<see cref="T:System.Text.StringBuilder" />对象通过调用<see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" />构造函数，长度和容量<see cref="T:System.Text.StringBuilder" />实例可以增长到的值超过其<see cref="P:System.Text.StringBuilder.MaxCapacity" />属性。发生这种情况尤其是当您调用<see cref="M:System.Text.StringBuilder.Append(System.String)" />和<see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" />追加小型字符串的方法。</para>
        </block>
        <altmember cref="T:System.Char" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (char* value, int valueCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(char* value, int32 valueCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Char*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(char* value, int valueCount);" />
      <MemberSignature Language="F#" Value="member this.Append : nativeptr&lt;char&gt; * int -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append (value, valueCount)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char*" />
        <Parameter Name="valueCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">指向字符数组的指针。</param>
        <param name="valueCount">数组中的字符数。</param>
        <summary>将从指定地址开始的 Unicode 字符数组追加到此实例。</summary>
        <returns>完成追加操作后对此实例的引用。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法将追加`valueCount`地址开始的字符`value`到当前实例。  
  
 <xref:System.Text.StringBuilder.Append%28System.Char%2A%2CSystem.Int32%29>方法修改此类的现有实例; 它不返回新的类实例。 因此，您可以调用方法或属性上现有的引用并不需要将返回值赋给<xref:System.Text.StringBuilder>对象。  
  
 根据需要调整此实例的容量。  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Text.StringBuilder.Append(System.Char[],System.Int32,System.Int32)" />
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="valueCount" /> 小于零。  
  
或 
增大此实例的值将超过 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</exception>
        <exception cref="T:System.NullReferenceException">
          <paramref name="value" /> 为 null 指针。</exception>
        <block subset="none" type="usage">
          <para>中[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]和[!INCLUDE[net_v45](~/includes/net-v45-md.md)]，当您实例化<see cref="T:System.Text.StringBuilder" />对象通过调用<see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" />构造函数，长度和容量<see cref="T:System.Text.StringBuilder" />实例可以增长到的值超过其<see cref="P:System.Text.StringBuilder.MaxCapacity" />属性。发生这种情况尤其是当您调用<see cref="M:System.Text.StringBuilder.Append(System.String)" />和<see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" />追加小型字符串的方法。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (char[] value, int startIndex, int charCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(char[] value, int32 startIndex, int32 charCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Char(), startIndex As Integer, charCount As Integer) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(cli::array &lt;char&gt; ^ value, int startIndex, int charCount);" />
      <MemberSignature Language="F#" Value="member this.Append : char[] * int * int -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append (value, startIndex, charCount)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="charCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">字符数组。</param>
        <param name="startIndex">
          <c>value</c> 中的开始位置。</param>
        <param name="charCount">要追加的字符数。</param>
        <summary>向此实例追加指定的 Unicode 字符子数组的字符串表示形式。</summary>
        <returns>完成追加操作后对此实例的引用。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法将指定的范围中的字符追加`value`到当前实例。 如果`value`是`null`并`startIndex`和`count`都是零个、 没有更改。  
  
 <xref:System.Text.StringBuilder.Append%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29>方法修改此类的现有实例; 它不返回新的类实例。 因此，您可以调用方法或属性上现有的引用并不需要将返回值赋给<xref:System.Text.StringBuilder>对象，如以下示例所示。  
  
 [!code-csharp[System.Text.StringBuilder.Append#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append2.cs#7)]
 [!code-vb[System.Text.StringBuilder.Append#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append2.vb#7)]  
  
 根据需要调整此实例的容量。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> 为 <see langword="null" />，且 <paramref name="startIndex" /> 和 <paramref name="charCount" /> 不为零。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="charCount" /> 小于零。  
  
或 
 <paramref name="startIndex" /> 小于零。  
  
或 
 <paramref name="startIndex" /> + <paramref name="charCount" /> 大于 <paramref name="value" /> 的长度。  
  
或 
增大此实例的值将超过 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</exception>
        <block subset="none" type="usage">
          <para>中[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]和[!INCLUDE[net_v45](~/includes/net-v45-md.md)]，当您实例化<see cref="T:System.Text.StringBuilder" />对象通过调用<see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" />构造函数，长度和容量<see cref="T:System.Text.StringBuilder" />实例可以增长到的值超过其<see cref="P:System.Text.StringBuilder.MaxCapacity" />属性。发生这种情况尤其是当您调用<see cref="M:System.Text.StringBuilder.Append(System.String)" />和<see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" />追加小型字符串的方法。</para>
        </block>
        <altmember cref="T:System.Char" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (string value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(string value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As String, startIndex As Integer, count As Integer) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(System::String ^ value, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.Append : string * int * int -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append (value, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">包含要追加的子字符串的字符串。</param>
        <param name="startIndex">
          <c>value</c> 中子字符串开始的位置。</param>
        <param name="count">
          <c>value</c> 中要追加的字符数。</param>
        <summary>向此实例追加指定子字符串的副本。</summary>
        <returns>完成追加操作后对此实例的引用。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法将指定的范围中的字符追加`value`到当前实例。 如果`value`是`null`并`startIndex`和`count`都是零个、 没有更改。  
  
 <xref:System.Text.StringBuilder.Append%28System.String%2CSystem.Int32%2CSystem.Int32%29>方法修改此类的现有实例; 它不返回新的类实例。 因此，您可以调用方法或属性上现有的引用并不需要将返回值赋给<xref:System.Text.StringBuilder>对象，如以下示例所示。  
  
 [!code-csharp[System.Text.StringBuilder.Append#19](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append3.cs#19)]
 [!code-vb[System.Text.StringBuilder.Append#19](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append3.vb#19)]  
  
 根据需要调整此实例的容量。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> 为 <see langword="null" />，且 <paramref name="startIndex" /> 和 <paramref name="count" /> 不为零。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="count" /> 小于零。  
  
或 
 <paramref name="startIndex" /> 小于零。  
  
或 
 <paramref name="startIndex" /> + <paramref name="count" /> 大于 <paramref name="value" /> 的长度。  
  
或 
增大此实例的值将超过 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</exception>
        <block subset="none" type="usage">
          <para>中[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]和[!INCLUDE[net_v45](~/includes/net-v45-md.md)]，当您实例化<see cref="T:System.Text.StringBuilder" />对象通过调用<see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" />构造函数，长度和容量<see cref="T:System.Text.StringBuilder" />实例可以增长到的值超过其<see cref="P:System.Text.StringBuilder.MaxCapacity" />属性。发生这种情况尤其是当您调用<see cref="M:System.Text.StringBuilder.Append(System.String)" />和<see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" />追加小型字符串的方法。</para>
        </block>
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (System.Text.StringBuilder value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(class System.Text.StringBuilder value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Text.StringBuilder,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As StringBuilder, startIndex As Integer, count As Integer) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(System::Text::StringBuilder ^ value, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.Append : System.Text.StringBuilder * int * int -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append (value, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Text.StringBuilder" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <param name="startIndex">To be added.</param>
        <param name="count">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AppendFormat">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>向此实例追加通过处理复合格式字符串（包含零个或更多格式项）而返回的字符串。 每个格式项都由相应的对象自变量的字符串表示形式替换。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AppendFormat">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendFormat (string format, object arg0);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendFormat(string format, object arg0) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendFormat (format As String, arg0 As Object) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendFormat(System::String ^ format, System::Object ^ arg0);" />
      <MemberSignature Language="F#" Value="member this.AppendFormat : string * obj -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendFormat (format, arg0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="arg0" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="format">复合格式字符串。</param>
        <param name="arg0">要设置其格式的对象。</param>
        <summary>向此实例追加通过处理复合格式字符串（包含零个或更多格式项）而返回的字符串。 每个格式项都替换为一个自变量的字符串表示形式。</summary>
        <returns>对追加了 <paramref name="format" /> 的此实例的引用。 <paramref name="format" /> 中的每个格式项都替换为 <paramref name="arg0" /> 的字符串表示形式。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法使用[复合格式设置功能](~/docs/standard/base-types/composite-formatting.md)的.NET Framework，才能将对象的值转换为其文本表示形式并将该表示形式嵌入在当前<xref:System.Text.StringBuilder>对象。  
  
 `format`参数由零个或多个文本和零个或多个索引占位符称为格式项混和组成。 格式项的索引必须为 0，对应于`arg0`，此方法的参数列表中的单个对象。 格式设置过程将每个格式项替换的字符串表示形式`arg0`。  
  
 格式项的语法如下所示：  
  
 {*索引*[，*长度*] [:*formatString*]}  
  
 括号中的元素是可选的。 下表对每个元素进行了描述。  
  
|元素|描述|  
|-------------|-----------------|  
|*index*|参数列表中要进行格式化的对象的从零开始位置。 如果指定的对象*索引*是`null`，格式项都替换为<xref:System.String.Empty?displayProperty=nameWithType>。 如果在没有参数*索引*位置，<xref:System.FormatException>引发。|  
|*长度*|最小参数的字符串表示形式中的字符数。 如果为正数，该参数为右对齐;如果为负数，它是左对齐。|  
|:*格式字符串*|由参数支持标准或自定义格式字符串。|  
  
> [!NOTE]
>  有关使用日期和时间值的标准和自定义格式字符串，请参阅[标准日期和时间格式字符串](~/docs/standard/base-types/standard-date-and-time-format-strings.md)并[自定义日期和时间格式字符串](~/docs/standard/base-types/custom-date-and-time-format-strings.md)。 对于标准和自定义格式字符串与数值一起使用，请参阅[标准数字格式字符串](~/docs/standard/base-types/standard-numeric-format-strings.md)并[自定义数字格式字符串](~/docs/standard/base-types/custom-numeric-format-strings.md)。 用于枚举的标准格式字符串，请参阅[枚举格式字符串](~/docs/standard/base-types/enumeration-format-strings.md)。  
  
 `arg0` 表示要设置格式的对象。 在每个格式项`format`替换的字符串表示形式`arg0`。 如果格式项包括`formatString`并`arg0`实现<xref:System.IFormattable>接口，则`arg0.ToString(formatString, null)`定义格式设置。 否则为`arg0.ToString()`定义格式设置。  
  
 如果字符串分配给`format`是"谢谢您捐赠 {0: # # #} 罐食品给我们的慈善组织。" 和`arg0`是一个整数值为 10，返回值将是"谢谢您捐赠 10 罐食品给我们的慈善组织。"  
  
   
  
## Examples  
 下面的示例演示<xref:System.Text.StringBuilder.AppendFormat%2A>方法。  
  
 [!code-cpp[stringbuilder.appendformat#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.appendformat/CPP/appfmt.cpp#1)]
 [!code-csharp[stringbuilder.appendformat#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.appendformat/CS/appfmt.cs#1)]
 [!code-vb[stringbuilder.appendformat#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.appendformat/VB/appfmt.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="format" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.FormatException">
          <paramref name="format" /> 无效。  
  
或 
格式项的索引小于 0（零），或者大于或等于 1。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">扩展的字符串的长度将超过 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</exception>
        <block subset="none" type="usage">
          <para>中[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]和[!INCLUDE[net_v45](~/includes/net-v45-md.md)]，当您实例化<see cref="T:System.Text.StringBuilder" />对象通过调用<see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" />构造函数，长度和容量<see cref="T:System.Text.StringBuilder" />实例可以增长到的值超过其<see cref="P:System.Text.StringBuilder.MaxCapacity" />属性。发生这种情况尤其是当您调用<see cref="M:System.Text.StringBuilder.Append(System.String)" />和<see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" />追加小型字符串的方法。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="AppendFormat">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendFormat (string format, params object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendFormat(string format, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendFormat (format As String, ParamArray args As Object()) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendFormat(System::String ^ format, ... cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="member this.AppendFormat : string * obj[] -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendFormat (format, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="format">复合格式字符串。</param>
        <param name="args">要设置其格式的对象的数组。</param>
        <summary>向此实例追加通过处理复合格式字符串（包含零个或更多格式项）而返回的字符串。 每个格式项都由参数数组中相应参数的字符串表示形式替换。</summary>
        <returns>对追加了 <paramref name="format" /> 的此实例的引用。 <paramref name="format" /> 中的每个格式项都由相应的对象参数的字符串表示形式替换。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法使用[复合格式设置功能](~/docs/standard/base-types/composite-formatting.md)的.NET Framework，才能将对象的值转换为其文本表示形式并将该表示形式嵌入在当前<xref:System.Text.StringBuilder>对象。  
  
 `format`参数由零个或多个文本与零个或多个索引占位符称为格式项，此方法的参数列表中的对象相对应的混合。 格式设置过程将每个格式项替换相应的对象的字符串表示形式。  
  
 格式项的语法如下所示：  
  
 {*索引*[，*长度*] [:*formatString*]}  
  
 括号中的元素是可选的。 下表对每个元素进行了描述。  
  
|元素|描述|  
|-------------|-----------------|  
|*index*|参数列表中要进行格式化的对象的从零开始位置。 如果指定的对象*索引*是`null`，格式项都替换为<xref:System.String.Empty?displayProperty=nameWithType>。 如果在没有参数*索引*位置，<xref:System.FormatException>引发。|  
|*长度*|最小参数的字符串表示形式中的字符数。 如果为正数，该参数为右对齐;如果为负数，它是左对齐。|  
|:*格式字符串*|由参数支持标准或自定义格式字符串。|  
  
> [!NOTE]
>  有关使用日期和时间值的标准和自定义格式字符串，请参阅[标准日期和时间格式字符串](~/docs/standard/base-types/standard-date-and-time-format-strings.md)并[自定义日期和时间格式字符串](~/docs/standard/base-types/custom-date-and-time-format-strings.md)。 对于标准和自定义格式字符串与数值一起使用，请参阅[标准数字格式字符串](~/docs/standard/base-types/standard-numeric-format-strings.md)并[自定义数字格式字符串](~/docs/standard/base-types/custom-numeric-format-strings.md)。 用于枚举的标准格式字符串，请参阅[枚举格式字符串](~/docs/standard/base-types/enumeration-format-strings.md)。  
  
 `args` 表示要设置格式的对象。 在每个格式项`format`中的相应对象的字符串表示形式替换`args`。 如果格式项包括`formatString`和中的相应对象`args`实现<xref:System.IFormattable>接口，则`args[index].ToString(formatString, provider)`定义格式设置。 否则为`args[index].ToString()`定义格式设置。  
  
 如果字符串分配给`format`是"谢谢您捐赠 {0: # # #} 罐食品给我们的慈善组织。" 和`arg0`是一个整数值为 10，返回值将是"谢谢您捐赠 10 罐食品给我们的慈善组织。"  
  
   
  
## Examples  
 下面的示例演示<xref:System.Text.StringBuilder.AppendFormat%2A>方法。  
  
 [!code-cpp[stringbuilder.appendformat#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.appendformat/CPP/appfmt.cpp#1)]
 [!code-csharp[stringbuilder.appendformat#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.appendformat/CS/appfmt.cs#1)]
 [!code-vb[stringbuilder.appendformat#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.appendformat/VB/appfmt.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="format" /> 或 <paramref name="args" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.FormatException">
          <paramref name="format" /> 无效。  
  
或 
格式项的索引小于 0（零），或者大于或等于 <paramref name="args" /> 数组的长度。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">扩展的字符串的长度将超过 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</exception>
        <block subset="none" type="usage">
          <para>中[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]和[!INCLUDE[net_v45](~/includes/net-v45-md.md)]，当您实例化<see cref="T:System.Text.StringBuilder" />对象通过调用<see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" />构造函数，长度和容量<see cref="T:System.Text.StringBuilder" />实例可以增长到的值超过其<see cref="P:System.Text.StringBuilder.MaxCapacity" />属性。发生这种情况尤其是当您调用<see cref="M:System.Text.StringBuilder.Append(System.String)" />和<see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" />追加小型字符串的方法。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="AppendFormat">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendFormat (IFormatProvider provider, string format, object arg0);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendFormat(class System.IFormatProvider provider, string format, object arg0) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendFormat(System.IFormatProvider,System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendFormat (provider As IFormatProvider, format As String, arg0 As Object) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendFormat(IFormatProvider ^ provider, System::String ^ format, System::Object ^ arg0);" />
      <MemberSignature Language="F#" Value="member this.AppendFormat : IFormatProvider * string * obj -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendFormat (provider, format, arg0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="arg0" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="provider">一个提供区域性特定的格式设置信息的对象。</param>
        <param name="format">复合格式字符串。</param>
        <param name="arg0">要设置格式的对象。</param>
        <summary>向此实例追加通过处理复合格式字符串（包含零个或更多格式项）而返回的字符串。 每个格式项都使用指定的格式提供程序替换为单个参数的字符串表示形式。</summary>
        <returns>完成追加操作后对此实例的引用。 完成追加操作后，此实例包含执行该操作之前已存在的任何数据，并且有一个 <paramref name="format" /> 的副本作为后缀，其中任何格式规范都由 <paramref name="arg0" /> 的字符串表示形式替换。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法使用[复合格式设置功能](~/docs/standard/base-types/composite-formatting.md)的值转换的.NET framework`arg0`为其文本表示形式，并将该表示形式嵌入在当前<xref:System.Text.StringBuilder>对象。  
  
 `format`参数由零个或多个文本和零个或多个索引占位符称为格式项混和组成。 每个格式项的索引必须为零 (0)，因为此方法包括使用单个自变量参数列表。 格式设置过程将每个格式项替换的字符串表示形式`arg0`。  
  
 格式项的语法如下所示：  
  
 {*索引*[，*长度*] [:*formatString*]}  
  
 括号中的元素是可选的。 下表对每个元素进行了描述。  
  
|元素|描述|  
|-------------|-----------------|  
|*index*|参数列表中要进行格式化的对象的从零开始位置。 如果指定的对象*索引*是`null`，格式项都替换为<xref:System.String.Empty?displayProperty=nameWithType>。 在这种情况下，由于<xref:System.Text.StringBuilder.AppendFormat%28System.IFormatProvider%2CSystem.String%2CSystem.Object%29>方法具有一个参数在参数列表中，值*索引*必须始终为 0。 如果不是，<xref:System.FormatException>引发。|  
|*长度*|最小参数的字符串表示形式中的字符数。 如果为正数，该参数为右对齐;如果为负数，它是左对齐。|  
|:*格式字符串*|由参数支持标准或自定义格式字符串。|  
  
> [!NOTE]
>  有关使用日期和时间值的标准和自定义格式字符串，请参阅[标准日期和时间格式字符串](~/docs/standard/base-types/standard-date-and-time-format-strings.md)并[自定义日期和时间格式字符串](~/docs/standard/base-types/custom-date-and-time-format-strings.md)。 对于标准和自定义格式字符串与数值一起使用，请参阅[标准数字格式字符串](~/docs/standard/base-types/standard-numeric-format-strings.md)并[自定义数字格式字符串](~/docs/standard/base-types/custom-numeric-format-strings.md)。 用于枚举的标准格式字符串，请参阅[枚举格式字符串](~/docs/standard/base-types/enumeration-format-strings.md)。  
  
 `provider`参数指定<xref:System.IFormatProvider>可以提供格式设置信息中的对象的实现`args`。 `provider` 可以是以下任意形式：  
  
-   一个<xref:System.Globalization.CultureInfo>提供特定于区域性的格式设置信息的对象。  
  
-   一个<xref:System.Globalization.NumberFormatInfo>对象，它提供区域性特定格式设置信息`arg0`如果它是数字值。  
  
-   一个<xref:System.Globalization.DateTimeFormatInfo>对象，它提供区域性特定格式设置信息`arg0`如果它是一个日期和时间值。  
  
-   自定义<xref:System.IFormatProvider>实现，提供的格式设置信息`arg0`。 通常情况下，此类实现还实现<xref:System.ICustomFormatter>接口。  
  
 如果`provider`参数是`null`、 格式设置信息来自当前区域性。  
  
 `arg0` 表示要设置格式的对象。 在每个格式项`format`替换的字符串表示形式`arg0`。 如果格式项包括`formatString`并`arg0`实现<xref:System.IFormattable>接口，则`arg0.ToString(formatString, provider)`定义格式设置。 否则为`arg0.ToString()`定义格式设置。  
  
   
  
## Examples  
 下面包含两个调用<xref:System.Text.StringBuilder.AppendFormat%28System.IFormatProvider%2CSystem.String%2CSystem.Object%29>方法。 同时使用英语 Great Britain (en-GB) 区域性的格式设置约定。 第一个插入的字符串表示形式<xref:System.Decimal>值在结果字符串中的货币。 第二个插入<xref:System.DateTime>字符串值在结果中的两个位置，第一个包括，仅短日期字符串和第二个短时间字符串。  
  
 [!code-csharp[System.Text.StringBuilder.AppendFormat#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.appendformat/cs/appendformat1.cs#2)]
 [!code-vb[System.Text.StringBuilder.AppendFormat#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.appendformat/vb/appendformat1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="format" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.FormatException">
          <paramref name="format" /> 无效。  
  
或 
格式项的索引小于 0（零），或者大于等于一 (1)。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">扩展的字符串的长度将超过 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</exception>
        <block subset="none" type="usage">
          <para>中[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]和[!INCLUDE[net_v45](~/includes/net-v45-md.md)]，当您实例化<see cref="T:System.Text.StringBuilder" />对象通过调用<see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" />构造函数，长度和容量<see cref="T:System.Text.StringBuilder" />实例可以增长到的值超过其<see cref="P:System.Text.StringBuilder.MaxCapacity" />属性。发生这种情况尤其是当您调用<see cref="M:System.Text.StringBuilder.Append(System.String)" />和<see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" />追加小型字符串的方法。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="AppendFormat">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendFormat (IFormatProvider provider, string format, params object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendFormat(class System.IFormatProvider provider, string format, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendFormat(System.IFormatProvider,System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendFormat (provider As IFormatProvider, format As String, ParamArray args As Object()) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendFormat(IFormatProvider ^ provider, System::String ^ format, ... cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="member this.AppendFormat : IFormatProvider * string * obj[] -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendFormat (provider, format, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="provider">一个提供区域性特定的格式设置信息的对象。</param>
        <param name="format">复合格式字符串。</param>
        <param name="args">要设置其格式的对象的数组。</param>
        <summary>向此实例追加通过处理复合格式字符串（包含零个或更多格式项）而返回的字符串。 每个格式项都使用指定的格式提供程序由参数数组中相应参数的字符串表示形式替换。</summary>
        <returns>完成追加操作后对此实例的引用。 完成追加操作后，此实例包含执行该操作之前已存在的任何数据，并且有一个 <paramref name="format" /> 的副本作为后缀，其中任何格式规范都由相应对象参数的字符串表示形式替换。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法使用[复合格式设置功能](~/docs/standard/base-types/composite-formatting.md)的.NET Framework，才能将对象的值转换为其文本表示形式并将该表示形式嵌入在当前<xref:System.Text.StringBuilder>对象。  
  
 `format`参数由零个或多个文本与零个或多个索引占位符称为格式项，此方法的参数列表中的对象相对应的混合。 格式设置过程将每个格式项替换相应的对象的字符串表示形式。  
  
 格式项的语法如下所示：  
  
 {*索引*[，*长度*] [:*formatString*]}  
  
 括号中的元素是可选的。 下表对每个元素进行了描述。  
  
|元素|描述|  
|-------------|-----------------|  
|*index*|参数列表中要进行格式化的对象的从零开始位置。 如果指定的对象*索引*是`null`，格式项都替换为<xref:System.String.Empty?displayProperty=nameWithType>。 如果在没有参数*索引*位置，<xref:System.FormatException>引发。|  
|*长度*|最小参数的字符串表示形式中的字符数。 如果为正数，该参数为右对齐;如果为负数，它是左对齐。|  
|:*格式字符串*|由参数支持标准或自定义格式字符串。|  
  
> [!NOTE]
>  有关使用日期和时间值的标准和自定义格式字符串，请参阅[标准日期和时间格式字符串](~/docs/standard/base-types/standard-date-and-time-format-strings.md)并[自定义日期和时间格式字符串](~/docs/standard/base-types/custom-date-and-time-format-strings.md)。 对于标准和自定义格式字符串与数值一起使用，请参阅[标准数字格式字符串](~/docs/standard/base-types/standard-numeric-format-strings.md)并[自定义数字格式字符串](~/docs/standard/base-types/custom-numeric-format-strings.md)。 用于枚举的标准格式字符串，请参阅[枚举格式字符串](~/docs/standard/base-types/enumeration-format-strings.md)。  
  
 `provider`参数指定<xref:System.IFormatProvider>可以提供格式设置信息中的对象的实现`args`。 `provider` 可以是以下任意形式：  
  
-   一个<xref:System.Globalization.CultureInfo>提供特定于区域性的格式设置信息的对象。  
  
-   一个<xref:System.Globalization.NumberFormatInfo>对象，它提供区域性特定格式设置信息中的数字值`args`。  
  
-   一个<xref:System.Globalization.DateTimeFormatInfo>对象，它提供区域性特定格式设置信息中的日期和时间值`args`。  
  
-   自定义<xref:System.IFormatProvider>实现，提供一个或多个中的对象的格式设置信息`args`。 通常情况下，此类实现还实现<xref:System.ICustomFormatter>接口。 下一节中的第二个示例说明了<xref:System.Text.StringBuilder.AppendFormat%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29?displayProperty=nameWithType>使用自定义方法调用<xref:System.IFormatProvider>实现。  
  
 如果`provider`参数是`null`，从当前区域获得格式提供程序信息。  
  
 `args` 表示要设置格式的对象。 在每个格式项`format`中的相应对象的字符串表示形式替换`args`。 如果格式项包括`formatString`和中的相应对象`args`实现<xref:System.IFormattable>接口，则`args[index].ToString(formatString, provider)`定义格式设置。 否则为`args[index].ToString()`定义格式设置。  
  
   
  
## Examples  
 下面的示例演示<xref:System.Text.StringBuilder.AppendFormat%2A>方法。  
  
 [!code-cpp[stringbuilder.appendformat#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.appendformat/CPP/appfmt.cpp#1)]
 [!code-csharp[stringbuilder.appendformat#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.appendformat/CS/appfmt.cs#1)]
 [!code-vb[stringbuilder.appendformat#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.appendformat/VB/appfmt.vb#1)]  
  
 下面的示例定义一个自定义<xref:System.IFormatProvider>实现名为`CustomerFormatter`后的第四个和第七个数字进行格式设置带有连字符的 10 位客户。 传递给<xref:System.Text.StringBuilder.AppendFormat%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29?displayProperty=nameWithType>方法来创建包含格式化的客户数和客户名称的字符串。  
  
 [!code-csharp[System.Text.StringBuilder.AppendFormat#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.appendformat/cs/customernumberformatter1.cs#1)]
 [!code-vb[System.Text.StringBuilder.AppendFormat#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.appendformat/vb/customernumberformatter1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="format" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.FormatException">
          <paramref name="format" /> 无效。  
  
或 
格式项的索引小于 0（零），或者大于或等于 <paramref name="args" /> 数组的长度。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">扩展的字符串的长度将超过 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</exception>
        <block subset="none" type="usage">
          <para>中[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]和[!INCLUDE[net_v45](~/includes/net-v45-md.md)]，当您实例化<see cref="T:System.Text.StringBuilder" />对象通过调用<see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" />构造函数，长度和容量<see cref="T:System.Text.StringBuilder" />实例可以增长到的值超过其<see cref="P:System.Text.StringBuilder.MaxCapacity" />属性。发生这种情况尤其是当您调用<see cref="M:System.Text.StringBuilder.Append(System.String)" />和<see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" />追加小型字符串的方法。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="AppendFormat">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendFormat (string format, object arg0, object arg1);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendFormat(string format, object arg0, object arg1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendFormat (format As String, arg0 As Object, arg1 As Object) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendFormat(System::String ^ format, System::Object ^ arg0, System::Object ^ arg1);" />
      <MemberSignature Language="F#" Value="member this.AppendFormat : string * obj * obj -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendFormat (format, arg0, arg1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="arg0" Type="System.Object" />
        <Parameter Name="arg1" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="format">复合格式字符串。</param>
        <param name="arg0">要设置格式的第一个对象。</param>
        <param name="arg1">要设置格式的第二个对象。</param>
        <summary>向此实例追加通过处理复合格式字符串（包含零个或更多格式项）而返回的字符串。 每个格式项都替换为这两个参数中任意一个参数的字符串表示形式。</summary>
        <returns>对追加了 <paramref name="format" /> 的此实例的引用。 <paramref name="format" /> 中的每个格式项都由相应的对象参数的字符串表示形式替换。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法使用[复合格式设置功能](~/docs/standard/base-types/composite-formatting.md)的.NET Framework，才能将对象的值转换为其文本表示形式并将该表示形式嵌入在当前<xref:System.Text.StringBuilder>对象。  
  
 `format`参数由零个或多个文本与零个或多个索引占位符称为，对应于格式项混合`arg0`和`arg1`，此方法的参数列表中的两个对象。 格式设置过程将每个格式项替换相应的对象的字符串表示形式。  
  
 格式项的语法如下所示：  
  
 {*索引*[，*长度*] [:*formatString*]}  
  
 括号中的元素是可选的。 下表对每个元素进行了描述。  
  
|元素|描述|  
|-------------|-----------------|  
|*index*|参数列表中要进行格式化的对象的从零开始位置。 如果指定的对象*索引*是`null`，格式项都替换为<xref:System.String.Empty?displayProperty=nameWithType>。 如果在没有参数*索引*位置，<xref:System.FormatException>引发。|  
|*长度*|最小参数的字符串表示形式中的字符数。 如果为正数，该参数为右对齐;如果为负数，它是左对齐。|  
|:*格式字符串*|由参数支持标准或自定义格式字符串。|  
  
> [!NOTE]
>  有关使用日期和时间值的标准和自定义格式字符串，请参阅[标准日期和时间格式字符串](~/docs/standard/base-types/standard-date-and-time-format-strings.md)并[自定义日期和时间格式字符串](~/docs/standard/base-types/custom-date-and-time-format-strings.md)。 对于标准和自定义格式字符串与数值一起使用，请参阅[标准数字格式字符串](~/docs/standard/base-types/standard-numeric-format-strings.md)并[自定义数字格式字符串](~/docs/standard/base-types/custom-numeric-format-strings.md)。 用于枚举的标准格式字符串，请参阅[枚举格式字符串](~/docs/standard/base-types/enumeration-format-strings.md)。  
  
 `arg0` 和`arg1`表示要设置格式的对象。 在每个格式项`format`替换的字符串表示形式`arg0`或`arg1`。 如果格式项包括`formatString`和相应的对象实现<xref:System.IFormattable>接口，则`arg` *x* `.ToString(formatString, provider)`定义的格式设置，其中*x*是自变量的索引。 否则为`arg` *x* `.ToString()`定义格式设置。  
  
 如果字符串分配给`format`是"谢谢您捐赠 {0: # # #} 罐食品给我们的慈善组织。" 和`arg0`是一个整数值为 10，返回值将是"谢谢您捐赠 10 罐食品给我们的慈善组织。"  
  
   
  
## Examples  
 下面的示例演示<xref:System.Text.StringBuilder.AppendFormat%2A>方法。  
  
 [!code-cpp[stringbuilder.appendformat#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.appendformat/CPP/appfmt.cpp#1)]
 [!code-csharp[stringbuilder.appendformat#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.appendformat/CS/appfmt.cs#1)]
 [!code-vb[stringbuilder.appendformat#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.appendformat/VB/appfmt.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="format" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.FormatException">
          <paramref name="format" /> 无效。  
  
或 
格式项的索引小于 0（零），或者大于等于 2。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">扩展的字符串的长度将超过 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</exception>
        <block subset="none" type="usage">
          <para>中[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]和[!INCLUDE[net_v45](~/includes/net-v45-md.md)]，当您实例化<see cref="T:System.Text.StringBuilder" />对象通过调用<see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" />构造函数，长度和容量<see cref="T:System.Text.StringBuilder" />实例可以增长到的值超过其<see cref="P:System.Text.StringBuilder.MaxCapacity" />属性。发生这种情况尤其是当您调用<see cref="M:System.Text.StringBuilder.Append(System.String)" />和<see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" />追加小型字符串的方法。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="AppendFormat">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendFormat (IFormatProvider provider, string format, object arg0, object arg1);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendFormat(class System.IFormatProvider provider, string format, object arg0, object arg1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendFormat(System.IFormatProvider,System.String,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendFormat (provider As IFormatProvider, format As String, arg0 As Object, arg1 As Object) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendFormat(IFormatProvider ^ provider, System::String ^ format, System::Object ^ arg0, System::Object ^ arg1);" />
      <MemberSignature Language="F#" Value="member this.AppendFormat : IFormatProvider * string * obj * obj -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendFormat (provider, format, arg0, arg1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="arg0" Type="System.Object" />
        <Parameter Name="arg1" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="provider">一个提供区域性特定的格式设置信息的对象。</param>
        <param name="format">复合格式字符串。</param>
        <param name="arg0">要设置格式的第一个对象。</param>
        <param name="arg1">要设置格式的第二个对象。</param>
        <summary>向此实例追加通过处理复合格式字符串（包含零个或更多格式项）而返回的字符串。 每个格式项都使用指定的格式提供程序替换为两个参数中任一个的字符串表示形式。</summary>
        <returns>完成追加操作后对此实例的引用。 完成追加操作后，此实例包含执行该操作之前已存在的任何数据，并且有一个 <paramref name="format" /> 的副本作为后缀，其中任何格式规范都由相应对象参数的字符串表示形式替换。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法使用[复合格式设置功能](~/docs/standard/base-types/composite-formatting.md)的.NET Framework，才能将对象的值转换为其文本表示形式并将该表示形式嵌入在当前<xref:System.Text.StringBuilder>对象。  
  
 `format`参数由零个或多个文本与零个或多个索引占位符称为格式项，此方法的参数列表中的对象相对应的混合。 格式设置过程将每个格式项替换相应的对象的字符串表示形式。  
  
 格式项的语法如下所示：  
  
 {*索引*[，*长度*] [:*formatString*]}  
  
 括号中的元素是可选的。 下表对每个元素进行了描述。  
  
|元素|描述|  
|-------------|-----------------|  
|*index*|参数列表中要进行格式化的对象的从零开始位置。 如果指定的对象*索引*是`null`，格式项都替换为<xref:System.String.Empty?displayProperty=nameWithType>。 如果在没有参数*索引*位置，<xref:System.FormatException>引发。|  
|*长度*|最小参数的字符串表示形式中的字符数。 如果为正数，该参数为右对齐;如果为负数，它是左对齐。|  
|:*格式字符串*|由参数支持标准或自定义格式字符串。|  
  
> [!NOTE]
>  有关使用日期和时间值的标准和自定义格式字符串，请参阅[标准日期和时间格式字符串](~/docs/standard/base-types/standard-date-and-time-format-strings.md)并[自定义日期和时间格式字符串](~/docs/standard/base-types/custom-date-and-time-format-strings.md)。 对于标准和自定义格式字符串与数值一起使用，请参阅[标准数字格式字符串](~/docs/standard/base-types/standard-numeric-format-strings.md)并[自定义数字格式字符串](~/docs/standard/base-types/custom-numeric-format-strings.md)。 用于枚举的标准格式字符串，请参阅[枚举格式字符串](~/docs/standard/base-types/enumeration-format-strings.md)。  
  
 `provider`参数指定<xref:System.IFormatProvider>实现，它可以提供格式设置信息`arg0`和`arg1`。 `provider` 可以是以下任意形式：  
  
-   一个<xref:System.Globalization.CultureInfo>提供特定于区域性的格式设置信息的对象。  
  
-   一个<xref:System.Globalization.NumberFormatInfo>对象，它提供区域性特定格式设置信息`arg0`或`arg1`如果它们是数字值。  
  
-   一个<xref:System.Globalization.DateTimeFormatInfo>对象，它提供区域性特定格式设置信息`arg0`或`arg1`如果它们是日期和时间值。  
  
-   自定义<xref:System.IFormatProvider>实现，提供的格式设置信息`arg0`和`arg1`。 通常情况下，此类实现还实现<xref:System.ICustomFormatter>接口。  
  
 如果`provider`参数是`null`，从当前区域获得格式提供程序信息。  
  
 `arg0` 和`arg1`表示要设置格式的对象。 在每个格式项`format`将替换为具有相应的索引的对象的字符串表示形式。 如果格式项包括`formatString`并实现相应的参数<xref:System.IFormattable>接口，则参数的`ToString(formatString, provider)`方法定义的格式设置。 否则为参数的`ToString()`方法定义的格式设置。  
  
   
  
## Examples  
 下面的示例使用<xref:System.Text.StringBuilder.AppendFormat%28System.IFormatProvider%2CSystem.String%2CSystem.Object%2CSystem.Object%29>方法来显示时间和温度数据存储在一个泛型<xref:System.Collections.Generic.Dictionary%602>对象。 请注意格式字符串具有三个格式项，尽管仅向要格式化的对象。 这是因为在使用两个格式项列表 （日期和时间值） 中的第一个对象： 第一个格式项显示时，第二个显示的日期。  
  
 [!code-csharp[System.Text.StringBuilder.AppendFormat#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.appendformat/cs/appendformat2.cs#3)]
 [!code-vb[System.Text.StringBuilder.AppendFormat#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.appendformat/vb/appendformat2.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="format" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.FormatException">
          <paramref name="format" /> 无效。  
  
或 
格式项的索引小于 0（零）或者大于或等于 2。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">扩展的字符串的长度将超过 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</exception>
        <block subset="none" type="usage">
          <para>中[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]和[!INCLUDE[net_v45](~/includes/net-v45-md.md)]，当您实例化<see cref="T:System.Text.StringBuilder" />对象通过调用<see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" />构造函数，长度和容量<see cref="T:System.Text.StringBuilder" />实例可以增长到的值超过其<see cref="P:System.Text.StringBuilder.MaxCapacity" />属性。发生这种情况尤其是当您调用<see cref="M:System.Text.StringBuilder.Append(System.String)" />和<see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" />追加小型字符串的方法。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="AppendFormat">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendFormat (string format, object arg0, object arg1, object arg2);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendFormat(string format, object arg0, object arg1, object arg2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendFormat (format As String, arg0 As Object, arg1 As Object, arg2 As Object) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendFormat(System::String ^ format, System::Object ^ arg0, System::Object ^ arg1, System::Object ^ arg2);" />
      <MemberSignature Language="F#" Value="member this.AppendFormat : string * obj * obj * obj -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendFormat (format, arg0, arg1, arg2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="arg0" Type="System.Object" />
        <Parameter Name="arg1" Type="System.Object" />
        <Parameter Name="arg2" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="format">复合格式字符串。</param>
        <param name="arg0">要设置格式的第一个对象。</param>
        <param name="arg1">要设置格式的第二个对象。</param>
        <param name="arg2">要设置格式的第三个对象。</param>
        <summary>向此实例追加通过处理复合格式字符串（包含零个或更多格式项）而返回的字符串。 每个格式项都替换为这三个参数中任意一个参数的字符串表示形式。</summary>
        <returns>对追加了 <paramref name="format" /> 的此实例的引用。 <paramref name="format" /> 中的每个格式项都由相应的对象参数的字符串表示形式替换。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法使用[复合格式设置功能](~/docs/standard/base-types/composite-formatting.md)的.NET Framework，才能将对象的值转换为其文本表示形式并将该表示形式嵌入在当前<xref:System.Text.StringBuilder>对象。  
  
 `format`参数由零个或多个文本与零个或多个索引占位符称为，对应于格式项混合`arg0`通过`arg2`，此方法的参数列表中的对象。 格式设置过程将每个格式项替换相应的对象的字符串表示形式。  
  
 格式项的语法如下所示：  
  
 {*索引*[，*长度*] [:*formatString*]}  
  
 括号中的元素是可选的。 下表对每个元素进行了描述。  
  
|元素|描述|  
|-------------|-----------------|  
|*index*|参数列表中要进行格式化的对象的从零开始位置。 如果指定的对象*索引*是`null`，格式项都替换为<xref:System.String.Empty?displayProperty=nameWithType>。 如果在没有参数*索引*位置，<xref:System.FormatException>引发。|  
|*长度*|最小参数的字符串表示形式中的字符数。 如果为正数，该参数为右对齐;如果为负数，它是左对齐。|  
|:*格式字符串*|由参数支持标准或自定义格式字符串。|  
  
> [!NOTE]
>  有关使用日期和时间值的标准和自定义格式字符串，请参阅[标准日期和时间格式字符串](~/docs/standard/base-types/standard-date-and-time-format-strings.md)并[自定义日期和时间格式字符串](~/docs/standard/base-types/custom-date-and-time-format-strings.md)。 对于标准和自定义格式字符串与数值一起使用，请参阅[标准数字格式字符串](~/docs/standard/base-types/standard-numeric-format-strings.md)并[自定义数字格式字符串](~/docs/standard/base-types/custom-numeric-format-strings.md)。 用于枚举的标准格式字符串，请参阅[枚举格式字符串](~/docs/standard/base-types/enumeration-format-strings.md)。  
  
 `arg0``arg1`，和`arg2`表示要设置格式的对象。 在每个格式项`format`替换的字符串表示形式`arg0`， `arg1`，或`arg2`，取决于格式项的索引。 如果格式项包括`formatString`和中的相应对象`args`实现<xref:System.IFormattable>接口，则`arg` *x* `.ToString(formatString, null)`定义格式设置，其中*x*是自变量的索引。 否则为`arg` *x* `.ToString()`定义格式设置。  
  
 如果字符串分配给`format`是"谢谢您捐赠 {0: # # #} 罐食品给我们的慈善组织。" 和`arg0`是一个整数值为 10，返回值将是"谢谢您捐赠 10 罐食品给我们的慈善组织。"  
  
   
  
## Examples  
 下面的示例演示<xref:System.Text.StringBuilder.AppendFormat%2A>方法。  
  
 [!code-cpp[stringbuilder.appendformat#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.appendformat/CPP/appfmt.cpp#1)]
 [!code-csharp[stringbuilder.appendformat#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.appendformat/CS/appfmt.cs#1)]
 [!code-vb[stringbuilder.appendformat#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.appendformat/VB/appfmt.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="format" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.FormatException">
          <paramref name="format" /> 无效。  
  
或 
格式项的索引小于 0（零）或者大于或等于 3。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">扩展的字符串的长度将超过 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</exception>
        <block subset="none" type="usage">
          <para>中[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]和[!INCLUDE[net_v45](~/includes/net-v45-md.md)]，当您实例化<see cref="T:System.Text.StringBuilder" />对象通过调用<see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" />构造函数，长度和容量<see cref="T:System.Text.StringBuilder" />实例可以增长到的值超过其<see cref="P:System.Text.StringBuilder.MaxCapacity" />属性。发生这种情况尤其是当您调用<see cref="M:System.Text.StringBuilder.Append(System.String)" />和<see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" />追加小型字符串的方法。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="AppendFormat">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendFormat (IFormatProvider provider, string format, object arg0, object arg1, object arg2);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendFormat(class System.IFormatProvider provider, string format, object arg0, object arg1, object arg2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendFormat(System.IFormatProvider,System.String,System.Object,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendFormat (provider As IFormatProvider, format As String, arg0 As Object, arg1 As Object, arg2 As Object) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendFormat(IFormatProvider ^ provider, System::String ^ format, System::Object ^ arg0, System::Object ^ arg1, System::Object ^ arg2);" />
      <MemberSignature Language="F#" Value="member this.AppendFormat : IFormatProvider * string * obj * obj * obj -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendFormat (provider, format, arg0, arg1, arg2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="arg0" Type="System.Object" />
        <Parameter Name="arg1" Type="System.Object" />
        <Parameter Name="arg2" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="provider">一个提供区域性特定的格式设置信息的对象。</param>
        <param name="format">复合格式字符串。</param>
        <param name="arg0">要设置格式的第一个对象。</param>
        <param name="arg1">要设置格式的第二个对象。</param>
        <param name="arg2">要设置格式的第三个对象。</param>
        <summary>向此实例追加通过处理复合格式字符串（包含零个或更多格式项）而返回的字符串。 每个格式项都使用指定的格式提供程序替换为三个参数中任一个的字符串表示形式。</summary>
        <returns>完成追加操作后对此实例的引用。 完成追加操作后，此实例包含执行该操作之前已存在的任何数据，并且有一个 <paramref name="format" /> 的副本作为后缀，其中任何格式规范都由相应对象参数的字符串表示形式替换。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法使用[复合格式设置功能](~/docs/standard/base-types/composite-formatting.md)的.NET Framework，才能将对象的值转换为其文本表示形式并将该表示形式嵌入在当前<xref:System.Text.StringBuilder>对象。  
  
 `format`参数由零个或多个文本与零个或多个索引占位符称为格式项，此方法的参数列表中的对象相对应的混合。 格式设置过程将每个格式项替换相应的对象的字符串表示形式。  
  
 格式项的语法如下所示：  
  
 {*索引*[，*长度*] [:*formatString*]}  
  
 括号中的元素是可选的。 下表对每个元素进行了描述。  
  
|元素|描述|  
|-------------|-----------------|  
|*index*|参数列表中要进行格式化的对象的从零开始位置。 如果指定的对象*索引*是`null`，格式项都替换为<xref:System.String.Empty?displayProperty=nameWithType>。 如果在没有参数*索引*位置，<xref:System.FormatException>引发。|  
|*长度*|最小参数的字符串表示形式中的字符数。 如果为正数，该参数为右对齐;如果为负数，它是左对齐。|  
|:*格式字符串*|由参数支持标准或自定义格式字符串。|  
  
> [!NOTE]
>  有关使用日期和时间值的标准和自定义格式字符串，请参阅[标准日期和时间格式字符串](~/docs/standard/base-types/standard-date-and-time-format-strings.md)并[自定义日期和时间格式字符串](~/docs/standard/base-types/custom-date-and-time-format-strings.md)。 对于标准和自定义格式字符串与数值一起使用，请参阅[标准数字格式字符串](~/docs/standard/base-types/standard-numeric-format-strings.md)并[自定义数字格式字符串](~/docs/standard/base-types/custom-numeric-format-strings.md)。 用于枚举的标准格式字符串，请参阅[枚举格式字符串](~/docs/standard/base-types/enumeration-format-strings.md)。  
  
 `provider`参数指定<xref:System.IFormatProvider>实现，它可以提供格式设置信息`arg0`和`arg1`。 `provider` 可以是以下任意形式：  
  
-   一个<xref:System.Globalization.CultureInfo>提供特定于区域性的格式设置信息的对象。  
  
-   一个<xref:System.Globalization.NumberFormatInfo>对象，它提供区域性特定格式设置信息`arg0`或`arg1`如果它们是数字值。  
  
-   一个<xref:System.Globalization.DateTimeFormatInfo>对象，它提供区域性特定格式设置信息`arg0`， `arg1`，或`arg2`如果它们是日期和时间值。  
  
-   自定义<xref:System.IFormatProvider>实现，提供的格式设置信息`arg0`， `arg1`，和`arg2`。 通常情况下，此类实现还实现<xref:System.ICustomFormatter>接口。  
  
 如果`provider`参数是`null`，从当前区域获得格式提供程序信息。  
  
 `arg0``arg1`，和`arg2`表示要设置格式的对象。 在每个格式项`format`将替换为具有相应的索引的对象的字符串表示形式。 如果格式项包括`formatString`并实现相应的参数<xref:System.IFormattable>接口，则参数的`ToString(formatString, provider)`方法定义的格式设置。 否则为参数的`ToString()`方法定义的格式设置。  
  
   
  
## Examples  
 下面的示例使用<xref:System.Text.StringBuilder.AppendFormat%28System.IFormatProvider%2CSystem.String%2CSystem.Object%2CSystem.Object%2CSystem.Object%29>方法来说明这一个布尔值结果`And`的整数值的操作。 请注意，格式字符串包括六个格式项，但该方法具有在其自变量列表中，只有三个项，因为每个项格式化两个不同的方式。  
  
 [!code-csharp[System.Text.StringBuilder.AppendFormat#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.appendformat/cs/appendformat3.cs#4)]
 [!code-vb[System.Text.StringBuilder.AppendFormat#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.appendformat/vb/appendformat3.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="format" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.FormatException">
          <paramref name="format" /> 无效。  
  
或 
格式项的索引小于 0（零）或者大于或等于 3。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">扩展的字符串的长度将超过 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</exception>
        <block subset="none" type="usage">
          <para>中[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]和[!INCLUDE[net_v45](~/includes/net-v45-md.md)]，当您实例化<see cref="T:System.Text.StringBuilder" />对象通过调用<see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" />构造函数，长度和容量<see cref="T:System.Text.StringBuilder" />实例可以增长到的值超过其<see cref="P:System.Text.StringBuilder.MaxCapacity" />属性。发生这种情况尤其是当您调用<see cref="M:System.Text.StringBuilder.Append(System.String)" />和<see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" />追加小型字符串的方法。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="AppendJoin">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendJoin (char separator, params object[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendJoin(char separator, object[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendJoin(System.Char,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendJoin (separator As Char, ParamArray values As Object()) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendJoin(char separator, ... cli::array &lt;System::Object ^&gt; ^ values);" />
      <MemberSignature Language="F#" Value="member this.AppendJoin : char * obj[] -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendJoin (separator, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char" />
        <Parameter Name="values" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="separator">To be added.</param>
        <param name="values">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AppendJoin">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendJoin (char separator, params string[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendJoin(char separator, string[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendJoin(System.Char,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendJoin (separator As Char, ParamArray values As String()) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendJoin(char separator, ... cli::array &lt;System::String ^&gt; ^ values);" />
      <MemberSignature Language="F#" Value="member this.AppendJoin : char * string[] -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendJoin (separator, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char" />
        <Parameter Name="values" Type="System.String[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="separator">To be added.</param>
        <param name="values">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AppendJoin">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendJoin (string separator, params object[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendJoin(string separator, object[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendJoin(System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendJoin (separator As String, ParamArray values As Object()) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendJoin(System::String ^ separator, ... cli::array &lt;System::Object ^&gt; ^ values);" />
      <MemberSignature Language="F#" Value="member this.AppendJoin : string * obj[] -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendJoin (separator, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String" />
        <Parameter Name="values" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="separator">To be added.</param>
        <param name="values">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AppendJoin">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendJoin (string separator, params string[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendJoin(string separator, string[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendJoin(System.String,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendJoin (separator As String, ParamArray values As String()) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendJoin(System::String ^ separator, ... cli::array &lt;System::String ^&gt; ^ values);" />
      <MemberSignature Language="F#" Value="member this.AppendJoin : string * string[] -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendJoin (separator, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String" />
        <Parameter Name="values" Type="System.String[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="separator">To be added.</param>
        <param name="values">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AppendJoin&lt;T&gt;">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendJoin&lt;T&gt; (char separator, System.Collections.Generic.IEnumerable&lt;T&gt; values);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendJoin&lt;T&gt;(char separator, class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendJoin``1(System.Char,System.Collections.Generic.IEnumerable{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendJoin(Of T) (separator As Char, values As IEnumerable(Of T)) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; System::Text::StringBuilder ^ AppendJoin(char separator, System::Collections::Generic::IEnumerable&lt;T&gt; ^ values);" />
      <MemberSignature Language="F#" Value="member this.AppendJoin : char * seq&lt;'T&gt; -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendJoin (separator, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="separator" Type="System.Char" />
        <Parameter Name="values" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="separator">To be added.</param>
        <param name="values">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AppendJoin&lt;T&gt;">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendJoin&lt;T&gt; (string separator, System.Collections.Generic.IEnumerable&lt;T&gt; values);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendJoin&lt;T&gt;(string separator, class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendJoin``1(System.String,System.Collections.Generic.IEnumerable{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendJoin(Of T) (separator As String, values As IEnumerable(Of T)) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; System::Text::StringBuilder ^ AppendJoin(System::String ^ separator, System::Collections::Generic::IEnumerable&lt;T&gt; ^ values);" />
      <MemberSignature Language="F#" Value="member this.AppendJoin : string * seq&lt;'T&gt; -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendJoin (separator, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="separator" Type="System.String" />
        <Parameter Name="values" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="separator">To be added.</param>
        <param name="values">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AppendLine">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>将默认的行终止符（或指定字符串的副本和默认的行终止符）追加到此实例的末尾。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AppendLine">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendLine ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendLine() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendLine" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendLine () As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendLine();" />
      <MemberSignature Language="F#" Value="member this.AppendLine : unit -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendLine " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>将默认的行终止符追加到当前 <see cref="T:System.Text.StringBuilder" /> 对象的末尾。</summary>
        <returns>完成追加操作后对此实例的引用。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 默认行终止符的当前值是否是<xref:System.Environment.NewLine%2A?displayProperty=nameWithType>属性。  
  
 根据需要调整此实例的容量。  
  
   
  
## Examples  
 下面的示例演示<xref:System.Text.StringBuilder.AppendLine%2A>方法。  
  
 [!code-cpp[stringbuilder.appendline#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.appendline/CPP/al.cpp#1)]
 [!code-csharp[stringbuilder.appendline#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.appendline/CS/al.cs#1)]
 [!code-vb[stringbuilder.appendline#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.appendline/VB/al.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">增大此实例的值将超过 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</exception>
        <block subset="none" type="usage">
          <para>中[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]和[!INCLUDE[net_v45](~/includes/net-v45-md.md)]，当您实例化<see cref="T:System.Text.StringBuilder" />对象通过调用<see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" />构造函数，长度和容量<see cref="T:System.Text.StringBuilder" />实例可以增长到的值超过其<see cref="P:System.Text.StringBuilder.MaxCapacity" />属性。发生这种情况尤其是当您调用<see cref="M:System.Text.StringBuilder.Append(System.String)" />和<see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" />追加小型字符串的方法。</para>
        </block>
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName="AppendLine">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendLine (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendLine(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendLine(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendLine (value As String) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendLine(System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.AppendLine : string -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendLine value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">要追加的字符串。</param>
        <summary>将后面跟有默认行终止符的指定字符串的副本追加到当前 <see cref="T:System.Text.StringBuilder" /> 对象的末尾。</summary>
        <returns>完成追加操作后对此实例的引用。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 默认行终止符的当前值是否是<xref:System.Environment.NewLine%2A?displayProperty=nameWithType>属性。  
  
 根据需要调整此实例的容量。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">增大此实例的值将超过 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</exception>
        <block subset="none" type="usage">
          <para>中[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]和[!INCLUDE[net_v45](~/includes/net-v45-md.md)]，当您实例化<see cref="T:System.Text.StringBuilder" />对象通过调用<see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" />构造函数，长度和容量<see cref="T:System.Text.StringBuilder" />实例可以增长到的值超过其<see cref="P:System.Text.StringBuilder.MaxCapacity" />属性。发生这种情况尤其是当您调用<see cref="M:System.Text.StringBuilder.Append(System.String)" />和<see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" />追加小型字符串的方法。</para>
        </block>
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName="Capacity">
      <MemberSignature Language="C#" Value="public int Capacity { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Capacity" />
      <MemberSignature Language="DocId" Value="P:System.Text.StringBuilder.Capacity" />
      <MemberSignature Language="VB.NET" Value="Public Property Capacity As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Capacity { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.Capacity : int with get, set" Usage="System.Text.StringBuilder.Capacity" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置可包含在当前实例所分配的内存中的最大字符数。</summary>
        <value>可包含在当前实例所分配的内存中的最大字符数。 其值可以从 <see cref="P:System.Text.StringBuilder.Length" /> 到 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.StringBuilder.Capacity%2A> 不会影响当前实例的字符串值。 <xref:System.Text.StringBuilder.Capacity%2A> 因为它不是可以缩小小于<xref:System.Text.StringBuilder.Length%2A>。  
  
 <xref:System.Text.StringBuilder>动态分配时所需的更多空间并增加<xref:System.Text.StringBuilder.Capacity%2A>相应地。 出于性能原因，<xref:System.Text.StringBuilder>可能会分配比所需的更多内存。 分配量是内存的特定于实现的。  
  
   
  
## Examples  
 下面的示例演示<xref:System.Text.StringBuilder.Capacity%2A>属性。  
  
 [!code-cpp[stringbuilder.ensurecapacity#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.ensurecapacity/CPP/cap.cpp#1)]
 [!code-csharp[stringbuilder.ensurecapacity#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.ensurecapacity/CS/cap.cs#1)]
 [!code-vb[stringbuilder.ensurecapacity#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.ensurecapacity/VB/cap.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">为集运算指定的值小于此实例的当前长度。  
  
或 
为集运算指定的值大于最大容量。</exception>
      </Docs>
    </Member>
    <Member MemberName="Chars">
      <MemberSignature Language="C#" Value="public char this[int index] { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance char Chars(int32)" />
      <MemberSignature Language="DocId" Value="P:System.Text.StringBuilder.Chars(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Default Public Property Chars(index As Integer) As Char" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property char default[int] { char get(int index); void set(int index, char value); };" />
      <MemberSignature Language="F#" Value="member this.Chars(int) : char with get, set" Usage="System.Text.StringBuilder.Chars" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">字符的位置。</param>
        <summary>获取或设置此实例中指定字符位置处的字符。</summary>
        <value>
          <paramref name="index" /> 位置处的 Unicode 字符。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `index`参数是字符内的字符位置<xref:System.Text.StringBuilder>。 在字符串中的第一个字符位于索引 0 处。 字符串的长度是它包含的字符数。 可访问的最后一个字符<xref:System.Text.StringBuilder>实例位于索引<xref:System.Text.StringBuilder.Length%2A>-1。  
  
 <xref:System.Text.StringBuilder.Chars%2A> 是默认属性<xref:System.Text.StringBuilder>类。 在 C# 中，它是一个索引器。 这意味着可以从检索单个字符<xref:System.Text.StringBuilder.Chars%2A>属性中所示下面的示例计数的字母数字、 空格，并在字符串中的标点字符。  
  
 [!code-csharp[System.Text.StringBuilder.Chars#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.chars/cs/chars1.cs#1)]
 [!code-vb[System.Text.StringBuilder.Chars#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.chars/vb/chars1.vb#1)]  

### <a name="performance-and-character-based-indexing"></a>性能和基于字符的索引

[!INCLUDE[stringbuilder-performance-note](~/includes/stringbuilder-perf-note.md)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">设置字符时，<paramref name="index" /> 在此实例的范围之外。</exception>
        <exception cref="T:System.IndexOutOfRangeException">获取字符时，<paramref name="index" /> 在此实例的范围之外。</exception>
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Clear" />
      <MemberSignature Language="VB.NET" Value="Public Function Clear () As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Clear();" />
      <MemberSignature Language="F#" Value="member this.Clear : unit -&gt; System.Text.StringBuilder" Usage="stringBuilder.Clear " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>从当前 <see cref="T:System.Text.StringBuilder" /> 实例中移除所有字符。</summary>
        <returns>其 <see cref="P:System.Text.StringBuilder.Length" /> 为 0（零）的对象。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.StringBuilder.Clear%2A> 是一种便利方法，它等效于设置<xref:System.Text.StringBuilder.Length%2A>为 0 （零） 的当前实例的属性。  
  
 调用<xref:System.Text.StringBuilder.Clear%2A>方法不会修改当前实例的<xref:System.Text.StringBuilder.Capacity%2A>或<xref:System.Text.StringBuilder.MaxCapacity%2A>属性。  
  
   
  
## Examples  
 下面的示例实例化<xref:System.Text.StringBuilder>对象的字符串，调用<xref:System.Text.StringBuilder.Clear%2A>方法，，然后将追加一个新的字符串。  
  
 [!code-csharp[System.Text.StringBuilder.Clear#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.clear/cs/clear1.cs#1)]
 [!code-vb[System.Text.StringBuilder.Clear#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.clear/vb/clear1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (int sourceIndex, Span&lt;char&gt; destination, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CopyTo(int32 sourceIndex, valuetype System.Span`1&lt;char&gt; destination, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.CopyTo(System.Int32,System.Span{System.Char},System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyTo (sourceIndex As Integer, destination As Span(Of Char), count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyTo(int sourceIndex, Span&lt;char&gt; destination, int count);" />
      <MemberSignature Language="F#" Value="member this.CopyTo : int * Span&lt;char&gt; * int -&gt; unit" Usage="stringBuilder.CopyTo (sourceIndex, destination, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceIndex" Type="System.Int32" />
        <Parameter Name="destination" Type="System.Span&lt;System.Char&gt;" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="sourceIndex">To be added.</param>
        <param name="destination">To be added.</param>
        <param name="count">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (int sourceIndex, char[] destination, int destinationIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CopyTo(int32 sourceIndex, char[] destination, int32 destinationIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.CopyTo(System.Int32,System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyTo (sourceIndex As Integer, destination As Char(), destinationIndex As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyTo(int sourceIndex, cli::array &lt;char&gt; ^ destination, int destinationIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.CopyTo : int * char[] * int * int -&gt; unit" Usage="stringBuilder.CopyTo (sourceIndex, destination, destinationIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceIndex" Type="System.Int32" />
        <Parameter Name="destination" Type="System.Char[]" />
        <Parameter Name="destinationIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="sourceIndex">此实例中开始复制字符的位置。 索引是从零开始的。</param>
        <param name="destination">将从中复制字符的数组。</param>
        <param name="destinationIndex">
          <c>destination</c> 中将从其开始复制字符的起始位置。 索引是从零开始的。</param>
        <param name="count">要复制的字符数。</param>
        <summary>将此实例的指定段中的字符复制到目标 <see cref="T:System.Char" /> 数组的指定段中。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.StringBuilder.CopyTo%2A>方法旨在时您需要高效地将复制的连续部分在极少数情况下使用<xref:System.Text.StringBuilder>到一个数组对象。 数组应为固定的大小，预分配、 可重用的和可能是全局访问。  
  
 例如，你的应用程序无法填充<xref:System.Text.StringBuilder>对象具有大量字符，然后使用<xref:System.Text.StringBuilder.CopyTo%2A>方法将复制的连续的小部分<xref:System.Text.StringBuilder>到一个数组，其中处理各个部分的对象。 当中的所有数据<xref:System.Text.StringBuilder>处理对象时，大小<xref:System.Text.StringBuilder>对象设置为零，并且重复周期。  
  
   
  
## Examples  
 下面的示例演示<xref:System.Text.StringBuilder.CopyTo%2A>方法。  
  
 [!code-cpp[stringbuilder.copyto2#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.copyto2/CPP/ct2.cpp#1)]
 [!code-csharp[stringbuilder.copyto2#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.copyto2/CS/ct2.cs#1)]
 [!code-vb[stringbuilder.copyto2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.copyto2/VB/ct2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="destination" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="sourceIndex" />、<paramref name="destinationIndex" /> 或 <paramref name="count" /> 小于零。  
  
或 
 <paramref name="sourceIndex" /> 大于此实例的长度。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="sourceIndex" /> + <paramref name="count" /> 大于此实例的长度。  
  
或 
 <paramref name="destinationIndex" /> + <paramref name="count" /> 大于 <paramref name="destination" /> 的长度。</exception>
      </Docs>
    </Member>
    <Member MemberName="EnsureCapacity">
      <MemberSignature Language="C#" Value="public int EnsureCapacity (int capacity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EnsureCapacity(int32 capacity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.EnsureCapacity(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function EnsureCapacity (capacity As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EnsureCapacity(int capacity);" />
      <MemberSignature Language="F#" Value="member this.EnsureCapacity : int -&gt; int" Usage="stringBuilder.EnsureCapacity capacity" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="capacity" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="capacity">要确保的最小容量。</param>
        <summary>确保 <see cref="T:System.Text.StringBuilder" /> 的此实例的容量至少是指定值。</summary>
        <returns>此实例的新容量。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果当前容量为小于`capacity`参数，此实例重新分配内存以容纳至少`capacity`字符数; 否则为更改任何内存。  
  
   
  
## Examples  
 下面的示例演示<xref:System.Text.StringBuilder.EnsureCapacity%2A>方法。  
  
 [!code-cpp[stringbuilder.ensurecapacity#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.ensurecapacity/CPP/cap.cpp#1)]
 [!code-csharp[stringbuilder.ensurecapacity#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.ensurecapacity/CS/cap.cs#1)]
 [!code-vb[stringbuilder.ensurecapacity#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.ensurecapacity/VB/cap.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="capacity" /> 小于零。  
  
或 
增大此实例的值将超过 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (ReadOnlySpan&lt;char&gt; span);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Equals(valuetype System.ReadOnlySpan`1&lt;char&gt; span) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Equals(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (span As ReadOnlySpan(Of Char)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Equals(ReadOnlySpan&lt;char&gt; span);" />
      <MemberSignature Language="F#" Value="override this.Equals : ReadOnlySpan&lt;char&gt; -&gt; bool" Usage="stringBuilder.Equals span" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="span" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
      </Parameters>
      <Docs>
        <param name="span">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (System.Text.StringBuilder sb);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Equals(class System.Text.StringBuilder sb) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Equals(System.Text.StringBuilder)" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (sb As StringBuilder) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Equals(System::Text::StringBuilder ^ sb);" />
      <MemberSignature Language="F#" Value="override this.Equals : System.Text.StringBuilder -&gt; bool" Usage="stringBuilder.Equals sb" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sb" Type="System.Text.StringBuilder" />
      </Parameters>
      <Docs>
        <param name="sb">与此实例进行比较的对象，或为 <see langword="null" />。</param>
        <summary>返回一个值，该值指示此实例是否等于指定的对象。</summary>
        <returns>如果此实例和 <paramref name="sb" /> 具有相等的字符串、<see cref="P:System.Text.StringBuilder.Capacity" /> 和 <see cref="P:System.Text.StringBuilder.MaxCapacity" /> 值，则为 <see langword="true" />；否则，为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下面的代码使用<xref:System.Text.StringBuilder.Equals%2A>方法，用于检查两个<xref:System.Text.StringBuilder>对象是否相等。 较小的更改都会对每个对象，并将结果显示到控制台后，将重复调用该方法。  
  
 [!code-cpp[stringbuilder.ensurecapacity#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.ensurecapacity/CPP/cap.cpp#1)]
 [!code-csharp[stringbuilder.ensurecapacity#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.ensurecapacity/CS/cap.cs#1)]
 [!code-vb[stringbuilder.ensurecapacity#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.ensurecapacity/VB/cap.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Insert">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>将指定对象的字符串表示形式插入到此实例中的指定字符位置。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, bool value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, bool value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As Boolean) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, bool value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * bool -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="index">此实例中开始插入的位置。</param>
        <param name="value">要插入的值。</param>
        <summary>将布尔值的字符串表示形式插入到此实例中的指定字符位置。</summary>
        <returns>完成插入操作后对此实例的引用。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Boolean.ToString%2A?displayProperty=nameWithType> 用于获取的字符串表示形式`value`。 移动现有字符的新文本留出空间。 根据需要调整容量。  
  
   
  
## Examples  
 下面的示例演示<xref:System.Text.StringBuilder.Insert%2A>方法。  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> 小于零或大于此实例的长度。</exception>
        <exception cref="T:System.OutOfMemoryException">增大此实例的值将超过 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</exception>
        <block subset="none" type="usage">
          <para>在中[!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)]和早期版本中，调用此方法引发<see cref="T:System.ArgumentOutOfRangeException" />如果插入<paramref name="value" />会导致对象的总长度超过<see cref="P:System.Text.StringBuilder.MaxCapacity" />。从开始[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]，该方法将引发<see cref="T:System.OutOfMemoryException" />。</para>
        </block>
        <altmember cref="T:System.Boolean" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, byte value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, unsigned int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Byte)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As Byte) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, System::Byte value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * byte -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Byte" />
      </Parameters>
      <Docs>
        <param name="index">此实例中开始插入的位置。</param>
        <param name="value">要插入的值。</param>
        <summary>将指定的 8 位无符号整数的字符串表示形式插入到此实例中的指定字符位置。</summary>
        <returns>完成插入操作后对此实例的引用。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Byte.ToString%2A?displayProperty=nameWithType> 用于获取的字符串表示形式`value`。 移动现有字符的新文本留出空间。 根据需要调整此实例的容量。  
  
   
  
## Examples  
 下面的示例演示<xref:System.Text.StringBuilder.Insert%2A>方法。  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> 小于零或大于此实例的长度。</exception>
        <exception cref="T:System.OutOfMemoryException">增大此实例的值将超过 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</exception>
        <block subset="none" type="usage">
          <para>在中[!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)]和早期版本中，调用此方法引发<see cref="T:System.ArgumentOutOfRangeException" />如果插入<paramref name="value" />会导致对象的总长度超过<see cref="P:System.Text.StringBuilder.MaxCapacity" />。从开始[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]，该方法将引发<see cref="T:System.OutOfMemoryException" />。</para>
        </block>
        <altmember cref="T:System.Byte" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, char value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, char value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As Char) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, char value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * char -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="index">此实例中开始插入的位置。</param>
        <param name="value">要插入的值。</param>
        <summary>将指定的 Unicode 字符的字符串表示形式插入到此实例中的指定位置。</summary>
        <returns>完成插入操作后对此实例的引用。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Char.ToString%2A?displayProperty=nameWithType> 用于获取的字符串表示形式`value`。 移动现有字符的新文本留出空间。 根据需要调整此实例的容量。  
  
   
  
## Examples  
 下面的示例演示<xref:System.Text.StringBuilder.Insert%2A>方法。  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> 小于零或大于此实例的长度。  
  
或 
增大此实例的值将超过 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</exception>
        <altmember cref="T:System.Char" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, char[] value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, char[] value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As Char()) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, cli::array &lt;char&gt; ^ value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * char[] -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Char[]" />
      </Parameters>
      <Docs>
        <param name="index">此实例中开始插入的位置。</param>
        <param name="value">要插入的字符数组。</param>
        <summary>将指定的 Unicode 字符数组的字符串表示形式插入到此实例中的指定字符位置。</summary>
        <returns>完成插入操作后对此实例的引用。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 移动现有字符的新文本留出空间。 根据需要调整此实例的容量。  
  
 如果`value`是`null`，则<xref:System.Text.StringBuilder>不会更改。  
  
   
  
## Examples  
 下面的示例演示<xref:System.Text.StringBuilder.Insert%2A>方法。  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> 小于零或大于此实例的长度。  
  
或 
增大此实例的值将超过 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, decimal value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, valuetype System.Decimal value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Decimal)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As Decimal) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, System::Decimal value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * decimal -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="index">此实例中开始插入的位置。</param>
        <param name="value">要插入的值。</param>
        <summary>将十进制数的字符串表示形式插入到此实例中的指定字符位置。</summary>
        <returns>完成插入操作后对此实例的引用。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Decimal.ToString%2A?displayProperty=nameWithType> 用于获取的字符串表示形式`value`。 移动现有字符的新文本留出空间。 根据需要调整此实例的容量。  
  
   
  
## Examples  
 下面的示例演示<xref:System.Text.StringBuilder.Insert%2A>方法。  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> 小于零或大于此实例的长度。</exception>
        <exception cref="T:System.OutOfMemoryException">增大此实例的值将超过 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</exception>
        <block subset="none" type="usage">
          <para>在中[!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)]和早期版本中，调用此方法引发<see cref="T:System.ArgumentOutOfRangeException" />如果插入<paramref name="value" />会导致对象的总长度超过<see cref="P:System.Text.StringBuilder.MaxCapacity" />。从开始[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]，该方法将引发<see cref="T:System.OutOfMemoryException" />。</para>
        </block>
        <altmember cref="T:System.Decimal" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, double value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As Double) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, double value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * double -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="index">此实例中开始插入的位置。</param>
        <param name="value">要插入的值。</param>
        <summary>将双精度浮点数的字符串表示形式插入到此实例中的指定字符位置。</summary>
        <returns>完成插入操作后对此实例的引用。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Double.ToString%2A?displayProperty=nameWithType> 用于获取的字符串表示形式`value`。 移动现有字符的新文本留出空间。 根据需要调整此实例的容量。  
  
   
  
## Examples  
 下面的示例演示<xref:System.Text.StringBuilder.Insert%2A>方法。  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> 小于零或大于此实例的长度。</exception>
        <exception cref="T:System.OutOfMemoryException">增大此实例的值将超过 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</exception>
        <block subset="none" type="usage">
          <para>在中[!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)]和早期版本中，调用此方法引发<see cref="T:System.ArgumentOutOfRangeException" />如果插入<paramref name="value" />会导致对象的总长度超过<see cref="P:System.Text.StringBuilder.MaxCapacity" />。从开始[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]，该方法将引发<see cref="T:System.OutOfMemoryException" />。</para>
        </block>
        <altmember cref="T:System.Double" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, short value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Int16)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As Short) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, short value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * int16 -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="index">此实例中开始插入的位置。</param>
        <param name="value">要插入的值。</param>
        <summary>将指定的 16 位带符号整数的字符串表示形式插入到此实例中的指定字符位置。</summary>
        <returns>完成插入操作后对此实例的引用。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Int16.ToString%2A?displayProperty=nameWithType> 用于获取的字符串表示形式`value`。 移动现有字符的新文本留出空间。 根据需要调整此实例的容量。  
  
   
  
## Examples  
 下面的示例演示<xref:System.Text.StringBuilder.Insert%2A>方法。  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> 小于零或大于此实例的长度。</exception>
        <exception cref="T:System.OutOfMemoryException">增大此实例的值将超过 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</exception>
        <block subset="none" type="usage">
          <para>在中[!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)]和早期版本中，调用此方法引发<see cref="T:System.ArgumentOutOfRangeException" />如果插入<paramref name="value" />会导致对象的总长度超过<see cref="P:System.Text.StringBuilder.MaxCapacity" />。从开始[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]，该方法将引发<see cref="T:System.OutOfMemoryException" />。</para>
        </block>
        <altmember cref="T:System.Int16" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, int value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As Integer) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, int value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * int -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">此实例中开始插入的位置。</param>
        <param name="value">要插入的值。</param>
        <summary>将指定的 32 位带符号整数的字符串表示形式插入到此实例中的指定字符位置。</summary>
        <returns>完成插入操作后对此实例的引用。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Int32.ToString%2A?displayProperty=nameWithType> 用于获取的字符串表示形式`value`。 移动现有字符的新文本留出空间。 根据需要调整此实例的容量。  
  
   
  
## Examples  
 下面的示例演示<xref:System.Text.StringBuilder.Insert%2A>方法。  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> 小于零或大于此实例的长度。</exception>
        <exception cref="T:System.OutOfMemoryException">增大此实例的值将超过 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</exception>
        <block subset="none" type="usage">
          <para>在中[!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)]和早期版本中，调用此方法引发<see cref="T:System.ArgumentOutOfRangeException" />如果插入<paramref name="value" />会导致对象的总长度超过<see cref="P:System.Text.StringBuilder.MaxCapacity" />。从开始[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]，该方法将引发<see cref="T:System.OutOfMemoryException" />。</para>
        </block>
        <altmember cref="T:System.Int32" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, long value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As Long) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, long value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * int64 -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="index">此实例中开始插入的位置。</param>
        <param name="value">要插入的值。</param>
        <summary>将 64 位带符号整数的字符串表示形式插入到此实例中的指定字符位置。</summary>
        <returns>完成插入操作后对此实例的引用。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Int64.ToString%2A?displayProperty=nameWithType> 用于获取的字符串表示形式`value`。 移动现有字符的新文本留出空间。 根据需要调整此实例的容量。  
  
   
  
## Examples  
 下面的示例演示<xref:System.Text.StringBuilder.Insert%2A>方法。  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> 小于零或大于此实例的长度。</exception>
        <exception cref="T:System.OutOfMemoryException">增大此实例的值将超过 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</exception>
        <block subset="none" type="usage">
          <para>在中[!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)]和早期版本中，调用此方法引发<see cref="T:System.ArgumentOutOfRangeException" />如果插入<paramref name="value" />会导致对象的总长度超过<see cref="P:System.Text.StringBuilder.MaxCapacity" />。从开始[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]，该方法将引发<see cref="T:System.OutOfMemoryException" />。</para>
        </block>
        <altmember cref="T:System.Int64" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As Object) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * obj -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="index">此实例中开始插入的位置。</param>
        <param name="value">要插入的对象，或 <see langword="null" />。</param>
        <summary>将对象的字符串表示形式插入到此实例中的指定字符位置。</summary>
        <returns>完成插入操作后对此实例的引用。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Object.ToString%2A?displayProperty=nameWithType> 用于获取的字符串表示形式`value`。 移动现有字符的新文本留出空间。 根据需要调整此实例的容量。  
  
 如果`value`是`null`，此实例的值保持不变。  
  
   
  
## Examples  
 下面的示例演示<xref:System.Text.StringBuilder.Insert%2A>方法。  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> 小于零或大于此实例的长度。</exception>
        <exception cref="T:System.OutOfMemoryException">增大此实例的值将超过 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</exception>
        <block subset="none" type="usage">
          <para>在中[!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)]和早期版本中，调用此方法引发<see cref="T:System.ArgumentOutOfRangeException" />如果插入<paramref name="value" />会导致对象的总长度超过<see cref="P:System.Text.StringBuilder.MaxCapacity" />。从开始[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]，该方法将引发<see cref="T:System.OutOfMemoryException" />。</para>
        </block>
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, ReadOnlySpan&lt;char&gt; value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, valuetype System.ReadOnlySpan`1&lt;char&gt; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As ReadOnlySpan(Of Char)) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, ReadOnlySpan&lt;char&gt; value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * ReadOnlySpan&lt;char&gt; -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
      </Parameters>
      <Docs>
        <param name="index">To be added.</param>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, sbyte value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.SByte)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As SByte) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, System::SByte value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * sbyte -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.SByte" />
      </Parameters>
      <Docs>
        <param name="index">此实例中开始插入的位置。</param>
        <param name="value">要插入的值。</param>
        <summary>将指定的 8 位带符号整数的字符串表示形式插入到此实例中的指定字符位置。</summary>
        <returns>完成插入操作后对此实例的引用。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.SByte.ToString%2A?displayProperty=nameWithType> 用于获取的字符串表示形式`value`。 移动现有字符的新文本留出空间。 根据需要调整容量。  
  
   
  
## Examples  
 下面的示例演示<xref:System.Text.StringBuilder.Insert%2A>方法。  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> 小于零或大于此实例的长度。</exception>
        <exception cref="T:System.OutOfMemoryException">增大此实例的值将超过 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</exception>
        <block subset="none" type="usage">
          <para>在中[!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)]和早期版本中，调用此方法引发<see cref="T:System.ArgumentOutOfRangeException" />如果插入<paramref name="value" />会导致对象的总长度超过<see cref="P:System.Text.StringBuilder.MaxCapacity" />。从开始[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]，该方法将引发<see cref="T:System.OutOfMemoryException" />。</para>
        </block>
        <altmember cref="T:System.SByte" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, float value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, float32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As Single) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, float value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * single -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="index">此实例中开始插入的位置。</param>
        <param name="value">要插入的值。</param>
        <summary>将单精度浮点数的字符串表示形式插入到此实例中的指定字符位置。</summary>
        <returns>完成插入操作后对此实例的引用。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Single.ToString%2A?displayProperty=nameWithType> 用于获取的字符串表示形式`value`。 移动现有字符的新文本留出空间。 根据需要调整此实例的容量。  
  
   
  
## Examples  
 下面的示例演示<xref:System.Text.StringBuilder.Insert%2A>方法。  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> 小于零或大于此实例的长度。</exception>
        <exception cref="T:System.OutOfMemoryException">增大此实例的值将超过 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</exception>
        <block subset="none" type="usage">
          <para>在中[!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)]和早期版本中，调用此方法引发<see cref="T:System.ArgumentOutOfRangeException" />如果插入<paramref name="value" />会导致对象的总长度超过<see cref="P:System.Text.StringBuilder.MaxCapacity" />。从开始[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]，该方法将引发<see cref="T:System.OutOfMemoryException" />。</para>
        </block>
        <altmember cref="T:System.Single" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As String) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * string -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="index">此实例中开始插入的位置。</param>
        <param name="value">要插入的字符串。</param>
        <summary>将字符串插入到此实例中的指定字符位置。</summary>
        <returns>完成插入操作后对此实例的引用。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 移动现有字符的新文本留出空间。 根据需要调整容量。  
  
 此实例的<xref:System.Text.StringBuilder>不会更改它，如果`value`是`null`，或`value`不是`null`但其长度为零。  
  
   
  
## Examples  
 下面的示例演示<xref:System.Text.StringBuilder.Insert%2A>方法。  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> 小于零或大于此实例的当前长度。  
  
或 
此 <see cref="T:System.Text.StringBuilder" /> 对象的当前长度加上 <paramref name="value" /> 的长度超过 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</exception>
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, ushort value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, unsigned int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.UInt16)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As UShort) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, System::UInt16 value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * uint16 -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.UInt16" />
      </Parameters>
      <Docs>
        <param name="index">此实例中开始插入的位置。</param>
        <param name="value">要插入的值。</param>
        <summary>将 16 位无符号整数的字符串表示形式插入到此实例中的指定字符位置。</summary>
        <returns>完成插入操作后对此实例的引用。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.UInt16.ToString%2A?displayProperty=nameWithType> 用于获取的字符串表示形式`value`。 移动现有字符的新文本留出空间。 根据需要调整此实例的容量。  
  
   
  
## Examples  
 下面的示例演示<xref:System.Text.StringBuilder.Insert%2A>方法。  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> 小于零或大于此实例的长度。</exception>
        <exception cref="T:System.OutOfMemoryException">增大此实例的值将超过 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</exception>
        <block subset="none" type="usage">
          <para>在中[!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)]和早期版本中，调用此方法引发<see cref="T:System.ArgumentOutOfRangeException" />如果插入<paramref name="value" />会导致对象的总长度超过<see cref="P:System.Text.StringBuilder.MaxCapacity" />。从开始[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]，该方法将引发<see cref="T:System.OutOfMemoryException" />。</para>
        </block>
        <altmember cref="T:System.UInt16" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, uint value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, unsigned int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.UInt32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As UInteger) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, System::UInt32 value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * uint32 -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.UInt32" />
      </Parameters>
      <Docs>
        <param name="index">此实例中开始插入的位置。</param>
        <param name="value">要插入的值。</param>
        <summary>将 32 位无符号整数的字符串表示形式插入到此实例中的指定字符位置。</summary>
        <returns>完成插入操作后对此实例的引用。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.UInt32.ToString%2A?displayProperty=nameWithType> 用于获取的字符串表示形式`value`。 移动现有字符的新文本留出空间。 根据需要调整此实例的容量。  
  
   
  
## Examples  
 下面的示例演示<xref:System.Text.StringBuilder.Insert%2A>方法。  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> 小于零或大于此实例的长度。</exception>
        <exception cref="T:System.OutOfMemoryException">增大此实例的值将超过 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</exception>
        <block subset="none" type="usage">
          <para>在中[!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)]和早期版本中，调用此方法引发<see cref="T:System.ArgumentOutOfRangeException" />如果插入<paramref name="value" />会导致对象的总长度超过<see cref="P:System.Text.StringBuilder.MaxCapacity" />。从开始[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]，该方法将引发<see cref="T:System.OutOfMemoryException" />。</para>
        </block>
        <altmember cref="T:System.UInt32" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, ulong value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, unsigned int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As ULong) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, System::UInt64 value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * uint64 -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="index">此实例中开始插入的位置。</param>
        <param name="value">要插入的值。</param>
        <summary>将 64 位无符号整数的字符串表示形式插入到此实例中的指定字符位置。</summary>
        <returns>完成插入操作后对此实例的引用。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.UInt64.ToString%2A?displayProperty=nameWithType> 用于获取的字符串表示形式`value`。 移动现有字符的新文本留出空间。 根据需要调整此实例的容量。  
  
   
  
## Examples  
 下面的示例演示<xref:System.Text.StringBuilder.Insert%2A>方法。  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> 小于零或大于此实例的长度。</exception>
        <exception cref="T:System.OutOfMemoryException">增大此实例的值将超过 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</exception>
        <block subset="none" type="usage">
          <para>在中[!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)]和早期版本中，调用此方法引发<see cref="T:System.ArgumentOutOfRangeException" />如果插入<paramref name="value" />会导致对象的总长度超过<see cref="P:System.Text.StringBuilder.MaxCapacity" />。从开始[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]，该方法将引发<see cref="T:System.OutOfMemoryException" />。</para>
        </block>
        <altmember cref="T:System.UInt64" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, string value, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, string value, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As String, count As Integer) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, System::String ^ value, int count);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * string * int -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">此实例中开始插入的位置。</param>
        <param name="value">要插入的字符串。</param>
        <param name="count">要插入 <c>value</c> 的次数。</param>
        <summary>将指定字符串的一个或更多副本插入到此实例中的指定字符位置。</summary>
        <returns>完成插入后对此实例的引用。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 移动现有字符的新文本留出空间。 根据需要调整此实例的容量。  
  
 这<xref:System.Text.StringBuilder>如果对象不会更改`value`是`null`，`value`不是`null`但其长度为零，或`count`为零。  
  
   
  
## Examples  
 下面的示例演示<xref:System.Text.StringBuilder.Insert%2A>方法。  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> 小于零或大于此实例的当前长度。  
  
或 
 <paramref name="count" /> 小于零。</exception>
        <exception cref="T:System.OutOfMemoryException">此 <see cref="T:System.Text.StringBuilder" /> 对象的当前长度加上 <paramref name="value" /> 的长度乘以 <paramref name="count" /> 的值超过 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</exception>
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, char[] value, int startIndex, int charCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, char[] value, int32 startIndex, int32 charCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As Char(), startIndex As Integer, charCount As Integer) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, cli::array &lt;char&gt; ^ value, int startIndex, int charCount);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * char[] * int * int -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value, startIndex, charCount)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Char[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="charCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">此实例中开始插入的位置。</param>
        <param name="value">字符数组。</param>
        <param name="startIndex">
          <c>value</c> 中的起始索引。</param>
        <param name="charCount">要插入的字符数。</param>
        <summary>将指定的 Unicode 字符子数组的字符串表示形式插入到此实例中的指定字符位置。</summary>
        <returns>完成插入操作后对此实例的引用。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 移动现有字符的新文本留出空间。 根据需要调整此实例的容量。  
  
   
  
## Examples  
 下面的示例演示<xref:System.Text.StringBuilder.Insert%2A>方法。  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> 为 <see langword="null" />，且 <paramref name="startIndex" /> 和 <paramref name="charCount" /> 不为零。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" />、<paramref name="startIndex" /> 或 <paramref name="charCount" /> 小于零。  
  
或 
 <paramref name="index" /> 大于此实例的长度。  
  
或 
 <paramref name="startIndex" /> 加上 <paramref name="charCount" /> 不是 <paramref name="value" /> 中的位置。  
  
或 
增大此实例的值将超过 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="Length">
      <MemberSignature Language="C#" Value="public int Length { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Length" />
      <MemberSignature Language="DocId" Value="P:System.Text.StringBuilder.Length" />
      <MemberSignature Language="VB.NET" Value="Public Property Length As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Length { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.Length : int with get, set" Usage="System.Text.StringBuilder.Length" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置当前 <see cref="T:System.Text.StringBuilder" /> 对象的长度。</summary>
        <value>此实例的长度。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 长度<xref:System.Text.StringBuilder>对象由其数量定义<xref:System.Char>对象。  
  
 像<xref:System.String.Length%2A?displayProperty=nameWithType>属性，<xref:System.Text.StringBuilder.Length%2A>属性指示当前字符串对象的长度。 与不同<xref:System.String.Length%2A?displayProperty=nameWithType>属性，它是只读的<xref:System.Text.StringBuilder.Length%2A>属性允许您修改存储到字符串的长度<xref:System.Text.StringBuilder>对象。  
  
 如果指定的长度小于当前长度，当前<xref:System.Text.StringBuilder>对象将被截断为指定的长度。 如果指定的长度大于当前长度的字符串值的当前末尾<xref:System.Text.StringBuilder>对象则用 Unicode NULL 字符填充 (U + 0000)。  
  
 如果指定的长度大于当前容量<xref:System.Text.StringBuilder.Capacity%2A>会增加，这样就大于或等于指定长度。  
  
   
  
## Examples  
 下面的示例演示<xref:System.Text.StringBuilder.Length%2A>属性。  
  
 [!code-cpp[stringbuilder.ensurecapacity#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.ensurecapacity/CPP/cap.cpp#1)]
 [!code-csharp[stringbuilder.ensurecapacity#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.ensurecapacity/CS/cap.cs#1)]
 [!code-vb[stringbuilder.ensurecapacity#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.ensurecapacity/VB/cap.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">为设置操作指定的值小于零或大于 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="MaxCapacity">
      <MemberSignature Language="C#" Value="public int MaxCapacity { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MaxCapacity" />
      <MemberSignature Language="DocId" Value="P:System.Text.StringBuilder.MaxCapacity" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MaxCapacity As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int MaxCapacity { int get(); };" />
      <MemberSignature Language="F#" Value="member this.MaxCapacity : int" Usage="System.Text.StringBuilder.MaxCapacity" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取此实例的最大容量。</summary>
        <value>此实例可容纳的最大字符数。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此实现的最大容量<xref:System.Int32.MaxValue?displayProperty=nameWithType>。 但是，此值是特定于实现的可能会在其他或更高版本的实现有所不同。 您可以显式设置的最大容量<xref:System.Text.StringBuilder>对象通过调用<xref:System.Text.StringBuilder.%23ctor%28System.Int32%2CSystem.Int32%29>构造函数。  
  
 中[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]和[!INCLUDE[net_v45](~/includes/net-v45-md.md)]，当您实例化<xref:System.Text.StringBuilder>对象通过调用<xref:System.Text.StringBuilder.%23ctor%28System.Int32%2CSystem.Int32%29>构造函数，长度和容量<xref:System.Text.StringBuilder>实例可以增长到的值超过其<xref:System.Text.StringBuilder.MaxCapacity%2A>属性。 发生这种情况尤其是当您调用<xref:System.Text.StringBuilder.Append%2A>和<xref:System.Text.StringBuilder.AppendFormat%2A>追加小型字符串的方法。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Remove (int startIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Remove(int32 startIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Remove(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Remove (startIndex As Integer, length As Integer) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Remove(int startIndex, int length);" />
      <MemberSignature Language="F#" Value="member this.Remove : int * int -&gt; System.Text.StringBuilder" Usage="stringBuilder.Remove (startIndex, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="startIndex">To be added.</param>
        <param name="length">要删除的字符数。</param>
        <summary>将指定范围的字符从此实例中移除。</summary>
        <returns>切除操作完成后对此实例的引用。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当前方法从当前实例中删除指定的范围的字符。 上的字符 (`startIndex` + `length`) 移动到`startIndex`，并且当前实例的字符串值缩短通过`length`。 当前实例的容量的不受影响。  
  
> [!NOTE]
>  <xref:System.Text.StringBuilder.Remove%2A>方法修改的当前值<xref:System.Text.StringBuilder>实例，并返回该实例。 它不创建和返回一个新<xref:System.Text.StringBuilder>对象。  
  
   
  
## Examples  
 下面的示例演示<xref:System.Text.StringBuilder.Remove%2A>方法。  
  
 [!code-cpp[stringbuilder.remove#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.remove/CPP/remove.cpp#1)]
 [!code-csharp[stringbuilder.remove#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.remove/CS/remove.cs#1)]
 [!code-vb[stringbuilder.remove#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.remove/VB/remove.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">如果 <paramref name="startIndex" /> 或 <paramref name="length" /> 小于零，或者 <paramref name="startIndex" /> + <paramref name="length" /> 大于此实例的长度。</exception>
        <altmember cref="M:System.Text.StringBuilder.Replace(System.String,System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Replace">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>将此实例中出现的所有指定字符或字符串替换为其他的指定字符或字符串。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Replace (char oldChar, char newChar);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Replace(char oldChar, char newChar) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Replace(System.Char,System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (oldChar As Char, newChar As Char) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Replace(char oldChar, char newChar);" />
      <MemberSignature Language="F#" Value="member this.Replace : char * char -&gt; System.Text.StringBuilder" Usage="stringBuilder.Replace (oldChar, newChar)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldChar" Type="System.Char" />
        <Parameter Name="newChar" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="oldChar">要替换的字符。</param>
        <param name="newChar">替换 <c>oldChar</c> 的字符。</param>
        <summary>将此实例中出现的所有指定字符替换为其他指定字符。</summary>
        <returns>对此实例的引用，其中 <paramref name="oldChar" /> 被 <paramref name="newChar" /> 替换。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法执行顺序、 区分大小写比较来标识出现的`oldChar`当前实例中。 当前大小<xref:System.Text.StringBuilder>实例更换后保持不变。  
  
   
  
## Examples  
 下面的示例演示<xref:System.Text.StringBuilder.Replace%2A>方法。  
  
 [!code-cpp[stringbuilder.replace#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.replace/CPP/replace.cpp#1)]
 [!code-csharp[stringbuilder.replace#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.replace/CS/replace.cs#1)]
 [!code-vb[stringbuilder.replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.replace/VB/replace.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Replace (string oldValue, string newValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Replace(string oldValue, string newValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Replace(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (oldValue As String, newValue As String) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Replace(System::String ^ oldValue, System::String ^ newValue);" />
      <MemberSignature Language="F#" Value="member this.Replace : string * string -&gt; System.Text.StringBuilder" Usage="stringBuilder.Replace (oldValue, newValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldValue" Type="System.String" />
        <Parameter Name="newValue" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="oldValue">要替换的字符串。</param>
        <param name="newValue">替换 <c>oldValue</c> 的字符串，或 <see langword="null" />。</param>
        <summary>将此实例中出现的所有指定字符串的替换为其他指定字符串。</summary>
        <returns>对此实例的引用，其中 <paramref name="oldValue" /> 的所有实例被 <paramref name="newValue" /> 替换。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法执行顺序、 区分大小写比较来标识出现的`oldValue`当前实例中。 如果`newValue`是`null`或<xref:System.String.Empty?displayProperty=nameWithType>，出现的所有`oldValue`删除。  
  
   
  
## Examples  
 下面的示例演示<xref:System.Text.StringBuilder.Replace%2A>方法。  
  
 [!code-cpp[stringbuilder.replace#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.replace/CPP/replace.cpp#1)]
 [!code-csharp[stringbuilder.replace#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.replace/CS/replace.cs#1)]
 [!code-vb[stringbuilder.replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.replace/VB/replace.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="oldValue" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="oldValue" /> 的长度为零。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">增大此实例的值将超过 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</exception>
        <altmember cref="M:System.Text.StringBuilder.Remove(System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Replace (char oldChar, char newChar, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Replace(char oldChar, char newChar, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Replace(System.Char,System.Char,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (oldChar As Char, newChar As Char, startIndex As Integer, count As Integer) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Replace(char oldChar, char newChar, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.Replace : char * char * int * int -&gt; System.Text.StringBuilder" Usage="stringBuilder.Replace (oldChar, newChar, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldChar" Type="System.Char" />
        <Parameter Name="newChar" Type="System.Char" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="oldChar">要替换的字符。</param>
        <param name="newChar">替换 <c>oldChar</c> 的字符。</param>
        <param name="startIndex">此实例中子字符串开始的位置。</param>
        <param name="count">子字符串的长度。</param>
        <summary>将此实例的子字符串中出现的所有指定字符替换为其他指定字符。</summary>
        <returns>对此实例的引用，其中从 <paramref name="startIndex" /> 到 <paramref name="startIndex" /> + <paramref name="count" /> -1 范围内的 <paramref name="oldChar" /> 被 <paramref name="newChar" /> 替换。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法执行顺序、 区分大小写比较来标识出现的`oldChar`当前实例中。 当前大小<xref:System.Text.StringBuilder>对象后替换不会更改。  
  
   
  
## Examples  
 下面的示例演示<xref:System.Text.StringBuilder.Replace%2A>方法。  
  
 [!code-cpp[stringbuilder.replace#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.replace/CPP/replace.cpp#1)]
 [!code-csharp[stringbuilder.replace#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.replace/CS/replace.cs#1)]
 [!code-vb[stringbuilder.replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.replace/VB/replace.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> + <paramref name="count" /> 大于此实例的值的长度。  
  
或 
 <paramref name="startIndex" /> 或 <paramref name="count" /> 小于零。</exception>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Replace (string oldValue, string newValue, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Replace(string oldValue, string newValue, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Replace(System.String,System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (oldValue As String, newValue As String, startIndex As Integer, count As Integer) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Replace(System::String ^ oldValue, System::String ^ newValue, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.Replace : string * string * int * int -&gt; System.Text.StringBuilder" Usage="stringBuilder.Replace (oldValue, newValue, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldValue" Type="System.String" />
        <Parameter Name="newValue" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="oldValue">要替换的字符串。</param>
        <param name="newValue">替换 <c>oldValue</c> 的字符串，或 <see langword="null" />。</param>
        <param name="startIndex">此实例中子字符串开始的位置。</param>
        <param name="count">子字符串的长度。</param>
        <summary>将此实例的子字符串中出现的所有指定字符串替换为其他指定字符串。</summary>
        <returns>对此实例的引用，其中从 <paramref name="startIndex" /> 到 <paramref name="startIndex" /> + <paramref name="count" /> - 1 的范围内 <paramref name="oldValue" /> 的所有实例被 <paramref name="newValue" /> 替换。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法执行顺序、 区分大小写比较来标识出现的`oldValue`中指定的子字符串。 如果`newValue`是`null`或<xref:System.String.Empty?displayProperty=nameWithType>，出现的所有`oldValue`删除。  
  
   
  
## Examples  
 下面的示例演示<xref:System.Text.StringBuilder.Replace%2A>方法。  
  
 [!code-cpp[stringbuilder.replace#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.replace/CPP/replace.cpp#1)]
 [!code-csharp[stringbuilder.replace#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.replace/CS/replace.cs#1)]
 [!code-vb[stringbuilder.replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.replace/VB/replace.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="oldValue" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="oldValue" /> 的长度为零。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> 或 <paramref name="count" /> 小于零。  
  
或 
 <paramref name="startIndex" /> 与 <paramref name="count" /> 之和指示一个不在此实例内的字符位置。  
  
或 
增大此实例的值将超过 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</exception>
        <altmember cref="M:System.Text.StringBuilder.Remove(System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.Serialization.ISerializable.GetObjectData">
      <MemberSignature Language="C#" Value="void ISerializable.GetObjectData (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.Serialization.ISerializable.GetObjectData(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.System#Runtime#Serialization#ISerializable#GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Sub GetObjectData (info As SerializationInfo, context As StreamingContext) Implements ISerializable.GetObjectData" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.Serialization.ISerializable.GetObjectData(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context) = System::Runtime::Serialization::ISerializable::GetObjectData;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info">要用序列化信息填充的对象。</param>
        <param name="context">存储和检索序列化数据的位置。 留待将来使用。</param>
        <summary>使用所需的数据填充 <see cref="T:System.Runtime.Serialization.SerializationInfo" /> 对象来反序列化当前 <see cref="T:System.Text.StringBuilder" /> 对象。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `context`参数保留供将来使用，并不参与此操作。  
  
 有关更多信息，请参见 <xref:System.Runtime.Serialization.SerializationInfo.AddValue%28System.String%2CSystem.Object%2CSystem.Type%29?displayProperty=nameWithType> 方法。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="info" /> 为 <see langword="null" />。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直接调用方需要完全信任。 不能由部分受信任的或透明的代码使用此成员。</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="ToString">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>将 <see cref="T:System.Text.StringBuilder" /> 的值转换为 <see cref="T:System.String" />。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="stringBuilder.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>将此实例的值转换为 <see cref="T:System.String" />。</summary>
        <returns>其值与此实例相同的字符串。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 必须调用<xref:System.Text.StringBuilder.ToString%2A>方法将转换<xref:System.Text.StringBuilder>对象传递给<xref:System.String>对象所表示的字符串的传递之前<xref:System.Text.StringBuilder>对象具有方法<xref:System.String>参数或在用户界面中显示它。  
  
   
  
## Examples  
 下面的示例演示如何调用 <xref:System.Text.StringBuilder.ToString%2A> 方法。 此示例摘自一个更大的示例为提供<xref:System.Text.StringBuilder>类。  
  
 [!code-cpp[StringBuilder#5](~/samples/snippets/cpp/VS_Snippets_CLR/StringBuilder/cpp/StringBuilder.cpp#5)]
 [!code-csharp[StringBuilder#5](~/samples/snippets/csharp/VS_Snippets_CLR/StringBuilder/CS/StringBuilder.cs#5)]
 [!code-vb[StringBuilder#5](~/samples/snippets/visualbasic/VS_Snippets_CLR/StringBuilder/VB/StringBuilder.vb#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (int startIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToString(int32 startIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.ToString(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (startIndex As Integer, length As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToString(int startIndex, int length);" />
      <MemberSignature Language="F#" Value="override this.ToString : int * int -&gt; string" Usage="stringBuilder.ToString (startIndex, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="startIndex">此实例内子字符串的起始位置。</param>
        <param name="length">子字符串的长度。</param>
        <summary>将此实例中子字符串的值转换为 <see cref="T:System.String" />。</summary>
        <returns>一个字符串，其值与此实例的指定子字符串相同。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 必须调用<xref:System.Text.StringBuilder.ToString%2A>方法将转换<xref:System.Text.StringBuilder>对象传递给<xref:System.String>对象所表示的字符串的传递之前<xref:System.Text.StringBuilder>对象具有方法<xref:System.String>参数或在用户界面中显示它。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> 或 <paramref name="length" /> 小于零。  
  
或 
<paramref name="startIndex" /> 与 <paramref name="length" /> 的和大于当前实例的长度。</exception>
      </Docs>
    </Member>
  </Members>
</Type>