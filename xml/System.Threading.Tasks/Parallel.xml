<Type Name="Parallel" FullName="System.Threading.Tasks.Parallel">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="9400e38d0e86f78825a1539468c98397e83c3420" />
    <Meta Name="ms.sourcegitcommit" Value="9e06b87bcfa4347dbbaaa4b3cc36b43b93b5badb" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-CN" />
    <Meta Name="ms.lasthandoff" Value="11/20/2018" />
    <Meta Name="ms.locfileid" Value="52236278" />
  </Metadata>
  <TypeSignature Language="C#" Value="public static class Parallel" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit Parallel extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Threading.Tasks.Parallel" />
  <TypeSignature Language="VB.NET" Value="Public Class Parallel" />
  <TypeSignature Language="C++ CLI" Value="public ref class Parallel abstract sealed" />
  <TypeSignature Language="F#" Value="type Parallel = class" />
  <AssemblyInfo>
    <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.3.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>提供对并行循环和区域的支持。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Tasks.Parallel>类提供了用于常见操作这样的循环，为每个循环和执行的一组语句基于库的数据并行替换。  
  
   
  
## Examples  
 此示例演示如何实现使用多个语言构造一个并行循环的几种方法。  
  
 [!code-csharp[System.Threading.Tasks.Parallel#07](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.parallel/cs/parallelintro.cs#07)]
 [!code-vb[System.Threading.Tasks.Parallel#07](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.parallel/vb/parallelintro.vb#07)]  
  
 ]]></format>
    </remarks>
    <threadsafe>所有公共和受保护成员<see cref="T:System.Threading.Tasks.Parallel" />是线程安全的可能从多个线程同时使用。</threadsafe>
    <related type="Article" href="~/docs/standard/parallel-programming/data-parallelism-task-parallel-library.md">数据并行（任务并行库）</related>
    <related type="ExternalDocumentation" href="https://code.msdn.microsoft.com/Samples-for-Parallel-b4b76364">使用.NET Framework 进行并行编程示例</related>
  </Docs>
  <Members>
    <MemberGroup MemberName="For">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>执行 <see langword="for" />（在 Visual Basic 中为 <see langword="For" />）循环，其中可能会并行运行迭代。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="For">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult For (int fromInclusive, int toExclusive, Action&lt;int,System.Threading.Tasks.ParallelLoopState&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult For(int32 fromInclusive, int32 toExclusive, class System.Action`2&lt;int32, class System.Threading.Tasks.ParallelLoopState&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.For(System.Int32,System.Int32,System.Action{System.Int32,System.Threading.Tasks.ParallelLoopState})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function For (fromInclusive As Integer, toExclusive As Integer, body As Action(Of Integer, ParallelLoopState)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::ParallelLoopResult For(int fromInclusive, int toExclusive, Action&lt;int, System::Threading::Tasks::ParallelLoopState ^&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member For : int * int * Action&lt;int, System.Threading.Tasks.ParallelLoopState&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.For (fromInclusive, toExclusive, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fromInclusive" Type="System.Int32" />
        <Parameter Name="toExclusive" Type="System.Int32" />
        <Parameter Name="body" Type="System.Action&lt;System.Int32,System.Threading.Tasks.ParallelLoopState&gt;" />
      </Parameters>
      <Docs>
        <param name="fromInclusive">开始索引（含）。</param>
        <param name="toExclusive">结束索引（不含）。</param>
        <param name="body">将为每个迭代调用一次的委托。</param>
        <summary>执行 <see langword="for" />（在 Visual Basic 中为 <see langword="For" />）循环，其中可能会并行运行迭代，而且可以监视和操作循环的状态。</summary>
        <returns>包含有关已完成的循环部分的信息的结构。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `body`委托会调用一次迭代范围中每个值 (`fromInclusive`， `toExclusive`)。 它提供两个参数：  
  
-   <xref:System.Int32>值，该值表示迭代次数。  
  
-   一个<xref:System.Threading.Tasks.ParallelLoopState>可用于中断循环过早的实例。 <xref:System.Threading.Tasks.ParallelLoopState>由编译器创建对象; 它不能在用户代码中实例化。  
  
 调用<xref:System.Threading.Tasks.ParallelLoopState.Break%2A>方法将通知`for`迭代后当前无需执行的操作。 但是，早于当前的所有迭代一个仍都将需要如果它们尚未准备好执行。  
  
 因此，调用<xref:System.Threading.Tasks.ParallelLoopState.Break%2A>类似于使用中断操作的传统`for`循环中一种语言如 C# 中，但并不是理想的替代： 例如，则之后当前迭代肯定将不会不能保证执行。  
  
 如果当前没有必要之前执行所有迭代，使用<xref:System.Threading.Tasks.ParallelLoopState.Stop%2A>方法而不是使用<xref:System.Threading.Tasks.ParallelLoopState.Break%2A>。 调用<xref:System.Threading.Tasks.ParallelLoopState.Stop%2A>通知`for`循环，它可能会放弃所有剩余迭代，而不考虑是否它们之前或之后的当前迭代，因为所有所需的工作将已完成。 但是，作为与<xref:System.Threading.Tasks.ParallelLoopState.Break%2A>，不有哪些其他迭代不会执行任何保证。  
  
 如果循环已提前结束<xref:System.Threading.Tasks.ParallelLoopResult>返回结构将包含循环的完成的相关信息。  
  
 如果`fromInclusive`大于或等于`toExclusive`，方法将立即返回而不执行任何迭代。  
  
   
  
## Examples  
 下面的示例以并行方式执行最多 100 个循环迭代。 从 1 到 1000 毫秒的随机间隔暂停每次迭代。 随机生成的值确定哪次循环迭代上<xref:System.Threading.Tasks.ParallelLoopState.Break%2A?displayProperty=nameWithType>调用方法。 如示例所示，前者的索引大于任何迭代中的输出<xref:System.Threading.Tasks.ParallelLoopState.LowestBreakIteration%2A?displayProperty=nameWithType>属性值开始后调用<xref:System.Threading.Tasks.ParallelLoopState.Break%2A?displayProperty=nameWithType>方法。  
  
 [!code-csharp[System.Threading.Tasks.ParallelLoopState#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.parallelloopstate/cs/break1.cs#2)]
 [!code-vb[System.Threading.Tasks.ParallelLoopState#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.parallelloopstate/vb/break1.vb#2)]  
  
 因为迭代循环的执行时仍可能<xref:System.Threading.Tasks.ParallelLoopState.Break%2A?displayProperty=nameWithType>方法调用时，每次迭代都会调用<xref:System.Threading.Tasks.ParallelLoopState.ShouldExitCurrentIteration%2A?displayProperty=nameWithType>属性来检查是否已调用另一个迭代<xref:System.Threading.Tasks.ParallelLoopState.Break%2A?displayProperty=nameWithType>方法。 如果属性值为`true`，在迭代检查的值<xref:System.Threading.Tasks.ParallelLoopState.LowestBreakIteration%2A?displayProperty=nameWithType>属性以及它是否大于当前迭代索引值，将立即返回。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="body" /> 参数为 <see langword="null" />。</exception>
        <exception cref="T:System.AggregateException">包含在所有线程上引发的全部单个异常的异常。</exception>
        <altmember cref="T:System.Threading.Tasks.ParallelLoopState" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">并行循环</related>
      </Docs>
    </Member>
    <Member MemberName="For">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult For (int fromInclusive, int toExclusive, Action&lt;int&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult For(int32 fromInclusive, int32 toExclusive, class System.Action`1&lt;int32&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.For(System.Int32,System.Int32,System.Action{System.Int32})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function For (fromInclusive As Integer, toExclusive As Integer, body As Action(Of Integer)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::ParallelLoopResult For(int fromInclusive, int toExclusive, Action&lt;int&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member For : int * int * Action&lt;int&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.For (fromInclusive, toExclusive, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fromInclusive" Type="System.Int32" />
        <Parameter Name="toExclusive" Type="System.Int32" />
        <Parameter Name="body" Type="System.Action&lt;System.Int32&gt;" />
      </Parameters>
      <Docs>
        <param name="fromInclusive">开始索引（含）。</param>
        <param name="toExclusive">结束索引（不含）。</param>
        <param name="body">将为每个迭代调用一次的委托。</param>
        <summary>执行 <see langword="for" />（在 Visual Basic 中为 <see langword="For" />）循环，其中可能会并行运行迭代。</summary>
        <returns>包含有关已完成的循环部分的信息的结构。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `body`委托会调用一次迭代范围中每个值 (`fromInclusive`， `toExclusive`)。 提供使用迭代计数 (<xref:System.Int32>) 作为参数。  
  
 如果`fromInclusive`大于或等于`toExclusive`，方法将立即返回而不执行任何迭代。  
  
   
  
## Examples  
 下面的示例使用<xref:System.Threading.Tasks.Parallel.For%2A>方法 100 调用的委托的生成随机字节值，并计算其总和。  
  
 [!code-csharp[System.Threading.Tasks.Parallel.For#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.parallel.for/cs/for1.cs#1)]
 [!code-vb[System.Threading.Tasks.Parallel.For#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.parallel.for/vb/for1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="body" /> 参数为 <see langword="null" />。</exception>
        <exception cref="T:System.AggregateException">包含在所有线程上引发的全部单个异常的异常。</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">并行循环</related>
      </Docs>
    </Member>
    <Member MemberName="For">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult For (long fromInclusive, long toExclusive, Action&lt;long,System.Threading.Tasks.ParallelLoopState&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult For(int64 fromInclusive, int64 toExclusive, class System.Action`2&lt;int64, class System.Threading.Tasks.ParallelLoopState&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.For(System.Int64,System.Int64,System.Action{System.Int64,System.Threading.Tasks.ParallelLoopState})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function For (fromInclusive As Long, toExclusive As Long, body As Action(Of Long, ParallelLoopState)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::ParallelLoopResult For(long fromInclusive, long toExclusive, Action&lt;long, System::Threading::Tasks::ParallelLoopState ^&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member For : int64 * int64 * Action&lt;int64, System.Threading.Tasks.ParallelLoopState&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.For (fromInclusive, toExclusive, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fromInclusive" Type="System.Int64" />
        <Parameter Name="toExclusive" Type="System.Int64" />
        <Parameter Name="body" Type="System.Action&lt;System.Int64,System.Threading.Tasks.ParallelLoopState&gt;" />
      </Parameters>
      <Docs>
        <param name="fromInclusive">开始索引（含）。</param>
        <param name="toExclusive">结束索引（不含）。</param>
        <param name="body">将为每个迭代调用一次的委托。</param>
        <summary>执行具有 64 位索引的 <see langword="for" />（在 Visual Basic 中为 <see langword="For" />）循环，其中可能会并行运行迭代，而且可以监视和操作循环的状态。</summary>
        <returns>一个 <see cref="T:System.Threading.Tasks.ParallelLoopResult" /> 结构，其中包含有关已完成的循环部分的信息。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `body`委托会调用一次迭代范围中每个值 (`fromInclusive`， `toExclusive`)。 提供使用以下参数： 迭代次数 (<xref:System.Int64>)，和一个<xref:System.Threading.Tasks.ParallelLoopState>可能用于过早中断该循环的实例。  
  
 调用<xref:System.Threading.Tasks.ParallelLoopState.Break%2A>方法将通知`for`迭代后当前无需执行，但在当前数据表之前的所有迭代都执行的操作。  
  
 因此，调用中断是类似于使用中断操作的传统`for`循环中一种语言如 C# 中，但并不是理想的替代： 例如，则不能保证该迭代后当前都不会执行。  
  
 如果当前没有必要之前执行所有迭代，使用<xref:System.Threading.Tasks.ParallelLoopState.Stop%2A>方法而不是使用<xref:System.Threading.Tasks.ParallelLoopState.Break%2A>。 调用<xref:System.Threading.Tasks.ParallelLoopState.Stop%2A>通知`for`循环，它可能会放弃所有剩余迭代，而不考虑是否它们之前或之后的当前迭代，因为所有所需的工作将已完成。 但是，作为与<xref:System.Threading.Tasks.ParallelLoopState.Break%2A>，不有哪些其他迭代不会执行任何保证。  
  
 如果循环已提前结束<xref:System.Threading.Tasks.ParallelLoopResult>返回结构将包含循环的完成的相关信息。  
  
 如果`fromInclusive`大于或等于`toExclusive`，则该方法立即返回而不执行任何迭代。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="body" /> 参数为 <see langword="null" />。</exception>
        <exception cref="T:System.AggregateException">包含在所有线程上引发的全部单个异常的异常。</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">并行循环</related>
      </Docs>
    </Member>
    <Member MemberName="For">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult For (long fromInclusive, long toExclusive, Action&lt;long&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult For(int64 fromInclusive, int64 toExclusive, class System.Action`1&lt;int64&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.For(System.Int64,System.Int64,System.Action{System.Int64})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function For (fromInclusive As Long, toExclusive As Long, body As Action(Of Long)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::ParallelLoopResult For(long fromInclusive, long toExclusive, Action&lt;long&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member For : int64 * int64 * Action&lt;int64&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.For (fromInclusive, toExclusive, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fromInclusive" Type="System.Int64" />
        <Parameter Name="toExclusive" Type="System.Int64" />
        <Parameter Name="body" Type="System.Action&lt;System.Int64&gt;" />
      </Parameters>
      <Docs>
        <param name="fromInclusive">开始索引（含）。</param>
        <param name="toExclusive">结束索引（不含）。</param>
        <param name="body">将为每个迭代调用一次的委托。</param>
        <summary>执行具有 64 位索引的 <see langword="for" />（在 Visual Basic 中为 <see langword="For" />）循环，其中可能会并行运行迭代。</summary>
        <returns>包含有关已完成的循环部分的信息的结构。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `body`委托会调用一次迭代范围中每个值 (`fromInclusive`， `toExclusive`)。 提供使用迭代计数 (<xref:System.Int64>) 作为参数。  
  
 如果`fromInclusive`大于或等于`toExclusive`，方法将立即返回而不执行任何迭代。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="body" /> 参数为 <see langword="null" />。</exception>
        <exception cref="T:System.AggregateException">包含在所有线程上引发的全部单个异常的异常。</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">并行循环</related>
      </Docs>
    </Member>
    <Member MemberName="For">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult For (int fromInclusive, int toExclusive, System.Threading.Tasks.ParallelOptions parallelOptions, Action&lt;int,System.Threading.Tasks.ParallelLoopState&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult For(int32 fromInclusive, int32 toExclusive, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Action`2&lt;int32, class System.Threading.Tasks.ParallelLoopState&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.For(System.Int32,System.Int32,System.Threading.Tasks.ParallelOptions,System.Action{System.Int32,System.Threading.Tasks.ParallelLoopState})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::ParallelLoopResult For(int fromInclusive, int toExclusive, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Action&lt;int, System::Threading::Tasks::ParallelLoopState ^&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member For : int * int * System.Threading.Tasks.ParallelOptions * Action&lt;int, System.Threading.Tasks.ParallelLoopState&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.For (fromInclusive, toExclusive, parallelOptions, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fromInclusive" Type="System.Int32" />
        <Parameter Name="toExclusive" Type="System.Int32" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="body" Type="System.Action&lt;System.Int32,System.Threading.Tasks.ParallelLoopState&gt;" />
      </Parameters>
      <Docs>
        <param name="fromInclusive">开始索引（含）。</param>
        <param name="toExclusive">结束索引（不含）。</param>
        <param name="parallelOptions">一个对象，用于配置此操作的行为。</param>
        <param name="body">将为每个迭代调用一次的委托。</param>
        <summary>执行 <see langword="for" />（在 Visual Basic 中为 <see langword="For" />）循环，其中可能会并行运行迭代，而且可以配置循环选项，可以监视和操作循环的状态。</summary>
        <returns>包含有关已完成的循环部分的信息的结构。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `body`委托会调用一次迭代范围中每个值 (`fromInclusive`， `toExclusive`)。 提供使用以下参数： 迭代次数 (<xref:System.Int32>)，和一个<xref:System.Threading.Tasks.ParallelLoopState>可能用于过早中断该循环的实例。  
  
 如果`fromInclusive`大于或等于`toExclusive`，方法将立即返回而不执行任何迭代。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException">在 <paramref name="parallelOptions" /> 取消的 <see cref="T:System.Threading.CancellationToken" /> 参数。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="body" /> 参数为 <see langword="null" />。  
  
或 
<paramref name="parallelOptions" /> 参数为 <see langword="null" />。</exception>
        <exception cref="T:System.AggregateException">包含在所有线程上引发的全部单个异常的异常。</exception>
        <exception cref="T:System.ObjectDisposedException">在 <paramref name="parallelOptions" /> 中与 <see cref="T:System.Threading.CancellationTokenSource" /> 关联的 <see cref="T:System.Threading.CancellationToken" /> 已被释放。</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">并行循环</related>
      </Docs>
    </Member>
    <Member MemberName="For">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult For (int fromInclusive, int toExclusive, System.Threading.Tasks.ParallelOptions parallelOptions, Action&lt;int&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult For(int32 fromInclusive, int32 toExclusive, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Action`1&lt;int32&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.For(System.Int32,System.Int32,System.Threading.Tasks.ParallelOptions,System.Action{System.Int32})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::ParallelLoopResult For(int fromInclusive, int toExclusive, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Action&lt;int&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member For : int * int * System.Threading.Tasks.ParallelOptions * Action&lt;int&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.For (fromInclusive, toExclusive, parallelOptions, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fromInclusive" Type="System.Int32" />
        <Parameter Name="toExclusive" Type="System.Int32" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="body" Type="System.Action&lt;System.Int32&gt;" />
      </Parameters>
      <Docs>
        <param name="fromInclusive">开始索引（含）。</param>
        <param name="toExclusive">结束索引（不含）。</param>
        <param name="parallelOptions">一个对象，用于配置此操作的行为。</param>
        <param name="body">将为每个迭代调用一次的委托。</param>
        <summary>执行 <see langword="for" />（在 Visual Basic 中为 <see langword="For" />）循环，其中可能会并行运行迭代，而且可以配置循环选项。</summary>
        <returns>包含有关已完成的循环部分的信息的结构。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `body`委托会调用一次迭代范围中每个值 (`fromInclusive`， `toExclusive`)。 提供使用迭代计数 (<xref:System.Int32>) 作为参数。  
  
 如果`fromInclusive`大于或等于`toExclusive`，则该方法立即返回而不执行任何迭代。  
  
   
  
## Examples  
 下面的示例演示如何取消并行循环：  
  
 [!code-csharp[System.Threading.Tasks.Parallel#05](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.parallel/cs/parallelforcancel.cs#05)]
 [!code-vb[System.Threading.Tasks.Parallel#05](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.parallel/vb/parallelforcancel.vb#05)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException">在 <paramref name="parallelOptions" /> 取消的 <see cref="T:System.Threading.CancellationToken" /> 参数。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="body" /> 参数为 <see langword="null" />。  
  
或 
<paramref name="parallelOptions" /> 参数为 <see langword="null" />。</exception>
        <exception cref="T:System.AggregateException">包含在所有线程上引发的全部单个异常的异常。</exception>
        <exception cref="T:System.ObjectDisposedException">在 <paramref name="parallelOptions" /> 中与 <see cref="T:System.Threading.CancellationTokenSource" /> 关联的 <see cref="T:System.Threading.CancellationToken" /> 已被释放。</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">并行循环</related>
      </Docs>
    </Member>
    <Member MemberName="For">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult For (long fromInclusive, long toExclusive, System.Threading.Tasks.ParallelOptions parallelOptions, Action&lt;long,System.Threading.Tasks.ParallelLoopState&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult For(int64 fromInclusive, int64 toExclusive, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Action`2&lt;int64, class System.Threading.Tasks.ParallelLoopState&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.For(System.Int64,System.Int64,System.Threading.Tasks.ParallelOptions,System.Action{System.Int64,System.Threading.Tasks.ParallelLoopState})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::ParallelLoopResult For(long fromInclusive, long toExclusive, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Action&lt;long, System::Threading::Tasks::ParallelLoopState ^&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member For : int64 * int64 * System.Threading.Tasks.ParallelOptions * Action&lt;int64, System.Threading.Tasks.ParallelLoopState&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.For (fromInclusive, toExclusive, parallelOptions, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fromInclusive" Type="System.Int64" />
        <Parameter Name="toExclusive" Type="System.Int64" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="body" Type="System.Action&lt;System.Int64,System.Threading.Tasks.ParallelLoopState&gt;" />
      </Parameters>
      <Docs>
        <param name="fromInclusive">开始索引（含）。</param>
        <param name="toExclusive">结束索引（不含）。</param>
        <param name="parallelOptions">一个对象，用于配置此操作的行为。</param>
        <param name="body">将为每个迭代调用一次的委托。</param>
        <summary>执行具有 64 位索引的 <see langword="for" />（在 Visual Basic 中为 <see langword="For" />）循环，其中可能会并行运行迭代，而且可以配置循环选项，可以监视和操作循环的状态。</summary>
        <returns>包含有关已完成的循环部分的信息的结构。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `body`委托会调用一次迭代范围中每个值 (`fromInclusive`， `toExclusive`)。 提供使用以下参数： 迭代次数 (<xref:System.Int64>)，和一个<xref:System.Threading.Tasks.ParallelLoopState>可能用于过早中断该循环的实例。  
  
 如果`fromInclusive`大于或等于`toExclusive`，方法将立即返回而不执行任何迭代。  
  
   
  
## Examples  
 下面的示例演示如何使用<xref:System.Threading.Tasks.Parallel.For%2A?displayProperty=nameWithType>方法替换<xref:System.Threading.Tasks.ParallelOptions>对象：  
  
 [!code-csharp[System.Threading.Tasks.Parallel#03](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.parallel/cs/parallelfor.cs#03)]
 [!code-vb[System.Threading.Tasks.Parallel#03](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.parallel/vb/parallelfor.vb#03)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException">在 <paramref name="parallelOptions" /> 取消的 <see cref="T:System.Threading.CancellationToken" /> 参数。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="body" /> 参数为 <see langword="null" />。  
  
或 
<paramref name="parallelOptions" /> 参数为 <see langword="null" />。</exception>
        <exception cref="T:System.AggregateException">包含在所有线程上引发的全部单个异常的异常。</exception>
        <exception cref="T:System.ObjectDisposedException">在 <paramref name="parallelOptions" /> 中与 <see cref="T:System.Threading.CancellationTokenSource" /> 关联的 <see cref="T:System.Threading.CancellationToken" /> 已被释放。</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">并行循环</related>
      </Docs>
    </Member>
    <Member MemberName="For">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult For (long fromInclusive, long toExclusive, System.Threading.Tasks.ParallelOptions parallelOptions, Action&lt;long&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult For(int64 fromInclusive, int64 toExclusive, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Action`1&lt;int64&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.For(System.Int64,System.Int64,System.Threading.Tasks.ParallelOptions,System.Action{System.Int64})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::ParallelLoopResult For(long fromInclusive, long toExclusive, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Action&lt;long&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member For : int64 * int64 * System.Threading.Tasks.ParallelOptions * Action&lt;int64&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.For (fromInclusive, toExclusive, parallelOptions, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fromInclusive" Type="System.Int64" />
        <Parameter Name="toExclusive" Type="System.Int64" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="body" Type="System.Action&lt;System.Int64&gt;" />
      </Parameters>
      <Docs>
        <param name="fromInclusive">开始索引（含）。</param>
        <param name="toExclusive">结束索引（不含）。</param>
        <param name="parallelOptions">一个对象，用于配置此操作的行为。</param>
        <param name="body">将为每个迭代调用一次的委托。</param>
        <summary>执行具有 64 位索引的 <see langword="for" />（在 Visual Basic 中为 <see langword="For" />）循环，其中可能会并行运行迭代，而且可以配置循环选项。</summary>
        <returns>包含有关已完成的循环部分的信息的结构。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 支持 64 位索引。 `body`委托会调用一次迭代范围中每个值 (`fromInclusive`， `toExclusive`)。 提供使用迭代计数 (<xref:System.Int64>) 作为参数。  
  
 如果`fromInclusive`大于或等于`toExclusive`，则该方法立即返回而不执行任何迭代。  
  
   
  
## Examples  
 下面的示例演示如何使用<xref:System.Threading.Tasks.ParallelOptions>若要指定自定义任务计划程序：  
  
 [!code-csharp[System.Threading.Tasks.Parallel#06](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.parallel/cs/parallelforwithscheduler.cs#06)]
 [!code-vb[System.Threading.Tasks.Parallel#06](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.parallel/vb/parallelforwithscheduler.vb#06)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException">在 <paramref name="parallelOptions" /> 取消的 <see cref="T:System.Threading.CancellationToken" /> 参数。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="body" /> 参数为 <see langword="null" />。  
  
或 
<paramref name="parallelOptions" /> 参数为 <see langword="null" />。</exception>
        <exception cref="T:System.AggregateException">包含在所有线程上引发的全部单个异常的异常。</exception>
        <exception cref="T:System.ObjectDisposedException">在 <paramref name="parallelOptions" /> 中与 <see cref="T:System.Threading.CancellationTokenSource" /> 关联的 <see cref="T:System.Threading.CancellationToken" /> 已被释放。</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">并行循环</related>
      </Docs>
    </Member>
    <Member MemberName="For&lt;TLocal&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult For&lt;TLocal&gt; (int fromInclusive, int toExclusive, Func&lt;TLocal&gt; localInit, Func&lt;int,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt; body, Action&lt;TLocal&gt; localFinally);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult For&lt;TLocal&gt;(int32 fromInclusive, int32 toExclusive, class System.Func`1&lt;!!TLocal&gt; localInit, class System.Func`4&lt;int32, class System.Threading.Tasks.ParallelLoopState, !!TLocal, !!TLocal&gt; body, class System.Action`1&lt;!!TLocal&gt; localFinally) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.For``1(System.Int32,System.Int32,System.Func{``0},System.Func{System.Int32,System.Threading.Tasks.ParallelLoopState,``0,``0},System.Action{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function For(Of TLocal) (fromInclusive As Integer, toExclusive As Integer, localInit As Func(Of TLocal), body As Func(Of Integer, ParallelLoopState, TLocal, TLocal), localFinally As Action(Of TLocal)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TLocal&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult For(int fromInclusive, int toExclusive, Func&lt;TLocal&gt; ^ localInit, Func&lt;int, System::Threading::Tasks::ParallelLoopState ^, TLocal, TLocal&gt; ^ body, Action&lt;TLocal&gt; ^ localFinally);" />
      <MemberSignature Language="F#" Value="static member For : int * int * Func&lt;'Local&gt; * Func&lt;int, System.Threading.Tasks.ParallelLoopState, 'Local, 'Local&gt; * Action&lt;'Local&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.For (fromInclusive, toExclusive, localInit, body, localFinally)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TLocal" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="fromInclusive" Type="System.Int32" />
        <Parameter Name="toExclusive" Type="System.Int32" />
        <Parameter Name="localInit" Type="System.Func&lt;TLocal&gt;" />
        <Parameter Name="body" Type="System.Func&lt;System.Int32,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt;" />
        <Parameter Name="localFinally" Type="System.Action&lt;TLocal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TLocal">线程本地数据的类型。</typeparam>
        <param name="fromInclusive">开始索引（含）。</param>
        <param name="toExclusive">结束索引（不含）。</param>
        <param name="localInit">用于返回每个任务的本地数据的初始状态的函数委托。</param>
        <param name="body">将为每个迭代调用一次的委托。</param>
        <param name="localFinally">用于对每个任务的本地状态执行一个最终操作的委托。</param>
        <summary>执行具有线程本地数据的 <see langword="for" />（在 Visual Basic 中为 <see langword="For" />）循环，其中可能会并行运行迭代，而且可以监视和操作循环的状态。</summary>
        <returns>包含有关已完成的循环部分的信息的结构。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `body`委托会调用一次迭代范围中每个值 (`fromInclusive`， `toExclusive`)。 提供使用以下参数： 迭代次数 (<xref:System.Int32>)、 一个<xref:System.Threading.Tasks.ParallelLoopState>实例可用于中断循环过早，并可能在同一线程执行的迭代之间共享某些本地状态。  
  
 `localInit`参与循环的执行，这些任务的每个返回初始本地状态的每个任务一次调用委托。 这些初始状态传递给第一个`body`上每个任务的调用。 然后，每个后续正文调用返回传递给下一个正文调用一个可能已修改的状态值。 最后，每个任务上的最后一个正文调用返回传递给的州值`localFinally`委托。 `localFinally`每个任务，每个任务的本地状态执行一个最终操作一次调用委托。 在多个任务; 可能会同时调用此委托因此，必须同步对共享的任何变量的访问。  
  
 <xref:System.Threading.Tasks.Parallel.For%2A?displayProperty=nameWithType>方法可能的现有任务完成其执行生存期内使用多于线程数的更多任务，并替换为新的任务。 这样，基础<xref:System.Threading.Tasks.TaskScheduler>对象机会添加，请更改或删除服务循环的线程。  
  
 如果`fromInclusive`大于或等于`toExclusive`，则该方法立即返回而不执行任何迭代。  
  
 使用此方法的示例，请参阅[如何： 编写具有线程局部变量的 Parallel.For 循环](~/docs/standard/parallel-programming/how-to-write-a-parallel-for-loop-with-thread-local-variables.md)。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="body" /> 参数为 <see langword="null" />。  
  
或 
<paramref name="localInit" /> 参数为 <see langword="null" />。  
  
或 
<paramref name="localFinally" /> 参数为 <see langword="null" />。</exception>
        <exception cref="T:System.AggregateException">包含在所有线程上引发的全部单个异常的异常。</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">并行循环</related>
      </Docs>
    </Member>
    <Member MemberName="For&lt;TLocal&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult For&lt;TLocal&gt; (long fromInclusive, long toExclusive, Func&lt;TLocal&gt; localInit, Func&lt;long,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt; body, Action&lt;TLocal&gt; localFinally);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult For&lt;TLocal&gt;(int64 fromInclusive, int64 toExclusive, class System.Func`1&lt;!!TLocal&gt; localInit, class System.Func`4&lt;int64, class System.Threading.Tasks.ParallelLoopState, !!TLocal, !!TLocal&gt; body, class System.Action`1&lt;!!TLocal&gt; localFinally) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.For``1(System.Int64,System.Int64,System.Func{``0},System.Func{System.Int64,System.Threading.Tasks.ParallelLoopState,``0,``0},System.Action{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function For(Of TLocal) (fromInclusive As Long, toExclusive As Long, localInit As Func(Of TLocal), body As Func(Of Long, ParallelLoopState, TLocal, TLocal), localFinally As Action(Of TLocal)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TLocal&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult For(long fromInclusive, long toExclusive, Func&lt;TLocal&gt; ^ localInit, Func&lt;long, System::Threading::Tasks::ParallelLoopState ^, TLocal, TLocal&gt; ^ body, Action&lt;TLocal&gt; ^ localFinally);" />
      <MemberSignature Language="F#" Value="static member For : int64 * int64 * Func&lt;'Local&gt; * Func&lt;int64, System.Threading.Tasks.ParallelLoopState, 'Local, 'Local&gt; * Action&lt;'Local&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.For (fromInclusive, toExclusive, localInit, body, localFinally)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TLocal" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="fromInclusive" Type="System.Int64" />
        <Parameter Name="toExclusive" Type="System.Int64" />
        <Parameter Name="localInit" Type="System.Func&lt;TLocal&gt;" />
        <Parameter Name="body" Type="System.Func&lt;System.Int64,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt;" />
        <Parameter Name="localFinally" Type="System.Action&lt;TLocal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TLocal">线程本地数据的类型。</typeparam>
        <param name="fromInclusive">开始索引（含）。</param>
        <param name="toExclusive">结束索引（不含）。</param>
        <param name="localInit">用于返回每个任务的本地数据的初始状态的函数委托。</param>
        <param name="body">将为每个迭代调用一次的委托。</param>
        <param name="localFinally">用于对每个任务的本地状态执行一个最终操作的委托。</param>
        <summary>执行具有 64 位索引和线程本地数据的 <see langword="for" />（在 Visual Basic 中为 <see langword="For" />）循环，其中可能会并行运行迭代，而且可以监视和操作循环的状态。</summary>
        <returns>包含有关已完成的循环部分的信息的结构。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `body`委托会调用一次迭代范围中每个值 (`fromInclusive`， `toExclusive`)。 提供使用以下参数： 迭代次数 (<xref:System.Int64>)、 一个<xref:System.Threading.Tasks.ParallelLoopState>实例可用于中断循环过早，并可能在相同的任务执行的迭代之间共享某些本地状态。  
  
 `localInit`参与循环的执行，这些任务的每个返回初始本地状态的每个任务一次调用委托。 这些初始状态传递给第一个`body`上每个任务的调用。 然后，每个后续正文调用返回传递给下一个正文调用一个可能已修改的状态值。 最后，每个任务上的最后一个正文调用返回传递给的州值`localFinally`委托。 `localFinally`每个任务，每个任务的本地状态执行一个最终操作一次调用委托。 在多个任务; 可能会同时调用此委托因此，必须同步对共享的任何变量的访问。  
  
 <xref:System.Threading.Tasks.Parallel.For%2A?displayProperty=nameWithType>方法可能的现有任务完成其执行生存期内使用多于线程数的更多任务，并替换为新的任务。 这样，基础<xref:System.Threading.Tasks.TaskScheduler>对象机会添加，请更改或删除服务循环的线程。  
  
 如果`fromInclusive`大于或等于`toExclusive`，则该方法立即返回而不执行任何迭代。  
  
 使用此方法的示例，请参阅[如何： 编写具有线程局部变量的 Parallel.For 循环](~/docs/standard/parallel-programming/how-to-write-a-parallel-for-loop-with-thread-local-variables.md)。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="body" /> 参数为 <see langword="null" />。  
  
或 
<paramref name="localInit" /> 参数为 <see langword="null" />。  
  
或 
<paramref name="localFinally" /> 参数为 <see langword="null" />。</exception>
        <exception cref="T:System.AggregateException">包含在所有线程上引发的全部单个异常的异常。</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">并行循环</related>
      </Docs>
    </Member>
    <Member MemberName="For&lt;TLocal&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult For&lt;TLocal&gt; (int fromInclusive, int toExclusive, System.Threading.Tasks.ParallelOptions parallelOptions, Func&lt;TLocal&gt; localInit, Func&lt;int,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt; body, Action&lt;TLocal&gt; localFinally);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult For&lt;TLocal&gt;(int32 fromInclusive, int32 toExclusive, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Func`1&lt;!!TLocal&gt; localInit, class System.Func`4&lt;int32, class System.Threading.Tasks.ParallelLoopState, !!TLocal, !!TLocal&gt; body, class System.Action`1&lt;!!TLocal&gt; localFinally) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.For``1(System.Int32,System.Int32,System.Threading.Tasks.ParallelOptions,System.Func{``0},System.Func{System.Int32,System.Threading.Tasks.ParallelLoopState,``0,``0},System.Action{``0})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TLocal&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult For(int fromInclusive, int toExclusive, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Func&lt;TLocal&gt; ^ localInit, Func&lt;int, System::Threading::Tasks::ParallelLoopState ^, TLocal, TLocal&gt; ^ body, Action&lt;TLocal&gt; ^ localFinally);" />
      <MemberSignature Language="F#" Value="static member For : int * int * System.Threading.Tasks.ParallelOptions * Func&lt;'Local&gt; * Func&lt;int, System.Threading.Tasks.ParallelLoopState, 'Local, 'Local&gt; * Action&lt;'Local&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.For (fromInclusive, toExclusive, parallelOptions, localInit, body, localFinally)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TLocal" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="fromInclusive" Type="System.Int32" />
        <Parameter Name="toExclusive" Type="System.Int32" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="localInit" Type="System.Func&lt;TLocal&gt;" />
        <Parameter Name="body" Type="System.Func&lt;System.Int32,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt;" />
        <Parameter Name="localFinally" Type="System.Action&lt;TLocal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TLocal">线程本地数据的类型。</typeparam>
        <param name="fromInclusive">开始索引（含）。</param>
        <param name="toExclusive">结束索引（不含）。</param>
        <param name="parallelOptions">一个对象，用于配置此操作的行为。</param>
        <param name="localInit">用于返回每个任务的本地数据的初始状态的函数委托。</param>
        <param name="body">将为每个迭代调用一次的委托。</param>
        <param name="localFinally">用于对每个任务的本地状态执行一个最终操作的委托。</param>
        <summary>执行具有线程本地数据的 <see langword="for" />（在 Visual Basic 中为 <see langword="For" />）循环，其中可能会并行运行迭代，而且可以配置循环选项，可以监视和操作循环的状态。</summary>
        <returns>包含有关已完成的循环部分的信息的结构。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `body`委托会调用一次迭代范围中每个值 (`fromInclusive`， `toExclusive`)。 提供使用以下参数： 迭代次数 (<xref:System.Int32>)、 一个<xref:System.Threading.Tasks.ParallelLoopState>实例可用于中断循环过早，并可能在相同的任务执行的迭代之间共享某些本地状态。  
  
 `localInit`参与循环的执行，这些任务的每个返回初始本地状态的每个任务一次调用委托。 这些初始状态传递给第一个`body`上每个任务的调用。 然后，每个后续正文调用返回传递给下一个正文调用一个可能已修改的状态值。 最后，每个任务上的最后一个正文调用返回传递给的州值`localFinally`委托。 `localFinally`每个任务，每个任务的本地状态执行一个最终操作一次调用委托。 可能在多个线程; 同时调用此委托因此，必须同步对共享的任何变量的访问。  
  
 <xref:System.Threading.Tasks.Parallel.For%2A?displayProperty=nameWithType>方法可能的现有任务完成其执行生存期内使用多于线程数的更多任务，并替换为新的任务。 这样，基础<xref:System.Threading.Tasks.TaskScheduler>对象机会添加，请更改或删除服务循环的线程。  
  
 如果`fromInclusive`大于或等于`toExclusive`，则该方法立即返回而不执行任何迭代。  
  
   
  
## Examples  
 以下示例使用线程本地变量来计算的很多长时间的操作的结果的总和。 此示例将限制的并行度为 4。  
  
 [!code-csharp[System.Threading.Tasks.Parallel#04](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.parallel/cs/threadlocalforwithoptions.cs#04)]
 [!code-vb[System.Threading.Tasks.Parallel#04](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.parallel/vb/threadlocalforwithoptions.vb#04)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="body" /> 参数为 <see langword="null" />。  
  
或 
<paramref name="localInit" /> 参数为 <see langword="null" />。  
  
或 
<paramref name="localFinally" /> 参数为 <see langword="null" />。  
  
或 
<paramref name="parallelOptions" /> 参数为 <see langword="null" />。</exception>
        <exception cref="T:System.OperationCanceledException">在 <paramref name="parallelOptions" /> 取消的 <see cref="T:System.Threading.CancellationToken" /> 参数。</exception>
        <exception cref="T:System.ObjectDisposedException">在 <paramref name="parallelOptions" /> 中与 <see cref="T:System.Threading.CancellationTokenSource" /> 关联的 <see cref="T:System.Threading.CancellationToken" /> 已被释放。</exception>
        <exception cref="T:System.AggregateException">包含在所有线程上引发的全部单个异常的异常。</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">并行循环</related>
      </Docs>
    </Member>
    <Member MemberName="For&lt;TLocal&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult For&lt;TLocal&gt; (long fromInclusive, long toExclusive, System.Threading.Tasks.ParallelOptions parallelOptions, Func&lt;TLocal&gt; localInit, Func&lt;long,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt; body, Action&lt;TLocal&gt; localFinally);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult For&lt;TLocal&gt;(int64 fromInclusive, int64 toExclusive, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Func`1&lt;!!TLocal&gt; localInit, class System.Func`4&lt;int64, class System.Threading.Tasks.ParallelLoopState, !!TLocal, !!TLocal&gt; body, class System.Action`1&lt;!!TLocal&gt; localFinally) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.For``1(System.Int64,System.Int64,System.Threading.Tasks.ParallelOptions,System.Func{``0},System.Func{System.Int64,System.Threading.Tasks.ParallelLoopState,``0,``0},System.Action{``0})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TLocal&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult For(long fromInclusive, long toExclusive, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Func&lt;TLocal&gt; ^ localInit, Func&lt;long, System::Threading::Tasks::ParallelLoopState ^, TLocal, TLocal&gt; ^ body, Action&lt;TLocal&gt; ^ localFinally);" />
      <MemberSignature Language="F#" Value="static member For : int64 * int64 * System.Threading.Tasks.ParallelOptions * Func&lt;'Local&gt; * Func&lt;int64, System.Threading.Tasks.ParallelLoopState, 'Local, 'Local&gt; * Action&lt;'Local&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.For (fromInclusive, toExclusive, parallelOptions, localInit, body, localFinally)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TLocal" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="fromInclusive" Type="System.Int64" />
        <Parameter Name="toExclusive" Type="System.Int64" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="localInit" Type="System.Func&lt;TLocal&gt;" />
        <Parameter Name="body" Type="System.Func&lt;System.Int64,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt;" />
        <Parameter Name="localFinally" Type="System.Action&lt;TLocal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TLocal">线程本地数据的类型。</typeparam>
        <param name="fromInclusive">开始索引（含）。</param>
        <param name="toExclusive">结束索引（不含）。</param>
        <param name="parallelOptions">一个对象，用于配置此操作的行为。</param>
        <param name="localInit">用于返回每个线程的本地数据的初始状态的函数委托。</param>
        <param name="body">将为每个迭代调用一次的委托。</param>
        <param name="localFinally">用于对每个线程的本地状态执行一个最终操作的委托。</param>
        <summary>执行具有 64 位索引和线程本地数据的 <see langword="for" />（在 Visual Basic 中为 <see langword="For" />）循环，其中可能会并行运行迭代，而且可以配置循环选项，可以监视和操作循环的状态。</summary>
        <returns>包含有关已完成的循环部分的信息的结构。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `body`委托会调用一次迭代范围中每个值 (`fromInclusive`， `toExclusive`)。 提供使用以下参数： 迭代次数 (<xref:System.Int64>)、 一个<xref:System.Threading.Tasks.ParallelLoopState>实例可用于中断循环过早，并可能在同一线程执行的迭代之间共享某些本地状态。  
  
 `localInit`委托会调用一次为每个线程都参与循环的执行，并为每个这些线程返回初始本地状态。 这些初始状态传递给第一个`body`上每个线程的调用。 然后，每个后续正文调用返回传递给下一个正文调用一个可能已修改的状态值。 最后，每个线程上的最后一个正文调用返回传递给的州值`localFinally`委托。 `localFinally`每个线程上每个线程本地状态执行一个最终操作一次调用委托。 可能在多个线程; 同时调用此委托因此，必须同步对共享的任何变量的访问。  
  
 <xref:System.Threading.Tasks.Parallel.For%2A?displayProperty=nameWithType>方法可能的现有任务完成其执行生存期内使用多于线程数的更多任务，并替换为新的任务。 这样，基础<xref:System.Threading.Tasks.TaskScheduler>对象机会添加，请更改或删除服务循环的线程。  
  
 如果`fromInclusive`大于或等于`toExclusive`，则该方法立即返回而不执行任何迭代。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="body" /> 参数为 <see langword="null" />。  
  
或 
<paramref name="localInit" /> 参数为 <see langword="null" />。  
  
或 
<paramref name="localFinally" /> 参数为 <see langword="null" />。  
  
或 
<paramref name="parallelOptions" /> 参数为 <see langword="null" />。</exception>
        <exception cref="T:System.OperationCanceledException">在 <paramref name="parallelOptions" /> 取消的 <see cref="T:System.Threading.CancellationToken" /> 参数。</exception>
        <exception cref="T:System.ObjectDisposedException">在 <paramref name="parallelOptions" /> 中与 <see cref="T:System.Threading.CancellationTokenSource" /> 关联的 <see cref="T:System.Threading.CancellationToken" /> 已被释放。</exception>
        <exception cref="T:System.AggregateException">包含在所有线程上引发的全部单个异常的异常。</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">并行循环</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="ForEach&lt;TSource&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>执行 <see langword="foreach" />（在 Visual Basic 中为 <see langword="For Each " />）操作，其中可能会并行运行迭代。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ForEach&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt; (System.Collections.Concurrent.OrderablePartitioner&lt;TSource&gt; source, Action&lt;TSource,System.Threading.Tasks.ParallelLoopState,long&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt;(class System.Collections.Concurrent.OrderablePartitioner`1&lt;!!TSource&gt; source, class System.Action`3&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState, int64&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Concurrent.OrderablePartitioner{``0},System.Action{``0,System.Threading.Tasks.ParallelLoopState,System.Int64})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ForEach(Of TSource) (source As OrderablePartitioner(Of TSource), body As Action(Of TSource, ParallelLoopState, Long)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Concurrent::OrderablePartitioner&lt;TSource&gt; ^ source, Action&lt;TSource, System::Threading::Tasks::ParallelLoopState ^, long&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member ForEach : System.Collections.Concurrent.OrderablePartitioner&lt;'Source&gt; * Action&lt;'Source, System.Threading.Tasks.ParallelLoopState, int64&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Concurrent.OrderablePartitioner&lt;TSource&gt;" />
        <Parameter Name="body" Type="System.Action&lt;TSource,System.Threading.Tasks.ParallelLoopState,System.Int64&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">
          <paramref name="source" /> 中的元素的类型。</typeparam>
        <param name="source">包含原始数据源的可排序分区程序。</param>
        <param name="body">将为每个迭代调用一次的委托。</param>
        <summary>执行 <see langword="foreach" />（在 Visual Basic 中为 <see langword="For Each" />）操作，其中在 <see cref="T:System.Collections.Concurrent.OrderablePartitioner`1" /> 中可能会并行运行迭代，而且可以监视和操作循环的状态。</summary>
        <returns>包含有关已完成的循环部分的信息的结构。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 对于想要重写默认分区方案的方案提供了此重载。 例如，小型循环体可能受益于分区范围。 <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType>方法需要自定义分区程序来支持动态分区。 有关详细信息，请参阅[PLINQ 和 TPL 的自定义分区程序](~/docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md)并[如何： 实现动态分区](~/docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md)。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> 参数为 <see langword="null" />。  
  
或 
<paramref name="body" /> 参数为 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">在 <paramref name="source" /> 可排序的分区程序的 <see cref="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions" /> 属性返回 <see langword="false" />。  
  
或 
在 <see langword="false" /> 可排序的分区程序的 <see cref="P:System.Collections.Concurrent.OrderablePartitioner`1.KeysNormalized" /> 属性返回 。  
  
或 
在源可排序的分区程序的所有方法都返回 <see langword="null" />。</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">并行循环</related>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt; (System.Collections.Concurrent.Partitioner&lt;TSource&gt; source, Action&lt;TSource,System.Threading.Tasks.ParallelLoopState&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt;(class System.Collections.Concurrent.Partitioner`1&lt;!!TSource&gt; source, class System.Action`2&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Concurrent.Partitioner{``0},System.Action{``0,System.Threading.Tasks.ParallelLoopState})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ForEach(Of TSource) (source As Partitioner(Of TSource), body As Action(Of TSource, ParallelLoopState)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Concurrent::Partitioner&lt;TSource&gt; ^ source, Action&lt;TSource, System::Threading::Tasks::ParallelLoopState ^&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member ForEach : System.Collections.Concurrent.Partitioner&lt;'Source&gt; * Action&lt;'Source, System.Threading.Tasks.ParallelLoopState&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Concurrent.Partitioner&lt;TSource&gt;" />
        <Parameter Name="body" Type="System.Action&lt;TSource,System.Threading.Tasks.ParallelLoopState&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">
          <paramref name="source" /> 中的元素的类型。</typeparam>
        <param name="source">包含原始数据源的分区程序。</param>
        <param name="body">将为每个迭代调用一次的委托。</param>
        <summary>执行 <see langword="foreach" />（在 Visual Basic 中为 <see langword="For Each" />）操作，其中在 <see cref="T:System.Collections.Concurrent.Partitioner" /> 中可能会并行运行迭代，而且可以监视和操作循环的状态。</summary>
        <returns>包含有关已完成的循环部分的信息的结构。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 对于想要重写默认分区方案的方案提供了此重载。 例如，小型循环体可能受益于分区范围。 <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType>方法需要自定义分区程序来支持动态分区。 有关详细信息，请参阅[PLINQ 和 TPL 的自定义分区程序](~/docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md)并[如何： 实现动态分区](~/docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md)。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> 参数为 <see langword="null" />。  
  
或 
<paramref name="body" /> 参数为 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">在 <paramref name="source" /> 的分区程序的 <see cref="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions" /> 属性返回 <see langword="false" />。  
  
或 
<paramref name="source" /> 分区程序中的方法返回 <see langword="null" />。  
  
或 
<paramref name="source" /> 分区程序中的 <see cref="M:System.Collections.Concurrent.Partitioner`1.GetPartitions(System.Int32)" /> 方法未返回正确的分区数时引发的异常。</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">并行循环</related>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt; (System.Collections.Concurrent.Partitioner&lt;TSource&gt; source, Action&lt;TSource&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt;(class System.Collections.Concurrent.Partitioner`1&lt;!!TSource&gt; source, class System.Action`1&lt;!!TSource&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Concurrent.Partitioner{``0},System.Action{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ForEach(Of TSource) (source As Partitioner(Of TSource), body As Action(Of TSource)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Concurrent::Partitioner&lt;TSource&gt; ^ source, Action&lt;TSource&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member ForEach : System.Collections.Concurrent.Partitioner&lt;'Source&gt; * Action&lt;'Source&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Concurrent.Partitioner&lt;TSource&gt;" />
        <Parameter Name="body" Type="System.Action&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">
          <paramref name="source" /> 中的元素的类型。</typeparam>
        <param name="source">包含原始数据源的分区程序。</param>
        <param name="body">将为每个迭代调用一次的委托。</param>
        <summary>执行 <see langword="foreach" />（在 Visual Basic 中为 <see langword="For Each" />）操作，其中在 <see cref="T:System.Collections.Concurrent.Partitioner" /> 上可能会并行运行迭代。</summary>
        <returns>包含有关已完成的循环部分的信息的结构。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 对于想要重写默认分区方案的方案提供了此重载。 例如，小型循环体可能受益于分区范围。 <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType>方法需要自定义分区程序来支持动态分区。 有关详细信息，请参阅[PLINQ 和 TPL 的自定义分区程序](~/docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md)并[如何： 实现动态分区](~/docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md)。  
  
   
  
## Examples  
 下面的示例演示如何实现用于范围分区程序<xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType>:  
  
 [!code-csharp[System.Threading.Tasks.Parallel_RangePartitioners#01](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.parallel_rangepartitioners/cs/rangepartitioner.cs#01)]
 [!code-vb[System.Threading.Tasks.Parallel_RangePartitioners#01](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.parallel_rangepartitioners/vb/rangepart.vb#01)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> 参数为 <see langword="null" />。  
  
或 
<paramref name="body" /> 参数为 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">在 <paramref name="source" /> 的分区程序的 <see cref="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions" /> 属性返回 <see langword="false" />。  
  
或 
在 <paramref name="source" /> 分区程序中的任何方法返回 <see langword="null" /> 时引发的异常。  
  
或 
<paramref name="source" /> 分区程序中的 <see cref="M:System.Collections.Concurrent.Partitioner`1.GetPartitions(System.Int32)" /> 方法未返回正确的分区数时引发的异常。</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">并行循环</related>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt; (System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Action&lt;TSource,System.Threading.Tasks.ParallelLoopState,long&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Action`3&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState, int64&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0,System.Threading.Tasks.ParallelLoopState,System.Int64})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ForEach(Of TSource) (source As IEnumerable(Of TSource), body As Action(Of TSource, ParallelLoopState, Long)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Action&lt;TSource, System::Threading::Tasks::ParallelLoopState ^, long&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member ForEach : seq&lt;'Source&gt; * Action&lt;'Source, System.Threading.Tasks.ParallelLoopState, int64&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
        <Parameter Name="body" Type="System.Action&lt;TSource,System.Threading.Tasks.ParallelLoopState,System.Int64&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">源中数据的类型。</typeparam>
        <param name="source">可枚举的数据源。</param>
        <param name="body">将为每个迭代调用一次的委托。</param>
        <summary>执行具有 64 位索引的 <see langword="foreach" />（在 Visual Basic 中为 <see langword="For Each" />）操作，其中在 <see cref="T:System.Collections.IEnumerable" /> 上可能会并行运行迭代，而且可以监视和操作循环的状态。</summary>
        <returns>包含有关已完成的循环部分的信息的结构。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `body`委托中每个元素调用一次`source`可枚举。 提供使用以下参数： 当前元素，<xref:System.Threading.Tasks.ParallelLoopState>可用于中断循环过早，实例和当前元素的索引 (<xref:System.Int64>)。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> 参数为 <see langword="null" />。  
  
或 
<paramref name="body" /> 参数为 <see langword="null" />。</exception>
        <exception cref="T:System.AggregateException">包含在所有线程上引发的全部单个异常的异常。</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">并行循环</related>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt; (System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Action&lt;TSource,System.Threading.Tasks.ParallelLoopState&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Action`2&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0,System.Threading.Tasks.ParallelLoopState})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ForEach(Of TSource) (source As IEnumerable(Of TSource), body As Action(Of TSource, ParallelLoopState)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Action&lt;TSource, System::Threading::Tasks::ParallelLoopState ^&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member ForEach : seq&lt;'Source&gt; * Action&lt;'Source, System.Threading.Tasks.ParallelLoopState&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
        <Parameter Name="body" Type="System.Action&lt;TSource,System.Threading.Tasks.ParallelLoopState&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">源中数据的类型。</typeparam>
        <param name="source">可枚举的数据源。</param>
        <param name="body">将为每个迭代调用一次的委托。</param>
        <summary>执行 <see langword="foreach" />（在 Visual Basic 中为 <see langword="For Each" />）操作，其中在 <see cref="T:System.Collections.IEnumerable" /> 中可能会并行运行迭代，而且可以监视和操作循环的状态。</summary>
        <returns>包含有关已完成的循环部分的信息的结构。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `body`委托中每个元素调用一次`source`可枚举。 提供使用以下参数： 当前元素和一个<xref:System.Threading.Tasks.ParallelLoopState>可能用于过早中断该循环的实例。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> 参数为 <see langword="null" />。  
  
或 
<paramref name="body" /> 参数为 <see langword="null" />。</exception>
        <exception cref="T:System.AggregateException">包含在所有线程上引发的全部单个异常的异常。</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">并行循环</related>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt; (System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Action&lt;TSource&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Action`1&lt;!!TSource&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ForEach(Of TSource) (source As IEnumerable(Of TSource), body As Action(Of TSource)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Action&lt;TSource&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member ForEach : seq&lt;'Source&gt; * Action&lt;'Source&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
        <Parameter Name="body" Type="System.Action&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">源中数据的类型。</typeparam>
        <param name="source">可枚举的数据源。</param>
        <param name="body">将为每个迭代调用一次的委托。</param>
        <summary>执行 <see langword="foreach" />（在 Visual Basic 中为 <see langword="For Each" />）操作，其中在 <see cref="T:System.Collections.IEnumerable" /> 上可能会并行运行迭代。</summary>
        <returns>包含有关已完成的循环部分的信息的结构。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `body`委托中每个元素调用一次`source`可枚举。 它提供当前元素作为参数。  
  
   
  
## Examples  
 下面的示例使用<xref:System.Threading.Tasks.Parallel.ForEach%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Action%7B%60%600%7D%29>方法以计算元音和在文本文件中的非空白字符的数目。 在这种情况下，<xref:System.Threading.Tasks.ParallelLoopResult>方法返回的值将被忽略。 请注意，因为操作可以并行运行，必须确保，递增的计数器变量是原子操作，并且多个线程未尝试同时访问计数器变量。 为此，该示例使用`lock`（在 C#) 语句和`SyncLock`（在 Visual Basic) 语句。  
  
 [!code-csharp[System.Threading.Tasks.Parallel.ForEach#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.parallel.foreach/cs/foreach1.cs#1)]
 [!code-vb[System.Threading.Tasks.Parallel.ForEach#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.parallel.foreach/vb/foreach1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> 参数为 <see langword="null" />。  
  
或 
<paramref name="body" /> 参数为 <see langword="null" />。</exception>
        <exception cref="T:System.AggregateException">包含在所有线程上引发的全部单个异常的异常。</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">并行循环</related>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt; (System.Collections.Concurrent.OrderablePartitioner&lt;TSource&gt; source, System.Threading.Tasks.ParallelOptions parallelOptions, Action&lt;TSource,System.Threading.Tasks.ParallelLoopState,long&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt;(class System.Collections.Concurrent.OrderablePartitioner`1&lt;!!TSource&gt; source, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Action`3&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState, int64&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Concurrent.OrderablePartitioner{``0},System.Threading.Tasks.ParallelOptions,System.Action{``0,System.Threading.Tasks.ParallelLoopState,System.Int64})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Concurrent::OrderablePartitioner&lt;TSource&gt; ^ source, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Action&lt;TSource, System::Threading::Tasks::ParallelLoopState ^, long&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member ForEach : System.Collections.Concurrent.OrderablePartitioner&lt;'Source&gt; * System.Threading.Tasks.ParallelOptions * Action&lt;'Source, System.Threading.Tasks.ParallelLoopState, int64&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, parallelOptions, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Concurrent.OrderablePartitioner&lt;TSource&gt;" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="body" Type="System.Action&lt;TSource,System.Threading.Tasks.ParallelLoopState,System.Int64&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">
          <paramref name="source" /> 中的元素的类型。</typeparam>
        <param name="source">包含原始数据源的可排序分区程序。</param>
        <param name="parallelOptions">一个对象，用于配置此操作的行为。</param>
        <param name="body">将为每个迭代调用一次的委托。</param>
        <summary>执行 <see langword="foreach" />（在 Visual Basic 中为 <see langword="For Each" />）操作，其中在 <see cref="T:System.Collections.Concurrent.OrderablePartitioner`1" /> 中可能会并行运行迭代，而且可以配置循环选项，可以监视和操作循环的状态。</summary>
        <returns>包含有关已完成的循环部分的信息的结构。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 对于想要重写默认分区方案的方案提供了此重载。 例如，小型循环体可能受益于分区范围。 <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType>方法需要自定义分区程序来支持动态分区。 有关详细信息，请参阅[PLINQ 和 TPL 的自定义分区程序](~/docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md)并[如何： 实现动态分区](~/docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md)。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException">在 <paramref name="parallelOptions" /> 取消的 <see cref="T:System.Threading.CancellationToken" />参数。 </exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> 参数为 <see langword="null" />。  
  
或 
<paramref name="parallelOptions" /> 参数为 <see langword="null" />。  
  
或 
<paramref name="body" /> 参数为 <see langword="null" />。</exception>
        <exception cref="T:System.ObjectDisposedException">在 <paramref name="parallelOptions" /> 中与 <see cref="T:System.Threading.CancellationTokenSource" /> 关联的 <see cref="T:System.Threading.CancellationToken" /> 已被释放。</exception>
        <exception cref="T:System.InvalidOperationException">在 <paramref name="source" /> 可排序的分区程序的 <see cref="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions" /> 属性返回 <see langword="false" />。  
  
或 
在 <paramref name="source" /> 可排序的分区程序的 <see cref="P:System.Collections.Concurrent.OrderablePartitioner`1.KeysNormalized" /> 属性返回 <see langword="false" />。  
  
或 
当 <paramref name="source" /> 可排序分区程序中的任何方法返回 <see langword="null" /> 时引发的异常。</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">并行循环</related>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt; (System.Collections.Concurrent.Partitioner&lt;TSource&gt; source, System.Threading.Tasks.ParallelOptions parallelOptions, Action&lt;TSource,System.Threading.Tasks.ParallelLoopState&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt;(class System.Collections.Concurrent.Partitioner`1&lt;!!TSource&gt; source, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Action`2&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Concurrent.Partitioner{``0},System.Threading.Tasks.ParallelOptions,System.Action{``0,System.Threading.Tasks.ParallelLoopState})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Concurrent::Partitioner&lt;TSource&gt; ^ source, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Action&lt;TSource, System::Threading::Tasks::ParallelLoopState ^&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member ForEach : System.Collections.Concurrent.Partitioner&lt;'Source&gt; * System.Threading.Tasks.ParallelOptions * Action&lt;'Source, System.Threading.Tasks.ParallelLoopState&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, parallelOptions, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Concurrent.Partitioner&lt;TSource&gt;" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="body" Type="System.Action&lt;TSource,System.Threading.Tasks.ParallelLoopState&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">
          <paramref name="source" /> 中的元素的类型。</typeparam>
        <param name="source">包含原始数据源的分区程序。</param>
        <param name="parallelOptions">一个对象，用于配置此操作的行为。</param>
        <param name="body">将为每个迭代调用一次的委托。</param>
        <summary>执行 <see langword="foreach" />（在 Visual Basic 中为 <see langword="For Each" />）操作，其中在 <see cref="T:System.Collections.Concurrent.Partitioner" /> 中可能会并行运行迭代，而且可以配置循环选项，可以监视和操作循环的状态。</summary>
        <returns>包含有关已完成的循环部分的信息的结构。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 对于想要重写默认分区方案的方案提供了此重载。 例如，小型循环体可能受益于分区范围。 <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType>方法需要自定义分区程序来支持动态分区。 有关详细信息，请参阅[PLINQ 和 TPL 的自定义分区程序](~/docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md)并[如何： 实现动态分区](~/docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md)。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException">在 <paramref name="parallelOptions" /> 取消的 <see cref="T:System.Threading.CancellationToken" /> 参数。</exception>
        <exception cref="T:System.ObjectDisposedException">在 <paramref name="parallelOptions" /> 中与 <see cref="T:System.Threading.CancellationTokenSource" /> 关联的 <see cref="T:System.Threading.CancellationToken" /> 已被释放。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> 参数为 <see langword="null" />。  
  
或 
<paramref name="parallelOptions" /> 参数为 <see langword="null" />。  
  
或 
<paramref name="body" /> 参数为 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">在 <paramref name="source" /> 的分区程序的 <see cref="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions" /> 属性返回 <see langword="false" />。  
  
或 
在 <paramref name="source" /> 分区程序中的任何方法返回 <see langword="null" /> 时引发的异常。</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">并行循环</related>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt; (System.Collections.Concurrent.Partitioner&lt;TSource&gt; source, System.Threading.Tasks.ParallelOptions parallelOptions, Action&lt;TSource&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt;(class System.Collections.Concurrent.Partitioner`1&lt;!!TSource&gt; source, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Action`1&lt;!!TSource&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Concurrent.Partitioner{``0},System.Threading.Tasks.ParallelOptions,System.Action{``0})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Concurrent::Partitioner&lt;TSource&gt; ^ source, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Action&lt;TSource&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member ForEach : System.Collections.Concurrent.Partitioner&lt;'Source&gt; * System.Threading.Tasks.ParallelOptions * Action&lt;'Source&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, parallelOptions, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Concurrent.Partitioner&lt;TSource&gt;" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="body" Type="System.Action&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">
          <paramref name="source" /> 中的元素的类型。</typeparam>
        <param name="source">包含原始数据源的分区程序。</param>
        <param name="parallelOptions">一个对象，用于配置此操作的行为。</param>
        <param name="body">将为每个迭代调用一次的委托。</param>
        <summary>执行 <see langword="foreach" />（在 Visual Basic 中为 <see langword="For Each" />）操作，其中在 <see cref="T:System.Collections.Concurrent.Partitioner" /> 中可能会并行运行迭代，而且可以配置循环选项。</summary>
        <returns>包含有关已完成的循环部分的信息的结构。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 对于想要重写默认分区方案的方案提供了此重载。 例如，小型循环体可能受益于分区范围。 <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType>方法需要自定义分区程序来支持动态分区。 有关详细信息，请参阅[PLINQ 和 TPL 的自定义分区程序](~/docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md)并[如何： 实现动态分区](~/docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md)。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException">在 <paramref name="parallelOptions" /> 取消的 <see cref="T:System.Threading.CancellationToken" /> 参数。</exception>
        <exception cref="T:System.ObjectDisposedException">在 <paramref name="parallelOptions" /> 中与 <see cref="T:System.Threading.CancellationTokenSource" /> 关联的 <see cref="T:System.Threading.CancellationToken" /> 已被释放。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> 参数为 <see langword="null" />。  
  
或 
<paramref name="parallelOptions" /> 参数为 <see langword="null" />。  
  
或 
<paramref name="body" /> 参数为 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">在 <paramref name="source" /> 的分区程序的 <see cref="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions" /> 属性返回 <see langword="false" />。  
  
或 
在 <paramref name="source" /> 分区程序中的任何方法返回 <see langword="null" /> 时引发的异常。</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">并行循环</related>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt; (System.Collections.Generic.IEnumerable&lt;TSource&gt; source, System.Threading.Tasks.ParallelOptions parallelOptions, Action&lt;TSource,System.Threading.Tasks.ParallelLoopState,long&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Action`3&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState, int64&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Generic.IEnumerable{``0},System.Threading.Tasks.ParallelOptions,System.Action{``0,System.Threading.Tasks.ParallelLoopState,System.Int64})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Action&lt;TSource, System::Threading::Tasks::ParallelLoopState ^, long&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member ForEach : seq&lt;'Source&gt; * System.Threading.Tasks.ParallelOptions * Action&lt;'Source, System.Threading.Tasks.ParallelLoopState, int64&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, parallelOptions, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="body" Type="System.Action&lt;TSource,System.Threading.Tasks.ParallelLoopState,System.Int64&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">源中数据的类型。</typeparam>
        <param name="source">可枚举的数据源。</param>
        <param name="parallelOptions">一个对象，用于配置此操作的行为。</param>
        <param name="body">将为每个迭代调用一次的委托。</param>
        <summary>执行具有 64 位索引的 <see langword="foreach" />（在 Visual Basic 中为 <see langword="For Each" />）操作，其中在 <see cref="T:System.Collections.IEnumerable" /> 上可能会并行运行迭代，而且可以配置循环选项，可以监视和操作循环的状态。</summary>
        <returns>包含有关已完成的循环部分的信息的结构。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `body`委托中每个元素调用一次`source`可枚举。 提供使用以下参数： 当前元素，<xref:System.Threading.Tasks.ParallelLoopState>可用于中断循环过早，实例和当前元素的索引 (<xref:System.Int64>)。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException">在 <paramref name="parallelOptions" /> 取消的 <see cref="T:System.Threading.CancellationToken" />参数。 </exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> 参数为 <see langword="null" />。  
  
或 
<paramref name="parallelOptions" /> 参数为 <see langword="null" />。  
  
或 
<paramref name="body" /> 参数为 <see langword="null" />。</exception>
        <exception cref="T:System.AggregateException">包含在所有线程上引发的全部单个异常的异常。</exception>
        <exception cref="T:System.ObjectDisposedException">在 <paramref name="parallelOptions" /> 中与 <see cref="T:System.Threading.CancellationTokenSource" /> 关联的 <see cref="T:System.Threading.CancellationToken" /> 已被释放。</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">并行循环</related>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt; (System.Collections.Generic.IEnumerable&lt;TSource&gt; source, System.Threading.Tasks.ParallelOptions parallelOptions, Action&lt;TSource,System.Threading.Tasks.ParallelLoopState&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Action`2&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Generic.IEnumerable{``0},System.Threading.Tasks.ParallelOptions,System.Action{``0,System.Threading.Tasks.ParallelLoopState})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Action&lt;TSource, System::Threading::Tasks::ParallelLoopState ^&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member ForEach : seq&lt;'Source&gt; * System.Threading.Tasks.ParallelOptions * Action&lt;'Source, System.Threading.Tasks.ParallelLoopState&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, parallelOptions, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="body" Type="System.Action&lt;TSource,System.Threading.Tasks.ParallelLoopState&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">源中数据的类型。</typeparam>
        <param name="source">可枚举的数据源。</param>
        <param name="parallelOptions">一个对象，用于配置此操作的行为。</param>
        <param name="body">将为每个迭代调用一次的委托。</param>
        <summary>执行 <see langword="foreach" />（在 Visual Basic 中为 <see langword="For Each" />）操作，其中在 <see cref="T:System.Collections.IEnumerable" /> 中可能会并行运行迭代，而且可以配置循环选项，可以监视和操作循环的状态。</summary>
        <returns>包含有关已完成的循环部分的信息的结构。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `body`委托中每个元素调用一次`source`可枚举。 提供使用以下参数： 当前元素和一个<xref:System.Threading.Tasks.ParallelLoopState>可能用于过早中断该循环的实例。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException">在 <paramref name="parallelOptions" /> 取消的 <see cref="T:System.Threading.CancellationToken" />参数。 </exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> 参数为 <see langword="null" />。  
  
或 
<paramref name="parallelOptions" /> 参数为 <see langword="null" />。  
  
或 
<paramref name="body" /> 参数为 <see langword="null" />。</exception>
        <exception cref="T:System.AggregateException">包含在所有线程上引发的全部单个异常的异常。</exception>
        <exception cref="T:System.ObjectDisposedException">在 <paramref name="parallelOptions" /> 中与 <see cref="T:System.Threading.CancellationTokenSource" /> 关联的 <see cref="T:System.Threading.CancellationToken" /> 已被释放。</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">并行循环</related>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt; (System.Collections.Generic.IEnumerable&lt;TSource&gt; source, System.Threading.Tasks.ParallelOptions parallelOptions, Action&lt;TSource&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Action`1&lt;!!TSource&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Generic.IEnumerable{``0},System.Threading.Tasks.ParallelOptions,System.Action{``0})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Action&lt;TSource&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member ForEach : seq&lt;'Source&gt; * System.Threading.Tasks.ParallelOptions * Action&lt;'Source&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, parallelOptions, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="body" Type="System.Action&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">源中数据的类型。</typeparam>
        <param name="source">可枚举的数据源。</param>
        <param name="parallelOptions">一个对象，用于配置此操作的行为。</param>
        <param name="body">将为每个迭代调用一次的委托。</param>
        <summary>执行 <see langword="foreach" />（在 Visual Basic 中为 <see langword="For Each" />）操作，其中在 <see cref="T:System.Collections.IEnumerable" /> 中可能会并行运行迭代，而且可以匹配配置循环选项。</summary>
        <returns>包含有关已完成的循环部分的信息的结构。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `body`委托中每个元素调用一次`source`可枚举。 它提供当前元素作为参数。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException">在 <paramref name="parallelOptions" /> 取消的 <see cref="T:System.Threading.CancellationToken" />参数。 </exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> 参数为 <see langword="null" />。  
  
或 
<paramref name="parallelOptions" /> 参数为 <see langword="null" />。  
  
或 
<paramref name="body" /> 参数为 <see langword="null" />。</exception>
        <exception cref="T:System.AggregateException">包含在所有线程上引发的全部单个异常的异常。</exception>
        <exception cref="T:System.ObjectDisposedException">在 <paramref name="parallelOptions" /> 中与 <see cref="T:System.Threading.CancellationTokenSource" /> 关联的 <see cref="T:System.Threading.CancellationToken" /> 已被释放。</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">并行循环</related>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource,TLocal&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource,TLocal&gt; (System.Collections.Concurrent.OrderablePartitioner&lt;TSource&gt; source, Func&lt;TLocal&gt; localInit, Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,long,TLocal,TLocal&gt; body, Action&lt;TLocal&gt; localFinally);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource, TLocal&gt;(class System.Collections.Concurrent.OrderablePartitioner`1&lt;!!TSource&gt; source, class System.Func`1&lt;!!TLocal&gt; localInit, class System.Func`5&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState, int64, !!TLocal, !!TLocal&gt; body, class System.Action`1&lt;!!TLocal&gt; localFinally) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``2(System.Collections.Concurrent.OrderablePartitioner{``0},System.Func{``1},System.Func{``0,System.Threading.Tasks.ParallelLoopState,System.Int64,``1,``1},System.Action{``1})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ForEach(Of TSource, TLocal) (source As OrderablePartitioner(Of TSource), localInit As Func(Of TLocal), body As Func(Of TSource, ParallelLoopState, Long, TLocal, TLocal), localFinally As Action(Of TLocal)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TLocal&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Concurrent::OrderablePartitioner&lt;TSource&gt; ^ source, Func&lt;TLocal&gt; ^ localInit, Func&lt;TSource, System::Threading::Tasks::ParallelLoopState ^, long, TLocal, TLocal&gt; ^ body, Action&lt;TLocal&gt; ^ localFinally);" />
      <MemberSignature Language="F#" Value="static member ForEach : System.Collections.Concurrent.OrderablePartitioner&lt;'Source&gt; * Func&lt;'Local&gt; * Func&lt;'Source, System.Threading.Tasks.ParallelLoopState, int64, 'Local, 'Local&gt; * Action&lt;'Local&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, localInit, body, localFinally)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TLocal" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Concurrent.OrderablePartitioner&lt;TSource&gt;" />
        <Parameter Name="localInit" Type="System.Func&lt;TLocal&gt;" />
        <Parameter Name="body" Type="System.Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,System.Int64,TLocal,TLocal&gt;" />
        <Parameter Name="localFinally" Type="System.Action&lt;TLocal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">
          <paramref name="source" /> 中的元素的类型。</typeparam>
        <typeparam name="TLocal">线程本地数据的类型。</typeparam>
        <param name="source">包含原始数据源的可排序分区程序。</param>
        <param name="localInit">用于返回每个任务的本地数据的初始状态的函数委托。</param>
        <param name="body">将为每个迭代调用一次的委托。</param>
        <param name="localFinally">用于对每个任务的本地状态执行一个最终操作的委托。</param>
        <summary>执行具有线程本地数据的 <see langword="foreach" />（在 Visual Basic 中为 <see langword="For Each" />）操作，其中在 <see cref="T:System.Collections.Concurrent.OrderablePartitioner`1" /> 上可能会并行运行迭代，而且可以配置循环选项，可以监视和操作循环的状态。</summary>
        <returns>包含有关已完成的循环部分的信息的结构。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 对于想要重写默认分区方案的方案提供了此重载。 例如，小型循环体可能受益于分区范围。 <xref:System.Threading.Tasks.Parallel.ForEach%2A>方法需要自定义分区程序来支持动态分区。 有关详细信息，请参阅[PLINQ 和 TPL 的自定义分区程序](~/docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md)并[如何： 实现动态分区](~/docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md)。  
  
 `localInit`参与循环的执行，这些任务的每个返回初始本地状态的每个任务一次调用委托。 这些初始状态传递给第一个`body`上每个任务的调用。 然后，每个后续正文调用返回传递给下一个正文调用一个可能已修改的状态值。 最后，每个任务上的最后一个正文调用返回传递给的州值`localFinally`委托。 `localFinally`每个任务，每个任务的本地状态执行一个最终操作一次调用委托。 在多个任务; 可能会同时调用此委托因此，必须同步对共享的任何变量的访问。  
  
 <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType>方法可能的现有任务完成其执行生存期内使用多于线程数的更多任务，并替换为新的任务。 这样，基础<xref:System.Threading.Tasks.TaskScheduler>对象机会添加，请更改或删除服务循环的线程。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> 参数为 <see langword="null" />。  
  
或 
<paramref name="body" /> 参数为 <see langword="null" />。  
  
或 
<paramref name="localInit" /> 参数为 <see langword="null" />。  
  
或 
<paramref name="localFinally" /> 参数为 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" />
          <see cref="T:System.Collections.Concurrent.Partitioner" /> 中的 <see cref="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions" /> 属性返回 <see langword="false" />，或者分区程序返回 <see langword="null" /> 分区。</exception>
        <exception cref="T:System.AggregateException">包含在所有线程上引发的全部单个异常的异常。</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">并行循环</related>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource,TLocal&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource,TLocal&gt; (System.Collections.Concurrent.Partitioner&lt;TSource&gt; source, Func&lt;TLocal&gt; localInit, Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt; body, Action&lt;TLocal&gt; localFinally);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource, TLocal&gt;(class System.Collections.Concurrent.Partitioner`1&lt;!!TSource&gt; source, class System.Func`1&lt;!!TLocal&gt; localInit, class System.Func`4&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState, !!TLocal, !!TLocal&gt; body, class System.Action`1&lt;!!TLocal&gt; localFinally) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``2(System.Collections.Concurrent.Partitioner{``0},System.Func{``1},System.Func{``0,System.Threading.Tasks.ParallelLoopState,``1,``1},System.Action{``1})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ForEach(Of TSource, TLocal) (source As Partitioner(Of TSource), localInit As Func(Of TLocal), body As Func(Of TSource, ParallelLoopState, TLocal, TLocal), localFinally As Action(Of TLocal)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TLocal&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Concurrent::Partitioner&lt;TSource&gt; ^ source, Func&lt;TLocal&gt; ^ localInit, Func&lt;TSource, System::Threading::Tasks::ParallelLoopState ^, TLocal, TLocal&gt; ^ body, Action&lt;TLocal&gt; ^ localFinally);" />
      <MemberSignature Language="F#" Value="static member ForEach : System.Collections.Concurrent.Partitioner&lt;'Source&gt; * Func&lt;'Local&gt; * Func&lt;'Source, System.Threading.Tasks.ParallelLoopState, 'Local, 'Local&gt; * Action&lt;'Local&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, localInit, body, localFinally)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TLocal" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Concurrent.Partitioner&lt;TSource&gt;" />
        <Parameter Name="localInit" Type="System.Func&lt;TLocal&gt;" />
        <Parameter Name="body" Type="System.Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt;" />
        <Parameter Name="localFinally" Type="System.Action&lt;TLocal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">
          <paramref name="source" /> 中的元素的类型。</typeparam>
        <typeparam name="TLocal">线程本地数据的类型。</typeparam>
        <param name="source">包含原始数据源的分区程序。</param>
        <param name="localInit">用于返回每个任务的本地数据的初始状态的函数委托。</param>
        <param name="body">将为每个迭代调用一次的委托。</param>
        <param name="localFinally">用于对每个任务的本地状态执行一个最终操作的委托。</param>
        <summary>执行具有线程本地数据的 <see langword="foreach" />（在 Visual Basic 中为 <see langword="For Each" />）操作，其中在 <see cref="T:System.Collections.Concurrent.Partitioner" /> 上可能会并行运行迭代，而且可以监视和操作循环的状态。</summary>
        <returns>包含有关已完成的循环部分的信息的结构。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 对于想要重写默认分区方案的方案提供了此重载。 例如，小型循环体可能受益于分区范围。 <xref:System.Threading.Tasks.Parallel.ForEach%2A>方法需要自定义分区程序来支持动态分区。 有关详细信息，请参阅[PLINQ 和 TPL 的自定义分区程序](~/docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md)并[如何： 实现动态分区](~/docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md)。  
  
 `localInit`委托会调用一次为每个线程都参与循环的执行，这些任务的每个返回初始本地状态。 这些初始状态传递给第一个`body`上每个任务的调用。 然后，每个后续正文调用返回传递给下一个正文调用一个可能已修改的状态值。 最后，每个任务上的最后一个正文调用返回传递给的州值`localFinally`委托。 `localFinally`每个任务，每个任务的本地状态执行一个最终操作一次调用委托。 在多个任务; 可能会同时调用此委托因此，必须同步对共享的任何变量的访问。  
  
 <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType>方法可能的现有任务完成其执行生存期内使用多于线程数的更多任务，并替换为新的任务。 这样，基础<xref:System.Threading.Tasks.TaskScheduler>对象机会添加，请更改或删除服务循环的线程。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> 参数为 <see langword="null" />。  
  
或 
<paramref name="body" /> 参数为 <see langword="null" />。  
  
或 
<paramref name="localInit" /> 参数为 <see langword="null" />。  
  
或 
<paramref name="localFinally" /> 参数为 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" />
          <see cref="T:System.Collections.Concurrent.Partitioner" /> 中的 <see cref="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions" /> 属性返回 <see langword="false" />，或者分区程序返回 <see langword="null" /> 分区。</exception>
        <exception cref="T:System.AggregateException">包含在所有线程上引发的全部单个异常的异常。</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">并行循环</related>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource,TLocal&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource,TLocal&gt; (System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TLocal&gt; localInit, Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,long,TLocal,TLocal&gt; body, Action&lt;TLocal&gt; localFinally);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource, TLocal&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`1&lt;!!TLocal&gt; localInit, class System.Func`5&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState, int64, !!TLocal, !!TLocal&gt; body, class System.Action`1&lt;!!TLocal&gt; localFinally) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``2(System.Collections.Generic.IEnumerable{``0},System.Func{``1},System.Func{``0,System.Threading.Tasks.ParallelLoopState,System.Int64,``1,``1},System.Action{``1})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ForEach(Of TSource, TLocal) (source As IEnumerable(Of TSource), localInit As Func(Of TLocal), body As Func(Of TSource, ParallelLoopState, Long, TLocal, TLocal), localFinally As Action(Of TLocal)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TLocal&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TLocal&gt; ^ localInit, Func&lt;TSource, System::Threading::Tasks::ParallelLoopState ^, long, TLocal, TLocal&gt; ^ body, Action&lt;TLocal&gt; ^ localFinally);" />
      <MemberSignature Language="F#" Value="static member ForEach : seq&lt;'Source&gt; * Func&lt;'Local&gt; * Func&lt;'Source, System.Threading.Tasks.ParallelLoopState, int64, 'Local, 'Local&gt; * Action&lt;'Local&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, localInit, body, localFinally)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TLocal" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
        <Parameter Name="localInit" Type="System.Func&lt;TLocal&gt;" />
        <Parameter Name="body" Type="System.Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,System.Int64,TLocal,TLocal&gt;" />
        <Parameter Name="localFinally" Type="System.Action&lt;TLocal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">源中数据的类型。</typeparam>
        <typeparam name="TLocal">线程本地数据的类型。</typeparam>
        <param name="source">可枚举的数据源。</param>
        <param name="localInit">用于返回每个任务的本地数据的初始状态的函数委托。</param>
        <param name="body">将为每个迭代调用一次的委托。</param>
        <param name="localFinally">用于对每个任务的本地状态执行一个最终操作的委托。</param>
        <summary>执行具有线程本地数据的 <see langword="foreach" />（在 Visual Basic 中为 <see langword="For Each" />）操作，其中在 <see cref="T:System.Collections.IEnumerable" /> 上可能会并行运行迭代，而且可以监视和操作循环的状态。</summary>
        <returns>包含有关已完成的循环部分的信息的结构。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `body`委托中每个元素调用一次`source`可枚举。 提供使用以下参数： 当前元素，<xref:System.Threading.Tasks.ParallelLoopState>可用于中断循环过早的实例、 当前元素的索引 (<xref:System.Int64>)，以及可能执行的迭代之间共享某些本地状态在同一线程中。  
  
 `localInit`参与循环的执行，这些任务的每个返回初始本地状态的每个任务一次调用委托。 这些初始状态传递给第一个`body`上每个任务的调用。 然后，每个后续正文调用返回传递给下一个正文调用一个可能已修改的状态值。 最后，每个任务上的最后一个正文调用返回传递给的州值`localFinally`委托。 `localFinally`每个任务，每个任务的本地状态执行一个最终操作一次调用委托。 在多个任务; 可能会同时调用此委托因此，必须同步对共享的任何变量的访问。  
  
 <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType>方法可能的现有任务完成其执行生存期内使用多于线程数的更多任务，并替换为新的任务。 这样，基础<xref:System.Threading.Tasks.TaskScheduler>对象机会添加，请更改或删除服务循环的线程。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> 参数为 <see langword="null" />。  
  
或 
<paramref name="body" /> 参数为 <see langword="null" />。  
  
或 
<paramref name="localInit" /> 参数为 <see langword="null" />。  
  
或 
<paramref name="localFinally" /> 参数为 <see langword="null" />。</exception>
        <exception cref="T:System.AggregateException">包含在所有线程上引发的全部单个异常的异常。</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">并行循环</related>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource,TLocal&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource,TLocal&gt; (System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TLocal&gt; localInit, Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt; body, Action&lt;TLocal&gt; localFinally);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource, TLocal&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`1&lt;!!TLocal&gt; localInit, class System.Func`4&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState, !!TLocal, !!TLocal&gt; body, class System.Action`1&lt;!!TLocal&gt; localFinally) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``2(System.Collections.Generic.IEnumerable{``0},System.Func{``1},System.Func{``0,System.Threading.Tasks.ParallelLoopState,``1,``1},System.Action{``1})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ForEach(Of TSource, TLocal) (source As IEnumerable(Of TSource), localInit As Func(Of TLocal), body As Func(Of TSource, ParallelLoopState, TLocal, TLocal), localFinally As Action(Of TLocal)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TLocal&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TLocal&gt; ^ localInit, Func&lt;TSource, System::Threading::Tasks::ParallelLoopState ^, TLocal, TLocal&gt; ^ body, Action&lt;TLocal&gt; ^ localFinally);" />
      <MemberSignature Language="F#" Value="static member ForEach : seq&lt;'Source&gt; * Func&lt;'Local&gt; * Func&lt;'Source, System.Threading.Tasks.ParallelLoopState, 'Local, 'Local&gt; * Action&lt;'Local&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, localInit, body, localFinally)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TLocal" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
        <Parameter Name="localInit" Type="System.Func&lt;TLocal&gt;" />
        <Parameter Name="body" Type="System.Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt;" />
        <Parameter Name="localFinally" Type="System.Action&lt;TLocal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">源中数据的类型。</typeparam>
        <typeparam name="TLocal">线程本地数据的类型。</typeparam>
        <param name="source">可枚举的数据源。</param>
        <param name="localInit">用于返回每个任务的本地数据的初始状态的函数委托。</param>
        <param name="body">将为每个迭代调用一次的委托。</param>
        <param name="localFinally">用于对每个任务的本地状态执行一个最终操作的委托。</param>
        <summary>执行具有线程本地数据的 <see langword="foreach" />（在 Visual Basic 中为 <see langword="For Each" />）操作，其中在 <see cref="T:System.Collections.IEnumerable" /> 上可能会并行运行迭代，而且可以监视和操作循环的状态。</summary>
        <returns>包含有关已完成的循环部分的信息的结构。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `body`委托中每个元素调用一次`source`可枚举。 提供使用以下参数： 当前元素，<xref:System.Threading.Tasks.ParallelLoopState>实例可用于中断循环过早，并可能在同一线程执行的迭代之间共享某些本地状态。  
  
 `localInit`参与循环的执行，这些任务的每个返回初始本地状态的每个任务一次调用委托。 这些初始状态传递给第一个`body`上每个任务的调用。 然后，每个后续正文调用返回传递给下一个正文调用一个可能已修改的状态值。 最后，每个任务上的最后一个正文调用返回传递给的州值`localFinally`委托。 `localFinally`每个线程上每个任务的本地状态执行一个最终操作一次调用委托。 在多个任务; 可能会同时调用此委托因此，必须同步对共享的任何变量的访问。  
  
 <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType>方法可能的现有任务完成其执行生存期内使用多于线程数的更多任务，并替换为新的任务。 这样，基础<xref:System.Threading.Tasks.TaskScheduler>对象机会添加，请更改或删除服务循环的线程。  
  
   
  
## Examples  
 下面的示例演示如何使用<xref:System.Threading.Tasks.Parallel.ForEach%2A>与本地状态的方法：  
  
 [!code-csharp[System.Threading.Tasks.Parallel#02](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.parallel/cs/parallelforeach.cs#02)]
 [!code-vb[System.Threading.Tasks.Parallel#02](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.parallel/vb/parallelforeach.vb#02)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> 参数为 <see langword="null" />。  
  
或 
<paramref name="body" /> 参数为 <see langword="null" />。  
  
或 
<paramref name="localInit" /> 参数为 <see langword="null" />。  
  
或 
<paramref name="localFinally" /> 参数为 <see langword="null" />。</exception>
        <exception cref="T:System.AggregateException">包含在所有线程上引发的全部单个异常的异常。</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">并行循环</related>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource,TLocal&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource,TLocal&gt; (System.Collections.Concurrent.OrderablePartitioner&lt;TSource&gt; source, System.Threading.Tasks.ParallelOptions parallelOptions, Func&lt;TLocal&gt; localInit, Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,long,TLocal,TLocal&gt; body, Action&lt;TLocal&gt; localFinally);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource, TLocal&gt;(class System.Collections.Concurrent.OrderablePartitioner`1&lt;!!TSource&gt; source, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Func`1&lt;!!TLocal&gt; localInit, class System.Func`5&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState, int64, !!TLocal, !!TLocal&gt; body, class System.Action`1&lt;!!TLocal&gt; localFinally) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``2(System.Collections.Concurrent.OrderablePartitioner{``0},System.Threading.Tasks.ParallelOptions,System.Func{``1},System.Func{``0,System.Threading.Tasks.ParallelLoopState,System.Int64,``1,``1},System.Action{``1})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TLocal&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Concurrent::OrderablePartitioner&lt;TSource&gt; ^ source, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Func&lt;TLocal&gt; ^ localInit, Func&lt;TSource, System::Threading::Tasks::ParallelLoopState ^, long, TLocal, TLocal&gt; ^ body, Action&lt;TLocal&gt; ^ localFinally);" />
      <MemberSignature Language="F#" Value="static member ForEach : System.Collections.Concurrent.OrderablePartitioner&lt;'Source&gt; * System.Threading.Tasks.ParallelOptions * Func&lt;'Local&gt; * Func&lt;'Source, System.Threading.Tasks.ParallelLoopState, int64, 'Local, 'Local&gt; * Action&lt;'Local&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, parallelOptions, localInit, body, localFinally)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TLocal" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Concurrent.OrderablePartitioner&lt;TSource&gt;" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="localInit" Type="System.Func&lt;TLocal&gt;" />
        <Parameter Name="body" Type="System.Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,System.Int64,TLocal,TLocal&gt;" />
        <Parameter Name="localFinally" Type="System.Action&lt;TLocal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">
          <paramref name="source" /> 中的元素的类型。</typeparam>
        <typeparam name="TLocal">线程本地数据的类型。</typeparam>
        <param name="source">包含原始数据源的可排序分区程序。</param>
        <param name="parallelOptions">一个对象，用于配置此操作的行为。</param>
        <param name="localInit">用于返回每个任务的本地数据的初始状态的函数委托。</param>
        <param name="body">将为每个迭代调用一次的委托。</param>
        <param name="localFinally">用于对每个任务的本地状态执行一个最终操作的委托。</param>
        <summary>执行具有 64 位索引和线程本地数据的 <see langword="foreach" />（在 Visual Basic 中为 <see langword="For Each" />）操作，其中在 <see cref="T:System.Collections.Concurrent.OrderablePartitioner`1" /> 上可能会并行运行迭代，而且可以配置循环选项，可以监视和操作循环的状态。</summary>
        <returns>包含有关已完成的循环部分的信息的结构。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 对于想要重写默认分区方案的方案提供了此重载。 例如，小型循环体可能受益于分区范围。 <xref:System.Threading.Tasks.Parallel.ForEach%2A>方法需要自定义分区程序来支持动态分区。 有关详细信息，请参阅[PLINQ 和 TPL 的自定义分区程序](~/docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md)并[如何： 实现动态分区](~/docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md)。  
  
 `localInit`参与循环的执行，这些任务的每个返回初始本地状态的每个任务一次调用委托。 这些初始状态传递给第一个`body`上每个任务的调用。 然后，每个后续正文调用返回传递给下一个正文调用一个可能已修改的状态值。 最后，每个线程上的最后一个正文调用返回传递给的州值`localFinally`委托。 `localFinally`每个任务，每个任务的本地状态执行一个最终操作一次调用委托。 在多个任务; 可能会同时调用此委托因此，必须同步对共享的任何变量的访问。  
  
 <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType>方法可能的现有任务完成其执行生存期内使用多于线程数的更多任务，并替换为新的任务。 这样，基础<xref:System.Threading.Tasks.TaskScheduler>对象机会添加，请更改或删除服务循环的线程。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> 参数为 <see langword="null" />。  
  
或 
<paramref name="parallelOptions" /> 参数为 <see langword="null" />。  
  
或 
<paramref name="body" /> 参数为 <see langword="null" />。  
  
或 
<paramref name="localInit" /> 或 <paramref name="localFinally" /> 参数为 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" />
          <see cref="T:System.Collections.Concurrent.Partitioner" /> 中的 <see cref="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions" /> 属性返回 <see langword="false" />，或者分区程序返回 <see langword="null" /> 分区。</exception>
        <exception cref="T:System.AggregateException">包含在所有线程上引发的全部单个异常的异常。</exception>
        <exception cref="T:System.OperationCanceledException">在 <paramref name="parallelOptions" /> 取消的 <see cref="T:System.Threading.CancellationToken" /> 参数。</exception>
        <exception cref="T:System.ObjectDisposedException">在 <paramref name="parallelOptions" /> 中与 <see cref="T:System.Threading.CancellationTokenSource" /> 关联的 <see cref="T:System.Threading.CancellationToken" /> 已被释放。</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">并行循环</related>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource,TLocal&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource,TLocal&gt; (System.Collections.Concurrent.Partitioner&lt;TSource&gt; source, System.Threading.Tasks.ParallelOptions parallelOptions, Func&lt;TLocal&gt; localInit, Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt; body, Action&lt;TLocal&gt; localFinally);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource, TLocal&gt;(class System.Collections.Concurrent.Partitioner`1&lt;!!TSource&gt; source, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Func`1&lt;!!TLocal&gt; localInit, class System.Func`4&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState, !!TLocal, !!TLocal&gt; body, class System.Action`1&lt;!!TLocal&gt; localFinally) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``2(System.Collections.Concurrent.Partitioner{``0},System.Threading.Tasks.ParallelOptions,System.Func{``1},System.Func{``0,System.Threading.Tasks.ParallelLoopState,``1,``1},System.Action{``1})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TLocal&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Concurrent::Partitioner&lt;TSource&gt; ^ source, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Func&lt;TLocal&gt; ^ localInit, Func&lt;TSource, System::Threading::Tasks::ParallelLoopState ^, TLocal, TLocal&gt; ^ body, Action&lt;TLocal&gt; ^ localFinally);" />
      <MemberSignature Language="F#" Value="static member ForEach : System.Collections.Concurrent.Partitioner&lt;'Source&gt; * System.Threading.Tasks.ParallelOptions * Func&lt;'Local&gt; * Func&lt;'Source, System.Threading.Tasks.ParallelLoopState, 'Local, 'Local&gt; * Action&lt;'Local&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, parallelOptions, localInit, body, localFinally)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TLocal" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Concurrent.Partitioner&lt;TSource&gt;" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="localInit" Type="System.Func&lt;TLocal&gt;" />
        <Parameter Name="body" Type="System.Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt;" />
        <Parameter Name="localFinally" Type="System.Action&lt;TLocal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">
          <paramref name="source" /> 中的元素的类型。</typeparam>
        <typeparam name="TLocal">线程本地数据的类型。</typeparam>
        <param name="source">包含原始数据源的分区程序。</param>
        <param name="parallelOptions">一个对象，用于配置此操作的行为。</param>
        <param name="localInit">用于返回每个任务的本地数据的初始状态的函数委托。</param>
        <param name="body">将为每个迭代调用一次的委托。</param>
        <param name="localFinally">用于对每个任务的本地状态执行一个最终操作的委托。</param>
        <summary>执行具有线程本地数据的 <see langword="foreach" />（在 Visual Basic 中为 <see langword="For Each" />）操作，其中在 <see cref="T:System.Collections.Concurrent.Partitioner" /> 上可能会并行运行迭代，而且可以配置循环选项，可以监视和操作循环的状态。</summary>
        <returns>包含有关已完成的循环部分的信息的结构。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 对于想要重写默认分区方案的方案提供了此重载。 例如，小型循环体可能受益于分区范围。 <xref:System.Threading.Tasks.Parallel.ForEach%2A>方法需要自定义分区程序来支持动态分区。 对于使用小型循环体可能会受益于静态范围分区方案提供了此重载。 分区程序必须支持动态分区。  有关详细信息，请参阅[PLINQ 和 TPL 的自定义分区程序](~/docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md)并[如何： 实现动态分区](~/docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md)。  
  
 `localInit`参与循环的执行，这些任务的每个返回初始本地状态的每个任务一次调用委托。 这些初始状态传递给第一个`body`上每个任务的调用。 然后，每个后续正文调用返回传递给下一个正文调用一个可能已修改的状态值。 最后，每个任务上的最后一个正文调用返回传递给的州值`localFinally`委托。 `localFinally`每个任务，每个任务的本地状态执行一个最终操作一次调用委托。 在多个任务; 可能会同时调用此委托因此，必须同步对共享的任何变量的访问。  
  
 <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType>方法可能的现有任务完成其执行生存期内使用多于线程数的更多任务，并替换为新的任务。 这样，基础<xref:System.Threading.Tasks.TaskScheduler>对象机会添加，请更改或删除服务循环的线程。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> 参数为 <see langword="null" />。  
  
或 
<paramref name="parallelOptions" /> 参数为 <see langword="null" />。  
  
或 
<paramref name="body" /> 参数为 <see langword="null" />。  
  
或 
<paramref name="localInit" /> 参数为 <see langword="null" />。  
  
或 
<paramref name="localFinally" /> 参数为 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" />
          <see cref="T:System.Collections.Concurrent.Partitioner" /> 中的 <see cref="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions" /> 属性返回 <see langword="false" />，或者分区程序返回 <see langword="null" /> 分区。</exception>
        <exception cref="T:System.AggregateException">包含在所有线程上引发的全部单个异常的异常。</exception>
        <exception cref="T:System.OperationCanceledException">在 <paramref name="parallelOptions" /> 取消的 <see cref="T:System.Threading.CancellationToken" /> 参数。</exception>
        <exception cref="T:System.ObjectDisposedException">在 <paramref name="parallelOptions" /> 中与 <see cref="T:System.Threading.CancellationTokenSource" /> 关联的 <see cref="T:System.Threading.CancellationToken" /> 已被释放。</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">并行循环</related>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource,TLocal&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource,TLocal&gt; (System.Collections.Generic.IEnumerable&lt;TSource&gt; source, System.Threading.Tasks.ParallelOptions parallelOptions, Func&lt;TLocal&gt; localInit, Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,long,TLocal,TLocal&gt; body, Action&lt;TLocal&gt; localFinally);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource, TLocal&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Func`1&lt;!!TLocal&gt; localInit, class System.Func`5&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState, int64, !!TLocal, !!TLocal&gt; body, class System.Action`1&lt;!!TLocal&gt; localFinally) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``2(System.Collections.Generic.IEnumerable{``0},System.Threading.Tasks.ParallelOptions,System.Func{``1},System.Func{``0,System.Threading.Tasks.ParallelLoopState,System.Int64,``1,``1},System.Action{``1})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TLocal&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Func&lt;TLocal&gt; ^ localInit, Func&lt;TSource, System::Threading::Tasks::ParallelLoopState ^, long, TLocal, TLocal&gt; ^ body, Action&lt;TLocal&gt; ^ localFinally);" />
      <MemberSignature Language="F#" Value="static member ForEach : seq&lt;'Source&gt; * System.Threading.Tasks.ParallelOptions * Func&lt;'Local&gt; * Func&lt;'Source, System.Threading.Tasks.ParallelLoopState, int64, 'Local, 'Local&gt; * Action&lt;'Local&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, parallelOptions, localInit, body, localFinally)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TLocal" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="localInit" Type="System.Func&lt;TLocal&gt;" />
        <Parameter Name="body" Type="System.Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,System.Int64,TLocal,TLocal&gt;" />
        <Parameter Name="localFinally" Type="System.Action&lt;TLocal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">源中数据的类型。</typeparam>
        <typeparam name="TLocal">线程本地数据的类型。</typeparam>
        <param name="source">可枚举的数据源。</param>
        <param name="parallelOptions">一个对象，用于配置此操作的行为。</param>
        <param name="localInit">用于返回每个任务的本地数据的初始状态的函数委托。</param>
        <param name="body">将为每个迭代调用一次的委托。</param>
        <param name="localFinally">用于对每个任务的本地状态执行一个最终操作的委托。</param>
        <summary>执行具有线程本地数据和 64 位索引的 <see langword="foreach" />（在 Visual Basic 中为 <see langword="For Each" />）操作，其中在 <see cref="T:System.Collections.IEnumerable" /> 上可能会并行运行迭代，而且可以配置循环选项，可以监视和操作循环的状态。</summary>
        <returns>包含有关已完成的循环部分的信息的结构。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `body`委托中每个元素调用一次`source`可枚举。 提供使用以下参数： 当前元素，<xref:System.Threading.Tasks.ParallelLoopState>可用于中断循环过早的实例、 当前元素的索引 (<xref:System.Int64>)，以及可能执行的迭代之间共享某些本地状态在同一线程中。  
  
 `localInit`参与循环的执行，这些任务的每个返回初始本地状态的每个任务一次调用委托。 这些初始状态传递给第一个`body`上每个任务的调用。 然后，每个后续正文调用返回传递给下一个正文调用一个可能已修改的状态值。 最后，每个任务上的最后一个正文调用返回传递给的州值`localFinally`委托。 `localFinally`每个线程上每个任务的本地状态执行一个最终操作一次调用委托。 在多个任务; 可能会同时调用此委托因此，必须同步对共享的任何变量的访问。  
  
 <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType>方法可能的现有任务完成其执行生存期内使用多于线程数的更多任务，并替换为新的任务。 这样，基础<xref:System.Threading.Tasks.TaskScheduler>对象机会添加，请更改或删除服务循环的线程。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> 参数为 <see langword="null" />。  
  
或 
<paramref name="parallelOptions" /> 参数为 <see langword="null" />。  
  
或 
<paramref name="body" /> 参数为 <see langword="null" />。  
  
或 
<paramref name="localInit" /> 参数为 <see langword="null" />。  
  
或 
<paramref name="localFinally" /> 参数为 <see langword="null" />。</exception>
        <exception cref="T:System.OperationCanceledException">在 <paramref name="parallelOptions" /> 取消的 <see cref="T:System.Threading.CancellationToken" /> 参数。</exception>
        <exception cref="T:System.ObjectDisposedException">在 <paramref name="parallelOptions" /> 中与 <see cref="T:System.Threading.CancellationTokenSource" /> 关联的 <see cref="T:System.Threading.CancellationToken" /> 已被释放。</exception>
        <exception cref="T:System.AggregateException">包含在所有线程上引发的全部单个异常的异常。</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">并行循环</related>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource,TLocal&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource,TLocal&gt; (System.Collections.Generic.IEnumerable&lt;TSource&gt; source, System.Threading.Tasks.ParallelOptions parallelOptions, Func&lt;TLocal&gt; localInit, Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt; body, Action&lt;TLocal&gt; localFinally);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource, TLocal&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Func`1&lt;!!TLocal&gt; localInit, class System.Func`4&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState, !!TLocal, !!TLocal&gt; body, class System.Action`1&lt;!!TLocal&gt; localFinally) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``2(System.Collections.Generic.IEnumerable{``0},System.Threading.Tasks.ParallelOptions,System.Func{``1},System.Func{``0,System.Threading.Tasks.ParallelLoopState,``1,``1},System.Action{``1})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TLocal&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Func&lt;TLocal&gt; ^ localInit, Func&lt;TSource, System::Threading::Tasks::ParallelLoopState ^, TLocal, TLocal&gt; ^ body, Action&lt;TLocal&gt; ^ localFinally);" />
      <MemberSignature Language="F#" Value="static member ForEach : seq&lt;'Source&gt; * System.Threading.Tasks.ParallelOptions * Func&lt;'Local&gt; * Func&lt;'Source, System.Threading.Tasks.ParallelLoopState, 'Local, 'Local&gt; * Action&lt;'Local&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, parallelOptions, localInit, body, localFinally)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TLocal" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="localInit" Type="System.Func&lt;TLocal&gt;" />
        <Parameter Name="body" Type="System.Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt;" />
        <Parameter Name="localFinally" Type="System.Action&lt;TLocal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">源中数据的类型。</typeparam>
        <typeparam name="TLocal">线程本地数据的类型。</typeparam>
        <param name="source">可枚举的数据源。</param>
        <param name="parallelOptions">一个对象，用于配置此操作的行为。</param>
        <param name="localInit">用于返回每个任务的本地数据的初始状态的函数委托。</param>
        <param name="body">将为每个迭代调用一次的委托。</param>
        <param name="localFinally">用于对每个任务的本地状态执行一个最终操作的委托。</param>
        <summary>执行具有线程本地数据的 <see langword="foreach" />（在 Visual Basic 中为 <see langword="For Each" />）操作，其中在 <see cref="T:System.Collections.IEnumerable" /> 上可能会并行运行迭代，而且可以配置循环选项，可以监视和操作循环的状态。</summary>
        <returns>包含有关已完成的循环部分的信息的结构。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `body`委托中每个元素调用一次`source`可枚举。 提供使用以下参数： 当前元素，<xref:System.Threading.Tasks.ParallelLoopState>实例可用于中断循环过早，并可能在同一线程执行的迭代之间共享某些本地状态。  
  
 `localInit`参与循环的执行，这些任务的每个返回初始本地状态的每个任务一次调用委托。 这些初始状态传递给第一个`body`上每个任务的调用。 然后，每个后续正文调用返回传递给下一个正文调用一个可能已修改的状态值。 最后，每个任务上的最后一个正文调用返回传递给的州值`localFinally`委托。 `localFinally`每个线程上每个任务的本地状态执行一个最终操作一次调用委托。 在多个任务; 可能会同时调用此委托因此，必须同步对共享的任何变量的访问。  
  
 <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType>方法可能的现有任务完成其执行生存期内使用多于线程数的更多任务，并替换为新的任务。 这样，基础<xref:System.Threading.Tasks.TaskScheduler>对象机会添加，请更改或删除服务循环的线程。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> 参数为 <see langword="null" />。  
  
或 
<paramref name="parallelOptions" /> 参数为 <see langword="null" />。  
  
或 
<paramref name="body" /> 参数为 <see langword="null" />。  
  
或 
<paramref name="localInit" /> 参数为 <see langword="null" />。  
  
或 
<paramref name="localFinally" /> 参数为 <see langword="null" />。</exception>
        <exception cref="T:System.OperationCanceledException">在 <paramref name="parallelOptions" /> 取消的 <see cref="T:System.Threading.CancellationToken" /> 参数。</exception>
        <exception cref="T:System.ObjectDisposedException">在 <paramref name="parallelOptions" /> 中与 <see cref="T:System.Threading.CancellationTokenSource" /> 关联的 <see cref="T:System.Threading.CancellationToken" /> 已被释放。</exception>
        <exception cref="T:System.AggregateException">包含在所有线程上引发的全部单个异常的异常。</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">并行循环</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Invoke">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>尽可能并行执行提供的每个操作。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public static void Invoke (params Action[] actions);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Invoke(class System.Action[] actions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.Invoke(System.Action[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Invoke (ParamArray actions As Action())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Invoke(... cli::array &lt;Action ^&gt; ^ actions);" />
      <MemberSignature Language="F#" Value="static member Invoke : Action[] -&gt; unit" Usage="System.Threading.Tasks.Parallel.Invoke actions" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="actions" Type="System.Action[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="actions">要执行的 <see cref="T:System.Action" /> 数组。</param>
        <summary>尽可能并行执行提供的每个操作。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法可以用于执行的一组操作，可能会并行。  
  
 有关在操作执行或它们是否并行执行的顺序不作任何保证。 此方法不返回每个提供操作完成之前，而不考虑是否在完成出现正常或异常终止。  
  
 有关详细信息，请参阅[如何：使用 Parallel.Invoke 执行并行操作](~/docs/standard/parallel-programming/how-to-use-parallel-invoke-to-execute-parallel-operations.md)。  
  
   
  
## Examples  
 此示例演示如何使用<xref:System.Threading.Tasks.Parallel.Invoke%2A>与其他方法、 匿名委托和 lambda 表达式的方法。  
  
 [!code-csharp[System.Threading.Tasks.Parallel#01](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.parallel/cs/parallelinvoke.cs#01)]
 [!code-vb[System.Threading.Tasks.Parallel#01](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.parallel/vb/parallelinvoke.vb#01)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="actions" /> 参数为 <see langword="null" />。</exception>
        <exception cref="T:System.AggregateException">当 <paramref name="actions" /> 数组中的任何操作引发异常时引发的异常。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="actions" />数组包含 <see langword="null" /> 个元素。</exception>
      </Docs>
    </Member>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public static void Invoke (System.Threading.Tasks.ParallelOptions parallelOptions, params Action[] actions);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Invoke(class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Action[] actions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.Invoke(System.Threading.Tasks.ParallelOptions,System.Action[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Invoke(System::Threading::Tasks::ParallelOptions ^ parallelOptions, ... cli::array &lt;Action ^&gt; ^ actions);" />
      <MemberSignature Language="F#" Value="static member Invoke : System.Threading.Tasks.ParallelOptions * Action[] -&gt; unit" Usage="System.Threading.Tasks.Parallel.Invoke (parallelOptions, actions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="actions" Type="System.Action[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="parallelOptions">一个对象，用于配置此操作的行为。</param>
        <param name="actions">要执行的操作数组。</param>
        <summary>执行所提供的每个操作，而且尽可能并行运行，除非用户取消了操作。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法可以用于执行的一组操作，可能会并行。 中的取消标记传递<xref:System.Threading.Tasks.ParallelOptions>结构使调用方取消整个操作。 有关详细信息，请参阅[托管线程中的取消](~/docs/standard/threading/cancellation-in-managed-threads.md)。  
  
 有关在操作执行或它们是否并行执行的顺序不作任何保证。 此方法不返回每个提供操作完成之前，而不考虑是否在完成出现正常或异常终止。  
  
 有关详细信息，请参阅[如何：使用 Parallel.Invoke 执行并行操作](~/docs/standard/parallel-programming/how-to-use-parallel-invoke-to-execute-parallel-operations.md)。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException">
          <see cref="T:System.Threading.CancellationToken" /> 处于 <paramref name="parallelOptions" /> 设置。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="actions" /> 参数为 <see langword="null" />。  
  
或 
<paramref name="parallelOptions" /> 参数为 <see langword="null" />。</exception>
        <exception cref="T:System.AggregateException">当 <paramref name="actions" /> 数组中的任何操作引发异常时引发的异常。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="actions" />数组包含 <see langword="null" /> 个元素。</exception>
        <exception cref="T:System.ObjectDisposedException">在 <paramref name="parallelOptions" /> 中与 <see cref="T:System.Threading.CancellationTokenSource" /> 关联的 <see cref="T:System.Threading.CancellationToken" /> 已被释放。</exception>
      </Docs>
    </Member>
  </Members>
</Type>