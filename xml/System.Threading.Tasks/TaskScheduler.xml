<Type Name="TaskScheduler" FullName="System.Threading.Tasks.TaskScheduler">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="9101875b3c768590b23db0c0c08ee17d09fc5e38" />
    <Meta Name="ms.sourcegitcommit" Value="5a49536d99d2d0b54e4cb7280870903e043272df" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-CN" />
    <Meta Name="ms.lasthandoff" Value="07/03/2018" />
    <Meta Name="ms.locfileid" Value="37609217" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class TaskScheduler" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit TaskScheduler extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Threading.Tasks.TaskScheduler" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class TaskScheduler" />
  <TypeSignature Language="C++ CLI" Value="public ref class TaskScheduler abstract" />
  <TypeSignature Language="F#" Value="type TaskScheduler = class" />
  <AssemblyInfo>
    <AssemblyName>System.Threading.Tasks</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Diagnostics.DebuggerDisplay("Id={Id}")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Diagnostics.DebuggerTypeProxy(typeof(System.Threading.Tasks.TaskScheduler/SystemThreadingTasks_TaskSchedulerDebugView))</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>表示一个处理将任务排队到线程中的低级工作的对象。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 实例<xref:System.Threading.Tasks.TaskScheduler>类表示任务计划程序。 任务计划程序确保最终执行任务作业。  
  
 默认的任务计划程序基于 .NET Framework 4 线程池，提供工作窃取实现负载平衡、线程注入/退出以实现最大吞吐量，并提供整体卓越性能。 它应足以满足大多数方案。  
  
 <xref:System.Threading.Tasks.TaskScheduler>类也用作所有可自定义计划逻辑的扩展点。  这包括机制，如应该向调试器公开如何安排执行的任务和如何计划的任务。 如果需要特殊功能，可以创建自定义计划程序并启用对特定任务或查询。  
  
 本主题内容：  
[默认任务计划程序和线程池](#Default)  
 [全局队列与本地队列](#Queues)  
 [工作窃取](#Stealing)  
 [长时间运行的任务](#LongRunning)  
 [任务内联](#Inlining)  
[指定同步上下文](#Sync)  
  
<a name="Default"></a>   
## <a name="the-default-task-scheduler-and-the-thread-pool"></a>默认任务计划程序和线程池  
 任务并行库和 PLINQ 的默认计划程序使用.NET Framework 线程池，由表示<xref:System.Threading.ThreadPool>类进行排队并执行工作。 线程池会使用提供的信息<xref:System.Threading.Tasks.Task>类型来有效地支持并行任务和查询通常表示的细化并行 （生存期较短的工作单位）。  
  
<a name="Queues"></a>   
### <a name="the-global-queue-vs-local-queues"></a>全局队列与本地队列  
 线程池维护全局先进先出 （先入先出） 工作队列中的每个应用程序域中的线程。 每当程序调用<xref:System.Threading.ThreadPool.QueueUserWorkItem%2A?displayProperty=nameWithType>(或<xref:System.Threading.ThreadPool.UnsafeQueueUserWorkItem%2A?displayProperty=nameWithType>) 方法，工作是放置在此共享队列上并最终取消排队到下一个可用线程上。 从.NET Framework 4 开始，此队列有了改进，可使用类似于无锁算法<xref:System.Collections.Concurrent.ConcurrentQueue%601>类。 通过使用此无锁实现，线程池会花费更少时间排队和离队工作项时。 此性能优势可供使用的线程池的所有程序。  
  
 最高级任务（即不在其他任务的上下文中创建的任务）与任何其他工作项一样放在全局队列上。 但是，嵌套任务或子任务（在其他任务的上下文中创建）的处理方式大不相同。 子任务或嵌套任务放置在特定于执行父任务的线程的本地队列上。 父任务可能是最高级任务，也可能是其他任务的子任务。 当此线程准备好执行更多工作时，首先查看本地队列。 如果工作项在此处等待，即可快速访问它们。 后进先出顺序 (LIFO) 以保留缓存区域并减少争用中访问的本地队列。 有关子任务和嵌套的任务的详细信息，请参阅[附加和分离的子任务](~/docs/standard/parallel-programming/attached-and-detached-child-tasks.md)。  
  
 使用本地队列不仅可减少全局队列上的压力，而且还会利用数据局部性。 本地中的工作项排入队列经常在物理上是相互在内存中的引用数据结构。 在这些情况下，数据已在缓存中之后的第一个任务已运行，并且可以快速访问。 这两[并行 LINQ (PLINQ)](~/docs/standard/parallel-programming/parallel-linq-plinq.md)和<xref:System.Threading.Tasks.Parallel>广泛，类使用嵌套任务和子任务，并通过使用本地工作队列实现显著的加速。  
  
<a name="Stealing"></a>   
### <a name="work-stealing"></a>工作窃取  
 从.NET Framework 4 开始，线程池还提供工作窃取算法，以帮助确保没有线程处于空闲状态时其他人仍具有在各自队列中工作。 当线程池线程准备好执更多工作时，首先查看其本地队列的开头，再查看全局队列，然后查看其他线程的本地队列。 如果在其他线程的本地队列中找到工作项，它会先应用试探法以确保可有效运行工作。 如果可以但它取消队列的工作项的结尾 （按 FIFO 顺序）。 这样可以减少每个本地队列上的争用并保留数据位置。 此体系结构有助于线程池进行负载平衡不是以前的版本更有效地工作。  
  
<a name="LongRunning"></a>   
### <a name="long-running-tasks"></a>长时间运行的任务  
 可能想要显式防止将任务放到本地队列上。 例如，你可能知道特定工作项将运行相对长的时间并可能阻塞本地队列中的所有其他工作项。 在这种情况下，可指定 <xref:System.Threading.Tasks.TaskCreationOptions?displayProperty=nameWithType> 选项，它提示附加线程执行任务时可能需要计划程序，以使此任务不阻塞本地队列中其他线程或工作项的向前推动。 通过使用此选项可以避免线程池完全，包括全局和本地队列。  
  
<a name="Inlining"></a>   
### <a name="task-inlining"></a>任务内联  
 在某些情况下当<xref:System.Threading.Tasks.Task>处于等待状态，它可能是以同步方式执行上执行等待操作的线程。 这可提高性能，从而无需进行其他线程，而使用现有的线程，否则被阻塞的。 若要防止造成的错误，任务内联时才出现在相关线程的本地队列中找到等待目标。  
  
<a name="Sync"></a>   
## <a name="specifying-a-synchronization-context"></a>指定同步上下文  
 可使用 <xref:System.Threading.Tasks.TaskScheduler.FromCurrentSynchronizationContext%2A?displayProperty=nameWithType> 方法指定任务应计划在特定线程上运行。 在 Windows 窗体和 Windows Presentation Foundation 等框架中此操作非常有用，在此类框架中对用户界面对象的访问限制为只可访问在创建 UI 对象的同一线程上运行的代码。  
  
 下面的示例使用<xref:System.Threading.Tasks.TaskScheduler.FromCurrentSynchronizationContext%2A?displayProperty=nameWithType>用于计划的任务，在创建用户界面 (UI) 控件所在的同一线程上的 Windows Presentation Foundation (WPF) 应用中的方法。   该示例创建马赛克从指定的目录中随机选择的映像。 WPF 对象用于加载和重设图像大小。 原始像素然后传递给一个任务，使用<xref:System.Threading.Tasks.Parallel.For%2A>循环，以向大型的单字节数组写入像素数据。 因为没有两个磁贴占用相同的数组元素不需要进行同步。 因为独立于任何其他磁贴计算其位置，则还可以按任意顺序写入磁贴。 大型数组然后传递到其中的像素数据加载到图像控件在 UI 线程运行的任务。  
  
 该示例将数据从 UI 线程、 通过使用并行循环对其进行修改和<xref:System.Threading.Tasks.Task>对象，它们然后将其传递回 UI 线程运行的任务。 当您必须使用任务并行库执行操作由 WPF API 不支持或不足够快的速度时，此方法非常有用。 在 WPF 中创建映像马赛克另一种方法是使用<xref:System.Windows.Controls.WrapPanel?displayProperty=nameWithType>控件并将图像添加到它。 <xref:System.Windows.Controls.WrapPanel>负责处理定位磁贴。 但是，仅可以在 UI 线程上执行这项工作。  
  
 [!code-csharp[TPL_SyncContext#01](~/samples/snippets/csharp/VS_Snippets_Misc/tpl_synccontext/cs/mainwindow.xaml.cs#01)]
 [!code-vb[TPL_SyncContext#01](~/samples/snippets/visualbasic/VS_Snippets_Misc/tpl_synccontext/vb/MainWindow.xaml.vb#01)]  
  
 若要创建该示例，在 Visual Studio 中创建一个 WPF 应用程序项目并将其分配所选的名称。 然后执行以下操作：  
  
1.  在设计视图中拖动<xref:System.Windows.Controls.Image>控件从**工具箱**到设计图面。 在 XAML 视图中，指定的水平对齐方式为"Left"。 因为在运行时动态调整控件大小并不重要。 接受默认名称，"图像"。  
  
2.  拖动<xref:System.Windows.Controls.Button>控件从**工具箱**到应用程序窗口的左下角。 双击按钮以添加<xref:System.Windows.Controls.Primitives.ButtonBase.Click>事件处理程序。 在 XAML 视图中，指定<xref:System.Windows.Controls.ContentControl.Content%2A>按钮为"使马赛克"并指定"Left"作为其水平对齐方式的属性。 接受默认名称，"button"。  
  
3.  将此示例中的代码替换为 MainWindow.xaml.cs 或 MainWindow.xaml.vb 文件的全部内容。 请确保工作区的名称与项目名称相匹配。  
  
4.  该示例从名为 C:\Users\Public\Pictures\Sample Pictures 的目录中读取 JPEG 图像\\。 创建目录，将某些映像放入其中，或者更改用于引用包含映像的一些其他目录的路径。  
  
 此示例中有一些限制。 例如，支持仅 32 位的每像素的图像;以其他格式的映像已损坏的<xref:System.Windows.Media.Imaging.BitmapImage>调整大小操作过程中的对象。 此外，源映像所有必须大于磁贴大小。 在进一步的练习，可以添加功能，用于处理多个像素格式和文件的大小。  
  
   
  
## Examples  
 下面的示例取自[使用.NET Framework 4 的并行编程示例](http://go.microsoft.com/fwlink/?LinkID=165717)MSDN 代码库网站上。  它将创建的自定义任务计划程序限制的应用使用的线程数。 然后会启动两个任务组，并显示有关该任务在其执行任务的线程的信息。  
  
 [!code-csharp[TPL_Schedulers#02](~/samples/snippets/csharp/VS_Snippets_Misc/tpl_schedulers/cs/limitex1.cs#02)]
 [!code-vb[TPL_Schedulers#02](~/samples/snippets/visualbasic/VS_Snippets_Misc/tpl_schedulers/vb/module2.vb#02)]  
  
 此外，多个示例任务计划程序可在代码库上：[使用.NET Framework 4 的并行编程示例](http://go.microsoft.com/fwlink/?LinkID=165717)。  
  
 ]]></format>
    </remarks>
    <threadsafe>所有成员的抽象<see cref="T:System.Threading.Tasks.TaskScheduler" />类型是线程安全的可能从多个线程同时使用。</threadsafe>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected TaskScheduler ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskScheduler.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; TaskScheduler();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>初始化 <see cref="T:System.Threading.Tasks.TaskScheduler" />。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Current">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.TaskScheduler Current { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Threading.Tasks.TaskScheduler Current" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.TaskScheduler.Current" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Current As TaskScheduler" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Threading::Tasks::TaskScheduler ^ Current { System::Threading::Tasks::TaskScheduler ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Current : System.Threading.Tasks.TaskScheduler" Usage="System.Threading.Tasks.TaskScheduler.Current" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.TaskScheduler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取与当前正在执行的任务关联的 <see cref="T:System.Threading.Tasks.TaskScheduler" />。</summary>
        <value>返回与当前正在执行的任务关联的 <see cref="T:System.Threading.Tasks.TaskScheduler" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当不能在任务中，从调用<xref:System.Threading.Tasks.TaskScheduler.Current%2A>将返回<xref:System.Threading.Tasks.TaskScheduler.Default%2A>计划程序。  
  
 有关详情，请参阅<xref:System.Threading.Tasks.TaskScheduler>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Default">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.TaskScheduler Default { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Threading.Tasks.TaskScheduler Default" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.TaskScheduler.Default" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Default As TaskScheduler" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Threading::Tasks::TaskScheduler ^ Default { System::Threading::Tasks::TaskScheduler ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Default : System.Threading.Tasks.TaskScheduler" Usage="System.Threading.Tasks.TaskScheduler.Default" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.TaskScheduler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取由 .NET Framework 提供的默认 <see cref="T:System.Threading.Tasks.TaskScheduler" /> 实例。</summary>
        <value>返回默认的 <see cref="T:System.Threading.Tasks.TaskScheduler" /> 实例。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 有关详细信息，请参阅[任务计划程序](http://msdn.microsoft.com/library/638f8ea5-21db-47a2-a934-86e1e961bf65)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~TaskScheduler ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskScheduler.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!TaskScheduler ()" />
      <MemberSignature Language="F#" Value="override this.Finalize : unit -&gt; unit" Usage="taskScheduler.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FromCurrentSynchronizationContext">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.TaskScheduler FromCurrentSynchronizationContext ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.TaskScheduler FromCurrentSynchronizationContext() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskScheduler.FromCurrentSynchronizationContext" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FromCurrentSynchronizationContext () As TaskScheduler" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::TaskScheduler ^ FromCurrentSynchronizationContext();" />
      <MemberSignature Language="F#" Value="static member FromCurrentSynchronizationContext : unit -&gt; System.Threading.Tasks.TaskScheduler" Usage="System.Threading.Tasks.TaskScheduler.FromCurrentSynchronizationContext " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.TaskScheduler</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>创建与当前 <see cref="T:System.Threading.SynchronizationContext" /> 关联的 <see cref="T:System.Threading.Tasks.TaskScheduler" />。</summary>
        <returns>与当前 <see cref="T:System.Threading.SynchronizationContext" /> 关联的 <see cref="T:System.Threading.Tasks.TaskScheduler" />，由 <see cref="P:System.Threading.SynchronizationContext.Current" /> 确定。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 所有<xref:System.Threading.Tasks.Task>实例中排队返回计划程序将执行通过调用<xref:System.Threading.SynchronizationContext.Post%2A>该上下文上的方法。  
  
 有关详细信息，请参阅[任务计划程序](http://msdn.microsoft.com/library/638f8ea5-21db-47a2-a934-86e1e961bf65)。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">当前的 SynchronizationContext 不能用作 TaskScheduler。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetScheduledTasks">
      <MemberSignature Language="C#" Value="protected abstract System.Collections.Generic.IEnumerable&lt;System.Threading.Tasks.Task&gt; GetScheduledTasks ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class System.Threading.Tasks.Task&gt; GetScheduledTasks() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskScheduler.GetScheduledTasks" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function GetScheduledTasks () As IEnumerable(Of Task)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract System::Collections::Generic::IEnumerable&lt;System::Threading::Tasks::Task ^&gt; ^ GetScheduledTasks();" />
      <MemberSignature Language="F#" Value="abstract member GetScheduledTasks : unit -&gt; seq&lt;System.Threading.Tasks.Task&gt;" Usage="taskScheduler.GetScheduledTasks " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Threading.Tasks.Task&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>仅对于调试器支持，生成当前排队到计划程序中等待执行的 <see cref="T:System.Threading.Tasks.Task" /> 实例的枚举。</summary>
        <returns>一个允许调试器遍历当前排队到此计划程序中的任务的枚举。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 一个类派生自<xref:System.Threading.Tasks.TaskScheduler>为了支持与调试器集成实现此方法。 调试器请求访问数据时，此方法仅调用由.NET Framework 中。 将遍历的调试实用程序来访问任务的可枚举项返回当前排队到此计划程序，使调试器能够提供此信息在用户界面中的表示形式。  
  
 请务必注意，调用此方法时，此进程中的所有其他线程会被冻结。 因此，很重要，可以避免与其他线程同步，这可能导致阻塞。 如果同步是必需的并且你将无法获取锁在这种方法，然后应引发异常，以便调试器不会挂起。 下面的示例显示了 C# 中的一种可行方法：  
  
```  
protected override IEnumerable<Task> GetScheduledTasks()  
{  
    bool lockTaken = false;  
    try  
    {  
        Monitor.TryEnter(_syncObj, ref lockTaken);  
        if (lockTaken)  
        {  
            return _tasks.ToArray();  
        }  
        else throw new NotSupportedException();  
    }  
    finally  
    {  
    if (lockTaken) Monitor.Exit(_syncObj);  
    }}  
```  
  
 此外，此方法，并返回可枚举不能修改任何全局可见状态。  
  
 返回可枚举应永远不会为 null。 如果当前没有排队的任务，应改为返回空的可枚举。  
  
 开发人员要实现自定义调试器不应直接调用此方法，但应使用的内部包装方法`GetScheduledTasksForDebugger`改为： `internal Task[] GetScheduledTasksForDebugger()`。 此包装器方法返回任务而不是一个可枚举对象的数组。 若要检索活动计划程序的列表，请使用内部方法`internal static TaskScheduler[] GetTaskSchedulersForDebugger()`。 此静态方法返回的所有活动数组<xref:System.Threading.Tasks.TaskScheduler>实例。 然后，可以使用`GetScheduledTasksForDebugger`上每个计划程序实例要检索其计划的任务的列表。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">此计划程序无法在此时生成排队任务的列表。</exception>
      </Docs>
    </Member>
    <Member MemberName="Id">
      <MemberSignature Language="C#" Value="public int Id { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Id" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.TaskScheduler.Id" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Id As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Id { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Id : int" Usage="System.Threading.Tasks.TaskScheduler.Id" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取此 <see cref="T:System.Threading.Tasks.TaskScheduler" /> 的唯一 ID。</summary>
        <value>返回此 <see cref="T:System.Threading.Tasks.TaskScheduler" /> 的唯一 ID。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 有关详细信息，请参阅[任务计划程序](http://msdn.microsoft.com/library/638f8ea5-21db-47a2-a934-86e1e961bf65)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MaximumConcurrencyLevel">
      <MemberSignature Language="C#" Value="public virtual int MaximumConcurrencyLevel { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MaximumConcurrencyLevel" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.TaskScheduler.MaximumConcurrencyLevel" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property MaximumConcurrencyLevel As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int MaximumConcurrencyLevel { int get(); };" />
      <MemberSignature Language="F#" Value="member this.MaximumConcurrencyLevel : int" Usage="System.Threading.Tasks.TaskScheduler.MaximumConcurrencyLevel" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>指示此 <see cref="T:System.Threading.Tasks.TaskScheduler" /> 能够支持的最大并发级别。</summary>
        <value>返回表示最大并发级别的一个整数。 默认计划程序返回 <see cref="F:System.Int32.MaxValue" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 有关详细信息，请参阅[任务计划程序](http://msdn.microsoft.com/library/638f8ea5-21db-47a2-a934-86e1e961bf65)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="QueueTask">
      <MemberSignature Language="C#" Value="protected internal abstract void QueueTask (System.Threading.Tasks.Task task);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void QueueTask(class System.Threading.Tasks.Task task) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskScheduler.QueueTask(System.Threading.Tasks.Task)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; abstract void QueueTask(System::Threading::Tasks::Task ^ task);" />
      <MemberSignature Language="F#" Value="abstract member QueueTask : System.Threading.Tasks.Task -&gt; unit" Usage="taskScheduler.QueueTask task" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="task" Type="System.Threading.Tasks.Task" />
      </Parameters>
      <Docs>
        <param name="task">要排队的 <see cref="T:System.Threading.Tasks.Task" />。</param>
        <summary>将 <see cref="T:System.Threading.Tasks.Task" /> 排队到计划程序中。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 一个类派生自<xref:System.Threading.Tasks.TaskScheduler>实现此方法以接受在计划程序上安排的任务。  
  
 一个典型的实现就将任务存储在内部数据结构中，这将会在将来的某个时间执行这些任务的线程由提供服务。  
  
 此方法仅用来调用由.NET Framework 并不应直接由派生类调用。 这是必要的维护系统的一致性。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="task" /> 参数为 null。</exception>
      </Docs>
    </Member>
    <Member MemberName="TryDequeue">
      <MemberSignature Language="C#" Value="protected internal virtual bool TryDequeue (System.Threading.Tasks.Task task);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance bool TryDequeue(class System.Threading.Tasks.Task task) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskScheduler.TryDequeue(System.Threading.Tasks.Task)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual bool TryDequeue(System::Threading::Tasks::Task ^ task);" />
      <MemberSignature Language="F#" Value="abstract member TryDequeue : System.Threading.Tasks.Task -&gt; bool&#xA;override this.TryDequeue : System.Threading.Tasks.Task -&gt; bool" Usage="taskScheduler.TryDequeue task" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="task" Type="System.Threading.Tasks.Task" />
      </Parameters>
      <Docs>
        <param name="task">要取消排队的 <see cref="T:System.Threading.Tasks.Task" />。</param>
        <summary>尝试将以前排队到此计划程序中的 <see cref="T:System.Threading.Tasks.Task" /> 取消排队。</summary>
        <returns>一个布尔值，该值指示是否已成功地将 <paramref name="task" /> 参数取消排队。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 有关详细信息，请参阅[任务计划程序](http://msdn.microsoft.com/library/638f8ea5-21db-47a2-a934-86e1e961bf65)。  
  
 此方法中可能会执行 finally 块;因此它应返回尽可能快地因此使任何资源，如<xref:System.Threading.CancellationTokenRegistration>对象可以及时地释放。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="task" /> 参数为 null。</exception>
      </Docs>
    </Member>
    <Member MemberName="TryExecuteTask">
      <MemberSignature Language="C#" Value="protected bool TryExecuteTask (System.Threading.Tasks.Task task);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance bool TryExecuteTask(class System.Threading.Tasks.Task task) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskScheduler.TryExecuteTask(System.Threading.Tasks.Task)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; bool TryExecuteTask(System::Threading::Tasks::Task ^ task);" />
      <MemberSignature Language="F#" Value="member this.TryExecuteTask : System.Threading.Tasks.Task -&gt; bool" Usage="taskScheduler.TryExecuteTask task" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="task" Type="System.Threading.Tasks.Task" />
      </Parameters>
      <Docs>
        <param name="task">要执行的 <see cref="T:System.Threading.Tasks.Task" /> 对象。</param>
        <summary>尝试在此计划程序上执行提供的 <see cref="T:System.Threading.Tasks.Task" />。</summary>
        <returns>一个布尔值，如果成功执行了 <paramref name="task" />，则该值为 true；如果未成功执行，则该值为 false。 执行失败的常见原因是，该任务先前已经执行或者位于正在由另一个线程执行的进程中。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 计划程序实现随附<xref:System.Threading.Tasks.Task>实例，以通过执行<xref:System.Threading.Tasks.TaskScheduler.QueueTask%2A>方法或<xref:System.Threading.Tasks.TaskScheduler.TryExecuteTaskInline%2A>方法。 当计划程序被视为不适合运行提供的任务，<xref:System.Threading.Tasks.TaskScheduler.TryExecuteTask%2A>应该用于执行此操作。 TryExecuteTask 处理执行的任务，包括操作调用、 异常处理、 状态管理和生命周期控制的所有方面。  
  
 <xref:System.Threading.Tasks.TaskScheduler.TryExecuteTask%2A> 必须仅用于.NET Framework 基础结构提供给此计划程序任务。 不应该用于执行任意任务通过自定义机制而获得。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="task" /> 与此计划程序无关联。</exception>
      </Docs>
    </Member>
    <Member MemberName="TryExecuteTaskInline">
      <MemberSignature Language="C#" Value="protected abstract bool TryExecuteTaskInline (System.Threading.Tasks.Task task, bool taskWasPreviouslyQueued);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool TryExecuteTaskInline(class System.Threading.Tasks.Task task, bool taskWasPreviouslyQueued) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskScheduler.TryExecuteTaskInline(System.Threading.Tasks.Task,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract bool TryExecuteTaskInline(System::Threading::Tasks::Task ^ task, bool taskWasPreviouslyQueued);" />
      <MemberSignature Language="F#" Value="abstract member TryExecuteTaskInline : System.Threading.Tasks.Task * bool -&gt; bool" Usage="taskScheduler.TryExecuteTaskInline (task, taskWasPreviouslyQueued)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="task" Type="System.Threading.Tasks.Task" />
        <Parameter Name="taskWasPreviouslyQueued" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="task">要执行的 <see cref="T:System.Threading.Tasks.Task" />。</param>
        <param name="taskWasPreviouslyQueued">一个布尔值，该值指示任务之前是否已排队。 如果此参数为 True，则该任务以前可能已排队（已计划）；如果为 False，则已知该任务尚未排队，此时将执行此调用，以便以内联方式执行该任务，而不用将其排队。</param>
        <summary>确定是否可以在此调用中同步执行提供的 <see cref="T:System.Threading.Tasks.Task" />，如果可以，将执行该任务。</summary>
        <returns>一个布尔值，该值指示是否已以内联方式执行该任务。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 一个类派生自<xref:System.Threading.Tasks.TaskScheduler>实现此函数，以便启动该任务对象上的等待的线程上支持内联执行的任务。 内联执行是可选的并可能拒绝该请求返回 false。 但是，更多的任务可以进行内联、 更好的计划程序将进行缩放。 事实上，计划程序的内嵌元素过少可能容易出现死锁。 正确实现应确保下保证由计划程序的策略执行的请求可以成功内联。 例如，如果计划程序使用的专用的线程执行任务，该线程的任何内联请求应会成功。  
  
 如果计划程序决定执行内联执行，它应执行操作来调用基 TaskScheduler<xref:System.Threading.Tasks.TaskScheduler.TryExecuteTask%2A>与提供的任务对象，传播的返回值的方法。 它还可能适用于计划程序若要从其内部数据结构中删除内联的任务，如果决定接受内联的请求。 但请注意，在某些情况下一个计划程序可能要求内联以前未提供与它通信的任务<xref:System.Threading.Tasks.TaskScheduler.QueueTask%2A>方法。  
  
 派生的计划程序负责确保调用线程是适用于执行指定的任务，就其自身的计划和执行策略相关。  
  
 有关详细信息，请参阅[任务计划程序](http://msdn.microsoft.com/library/638f8ea5-21db-47a2-a934-86e1e961bf65)。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="task" /> 参数为 null。</exception>
        <exception cref="T:System.InvalidOperationException">已执行的 <paramref name="task" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="UnobservedTaskException">
      <MemberSignature Language="C#" Value="public static event EventHandler&lt;System.Threading.Tasks.UnobservedTaskExceptionEventArgs&gt; UnobservedTaskException;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Threading.Tasks.UnobservedTaskExceptionEventArgs&gt; UnobservedTaskException" />
      <MemberSignature Language="DocId" Value="E:System.Threading.Tasks.TaskScheduler.UnobservedTaskException" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event UnobservedTaskException As EventHandler(Of UnobservedTaskExceptionEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event EventHandler&lt;System::Threading::Tasks::UnobservedTaskExceptionEventArgs ^&gt; ^ UnobservedTaskException;" />
      <MemberSignature Language="F#" Value="member this.UnobservedTaskException : EventHandler&lt;System.Threading.Tasks.UnobservedTaskExceptionEventArgs&gt; " Usage="member this.UnobservedTaskException : System.EventHandler&lt;System.Threading.Tasks.UnobservedTaskExceptionEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>add: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>remove: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Threading.Tasks.UnobservedTaskExceptionEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>出错的任务中未观察到的异常将触发异常呈报策略时出现，默认情况下会终止进程。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此应用程序的全域性事件触发提供一种机制来防止异常升级策略 （其中，默认情况下终止进程）。  
  
 为了简化开发人员能够编写基于任务的异步代码[!INCLUDE[net_v45](~/includes/net-v45-md.md)]更改未观察到异常的默认异常行为。 尽管仍未观察到的异常引发<xref:System.Threading.Tasks.TaskScheduler.UnobservedTaskException>异常，该过程不会终止默认情况下。 相反，异常处理由运行时后引发该事件，而不考虑是否将事件处理程序观察异常。 可以配置该行为。 从开始[!INCLUDE[net_v45](~/includes/net-v45-md.md)]，可以使用的配置元素以恢复到的行为[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]并终止此过程：  
  
```xml  
<configuration>   
   <runtime>   
      <ThrowUnobservedTaskExceptions enabled="true"/>   
   </runtime>   
</configuration>  
  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>