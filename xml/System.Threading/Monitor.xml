<Type Name="Monitor" FullName="System.Threading.Monitor">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="90a2111b4e95ea3ea80a469c06f7334a9e6eac2b" />
    <Meta Name="ms.sourcegitcommit" Value="5a49536d99d2d0b54e4cb7280870903e043272df" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-CN" />
    <Meta Name="ms.lasthandoff" Value="07/03/2018" />
    <Meta Name="ms.locfileid" Value="37549125" />
  </Metadata>
  <TypeSignature Language="C#" Value="public static class Monitor" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit Monitor extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Threading.Monitor" />
  <TypeSignature Language="VB.NET" Value="Public Class Monitor" />
  <TypeSignature Language="C++ CLI" Value="public ref class Monitor abstract sealed" />
  <TypeSignature Language="F#" Value="type Monitor = class" />
  <AssemblyInfo>
    <AssemblyName>System.Threading</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>提供同步访问对象的机制。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Monitor>类使您可以通过应用和特定对象上的锁释放通过调用同步代码区域的访问<xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType>， <xref:System.Threading.Monitor.TryEnter%2A?displayProperty=nameWithType>，和<xref:System.Threading.Monitor.Exit%2A?displayProperty=nameWithType>方法。 对象锁提供的功能限制到块的代码，通常称为关键部分的访问。 一个线程拥有对象的锁，而没有其他线程可以获取该锁。 此外可以使用<xref:System.Threading.Monitor>类，以确保没有其他线程可以访问的应用程序的某个部分的代码正在执行的锁的所有者，除非其他线程正在执行使用不同的锁定的对象的代码。  
  
 本文内容：  
  
 [Monitor 类： 概述](#Overview)   
 [锁对象](#Lock)   
 [关键节](#CriticalSection)   
 [Pulse 和 PulseAll 等待](#Pulse)   
 [监视器和等待句柄](#WaitHandles)  
  
<a name="Overview"></a>   
## <a name="the-monitor-class-an-overview"></a>Monitor 类： 概述  
 <xref:System.Threading.Monitor> 具有以下功能：  
  
-   它是与按需的对象相关联。  
  
-   未绑定，这意味着它可以直接从任何上下文调用。  
  
-   实例<xref:System.Threading.Monitor>无法创建类; 方法的<xref:System.Threading.Monitor>类都是静态的。 每个方法传递控制访问的同步的对象的关键部分。  
  
> [!NOTE]
>  使用<xref:System.Threading.Monitor>字符串以外的锁对象的类 (即，不是引用类型<xref:System.String>)，不是值类型。 有关详细信息，请参阅的重载<xref:System.Threading.Monitor.Enter%2A>方法和[锁对象](#Lock)本文后面的部分。  
  
 下表介绍可以通过访问同步的对象的线程执行的操作：  
  
|操作|描述|  
|------------|-----------------|  
|<xref:System.Threading.Monitor.Enter%2A>, <xref:System.Threading.Monitor.TryEnter%2A>|获取一个对象的锁。 此操作还表示关键部分的开头。 没有其他线程可以进入关键节，除非它使用不同的锁定的对象的关键部分中执行的说明。|  
|<xref:System.Threading.Monitor.Wait%2A>|若要允许其他线程锁定，并访问该对象释放对象上的锁。 另一个线程访问对象时，调用线程等待。 脉冲信号用于通知等待线程有关对象的状态更改。|  
|<xref:System.Threading.Monitor.Pulse%2A> （信号） <xref:System.Threading.Monitor.PulseAll%2A>|将信号发送到一个或多个等待线程。 该信号通知的锁定对象的状态已更改，在等待线程和锁的所有者已准备好释放锁。 等待线程位于对象的准备就绪的队列，以便它最终可能会收到对象的锁。 一旦线程拥有该锁，它可以检查以查看是否已到达所需的状态的对象的新状态。|  
|<xref:System.Threading.Monitor.Exit%2A>|释放对象锁。 此操作还将标记的关键部分保护锁定对象的末尾。|  
  
 开头[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]，有两个组的重载<xref:System.Threading.Monitor.Enter%2A>和<xref:System.Threading.Monitor.TryEnter%2A>方法。 一组重载具有`ref`（在 C# 中) 或`ByRef`（在 Visual Basic)<xref:System.Boolean>参数以原子方式设置为`true`如果已获取锁，即使当获取锁时引发异常。 如果问题比较严重释放在所有情况下，锁，即使该锁定保护的资源可能处于不一致状态，请使用这些重载。  
  
<a name="Lock"></a>   
## <a name="the-lock-object"></a>锁对象  
 Monitor 类组成`static`（在 C# 中) 或`Shared`（在 Visual Basic) 控制访问的关键部分对象上运行。  为每个同步对象维护的以下信息：  
  
-   对当前持有锁的线程的引用。  
  
-   对就绪的队列，其中包含准备好获取锁的线程的引用。  
  
-   对包含的锁定对象的状态的更改通知等待的线程的等待队列的引用。  
  
 <xref:System.Threading.Monitor> 锁定对象（即引用类型），而不是值类型。 虽然可以将值类型传递到 <xref:System.Threading.Monitor.Enter%2A> 和 <xref:System.Threading.Monitor.Exit%2A>，但对每个调用它都分别进行了装箱。 由于每次调用都将创建一个单独的对象，所以绝不会阻止 <xref:System.Threading.Monitor.Enter%2A> 并且它应该保护的代码不会真正同步。 此外，传递到 <xref:System.Threading.Monitor.Exit%2A> 的对象不同于传递到 <xref:System.Threading.Monitor.Enter%2A> 的对象，因此 <xref:System.Threading.Monitor> 将引发 <xref:System.Threading.SynchronizationLockException> 异常并显示消息“从代码的非同步块调用了对象同步方法。”  
  
 以下示例阐释了此问题。 它启动十个任务，其中每个任务仅休眠 250 毫秒。 然后，每个任务会更新计数器变量 `nTasks`，该变量用于计算实际启动和执行的任务数。 因为 `nTasks` 是一个可同时被多个任务更新的全局变量，所以使用监视器防止其同时被多个任务进行修改。 但是，如示例输出所示，每个任务都将引发 <xref:System.Threading.SynchronizationLockException> 异常。  
  
 [!code-csharp[Conceptual.Monitors#2](~/samples/snippets/csharp/VS_Snippets_CLR/conceptual.monitors/cs/badlock1.cs#2)]
 [!code-vb[Conceptual.Monitors#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.monitors/vb/badlock1.vb#2)]  
  
 因为 `nTasks` 变量会先于对每个任务中的 <xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType> 方法的调用而进行装箱，所以每个任务都将引发 <xref:System.Threading.SynchronizationLockException> 异常。 换言之，将向每个方法调用传递一个独立于其他变量的单独变量。 `nTasks` 在对 <xref:System.Threading.Monitor.Exit%2A?displayProperty=nameWithType> 方法的调用中会再次进行装箱。 这将再次创建 10 个新装箱的变量 `nTasks`，这些变量相互独立并且独立于在调用 <xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType> 方法时创建的 10 个装箱变量。 然后将引发异常，因为我们的代码正尝试在之前未锁定的新创建变量上释放锁定。  
  
 尽管可以先装箱值类型变量，再调用 <xref:System.Threading.Monitor.Enter%2A> 和 <xref:System.Threading.Monitor.Exit%2A>（如下例所示）并且同时向这两种方法传递相同的装箱对象，但是进行该操作并没有什么好处。 对未装箱的变量所做的更改不会反映在装箱副本中，并且无法更改装箱副本的值。  
  
 [!code-csharp[Conceptual.Monitors#3](~/samples/snippets/csharp/VS_Snippets_CLR/conceptual.monitors/cs/badbox1.cs#3)]
 [!code-vb[Conceptual.Monitors#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.monitors/vb/badbox1.vb#3)]  
  
 选择要同步的对象，便应仅在私有或内部对象上锁定。 外部对象上锁定可能会导致死锁，因为不相关的代码可能选择相同的对象上锁定用于不同目的。  
  
 请注意，如果用于锁的对象派生可以同步多个应用程序域中的某个对象<xref:System.MarshalByRefObject>。  
  
<a name="CriticalSection"></a>   
## <a name="the-critical-section"></a>关键节  
 使用<xref:System.Threading.Monitor.Enter%2A>和<xref:System.Threading.Monitor.Exit%2A>方法将标记的开头和结尾的关键部分。  
  
> [!NOTE]
>  提供的功能<xref:System.Threading.Monitor.Enter%2A>和<xref:System.Threading.Monitor.Exit%2A>方法等同于由提供[锁](~/docs/csharp/language-reference/keywords/lock-statement.md)C# 中的语句和[SyncLock](~/docs/visual-basic/language-reference/statements/synclock-statement.md)不同之处在于在 Visual Basic 中的语句语言构造大大降低环绕<xref:System.Threading.Monitor.Enter%28System.Object%2CSystem.Boolean%40%29?displayProperty=nameWithType>方法重载并<xref:System.Threading.Monitor.Exit%2A?displayProperty=nameWithType>中的方法`try`...`finally` 若要确保监视器被释放的块。  
  
 如果关键部分是一组连续的说明，然后获取的锁的<xref:System.Threading.Monitor.Enter%2A>方法可保证只有一个线程可以执行与锁定的对象所包含的代码。 在这种情况下，我们建议你将在该代码放`try`阻止并发出到呼叫<xref:System.Threading.Monitor.Exit%2A>中的方法`finally`块。 这可确保即使发生异常，也将释放该锁定。 下面的代码段演示了此模式。  
  
 [!code-csharp[System.Threading.Monitor.Class#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.monitor.class/cs/Pattern2.cs#2)]
 [!code-vb[System.Threading.Monitor.Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.monitor.class/vb/Pattern2.vb#2)]  
  
 此工具通常用于同步访问静态方法或类的实例方法。  
  
 如果临界区跨越整个方法，可以通过锁定设施放置<xref:System.Runtime.CompilerServices.MethodImplAttribute?displayProperty=nameWithType>方法，并指定<xref:System.Runtime.CompilerServices.MethodImplOptions.Synchronized>的构造函数中的值<xref:System.Runtime.CompilerServices.MethodImplAttribute?displayProperty=nameWithType>。 使用此属性时<xref:System.Threading.Monitor.Enter%2A>和<xref:System.Threading.Monitor.Exit%2A>不需要方法调用。 下面的代码段演示了这种模式：  
  
 [!code-csharp[System.Threading.Monitor.Class#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.monitor.class/cs/Pattern2.cs#3)]
 [!code-vb[System.Threading.Monitor.Class#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.monitor.class/vb/Pattern2.vb#3)]  
  
 请注意，该属性会导致当前线程持有锁，直到该方法返回;如果可以更快地释放锁，则使用<xref:System.Threading.Monitor>类，C#[锁](~/docs/csharp/language-reference/keywords/lock-statement.md)语句或 Visual Basic [SyncLock](~/docs/visual-basic/language-reference/statements/synclock-statement.md)语句而不是属性的方法。  
  
 尽管很可能<xref:System.Threading.Monitor.Enter%2A>和<xref:System.Threading.Monitor.Exit%2A>锁定和释放给定的对象跨成员或类边界的语句，不推荐这样做。  
  
<a name="Pulse"></a>   
## <a name="pulse-pulseall-and-wait"></a>Pulse 和 PulseAll 等待  
 后一个线程拥有该锁，并已进入关键节锁保护，它可以调用<xref:System.Threading.Monitor.Wait%2A?displayProperty=nameWithType>， <xref:System.Threading.Monitor.Pulse%2A?displayProperty=nameWithType>，和<xref:System.Threading.Monitor.PulseAll%2A?displayProperty=nameWithType>方法。  
  
 <xref:System.Threading.Monitor.Wait%2A> 如果它保留、 允许等待线程或线程获得的锁，并进入关键节，并等待通过调用通知释放锁<xref:System.Threading.Monitor.Pulse%2A?displayProperty=nameWithType>或<xref:System.Threading.Monitor.PulseAll%2A?displayProperty=nameWithType>方法。 当 <xref:System.Threading.Monitor.Wait%2A> 获得通知后，它将返回并再次获取该锁定。  
  
 在等待队列中等待处理的下一个线程的 <xref:System.Threading.Monitor.Pulse%2A> 和 <xref:System.Threading.Monitor.PulseAll%2A> 信号。  
  
<a name="WaitHandles"></a>   
## <a name="monitors-and-wait-handles"></a>监视器和等待句柄  
 务必要注意的使用之间的区别<xref:System.Threading.Monitor>类和<xref:System.Threading.WaitHandle>对象。  
  
-   <xref:System.Threading.Monitor>类是纯托管且完全可移植，并且可能会在操作系统资源需求方面更加高效。  
  
-   <xref:System.Threading.WaitHandle> 对象表示操作系统可等待对象，有助于托管和非托管代码之间进行同步，并公开一些高级操作系统功能，如同时等待多个对象的功能。  
  
   
  
## Examples  
 下面的示例使用<xref:System.Threading.Monitor>类所表示的随机数生成器的单个实例对访问进行同步<xref:System.Random>类。 该示例创建了十个任务，其中每个线程池线程异步执行。 每个任务生成 10,000 的随机数字、 计算其平均值，并更新维护的随机数字生成数的运行总计和其总和的两个过程级变量。 所有任务都执行完成后，然后使用这两个值来计算总体的平均值。  
  
 [!code-csharp[System.Threading.Monitor.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.monitor.class/cs/example1.cs#1)]
 [!code-vb[System.Threading.Monitor.Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.monitor.class/vb/example1.vb#1)]  
  
 由于它们可以从任何线程池线程上运行的任务进行访问，访问到的变量`total`和`n`也必须同步。 <xref:System.Threading.Interlocked.Add%2A?displayProperty=nameWithType>方法用于此目的。  
  
 下面的示例演示如何组合的使用的<xref:System.Threading.Monitor>类 (通过实现`lock`或`SyncLock`语言构造)，则<xref:System.Threading.Interlocked>类，和<xref:System.Threading.AutoResetEvent>类。 它定义了两个`internal`（在 C# 中) 或`Friend`（在 Visual Basic) 类，`SyncResource`和`UnSyncResource`，它们分别提供对资源的同步和不同步访问。 若要确保该示例阐释了同步和不同步访问 （这可能是这种情况，如果每个方法调用快速完成） 之间的差异，此方法包含随机延迟： 对于线程<xref:System.Threading.Thread.ManagedThreadId%2A?displayProperty=nameWithType>属性为偶数，方法调用<xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType>引入 2,000 毫秒的延迟。 注意，因为`SyncResource`类不是公共的没有任何客户端代码对同步资源采用锁; 内部类本身所需的锁。 这可以防止恶意代码对公共对象采用锁。  
  
 [!code-csharp[Conceptual.Monitors#1](~/samples/snippets/csharp/VS_Snippets_CLR/conceptual.monitors/cs/source.cs#1)]
 [!code-vb[Conceptual.Monitors#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.monitors/vb/source.vb#1)]  
  
 该示例定义一个变量， `numOps`，定义将要尝试访问资源的线程数。 应用程序线程调用<xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%29?displayProperty=nameWithType>方法的同步和不同步访问五次每个。 <xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%29?displayProperty=nameWithType>方法具有一个参数，不接受任何参数且不返回值的委托。 对于同步访问，它将调用`SyncUpdateResource`方法; 因此，对于不同步访问，它将调用`UnSyncUpdateResource`方法。 在方法调用的每个集之后, 应用程序线程调用[AutoResetEvent.WaitOne](xref:System.Threading.WaitHandle.WaitOne*)方法，以便阻止，直到<xref:System.Threading.AutoResetEvent>实例发出信号。  
  
 每次调用`SyncUpdateResource`方法都会调用内部`SyncResource.Access`方法，然后调用<xref:System.Threading.Interlocked.Decrement%2A?displayProperty=nameWithType>方法以递减`numOps`计数器。 <xref:System.Threading.Interlocked.Decrement%2A?displayProperty=nameWithType>方法用于递减该计数器，因为否则您无法确保第二个线程将访问的值之前第一个线程的递减, 值已存储在变量。 当上一次同步工作线程递减为零的计数器时，指示所有同步线程已完成访问资源`SyncUpdateResource`方法调用<xref:System.Threading.EventWaitHandle.Set%2A?displayProperty=nameWithType>方法，发出主线程继续的信号执行。  
  
 每次调用`UnSyncUpdateResource`方法都会调用内部`UnSyncResource.Access`方法，然后调用<xref:System.Threading.Interlocked.Decrement%2A?displayProperty=nameWithType>方法以递减`numOps`计数器。 再次重申，<xref:System.Threading.Interlocked.Decrement%2A?displayProperty=nameWithType>方法用于递减的计数器以确保第二个线程不会在第一个线程的递减值已分配给变量之前访问值。 当上一次同步工作线程递减为零的计数器时，指示没有更多不同步线程需要访问的资源，`UnSyncUpdateResource`方法调用<xref:System.Threading.EventWaitHandle.Set%2A?displayProperty=nameWithType>方法，发出主线程继续执行的信号.  
  
 如示例的输出所示，同步访问可确保另一个线程必须在调用线程退出受保护的资源之后才能访问该资源；每个线程都在其前置任务上等待。 但是，无锁，`UnSyncResource.Access`线程到达它的顺序调用方法。  
  
 ]]></format>
    </remarks>
    <threadsafe>此类型是线程安全的。</threadsafe>
    <altmember cref="T:System.Threading.Thread" />
  </Docs>
  <Members>
    <MemberGroup MemberName="Enter">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>获取指定对象上的排他锁。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Enter">
      <MemberSignature Language="C#" Value="public static void Enter (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Enter(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.Enter(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Enter (obj As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Enter(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="static member Enter : obj -&gt; unit" Usage="System.Threading.Monitor.Enter obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">在其上获取监视器锁的对象。</param>
        <summary>在指定对象上获取排他锁。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用`Enter`获取<xref:System.Threading.Monitor>上作为参数传递的对象。 如果已执行了另一个线程`Enter`对象上但尚未执行相应<xref:System.Threading.Monitor.Exit%2A>，当前线程会阻塞，直到另一个线程释放对象。 是合法的同一线程调用`Enter`多次而无需阻止它; 但是，相同数目的`Exit`之前等待的对象上的其他线程将取消阻止，则必须调用的调用。  
  
 使用<xref:System.Threading.Monitor>来锁定对象 （即，引用类型） 而不是值类型。 传递到值类型变量时`Enter`，它被装箱为对象。 如果传递到相同的变量`Enter`同样，它被装箱为单独的对象，并在线程不会阻止。 在此情况下，代码的`Monitor`是应该保护不受保护。 此外，当您将该变量传递到`Exit`，创建另一个单独的对象。 因为该对象传递给`Exit`不同于传递给对象`Enter`，`Monitor`引发<xref:System.Threading.SynchronizationLockException>。 有关详细信息，请参阅概念性主题[监视器](xref:System.Threading.Monitor)。  
  
 <xref:System.Threading.Thread.Interrupt%2A> 可能会中断线程正在等待输入`Monitor`对象上。 一个<xref:System.Threading.ThreadInterruptedException>将引发。  
  
 使用 C# `try`...`finally` 块 (`Try`...`Finally` 在 Visual Basic 中) 以确保释放监视器，或使用 C#`lock`语句 (`SyncLock`在 Visual Basic 中的语句)，用于包装<xref:System.Threading.Monitor.Enter%2A>并<xref:System.Threading.Monitor.Exit%2A>中的方法`try`...`finally` 块。  
  
   
  
## Examples  
 下面的示例演示如何使用 `Enter` 方法。  
  
 [!code-cpp[MonitorExmpl2#1](~/samples/snippets/cpp/VS_Snippets_CLR/MonitorExmpl2/CPP/monitor2.cpp#1)]
 [!code-csharp[MonitorExmpl2#1](~/samples/snippets/csharp/VS_Snippets_CLR/MonitorExmpl2/CS/monitor2.cs#1)]
 [!code-vb[MonitorExmpl2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/MonitorExmpl2/VB/monitor2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="obj" /> 参数为 <see langword="null" />。</exception>
        <altmember cref="T:System.Threading.Thread" />
      </Docs>
    </Member>
    <Member MemberName="Enter">
      <MemberSignature Language="C#" Value="public static void Enter (object obj, ref bool lockTaken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Enter(object obj, bool&amp; lockTaken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.Enter(System.Object,System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Enter (obj As Object, ByRef lockTaken As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Enter(System::Object ^ obj, bool % lockTaken);" />
      <MemberSignature Language="F#" Value="static member Enter : obj *  -&gt; unit" Usage="System.Threading.Monitor.Enter (obj, lockTaken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="lockTaken" Type="System.Boolean&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="obj">要在其上等待的对象。</param>
        <param name="lockTaken">尝试获取锁的结果，通过引用传递。 输入必须为 <see langword="false" />。 如果已获取锁，则输出为 <see langword="true" />；否则输出为 <see langword="false" />。 即使在尝试获取锁的过程中发生异常，也会设置输出。  注意   如果没有发生异常，则此方法的输出始终为 <see langword="true" />。</param>
        <summary>获取指定对象上的排他锁，并自动设置一个值，指示是否获取了该锁。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用`Enter`来获取<xref:System.Threading.Monitor>作为传递的对象上`obj`参数。 如果已执行了另一个线程`Enter`对象上但尚未执行相应<xref:System.Threading.Monitor.Exit%2A>，当前线程会阻塞，直到另一个线程释放对象。 是合法的同一线程调用`Enter`多次而无需阻止它; 但是，相同数目的`Exit`之前等待的对象上的其他线程将取消阻止，则必须调用的调用。  
  
 如果不采取锁，因为引发了异常，所指定的变量`lockTaken`参数是`false`此方法结束后。 这样，若要确定是否需要释放锁，在所有情况下，该程序。 如果此方法返回而不引发异常时，所指定的变量`lockTaken`参数始终是`true`，并且无需对其进行测试。  
  
 使用<xref:System.Threading.Monitor>来锁定对象 （即，引用类型） 而不是值类型。 传递到值类型变量时`Enter`，它被装箱为对象。 如果传递到相同的变量`Enter`同样，它被装箱为单独的对象，并在线程不会阻止。 在此情况下，代码的`Monitor`是应该保护不受保护。 此外，当您将该变量传递到`Exit`，创建另一个单独的对象。 因为该对象传递给`Exit`不同于传递给对象`Enter`，`Monitor`引发<xref:System.Threading.SynchronizationLockException>。 有关详细信息，请参阅概念性主题[监视器](xref:System.Threading.Monitor)。  
  
 <xref:System.Threading.Thread.Interrupt%2A> 可能会中断线程正在等待输入`Monitor`对象上。 一个<xref:System.Threading.ThreadInterruptedException>将引发。  
  
   
  
## Examples  
 下面的代码演示使用的基本模式<xref:System.Threading.Monitor.Enter%28System.Object%2CSystem.Boolean%40%29>方法重载。 此重载总是设置传递给该变量的值`ref`参数 (`ByRef`在 Visual Basic 中) `lockTaken`，即使该方法将引发异常，因此该变量的值是可靠的方式来测试是否锁必须是发布。  
  
 [!code-csharp[System.Threading.Monitor.Enter#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.monitor.enter/cs/example.cs#2)]
 [!code-vb[System.Threading.Monitor.Enter#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.monitor.enter/vb/example.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="lockTaken" /> 的输入为 <see langword="true" />。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="obj" /> 参数为 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="Exit">
      <MemberSignature Language="C#" Value="public static void Exit (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Exit(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.Exit(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Exit (obj As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Exit(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="static member Exit : obj -&gt; unit" Usage="System.Threading.Monitor.Exit obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">在其上释放锁的对象。</param>
        <summary>释放指定对象上的排他锁。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 调用线程必须在拥有的锁`obj`参数。 如果调用线程拥有指定对象上的锁，并且具有相同数量`Exit`和<xref:System.Threading.Monitor.Enter%2A>调用对于对象，则释放该锁。 如果调用线程不调用`Exit`多少次`Enter`，不释放锁。  
  
 如果该锁被释放，其他线程处于准备就绪的队列对象的某个线程获取锁。 如果其他线程等待获取锁的等待队列中，它们不会自动移到准备就绪的队列时锁的所有者调用`Exit`。 若要将一个或多个等待线程移动到准备就绪的队列，调用<xref:System.Threading.Monitor.Pulse%2A>或<xref:System.Threading.Monitor.PulseAll%2A>然后再调用`Exit`。  
  
   
  
## Examples  
 下面的示例演示如何使用 `Exit` 方法。  
  
 [!code-cpp[MonitorExmpl2#1](~/samples/snippets/cpp/VS_Snippets_CLR/MonitorExmpl2/CPP/monitor2.cpp#1)]
 [!code-csharp[MonitorExmpl2#1](~/samples/snippets/csharp/VS_Snippets_CLR/MonitorExmpl2/CS/monitor2.cs#1)]
 [!code-vb[MonitorExmpl2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/MonitorExmpl2/VB/monitor2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="obj" /> 参数为 <see langword="null" />。</exception>
        <exception cref="T:System.Threading.SynchronizationLockException">当前线程不拥有指定对象的锁。</exception>
        <altmember cref="T:System.Threading.Thread" />
      </Docs>
    </Member>
    <Member MemberName="IsEntered">
      <MemberSignature Language="C#" Value="public static bool IsEntered (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsEntered(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.IsEntered(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsEntered (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsEntered(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="static member IsEntered : obj -&gt; bool" Usage="System.Threading.Monitor.IsEntered obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">要测试的对象。</param>
        <summary>确定当前线程是否保留指定对象上的锁。</summary>
        <returns>如果当前线程持有 <paramref name="obj" /> 锁，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法仅适用于使用的方法获得的锁<xref:System.Threading.Monitor>类，或通过使用 C#`lock`语句或 Visual Basic`SyncLock`语句，实现与<xref:System.Threading.Monitor>。  
  
 使用此方法通过诊断工具，如<xref:System.Diagnostics.Debug.Assert%2A>方法和<xref:System.Diagnostics.Contracts.Contract>类中，以调试涉及的锁定问题<xref:System.Threading.Monitor>类。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="obj" /> 为 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="Pulse">
      <MemberSignature Language="C#" Value="public static void Pulse (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Pulse(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.Pulse(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Pulse (obj As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Pulse(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="static member Pulse : obj -&gt; unit" Usage="System.Threading.Monitor.Pulse obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">线程正在等待的对象。</param>
        <summary>通知等待队列中的线程锁定对象状态的更改。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 仅当前锁的所有者可以发出信号等待对象使用`Pulse`。  
  
 当前拥有指定对象上的锁的线程调用此方法来发出信号的锁的行中的下一个线程。 一旦收到状况了如指掌，等待线程移到准备就绪的队列。 该线程的调用时`Pulse`释放锁后，在准备就绪的队列 （它不一定接收到脉冲的线程） 中的下一个线程获取该锁。  
  
> [!IMPORTANT]
>  <xref:System.Threading.Monitor>类不维护状态，指示<xref:System.Threading.Monitor.Pulse%2A>调用方法。 因此，如果您调用<xref:System.Threading.Monitor.Pulse%2A>没有线程在等待，在下一个调用线程<xref:System.Threading.Monitor.Wait%2A>块像<xref:System.Threading.Monitor.Pulse%2A>从未被调用过。 如果使用的两个线程<xref:System.Threading.Monitor.Pulse%2A>和<xref:System.Threading.Monitor.Wait%2A>进行交互，这可能导致死锁。 与此相反的行为<xref:System.Threading.AutoResetEvent>类： 如果你发出信号<xref:System.Threading.AutoResetEvent>通过调用其<xref:System.Threading.EventWaitHandle.Set%2A>方法中，没有线程在等待，并且<xref:System.Threading.AutoResetEvent>保持终止状态，直到某个线程调用在<xref:System.Threading.WaitHandle.WaitOne%2A>， <xref:System.Threading.WaitHandle.WaitAny%2A>，或<xref:System.Threading.WaitHandle.WaitAll%2A>。 <xref:System.Threading.AutoResetEvent>释放该线程并返回到未终止的状态。  
  
 请注意同步的对象包含多个引用，其中包括对在线程当前持有锁、 准备就绪的队列，其中包含准备好获取锁的线程，对的引用和对等待队列的引用的引用的包含的对象的状态的更改通知等待的线程。  
  
 `Pulse`， <xref:System.Threading.Monitor.PulseAll%2A>，和<xref:System.Threading.Monitor.Wait%2A>方法必须从调用代码的同步块内。  
  
 若要通知的多个线程信息，请使用<xref:System.Threading.Monitor.PulseAll%2A>方法。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="obj" /> 参数为 <see langword="null" />。</exception>
        <exception cref="T:System.Threading.SynchronizationLockException">调用线程不拥有指定对象的锁。</exception>
        <altmember cref="T:System.Threading.Thread" />
      </Docs>
    </Member>
    <Member MemberName="PulseAll">
      <MemberSignature Language="C#" Value="public static void PulseAll (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void PulseAll(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.PulseAll(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub PulseAll (obj As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void PulseAll(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="static member PulseAll : obj -&gt; unit" Usage="System.Threading.Monitor.PulseAll obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">发送脉冲的对象。</param>
        <summary>通知所有的等待线程对象状态的更改。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当前拥有指定对象上的锁的线程调用此方法以向等待获取锁的对象上的所有线程发出都信号。 发送信号后，等待线程会移到准备就绪的队列。 该线程的调用时`PulseAll`释放锁后，在准备就绪的队列中的下一个线程获取该锁。  
  
 请注意同步的对象包含多个引用，其中包括对在线程当前持有锁、 准备就绪的队列，其中包含准备好获取锁的线程，对的引用和对等待队列的引用的引用的包含的对象的状态的更改通知等待的线程。  
  
 <xref:System.Threading.Monitor.Pulse%2A>， `PulseAll`，和<xref:System.Threading.Monitor.Wait%2A>方法必须从调用代码的同步块内。  
  
 备注<xref:System.Threading.Monitor.Pulse%2A>解释发生的方法如果<xref:System.Threading.Monitor.Pulse%2A>没有线程处于等待状态时调用。  
  
 若要通知一个线程的信息，请使用`Pulse`方法。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="obj" /> 参数为 <see langword="null" />。</exception>
        <exception cref="T:System.Threading.SynchronizationLockException">调用线程不拥有指定对象的锁。</exception>
        <altmember cref="T:System.Threading.Thread" />
      </Docs>
    </Member>
    <MemberGroup MemberName="TryEnter">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>尝试获取指定对象的排他锁。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TryEnter">
      <MemberSignature Language="C#" Value="public static bool TryEnter (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryEnter(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.TryEnter(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryEnter (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryEnter(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="static member TryEnter : obj -&gt; bool" Usage="System.Threading.Monitor.TryEnter obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">在其上获取锁的对象。</param>
        <summary>尝试获取指定对象的排他锁。</summary>
        <returns>如果当前线程获取该锁，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果成功，此方法将获取排他锁上`obj`参数。 此方法立即返回锁可用。  
  
 此方法是类似于<xref:System.Threading.Monitor.Enter%2A>，但它将永远不会阻止当前线程。 如果该线程不能输入而不会阻塞，则该方法将返回`false,`。  
  
> [!NOTE]
>  使用<xref:System.Threading.Monitor>来锁定对象 （即，引用类型） 而不是值类型。 有关详细信息，请参阅<xref:System.Threading.Monitor>一文。  
  
 若要确保线程不会进入关键节，应检查方法的返回值，并执行代码的关键部分中，仅当其返回值为`true`。 下面的代码段显示了用于调用此方法的模式。 请注意，应调用<xref:System.Threading.Monitor.Exit%2A>在`finally`块来确保调用线程释放关键节上的其锁定，如果发生异常。  
  
 [!code-csharp[System.Threading.Monitor.TryEnter#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/cs/pattern1.cs#1)]
 [!code-vb[System.Threading.Monitor.TryEnter#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/vb/pattern1.vb#1)]  
  
   
  
## Examples  
 下面的代码示例演示如何使用 `TryEnter` 方法。  
  
 [!code-cpp[MonitorExmpl2#1](~/samples/snippets/cpp/VS_Snippets_CLR/MonitorExmpl2/CPP/monitor2.cpp#1)]
 [!code-csharp[MonitorExmpl2#1](~/samples/snippets/csharp/VS_Snippets_CLR/MonitorExmpl2/CS/monitor2.cs#1)]
 [!code-vb[MonitorExmpl2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/MonitorExmpl2/VB/monitor2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="obj" /> 参数为 <see langword="null" />。</exception>
        <altmember cref="T:System.Threading.Thread" />
      </Docs>
    </Member>
    <Member MemberName="TryEnter">
      <MemberSignature Language="C#" Value="public static void TryEnter (object obj, ref bool lockTaken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void TryEnter(object obj, bool&amp; lockTaken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.TryEnter(System.Object,System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub TryEnter (obj As Object, ByRef lockTaken As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void TryEnter(System::Object ^ obj, bool % lockTaken);" />
      <MemberSignature Language="F#" Value="static member TryEnter : obj *  -&gt; unit" Usage="System.Threading.Monitor.TryEnter (obj, lockTaken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="lockTaken" Type="System.Boolean&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="obj">在其上获取锁的对象。</param>
        <param name="lockTaken">尝试获取锁的结果，通过引用传递。 输入必须为 <see langword="false" />。 如果已获取锁，则输出为 <see langword="true" />；否则输出为 <see langword="false" />。 即使在尝试获取锁的过程中发生异常，也会设置输出。</param>
        <summary>尝试获取指定对象上的排他锁，并自动设置一个值，指示是否获取了该锁。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果成功，此方法将获取排他锁上`obj`参数。 此方法立即返回锁可用。  
  
 如果不采取锁，因为引发了异常，所指定的变量`lockTaken`参数是`false`此方法结束后。 这样，若要确定是否需要释放锁，在所有情况下，该程序。  
  
 此方法是类似于<xref:System.Threading.Monitor.Enter%28System.Object%2CSystem.Boolean%40%29>，但它将永远不会阻止当前线程。 如果线程而不会阻止，无法进入`lockTaken`参数设置为`false`方法返回时。  
  
> [!NOTE]
>  使用<xref:System.Threading.Monitor>来锁定对象 （即，引用类型） 而不是值类型。 有关详细信息，请参阅<xref:System.Threading.Monitor>一文。  
  
 若要确保线程不会进入关键节，则应检查的值`lockTaken`并执行代码的关键部分中，仅当其值为`true`。 下面的代码段显示了用于调用此方法的模式。 请注意，应调用<xref:System.Threading.Monitor.Exit%2A>在`finally`块来确保调用线程释放关键节上的其锁定，如果发生异常。  
  
 [!code-csharp[System.Threading.Monitor.TryEnter#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/cs/pattern1.cs#2)]
 [!code-vb[System.Threading.Monitor.TryEnter#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/vb/pattern1.vb#2)]  
  
   
  
## Examples  
 下面的代码演示使用的基本模式<xref:System.Threading.Monitor.TryEnter%28System.Object%2CSystem.Boolean%40%29>方法重载。 此重载总是设置传递给该变量的值`ref`参数 (`ByRef`在 Visual Basic 中) `lockTaken`，即使该方法将引发异常，因此该变量的值是可靠的方式来测试是否锁必须是发布。  
  
 [!code-csharp[System.Threading.Monitor.Enter#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.monitor.enter/cs/example.cs#3)]
 [!code-vb[System.Threading.Monitor.Enter#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.monitor.enter/vb/example.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="lockTaken" /> 的输入为 <see langword="true" />。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="obj" /> 参数为 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="TryEnter">
      <MemberSignature Language="C#" Value="public static bool TryEnter (object obj, int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryEnter(object obj, int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.TryEnter(System.Object,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryEnter (obj As Object, millisecondsTimeout As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryEnter(System::Object ^ obj, int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="static member TryEnter : obj * int -&gt; bool" Usage="System.Threading.Monitor.TryEnter (obj, millisecondsTimeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="obj">在其上获取锁的对象。</param>
        <param name="millisecondsTimeout">等待锁所需的毫秒数。</param>
        <summary>在指定的毫秒数内尝试获取指定对象上的排他锁。</summary>
        <returns>如果当前线程获取该锁，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果`millisecondsTimeout`参数等于<xref:System.Threading.Timeout.Infinite>，此方法等效于<xref:System.Threading.Monitor.Enter%2A>。 如果`millisecondsTimeout`等于 0，则此方法等效于<xref:System.Threading.Monitor.TryEnter%2A>。  
  
> [!NOTE]
>  使用<xref:System.Threading.Monitor>来锁定对象 （即，引用类型） 而不是值类型。 有关详细信息，请参阅<xref:System.Threading.Monitor>一文。  
  
 若要确保线程不会进入关键节，应检查方法的返回值，并执行代码的关键部分中，仅当其返回值为`true`。 下面的代码段显示了用于调用此方法的模式。 请注意，应调用<xref:System.Threading.Monitor.Exit%2A>在`finally`块来确保调用线程释放关键节上的其锁定，如果发生异常。  
  
 [!code-csharp[System.Threading.Monitor.TryEnter#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/cs/pattern1.cs#3)]
 [!code-vb[System.Threading.Monitor.TryEnter#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/vb/pattern1.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="obj" /> 参数为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsTimeout" /> 是负数且不等于 <see cref="F:System.Threading.Timeout.Infinite" />。</exception>
        <altmember cref="T:System.Threading.Thread" />
      </Docs>
    </Member>
    <Member MemberName="TryEnter">
      <MemberSignature Language="C#" Value="public static bool TryEnter (object obj, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryEnter(object obj, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.TryEnter(System.Object,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryEnter (obj As Object, timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryEnter(System::Object ^ obj, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="static member TryEnter : obj * TimeSpan -&gt; bool" Usage="System.Threading.Monitor.TryEnter (obj, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="obj">在其上获取锁的对象。</param>
        <param name="timeout">
          <see cref="T:System.TimeSpan" />，表示等待锁所需的时间量。 值为 -1 毫秒表示指定无限期等待。</param>
        <summary>在指定的时间内尝试获取指定对象上的排他锁。</summary>
        <returns>如果当前线程获取该锁，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果的值`timeout`参数转换为毫秒等于 – 1，则此方法等效于<xref:System.Threading.Monitor.Enter%2A>。 如果的值`timeout`等于 0，则此方法等效于<xref:System.Threading.Monitor.TryEnter%2A>。  
  
> [!NOTE]
>  使用<xref:System.Threading.Monitor>来锁定对象 （即，引用类型） 而不是值类型。 有关详细信息，请参阅<xref:System.Threading.Monitor>类主题。  
  
 若要确保线程不会进入关键节，应检查方法的返回值，并执行代码的关键部分中，仅当其返回值为`true`。 下面的代码段显示了用于调用此方法的模式。 请注意，应调用<xref:System.Threading.Monitor.Exit%2A>在`finally`块来确保调用线程释放关键节上的其锁定，如果发生异常。  
  
 [!code-csharp[System.Threading.Monitor.TryEnter#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/cs/pattern1.cs#5)]
 [!code-vb[System.Threading.Monitor.TryEnter#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/vb/pattern1.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="obj" /> 参数为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="timeout" /> 的值（以毫秒计）为负数且不等于 <see cref="F:System.Threading.Timeout.Infinite" />（–1 毫秒），或者大于 <see cref="F:System.Int32.MaxValue" />。</exception>
        <altmember cref="T:System.Threading.Thread" />
      </Docs>
    </Member>
    <Member MemberName="TryEnter">
      <MemberSignature Language="C#" Value="public static void TryEnter (object obj, int millisecondsTimeout, ref bool lockTaken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void TryEnter(object obj, int32 millisecondsTimeout, bool&amp; lockTaken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.TryEnter(System.Object,System.Int32,System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub TryEnter (obj As Object, millisecondsTimeout As Integer, ByRef lockTaken As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void TryEnter(System::Object ^ obj, int millisecondsTimeout, bool % lockTaken);" />
      <MemberSignature Language="F#" Value="static member TryEnter : obj * int *  -&gt; unit" Usage="System.Threading.Monitor.TryEnter (obj, millisecondsTimeout, lockTaken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
        <Parameter Name="lockTaken" Type="System.Boolean&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="obj">在其上获取锁的对象。</param>
        <param name="millisecondsTimeout">等待锁所需的毫秒数。</param>
        <param name="lockTaken">尝试获取锁的结果，通过引用传递。 输入必须为 <see langword="false" />。 如果已获取锁，则输出为 <see langword="true" />；否则输出为 <see langword="false" />。 即使在尝试获取锁的过程中发生异常，也会设置输出。</param>
        <summary>在指定的毫秒数内尝试获取指定对象上的排他锁，并自动设置一个值，指示是否获取了该锁。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果`millisecondsTimeout`参数等于<xref:System.Threading.Timeout.Infinite>，此方法等效于<xref:System.Threading.Monitor.Enter%28System.Object%29>。 如果`millisecondsTimeout`等于 0，则此方法等效于<xref:System.Threading.Monitor.TryEnter%28System.Object%29>。  
  
 如果不采取锁，因为引发了异常，所指定的变量`lockTaken`参数是`false`此方法结束后。 这样，若要确定是否需要释放锁，在所有情况下，该程序。  
  
> [!NOTE]
>  使用<xref:System.Threading.Monitor>来锁定对象 （即，引用类型） 而不是值类型。 有关详细信息，请参阅<xref:System.Threading.Monitor>类主题。  
  
 若要确保线程不会进入关键节，则应检查的值`lockTaken`并执行代码的关键部分中，仅当其值为`true`。 下面的代码段显示了用于调用此方法的模式。 请注意，应调用<xref:System.Threading.Monitor.Exit%2A>在`finally`块来确保调用线程释放关键节上的其锁定，如果发生异常。  
  
 [!code-csharp[System.Threading.Monitor.TryEnter#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/cs/pattern1.cs#4)]
 [!code-vb[System.Threading.Monitor.TryEnter#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/vb/pattern1.vb#4)]  
  
   
  
## Examples  
 下面的代码演示使用的基本模式<xref:System.Threading.Monitor.TryEnter%28System.Object%2CSystem.Boolean%40%29>方法重载。 此重载总是设置传递给该变量的值`ref`参数 (`ByRef`在 Visual Basic 中) `lockTaken`，即使该方法将引发异常，因此该变量的值是可靠的方式来测试是否锁必须是发布。  
  
 [!code-csharp[System.Threading.Monitor.Enter#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.monitor.enter/cs/example.cs#4)]
 [!code-vb[System.Threading.Monitor.Enter#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.monitor.enter/vb/example.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="lockTaken" /> 的输入为 <see langword="true" />。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="obj" /> 参数为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsTimeout" /> 是负数且不等于 <see cref="F:System.Threading.Timeout.Infinite" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="TryEnter">
      <MemberSignature Language="C#" Value="public static void TryEnter (object obj, TimeSpan timeout, ref bool lockTaken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void TryEnter(object obj, valuetype System.TimeSpan timeout, bool&amp; lockTaken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.TryEnter(System.Object,System.TimeSpan,System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub TryEnter (obj As Object, timeout As TimeSpan, ByRef lockTaken As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void TryEnter(System::Object ^ obj, TimeSpan timeout, bool % lockTaken);" />
      <MemberSignature Language="F#" Value="static member TryEnter : obj * TimeSpan *  -&gt; unit" Usage="System.Threading.Monitor.TryEnter (obj, timeout, lockTaken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="lockTaken" Type="System.Boolean&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="obj">在其上获取锁的对象。</param>
        <param name="timeout">用于等待锁的时间。 值为 -1 毫秒表示指定无限期等待。</param>
        <param name="lockTaken">尝试获取锁的结果，通过引用传递。 输入必须为 <see langword="false" />。 如果已获取锁，则输出为 <see langword="true" />；否则输出为 <see langword="false" />。 即使在尝试获取锁的过程中发生异常，也会设置输出。</param>
        <summary>在指定的一段时间内尝试获取指定对象上的排他锁，并自动设置一个值，指示是否获得了该锁。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果的值`timeout`参数转换为毫秒等于 – 1，则此方法等效于<xref:System.Threading.Monitor.Enter%28System.Object%29>。 如果的值`timeout`等于 0，则此方法等效于<xref:System.Threading.Monitor.TryEnter%28System.Object%29>。  
  
 如果不采取锁，因为引发了异常，所指定的变量`lockTaken`参数是`false`此方法结束后。 这样，若要确定是否需要释放锁，在所有情况下，该程序。  
  
> [!NOTE]
>  使用<xref:System.Threading.Monitor>来锁定对象 （即，引用类型） 而不是值类型。 有关详细信息，请参阅<xref:System.Threading.Monitor>类主题。  
  
 若要确保线程不会进入关键节，则应检查的值`lockTaken`并执行代码的关键部分中，仅当其值为`true`。 下面的代码段显示了用于调用此方法的模式。 请注意，应调用<xref:System.Threading.Monitor.Exit%2A>在`finally`块来确保调用线程释放关键节上的其锁定，如果发生异常。  
  
 [!code-csharp[System.Threading.Monitor.TryEnter#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/cs/pattern1.cs#6)]
 [!code-vb[System.Threading.Monitor.TryEnter#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/vb/pattern1.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="lockTaken" /> 的输入为 <see langword="true" />。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="obj" /> 参数为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="timeout" /> 的值（以毫秒计）为负数且不等于 <see cref="F:System.Threading.Timeout.Infinite" />（–1 毫秒），或者大于 <see cref="F:System.Int32.MaxValue" />。</exception>
        <altmember cref="T:System.Threading.Thread" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Wait">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>释放对象上的锁并阻止当前线程，直到它重新获取该锁。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Wait">
      <MemberSignature Language="C#" Value="public static bool Wait (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Wait(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.Wait(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Wait (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Wait(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="static member Wait : obj -&gt; bool" Usage="System.Threading.Monitor.Wait obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">要在其上等待的对象。</param>
        <summary>释放对象上的锁并阻止当前线程，直到它重新获取该锁。</summary>
        <returns>如果调用由于调用方重新获取了指定对象的锁而返回，则为 <see langword="true" />。 如果未重新获取该锁，则此方法不会返回。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当前拥有指定对象上的锁的线程调用此方法以释放该对象，以便另一个线程可以访问它。 等待重新获取锁时阻止调用方。 当调用方需要等待导致另一个线程的操作的状态更改时，调用此方法。  
  
 当线程调用`Wait`，释放对象上的锁，并进入对象的等待队列。 对象的准备就绪的队列中的下一个线程 （如果有） 获取该锁和独占使用的对象。 调用的所有线程`Wait`保留在等待队列，直到它们接收来自信号<xref:System.Threading.Monitor.Pulse%2A>或<xref:System.Threading.Monitor.PulseAll%2A>、 发送的锁的所有者。 如果`Pulse`发送，只有等待队列的开头处的线程会受到影响。 如果`PulseAll`发送，等待对对象的所有线程会受到都影响。 当收到信号时，一个或多个线程保持等待队列，然后输入准备就绪的队列。 准备就绪的队列中的线程，允许重新获取该锁。  
  
 此方法返回时调用的线程重新获取该锁的对象上。 请注意，如果锁持有者不会调用该方法会阻止无限期地`Pulse`或`PulseAll`。  
  
 调用方执行`Wait`一次，无论有多少次<xref:System.Threading.Monitor.Enter%2A>已调用为指定的对象。 从概念上讲，`Wait`方法将存储在调用方调用的次数`Enter`对象并调用`Exit`尽可能多地需要完全释放锁定的对象。 然后，调用方被阻塞等待重新获取该对象时。 当调用方重新获取该锁时，系统会调用`Enter`根据需要还原保存的多次`Enter`调用方的计数。 调用`Wait`释放指定对象的锁; 如果调用方是对其他对象的锁的所有者，这些锁也不会释放。  
  
 请注意同步的对象包含多个引用，其中包括对在线程当前持有锁、 准备就绪的队列，其中包含准备好获取锁的线程，对的引用和对等待队列的引用的引用的包含的对象的状态的更改通知等待的线程。  
  
 <xref:System.Threading.Monitor.Pulse%2A>， <xref:System.Threading.Monitor.PulseAll%2A>，和`Wait`方法必须从调用代码的同步块内。  
  
 备注<xref:System.Threading.Monitor.Pulse%2A>解释发生的方法如果<xref:System.Threading.Monitor.Pulse%2A>没有线程处于等待状态时调用。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="obj" /> 参数为 <see langword="null" />。</exception>
        <exception cref="T:System.Threading.SynchronizationLockException">调用线程不拥有指定对象的锁。</exception>
        <exception cref="T:System.Threading.ThreadInterruptedException">调用 <see langword="Wait" /> 的线程稍后从等待状态中断。 另一线程调用此线程的 <see cref="M:System.Threading.Thread.Interrupt" /> 方法时将发生这种情况。</exception>
        <altmember cref="T:System.Threading.Thread" />
      </Docs>
    </Member>
    <Member MemberName="Wait">
      <MemberSignature Language="C#" Value="public static bool Wait (object obj, int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Wait(object obj, int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.Wait(System.Object,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Wait (obj As Object, millisecondsTimeout As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Wait(System::Object ^ obj, int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="static member Wait : obj * int -&gt; bool" Usage="System.Threading.Monitor.Wait (obj, millisecondsTimeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="obj">要在其上等待的对象。</param>
        <param name="millisecondsTimeout">线程进入就绪队列之前等待的毫秒数。</param>
        <summary>释放对象上的锁并阻止当前线程，直到它重新获取该锁。 如果已用指定的超时时间间隔，则线程进入就绪队列。</summary>
        <returns>如果在指定的时间过期之前重新获取该锁，则为 <see langword="true" />；如果在指定的时间过期之后重新获取该锁，则为 <see langword="false" />。 此方法只有在重新获取该锁后才会返回。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法不返回直到它重新上获取排他锁`obj`参数。  
  
 当前拥有指定对象上的锁的线程调用此方法以释放该对象，以便另一个线程可以访问它。 等待重新获取锁时阻止调用方。 当调用方需要等待导致另一个线程的操作的状态更改时，调用此方法。  
  
 超时可确保，当前线程不会无限期阻塞如果另一个线程释放锁，但第一个调用不<xref:System.Threading.Monitor.Pulse%2A>或<xref:System.Threading.Monitor.PulseAll%2A>方法。 此外，它还会将线程移到准备就绪的队列，以便它可以更快地重新获取该锁绕过早在等待队列中，其他线程。 该线程可以测试的返回值<xref:System.Threading.Monitor.Wait%2A>方法，以确定它是否重新获取则在超时之前的锁。线程可以评估条件导致它进入等待，并且如果必要调用<xref:System.Threading.Monitor.Wait%2A>再次方法。  
  
 当线程调用`Wait`，释放对象上的锁，并进入对象的等待队列。 对象的准备就绪的队列中的下一个线程 （如果有） 获取该锁和独占使用的对象。 调用的线程`Wait`仍在等待队列中直至持有锁的线程调用<xref:System.Threading.Monitor.PulseAll%2A>，或它是在队列中的下一步并持有锁的线程调用<xref:System.Threading.Monitor.Pulse%2A>。 但是，如果`millisecondsTimeout`前另一个线程调用此对象的经过<xref:System.Threading.Monitor.Pulse%2A>或<xref:System.Threading.Monitor.PulseAll%2A>方法，在原始线程将移动到准备就绪的队列，以便重新获取该锁。  
  
> [!NOTE]
>  如果<xref:System.Threading.Timeout.Infinite>为指定`millisecondsTimeout`参数，此方法会无限期阻止除非锁持有者调用<xref:System.Threading.Monitor.Pulse%2A>或<xref:System.Threading.Monitor.PulseAll%2A>。 如果`millisecondsTimeout`等于 0，调用的线程`Wait`释放锁，然后立即进入就绪队列以便重新获取该锁。  
  
 调用方执行`Wait`一次，无论有多少次<xref:System.Threading.Monitor.Enter%2A>已调用为指定的对象。 从概念上讲，`Wait`方法将存储在调用方调用的次数<xref:System.Threading.Monitor.Enter%2A>对象并调用<xref:System.Threading.Monitor.Exit%2A>尽可能多地需要完全释放锁定的对象。 然后，调用方被阻塞等待重新获取该对象时。 当调用方重新获取该锁时，系统会调用<xref:System.Threading.Monitor.Enter%2A>根据需要还原保存的多次<xref:System.Threading.Monitor.Enter%2A>调用方的计数。 调用`Wait`释放指定对象的锁; 如果调用方是对其他对象的锁的所有者，这些锁也不会释放。  
  
> [!NOTE]
>  同步的对象包含多个引用，其中包括对在线程当前持有锁、 准备就绪的队列，其中包含准备好获取锁的线程，对的引用和对等待队列，其中包含的引用的引用有关的对象的状态的更改通知等待的线程。  
  
 <xref:System.Threading.Monitor.Pulse%2A>， <xref:System.Threading.Monitor.PulseAll%2A>，和`Wait`方法必须从调用代码的同步块内。  
  
 备注<xref:System.Threading.Monitor.Pulse%2A>解释发生的方法如果<xref:System.Threading.Monitor.Pulse%2A>没有线程处于等待状态时调用。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="obj" /> 参数为 <see langword="null" />。</exception>
        <exception cref="T:System.Threading.SynchronizationLockException">调用线程不拥有指定对象的锁。</exception>
        <exception cref="T:System.Threading.ThreadInterruptedException">调用 <see langword="Wait" /> 的线程稍后从等待状态中断。 另一线程调用此线程的 <see cref="M:System.Threading.Thread.Interrupt" /> 方法时将发生这种情况。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsTimeout" /> 参数值为负且不等于 <see cref="F:System.Threading.Timeout.Infinite" />。</exception>
        <altmember cref="T:System.Threading.Thread" />
      </Docs>
    </Member>
    <Member MemberName="Wait">
      <MemberSignature Language="C#" Value="public static bool Wait (object obj, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Wait(object obj, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Wait (obj As Object, timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Wait(System::Object ^ obj, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="static member Wait : obj * TimeSpan -&gt; bool" Usage="System.Threading.Monitor.Wait (obj, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="obj">要在其上等待的对象。</param>
        <param name="timeout">
          <see cref="T:System.TimeSpan" />，表示线程进入就绪队列之前等待的时间量。</param>
        <summary>释放对象上的锁并阻止当前线程，直到它重新获取该锁。 如果已用指定的超时时间间隔，则线程进入就绪队列。</summary>
        <returns>如果在指定的时间过期之前重新获取该锁，则为 <see langword="true" />；如果在指定的时间过期之后重新获取该锁，则为 <see langword="false" />。 此方法只有在重新获取该锁后才会返回。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法不返回直到它重新上获取排他锁`obj`参数。  
  
 当前拥有指定对象上的锁的线程调用此方法以释放该对象，以便另一个线程可以访问它。 等待重新获取锁时阻止调用方。 当调用方需要等待导致另一个线程的操作的状态更改时，调用此方法。  
  
 超时可确保，当前线程不会无限期阻塞如果另一个线程释放锁，但第一个调用不<xref:System.Threading.Monitor.Pulse%2A>或<xref:System.Threading.Monitor.PulseAll%2A>方法。 此外，它还会将线程移到准备就绪的队列，以便它可以更快地重新获取该锁绕过早在等待队列中，其他线程。 该线程可以测试的返回值<xref:System.Threading.Monitor.Wait%2A>方法，以确定它是否重新获取则在超时之前的锁。线程可以评估条件导致它进入等待，并且如果必要调用<xref:System.Threading.Monitor.Wait%2A>再次方法。  
  
 当线程调用`Wait`，释放对象上的锁，并进入对象的等待队列。 对象的准备就绪的队列中的下一个线程 （如果有） 获取该锁和独占使用的对象。 调用的线程`Wait`仍在等待队列中直至持有锁的线程调用<xref:System.Threading.Monitor.PulseAll%2A>，或它是在队列中的下一步并持有锁的线程调用<xref:System.Threading.Monitor.Pulse%2A>。 但是，如果`timeout`前另一个线程调用此对象的经过<xref:System.Threading.Monitor.Pulse%2A>或<xref:System.Threading.Monitor.PulseAll%2A>方法，在原始线程将移动到准备就绪的队列，以便重新获取该锁。  
  
> [!NOTE]
>  如果<xref:System.TimeSpan>指定表示-1 毫秒`timeout`参数，此方法会无限期阻止除非锁持有者调用<xref:System.Threading.Monitor.Pulse%2A>或<xref:System.Threading.Monitor.PulseAll%2A>。 如果`timeout`为 0 毫秒，调用的线程`Wait`释放锁，然后立即进入就绪队列以便重新获取该锁。  
  
 调用方执行`Wait`一次，无论有多少次<xref:System.Threading.Monitor.Enter%2A>已调用为指定的对象。 从概念上讲，`Wait`方法将存储在调用方调用的次数<xref:System.Threading.Monitor.Enter%2A>对象并调用<xref:System.Threading.Monitor.Exit%2A>尽可能多地需要完全释放锁定的对象。 然后，调用方被阻塞等待重新获取该对象时。 当调用方重新获取该锁时，系统会调用<xref:System.Threading.Monitor.Enter%2A>根据需要还原保存的多次<xref:System.Threading.Monitor.Enter%2A>调用方的计数。 调用`Wait`释放指定对象的锁; 如果调用方是对其他对象的锁的所有者，这些锁也不会释放。  
  
> [!NOTE]
>  同步的对象包含多个引用，其中包括对在线程当前持有锁、 准备就绪的队列，其中包含准备好获取锁的线程，对的引用和对等待队列，其中包含的引用的引用有关的对象的状态的更改通知等待的线程。  
  
 <xref:System.Threading.Monitor.Pulse%2A>， <xref:System.Threading.Monitor.PulseAll%2A>，和`Wait`方法必须从调用代码的同步块内。  
  
 备注<xref:System.Threading.Monitor.Pulse%2A>解释发生的方法如果<xref:System.Threading.Monitor.Pulse%2A>没有线程处于等待状态时调用。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="obj" /> 参数为 <see langword="null" />。</exception>
        <exception cref="T:System.Threading.SynchronizationLockException">调用线程不拥有指定对象的锁。</exception>
        <exception cref="T:System.Threading.ThreadInterruptedException">调用 <see langword="Wait" /> 的线程稍后从等待状态中断。 另一线程调用此线程的 <see cref="M:System.Threading.Thread.Interrupt" /> 方法时将发生这种情况。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="timeout" /> 参数值（以毫秒为单位）为负且不表示 <see cref="F:System.Threading.Timeout.Infinite" />（-1 毫秒），或者大于 <see cref="F:System.Int32.MaxValue" />。</exception>
        <altmember cref="T:System.Threading.Thread" />
      </Docs>
    </Member>
    <Member MemberName="Wait">
      <MemberSignature Language="C#" Value="public static bool Wait (object obj, int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Wait(object obj, int32 millisecondsTimeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.Wait(System.Object,System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Wait (obj As Object, millisecondsTimeout As Integer, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Wait(System::Object ^ obj, int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="static member Wait : obj * int * bool -&gt; bool" Usage="System.Threading.Monitor.Wait (obj, millisecondsTimeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="obj">要在其上等待的对象。</param>
        <param name="millisecondsTimeout">线程进入就绪队列之前等待的毫秒数。</param>
        <param name="exitContext">如果在等待前退出并重新获取上下文的同步域（如果在同步上下文中），则为 <see langword="true" />；否则为 <see langword="false" />。</param>
        <summary>释放对象上的锁并阻止当前线程，直到它重新获取该锁。 如果已用指定的超时时间间隔，则线程进入就绪队列。 此方法还指定是否在等待之前退出上下文的同步域（如果在同步上下文中）然后重新获取该同步域。</summary>
        <returns>如果在指定的时间过期之前重新获取该锁，则为 <see langword="true" />；如果在指定的时间过期之后重新获取该锁，则为 <see langword="false" />。 此方法只有在重新获取该锁后才会返回。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法不返回直到它重新上获取排他锁`obj`参数。  
  
 当前拥有指定对象上的锁的线程调用此方法以释放该对象，以便另一个线程可以访问它。 等待重新获取锁时阻止调用方。 当调用方需要等待导致另一个线程的操作的状态更改时，调用此方法。  
  
 超时可确保，当前线程不会无限期阻塞如果另一个线程释放锁，但第一个调用不<xref:System.Threading.Monitor.Pulse%2A>或<xref:System.Threading.Monitor.PulseAll%2A>方法。 此外，它还会将线程移到准备就绪的队列，以便它可以更快地重新获取该锁绕过早在等待队列中，其他线程。 该线程可以测试的返回值<xref:System.Threading.Monitor.Wait%2A>方法，以确定它是否重新获取则在超时之前的锁。线程可以评估条件导致它进入等待，并且如果必要调用<xref:System.Threading.Monitor.Wait%2A>再次方法。  
  
 当线程调用`Wait`，释放该锁，并进入等待队列。 此时，在准备就绪的队列中的下一个线程 （如果有） 允许控制锁。 调用的线程`Wait`仍在等待队列中直至持有锁的线程调用<xref:System.Threading.Monitor.PulseAll%2A>，或它是在队列中的下一步并持有锁的线程调用<xref:System.Threading.Monitor.Pulse%2A>。 但是，如果`millisecondsTimeout`前另一个线程调用此对象的经过<xref:System.Threading.Monitor.Pulse%2A>或<xref:System.Threading.Monitor.PulseAll%2A>方法，在原始线程将移动到准备就绪的队列，以便重新获取该锁。  
  
> [!NOTE]
>  如果<xref:System.Threading.Timeout.Infinite>为指定`millisecondsTimeout`参数，此方法会无限期阻止除非锁持有者调用<xref:System.Threading.Monitor.Pulse%2A>或<xref:System.Threading.Monitor.PulseAll%2A>。 如果`millisecondsTimeout`等于 0，调用的线程`Wait`释放锁，然后立即进入就绪队列以便重新获取该锁。  
  
 调用方执行`Wait`一次，无论有多少次<xref:System.Threading.Monitor.Enter%2A>已调用为指定的对象。 从概念上讲，`Wait`方法将存储在调用方调用的次数<xref:System.Threading.Monitor.Enter%2A>对象并调用<xref:System.Threading.Monitor.Exit%2A>尽可能多地需要完全释放锁定的对象。 然后，调用方被阻塞等待重新获取该对象时。 当调用方重新获取该锁时，系统会调用<xref:System.Threading.Monitor.Enter%2A>根据需要还原保存的多次<xref:System.Threading.Monitor.Enter%2A>调用方的计数。 调用`Wait`释放指定对象的锁; 如果调用方是对其他对象的锁的所有者，这些锁也不会释放。  
  
> [!NOTE]
>  同步的对象包含多个引用，其中包括对在线程当前持有锁、 准备就绪的队列，其中包含准备好获取锁的线程，对的引用和对等待队列，其中包含的引用的引用有关的对象的状态的更改通知等待的线程。  
  
 <xref:System.Threading.Monitor.Pulse%2A>， <xref:System.Threading.Monitor.PulseAll%2A>，和`Wait`方法必须从调用代码的同步块内。  
  
 备注<xref:System.Threading.Monitor.Pulse%2A>解释发生的方法如果<xref:System.Threading.Monitor.Pulse%2A>没有线程处于等待状态时调用。  
  
## <a name="notes-on-exiting-the-context"></a>在退出上下文的说明  
 `exitContext`参数无任何效果，除非<xref:System.Threading.Monitor.Wait%2A>从非默认托管上下文中调用方法。 如果你的线程是派生自的类的实例的调用内部发生这种情况<xref:System.ContextBoundObject>。 即使当前正在执行一种方法不派生自的类上<xref:System.ContextBoundObject>，例如<xref:System.String>，可以在非默认上下文中是如果<xref:System.ContextBoundObject>是当前的应用程序域中的堆栈上。  
  
 时在非默认上下文中执行代码时，指定`true`有关`exitContext`会导致线程退出非默认托管的上下文 (即，转换到默认上下文) 执行前<xref:System.Threading.Monitor.Wait%2A>方法。 在调用后返回到原始的非默认上下文<xref:System.Threading.Monitor.Wait%2A>方法完成。  
  
 在上下文绑定类时这很有用<xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>应用属性。 在这种情况下，所有调用的类的成员将自动都同步，并同步域是为类代码的整个正文。 如果某个成员的调用堆栈中的代码将调用<xref:System.Threading.Monitor.Wait%2A>方法，并指定`true`为`exitContext`，在线程退出同步域，这样在调用对象的任何成员以继续操作被阻止的线程。 当<xref:System.Threading.Monitor.Wait%2A>方法返回时，调用线程必须等待以重新输入同步域。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="obj" /> 参数为 <see langword="null" />。</exception>
        <exception cref="T:System.Threading.SynchronizationLockException">
          <see langword="Wait" /> 不是从同步的代码块中调用的。</exception>
        <exception cref="T:System.Threading.ThreadInterruptedException">调用 <see langword="Wait" /> 的线程稍后从等待状态中断。 另一线程调用此线程的 <see cref="M:System.Threading.Thread.Interrupt" /> 方法时将发生这种情况。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsTimeout" /> 参数值为负且不等于 <see cref="F:System.Threading.Timeout.Infinite" />。</exception>
        <altmember cref="T:System.Threading.Thread" />
      </Docs>
    </Member>
    <Member MemberName="Wait">
      <MemberSignature Language="C#" Value="public static bool Wait (object obj, TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Wait(object obj, valuetype System.TimeSpan timeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Wait (obj As Object, timeout As TimeSpan, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Wait(System::Object ^ obj, TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="static member Wait : obj * TimeSpan * bool -&gt; bool" Usage="System.Threading.Monitor.Wait (obj, timeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="obj">要在其上等待的对象。</param>
        <param name="timeout">
          <see cref="T:System.TimeSpan" />，表示线程进入就绪队列之前等待的时间量。</param>
        <param name="exitContext">如果在等待前退出并重新获取上下文的同步域（如果在同步上下文中），则为 <see langword="true" />；否则为 <see langword="false" />。</param>
        <summary>释放对象上的锁并阻止当前线程，直到它重新获取该锁。 如果已用指定的超时时间间隔，则线程进入就绪队列。 可以在等待之前退出同步上下文的同步域，随后重新获取该域。</summary>
        <returns>如果在指定的时间过期之前重新获取该锁，则为 <see langword="true" />；如果在指定的时间过期之后重新获取该锁，则为 <see langword="false" />。 此方法只有在重新获取该锁后才会返回。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法不返回直到它重新上获取排他锁`obj`参数。  
  
 当前拥有指定对象上的锁的线程调用此方法以释放该对象，以便另一个线程可以访问它。 等待重新获取锁时阻止调用方。 当调用方需要等待导致另一个线程的操作的状态更改时，调用此方法。  
  
 超时可确保，当前线程不会无限期阻塞如果另一个线程释放锁，但第一个调用不<xref:System.Threading.Monitor.Pulse%2A>或<xref:System.Threading.Monitor.PulseAll%2A>方法。 此外，它还会将线程移到准备就绪的队列，以便它可以更快地重新获取该锁绕过早在等待队列中，其他线程。 该线程可以测试的返回值<xref:System.Threading.Monitor.Wait%2A>方法，以确定它是否重新获取则在超时之前的锁。线程可以评估条件导致它进入等待，并且如果必要调用<xref:System.Threading.Monitor.Wait%2A>再次方法。  
  
 当线程调用`Wait`，释放该锁，并进入等待队列。 此时，在准备就绪的队列中的下一个线程 （如果有） 允许控制锁。 调用的线程`Wait`仍在等待队列中直至持有锁的线程调用<xref:System.Threading.Monitor.PulseAll%2A>，或它是在队列中的下一步并持有锁的线程调用<xref:System.Threading.Monitor.Pulse%2A>。 但是，如果`timeout`毫秒等待另一个线程调用此对象之前<xref:System.Threading.Monitor.Pulse%2A>或<xref:System.Threading.Monitor.PulseAll%2A>方法，在原始线程将移动到准备就绪的队列，以便重新获取该锁。  
  
> [!NOTE]
>  如果<xref:System.TimeSpan>指定表示-1 毫秒`timeout`参数，此方法会无限期阻止除非锁持有者调用<xref:System.Threading.Monitor.Pulse%2A>或<xref:System.Threading.Monitor.PulseAll%2A>。 如果`timeout`为 0 毫秒，调用的线程`Wait`释放锁，然后立即进入就绪队列以便重新获取该锁。  
  
 调用方执行`Wait`一次，无论有多少次<xref:System.Threading.Monitor.Enter%2A>已调用为指定的对象。 从概念上讲，`Wait`方法将存储在调用方调用的次数<xref:System.Threading.Monitor.Enter%2A>对象并调用<xref:System.Threading.Monitor.Exit%2A>尽可能多地需要完全释放锁定的对象。 然后，调用方被阻塞等待重新获取该对象时。 当调用方重新获取该锁时，系统会调用<xref:System.Threading.Monitor.Enter%2A>根据需要还原保存的多次<xref:System.Threading.Monitor.Enter%2A>调用方的计数。 调用`Wait`释放指定对象的锁; 如果调用方是对其他对象的锁的所有者，这些锁也不会释放。  
  
> [!NOTE]
>  同步的对象包含多个引用，其中包括对在线程当前持有锁、 准备就绪的队列，其中包含准备好获取锁的线程，对的引用和对等待队列，其中包含的引用的引用有关的对象的状态的更改通知等待的线程。  
  
 <xref:System.Threading.Monitor.Pulse%2A>， <xref:System.Threading.Monitor.PulseAll%2A>，和`Wait`方法必须从调用代码的同步块内。  
  
 备注<xref:System.Threading.Monitor.Pulse%2A>解释发生的方法如果<xref:System.Threading.Monitor.Pulse%2A>没有线程处于等待状态时调用。  
  
## <a name="notes-on-exiting-the-context"></a>在退出上下文的说明  
 `exitContext`参数无任何效果，除非<xref:System.Threading.Monitor.Wait%2A>从非默认托管上下文中调用方法。 如果你的线程是派生自的类的实例的调用内部发生这种情况<xref:System.ContextBoundObject>。 即使当前正在执行一种方法不派生自的类上<xref:System.ContextBoundObject>，例如<xref:System.String>，可以在非默认上下文中是如果<xref:System.ContextBoundObject>是当前的应用程序域中的堆栈上。  
  
 时在非默认上下文中执行代码时，指定`true`有关`exitContext`会导致线程退出非默认托管的上下文 (即，转换到默认上下文) 执行前<xref:System.Threading.Monitor.Wait%2A>方法。 在调用后返回到原始的非默认上下文<xref:System.Threading.Monitor.Wait%2A>方法完成。  
  
 在上下文绑定类时这很有用<xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>应用属性。 在这种情况下，所有调用的类的成员将自动都同步，并同步域是为类代码的整个正文。 如果某个成员的调用堆栈中的代码将调用<xref:System.Threading.Monitor.Wait%2A>方法，并指定`true`为`exitContext`，在线程退出同步域，这样在调用对象的任何成员以继续操作被阻止的线程。 当<xref:System.Threading.Monitor.Wait%2A>方法返回时，调用线程必须等待以重新输入同步域。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="obj" /> 参数为 <see langword="null" />。</exception>
        <exception cref="T:System.Threading.SynchronizationLockException">
          <see langword="Wait" /> 不是从同步的代码块中调用的。</exception>
        <exception cref="T:System.Threading.ThreadInterruptedException">调用 Wait 的线程稍后会从等待状态中中断。 另一线程调用此线程的 <see cref="M:System.Threading.Thread.Interrupt" /> 方法时将发生这种情况。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="timeout" /> 参数为负数，并且不表示 <see cref="F:System.Threading.Timeout.Infinite" />（-1 毫秒），或者大于 <see cref="F:System.Int32.MaxValue" />。</exception>
        <altmember cref="T:System.Threading.Thread" />
      </Docs>
    </Member>
  </Members>
</Type>