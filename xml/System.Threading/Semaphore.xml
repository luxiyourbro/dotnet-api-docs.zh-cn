<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="Semaphore.xml" source-language="en-US" target-language="zh-CN">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-15c36f0" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">02cd5861-7ce2-4a82-b358-31f8435a0ac5589fcf34edfc4ff1eb1c243acad8b5ad0d3cd911.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">589fcf34edfc4ff1eb1c243acad8b5ad0d3cd911</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/03/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netcore-1.0,netcore-1.1,netcore-2.0,netcore-2.1,netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7,netstandard-1.0,netstandard-1.1,netstandard-1.2,netstandard-1.3,netstandard-1.4,netstandard-1.6,netstandard-2.0,xamarinandroid-7.1,xamarinios-10.8,xamarinmac-3.0</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.Threading.Semaphore">
          <source>Limits the number of threads that can access a resource or pool of resources concurrently.</source>
          <target state="translated">限制可同时访问某一资源或资源池的线程数。</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Semaphore">
          <source>Use the <ph id="ph1">&lt;xref:System.Threading.Semaphore&gt;</ph> class to control access to a pool of resources.</source>
          <target state="translated">使用<ph id="ph1">&lt;xref:System.Threading.Semaphore&gt;</ph>类来控制对资源的池的访问。</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Semaphore">
          <source>Threads enter the semaphore by calling the <ph id="ph1">&lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;</ph> method, which is inherited from the <ph id="ph2">&lt;xref:System.Threading.WaitHandle&gt;</ph> class, and release the semaphore by calling the <ph id="ph3">&lt;xref:System.Threading.Semaphore.Release%2A&gt;</ph> method.</source>
          <target state="translated">线程进入信号量，通过调用<ph id="ph1">&lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;</ph>方法，继承自<ph id="ph2">&lt;xref:System.Threading.WaitHandle&gt;</ph>类，并通过调用释放信号量<ph id="ph3">&lt;xref:System.Threading.Semaphore.Release%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Semaphore">
          <source>The count on a semaphore is decremented each time a thread enters the semaphore, and incremented when a thread releases the semaphore.</source>
          <target state="translated">上一个信号量计数会递减每当一个线程进入信号量，和一个线程释放信号量时，会增加的时。</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Semaphore">
          <source>When the count is zero, subsequent requests block until other threads release the semaphore.</source>
          <target state="translated">当计数为零时，其他线程释放信号量一直进行阻止后续请求。</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Semaphore">
          <source>When all threads have released the semaphore, the count is at the maximum value specified when the semaphore was created.</source>
          <target state="translated">如果所有线程都已都释放信号量，计数是最大值时指定创建信号量。</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Semaphore">
          <source>There is no guaranteed order, such as FIFO or LIFO, in which blocked threads enter the semaphore.</source>
          <target state="translated">没有任何有保证的顺序，如先进先出或后进先出，在其中受阻的线程进入信号量。</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Semaphore">
          <source>A thread can enter the semaphore multiple times, by calling the <ph id="ph1">&lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;</ph> method repeatedly.</source>
          <target state="translated">线程可以输入信号量多次，通过调用<ph id="ph1">&lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;</ph>方法重复。</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Semaphore">
          <source>To release some or all of these entries, the thread can call the parameterless <ph id="ph1">&lt;xref:System.Threading.Semaphore.Release&gt;</ph> method overload multiple times, or it can call the <ph id="ph2">&lt;xref:System.Threading.Semaphore.Release%28System.Int32%29&gt;</ph> method overload that specifies the number of entries to be released.</source>
          <target state="translated">若要释放某些或所有这些项，可以调用线程的无参数<ph id="ph1">&lt;xref:System.Threading.Semaphore.Release&gt;</ph>多个倍，或它可以调用的方法重载<ph id="ph2">&lt;xref:System.Threading.Semaphore.Release%28System.Int32%29&gt;</ph>方法重载来指定要释放的项数。</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Semaphore">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Semaphore&gt;</ph> class does not enforce thread identity on calls to <ph id="ph2">&lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Threading.Semaphore.Release%2A&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.Semaphore&gt;</ph>类不会强制在调用线程标识<ph id="ph2">&lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;</ph>或<ph id="ph3">&lt;xref:System.Threading.Semaphore.Release%2A&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Semaphore">
          <source>It is the programmer's responsibility to ensure that threads do not release the semaphore too many times.</source>
          <target state="translated">它是程序员有责任确保线程不要释放信号量次数过多。</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Semaphore">
          <source>For example, suppose a semaphore has a maximum count of two, and that thread A and thread B both enter the semaphore.</source>
          <target state="translated">例如，假定信号量的最大计数为 2 并且线程 A 和线程 B 都进入了该信号量。</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Semaphore">
          <source>If a programming error in thread B causes it to call <ph id="ph1">&lt;xref:System.Threading.Semaphore.Release%2A&gt;</ph> twice, both calls succeed.</source>
          <target state="translated">如果线程 B 中的编程错误导致它调用<ph id="ph1">&lt;xref:System.Threading.Semaphore.Release%2A&gt;</ph>两次，这两个调用成功。</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Semaphore">
          <source>The count on the semaphore is full, and when thread A eventually calls <ph id="ph1">&lt;xref:System.Threading.Semaphore.Release%2A&gt;</ph>, a <ph id="ph2">&lt;xref:System.Threading.SemaphoreFullException&gt;</ph> is thrown.</source>
          <target state="translated">信号灯计数已满，当线程 A 最终调用 <ph id="ph1">&lt;xref:System.Threading.Semaphore.Release%2A&gt;</ph> 时，<ph id="ph2">&lt;xref:System.Threading.SemaphoreFullException&gt;</ph> 抛出。</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Semaphore">
          <source>Semaphores are of two types: local semaphores and named system semaphores.</source>
          <target state="translated">信号量有两种类型： 本地信号量和已命名的系统信号量。</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Semaphore">
          <source>If you create a <ph id="ph1">&lt;xref:System.Threading.Semaphore&gt;</ph> object using a constructor that accepts a name, it is associated with an operating-system semaphore of that name.</source>
          <target state="translated">如果你创建<ph id="ph1">&lt;xref:System.Threading.Semaphore&gt;</ph>对象使用构造函数接受一个名称，它是与该名称的操作系统信号关联。</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Semaphore">
          <source>Named system semaphores are visible throughout the operating system, and can be used to synchronize the activities of processes.</source>
          <target state="translated">已命名的系统信号量可以看到在整个操作系统，也可用于同步进程的活动。</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Semaphore">
          <source>You can create multiple <ph id="ph1">&lt;xref:System.Threading.Semaphore&gt;</ph> objects that represent the same named system semaphore, and you can use the <ph id="ph2">&lt;xref:System.Threading.Semaphore.OpenExisting%2A&gt;</ph> method to open an existing named system semaphore.</source>
          <target state="translated">你可以创建多个<ph id="ph1">&lt;xref:System.Threading.Semaphore&gt;</ph>对象来表示同一个已命名系统信号量，并且你可以使用<ph id="ph2">&lt;xref:System.Threading.Semaphore.OpenExisting%2A&gt;</ph>方法以打开一个现有的命名系统信号量。</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Semaphore">
          <source>A local semaphore exists only within your process.</source>
          <target state="translated">仅在你的进程内存在本地信号量。</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Semaphore">
          <source>It can be used by any thread in your process that has a reference to the local <ph id="ph1">&lt;xref:System.Threading.Semaphore&gt;</ph> object.</source>
          <target state="translated">进程中引用本地 <ph id="ph1">&lt;xref:System.Threading.Semaphore&gt;</ph> 对象的所有线程都可以使用本地 mutex。</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Semaphore">
          <source>Each <ph id="ph1">&lt;xref:System.Threading.Semaphore&gt;</ph> object is a separate local semaphore.</source>
          <target state="translated">每个<ph id="ph1">&lt;xref:System.Threading.Semaphore&gt;</ph>对象是单独的本地信号量。</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Semaphore">
          <source>The following code example creates a semaphore with a maximum count of three and an initial count of zero.</source>
          <target state="translated">下面的代码示例创建与最大计数为三个和初始计数为零的信号量。</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Semaphore">
          <source>The example starts five threads, which block waiting for the semaphore.</source>
          <target state="translated">该示例启动五个线程，阻止等待信号量。</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Semaphore">
          <source>The main thread uses the <ph id="ph1">&lt;xref:System.Threading.Semaphore.Release%28System.Int32%29&gt;</ph> method overload to increase the semaphore count to its maximum, allowing three threads to enter the semaphore.</source>
          <target state="translated">主线程使用<ph id="ph1">&lt;xref:System.Threading.Semaphore.Release%28System.Int32%29&gt;</ph>方法重载来增加到其最大值，允许三个线程进入信号量的信号量计数。</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Semaphore">
          <source>Each thread uses the <ph id="ph1">&lt;xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType&gt;</ph> method to wait for one second, to simulate work, and then calls the <ph id="ph2">&lt;xref:System.Threading.Semaphore.Release&gt;</ph> method overload to release the semaphore.</source>
          <target state="translated">每个线程使用<ph id="ph1">&lt;xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType&gt;</ph>方法等待 1 秒，以模拟工作，然后调用<ph id="ph2">&lt;xref:System.Threading.Semaphore.Release&gt;</ph>方法重载来释放信号量。</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Semaphore">
          <source>Each time the semaphore is released, the previous semaphore count is displayed.</source>
          <target state="translated">释放信号量时，每个时间显示前一个信号量计数。</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Semaphore">
          <source>Console messages track semaphore use.</source>
          <target state="translated">控制台消息跟踪信号量的使用。</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Semaphore">
          <source>The simulated work interval is increased slightly for each thread, to make the output easier to read.</source>
          <target state="translated">模拟的工作间隔都稍有增加为每个线程，以使输出更易于阅读。</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Semaphore">
          <source>This type is thread safe.</source>
          <target state="translated">此类型是线程安全的。</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" uid="T:System.Threading.Semaphore">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Threading.Semaphore" /&gt;</ph> class.</source>
          <target state="translated">初始化 <ph id="ph1">&lt;see cref="T:System.Threading.Semaphore" /&gt;</ph> 类的新实例。</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32)">
          <source>The initial number of requests for the semaphore that can be granted concurrently.</source>
          <target state="translated">可以同时授予的信号量的初始请求数。</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32)">
          <source>The maximum number of requests for the semaphore that can be granted concurrently.</source>
          <target state="translated">可以同时授予的信号量的最大请求数。</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Threading.Semaphore" /&gt;</ph> class, specifying the initial number of entries and the maximum number of concurrent entries.</source>
          <target state="translated">初始化 <ph id="ph1">&lt;see cref="T:System.Threading.Semaphore" /&gt;</ph> 类的新实例，并指定初始入口数和最大并发入口数。</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32)">
          <source>This constructor initializes an unnamed semaphore.</source>
          <target state="translated">此构造函数初始化未命名信号量。</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32)">
          <source>All threads that use an instance of such a semaphore must have references to the instance.</source>
          <target state="translated">使用此类的信号量的实例的所有线程必须都具有对该实例引用。</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32)">
          <source>If <ph id="ph1">`initialCount`</ph> is less than <ph id="ph2">`maximumCount`</ph>, the effect is the same as if the current thread had called <ph id="ph3">&lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;</ph> (<ph id="ph4">`maximumCount`</ph> minus <ph id="ph5">`initialCount`</ph>) times.</source>
          <target state="translated">如果<ph id="ph1">`initialCount`</ph>是小于<ph id="ph2">`maximumCount`</ph>，效果都是相同就像调用当前线程一样<ph id="ph3">&lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;</ph>(<ph id="ph4">`maximumCount`</ph>减<ph id="ph5">`initialCount`</ph>) 时间。</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32)">
          <source>If you do not want to reserve any entries for the thread that creates the semaphore, use the same number for <ph id="ph1">`maximumCount`</ph> and <ph id="ph2">`initialCount`</ph>.</source>
          <target state="translated">如果您不想要保留任何项创建信号量的线程，使用的相同号<ph id="ph1">`maximumCount`</ph>和<ph id="ph2">`initialCount`</ph>。</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32)">
          <source>The following example creates a semaphore with a maximum count of three and an initial count of zero.</source>
          <target state="translated">下面的示例创建三个的最大计数和初始计数为零的信号量。</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32)">
          <source>The example starts five threads, which block waiting for the semaphore.</source>
          <target state="translated">该示例启动五个线程，阻止等待信号量。</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32)">
          <source>The main thread uses the <ph id="ph1">&lt;xref:System.Threading.Semaphore.Release%28System.Int32%29&gt;</ph> method overload to increase the semaphore count to its maximum, allowing three threads to enter the semaphore.</source>
          <target state="translated">主线程使用<ph id="ph1">&lt;xref:System.Threading.Semaphore.Release%28System.Int32%29&gt;</ph>方法重载来增加到其最大值，允许三个线程进入信号量的信号量计数。</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32)">
          <source>Each thread uses the <ph id="ph1">&lt;xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType&gt;</ph> method to wait for one second, to simulate work, and then calls the <ph id="ph2">&lt;xref:System.Threading.Semaphore.Release&gt;</ph> method overload to release the semaphore.</source>
          <target state="translated">每个线程使用<ph id="ph1">&lt;xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType&gt;</ph>方法等待 1 秒，以模拟工作，然后调用<ph id="ph2">&lt;xref:System.Threading.Semaphore.Release&gt;</ph>方法重载来释放信号量。</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32)">
          <source>Each time the semaphore is released, the previous semaphore count is displayed.</source>
          <target state="translated">释放信号量时，每个时间显示前一个信号量计数。</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32)">
          <source>Console messages track semaphore use.</source>
          <target state="translated">控制台消息跟踪信号量的使用。</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32)">
          <source>The simulated work interval is increased slightly for each thread, to make the output easier to read.</source>
          <target state="translated">模拟的工作间隔都稍有增加为每个线程，以使输出更易于阅读。</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="initialCount" /&gt;</ph> is greater than <ph id="ph2">&lt;paramref name="maximumCount" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="initialCount" /&gt;</ph> 大于 <ph id="ph2">&lt;paramref name="maximumCount" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="maximumCount" /&gt;</ph> is less than 1.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="maximumCount" /&gt;</ph> 小于 1。</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="initialCount" /&gt;</ph> is less than 0.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="initialCount" /&gt;</ph> 小于 0。</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String)">
          <source>The initial number of requests for the semaphore that can be granted concurrently.</source>
          <target state="translated">可以同时授予的信号量的初始请求数。</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String)">
          <source>The maximum number of requests for the semaphore that can be granted concurrently.</source>
          <target state="translated">可以同时授予的信号量的最大请求数。</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String)">
          <source>The name of a named system semaphore object.</source>
          <target state="translated">命名系统信号量对象的名称。</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Threading.Semaphore" /&gt;</ph> class, specifying the initial number of entries and the maximum number of concurrent entries, and optionally specifying the name of a system semaphore object.</source>
          <target state="translated">初始化 <ph id="ph1">&lt;see cref="T:System.Threading.Semaphore" /&gt;</ph> 类的新实例，并指定初始入口数和最大并发入口数，可以选择指定系统信号量对象的名称。</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String)">
          <source>This constructor initializes a <ph id="ph1">&lt;xref:System.Threading.Semaphore&gt;</ph> object that represents a named system semaphore.</source>
          <target state="translated">此构造函数初始化<ph id="ph1">&lt;xref:System.Threading.Semaphore&gt;</ph>表示已命名的系统信号量的对象。</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String)">
          <source>You can create multiple <ph id="ph1">&lt;xref:System.Threading.Semaphore&gt;</ph> objects that represent the same named system semaphore.</source>
          <target state="translated">你可以创建多个<ph id="ph1">&lt;xref:System.Threading.Semaphore&gt;</ph>对象来表示同一个已命名系统信号量。</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String)">
          <source>If the named system semaphore does not exist, it is created with the initial count and maximum count specified by <ph id="ph1">`initialCount`</ph> and <ph id="ph2">`maximumCount`</ph>.</source>
          <target state="translated">如果已命名的系统信号量不存在，则使用创建它的初始计数和指定的最大计数<ph id="ph1">`initialCount`</ph>和<ph id="ph2">`maximumCount`</ph>。</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String)">
          <source>If the named system semaphore already exists, <ph id="ph1">`initialCount`</ph> and <ph id="ph2">`maximumCount`</ph> are not used, although invalid values still cause exceptions.</source>
          <target state="translated">如果已命名的系统信号量已存在，<ph id="ph1">`initialCount`</ph>和<ph id="ph2">`maximumCount`</ph>不使用名称，尽管无效的值仍会导致异常。</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String)">
          <source>If you need to determine whether or not a named system semaphore was created, use the <ph id="ph1">&lt;xref:System.Threading.Semaphore.%23ctor%28System.Int32%2CSystem.Int32%2CSystem.String%2CSystem.Boolean%40%29&gt;</ph> constructor overload instead.</source>
          <target state="translated">如果你需要确定是否已创建了命名的系统信号量，使用<ph id="ph1">&lt;xref:System.Threading.Semaphore.%23ctor%28System.Int32%2CSystem.Int32%2CSystem.String%2CSystem.Boolean%40%29&gt;</ph>构造函数重载。</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String)">
          <source>When you use this constructor overload, the recommended practice is to specify the same number for <ph id="ph1">`initialCount`</ph> and <ph id="ph2">`maximumCount`</ph>.</source>
          <target state="translated">当你使用此构造函数重载时，建议的做法是指定的相同号<ph id="ph1">`initialCount`</ph>和<ph id="ph2">`maximumCount`</ph>。</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String)">
          <source>If <ph id="ph1">`initialCount`</ph> is less than <ph id="ph2">`maximumCount`</ph>, and a named system semaphore is created, the effect is the same as if the current thread had called <ph id="ph3">&lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;</ph> (<ph id="ph4">`maximumCount`</ph> minus <ph id="ph5">`initialCount`</ph>) times.</source>
          <target state="translated">如果<ph id="ph1">`initialCount`</ph>是小于<ph id="ph2">`maximumCount`</ph>，并创建了命名的系统信号量，效果都是相同就像调用当前线程一样<ph id="ph3">&lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;</ph>(<ph id="ph4">`maximumCount`</ph>减<ph id="ph5">`initialCount`</ph>) 时间。</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String)">
          <source>However, with this constructor overload there is no way to determine whether a named system semaphore was created.</source>
          <target state="translated">但是，使用此构造函数重载没有方法来确定是否已创建了命名的系统信号量。</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String)">
          <source>If you specify <ph id="ph1">`null`</ph> or an empty string for <ph id="ph2">`name`</ph>, a local semaphore is created, as if you had called the <ph id="ph3">&lt;xref:System.Threading.Semaphore.%23ctor%28System.Int32%2CSystem.Int32%29&gt;</ph> constructor overload.</source>
          <target state="translated">如果指定<ph id="ph1">`null`</ph>或为空字符串<ph id="ph2">`name`</ph>，创建了本地信号量时，就像已调用<ph id="ph3">&lt;xref:System.Threading.Semaphore.%23ctor%28System.Int32%2CSystem.Int32%29&gt;</ph>构造函数重载。</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String)">
          <source>Because named semaphores are visible throughout the operating system, they can be used to coordinate resource use across process boundaries.</source>
          <target state="translated">因为命名信号量是在整个操作系统可见的它们可以用于协调跨进程边界的资源使用。</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String)">
          <source>If you want to find out whether a named system semaphore exists, use the <ph id="ph1">&lt;xref:System.Threading.Semaphore.OpenExisting%2A&gt;</ph> method.</source>
          <target state="translated">如果你想要查找已命名的系统信号量是否存在，请使用<ph id="ph1">&lt;xref:System.Threading.Semaphore.OpenExisting%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String)">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Semaphore.OpenExisting%2A&gt;</ph> method attempts to open an existing named semaphore, and throws an exception if the system semaphore does not exist.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.Semaphore.OpenExisting%2A&gt;</ph>方法尝试打开现有的已命名信号量，并在引发异常，如果不存在的系统信号量。</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String)">
          <source>The following code example demonstrates the cross-process behavior of a named semaphore.</source>
          <target state="translated">下面的代码示例演示了命名信号量的跨进程行为。</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String)">
          <source>The example creates a named semaphore with a maximum count of five and an initial count of five.</source>
          <target state="translated">该示例创建具有五个的最大计数和五个初始计数命名信号量。</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String)">
          <source>The program makes three calls to the <ph id="ph1">&lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;</ph> method.</source>
          <target state="translated">程序调用三<ph id="ph1">&lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String)">
          <source>Thus, if you run the compiled example from two command windows, the second copy will block on the third call to <ph id="ph1">&lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;</ph>.</source>
          <target state="translated">因此，如果从两个命令窗口中运行已编译的示例，则第二个副本将阻止在第三个调用<ph id="ph1">&lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String)">
          <source>Release one or more entries in the first copy of the program to unblock the second.</source>
          <target state="translated">释放第一个计划，以便取消阻止第二个副本中的一个或多个条目。</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String)">
          <source><ph id="ph1">&lt;paramref name="initialCount" /&gt;</ph> is greater than <ph id="ph2">&lt;paramref name="maximumCount" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="initialCount" /&gt;</ph> 大于 <ph id="ph2">&lt;paramref name="maximumCount" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String)">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is longer than 260 characters.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> 超过 260 个字符。</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String)">
          <source><ph id="ph1">&lt;paramref name="maximumCount" /&gt;</ph> is less than 1.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="maximumCount" /&gt;</ph> 小于 1。</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String)">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String)">
          <source><ph id="ph1">&lt;paramref name="initialCount" /&gt;</ph> is less than 0.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="initialCount" /&gt;</ph> 小于 0。</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String)">
          <source>A Win32 error occurred.</source>
          <target state="translated">出现 Win32 错误。</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String)">
          <source>The named semaphore exists and has access control security, and the user does not have <ph id="ph1">&lt;see cref="F:System.Security.AccessControl.SemaphoreRights.FullControl" /&gt;</ph>.</source>
          <target state="translated">命名信号量存在且具有访问控制安全性，用户不具有 <ph id="ph1">&lt;see cref="F:System.Security.AccessControl.SemaphoreRights.FullControl" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String)">
          <source>The named semaphore cannot be created, perhaps because a wait handle of a different type has the same name.</source>
          <target state="translated">无法创建命名信号量，可能是由于其他类型的等待句柄具有相同名称。</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String)">
          <source>for calling unmanaged code to create a named system semaphore.</source>
          <target state="translated">用于调用非托管的代码来创建已命名的系统信号量。</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /&gt;</ph>.</source>
          <target state="translated">关联枚举：<ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String)">
          <source>Security action: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" /&gt;</ph>.</source>
          <target state="translated">安全操作： <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@)">
          <source>The initial number of requests for the semaphore that can be satisfied concurrently.</source>
          <target state="translated">可以同时满足的信号量的初始请求数。</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@)">
          <source>The maximum number of requests for the semaphore that can be satisfied concurrently.</source>
          <target state="translated">可以同时满足的信号量的最大请求数。</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@)">
          <source>The name of a named system semaphore object.</source>
          <target state="translated">命名系统信号量对象的名称。</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@)">
          <source>When this method returns, contains <ph id="ph1">&lt;see langword="true" /&gt;</ph> if a local semaphore was created (that is, if <bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> is <ph id="ph2">&lt;see langword="null" /&gt;</ph> or an empty string) or if the specified named system semaphore was created; <ph id="ph3">&lt;see langword="false" /&gt;</ph> if the specified named system semaphore already existed.</source>
          <target state="translated">在此方法返回时，如果创建了本地信号量（即，如果 <bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> 为 <ph id="ph2">&lt;see langword="null" /&gt;</ph> 或空字符串）或指定的已命名系统信号量，则包含 <ph id="ph1">&lt;see langword="true" /&gt;</ph>；如果指定的已命名系统信号量已存在，则为 <ph id="ph3">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@)">
          <source>This parameter is passed uninitialized.</source>
          <target state="translated">此参数未经初始化即被传递。</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Threading.Semaphore" /&gt;</ph> class, specifying the initial number of entries and the maximum number of concurrent entries, optionally specifying the name of a system semaphore object, and specifying a variable that receives a value indicating whether a new system semaphore was created.</source>
          <target state="translated">初始化 <ph id="ph1">&lt;see cref="T:System.Threading.Semaphore" /&gt;</ph> 类的新实例，并指定初始入口数和最大并发入口数，还可以选择指定系统信号量对象的名称，以及指定一个变量来接收指示是否创建了新系统信号量的值。</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@)">
          <source>This constructor initializes a <ph id="ph1">&lt;xref:System.Threading.Semaphore&gt;</ph> object that represents a named system semaphore.</source>
          <target state="translated">此构造函数初始化<ph id="ph1">&lt;xref:System.Threading.Semaphore&gt;</ph>表示已命名的系统信号量的对象。</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@)">
          <source>You can create multiple <ph id="ph1">&lt;xref:System.Threading.Semaphore&gt;</ph> objects that represent the same named system semaphore.</source>
          <target state="translated">你可以创建多个<ph id="ph1">&lt;xref:System.Threading.Semaphore&gt;</ph>对象来表示同一个已命名系统信号量。</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@)">
          <source>If the named system semaphore does not exist, it is created with the initial count and maximum count specified by <ph id="ph1">`initialCount`</ph> and <ph id="ph2">`maximumCount`</ph>.</source>
          <target state="translated">如果已命名的系统信号量不存在，则使用创建它的初始计数和指定的最大计数<ph id="ph1">`initialCount`</ph>和<ph id="ph2">`maximumCount`</ph>。</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@)">
          <source>If the named system semaphore already exists, <ph id="ph1">`initialCount`</ph> and <ph id="ph2">`maximumCount`</ph> are not used, although invalid values still cause exceptions.</source>
          <target state="translated">如果已命名的系统信号量已存在，<ph id="ph1">`initialCount`</ph>和<ph id="ph2">`maximumCount`</ph>不使用名称，尽管无效的值仍会导致异常。</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@)">
          <source>Use <ph id="ph1">`createdNew`</ph> to determine whether the system semaphore was created.</source>
          <target state="translated">使用<ph id="ph1">`createdNew`</ph>来确定是否已创建的系统信号量。</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@)">
          <source>If <ph id="ph1">`initialCount`</ph> is less than <ph id="ph2">`maximumCount`</ph>, and <ph id="ph3">`createdNew`</ph> is <ph id="ph4">`true`</ph>, the effect is the same as if the current thread had called <ph id="ph5">&lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;</ph> (<ph id="ph6">`maximumCount`</ph> minus <ph id="ph7">`initialCount`</ph>) times.</source>
          <target state="translated">如果<ph id="ph1">`initialCount`</ph>是小于<ph id="ph2">`maximumCount`</ph>，和<ph id="ph3">`createdNew`</ph>是<ph id="ph4">`true`</ph>，效果都是相同就像调用当前线程一样<ph id="ph5">&lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;</ph>(<ph id="ph6">`maximumCount`</ph>减<ph id="ph7">`initialCount`</ph>) 时间。</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@)">
          <source>If you specify <ph id="ph1">`null`</ph> or an empty string for <ph id="ph2">`name`</ph>, a local semaphore is created, as if you had called the <ph id="ph3">&lt;xref:System.Threading.Semaphore.%23ctor%28System.Int32%2CSystem.Int32%29&gt;</ph> constructor overload.</source>
          <target state="translated">如果指定<ph id="ph1">`null`</ph>或为空字符串<ph id="ph2">`name`</ph>，创建了本地信号量时，就像已调用<ph id="ph3">&lt;xref:System.Threading.Semaphore.%23ctor%28System.Int32%2CSystem.Int32%29&gt;</ph>构造函数重载。</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@)">
          <source>In this case, <ph id="ph1">`createdNew`</ph> is always <ph id="ph2">`true`</ph>.</source>
          <target state="translated">在这种情况下，<ph id="ph1">`createdNew`</ph>始终<ph id="ph2">`true`</ph>。</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@)">
          <source>Because named semaphores are visible throughout the operating system, they can be used to coordinate resource use across process boundaries.</source>
          <target state="translated">因为命名信号量是在整个操作系统可见的它们可以用于协调跨进程边界的资源使用。</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@)">
          <source>The following code example demonstrates the cross-process behavior of a named semaphore.</source>
          <target state="translated">下面的代码示例演示了命名信号量的跨进程行为。</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@)">
          <source>The example creates a named semaphore with a maximum count of five and an initial count of two.</source>
          <target state="translated">该示例创建一个最大计数为 5、 初始计数为两个名称为信号量。</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@)">
          <source>That is, it reserves three entries for the thread that calls the constructor.</source>
          <target state="translated">也就是说，它保留线程的调用构造函数的三个条目。</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@)">
          <source>If <ph id="ph1">`createNew`</ph> is <ph id="ph2">`false`</ph>, the program makes three calls to the <ph id="ph3">&lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;</ph> method.</source>
          <target state="translated">如果<ph id="ph1">`createNew`</ph>是<ph id="ph2">`false`</ph>，程序调用三<ph id="ph3">&lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@)">
          <source>Thus, if you run the compiled example from two command windows, the second copy will block on the third call to <ph id="ph1">&lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;</ph>.</source>
          <target state="translated">因此，如果从两个命令窗口中运行已编译的示例，则第二个副本将阻止在第三个调用<ph id="ph1">&lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@)">
          <source>Release one or more entries in the first copy of the program to unblock the second.</source>
          <target state="translated">释放第一个计划，以便取消阻止第二个副本中的一个或多个条目。</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@)">
          <source><ph id="ph1">&lt;paramref name="initialCount" /&gt;</ph> is greater than <ph id="ph2">&lt;paramref name="maximumCount" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="initialCount" /&gt;</ph> 大于 <ph id="ph2">&lt;paramref name="maximumCount" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@)">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is longer than 260 characters.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> 超过 260 个字符。</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@)">
          <source><ph id="ph1">&lt;paramref name="maximumCount" /&gt;</ph> is less than 1.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="maximumCount" /&gt;</ph> 小于 1。</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@)">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@)">
          <source><ph id="ph1">&lt;paramref name="initialCount" /&gt;</ph> is less than 0.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="initialCount" /&gt;</ph> 小于 0。</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@)">
          <source>A Win32 error occurred.</source>
          <target state="translated">出现 Win32 错误。</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@)">
          <source>The named semaphore exists and has access control security, and the user does not have <ph id="ph1">&lt;see cref="F:System.Security.AccessControl.SemaphoreRights.FullControl" /&gt;</ph>.</source>
          <target state="translated">命名信号量存在且具有访问控制安全性，用户不具有 <ph id="ph1">&lt;see cref="F:System.Security.AccessControl.SemaphoreRights.FullControl" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@)">
          <source>The named semaphore cannot be created, perhaps because a wait handle of a different type has the same name.</source>
          <target state="translated">无法创建命名信号量，可能是由于其他类型的等待句柄具有相同名称。</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@)">
          <source>for calling unmanaged code to create a named system semaphore.</source>
          <target state="translated">用于调用非托管的代码来创建已命名的系统信号量。</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /&gt;</ph>.</source>
          <target state="translated">关联枚举：<ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@)">
          <source>Security action: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" /&gt;</ph>.</source>
          <target state="translated">安全操作： <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@,System.Security.AccessControl.SemaphoreSecurity)">
          <source>The initial number of requests for the semaphore that can be satisfied concurrently.</source>
          <target state="translated">可以同时满足的信号量的初始请求数。</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@,System.Security.AccessControl.SemaphoreSecurity)">
          <source>The maximum number of requests for the semaphore that can be satisfied concurrently.</source>
          <target state="translated">可以同时满足的信号量的最大请求数。</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@,System.Security.AccessControl.SemaphoreSecurity)">
          <source>The name of a named system semaphore object.</source>
          <target state="translated">命名系统信号量对象的名称。</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@,System.Security.AccessControl.SemaphoreSecurity)">
          <source>When this method returns, contains <ph id="ph1">&lt;see langword="true" /&gt;</ph> if a local semaphore was created (that is, if <bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> is <ph id="ph2">&lt;see langword="null" /&gt;</ph> or an empty string) or if the specified named system semaphore was created; <ph id="ph3">&lt;see langword="false" /&gt;</ph> if the specified named system semaphore already existed.</source>
          <target state="translated">在此方法返回时，如果创建了本地信号量（即，如果 <bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> 为 <ph id="ph2">&lt;see langword="null" /&gt;</ph> 或空字符串）或指定的已命名系统信号量，则包含 <ph id="ph1">&lt;see langword="true" /&gt;</ph>；如果指定的已命名系统信号量已存在，则为 <ph id="ph3">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@,System.Security.AccessControl.SemaphoreSecurity)">
          <source>This parameter is passed uninitialized.</source>
          <target state="translated">此参数未经初始化即被传递。</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@,System.Security.AccessControl.SemaphoreSecurity)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Security.AccessControl.SemaphoreSecurity" /&gt;</ph> object that represents the access control security to be applied to the named system semaphore.</source>
          <target state="translated">一个 <ph id="ph1">&lt;see cref="T:System.Security.AccessControl.SemaphoreSecurity" /&gt;</ph> 对象，表示应用于已命名的系统信号量的访问控制安全性。</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@,System.Security.AccessControl.SemaphoreSecurity)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Threading.Semaphore" /&gt;</ph> class, specifying the initial number of entries and the maximum number of concurrent entries, optionally specifying the name of a system semaphore object, specifying a variable that receives a value indicating whether a new system semaphore was created, and specifying security access control for the system semaphore.</source>
          <target state="translated">初始化 <ph id="ph1">&lt;see cref="T:System.Threading.Semaphore" /&gt;</ph> 类的新实例，并指定初始入口数和最大并发入口数，可以选择指定系统信号量对象的名称，指定一个变量来接收指示是否创建了新系统信号量的值，以及指定系统信号量的安全访问控制。</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@,System.Security.AccessControl.SemaphoreSecurity)">
          <source>Use this constructor to apply access control security to a named system semaphore when it is created, preventing other code from taking control of the semaphore.</source>
          <target state="translated">使用此构造函数应用于已命名的系统信号量的访问控制安全性，创建时，阻止其他代码的信号量的控制。</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@,System.Security.AccessControl.SemaphoreSecurity)">
          <source>This constructor initializes a <ph id="ph1">&lt;xref:System.Threading.Semaphore&gt;</ph> object that represents a named system semaphore.</source>
          <target state="translated">此构造函数初始化<ph id="ph1">&lt;xref:System.Threading.Semaphore&gt;</ph>表示已命名的系统信号量的对象。</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@,System.Security.AccessControl.SemaphoreSecurity)">
          <source>You can create multiple <ph id="ph1">&lt;xref:System.Threading.Semaphore&gt;</ph> objects that represent the same named system semaphore.</source>
          <target state="translated">你可以创建多个<ph id="ph1">&lt;xref:System.Threading.Semaphore&gt;</ph>对象来表示同一个已命名系统信号量。</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@,System.Security.AccessControl.SemaphoreSecurity)">
          <source>If the named system semaphore does not exist, it is created with the specified access control security.</source>
          <target state="translated">如果已命名的系统信号量不存在，它被创建具有指定的访问控制安全性。</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@,System.Security.AccessControl.SemaphoreSecurity)">
          <source>If the named semaphore exists, the specified access control security is ignored.</source>
          <target state="translated">如果存在名称为信号量，则忽略指定的访问控制安全性。</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@,System.Security.AccessControl.SemaphoreSecurity)">
          <source>The caller has full control over the newly created <ph id="ph1">&lt;xref:System.Threading.Semaphore&gt;</ph> object even if <ph id="ph2">`semaphoreSecurity`</ph> denies or fails to grant some access rights to the current user.</source>
          <target state="translated">调用方具有对新创建的完全控制<ph id="ph1">&lt;xref:System.Threading.Semaphore&gt;</ph>对象即使<ph id="ph2">`semaphoreSecurity`</ph>拒绝或无法授予当前用户某些访问权限。</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@,System.Security.AccessControl.SemaphoreSecurity)">
          <source>However, if the current user attempts to get another <ph id="ph1">&lt;xref:System.Threading.Semaphore&gt;</ph> object to represent the same named semaphore, using either a constructor or the <ph id="ph2">&lt;xref:System.Threading.Semaphore.OpenExisting%2A&gt;</ph> method, Windows access control security is applied.</source>
          <target state="translated">但是，如果当前的用户尝试获取另一个<ph id="ph1">&lt;xref:System.Threading.Semaphore&gt;</ph>对象来表示同一命名信号量，使用构造函数或<ph id="ph2">&lt;xref:System.Threading.Semaphore.OpenExisting%2A&gt;</ph>方法，Windows 应用访问控制安全性。</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@,System.Security.AccessControl.SemaphoreSecurity)">
          <source>If the named system semaphore does not exist, it is created with the initial count and maximum count specified by <ph id="ph1">`initialCount`</ph> and <ph id="ph2">`maximumCount`</ph>.</source>
          <target state="translated">如果已命名的系统信号量不存在，则使用创建它的初始计数和指定的最大计数<ph id="ph1">`initialCount`</ph>和<ph id="ph2">`maximumCount`</ph>。</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@,System.Security.AccessControl.SemaphoreSecurity)">
          <source>If the named system semaphore already exists, <ph id="ph1">`initialCount`</ph> and <ph id="ph2">`maximumCount`</ph> are not used, although invalid values still cause exceptions.</source>
          <target state="translated">如果已命名的系统信号量已存在，<ph id="ph1">`initialCount`</ph>和<ph id="ph2">`maximumCount`</ph>不使用名称，尽管无效的值仍会导致异常。</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@,System.Security.AccessControl.SemaphoreSecurity)">
          <source>Use the <ph id="ph1">`createdNew`</ph> parameter to determine whether the system semaphore was created by this constructor.</source>
          <target state="translated">使用<ph id="ph1">`createdNew`</ph>参数来确定的系统信号量由此构造函数。</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@,System.Security.AccessControl.SemaphoreSecurity)">
          <source>If <ph id="ph1">`initialCount`</ph> is less than <ph id="ph2">`maximumCount`</ph>, and <ph id="ph3">`createdNew`</ph> is <ph id="ph4">`true`</ph>, the effect is the same as if the current thread had called <ph id="ph5">&lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;</ph> (<ph id="ph6">`maximumCount`</ph> minus <ph id="ph7">`initialCount`</ph>) times.</source>
          <target state="translated">如果<ph id="ph1">`initialCount`</ph>是小于<ph id="ph2">`maximumCount`</ph>，和<ph id="ph3">`createdNew`</ph>是<ph id="ph4">`true`</ph>，效果都是相同就像调用当前线程一样<ph id="ph5">&lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;</ph>(<ph id="ph6">`maximumCount`</ph>减<ph id="ph7">`initialCount`</ph>) 时间。</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@,System.Security.AccessControl.SemaphoreSecurity)">
          <source>If you specify <ph id="ph1">`null`</ph> or an empty string for <ph id="ph2">`name`</ph>, a local semaphore is created, as if you had called the <ph id="ph3">&lt;xref:System.Threading.Semaphore.%23ctor%28System.Int32%2CSystem.Int32%29&gt;</ph> constructor overload.</source>
          <target state="translated">如果指定<ph id="ph1">`null`</ph>或为空字符串<ph id="ph2">`name`</ph>，创建了本地信号量时，就像已调用<ph id="ph3">&lt;xref:System.Threading.Semaphore.%23ctor%28System.Int32%2CSystem.Int32%29&gt;</ph>构造函数重载。</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@,System.Security.AccessControl.SemaphoreSecurity)">
          <source>In this case, <ph id="ph1">`createdNew`</ph> is always <ph id="ph2">`true`</ph>.</source>
          <target state="translated">在这种情况下，<ph id="ph1">`createdNew`</ph>始终<ph id="ph2">`true`</ph>。</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@,System.Security.AccessControl.SemaphoreSecurity)">
          <source>Because named semaphores are visible throughout the operating system, they can be used to coordinate resource use across process boundaries.</source>
          <target state="translated">因为命名信号量是在整个操作系统可见的它们可以用于协调跨进程边界的资源使用。</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@,System.Security.AccessControl.SemaphoreSecurity)">
          <source>The following code example demonstrates the cross-process behavior of a named semaphore with access control security.</source>
          <target state="translated">下面的代码示例演示具有访问控制安全性的跨进程行为的名称为信号量。</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@,System.Security.AccessControl.SemaphoreSecurity)">
          <source>The example uses the <ph id="ph1">&lt;xref:System.Threading.Semaphore.OpenExisting%28System.String%29&gt;</ph> method overload to test for the existence of a named semaphore.</source>
          <target state="translated">该示例使用<ph id="ph1">&lt;xref:System.Threading.Semaphore.OpenExisting%28System.String%29&gt;</ph>方法重载来测试是否存在名称为信号量。</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@,System.Security.AccessControl.SemaphoreSecurity)">
          <source>If the semaphore does not exist, it is created with a maximum count of two and with access control security that denies the current user the right to use the semaphore but grants the right to read and change permissions on the semaphore.</source>
          <target state="translated">如果不存在信号量，创建与最大计数为 2 和将拒绝使用信号量的权限的当前用户，但授予的权限读取和更改权限信号量的访问控制安全性。</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@,System.Security.AccessControl.SemaphoreSecurity)">
          <source>If you run the compiled example from two command windows, the second copy will throw an access violation exception on the call to the <ph id="ph1">&lt;xref:System.Threading.Semaphore.OpenExisting%28System.String%29&gt;</ph> method.</source>
          <target state="translated">如果从两个命令窗口中运行已编译的示例，第二个副本将在调用引发访问冲突异常<ph id="ph1">&lt;xref:System.Threading.Semaphore.OpenExisting%28System.String%29&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@,System.Security.AccessControl.SemaphoreSecurity)">
          <source>The exception is caught, and the example uses the <ph id="ph1">&lt;xref:System.Threading.Semaphore.OpenExisting%28System.String%2CSystem.Security.AccessControl.SemaphoreRights%29&gt;</ph> method overload to open the semaphore with the rights needed to read and change the permissions.</source>
          <target state="translated">捕获了异常，并且该示例使用<ph id="ph1">&lt;xref:System.Threading.Semaphore.OpenExisting%28System.String%2CSystem.Security.AccessControl.SemaphoreRights%29&gt;</ph>方法重载，以读取和更改的权限所需的权限打开信号量。</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@,System.Security.AccessControl.SemaphoreSecurity)">
          <source>After the permissions are changed, the semaphore is opened with the rights required to enter and release.</source>
          <target state="translated">更改权限后，输入并释放所需的权限打开信号量。</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@,System.Security.AccessControl.SemaphoreSecurity)">
          <source>If you run the compiled example from a third command window, it runs using the new permissions.</source>
          <target state="translated">如果从第三个命令窗口中运行已编译的示例，它将运行使用新的权限。</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@,System.Security.AccessControl.SemaphoreSecurity)">
          <source><ph id="ph1">&lt;paramref name="initialCount" /&gt;</ph> is greater than <ph id="ph2">&lt;paramref name="maximumCount" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="initialCount" /&gt;</ph> 大于 <ph id="ph2">&lt;paramref name="maximumCount" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@,System.Security.AccessControl.SemaphoreSecurity)">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@,System.Security.AccessControl.SemaphoreSecurity)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is longer than 260 characters.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> 超过 260 个字符。</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@,System.Security.AccessControl.SemaphoreSecurity)">
          <source><ph id="ph1">&lt;paramref name="maximumCount" /&gt;</ph> is less than 1.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="maximumCount" /&gt;</ph> 小于 1。</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@,System.Security.AccessControl.SemaphoreSecurity)">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@,System.Security.AccessControl.SemaphoreSecurity)">
          <source><ph id="ph1">&lt;paramref name="initialCount" /&gt;</ph> is less than 0.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="initialCount" /&gt;</ph> 小于 0。</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@,System.Security.AccessControl.SemaphoreSecurity)">
          <source>The named semaphore exists and has access control security, and the user does not have <ph id="ph1">&lt;see cref="F:System.Security.AccessControl.SemaphoreRights.FullControl" /&gt;</ph>.</source>
          <target state="translated">命名信号量存在且具有访问控制安全性，用户不具有 <ph id="ph1">&lt;see cref="F:System.Security.AccessControl.SemaphoreRights.FullControl" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@,System.Security.AccessControl.SemaphoreSecurity)">
          <source>A Win32 error occurred.</source>
          <target state="translated">出现 Win32 错误。</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@,System.Security.AccessControl.SemaphoreSecurity)">
          <source>The named semaphore cannot be created, perhaps because a wait handle of a different type has the same name.</source>
          <target state="translated">无法创建命名信号量，可能是由于其他类型的等待句柄具有相同名称。</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@,System.Security.AccessControl.SemaphoreSecurity)">
          <source>for calling unmanaged code to create a named system semaphore.</source>
          <target state="translated">用于调用非托管的代码来创建已命名的系统信号量。</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@,System.Security.AccessControl.SemaphoreSecurity)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /&gt;</ph>.</source>
          <target state="translated">关联枚举：<ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@,System.Security.AccessControl.SemaphoreSecurity)">
          <source>Security action: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" /&gt;</ph>.</source>
          <target state="translated">安全操作： <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.GetAccessControl">
          <source>Gets the access control security for a named system semaphore.</source>
          <target state="translated">获取已命名的系统信号量的访问控制安全性。</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.GetAccessControl">
          <source>A <ph id="ph1">&lt;see cref="T:System.Security.AccessControl.SemaphoreSecurity" /&gt;</ph> object that represents the access control security for the named system semaphore.</source>
          <target state="translated">一个 <ph id="ph1">&lt;see cref="T:System.Security.AccessControl.SemaphoreSecurity" /&gt;</ph> 对象，表示已命名系统信号量的访问控制安全性。</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.GetAccessControl">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Semaphore.GetAccessControl%2A&gt;</ph> method uses the following combination of flags (combined using the bitwise OR operation) to search for permissions: <ph id="ph2">&lt;xref:System.Security.AccessControl.AccessControlSections.Access?displayProperty=nameWithType&gt;</ph>, <ph id="ph3">&lt;xref:System.Security.AccessControl.AccessControlSections.Owner?displayProperty=nameWithType&gt;</ph>, and <ph id="ph4">&lt;xref:System.Security.AccessControl.AccessControlSections.Group?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.Semaphore.GetAccessControl%2A&gt;</ph>方法使用以下标志 （使用按位或运算组合） 的组合来搜索权限： <ph id="ph2">&lt;xref:System.Security.AccessControl.AccessControlSections.Access?displayProperty=nameWithType&gt;</ph>， <ph id="ph3">&lt;xref:System.Security.AccessControl.AccessControlSections.Owner?displayProperty=nameWithType&gt;</ph>，和<ph id="ph4">&lt;xref:System.Security.AccessControl.AccessControlSections.Group?displayProperty=nameWithType&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.GetAccessControl">
          <source>The user must have <ph id="ph1">&lt;xref:System.Security.AccessControl.SemaphoreRights.ReadPermissions?displayProperty=nameWithType&gt;</ph> rights to call this method, and the semaphore must have been opened with <ph id="ph2">&lt;xref:System.Security.AccessControl.SemaphoreRights.ReadPermissions?displayProperty=nameWithType&gt;</ph> rights.</source>
          <target state="translated">用户必须具有<ph id="ph1">&lt;xref:System.Security.AccessControl.SemaphoreRights.ReadPermissions?displayProperty=nameWithType&gt;</ph>权限才能调用此方法，而且信号量必须使用打开<ph id="ph2">&lt;xref:System.Security.AccessControl.SemaphoreRights.ReadPermissions?displayProperty=nameWithType&gt;</ph>权限。</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.GetAccessControl">
          <source>On a local semaphore, access control security is irrelevant.</source>
          <target state="translated">在本地信号量，访问控制安全性是不相关。</target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.GetAccessControl">
          <source>If the <ph id="ph1">&lt;xref:System.Threading.Semaphore&gt;</ph> object does not represent a named system semaphore, this method returns a <ph id="ph2">&lt;xref:System.Security.AccessControl.SemaphoreSecurity&gt;</ph> object that grants all rights to any user.</source>
          <target state="translated">如果<ph id="ph1">&lt;xref:System.Threading.Semaphore&gt;</ph>对象不表示已命名的系统信号量，此方法返回<ph id="ph2">&lt;xref:System.Security.AccessControl.SemaphoreSecurity&gt;</ph>授予任何用户对所有权限的对象。</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.GetAccessControl">
          <source>The following code example demonstrates the cross-process behavior of a named semaphore with access control security.</source>
          <target state="translated">下面的代码示例演示具有访问控制安全性的跨进程行为的名称为信号量。</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.GetAccessControl">
          <source>The example uses the <ph id="ph1">&lt;xref:System.Threading.Semaphore.OpenExisting%28System.String%29&gt;</ph> method overload to test for the existence of a named semaphore.</source>
          <target state="translated">该示例使用<ph id="ph1">&lt;xref:System.Threading.Semaphore.OpenExisting%28System.String%29&gt;</ph>方法重载来测试是否存在名称为信号量。</target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.GetAccessControl">
          <source>If the semaphore does not exist, it is created with a maximum count of two and with access control security that denies the current user the right to use the semaphore, but grants the right to read and change permissions on the semaphore.</source>
          <target state="translated">如果不存在信号量，创建与最大计数为 2 和拒绝当前用户的权限使用信号量，但授予的权限读取和更改权限信号量的访问控制安全性。</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.GetAccessControl">
          <source>If you run the compiled example from two command windows, the second copy will throw an access violation exception on the call to the <ph id="ph1">&lt;xref:System.Threading.Semaphore.OpenExisting%28System.String%29&gt;</ph> method.</source>
          <target state="translated">如果从两个命令窗口中运行已编译的示例，第二个副本将在调用引发访问冲突异常<ph id="ph1">&lt;xref:System.Threading.Semaphore.OpenExisting%28System.String%29&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.GetAccessControl">
          <source>The exception is caught, and the example uses the <ph id="ph1">&lt;xref:System.Threading.Semaphore.OpenExisting%28System.String%2CSystem.Security.AccessControl.SemaphoreRights%29&gt;</ph> method overload to open the semaphore with the rights needed to read and change the permissions.</source>
          <target state="translated">捕获了异常，并且该示例使用<ph id="ph1">&lt;xref:System.Threading.Semaphore.OpenExisting%28System.String%2CSystem.Security.AccessControl.SemaphoreRights%29&gt;</ph>方法重载，以读取和更改的权限所需的权限打开信号量。</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.GetAccessControl">
          <source>The access control security for the system semaphore is obtained using the <ph id="ph1">&lt;xref:System.Threading.Semaphore.GetAccessControl%2A&gt;</ph> method.</source>
          <target state="translated">使用获取的系统信号量的访问控制安全性<ph id="ph1">&lt;xref:System.Threading.Semaphore.GetAccessControl%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.GetAccessControl">
          <source>After the permissions are changed, the semaphore is opened with the rights required to enter and release.</source>
          <target state="translated">更改权限后，输入并释放所需的权限打开信号量。</target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.GetAccessControl">
          <source>If you run the compiled example from a third command window, it runs using the new permissions.</source>
          <target state="translated">如果从第三个命令窗口中运行已编译的示例，它将运行使用新的权限。</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.GetAccessControl">
          <source>The current <ph id="ph1">&lt;see cref="T:System.Threading.Semaphore" /&gt;</ph> object represents a named system semaphore, and the user does not have <ph id="ph2">&lt;see cref="F:System.Security.AccessControl.SemaphoreRights.ReadPermissions" /&gt;</ph> rights.</source>
          <target state="translated">当前的 <ph id="ph1">&lt;see cref="T:System.Threading.Semaphore" /&gt;</ph> 对象表示已命名的系统信号灯，且用户不具备 <ph id="ph2">&lt;see cref="F:System.Security.AccessControl.SemaphoreRights.ReadPermissions" /&gt;</ph> 权限。</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.GetAccessControl">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.GetAccessControl">
          <source>The current <ph id="ph1">&lt;see cref="T:System.Threading.Semaphore" /&gt;</ph> object represents a named system semaphore and was not opened with <ph id="ph2">&lt;see cref="F:System.Security.AccessControl.SemaphoreRights.ReadPermissions" /&gt;</ph> rights.</source>
          <target state="translated">当前的 <ph id="ph1">&lt;see cref="T:System.Threading.Semaphore" /&gt;</ph> 对象表示已命名的系统信号灯，且 <ph id="ph2">&lt;see cref="F:System.Security.AccessControl.SemaphoreRights.ReadPermissions" /&gt;</ph> 权限不开放。</target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.GetAccessControl">
          <source>Not supported for Windows 98 or Windows Millennium Edition.</source>
          <target state="translated">不支持 Windows 98 或 Windows Millennium Edition。</target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve" uid="T:System.Threading.Semaphore">
          <source>Opens a specified named semaphore, if it already exists.</source>
          <target state="translated">打开指定名称为信号量（如果已经存在）。</target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.OpenExisting(System.String)">
          <source>The name of the system semaphore to open.</source>
          <target state="translated">要打开的系统信号量的名称。</target>       </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.OpenExisting(System.String)">
          <source>Opens the specified named semaphore, if it already exists.</source>
          <target state="translated">打开指定名称为信号量（如果已经存在）。</target>       </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.OpenExisting(System.String)">
          <source>An object that represents the named system semaphore.</source>
          <target state="translated">一个对象，表示已命名的系统信号量。</target>       </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.OpenExisting(System.String)">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Semaphore.OpenExisting%2A&gt;</ph> method tries to open the specified named semaphore.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.Semaphore.OpenExisting%2A&gt;</ph>方法尝试打开指定的命名信号量。</target>       </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.OpenExisting(System.String)">
          <source>If the system semaphore does not exist, this method throws an exception instead of creating the system semaphore.</source>
          <target state="translated">如果不存在的系统信号量，此方法将引发异常而不是创建的系统信号量。</target>       </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.OpenExisting(System.String)">
          <source>To create the system semaphore when it does not already exist, use one of the <ph id="ph1">&lt;xref:System.Threading.Semaphore.%23ctor%2A&gt;</ph> constructors that has a <ph id="ph2">`name`</ph> parameter.</source>
          <target state="translated">若要创建的系统信号量时不存在，请使用之一<ph id="ph1">&lt;xref:System.Threading.Semaphore.%23ctor%2A&gt;</ph>构造函数具有<ph id="ph2">`name`</ph>参数。</target>       </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.OpenExisting(System.String)">
          <source>Multiple calls to this method that use the same value for <ph id="ph1">`name`</ph> do not necessarily return the same <ph id="ph2">&lt;xref:System.Threading.Semaphore&gt;</ph> object, even though the objects that are returned represent the same named system semaphore.</source>
          <target state="translated">多次调用此方法使用相同的值的<ph id="ph1">`name`</ph>不一定返回相同<ph id="ph2">&lt;xref:System.Threading.Semaphore&gt;</ph>对象，即使返回表示的对象相同的命名系统信号量。</target>       </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.OpenExisting(System.String)">
          <source>This method overload is equivalent to calling the <ph id="ph1">&lt;xref:System.Threading.Semaphore.OpenExisting%2A&gt;</ph> method overload and specifying <ph id="ph2">&lt;xref:System.Security.AccessControl.SemaphoreRights.Synchronize?displayProperty=nameWithType&gt;</ph> and <ph id="ph3">&lt;xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType&gt;</ph> rights, combined by using the bitwise OR operation.</source>
          <target state="translated">此方法重载是等效于调用<ph id="ph1">&lt;xref:System.Threading.Semaphore.OpenExisting%2A&gt;</ph>方法重载并指定<ph id="ph2">&lt;xref:System.Security.AccessControl.SemaphoreRights.Synchronize?displayProperty=nameWithType&gt;</ph>和<ph id="ph3">&lt;xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType&gt;</ph>权限，使用按位或运算组合在一起。</target>       </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.OpenExisting(System.String)">
          <source>Specifying the <ph id="ph1">&lt;xref:System.Security.AccessControl.SemaphoreRights.Synchronize?displayProperty=nameWithType&gt;</ph> flag allows a thread to enter the semaphore, and specifying the <ph id="ph2">&lt;xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType&gt;</ph> flag allows a thread to call the <ph id="ph3">&lt;xref:System.Threading.Semaphore.Release%2A&gt;</ph> method.</source>
          <target state="translated">指定<ph id="ph1">&lt;xref:System.Security.AccessControl.SemaphoreRights.Synchronize?displayProperty=nameWithType&gt;</ph>标志将允许线程进入信号量，并指定<ph id="ph2">&lt;xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType&gt;</ph>标志将允许线程调用<ph id="ph3">&lt;xref:System.Threading.Semaphore.Release%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.OpenExisting(System.String)">
          <source>The following code example demonstrates the cross-process behavior of a named semaphore with access control security.</source>
          <target state="translated">下面的代码示例演示具有访问控制安全性的跨进程行为的名称为信号量。</target>       </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.OpenExisting(System.String)">
          <source>The example uses the <ph id="ph1">&lt;xref:System.Threading.Semaphore.OpenExisting%28System.String%29&gt;</ph> method overload to test for the existence of a named semaphore.</source>
          <target state="translated">该示例使用<ph id="ph1">&lt;xref:System.Threading.Semaphore.OpenExisting%28System.String%29&gt;</ph>方法重载来测试是否存在名称为信号量。</target>       </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.OpenExisting(System.String)">
          <source>If the semaphore does not exist, it is created with a maximum count of two and with access control security that denies the current user the right to use the semaphore, but which grants the right to read and change permissions on the semaphore.</source>
          <target state="translated">如果不存在信号量，创建与最大计数为 2 和访问控制安全性，拒绝当前用户的权限使用信号量，但该权限授予的权限读取和更改信号量的权限。</target>       </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.OpenExisting(System.String)">
          <source>If you run the compiled example from two command windows, the second copy will throw an access violation exception on the call to the <ph id="ph1">&lt;xref:System.Threading.Semaphore.OpenExisting%28System.String%29&gt;</ph> method overload.</source>
          <target state="translated">如果从两个命令窗口中运行已编译的示例，第二个副本将在调用引发访问冲突异常<ph id="ph1">&lt;xref:System.Threading.Semaphore.OpenExisting%28System.String%29&gt;</ph>方法重载。</target>       </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.OpenExisting(System.String)">
          <source>The exception is caught, and the example uses the <ph id="ph1">&lt;xref:System.Threading.Semaphore.OpenExisting%28System.String%2CSystem.Security.AccessControl.SemaphoreRights%29&gt;</ph> method overload to open the semaphore with the rights needed to read and change the permissions.</source>
          <target state="translated">捕获了异常，并且该示例使用<ph id="ph1">&lt;xref:System.Threading.Semaphore.OpenExisting%28System.String%2CSystem.Security.AccessControl.SemaphoreRights%29&gt;</ph>方法重载，以读取和更改的权限所需的权限打开信号量。</target>       </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.OpenExisting(System.String)">
          <source>After the permissions are changed, the semaphore is opened with the rights required to enter and release it.</source>
          <target state="translated">更改权限后，输入并释放它所需的权限打开信号量。</target>       </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.OpenExisting(System.String)">
          <source>If you run the compiled example from a third command window, it runs using the new permissions.</source>
          <target state="translated">如果从第三个命令窗口中运行已编译的示例，它将运行使用新的权限。</target>       </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.OpenExisting(System.String)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is an empty string.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> 是一个空字符串。</target>       </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.OpenExisting(System.String)">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.OpenExisting(System.String)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is longer than 260 characters.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> 超过 260 个字符。</target>       </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.OpenExisting(System.String)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> 为 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.OpenExisting(System.String)">
          <source>The named semaphore does not exist.</source>
          <target state="translated">命名的信号量不存在。</target>       </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.OpenExisting(System.String)">
          <source>A Win32 error occurred.</source>
          <target state="translated">出现 Win32 错误。</target>       </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.OpenExisting(System.String)">
          <source>The named semaphore exists, but the user does not have the security access required to use it.</source>
          <target state="translated">存在该命名信号量，但用户没有使用它时所需的安全访问权限。</target>       </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.OpenExisting(System.String)">
          <source>for calling unmanaged code to open a named system semaphore.</source>
          <target state="translated">用于调用非托管的代码，以打开一个已命名的系统信号量。</target>       </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.OpenExisting(System.String)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /&gt;</ph>.</source>
          <target state="translated">关联枚举：<ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.OpenExisting(System.String)">
          <source>Security action: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" /&gt;</ph>.</source>
          <target state="translated">安全操作： <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.OpenExisting(System.String,System.Security.AccessControl.SemaphoreRights)">
          <source>The name of the system semaphore to open.</source>
          <target state="translated">要打开的系统信号量的名称。</target>       </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.OpenExisting(System.String,System.Security.AccessControl.SemaphoreRights)">
          <source>A bitwise combination of the enumeration values that represent the desired security access.</source>
          <target state="translated">表示所需的安全访问权限的枚举值的按位组合。</target>       </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.OpenExisting(System.String,System.Security.AccessControl.SemaphoreRights)">
          <source>Opens the specified named semaphore, if it already exists, with the desired security access.</source>
          <target state="translated">用安全访问权限打开指定名称为信号量（如果已经存在）。</target>       </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.OpenExisting(System.String,System.Security.AccessControl.SemaphoreRights)">
          <source>An object that represents the named system semaphore.</source>
          <target state="translated">一个对象，表示已命名的系统信号量。</target>       </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.OpenExisting(System.String,System.Security.AccessControl.SemaphoreRights)">
          <source>The <ph id="ph1">`rights`</ph> parameter must include the <ph id="ph2">&lt;xref:System.Security.AccessControl.SemaphoreRights.Synchronize?displayProperty=nameWithType&gt;</ph> flag to allow threads to enter the semaphore, and the <ph id="ph3">&lt;xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType&gt;</ph> flag to allow threads to call the <ph id="ph4">&lt;xref:System.Threading.Semaphore.Release%2A&gt;</ph> method.</source>
          <target state="translated"><ph id="ph1">`rights`</ph>参数必须包含<ph id="ph2">&lt;xref:System.Security.AccessControl.SemaphoreRights.Synchronize?displayProperty=nameWithType&gt;</ph>标志以允许线程进入信号量，与<ph id="ph3">&lt;xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType&gt;</ph>标志以允许线程调用<ph id="ph4">&lt;xref:System.Threading.Semaphore.Release%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.OpenExisting(System.String,System.Security.AccessControl.SemaphoreRights)">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Semaphore.OpenExisting%2A&gt;</ph> method tries to open an existing named semaphore.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.Semaphore.OpenExisting%2A&gt;</ph>方法尝试打开现有的已命名信号量。</target>       </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.OpenExisting(System.String,System.Security.AccessControl.SemaphoreRights)">
          <source>If the system semaphore does not exist, this method throws an exception instead of creating the system semaphore.</source>
          <target state="translated">如果不存在的系统信号量，此方法将引发异常而不是创建的系统信号量。</target>       </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.OpenExisting(System.String,System.Security.AccessControl.SemaphoreRights)">
          <source>To create the system semaphore when it does not already exist, use one of the <ph id="ph1">&lt;xref:System.Threading.Semaphore.%23ctor%2A&gt;</ph> constructors that has a <ph id="ph2">`name`</ph> parameter.</source>
          <target state="translated">若要创建的系统信号量时不存在，请使用之一<ph id="ph1">&lt;xref:System.Threading.Semaphore.%23ctor%2A&gt;</ph>构造函数具有<ph id="ph2">`name`</ph>参数。</target>       </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.OpenExisting(System.String,System.Security.AccessControl.SemaphoreRights)">
          <source>Multiple calls to this method that use the same value for <ph id="ph1">`name`</ph> do not necessarily return the same <ph id="ph2">&lt;xref:System.Threading.Semaphore&gt;</ph> object, even though the objects that are returned represent the same named system semaphore.</source>
          <target state="translated">多次调用此方法使用相同的值的<ph id="ph1">`name`</ph>不一定返回相同<ph id="ph2">&lt;xref:System.Threading.Semaphore&gt;</ph>对象，即使返回表示的对象相同的命名系统信号量。</target>       </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.OpenExisting(System.String,System.Security.AccessControl.SemaphoreRights)">
          <source>The following code example demonstrates the cross-process behavior of a named semaphore with access control security.</source>
          <target state="translated">下面的代码示例演示具有访问控制安全性的跨进程行为的名称为信号量。</target>       </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.OpenExisting(System.String,System.Security.AccessControl.SemaphoreRights)">
          <source>The example uses the <ph id="ph1">&lt;xref:System.Threading.Semaphore.OpenExisting%28System.String%29&gt;</ph> method overload to test for the existence of a named semaphore.</source>
          <target state="translated">该示例使用<ph id="ph1">&lt;xref:System.Threading.Semaphore.OpenExisting%28System.String%29&gt;</ph>方法重载来测试是否存在名称为信号量。</target>       </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.OpenExisting(System.String,System.Security.AccessControl.SemaphoreRights)">
          <source>If the semaphore does not exist, it is created with a maximum count of two and with access control security that denies the current user the right to use the semaphore, but grants the right to read and change permissions on the semaphore.</source>
          <target state="translated">如果不存在信号量，创建与最大计数为 2 和拒绝当前用户的权限使用信号量，但授予的权限读取和更改权限信号量的访问控制安全性。</target>       </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.OpenExisting(System.String,System.Security.AccessControl.SemaphoreRights)">
          <source>If you run the compiled example from two command windows, the second copy will throw an access violation exception on the call to the <ph id="ph1">&lt;xref:System.Threading.Semaphore.OpenExisting%28System.String%29&gt;</ph> method.</source>
          <target state="translated">如果从两个命令窗口中运行已编译的示例，第二个副本将在调用引发访问冲突异常<ph id="ph1">&lt;xref:System.Threading.Semaphore.OpenExisting%28System.String%29&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.OpenExisting(System.String,System.Security.AccessControl.SemaphoreRights)">
          <source>The exception is caught, and the example uses the <ph id="ph1">&lt;xref:System.Threading.Semaphore.OpenExisting%28System.String%2CSystem.Security.AccessControl.SemaphoreRights%29&gt;</ph> method overload to open the semaphore with the rights needed to read and change the permissions.</source>
          <target state="translated">捕获了异常，并且该示例使用<ph id="ph1">&lt;xref:System.Threading.Semaphore.OpenExisting%28System.String%2CSystem.Security.AccessControl.SemaphoreRights%29&gt;</ph>方法重载，以读取和更改的权限所需的权限打开信号量。</target>       </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.OpenExisting(System.String,System.Security.AccessControl.SemaphoreRights)">
          <source>After the permissions are changed, the semaphore is opened with the rights required to enter and release it.</source>
          <target state="translated">更改权限后，输入并释放它所需的权限打开信号量。</target>       </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.OpenExisting(System.String,System.Security.AccessControl.SemaphoreRights)">
          <source>If you run the compiled example from a third command window, it runs using the new permissions.</source>
          <target state="translated">如果从第三个命令窗口中运行已编译的示例，它将运行使用新的权限。</target>       </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.OpenExisting(System.String,System.Security.AccessControl.SemaphoreRights)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is an empty string.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> 是一个空字符串。</target>       </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.OpenExisting(System.String,System.Security.AccessControl.SemaphoreRights)">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.OpenExisting(System.String,System.Security.AccessControl.SemaphoreRights)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is longer than 260 characters.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> 超过 260 个字符。</target>       </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.OpenExisting(System.String,System.Security.AccessControl.SemaphoreRights)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> 为 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.OpenExisting(System.String,System.Security.AccessControl.SemaphoreRights)">
          <source>The named semaphore does not exist.</source>
          <target state="translated">命名的信号量不存在。</target>       </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.OpenExisting(System.String,System.Security.AccessControl.SemaphoreRights)">
          <source>A Win32 error occurred.</source>
          <target state="translated">出现 Win32 错误。</target>       </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.OpenExisting(System.String,System.Security.AccessControl.SemaphoreRights)">
          <source>The named semaphore exists, but the user does not have the desired security access rights.</source>
          <target state="translated">已命名的信号量存在，但用户不具备所需的安全访问权限。</target>       </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.OpenExisting(System.String,System.Security.AccessControl.SemaphoreRights)">
          <source>for calling unmanaged code to create a named system semaphore.</source>
          <target state="translated">用于调用非托管的代码来创建已命名的系统信号量。</target>       </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.OpenExisting(System.String,System.Security.AccessControl.SemaphoreRights)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /&gt;</ph>.</source>
          <target state="translated">关联枚举：<ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.OpenExisting(System.String,System.Security.AccessControl.SemaphoreRights)">
          <source>Security action: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" /&gt;</ph>.</source>
          <target state="translated">安全操作： <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve" uid="T:System.Threading.Semaphore">
          <source>Exits the semaphore.</source>
          <target state="translated">退出信号量。</target>       </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.Release">
          <source>Exits the semaphore and returns the previous count.</source>
          <target state="translated">退出信号量并返回前一个计数。</target>       </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.Release">
          <source>The count on the semaphore before the <ph id="ph1">&lt;see cref="Overload:System.Threading.Semaphore.Release" /&gt;</ph> method was called.</source>
          <target state="translated">调用 <ph id="ph1">&lt;see cref="Overload:System.Threading.Semaphore.Release" /&gt;</ph> 方法前信号量的计数。</target>       </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.Release">
          <source>Threads typically use the <ph id="ph1">&lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;</ph> method to enter the semaphore, and they typically use this method overload to exit.</source>
          <target state="translated">线程通常使用<ph id="ph1">&lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;</ph>方法进入信号量，并且它们通常使用此方法重载退出。</target>       </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.Release">
          <source>If a <ph id="ph1">&lt;xref:System.Threading.SemaphoreFullException&gt;</ph> is thrown by the <ph id="ph2">&lt;xref:System.Threading.Semaphore.Release%2A&gt;</ph> method, it does not necessarily indicate a problem with the calling thread.</source>
          <target state="translated">如果<ph id="ph1">&lt;xref:System.Threading.SemaphoreFullException&gt;</ph>由引发<ph id="ph2">&lt;xref:System.Threading.Semaphore.Release%2A&gt;</ph>方法，它不一定表示调用线程问题。</target>       </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.Release">
          <source>A programming error in another thread might have caused that thread to exit the semaphore more times than it entered.</source>
          <target state="translated">另一个线程中的编程错误可能导致该线程退出详细的时间比输入信号量。</target>       </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.Release">
          <source>If the current <ph id="ph1">&lt;xref:System.Threading.Semaphore&gt;</ph> object represents a named system semaphore, the user must have <ph id="ph2">&lt;xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType&gt;</ph> rights and the semaphore must have been opened with <ph id="ph3">&lt;xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType&gt;</ph> rights.</source>
          <target state="translated">如果当前<ph id="ph1">&lt;xref:System.Threading.Semaphore&gt;</ph>对象表示已命名的系统信号量，则用户必须具有<ph id="ph2">&lt;xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType&gt;</ph>权限而且信号量必须打开与<ph id="ph3">&lt;xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType&gt;</ph>权限。</target>       </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.Release">
          <source>The following code example creates a semaphore with a maximum count of three and an initial count of zero.</source>
          <target state="translated">下面的代码示例创建与最大计数为三个和初始计数为零的信号量。</target>       </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.Release">
          <source>The example starts five threads, which block waiting for the semaphore.</source>
          <target state="translated">该示例启动五个线程，阻止等待信号量。</target>       </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.Release">
          <source>The main thread uses the <ph id="ph1">&lt;xref:System.Threading.Semaphore.Release%28System.Int32%29&gt;</ph> method overload to increase the semaphore count to its maximum, allowing three threads to enter the semaphore.</source>
          <target state="translated">主线程使用<ph id="ph1">&lt;xref:System.Threading.Semaphore.Release%28System.Int32%29&gt;</ph>方法重载来增加到其最大值，允许三个线程进入信号量的信号量计数。</target>       </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.Release">
          <source>Each thread uses the <ph id="ph1">&lt;xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType&gt;</ph> method to wait for one second, to simulate work, and then calls the <ph id="ph2">&lt;xref:System.Threading.Semaphore.Release&gt;</ph> method overload to release the semaphore.</source>
          <target state="translated">每个线程使用<ph id="ph1">&lt;xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType&gt;</ph>方法等待 1 秒，以模拟工作，然后调用<ph id="ph2">&lt;xref:System.Threading.Semaphore.Release&gt;</ph>方法重载来释放信号量。</target>       </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.Release">
          <source>Each time the semaphore is released, the previous semaphore count is displayed.</source>
          <target state="translated">释放信号量时，每个时间显示前一个信号量计数。</target>       </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.Release">
          <source>Console messages track semaphore use.</source>
          <target state="translated">控制台消息跟踪信号量的使用。</target>       </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.Release">
          <source>The simulated work interval is increased slightly for each thread, to make the output easier to read.</source>
          <target state="translated">模拟的工作间隔都稍有增加为每个线程，以使输出更易于阅读。</target>       </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.Release">
          <source>The semaphore count is already at the maximum value.</source>
          <target state="translated">信号量计数已是最大值。</target>       </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.Release">
          <source>A Win32 error occurred with a named semaphore.</source>
          <target state="translated">发生已命名信号量的 Win32 错误。</target>       </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.Release">
          <source>The current semaphore represents a named system semaphore, but the user does not have <ph id="ph1">&lt;see cref="F:System.Security.AccessControl.SemaphoreRights.Modify" /&gt;</ph>.</source>
          <target state="translated">当前信号量表示一个已命名的系统信号量，但用户不具备 <ph id="ph1">&lt;see cref="F:System.Security.AccessControl.SemaphoreRights.Modify" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.Release">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.Release">
          <source>The current semaphore represents a named system semaphore, but it was not opened with <ph id="ph1">&lt;see cref="F:System.Security.AccessControl.SemaphoreRights.Modify" /&gt;</ph>.</source>
          <target state="translated">当前信号量表示一个已命名的系统信号量，但它未用 <ph id="ph1">&lt;see cref="F:System.Security.AccessControl.SemaphoreRights.Modify" /&gt;</ph> 打开。</target>       </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.Release(System.Int32)">
          <source>The number of times to exit the semaphore.</source>
          <target state="translated">退出信号量的次数。</target>       </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.Release(System.Int32)">
          <source>Exits the semaphore a specified number of times and returns the previous count.</source>
          <target state="translated">以指定的次数退出信号量并返回前一个计数。</target>       </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.Release(System.Int32)">
          <source>The count on the semaphore before the <ph id="ph1">&lt;see cref="Overload:System.Threading.Semaphore.Release" /&gt;</ph> method was called.</source>
          <target state="translated">调用 <ph id="ph1">&lt;see cref="Overload:System.Threading.Semaphore.Release" /&gt;</ph> 方法前信号量的计数。</target>       </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.Release(System.Int32)">
          <source>If a thread has entered the semaphore multiple times, this method overload allows the entire semaphore count to be restored with one call.</source>
          <target state="translated">如果线程已进入信号量多次，此方法重载将允许要还原的一个调用的整个信号量计数。</target>       </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.Release(System.Int32)">
          <source>If a <ph id="ph1">&lt;xref:System.Threading.SemaphoreFullException&gt;</ph> is thrown by the <ph id="ph2">&lt;xref:System.Threading.Semaphore.Release%2A&gt;</ph> method, it does not necessarily indicate a problem with the calling thread.</source>
          <target state="translated">如果<ph id="ph1">&lt;xref:System.Threading.SemaphoreFullException&gt;</ph>由引发<ph id="ph2">&lt;xref:System.Threading.Semaphore.Release%2A&gt;</ph>方法，它不一定表示调用线程问题。</target>       </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.Release(System.Int32)">
          <source>A programming error in another thread might have caused that thread to exit the semaphore more times than it entered.</source>
          <target state="translated">另一个线程中的编程错误可能导致该线程退出详细的时间比输入信号量。</target>       </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.Release(System.Int32)">
          <source>If the current <ph id="ph1">&lt;xref:System.Threading.Semaphore&gt;</ph> object represents a named system semaphore, the user must have <ph id="ph2">&lt;xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType&gt;</ph> rights and the semaphore must have been opened with <ph id="ph3">&lt;xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType&gt;</ph> rights.</source>
          <target state="translated">如果当前<ph id="ph1">&lt;xref:System.Threading.Semaphore&gt;</ph>对象表示已命名的系统信号量，则用户必须具有<ph id="ph2">&lt;xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType&gt;</ph>权限而且信号量必须打开与<ph id="ph3">&lt;xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType&gt;</ph>权限。</target>       </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.Release(System.Int32)">
          <source>The following code example creates a semaphore with a maximum count of three and an initial count of zero.</source>
          <target state="translated">下面的代码示例创建与最大计数为三个和初始计数为零的信号量。</target>       </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.Release(System.Int32)">
          <source>The example starts five threads, which block waiting for the semaphore.</source>
          <target state="translated">该示例启动五个线程，阻止等待信号量。</target>       </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.Release(System.Int32)">
          <source>The main thread uses the <ph id="ph1">&lt;xref:System.Threading.Semaphore.Release%28System.Int32%29&gt;</ph> method overload to increase the semaphore count to its maximum, allowing three threads to enter the semaphore.</source>
          <target state="translated">主线程使用<ph id="ph1">&lt;xref:System.Threading.Semaphore.Release%28System.Int32%29&gt;</ph>方法重载来增加到其最大值，允许三个线程进入信号量的信号量计数。</target>       </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.Release(System.Int32)">
          <source>Each thread uses the <ph id="ph1">&lt;xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType&gt;</ph> method to wait for one second, to simulate work, and then calls the <ph id="ph2">&lt;xref:System.Threading.Semaphore.Release&gt;</ph> method overload to release the semaphore.</source>
          <target state="translated">每个线程使用<ph id="ph1">&lt;xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType&gt;</ph>方法等待 1 秒，以模拟工作，然后调用<ph id="ph2">&lt;xref:System.Threading.Semaphore.Release&gt;</ph>方法重载来释放信号量。</target>       </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.Release(System.Int32)">
          <source>Each time the semaphore is released, the previous semaphore count is displayed.</source>
          <target state="translated">释放信号量时，每个时间显示前一个信号量计数。</target>       </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.Release(System.Int32)">
          <source>Console messages track semaphore use.</source>
          <target state="translated">控制台消息跟踪信号量的使用。</target>       </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.Release(System.Int32)">
          <source>The simulated work interval is increased slightly for each thread, to make the output easier to read.</source>
          <target state="translated">模拟的工作间隔都稍有增加为每个线程，以使输出更易于阅读。</target>       </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.Release(System.Int32)">
          <source><ph id="ph1">&lt;paramref name="releaseCount" /&gt;</ph> is less than 1.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="releaseCount" /&gt;</ph> 小于 1。</target>       </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.Release(System.Int32)">
          <source>The semaphore count is already at the maximum value.</source>
          <target state="translated">信号量计数已是最大值。</target>       </trans-unit>
        <trans-unit id="361" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.Release(System.Int32)">
          <source>A Win32 error occurred with a named semaphore.</source>
          <target state="translated">发生已命名信号量的 Win32 错误。</target>       </trans-unit>
        <trans-unit id="362" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.Release(System.Int32)">
          <source>The current semaphore represents a named system semaphore, but the user does not have <ph id="ph1">&lt;see cref="F:System.Security.AccessControl.SemaphoreRights.Modify" /&gt;</ph> rights.</source>
          <target state="translated">当前信号量表示一个已命名的系统信号量，但用户不具备 <ph id="ph1">&lt;see cref="F:System.Security.AccessControl.SemaphoreRights.Modify" /&gt;</ph> 权限。</target>       </trans-unit>
        <trans-unit id="363" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.Release(System.Int32)">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="364" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.Release(System.Int32)">
          <source>The current semaphore represents a named system semaphore, but it was not opened with <ph id="ph1">&lt;see cref="F:System.Security.AccessControl.SemaphoreRights.Modify" /&gt;</ph> rights.</source>
          <target state="translated">当前信号量表示一个已命名的系统信号量，但它不是以 <ph id="ph1">&lt;see cref="F:System.Security.AccessControl.SemaphoreRights.Modify" /&gt;</ph> 权限打开的。</target>       </trans-unit>
        <trans-unit id="365" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.SetAccessControl(System.Security.AccessControl.SemaphoreSecurity)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Security.AccessControl.SemaphoreSecurity" /&gt;</ph> object that represents the access control security to be applied to the named system semaphore.</source>
          <target state="translated">一个 <ph id="ph1">&lt;see cref="T:System.Security.AccessControl.SemaphoreSecurity" /&gt;</ph> 对象，表示应用于已命名的系统信号量的访问控制安全性。</target>       </trans-unit>
        <trans-unit id="366" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.SetAccessControl(System.Security.AccessControl.SemaphoreSecurity)">
          <source>Sets the access control security for a named system semaphore.</source>
          <target state="translated">设置已命名的系统信号量的访问控制安全性。</target>       </trans-unit>
        <trans-unit id="367" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.SetAccessControl(System.Security.AccessControl.SemaphoreSecurity)">
          <source>You can set access control security only on <ph id="ph1">&lt;xref:System.Threading.Semaphore&gt;</ph> objects that represent named system semaphores.</source>
          <target state="translated">你可以仅在上设置访问控制安全性<ph id="ph1">&lt;xref:System.Threading.Semaphore&gt;</ph>表示已命名的系统信号量的对象。</target>       </trans-unit>
        <trans-unit id="368" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.SetAccessControl(System.Security.AccessControl.SemaphoreSecurity)">
          <source>The user must have <ph id="ph1">&lt;xref:System.Security.AccessControl.SemaphoreRights.ChangePermissions?displayProperty=nameWithType&gt;</ph> rights to call this method, and the semaphore must have been opened with <ph id="ph2">&lt;xref:System.Security.AccessControl.SemaphoreRights.ChangePermissions?displayProperty=nameWithType&gt;</ph> rights.</source>
          <target state="translated">用户必须具有<ph id="ph1">&lt;xref:System.Security.AccessControl.SemaphoreRights.ChangePermissions?displayProperty=nameWithType&gt;</ph>权限才能调用此方法，而且信号量必须使用打开<ph id="ph2">&lt;xref:System.Security.AccessControl.SemaphoreRights.ChangePermissions?displayProperty=nameWithType&gt;</ph>权限。</target>       </trans-unit>
        <trans-unit id="369" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.SetAccessControl(System.Security.AccessControl.SemaphoreSecurity)">
          <source>The following code example demonstrates the cross-process behavior of a named semaphore with access control security.</source>
          <target state="translated">下面的代码示例演示具有访问控制安全性的跨进程行为的名称为信号量。</target>       </trans-unit>
        <trans-unit id="370" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.SetAccessControl(System.Security.AccessControl.SemaphoreSecurity)">
          <source>The example uses the <ph id="ph1">&lt;xref:System.Threading.Semaphore.OpenExisting%28System.String%29&gt;</ph> method overload to test for the existence of a named semaphore.</source>
          <target state="translated">该示例使用<ph id="ph1">&lt;xref:System.Threading.Semaphore.OpenExisting%28System.String%29&gt;</ph>方法重载来测试是否存在名称为信号量。</target>       </trans-unit>
        <trans-unit id="371" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.SetAccessControl(System.Security.AccessControl.SemaphoreSecurity)">
          <source>If the semaphore does not exist, it is created with a maximum count of two and with access control security that denies the current user the right to use the semaphore but grants the right to read and change permissions on the semaphore.</source>
          <target state="translated">如果不存在信号量，创建与最大计数为 2 和将拒绝使用信号量的权限的当前用户，但授予的权限读取和更改权限信号量的访问控制安全性。</target>       </trans-unit>
        <trans-unit id="372" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.SetAccessControl(System.Security.AccessControl.SemaphoreSecurity)">
          <source>If you run the compiled example from two command windows, the second copy will throw an access violation exception on the call to the <ph id="ph1">&lt;xref:System.Threading.Semaphore.OpenExisting%28System.String%29&gt;</ph> method.</source>
          <target state="translated">如果从两个命令窗口中运行已编译的示例，第二个副本将在调用引发访问冲突异常<ph id="ph1">&lt;xref:System.Threading.Semaphore.OpenExisting%28System.String%29&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="373" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.SetAccessControl(System.Security.AccessControl.SemaphoreSecurity)">
          <source>The exception is caught, and the example uses the <ph id="ph1">&lt;xref:System.Threading.Semaphore.OpenExisting%28System.String%2CSystem.Security.AccessControl.SemaphoreRights%29&gt;</ph> method overload to open the semaphore with the rights needed to read and change the permissions.</source>
          <target state="translated">捕获了异常，并且该示例使用<ph id="ph1">&lt;xref:System.Threading.Semaphore.OpenExisting%28System.String%2CSystem.Security.AccessControl.SemaphoreRights%29&gt;</ph>方法重载，以读取和更改的权限所需的权限打开信号量。</target>       </trans-unit>
        <trans-unit id="374" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.SetAccessControl(System.Security.AccessControl.SemaphoreSecurity)">
          <source>After the permissions are changed, using the <ph id="ph1">&lt;xref:System.Threading.Semaphore.SetAccessControl%2A&gt;</ph> method, the semaphore is opened with the rights required to enter and release.</source>
          <target state="translated">更改的权限，使用后<ph id="ph1">&lt;xref:System.Threading.Semaphore.SetAccessControl%2A&gt;</ph>方法，信号量打开输入并释放所需的权限。</target>       </trans-unit>
        <trans-unit id="375" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.SetAccessControl(System.Security.AccessControl.SemaphoreSecurity)">
          <source>If you run the compiled example from a third command window, it runs using the new permissions.</source>
          <target state="translated">如果从第三个命令窗口中运行已编译的示例，它将运行使用新的权限。</target>       </trans-unit>
        <trans-unit id="376" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.SetAccessControl(System.Security.AccessControl.SemaphoreSecurity)">
          <source><ph id="ph1">&lt;paramref name="semaphoreSecurity" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="semaphoreSecurity" /&gt;</ph> 为 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="377" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.SetAccessControl(System.Security.AccessControl.SemaphoreSecurity)">
          <source>The user does not have <ph id="ph1">&lt;see cref="F:System.Security.AccessControl.SemaphoreRights.ChangePermissions" /&gt;</ph> rights.</source>
          <target state="translated">用户不具备 <ph id="ph1">&lt;see cref="F:System.Security.AccessControl.SemaphoreRights.ChangePermissions" /&gt;</ph> 权限。</target>       </trans-unit>
        <trans-unit id="378" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.SetAccessControl(System.Security.AccessControl.SemaphoreSecurity)">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="379" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.SetAccessControl(System.Security.AccessControl.SemaphoreSecurity)">
          <source>The semaphore was not opened with <ph id="ph1">&lt;see cref="F:System.Security.AccessControl.SemaphoreRights.ChangePermissions" /&gt;</ph> rights.</source>
          <target state="translated">信号量不是以 <ph id="ph1">&lt;see cref="F:System.Security.AccessControl.SemaphoreRights.ChangePermissions" /&gt;</ph> 权限打开的。</target>       </trans-unit>
        <trans-unit id="380" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.SetAccessControl(System.Security.AccessControl.SemaphoreSecurity)">
          <source>The current <ph id="ph1">&lt;see cref="T:System.Threading.Semaphore" /&gt;</ph> object does not represent a named system semaphore.</source>
          <target state="translated">当前 <ph id="ph1">&lt;see cref="T:System.Threading.Semaphore" /&gt;</ph> 对象不表示已命名的系统信号量。</target>       </trans-unit>
        <trans-unit id="381" translate="yes" xml:space="preserve" uid="T:System.Threading.Semaphore">
          <source>Opens a specified named semaphore, if it already exists, and returns a value that indicates whether the operation succeeded.</source>
          <target state="translated">打开指定名称为信号量（如果已经存在)，并返回指示操作是否成功的值。</target>       </trans-unit>
        <trans-unit id="382" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.TryOpenExisting(System.String,System.Threading.Semaphore@)">
          <source>The name of the system semaphore to open.</source>
          <target state="translated">要打开的系统信号量的名称。</target>       </trans-unit>
        <trans-unit id="383" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.TryOpenExisting(System.String,System.Threading.Semaphore@)">
          <source>When this method returns, contains a <ph id="ph1">&lt;see cref="T:System.Threading.Semaphore" /&gt;</ph> object that represents the named semaphore if the call succeeded, or <ph id="ph2">&lt;see langword="null" /&gt;</ph> if the call failed.</source>
          <target state="translated">当此方法返回时，如果调用成功，则包含表示命名信号的 <ph id="ph1">&lt;see cref="T:System.Threading.Semaphore" /&gt;</ph> 对象；否则为 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="384" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.TryOpenExisting(System.String,System.Threading.Semaphore@)">
          <source>This parameter is treated as uninitialized.</source>
          <target state="translated">该参数未经初始化即被处理。</target>       </trans-unit>
        <trans-unit id="385" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.TryOpenExisting(System.String,System.Threading.Semaphore@)">
          <source>Opens the specified named semaphore, if it already exists, and returns a value that indicates whether the operation succeeded.</source>
          <target state="translated">打开指定名称为信号量（如果已经存在），并返回指示操作是否成功的值。</target>       </trans-unit>
        <trans-unit id="386" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.TryOpenExisting(System.String,System.Threading.Semaphore@)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the named semaphore was opened successfully; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">如果命名信号量成功打开，则为 <ph id="ph1">&lt;see langword="true" /&gt;</ph>；否则为 <ph id="ph2">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="387" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.TryOpenExisting(System.String,System.Threading.Semaphore@)">
          <source>If the named semaphore does not exist, this method does not create it.</source>
          <target state="translated">如果不存在名称为信号量，此方法不创建它。</target>       </trans-unit>
        <trans-unit id="388" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.TryOpenExisting(System.String,System.Threading.Semaphore@)">
          <source>To create the system semaphore when it does not already exist, use one of the <ph id="ph1">&lt;xref:System.Threading.Semaphore.%23ctor%2A&gt;</ph> constructors that has a <ph id="ph2">`name`</ph> parameter.</source>
          <target state="translated">若要创建的系统信号量时不存在，请使用之一<ph id="ph1">&lt;xref:System.Threading.Semaphore.%23ctor%2A&gt;</ph>构造函数具有<ph id="ph2">`name`</ph>参数。</target>       </trans-unit>
        <trans-unit id="389" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.TryOpenExisting(System.String,System.Threading.Semaphore@)">
          <source>If you are uncertain whether a named semaphore exists, use this method overload instead of the <ph id="ph1">&lt;xref:System.Threading.Semaphore.OpenExisting%28System.String%29&gt;</ph> method overload, which throws an exception if the semaphore does not exist.</source>
          <target state="translated">如果你不确定是否存在名称为信号量，请使用而不是此方法重载<ph id="ph1">&lt;xref:System.Threading.Semaphore.OpenExisting%28System.String%29&gt;</ph>方法重载，信号量不存在时引发异常。</target>       </trans-unit>
        <trans-unit id="390" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.TryOpenExisting(System.String,System.Threading.Semaphore@)">
          <source>This method overload is equivalent to calling the <ph id="ph1">&lt;xref:System.Threading.Semaphore.TryOpenExisting%2A&gt;</ph> method overload and specifying <ph id="ph2">&lt;xref:System.Security.AccessControl.SemaphoreRights.Synchronize?displayProperty=nameWithType&gt;</ph> and <ph id="ph3">&lt;xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType&gt;</ph> rights, combined by using the bitwise OR operation.</source>
          <target state="translated">此方法重载是等效于调用<ph id="ph1">&lt;xref:System.Threading.Semaphore.TryOpenExisting%2A&gt;</ph>方法重载并指定<ph id="ph2">&lt;xref:System.Security.AccessControl.SemaphoreRights.Synchronize?displayProperty=nameWithType&gt;</ph>和<ph id="ph3">&lt;xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType&gt;</ph>权限，使用按位或运算组合在一起。</target>       </trans-unit>
        <trans-unit id="391" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.TryOpenExisting(System.String,System.Threading.Semaphore@)">
          <source>Specifying the <ph id="ph1">&lt;xref:System.Security.AccessControl.SemaphoreRights.Synchronize?displayProperty=nameWithType&gt;</ph> flag allows a thread to enter the semaphore, and specifying the   <ph id="ph2">&lt;xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType&gt;</ph> flag allows a thread to call the <ph id="ph3">&lt;xref:System.Threading.Semaphore.Release%2A&gt;</ph> method.</source>
          <target state="translated">指定<ph id="ph1">&lt;xref:System.Security.AccessControl.SemaphoreRights.Synchronize?displayProperty=nameWithType&gt;</ph>标志将允许线程进入信号量，并指定<ph id="ph2">&lt;xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType&gt;</ph>标志将允许线程调用<ph id="ph3">&lt;xref:System.Threading.Semaphore.Release%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="392" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.TryOpenExisting(System.String,System.Threading.Semaphore@)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is an empty string.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> 是一个空字符串。</target>       </trans-unit>
        <trans-unit id="393" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.TryOpenExisting(System.String,System.Threading.Semaphore@)">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="394" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.TryOpenExisting(System.String,System.Threading.Semaphore@)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is longer than 260 characters.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> 超过 260 个字符。</target>       </trans-unit>
        <trans-unit id="395" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.TryOpenExisting(System.String,System.Threading.Semaphore@)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> 为 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="396" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.TryOpenExisting(System.String,System.Threading.Semaphore@)">
          <source>A Win32 error occurred.</source>
          <target state="translated">出现 Win32 错误。</target>       </trans-unit>
        <trans-unit id="397" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.TryOpenExisting(System.String,System.Threading.Semaphore@)">
          <source>The named semaphore exists, but the user does not have the security access required to use it.</source>
          <target state="translated">存在该命名信号量，但用户没有使用它时所需的安全访问权限。</target>       </trans-unit>
        <trans-unit id="398" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.TryOpenExisting(System.String,System.Security.AccessControl.SemaphoreRights,System.Threading.Semaphore@)">
          <source>The name of the system semaphore to open.</source>
          <target state="translated">要打开的系统信号量的名称。</target>       </trans-unit>
        <trans-unit id="399" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.TryOpenExisting(System.String,System.Security.AccessControl.SemaphoreRights,System.Threading.Semaphore@)">
          <source>A bitwise combination of the enumeration values that represent the desired security access.</source>
          <target state="translated">表示所需的安全访问权限的枚举值的按位组合。</target>       </trans-unit>
        <trans-unit id="400" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.TryOpenExisting(System.String,System.Security.AccessControl.SemaphoreRights,System.Threading.Semaphore@)">
          <source>When this method returns, contains a <ph id="ph1">&lt;see cref="T:System.Threading.Semaphore" /&gt;</ph> object that represents the named semaphore if the call succeeded, or <ph id="ph2">&lt;see langword="null" /&gt;</ph> if the call failed.</source>
          <target state="translated">当此方法返回时，如果调用成功，则包含表示命名信号的 <ph id="ph1">&lt;see cref="T:System.Threading.Semaphore" /&gt;</ph> 对象；否则为 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="401" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.TryOpenExisting(System.String,System.Security.AccessControl.SemaphoreRights,System.Threading.Semaphore@)">
          <source>This parameter is treated as uninitialized.</source>
          <target state="translated">该参数未经初始化即被处理。</target>       </trans-unit>
        <trans-unit id="402" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.TryOpenExisting(System.String,System.Security.AccessControl.SemaphoreRights,System.Threading.Semaphore@)">
          <source>Opens the specified named semaphore, if it already exists, with the desired security access, and returns a value that indicates whether the operation succeeded.</source>
          <target state="translated">用安全访问权限打开指定名称为信号量（如果已经存在），并返回指示操作是否成功的值。</target>       </trans-unit>
        <trans-unit id="403" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.TryOpenExisting(System.String,System.Security.AccessControl.SemaphoreRights,System.Threading.Semaphore@)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the named semaphore was opened successfully; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">如果命名信号量成功打开，则为 <ph id="ph1">&lt;see langword="true" /&gt;</ph>；否则为 <ph id="ph2">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="404" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.TryOpenExisting(System.String,System.Security.AccessControl.SemaphoreRights,System.Threading.Semaphore@)">
          <source>If the named semaphore does not exist, this method does not create it.</source>
          <target state="translated">如果不存在名称为信号量，此方法不创建它。</target>       </trans-unit>
        <trans-unit id="405" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.TryOpenExisting(System.String,System.Security.AccessControl.SemaphoreRights,System.Threading.Semaphore@)">
          <source>To create the system semaphore when it does not already exist, use one of the <ph id="ph1">&lt;xref:System.Threading.Semaphore.%23ctor%2A&gt;</ph> constructors that has a <ph id="ph2">`name`</ph> parameter.</source>
          <target state="translated">若要创建的系统信号量时不存在，请使用之一<ph id="ph1">&lt;xref:System.Threading.Semaphore.%23ctor%2A&gt;</ph>构造函数具有<ph id="ph2">`name`</ph>参数。</target>       </trans-unit>
        <trans-unit id="406" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.TryOpenExisting(System.String,System.Security.AccessControl.SemaphoreRights,System.Threading.Semaphore@)">
          <source>If you are uncertain whether a named semaphore exists, use this method overload instead of the <ph id="ph1">&lt;xref:System.Threading.Semaphore.OpenExisting%28System.String%2CSystem.Security.AccessControl.SemaphoreRights%29&gt;</ph> method overload, which throws an exception if the semaphore does not exist.</source>
          <target state="translated">如果你不确定是否存在名称为信号量，请使用而不是此方法重载<ph id="ph1">&lt;xref:System.Threading.Semaphore.OpenExisting%28System.String%2CSystem.Security.AccessControl.SemaphoreRights%29&gt;</ph>方法重载，信号量不存在时引发异常。</target>       </trans-unit>
        <trans-unit id="407" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.TryOpenExisting(System.String,System.Security.AccessControl.SemaphoreRights,System.Threading.Semaphore@)">
          <source>The <ph id="ph1">`rights`</ph> parameter must include the <ph id="ph2">&lt;xref:System.Security.AccessControl.SemaphoreRights.Synchronize?displayProperty=nameWithType&gt;</ph> flag to allow threads to enter the semaphore, and the <ph id="ph3">&lt;xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType&gt;</ph> flag to allow threads to call the <ph id="ph4">&lt;xref:System.Threading.Semaphore.Release%2A&gt;</ph> method.</source>
          <target state="translated"><ph id="ph1">`rights`</ph>参数必须包含<ph id="ph2">&lt;xref:System.Security.AccessControl.SemaphoreRights.Synchronize?displayProperty=nameWithType&gt;</ph>标志以允许线程进入信号量，与<ph id="ph3">&lt;xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType&gt;</ph>标志以允许线程调用<ph id="ph4">&lt;xref:System.Threading.Semaphore.Release%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="408" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.TryOpenExisting(System.String,System.Security.AccessControl.SemaphoreRights,System.Threading.Semaphore@)">
          <source>Multiple calls to this method that use the same value for <ph id="ph1">`name`</ph> do not necessarily return the same <ph id="ph2">&lt;xref:System.Threading.Semaphore&gt;</ph> object, even though the objects that are returned represent the same named system semaphore.</source>
          <target state="translated">多次调用此方法使用相同的值的<ph id="ph1">`name`</ph>不一定返回相同<ph id="ph2">&lt;xref:System.Threading.Semaphore&gt;</ph>对象，即使返回表示的对象相同的命名系统信号量。</target>       </trans-unit>
        <trans-unit id="409" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.TryOpenExisting(System.String,System.Security.AccessControl.SemaphoreRights,System.Threading.Semaphore@)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is an empty string.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> 是一个空字符串。</target>       </trans-unit>
        <trans-unit id="410" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.TryOpenExisting(System.String,System.Security.AccessControl.SemaphoreRights,System.Threading.Semaphore@)">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="411" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.TryOpenExisting(System.String,System.Security.AccessControl.SemaphoreRights,System.Threading.Semaphore@)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is longer than 260 characters.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> 超过 260 个字符。</target>       </trans-unit>
        <trans-unit id="412" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.TryOpenExisting(System.String,System.Security.AccessControl.SemaphoreRights,System.Threading.Semaphore@)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> 为 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="413" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.TryOpenExisting(System.String,System.Security.AccessControl.SemaphoreRights,System.Threading.Semaphore@)">
          <source>A Win32 error occurred.</source>
          <target state="translated">出现 Win32 错误。</target>       </trans-unit>
        <trans-unit id="414" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.TryOpenExisting(System.String,System.Security.AccessControl.SemaphoreRights,System.Threading.Semaphore@)">
          <source>The named semaphore exists, but the user does not have the security access required to use it.</source>
          <target state="translated">存在该命名信号量，但用户没有使用它时所需的安全访问权限。</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>