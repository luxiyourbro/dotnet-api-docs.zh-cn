<Type Name="ThreadPool" FullName="System.Threading.ThreadPool">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="7617592e89d13d04e8d498e0f56a8aa9306b3a56" />
    <Meta Name="ms.sourcegitcommit" Value="9e06b87bcfa4347dbbaaa4b3cc36b43b93b5badb" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-CN" />
    <Meta Name="ms.lasthandoff" Value="11/20/2018" />
    <Meta Name="ms.locfileid" Value="52215674" />
  </Metadata>
  <TypeSignature Language="C#" Value="public static class ThreadPool" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit ThreadPool extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Threading.ThreadPool" />
  <TypeSignature Language="VB.NET" Value="Public Class ThreadPool" />
  <TypeSignature Language="C++ CLI" Value="public ref class ThreadPool abstract sealed" />
  <TypeSignature Language="F#" Value="type ThreadPool = class" />
  <AssemblyInfo>
    <AssemblyName>System.Threading.ThreadPool</AssemblyName>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>提供一个线程池，该线程池可用于执行任务、发送工作项、处理异步 I/O、代表其他线程等待以及处理计时器。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 许多应用程序创建大量花费的时间处于睡眠状态，等待要发生的事件的线程。 其他线程可能会进入休眠状态，只是为了被唤醒，定期轮询更改或更新的状态信息。 线程池，可通过提供应用程序提供的由系统管理的工作线程池来更有效地使用线程。 使用线程池线程的操作的示例包括：  
  
-   当您创建<xref:System.Threading.Tasks.Task>或<xref:System.Threading.Tasks.Task%601>对象来计划任务在线程池线程上运行的默认情况下以异步方式执行某项任务。  
  
-   异步计时器使用线程池。 线程池线程执行从回调<xref:System.Threading.Timer?displayProperty=nameWithType>类，并从引发事件<xref:System.Timers.Timer?displayProperty=nameWithType>类。  
  
-   当使用已注册的等待句柄时，系统线程监视等待句柄的状态。 等待操作完成后，从线程池工作线程将执行相应的回调函数。  
  
-   当您调用<xref:System.Threading.ThreadPool.QueueUserWorkItem%2A>方法进行排队以在线程池线程上执行的方法。 为此，可将该方法传递<xref:System.Threading.WaitCallback>委托。   委托的签名  
  
    ```csharp  
    void WaitCallback(Object state)  
    ```  
  
    ```vb  
    Sub WaitCallback(state As Object)  
    ```  
  
     其中`state`是一个对象，包含使用委托的数据。 实际的数据可以通过调用传递给委托<xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%2CSystem.Object%29>方法。  
  
> [!NOTE]
>  在托管的线程池线程是后台线程。 也就是说，其<xref:System.Threading.Thread.IsBackground%2A>属性是`true`。 这意味着，<xref:System.Threading.ThreadPool>线程不会对所有前台线程均已都退出后运行的应用程序。  
  
> [!IMPORTANT]
>  如果线程池重用某个线程，它不会清除线程本地存储区中或使用标记的字段中的数据<xref:System.ThreadStaticAttribute>属性。 因此，使用标记的方法时检查线程本地存储区或字段的<xref:System.ThreadStaticAttribute>属性，它找到的值可能会保留从线程池线程更早版本使用。  
  
 您还可以排队到线程池等待操作不相关的工作项。 若要请求工作项通过在线程池中的线程处理，请调用<xref:System.Threading.ThreadPool.QueueUserWorkItem%2A>方法。 此方法将对方法或将由所选从线程池线程调用的委托的引用作为参数。 没有方法来取消后已排队的工作项。  
  
 计时器队列中的计时器和已注册的等待操作也使用线程池。 它们的回调函数将排队到线程池。  
  
 没有一个线程池，每个进程。 从 [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)] 开始，进程的线程池的默认大小取决于若干因素，例如虚拟地址空间的大小。 进程可以调用 <xref:System.Threading.ThreadPool.GetMaxThreads%2A> 方法，以确定线程数。 可以使用更改线程池中的线程数<xref:System.Threading.ThreadPool.SetMaxThreads%2A>方法。 每个线程使用的默认堆栈大小，并运行默认的优先级。  
  
> [!NOTE]
>  承载.NET Framework 的非托管的代码可以通过更改线程池的大小`CorSetMaxThreads`mscoree.h 文件中定义的函数。  
  
 线程池按需提供新的工作线程或 I/O 完成线程直到它达到每个类别的最小值。 当达到最小值时，线程池可以创建该类别中的其他线程或等待，直到一些任务完成。 从 [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] 开始，线程池创建和销毁工作线程以优化吞吐量，吞吐量被定义为每个单位时间完成的任务数。 线程过少可能无法实现可用资源的最优利用，而线程过多则可能增加资源争用。  
  
> [!NOTE]
>  需求较低时，线程池线程的实际数量可以低于最小值。  
  
 可以使用 <xref:System.Threading.ThreadPool.GetMinThreads%2A> 方法来获取这些最小值。  
  
> [!CAUTION]
>  可以使用<xref:System.Threading.ThreadPool.SetMinThreads%2A>方法来增加最小线程数。 但是，不必要地增加这些值可能导致性能问题。 如果在同一时间开始太多的任务，则所有任务均可能会很慢。 大多数情况下，使用自己的分配线程算法，线程池将更好地执行任务。  
  
   
  
## Examples  
 在以下示例中，主应用程序线程方法排入队列名为`ThreadProc`休眠一秒，然后退出在线程池线程上执行。 `ThreadProc`方法只是显示一条消息。  
  
 [!code-cpp[System.Threading.ThreadPool QueueUserWorkItem0#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem0/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ThreadPool QueueUserWorkItem0#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem0/CS/source.cs#1)]
 [!code-vb[System.Threading.ThreadPool QueueUserWorkItem0#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem0/VB/source.vb#1)]  
  
 如果注释掉对的调用<xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType>方法中，主线程退出之前方法在线程池线程上运行。  线程池使用后台线程，不保留应用程序的运行的所有前台线程已都终止。  （这是一个争用条件的简单示例。）  
  
 ]]></format>
    </remarks>
    <threadsafe>此类型是线程安全的。</threadsafe>
    <related type="Article" href="~/docs/standard/threading/threads-and-threading.md">线程与线程处理</related>
    <related type="Article" href="~/docs/standard/threading/the-managed-thread-pool.md">托管的线程池</related>
  </Docs>
  <Members>
    <MemberGroup MemberName="BindHandle">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>将操作系统句柄绑定到 <see cref="T:System.Threading.ThreadPool" />。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BindHandle">
      <MemberSignature Language="C#" Value="public static bool BindHandle (IntPtr osHandle);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool BindHandle(native int osHandle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.BindHandle(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function BindHandle (osHandle As IntPtr) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool BindHandle(IntPtr osHandle);" />
      <MemberSignature Language="F#" Value="static member BindHandle : nativeint -&gt; bool" Usage="System.Threading.ThreadPool.BindHandle osHandle" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("ThreadPool.BindHandle(IntPtr) has been deprecated.  Please use ThreadPool.BindHandle(SafeHandle) instead.", false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="osHandle" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="osHandle">持有句柄的 <see cref="T:System.IntPtr" />。 在非托管端必须为重叠 I/O 打开该句柄。</param>
        <summary>将操作系统句柄绑定到 <see cref="T:System.Threading.ThreadPool" />。</summary>
        <returns>如果绑定了句柄，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Security.SecurityException">调用方没有所要求的权限。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">表示调用非托管的代码的能力。 关联枚举：<see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />。</permission>
      </Docs>
    </Member>
    <Member MemberName="BindHandle">
      <MemberSignature Language="C#" Value="public static bool BindHandle (System.Runtime.InteropServices.SafeHandle osHandle);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool BindHandle(class System.Runtime.InteropServices.SafeHandle osHandle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.BindHandle(System.Runtime.InteropServices.SafeHandle)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function BindHandle (osHandle As SafeHandle) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool BindHandle(System::Runtime::InteropServices::SafeHandle ^ osHandle);" />
      <MemberSignature Language="F#" Value="static member BindHandle : System.Runtime.InteropServices.SafeHandle -&gt; bool" Usage="System.Threading.ThreadPool.BindHandle osHandle" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="osHandle" Type="System.Runtime.InteropServices.SafeHandle" />
      </Parameters>
      <Docs>
        <param name="osHandle">保存操作系统句柄的 <see cref="T:System.Runtime.InteropServices.SafeHandle" />。 在非托管端必须为重叠 I/O 打开该句柄。</param>
        <summary>将操作系统句柄绑定到 <see cref="T:System.Threading.ThreadPool" />。</summary>
        <returns>如果绑定了句柄，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `osHandle`参数应<xref:Microsoft.Win32.SafeHandles.SafeFileHandle>，又派生自抽象<xref:System.Runtime.InteropServices.SafeHandle>类。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="osHandle" /> 为 <see langword="null" />。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">表示调用非托管的代码的能力。 关联枚举：<see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />。</permission>
      </Docs>
    </Member>
    <Member MemberName="GetAvailableThreads">
      <MemberSignature Language="C#" Value="public static void GetAvailableThreads (out int workerThreads, out int completionPortThreads);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void GetAvailableThreads([out] int32&amp; workerThreads, [out] int32&amp; completionPortThreads) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.GetAvailableThreads(System.Int32@,System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub GetAvailableThreads (ByRef workerThreads As Integer, ByRef completionPortThreads As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void GetAvailableThreads([Runtime::InteropServices::Out] int % workerThreads, [Runtime::InteropServices::Out] int % completionPortThreads);" />
      <MemberSignature Language="F#" Value="static member GetAvailableThreads :  *  -&gt; unit" Usage="System.Threading.ThreadPool.GetAvailableThreads (workerThreads, completionPortThreads)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="workerThreads" Type="System.Int32" RefType="out" />
        <Parameter Name="completionPortThreads" Type="System.Int32" RefType="out" />
      </Parameters>
      <Docs>
        <param name="workerThreads">可用辅助线程的数目。</param>
        <param name="completionPortThreads">可用异步 I/O 线程的数目。</param>
        <summary>检索由 <see cref="M:System.Threading.ThreadPool.GetMaxThreads(System.Int32@,System.Int32@)" /> 方法返回的最大线程池线程数和当前活动线程数之间的差值。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当<xref:System.Threading.ThreadPool.GetAvailableThreads%2A>返回指定的变量`workerThreads`包含额外的工作线程可启动和指定的变量的数量`completionPortThreads`包含可以是其他异步 I/O 线程数已启动。  
  
 如果没有可用的线程，其他线程池请求保持排队状态，直到线程池线程变得可用。  
  
   
  
## Examples  
 下面的示例的简单应用程序启动时显示工作线程数和可用的 I/O 线程的数。  
  
 [!code-csharp[System.Threading.ThreadPool.GetAvailableThreads#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetAvailableThreads/CS/Example2.cs#2)]
 [!code-vb[System.Threading.ThreadPool.GetAvailableThreads#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetAvailableThreads/VB/Example2.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Threading.ThreadPool.SetMinThreads(System.Int32,System.Int32)" />
        <altmember cref="M:System.Threading.ThreadPool.GetMinThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.GetMaxThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.SetMaxThreads(System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetMaxThreads">
      <MemberSignature Language="C#" Value="public static void GetMaxThreads (out int workerThreads, out int completionPortThreads);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void GetMaxThreads([out] int32&amp; workerThreads, [out] int32&amp; completionPortThreads) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.GetMaxThreads(System.Int32@,System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub GetMaxThreads (ByRef workerThreads As Integer, ByRef completionPortThreads As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void GetMaxThreads([Runtime::InteropServices::Out] int % workerThreads, [Runtime::InteropServices::Out] int % completionPortThreads);" />
      <MemberSignature Language="F#" Value="static member GetMaxThreads :  *  -&gt; unit" Usage="System.Threading.ThreadPool.GetMaxThreads (workerThreads, completionPortThreads)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="workerThreads" Type="System.Int32" RefType="out" />
        <Parameter Name="completionPortThreads" Type="System.Int32" RefType="out" />
      </Parameters>
      <Docs>
        <param name="workerThreads">线程池中辅助线程的最大数目。</param>
        <param name="completionPortThreads">线程池中异步 I/O 线程的最大数目。</param>
        <summary>检索可以同时处于活动状态的线程池请求的数目。 所有大于此数目的请求将保持排队状态，直到线程池线程变为可用。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当<xref:System.Threading.ThreadPool.GetMaxThreads%2A>返回指定的变量`workerThreads`包含允许在线程池中的工作线程和指定的变量的最大数目`completionPortThreads`包含异步 I/O 线程中允许的最大数目线程池。  
  
 可以使用<xref:System.Threading.ThreadPool.GetAvailableThreads%2A>方法来确定在任何给定时间的实际线程池中的线程数。  
  
 可以使用<xref:System.Threading.ThreadPool.SetMaxThreads%2A>设置线程池中的工作线程和异步 I/O 线程的最大数目。  
  
 您可以尽可能的系统内存允许线程池的请求进行排队。 如果有多个请求线程池线程数多于，其他请求保持排队状态，直到线程池线程变得可用。  
  
   
  
## Examples  
 下面的代码示例演示如何检索最大和可用的线程池中的线程数的计数。 工作项进行排队，使用`FileStream`将以异步方式写入两个文件。 回叫方法超时重叠。 工作线程处理的工作项，并根据速度和的计算机上的处理器数，一个或两个完成端口线程处理写入操作。  
  
 [!code-cpp[System.Threading.ThreadPool.GetAvailableThreads#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetAvailableThreads/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ThreadPool.GetAvailableThreads#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetAvailableThreads/CS/source.cs#1)]
 [!code-vb[System.Threading.ThreadPool.GetAvailableThreads#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetAvailableThreads/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Threading.ThreadPool.SetMinThreads(System.Int32,System.Int32)" />
        <altmember cref="M:System.Threading.ThreadPool.GetMinThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.GetAvailableThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.SetMaxThreads(System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetMinThreads">
      <MemberSignature Language="C#" Value="public static void GetMinThreads (out int workerThreads, out int completionPortThreads);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void GetMinThreads([out] int32&amp; workerThreads, [out] int32&amp; completionPortThreads) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.GetMinThreads(System.Int32@,System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub GetMinThreads (ByRef workerThreads As Integer, ByRef completionPortThreads As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void GetMinThreads([Runtime::InteropServices::Out] int % workerThreads, [Runtime::InteropServices::Out] int % completionPortThreads);" />
      <MemberSignature Language="F#" Value="static member GetMinThreads :  *  -&gt; unit" Usage="System.Threading.ThreadPool.GetMinThreads (workerThreads, completionPortThreads)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="workerThreads" Type="System.Int32" RefType="out" />
        <Parameter Name="completionPortThreads" Type="System.Int32" RefType="out" />
      </Parameters>
      <Docs>
        <param name="workerThreads">当此方法返回时，将包含线程池根据需要创建的最少数量的辅助线程。</param>
        <param name="completionPortThreads">当此方法返回时，将包含线程池根据需要创建的最少数量的异步 I/O 线程。</param>
        <summary>发出新的请求时，在切换到管理线程创建和销毁的算法之前检索线程池按需创建的线程的最小数量。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 线程池按需提供新的工作线程或 I/O 完成线程直到它达到每个类别的最小值。 默认情况下，最小线程数设置为在系统上的处理器数。 当达到最小值时，线程池可以创建该类别中的其他线程或等待，直到一些任务完成。 从[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]，线程池创建和销毁线程以优化吞吐量，该常数定义为每个单位的时间完成的任务数。 线程过少可能无法实现可用资源的最优利用，而线程过多则可能增加资源争用。  
  
> [!NOTE]
>  需求较低时，线程池线程的实际数量可以低于最小值。  
  
   
  
## Examples  
 下面的示例将最小工作线程数设置为 4，并保留的最小异步 I/O 完成线程数的原始值。  
  
 [!code-cpp[System.Threading.ThreadPool.GetSetMinThreads#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetSetMinThreads/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ThreadPool.GetSetMinThreads#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetSetMinThreads/CS/source.cs#1)]
 [!code-vb[System.Threading.ThreadPool.GetSetMinThreads#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetSetMinThreads/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Threading.ThreadPool.SetMinThreads(System.Int32,System.Int32)" />
        <altmember cref="M:System.Threading.ThreadPool.GetMaxThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.GetAvailableThreads(System.Int32@,System.Int32@)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="QueueUserWorkItem">
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>将方法排入队列以便执行。 此方法在有线程池线程变得可用时执行。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="QueueUserWorkItem">
      <MemberSignature Language="C#" Value="public static bool QueueUserWorkItem (System.Threading.WaitCallback callBack);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool QueueUserWorkItem(class System.Threading.WaitCallback callBack) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.QueueUserWorkItem(System.Threading.WaitCallback)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function QueueUserWorkItem (callBack As WaitCallback) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool QueueUserWorkItem(System::Threading::WaitCallback ^ callBack);" />
      <MemberSignature Language="F#" Value="static member QueueUserWorkItem : System.Threading.WaitCallback -&gt; bool" Usage="System.Threading.ThreadPool.QueueUserWorkItem callBack" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callBack" Type="System.Threading.WaitCallback" />
      </Parameters>
      <Docs>
        <param name="callBack">一个 <see cref="T:System.Threading.WaitCallback" />，表示要执行的方法。</param>
        <summary>将方法排入队列以便执行。 此方法在有线程池线程变得可用时执行。</summary>
        <returns>如果此方法成功排队，则为 <see langword="true" />；如果无法将该工作项排队，则引发 <see cref="T:System.NotSupportedException" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 可以将放置在其中定义该方法，也可以使用的类的实例字段中排队的方法所需的数据<xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%2CSystem.Object%29>重载接受一个包含所需的数据的对象。  
  
> [!NOTE]
>  Visual Basic 用户可以省略<xref:System.Threading.WaitCallback>构造函数，并只需使用`AddressOf`运算符时将传递到回调方法<xref:System.Threading.ThreadPool.QueueUserWorkItem%2A>。 Visual Basic 会自动调用正确的委托构造函数。  
  
## <a name="version-information"></a>版本信息  
 在.NET Framework 2.0 版中，<xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType>属性值将传播到辅助线程排入队列使用<xref:System.Threading.ThreadPool.QueueUserWorkItem%2A>方法。 在早期版本中，不会传播主体的信息。  
  
   
  
## Examples  
 下面的示例使用<xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%29>方法重载将任务排入队列，由表示`ThreadProc`方法，以在线程变得可用时执行。 使用此重载不提供任何任务信息。 因此，可供信息`ThreadProc`方法被限制为该方法所属的对象。  
  
 [!code-cpp[System.Threading.ThreadPool QueueUserWorkItem0#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem0/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ThreadPool QueueUserWorkItem0#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem0/CS/source.cs#1)]
 [!code-vb[System.Threading.ThreadPool QueueUserWorkItem0#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem0/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="callBack" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.NotSupportedException">承载公共语言运行时 (CLR) 的宿主不支持此操作。</exception>
        <related type="Article" href="~/docs/standard/threading/the-managed-thread-pool.md">托管线程池</related>
      </Docs>
    </Member>
    <Member MemberName="QueueUserWorkItem">
      <MemberSignature Language="C#" Value="public static bool QueueUserWorkItem (System.Threading.WaitCallback callBack, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool QueueUserWorkItem(class System.Threading.WaitCallback callBack, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.QueueUserWorkItem(System.Threading.WaitCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function QueueUserWorkItem (callBack As WaitCallback, state As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool QueueUserWorkItem(System::Threading::WaitCallback ^ callBack, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="static member QueueUserWorkItem : System.Threading.WaitCallback * obj -&gt; bool" Usage="System.Threading.ThreadPool.QueueUserWorkItem (callBack, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callBack" Type="System.Threading.WaitCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="callBack">
          <see cref="T:System.Threading.WaitCallback" />，它表示要执行的方法。</param>
        <param name="state">包含方法所用数据的对象。</param>
        <summary>将方法排入队列以便执行，并指定包含该方法所用数据的对象。 此方法在有线程池线程变得可用时执行。</summary>
        <returns>如果此方法成功排队，则为 <see langword="true" />；如果无法将该工作项排队，则引发 <see cref="T:System.NotSupportedException" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果回调方法需要复杂的数据，可以定义一个类来包含的数据。  
  
> [!NOTE]
>  Visual Basic 用户可以省略<xref:System.Threading.WaitCallback>构造函数，并只需使用`AddressOf`运算符时将传递到回调方法<xref:System.Threading.ThreadPool.QueueUserWorkItem%2A>。 Visual Basic 会自动调用正确的委托构造函数。  
  
## <a name="version-information"></a>版本信息  
 在.NET Framework 2.0 版中，<xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType>属性值将传播到辅助线程排入队列使用<xref:System.Threading.ThreadPool.QueueUserWorkItem%2A>方法。 在早期版本中，不会传播主体的信息。  
  
   
  
## Examples  
 下面的示例使用.NET 线程池来计算`Fibonacci`介于 20 和 40 之间的五个数字的结果。 每个 `Fibonacci` 结果都由 `Fibonacci` 类表示，该类提供一个名为 `ThreadPoolCallback` 的方法，用于执行计算。 创建表示每个 `Fibonacci` 值的对象，并将 `ThreadPoolCallback` 方法传递给 <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A>，它分配池中的一个可用线程来执行此方法。  
  
 因为每个`Fibonacci`对象指定一个半随机值来计算，和每个线程都将争用处理器时间，因为无法知道如何预先花费的时间计算的所有五个结果。 这就是在构造期间为每个 `Fibonacci` 对象传递 <xref:System.Threading.ManualResetEvent> 类的一个实例的原因。 每个对象都通知提供的事件对象其计算过程何时完成，它允许使用的块执行主线程<xref:System.Threading.WaitHandle.WaitAll%2A>直到所有五个`Fibonacci`对象全部计算出结果。 然后 `Main` 方法会显示每个 `Fibonacci` 结果。
  
 [!code-cpp[System.Threading.ThreadPool QueueUserWorkItem1#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem1/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ThreadPool QueueUserWorkItem1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem1/CS/source.cs#1)]
 [!code-vb[System.Threading.ThreadPool QueueUserWorkItem1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem1/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">承载公共语言运行时 (CLR) 的宿主不支持此操作。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="callBack" /> 为 <see langword="null" />。</exception>
        <related type="Article" href="~/docs/standard/threading/the-managed-thread-pool.md">托管线程池</related>
      </Docs>
    </Member>
    <Member MemberName="QueueUserWorkItem&lt;TState&gt;">
      <MemberSignature Language="C#" Value="public static bool QueueUserWorkItem&lt;TState&gt; (Action&lt;TState&gt; callBack, TState state, bool preferLocal);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool QueueUserWorkItem&lt;TState&gt;(class System.Action`1&lt;!!TState&gt; callBack, !!TState state, bool preferLocal) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.QueueUserWorkItem``1(System.Action{``0},``0,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function QueueUserWorkItem(Of TState) (callBack As Action(Of TState), state As TState, preferLocal As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TState&gt;&#xA; static bool QueueUserWorkItem(Action&lt;TState&gt; ^ callBack, TState state, bool preferLocal);" />
      <MemberSignature Language="F#" Value="static member QueueUserWorkItem : Action&lt;'State&gt; * 'State * bool -&gt; bool" Usage="System.Threading.ThreadPool.QueueUserWorkItem (callBack, state, preferLocal)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TState" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="callBack" Type="System.Action&lt;TState&gt;" />
        <Parameter Name="state" Type="TState" />
        <Parameter Name="preferLocal" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <typeparam name="TState">To be added.</typeparam>
        <param name="callBack">To be added.</param>
        <param name="state">To be added.</param>
        <param name="preferLocal">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="RegisterWaitForSingleObject">
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>注册正在等待 <see cref="T:System.Threading.WaitHandle" /> 的委托。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RegisterWaitForSingleObject">
      <MemberSignature Language="C#" Value="public static System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, int millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject(class System.Threading.WaitHandle waitObject, class System.Threading.WaitOrTimerCallback callBack, object state, int32 millisecondsTimeOutInterval, bool executeOnlyOnce) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RegisterWaitForSingleObject (waitObject As WaitHandle, callBack As WaitOrTimerCallback, state As Object, millisecondsTimeOutInterval As Integer, executeOnlyOnce As Boolean) As RegisteredWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::RegisteredWaitHandle ^ RegisterWaitForSingleObject(System::Threading::WaitHandle ^ waitObject, System::Threading::WaitOrTimerCallback ^ callBack, System::Object ^ state, int millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="F#" Value="static member RegisterWaitForSingleObject : System.Threading.WaitHandle * System.Threading.WaitOrTimerCallback * obj * int * bool -&gt; System.Threading.RegisteredWaitHandle" Usage="System.Threading.ThreadPool.RegisterWaitForSingleObject (waitObject, callBack, state, millisecondsTimeOutInterval, executeOnlyOnce)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.RegisteredWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitObject" Type="System.Threading.WaitHandle" />
        <Parameter Name="callBack" Type="System.Threading.WaitOrTimerCallback" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="millisecondsTimeOutInterval" Type="System.Int32" />
        <Parameter Name="executeOnlyOnce" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitObject">要注册的 <see cref="T:System.Threading.WaitHandle" />。 使用 <see cref="T:System.Threading.WaitHandle" /> 而非 <see cref="T:System.Threading.Mutex" />。</param>
        <param name="callBack">向 <paramref name="waitObject" /> 参数发出信号时调用的 <see cref="T:System.Threading.WaitOrTimerCallback" /> 委托。</param>
        <param name="state">传递给委托的对象。</param>
        <param name="millisecondsTimeOutInterval">以毫秒为单位的超时。 如果 <paramref name="millisecondsTimeOutInterval" /> 参数为 0（零），函数将测试对象的状态并立即返回。 如果 <paramref name="millisecondsTimeOutInterval" /> 为 -1，则函数的超时间隔永远不过期。</param>
        <param name="executeOnlyOnce">如果为 <see langword="true" />，表示在调用了委托后，线程将不再在 <paramref name="waitObject" /> 参数上等待；如果为 <see langword="false" />，表示每次完成等待操作后都重置计时器，直到注销等待。</param>
        <summary>注册一个等待 <see cref="T:System.Threading.WaitHandle" /> 的委托，并指定一个 32 位有符号整数来表示超时值（以毫秒为单位）。</summary>
        <returns>封装本机句柄的 <see cref="T:System.Threading.RegisteredWaitHandle" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 完成后使用<xref:System.Threading.RegisteredWaitHandle>此方法返回时，请调用其<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType>方法，以释放对等待句柄的引用。 我们建议，始终调用<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType>方法，即使您指定`true`为`executeOnlyOnce`。 垃圾回收的工作的详细信息有效地调用<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType>方法而不是具体取决于已注册的等待句柄的终结器。  
  
 <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>方法指定的委托排队到线程池。 发生以下情况之一时，工作线程将执行委托：  
  
-   指定的对象处于已发出信号状态。  
  
-   超时间隔过期。  
  
 <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>方法检查指定的对象的当前状态<xref:System.Threading.WaitHandle>。 如果对象的状态为非终止状态，该方法注册一个等待操作。 由线程池中的线程执行等待操作。 对象的状态将被发送信号或超时间隔结束时，将由工作线程执行委托。 如果`timeOutInterval`参数不是 0 （零） 和`executeOnlyOnce`参数是`false`，每次发出事件信号或超时间隔结束时重置计时器。  
  
> [!IMPORTANT]
>  使用<xref:System.Threading.Mutex>有关`waitObject`不提供用于回调的互相排斥，因为基础 Win32 API 使用默认`WT_EXECUTEDEFAULT`标志，因此在单独的线程池线程上调度每个回调。 而不是<xref:System.Threading.Mutex>，使用<xref:System.Threading.Semaphore>，最大计数为 1。  
  
 若要取消等待操作，请调用<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType>方法。  
  
 等待线程使用 Win32`WaitForMultipleObjects`函数来监视已注册的等待操作。 因此，如果必须使用相同的本机操作系统句柄中多次调用<xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>，必须重复使用 Win32 句柄`DuplicateHandle`函数。 请注意，不应传递到<xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>，这是因为等待线程可能检测不到该事件重置之前发出信号。  
  
 再返回，该函数修改某些类型的同步对象的状态。 仅对其发出信号的状态引起的等待条件得到满足的对象的进行修改。 例如，一个信号量计数被减少 1。  
  
## <a name="version-information"></a>版本信息  
 从.NET Framework 2.0 版中，开始<xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType>属性值将传播到辅助线程排入队列使用<xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>方法。 在早期版本中，不会传播主体的信息。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsTimeOutInterval" /> 参数小于 -1。</exception>
        <related type="Article" href="~/docs/standard/threading/the-managed-thread-pool.md">托管线程池</related>
      </Docs>
    </Member>
    <Member MemberName="RegisterWaitForSingleObject">
      <MemberSignature Language="C#" Value="public static System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, long millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject(class System.Threading.WaitHandle waitObject, class System.Threading.WaitOrTimerCallback callBack, object state, int64 millisecondsTimeOutInterval, bool executeOnlyOnce) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int64,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RegisterWaitForSingleObject (waitObject As WaitHandle, callBack As WaitOrTimerCallback, state As Object, millisecondsTimeOutInterval As Long, executeOnlyOnce As Boolean) As RegisteredWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::RegisteredWaitHandle ^ RegisterWaitForSingleObject(System::Threading::WaitHandle ^ waitObject, System::Threading::WaitOrTimerCallback ^ callBack, System::Object ^ state, long millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="F#" Value="static member RegisterWaitForSingleObject : System.Threading.WaitHandle * System.Threading.WaitOrTimerCallback * obj * int64 * bool -&gt; System.Threading.RegisteredWaitHandle" Usage="System.Threading.ThreadPool.RegisterWaitForSingleObject (waitObject, callBack, state, millisecondsTimeOutInterval, executeOnlyOnce)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.RegisteredWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitObject" Type="System.Threading.WaitHandle" />
        <Parameter Name="callBack" Type="System.Threading.WaitOrTimerCallback" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="millisecondsTimeOutInterval" Type="System.Int64" />
        <Parameter Name="executeOnlyOnce" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitObject">要注册的 <see cref="T:System.Threading.WaitHandle" />。 使用 <see cref="T:System.Threading.WaitHandle" /> 而非 <see cref="T:System.Threading.Mutex" />。</param>
        <param name="callBack">向 <paramref name="waitObject" /> 参数发出信号时调用的 <see cref="T:System.Threading.WaitOrTimerCallback" /> 委托。</param>
        <param name="state">传递给委托的对象。</param>
        <param name="millisecondsTimeOutInterval">以毫秒为单位的超时。 如果 <paramref name="millisecondsTimeOutInterval" /> 参数为 0（零），函数将测试对象的状态并立即返回。 如果 <paramref name="millisecondsTimeOutInterval" /> 为 -1，则函数的超时间隔永远不过期。</param>
        <param name="executeOnlyOnce">如果为 <see langword="true" />，表示在调用了委托后，线程将不再在 <paramref name="waitObject" /> 参数上等待；如果为 <see langword="false" />，表示每次完成等待操作后都重置计时器，直到注销等待。</param>
        <summary>注册一个等待 <see cref="T:System.Threading.WaitHandle" /> 的委托，并指定一个 64 位有符号整数来表示超时值（以毫秒为单位）。</summary>
        <returns>封装本机句柄的 <see cref="T:System.Threading.RegisteredWaitHandle" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 完成后使用<xref:System.Threading.RegisteredWaitHandle>此方法返回时，请调用其<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType>方法，以释放对等待句柄的引用。 我们建议，始终调用<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType>方法，即使您指定`true`为`executeOnlyOnce`。 垃圾回收的工作的详细信息有效地调用<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType>方法而不是具体取决于已注册的等待句柄的终结器。  
  
 <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>方法指定的委托排队到线程池。 发生以下情况之一时，工作线程将执行委托：  
  
-   指定的对象处于已发出信号状态。  
  
-   超时间隔过期。  
  
 <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>方法检查指定的对象的当前状态<xref:System.Threading.WaitHandle>。 如果对象的状态为非终止状态，该方法注册一个等待操作。 由线程池中的线程执行等待操作。 对象的状态将被发送信号或超时间隔结束时，将由工作线程执行委托。 如果`timeOutInterval`参数不是 0 （零） 和`executeOnlyOnce`参数是`false`，每次发出事件信号或超时间隔结束时重置计时器。  
  
> [!IMPORTANT]
>  使用<xref:System.Threading.Mutex>有关`waitObject`不提供用于回调的互相排斥，因为基础 Win32 API 使用默认`WT_EXECUTEDEFAULT`标志，因此在单独的线程池线程上调度每个回调。 而不是<xref:System.Threading.Mutex>，使用<xref:System.Threading.Semaphore>，最大计数为 1。  
  
 若要取消等待操作，请调用<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType>方法。  
  
 等待线程使用 Win32`WaitForMultipleObjects`函数来监视已注册的等待操作。 因此，如果必须使用相同的本机操作系统句柄中多次调用<xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>，必须重复使用 Win32 句柄`DuplicateHandle`函数。 请注意，不应传递到<xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>，这是因为等待线程可能检测不到该事件重置之前发出信号。  
  
 再返回，该函数修改某些类型的同步对象的状态。 仅对其发出信号的状态引起的等待条件得到满足的对象的进行修改。 例如，一个信号量计数被减少 1。  
  
## <a name="version-information"></a>版本信息  
 从.NET Framework 2.0 版中，开始<xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType>属性值将传播到辅助线程排入队列使用<xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>方法。 在早期版本中，不会传播主体的信息。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsTimeOutInterval" /> 参数小于 -1。</exception>
        <related type="Article" href="~/docs/standard/threading/the-managed-thread-pool.md">托管线程池</related>
      </Docs>
    </Member>
    <Member MemberName="RegisterWaitForSingleObject">
      <MemberSignature Language="C#" Value="public static System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, TimeSpan timeout, bool executeOnlyOnce);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject(class System.Threading.WaitHandle waitObject, class System.Threading.WaitOrTimerCallback callBack, object state, valuetype System.TimeSpan timeout, bool executeOnlyOnce) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.TimeSpan,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RegisterWaitForSingleObject (waitObject As WaitHandle, callBack As WaitOrTimerCallback, state As Object, timeout As TimeSpan, executeOnlyOnce As Boolean) As RegisteredWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::RegisteredWaitHandle ^ RegisterWaitForSingleObject(System::Threading::WaitHandle ^ waitObject, System::Threading::WaitOrTimerCallback ^ callBack, System::Object ^ state, TimeSpan timeout, bool executeOnlyOnce);" />
      <MemberSignature Language="F#" Value="static member RegisterWaitForSingleObject : System.Threading.WaitHandle * System.Threading.WaitOrTimerCallback * obj * TimeSpan * bool -&gt; System.Threading.RegisteredWaitHandle" Usage="System.Threading.ThreadPool.RegisterWaitForSingleObject (waitObject, callBack, state, timeout, executeOnlyOnce)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.RegisteredWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitObject" Type="System.Threading.WaitHandle" />
        <Parameter Name="callBack" Type="System.Threading.WaitOrTimerCallback" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="executeOnlyOnce" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitObject">要注册的 <see cref="T:System.Threading.WaitHandle" />。 使用 <see cref="T:System.Threading.WaitHandle" /> 而非 <see cref="T:System.Threading.Mutex" />。</param>
        <param name="callBack">向 <paramref name="waitObject" /> 参数发出信号时调用的 <see cref="T:System.Threading.WaitOrTimerCallback" /> 委托。</param>
        <param name="state">传递给委托的对象。</param>
        <param name="timeout">
          <see cref="T:System.TimeSpan" /> 表示的超时时间。 如果 <paramref name="timeout" /> 为 0（零），则函数将测试对象的状态并立即返回。 如果 <paramref name="timeout" /> 为 -1，则函数的超时间隔永远不过期。</param>
        <param name="executeOnlyOnce">如果为 <see langword="true" />，表示在调用了委托后，线程将不再在 <paramref name="waitObject" /> 参数上等待；如果为 <see langword="false" />，表示每次完成等待操作后都重置计时器，直到注销等待。</param>
        <summary>注册一个等待 <see cref="T:System.Threading.WaitHandle" /> 的委托，并指定一个 <see cref="T:System.TimeSpan" /> 值来表示超时时间。</summary>
        <returns>封装本机句柄的 <see cref="T:System.Threading.RegisteredWaitHandle" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 完成后使用<xref:System.Threading.RegisteredWaitHandle>此方法返回时，请调用其<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType>方法，以释放对等待句柄的引用。 我们建议，始终调用<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType>方法，即使您指定`true`为`executeOnlyOnce`。 垃圾回收的工作的详细信息有效地调用<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType>方法而不是具体取决于已注册的等待句柄的终结器。  
  
 <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>方法指定的委托排队到线程池。 发生以下情况之一时，工作线程将执行委托：  
  
-   指定的对象处于已发出信号状态。  
  
-   超时间隔过期。  
  
 <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>方法检查指定的对象的当前状态<xref:System.Threading.WaitHandle>。 如果对象的状态为非终止状态，该方法注册一个等待操作。 由线程池中的线程执行等待操作。 对象的状态将被发送信号或超时间隔结束时，将由工作线程执行委托。 如果`timeOutInterval`参数不是 0 （零） 和`executeOnlyOnce`参数是`false`，每次发出事件信号或超时间隔结束时重置计时器。  
  
> [!IMPORTANT]
>  使用<xref:System.Threading.Mutex>有关`waitObject`不提供用于回调的互相排斥，因为基础 Win32 API 使用默认`WT_EXECUTEDEFAULT`标志，因此在单独的线程池线程上调度每个回调。 而不是<xref:System.Threading.Mutex>，使用<xref:System.Threading.Semaphore>，最大计数为 1。  
  
 若要取消等待操作，请调用<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType>方法。  
  
 等待线程使用 Win32`WaitForMultipleObjects`函数来监视已注册的等待操作。 因此，如果必须使用相同的本机操作系统句柄中多次调用<xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>，必须重复使用 Win32 句柄`DuplicateHandle`函数。 请注意，不应传递到<xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>，这是因为等待线程可能检测不到该事件重置之前发出信号。  
  
 再返回，该函数修改某些类型的同步对象的状态。 仅对其发出信号的状态引起的等待条件得到满足的对象的进行修改。 例如，一个信号量计数被减少 1。  
  
## <a name="version-information"></a>版本信息  
 从.NET Framework 2.0 版中，开始<xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType>属性值将传播到辅助线程排入队列使用<xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>方法。 在早期版本中，不会传播主体的信息。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="timeout" /> 参数小于 -1。</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="timeout" /> 参数大于 <see cref="F:System.Int32.MaxValue" />。</exception>
        <related type="Article" href="~/docs/standard/threading/the-managed-thread-pool.md">托管线程池</related>
      </Docs>
    </Member>
    <Member MemberName="RegisterWaitForSingleObject">
      <MemberSignature Language="C#" Value="public static System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, uint millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject(class System.Threading.WaitHandle waitObject, class System.Threading.WaitOrTimerCallback callBack, object state, unsigned int32 millisecondsTimeOutInterval, bool executeOnlyOnce) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.UInt32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RegisterWaitForSingleObject (waitObject As WaitHandle, callBack As WaitOrTimerCallback, state As Object, millisecondsTimeOutInterval As UInteger, executeOnlyOnce As Boolean) As RegisteredWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::RegisteredWaitHandle ^ RegisterWaitForSingleObject(System::Threading::WaitHandle ^ waitObject, System::Threading::WaitOrTimerCallback ^ callBack, System::Object ^ state, System::UInt32 millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="F#" Value="static member RegisterWaitForSingleObject : System.Threading.WaitHandle * System.Threading.WaitOrTimerCallback * obj * uint32 * bool -&gt; System.Threading.RegisteredWaitHandle" Usage="System.Threading.ThreadPool.RegisterWaitForSingleObject (waitObject, callBack, state, millisecondsTimeOutInterval, executeOnlyOnce)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.RegisteredWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitObject" Type="System.Threading.WaitHandle" />
        <Parameter Name="callBack" Type="System.Threading.WaitOrTimerCallback" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="millisecondsTimeOutInterval" Type="System.UInt32" />
        <Parameter Name="executeOnlyOnce" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitObject">要注册的 <see cref="T:System.Threading.WaitHandle" />。 使用 <see cref="T:System.Threading.WaitHandle" /> 而非 <see cref="T:System.Threading.Mutex" />。</param>
        <param name="callBack">向 <paramref name="waitObject" /> 参数发出信号时调用的 <see cref="T:System.Threading.WaitOrTimerCallback" /> 委托。</param>
        <param name="state">传递给委托的对象。</param>
        <param name="millisecondsTimeOutInterval">以毫秒为单位的超时。 如果 <paramref name="millisecondsTimeOutInterval" /> 参数为 0（零），函数将测试对象的状态并立即返回。 如果 <paramref name="millisecondsTimeOutInterval" /> 为 -1，则函数的超时间隔永远不过期。</param>
        <param name="executeOnlyOnce">如果为 <see langword="true" />，表示在调用了委托后，线程将不再在 <paramref name="waitObject" /> 参数上等待；如果为 <see langword="false" />，表示每次完成等待操作后都重置计时器，直到注销等待。</param>
        <summary>指定表示超时（以毫秒为单位）的 32 位无符号整数，注册一个委托等待 <see cref="T:System.Threading.WaitHandle" />。</summary>
        <returns>
          <see cref="T:System.Threading.RegisteredWaitHandle" />，可用于取消已注册的等待操作。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 完成后使用<xref:System.Threading.RegisteredWaitHandle>此方法返回时，请调用其<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType>方法，以释放对等待句柄的引用。 我们建议，始终调用<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType>方法，即使您指定`true`为`executeOnlyOnce`。 垃圾回收的工作的详细信息有效地调用<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType>方法而不是具体取决于已注册的等待句柄的终结器。  
  
 <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>方法指定的委托排队到线程池。 发生以下情况之一时，工作线程将执行委托：  
  
-   指定的对象处于已发出信号状态。  
  
-   超时间隔过期。  
  
 <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>方法检查指定的对象的当前状态<xref:System.Threading.WaitHandle>。 如果对象的状态为非终止状态，该方法注册一个等待操作。 由线程池中的线程执行等待操作。 对象的状态将被发送信号或超时间隔结束时，将由工作线程执行委托。 如果`timeOutInterval`参数不是 0 （零） 和`executeOnlyOnce`参数是`false`，每次发出事件信号或超时间隔结束时重置计时器。  
  
> [!IMPORTANT]
>  使用<xref:System.Threading.Mutex>有关`waitObject`不提供用于回调的互相排斥，因为基础 Win32 API 使用默认`WT_EXECUTEDEFAULT`标志，因此在单独的线程池线程上调度每个回调。 而不是<xref:System.Threading.Mutex>，使用<xref:System.Threading.Semaphore>，最大计数为 1。  
  
 若要取消等待操作，请调用<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType>方法。  
  
 等待线程使用 Win32`WaitForMultipleObjects`函数来监视已注册的等待操作。 因此，如果必须使用相同的本机操作系统句柄中多次调用<xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>，必须重复使用 Win32 句柄`DuplicateHandle`函数。 请注意，不应传递到<xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>，这是因为等待线程可能检测不到该事件重置之前发出信号。  
  
 再返回，该函数修改某些类型的同步对象的状态。 仅对其发出信号的状态引起的等待条件得到满足的对象的进行修改。 例如，一个信号量计数被减少 1。  
  
## <a name="version-information"></a>版本信息  
 从.NET Framework 2.0 版中，开始<xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType>属性值将传播到辅助线程排入队列使用<xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>方法。 在早期版本中，不会传播主体的信息。  
  
   
  
## Examples  
 下面的示例演示如何使用<xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>要指定的等待句柄发出信号时执行指定的回调方法的方法。 在此示例中，回调方法是`WaitProc`，并等待句柄是<xref:System.Threading.AutoResetEvent>。  
  
 该示例定义了`TaskInfo`类来保存时它将执行传递给回调的信息。 此示例将创建`TaskInfo`对象，并将其分配一些字符串数据。 <xref:System.Threading.RegisteredWaitHandle>返回的<xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>方法指定给`Handle`字段`TaskInfo`对象，以便回调方法有权访问<xref:System.Threading.RegisteredWaitHandle>。  
  
 除了指定`TaskInfo`作为要传递给回调方法调用的对象<xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>方法指定<xref:System.Threading.AutoResetEvent>任务将等待<xref:System.Threading.WaitOrTimerCallback>委托，表示`WaitProc`回调方法一个第二个超时时间间隔和多个回调。  
  
 当主线程发出信号<xref:System.Threading.AutoResetEvent>通过调用其<xref:System.Threading.EventWaitHandle.Set%2A>方法，<xref:System.Threading.WaitOrTimerCallback>调用委托。 `WaitProc`方法测试<xref:System.Threading.RegisteredWaitHandle>以确定是否发生了超时值。 如果由于等待句柄已收到信号，而调用的回调`WaitProc`方法将注销<xref:System.Threading.RegisteredWaitHandle>，从而停止其他回调。 在超时的情况下该任务将继续等待。 `WaitProc`方法结束通过将消息输出到控制台。  
  
 [!code-cpp[System.Threading.ThreadPool RegisterWaitForSingleObject0#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ThreadPool RegisterWaitForSingleObject0/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ThreadPool RegisterWaitForSingleObject0#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ThreadPool RegisterWaitForSingleObject0/CS/source.cs#1)]
 [!code-vb[System.Threading.ThreadPool RegisterWaitForSingleObject0#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ThreadPool RegisterWaitForSingleObject0/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsTimeOutInterval" /> 参数小于 -1。</exception>
        <related type="Article" href="~/docs/standard/threading/the-managed-thread-pool.md">托管线程池</related>
      </Docs>
    </Member>
    <Member MemberName="SetMaxThreads">
      <MemberSignature Language="C#" Value="public static bool SetMaxThreads (int workerThreads, int completionPortThreads);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SetMaxThreads(int32 workerThreads, int32 completionPortThreads) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.SetMaxThreads(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SetMaxThreads (workerThreads As Integer, completionPortThreads As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool SetMaxThreads(int workerThreads, int completionPortThreads);" />
      <MemberSignature Language="F#" Value="static member SetMaxThreads : int * int -&gt; bool" Usage="System.Threading.ThreadPool.SetMaxThreads (workerThreads, completionPortThreads)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="workerThreads" Type="System.Int32" />
        <Parameter Name="completionPortThreads" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="workerThreads">线程池中辅助线程的最大数目。</param>
        <param name="completionPortThreads">线程池中异步 I/O 线程的最大数目。</param>
        <summary>设置可以同时处于活动状态的线程池的请求数目。 所有大于此数目的请求将保持排队状态，直到线程池线程变为可用。</summary>
        <returns>如果更改成功，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 您不能设置工作线程或 I/O 完成线程的最大数目为一个数字小于的计算机上的处理器数。 若要确定存在有多少处理器，检索的值<xref:System.Environment.ProcessorCount%2A?displayProperty=nameWithType>属性。 此外，不能设置工作线程或 I/O 完成线程数小于最小相应工作线程数或 I/O 完成线程的最大数目。 若要确定最小线程池的大小，请调用<xref:System.Threading.ThreadPool.GetMinThreads%2A>方法。  
  
 如果托管公共语言运行时，例如通过 Internet 信息服务 (IIS) 或 SQL Server，主机可以限制或阻止更改到线程池大小。  
  
 更改最大数量的线程池中的线程时要格外小心。 虽然你的代码可能受益，所做的更改可能产生负面影响您使用的代码库。  
  
 设置线程池大小太大，可能会导致性能问题。 如果在同一时间执行过多的线程，任务切换开销就成为一个重要的因素。  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">用于控制线程的能力。 权限值： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" /></permission>
        <altmember cref="M:System.Threading.ThreadPool.GetMaxThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.SetMinThreads(System.Int32,System.Int32)" />
        <altmember cref="M:System.Threading.ThreadPool.GetMinThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.GetAvailableThreads(System.Int32@,System.Int32@)" />
      </Docs>
    </Member>
    <Member MemberName="SetMinThreads">
      <MemberSignature Language="C#" Value="public static bool SetMinThreads (int workerThreads, int completionPortThreads);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SetMinThreads(int32 workerThreads, int32 completionPortThreads) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.SetMinThreads(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SetMinThreads (workerThreads As Integer, completionPortThreads As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool SetMinThreads(int workerThreads, int completionPortThreads);" />
      <MemberSignature Language="F#" Value="static member SetMinThreads : int * int -&gt; bool" Usage="System.Threading.ThreadPool.SetMinThreads (workerThreads, completionPortThreads)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="workerThreads" Type="System.Int32" />
        <Parameter Name="completionPortThreads" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="workerThreads">要由线程池根据需要创建的新的最小工作程序线程数。</param>
        <param name="completionPortThreads">要由线程池根据需要创建的新的最小空闲异步 I/O 线程数。</param>
        <summary>发出新的请求时，在切换到管理线程创建和销毁的算法之前设置线程池按需创建的线程的最小数量。</summary>
        <returns>如果更改成功，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 线程池按需提供新的工作线程或 I/O 完成线程直到它达到每个类别的最小值。 当达到最小值时，线程池可以创建该类别中的其他线程或等待，直到一些任务完成。 从[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]，线程池创建和销毁线程以优化吞吐量，该常数定义为每个单位的时间完成的任务数。 线程过少可能无法实现可用资源的最优利用，而线程过多则可能增加资源争用。  
  
 需求较低时，线程池线程的实际数量可以低于最小值。  
  
 如果指定为负数或大于最大活动线程池线程数的数字 (使用获得<xref:System.Threading.ThreadPool.GetMaxThreads%2A>)，<xref:System.Threading.ThreadPool.SetMinThreads%2A>返回`false`和也最小值不会更改。  
  
> [!CAUTION]
>  默认情况下，最小线程数设置为在系统上的处理器数。 可以使用<xref:System.Threading.ThreadPool.SetMinThreads%2A>方法来增加最小数字 ofthreads。 但是，不必要地增加这些值可能导致性能问题。 如果在同一时间开始太多的任务，则所有任务均可能会很慢。 在大多数情况下，线程池将使用其自己的分配线程算法更好地执行。 减少到小于处理器的数量也会影响性能的最小值。  
  
   
  
## Examples  
 下面的示例将最小工作线程数设置为 4，并保留的最小异步 I/O 完成线程数的原始值。  
  
 [!code-cpp[System.Threading.ThreadPool.GetSetMinThreads#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetSetMinThreads/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ThreadPool.GetSetMinThreads#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetSetMinThreads/CS/source.cs#1)]
 [!code-vb[System.Threading.ThreadPool.GetSetMinThreads#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetSetMinThreads/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">用于控制线程的能力。 权限值： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" /></permission>
        <altmember cref="M:System.Threading.ThreadPool.GetMinThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.GetMaxThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.GetAvailableThreads(System.Int32@,System.Int32@)" />
      </Docs>
    </Member>
    <Member MemberName="UnsafeQueueNativeOverlapped">
      <MemberSignature Language="C#" Value="public static bool UnsafeQueueNativeOverlapped (System.Threading.NativeOverlapped* overlapped);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool UnsafeQueueNativeOverlapped(valuetype System.Threading.NativeOverlapped* overlapped) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.UnsafeQueueNativeOverlapped(System.Threading.NativeOverlapped*)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool UnsafeQueueNativeOverlapped(System::Threading::NativeOverlapped* overlapped);" />
      <MemberSignature Language="F#" Value="static member UnsafeQueueNativeOverlapped : nativeptr&lt;System.Threading.NativeOverlapped&gt; -&gt; bool" Usage="System.Threading.ThreadPool.UnsafeQueueNativeOverlapped overlapped" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="overlapped" Type="System.Threading.NativeOverlapped*" />
      </Parameters>
      <Docs>
        <param name="overlapped">要排队的 <see cref="T:System.Threading.NativeOverlapped" /> 结构。</param>
        <summary>将重叠的 I/O 操作排队以便执行。</summary>
        <returns>如果成功地将此操作排队到 I/O 完成端口，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 有关使用本机 Win32 信息重叠 I/O，请参阅<xref:System.Threading.Overlapped>类，<xref:System.Threading.NativeOverlapped>结构，和`OVERLAPPED`Win32 平台 SDK 中的结构。  
  
> [!CAUTION]
>  使用<xref:System.Threading.ThreadPool.UnsafeQueueNativeOverlapped%2A>方法可能会无意中打开安全漏洞。 代码访问安全性基础在堆栈上的所有调用方的权限及其权限检查。 工作线程池线程使用的排队时<xref:System.Threading.ThreadPool.UnsafeQueueNativeOverlapped%2A>，线程池线程的堆栈不具有实际调用方的上下文。 恶意代码可能会利用这一点以避免权限检查。  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直接调用方需要完全信任。 不能由部分受信任的或透明的代码使用此成员。</permission>
      </Docs>
    </Member>
    <Member MemberName="UnsafeQueueUserWorkItem">
      <MemberSignature Language="C#" Value="public static bool UnsafeQueueUserWorkItem (System.Threading.WaitCallback callBack, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool UnsafeQueueUserWorkItem(class System.Threading.WaitCallback callBack, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.UnsafeQueueUserWorkItem(System.Threading.WaitCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function UnsafeQueueUserWorkItem (callBack As WaitCallback, state As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool UnsafeQueueUserWorkItem(System::Threading::WaitCallback ^ callBack, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="static member UnsafeQueueUserWorkItem : System.Threading.WaitCallback * obj -&gt; bool" Usage="System.Threading.ThreadPool.UnsafeQueueUserWorkItem (callBack, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callBack" Type="System.Threading.WaitCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="callBack">一个 <see cref="T:System.Threading.WaitCallback" />，表示当线程池中的线程选择工作项时调用的委托。</param>
        <param name="state">在接受线程池服务时传递给委托的对象。</param>
        <summary>将指定的委托排队到线程池，但不会将调用堆栈传播到辅助线程。</summary>
        <returns>如果方法成功，则为 <see langword="true" />；如果未能将该工作项排队，则引发 <see cref="T:System.OutOfMemoryException" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 与不同<xref:System.Threading.ThreadPool.QueueUserWorkItem%2A>方法，<xref:System.Threading.ThreadPool.UnsafeQueueUserWorkItem%2A>不会传播到辅助线程的调用堆栈。 这允许丢失的调用堆栈，从而提升其安全特权的代码。  
  
> [!CAUTION]
>  使用<xref:System.Threading.ThreadPool.UnsafeQueueUserWorkItem%2A>可能会无意中打开安全漏洞。 代码访问安全性基础在堆栈上的所有调用方的权限及其权限检查。 工作线程池线程使用的排队时<xref:System.Threading.ThreadPool.UnsafeQueueUserWorkItem%2A>，线程池线程的堆栈不会实际调用方的上下文。 恶意代码可能会利用这一点以避免权限检查。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">调用方没有所要求的权限。</exception>
        <exception cref="T:System.ApplicationException">遇到了内存不足的情况。</exception>
        <exception cref="T:System.OutOfMemoryException">未能将该工作项排队。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="callBack" /> 为 <see langword="null" />。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直接调用方需要完全信任。 不能由部分受信任的或透明的代码使用此成员。</permission>
        <related type="Article" href="~/docs/standard/threading/the-managed-thread-pool.md">托管线程池</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="UnsafeRegisterWaitForSingleObject">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>注册委托以等待 <see cref="T:System.Threading.WaitHandle" />，但不会将调用堆栈传播到辅助线程。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="UnsafeRegisterWaitForSingleObject">
      <MemberSignature Language="C#" Value="public static System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, int millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject(class System.Threading.WaitHandle waitObject, class System.Threading.WaitOrTimerCallback callBack, object state, int32 millisecondsTimeOutInterval, bool executeOnlyOnce) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function UnsafeRegisterWaitForSingleObject (waitObject As WaitHandle, callBack As WaitOrTimerCallback, state As Object, millisecondsTimeOutInterval As Integer, executeOnlyOnce As Boolean) As RegisteredWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::RegisteredWaitHandle ^ UnsafeRegisterWaitForSingleObject(System::Threading::WaitHandle ^ waitObject, System::Threading::WaitOrTimerCallback ^ callBack, System::Object ^ state, int millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="F#" Value="static member UnsafeRegisterWaitForSingleObject : System.Threading.WaitHandle * System.Threading.WaitOrTimerCallback * obj * int * bool -&gt; System.Threading.RegisteredWaitHandle" Usage="System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject (waitObject, callBack, state, millisecondsTimeOutInterval, executeOnlyOnce)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.RegisteredWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitObject" Type="System.Threading.WaitHandle" />
        <Parameter Name="callBack" Type="System.Threading.WaitOrTimerCallback" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="millisecondsTimeOutInterval" Type="System.Int32" />
        <Parameter Name="executeOnlyOnce" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitObject">要注册的 <see cref="T:System.Threading.WaitHandle" />。 使用 <see cref="T:System.Threading.WaitHandle" /> 而非 <see cref="T:System.Threading.Mutex" />。</param>
        <param name="callBack">向 <paramref name="waitObject" /> 参数发出信号时调用的委托。</param>
        <param name="state">传递给委托的对象。</param>
        <param name="millisecondsTimeOutInterval">以毫秒为单位的超时。 如果 <paramref name="millisecondsTimeOutInterval" /> 参数为 0（零），函数将测试对象的状态并立即返回。 如果 <paramref name="millisecondsTimeOutInterval" /> 为 -1，则函数的超时间隔永远不过期。</param>
        <param name="executeOnlyOnce">如果为 <see langword="true" />，表示在调用了委托后，线程将不再在 <paramref name="waitObject" /> 参数上等待；如果为 <see langword="false" />，表示每次完成等待操作后都重置计时器，直到注销等待。</param>
        <summary>注册一个等待 <see cref="T:System.Threading.WaitHandle" /> 的委托，并使用一个 32 位带符号整数来表示超时时间（以毫秒为单位）。 此方法不将调用堆栈传播到辅助线程。</summary>
        <returns>
          <see cref="T:System.Threading.RegisteredWaitHandle" /> 对象，可用于取消已注册的等待操作。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 与不同<xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>方法，<xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A>不会传播到辅助线程的调用堆栈。 这允许丢失的调用堆栈，从而提升其安全特权的代码。  
  
> [!CAUTION]
>  使用<xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A>可能会无意中打开安全漏洞。 代码访问安全性基础在堆栈上的所有调用方的权限及其权限检查。 工作线程池线程使用的排队时<xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A>，线程池线程的堆栈不会实际调用方的上下文。 恶意代码可能会利用这一点以避免权限检查。  
  
 使用<xref:System.Threading.Mutex>有关`waitObject`不提供用于回调的互相排斥，因为基础 Win32 API 使用默认`WT_EXECUTEDEFAULT`标志，因此在单独的线程池线程上调度每个回调。  
  
 完成后使用<xref:System.Threading.RegisteredWaitHandle>此方法返回时，请调用其<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType>方法，以释放对等待句柄的引用。 我们建议，始终调用<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType>方法，即使您指定`true`为`executeOnlyOnce`。 垃圾回收的工作的详细信息有效地调用<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType>方法而不是具体取决于已注册的等待句柄的终结器。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsTimeOutInterval" /> 参数小于 -1。</exception>
        <exception cref="T:System.Security.SecurityException">调用方没有所要求的权限。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直接调用方需要完全信任。 不能由部分受信任的或透明的代码使用此成员。</permission>
        <related type="Article" href="~/docs/standard/threading/the-managed-thread-pool.md">托管线程池</related>
      </Docs>
    </Member>
    <Member MemberName="UnsafeRegisterWaitForSingleObject">
      <MemberSignature Language="C#" Value="public static System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, long millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject(class System.Threading.WaitHandle waitObject, class System.Threading.WaitOrTimerCallback callBack, object state, int64 millisecondsTimeOutInterval, bool executeOnlyOnce) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int64,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function UnsafeRegisterWaitForSingleObject (waitObject As WaitHandle, callBack As WaitOrTimerCallback, state As Object, millisecondsTimeOutInterval As Long, executeOnlyOnce As Boolean) As RegisteredWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::RegisteredWaitHandle ^ UnsafeRegisterWaitForSingleObject(System::Threading::WaitHandle ^ waitObject, System::Threading::WaitOrTimerCallback ^ callBack, System::Object ^ state, long millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="F#" Value="static member UnsafeRegisterWaitForSingleObject : System.Threading.WaitHandle * System.Threading.WaitOrTimerCallback * obj * int64 * bool -&gt; System.Threading.RegisteredWaitHandle" Usage="System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject (waitObject, callBack, state, millisecondsTimeOutInterval, executeOnlyOnce)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.RegisteredWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitObject" Type="System.Threading.WaitHandle" />
        <Parameter Name="callBack" Type="System.Threading.WaitOrTimerCallback" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="millisecondsTimeOutInterval" Type="System.Int64" />
        <Parameter Name="executeOnlyOnce" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitObject">要注册的 <see cref="T:System.Threading.WaitHandle" />。 使用 <see cref="T:System.Threading.WaitHandle" /> 而非 <see cref="T:System.Threading.Mutex" />。</param>
        <param name="callBack">向 <paramref name="waitObject" /> 参数发出信号时调用的委托。</param>
        <param name="state">传递给委托的对象。</param>
        <param name="millisecondsTimeOutInterval">以毫秒为单位的超时。 如果 <paramref name="millisecondsTimeOutInterval" /> 参数为 0（零），函数将测试对象的状态并立即返回。 如果 <paramref name="millisecondsTimeOutInterval" /> 为 -1，则函数的超时间隔永远不过期。</param>
        <param name="executeOnlyOnce">如果为 <see langword="true" />，表示在调用了委托后，线程将不再在 <paramref name="waitObject" /> 参数上等待；如果为 <see langword="false" />，表示每次完成等待操作后都重置计时器，直到注销等待。</param>
        <summary>注册一个等待 <see cref="T:System.Threading.WaitHandle" /> 的委托，并指定一个 64 位有符号整数来表示超时值（以毫秒为单位）。 此方法不将调用堆栈传播到辅助线程。</summary>
        <returns>
          <see cref="T:System.Threading.RegisteredWaitHandle" /> 对象，可用于取消已注册的等待操作。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 与不同<xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>方法，<xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A>不会传播到辅助线程的调用堆栈。 这允许丢失的调用堆栈，从而提升其安全特权的代码。  
  
> [!CAUTION]
>  使用<xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A>可能会无意中打开安全漏洞。 代码访问安全性基础在堆栈上的所有调用方的权限及其权限检查。 工作线程池线程使用的排队时<xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A>，线程池线程的堆栈不会实际调用方的上下文。 恶意代码可能会利用这一点以避免权限检查。  
  
 使用<xref:System.Threading.Mutex>有关`waitObject`不提供用于回调的互相排斥，因为基础 Win32 API 使用默认`WT_EXECUTEDEFAULT`标志，因此在单独的线程池线程上调度每个回调。  
  
 完成后使用<xref:System.Threading.RegisteredWaitHandle>此方法返回时，请调用其<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType>方法，以释放对等待句柄的引用。 我们建议，始终调用<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType>方法，即使您指定`true`为`executeOnlyOnce`。 垃圾回收的工作的详细信息有效地调用<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType>方法而不是具体取决于已注册的等待句柄的终结器。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsTimeOutInterval" /> 参数小于 -1。</exception>
        <exception cref="T:System.Security.SecurityException">调用方没有所要求的权限。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直接调用方需要完全信任。 不能由部分受信任的或透明的代码使用此成员。</permission>
        <related type="Article" href="~/docs/standard/threading/the-managed-thread-pool.md">托管线程池</related>
      </Docs>
    </Member>
    <Member MemberName="UnsafeRegisterWaitForSingleObject">
      <MemberSignature Language="C#" Value="public static System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, TimeSpan timeout, bool executeOnlyOnce);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject(class System.Threading.WaitHandle waitObject, class System.Threading.WaitOrTimerCallback callBack, object state, valuetype System.TimeSpan timeout, bool executeOnlyOnce) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.TimeSpan,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function UnsafeRegisterWaitForSingleObject (waitObject As WaitHandle, callBack As WaitOrTimerCallback, state As Object, timeout As TimeSpan, executeOnlyOnce As Boolean) As RegisteredWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::RegisteredWaitHandle ^ UnsafeRegisterWaitForSingleObject(System::Threading::WaitHandle ^ waitObject, System::Threading::WaitOrTimerCallback ^ callBack, System::Object ^ state, TimeSpan timeout, bool executeOnlyOnce);" />
      <MemberSignature Language="F#" Value="static member UnsafeRegisterWaitForSingleObject : System.Threading.WaitHandle * System.Threading.WaitOrTimerCallback * obj * TimeSpan * bool -&gt; System.Threading.RegisteredWaitHandle" Usage="System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject (waitObject, callBack, state, timeout, executeOnlyOnce)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.RegisteredWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitObject" Type="System.Threading.WaitHandle" />
        <Parameter Name="callBack" Type="System.Threading.WaitOrTimerCallback" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="executeOnlyOnce" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitObject">要注册的 <see cref="T:System.Threading.WaitHandle" />。 使用 <see cref="T:System.Threading.WaitHandle" /> 而非 <see cref="T:System.Threading.Mutex" />。</param>
        <param name="callBack">向 <paramref name="waitObject" /> 参数发出信号时调用的委托。</param>
        <param name="state">传递给委托的对象。</param>
        <param name="timeout">
          <see cref="T:System.TimeSpan" /> 表示的超时时间。 如果 <paramref name="timeout" /> 为 0（零），则函数将测试对象的状态并立即返回。 如果 <paramref name="timeout" /> 为 -1，则函数的超时间隔永远不过期。</param>
        <param name="executeOnlyOnce">如果为 <see langword="true" />，表示在调用了委托后，线程将不再在 <paramref name="waitObject" /> 参数上等待；如果为 <see langword="false" />，表示每次完成等待操作后都重置计时器，直到注销等待。</param>
        <summary>注册一个等待 <see cref="T:System.Threading.WaitHandle" /> 的委托，并指定一个 <see cref="T:System.TimeSpan" /> 值来表示超时时间。此方法不将调用堆栈传播到辅助线程。</summary>
        <returns>
          <see cref="T:System.Threading.RegisteredWaitHandle" /> 对象，可用于取消已注册的等待操作。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 与不同<xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>方法，<xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A>不会传播到辅助线程的调用堆栈。 这允许丢失的调用堆栈，从而提升其安全特权的代码。  
  
> [!CAUTION]
>  使用<xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A>可能会无意中打开安全漏洞。 代码访问安全性基础在堆栈上的所有调用方的权限及其权限检查。 工作线程池线程使用的排队时<xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A>，线程池线程的堆栈不会实际调用方的上下文。 恶意代码可能会利用这一点以避免权限检查。  
  
 使用<xref:System.Threading.Mutex>有关`waitObject`不提供用于回调的互相排斥，因为基础 Win32 API 使用默认`WT_EXECUTEDEFAULT`标志，因此在单独的线程池线程上调度每个回调。  
  
 完成后使用<xref:System.Threading.RegisteredWaitHandle>此方法返回时，请调用其<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType>方法，以释放对等待句柄的引用。 我们建议，始终调用<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType>方法，即使您指定`true`为`executeOnlyOnce`。 垃圾回收的工作的详细信息有效地调用<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType>方法而不是具体取决于已注册的等待句柄的终结器。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="timeout" /> 参数小于 -1。</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="timeout" /> 参数大于 <see cref="F:System.Int32.MaxValue" />。</exception>
        <exception cref="T:System.Security.SecurityException">调用方没有所要求的权限。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直接调用方需要完全信任。 不能由部分受信任的或透明的代码使用此成员。</permission>
        <related type="Article" href="~/docs/standard/threading/the-managed-thread-pool.md">托管线程池</related>
      </Docs>
    </Member>
    <Member MemberName="UnsafeRegisterWaitForSingleObject">
      <MemberSignature Language="C#" Value="public static System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, uint millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject(class System.Threading.WaitHandle waitObject, class System.Threading.WaitOrTimerCallback callBack, object state, unsigned int32 millisecondsTimeOutInterval, bool executeOnlyOnce) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.UInt32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function UnsafeRegisterWaitForSingleObject (waitObject As WaitHandle, callBack As WaitOrTimerCallback, state As Object, millisecondsTimeOutInterval As UInteger, executeOnlyOnce As Boolean) As RegisteredWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::RegisteredWaitHandle ^ UnsafeRegisterWaitForSingleObject(System::Threading::WaitHandle ^ waitObject, System::Threading::WaitOrTimerCallback ^ callBack, System::Object ^ state, System::UInt32 millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="F#" Value="static member UnsafeRegisterWaitForSingleObject : System.Threading.WaitHandle * System.Threading.WaitOrTimerCallback * obj * uint32 * bool -&gt; System.Threading.RegisteredWaitHandle" Usage="System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject (waitObject, callBack, state, millisecondsTimeOutInterval, executeOnlyOnce)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.RegisteredWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitObject" Type="System.Threading.WaitHandle" />
        <Parameter Name="callBack" Type="System.Threading.WaitOrTimerCallback" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="millisecondsTimeOutInterval" Type="System.UInt32" />
        <Parameter Name="executeOnlyOnce" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitObject">要注册的 <see cref="T:System.Threading.WaitHandle" />。 使用 <see cref="T:System.Threading.WaitHandle" /> 而非 <see cref="T:System.Threading.Mutex" />。</param>
        <param name="callBack">向 <paramref name="waitObject" /> 参数发出信号时调用的委托。</param>
        <param name="state">传递给委托的对象。</param>
        <param name="millisecondsTimeOutInterval">以毫秒为单位的超时。 如果 <paramref name="millisecondsTimeOutInterval" /> 参数为 0（零），函数将测试对象的状态并立即返回。 如果 <paramref name="millisecondsTimeOutInterval" /> 为 -1，则函数的超时间隔永远不过期。</param>
        <param name="executeOnlyOnce">如果为 <see langword="true" />，表示在调用了委托后，线程将不再在 <paramref name="waitObject" /> 参数上等待；如果为 <see langword="false" />，表示每次完成等待操作后都重置计时器，直到注销等待。</param>
        <summary>指定表示超时（以毫秒为单位）的 32 位无符号整数，注册一个委托等待 <see cref="T:System.Threading.WaitHandle" />。 此方法不将调用堆栈传播到辅助线程。</summary>
        <returns>
          <see cref="T:System.Threading.RegisteredWaitHandle" /> 对象，可用于取消已注册的等待操作。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 与不同<xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>方法，<xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A>不会传播到辅助线程的调用堆栈。 这允许丢失的调用堆栈，从而提升其安全特权的代码。  
  
> [!CAUTION]
>  使用<xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A>可能会无意中打开安全漏洞。 代码访问安全性基础在堆栈上的所有调用方的权限及其权限检查。 工作线程池线程使用的排队时<xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A>，线程池线程的堆栈不会实际调用方的上下文。 恶意代码可能会利用这一点以避免权限检查。  
  
 使用<xref:System.Threading.Mutex>有关`waitObject`不提供用于回调的互相排斥，因为基础 Win32 API 使用默认`WT_EXECUTEDEFAULT`标志，因此在单独的线程池线程上调度每个回调。  
  
 完成后使用<xref:System.Threading.RegisteredWaitHandle>此方法返回时，请调用其<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType>方法，以释放对等待句柄的引用。 我们建议，始终调用<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType>方法，即使您指定`true`为`executeOnlyOnce`。 垃圾回收的工作的详细信息有效地调用<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType>方法而不是具体取决于已注册的等待句柄的终结器。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">调用方没有所要求的权限。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直接调用方需要完全信任。 不能由部分受信任的或透明的代码使用此成员。</permission>
        <related type="Article" href="~/docs/standard/threading/the-managed-thread-pool.md">托管线程池</related>
      </Docs>
    </Member>
  </Members>
</Type>