<Type Name="ControlAdapter" FullName="System.Web.UI.Adapters.ControlAdapter">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="32da3a4f246af136cf0a6d8ef5bbe62b7f5d4aa6" />
    <Meta Name="ms.sourcegitcommit" Value="0ec122ee5f3681159b8460ab15b409fd6e3d3ae0" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-CN" />
    <Meta Name="ms.lasthandoff" Value="10/04/2018" />
    <Meta Name="ms.locfileid" Value="48616292" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class ControlAdapter" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit ControlAdapter extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Web.UI.Adapters.ControlAdapter" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class ControlAdapter" />
  <TypeSignature Language="C++ CLI" Value="public ref class ControlAdapter abstract" />
  <TypeSignature Language="F#" Value="type ControlAdapter = class" />
  <AssemblyInfo>
    <AssemblyName>System.Web</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>
      <span data-ttu-id="314a3-101">自定义附加了适配器的派生控件的呈现，以修改特定浏览器的默认标记或行为，是所有控件适配器都可以继承的基类。</span>
      <span class="sxs-lookup">
        <span data-stu-id="314a3-101">Customizes rendering for the derived control to which the adapter is attached, to modify the default markup or behavior for specific browsers, and is the base class from which all control adapters inherit.</span>
      </span>
    </summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="314a3-102">控件适配器是组件，可以重写某些<xref:System.Web.UI.Control>类中执行生命周期以允许浏览器或特定于标记的处理方法和事件。</span><span class="sxs-lookup"><span data-stu-id="314a3-102">Control adapters are components that override certain <xref:System.Web.UI.Control> class methods and events in its execution lifecycle to allow browser or markup-specific handling.</span></span> <span data-ttu-id="314a3-103">.NET Framework 映射到的单个派生的控件适配器<xref:System.Web.UI.Control>为每个客户端请求的对象。</span><span class="sxs-lookup"><span data-stu-id="314a3-103">The .NET Framework maps a single derived control adapter to a <xref:System.Web.UI.Control> object for each client request.</span></span>  
  
 <span data-ttu-id="314a3-104">适配器修改特定浏览器或浏览器的类的控件，或作为针对某些功能的任意筛选器。</span><span class="sxs-lookup"><span data-stu-id="314a3-104">An adapter modifies a control for a specific browser or class of browsers or acts as an arbitrary filter on some capability.</span></span> <span data-ttu-id="314a3-105">通常由浏览器使用 （例如，XHTML 或 HTML 3.2） 的标记语言定义适配器。</span><span class="sxs-lookup"><span data-stu-id="314a3-105">Typically the adapter is defined by the markup language that the browser uses (for example, XHTML or HTML 3.2).</span></span> <span data-ttu-id="314a3-106">呈现行为的适应性很多可以封装在派生的专用类<xref:System.Web.UI.HtmlTextWriter>类。</span><span class="sxs-lookup"><span data-stu-id="314a3-106">Much of the adaptability in rendering behavior can be encapsulated in the specialized classes that derive from the <xref:System.Web.UI.HtmlTextWriter> class.</span></span> <span data-ttu-id="314a3-107">因此，很可能一个适配器可以用于多种浏览器类行为，或者包括在适应性<xref:System.Web.UI.HtmlTextWriter>类可以使控件适配器的使用不必要。</span><span class="sxs-lookup"><span data-stu-id="314a3-107">Therefore, it is likely that a single adapter can be used for a number of browser class behaviors or that inclusion of the adaptability in the <xref:System.Web.UI.HtmlTextWriter> classes could make the use of a control adapter unnecessary.</span></span>  
  
 <span data-ttu-id="314a3-108">控件类的适配器适用于所有控件都继承自该类的除非存在更专业的适配器。</span><span class="sxs-lookup"><span data-stu-id="314a3-108">An adapter for a control class applies to all controls that inherit from that class, unless more specialized adapters are present.</span></span> <span data-ttu-id="314a3-109">例如，对于适配器<xref:System.Web.UI.WebControls.BaseValidator>类可用于所有`Validator`对象。</span><span class="sxs-lookup"><span data-stu-id="314a3-109">For example, an adapter for the <xref:System.Web.UI.WebControls.BaseValidator> class can be used for all `Validator` objects.</span></span>  
  
 <span data-ttu-id="314a3-110">适配器通常不直接从继承<xref:System.Web.UI.Adapters.ControlAdapter>类，但从一个特定于目标的适配器基类，后者可提供特定于控件类型和目标浏览器的其他功能或特定的呈现所需。</span><span class="sxs-lookup"><span data-stu-id="314a3-110">Adapters typically do not inherit directly from the <xref:System.Web.UI.Adapters.ControlAdapter> class, but from one of the target-specific adapter base classes that provide additional functionality specific to the control type and target browser or the particular rendering required.</span></span>  
  
 <span data-ttu-id="314a3-111">控件本身并不一定需要适配器。</span><span class="sxs-lookup"><span data-stu-id="314a3-111">Controls themselves do not necessarily require an adapter.</span></span> <span data-ttu-id="314a3-112">如果控件通过组合扩展，通常子控件适配器已足够。</span><span class="sxs-lookup"><span data-stu-id="314a3-112">If controls are extended through composition, generally the child control adapters are sufficient.</span></span>  
  
 <span data-ttu-id="314a3-113">每个控件具有通过.browser 定义文件的显式映射到适配器。</span><span class="sxs-lookup"><span data-stu-id="314a3-113">Each control has explicit mappings to adapters through the .browser definition files.</span></span> <span data-ttu-id="314a3-114">因此，任何访问<xref:System.Web.UI.Control.Adapter%2A?displayProperty=nameWithType>属性使用<xref:System.Web.HttpBrowserCapabilities>从浏览器定义文件来查找到控件适配器的映射中提取的对象。</span><span class="sxs-lookup"><span data-stu-id="314a3-114">Thus, any access to the <xref:System.Web.UI.Control.Adapter%2A?displayProperty=nameWithType> property uses the <xref:System.Web.HttpBrowserCapabilities> object extracted from the browser definition files to perform the lookup for the mapping of the adapter to control.</span></span>  
  
 <span data-ttu-id="314a3-115">在处理期间，.NET Framework 截获对可能是特定于目标的一个控件的可重写方法的调用。</span><span class="sxs-lookup"><span data-stu-id="314a3-115">During processing, the .NET Framework intercepts calls to the overridable methods of a control that could be target-specific.</span></span> <span data-ttu-id="314a3-116">如果附加了控件适配器，.NET Framework 调用关联的适配器方法。</span><span class="sxs-lookup"><span data-stu-id="314a3-116">If a control adapter is attached, the .NET Framework calls the associated adapter methods.</span></span>  
  
 <span data-ttu-id="314a3-117">适配器通过控件执行呈现<xref:System.Web.UI.Adapters.ControlAdapter.Render%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="314a3-117">The adapter performs rendering for the control through the <xref:System.Web.UI.Adapters.ControlAdapter.Render%2A> method.</span></span> <span data-ttu-id="314a3-118">如果重写，则<xref:System.Web.UI.Adapters.ControlAdapter.Render%2A>可能不应调用基类实现，它执行调用返回因为<xref:System.Web.UI.Control.Render%2A?displayProperty=nameWithType>方法。</span><span class="sxs-lookup"><span data-stu-id="314a3-118">If overridden, <xref:System.Web.UI.Adapters.ControlAdapter.Render%2A> potentially should not call the base class implementation because that performs a call back on the <xref:System.Web.UI.Control.Render%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="314a3-119">这可能会导致出现两次，一次由适配器和一次由该控件的呈现。</span><span class="sxs-lookup"><span data-stu-id="314a3-119">This might cause the rendering to occur twice, once by the adapter and once by the control.</span></span>  
  
 <span data-ttu-id="314a3-120"><xref:System.Web.UI.Adapters.ControlAdapter.Render%2A>基于方法调用<xref:System.Web.UI.Control.Render%2A?displayProperty=nameWithType>控件的方法。</span><span class="sxs-lookup"><span data-stu-id="314a3-120">The <xref:System.Web.UI.Adapters.ControlAdapter.Render%2A> base method calls back on the <xref:System.Web.UI.Control.Render%2A?displayProperty=nameWithType> method of the control.</span></span> <span data-ttu-id="314a3-121">因此，如果重写<xref:System.Web.UI.Adapters.ControlAdapter.Render%2A>，除非您实现的呈现之外，提供的不应调用基类实现<xref:System.Web.UI.Control.Render%2A?displayProperty=nameWithType>的控件。</span><span class="sxs-lookup"><span data-stu-id="314a3-121">Thus, if you override <xref:System.Web.UI.Adapters.ControlAdapter.Render%2A>, you should not call the base class implementation unless the rendering you implement is in addition to that provided by <xref:System.Web.UI.Control.Render%2A?displayProperty=nameWithType> of the control.</span></span>  
  
 <span data-ttu-id="314a3-122">您必须确保.NET Framework 的子控件的适配器执行拦截。</span><span class="sxs-lookup"><span data-stu-id="314a3-122">You must ensure that the .NET Framework performs interception for adapters of the child controls.</span></span> <span data-ttu-id="314a3-123">您可以执行此操作通过调用<xref:System.Web.UI.Adapters.ControlAdapter.RenderChildren%2A>基方法，以便调用<xref:System.Web.UI.Control.RenderChildren%2A?displayProperty=nameWithType>控件的方法从你<xref:System.Web.UI.Adapters.ControlAdapter.Render%2A>重写。</span><span class="sxs-lookup"><span data-stu-id="314a3-123">You can do this by calling the <xref:System.Web.UI.Adapters.ControlAdapter.RenderChildren%2A> base method, which calls the <xref:System.Web.UI.Control.RenderChildren%2A?displayProperty=nameWithType> method of the control, from your <xref:System.Web.UI.Adapters.ControlAdapter.Render%2A> override.</span></span>  
  
 <span data-ttu-id="314a3-124"><xref:System.Web.UI.Adapters.ControlAdapter.BeginRender%2A>并<xref:System.Web.UI.Adapters.ControlAdapter.EndRender%2A>方法由该控件之前和之后 （分别） 的控件调用立即调用<xref:System.Web.UI.Adapters.ControlAdapter.Render%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="314a3-124">The <xref:System.Web.UI.Adapters.ControlAdapter.BeginRender%2A> and <xref:System.Web.UI.Adapters.ControlAdapter.EndRender%2A> methods are called by the control immediately before and after (respectively) the control calls the <xref:System.Web.UI.Adapters.ControlAdapter.Render%2A> method.</span></span> <span data-ttu-id="314a3-125">如果前和后呈现唯一的浏览器特定处理任务，使用<xref:System.Web.UI.Adapters.ControlAdapter.BeginRender%2A>并<xref:System.Web.UI.Adapters.ControlAdapter.EndRender%2A>可能会使用户无需重写<xref:System.Web.UI.Adapters.ControlAdapter.Render%2A>。</span><span class="sxs-lookup"><span data-stu-id="314a3-125">If pre- and post-rendering are the only browser-specific processing tasks required, using <xref:System.Web.UI.Adapters.ControlAdapter.BeginRender%2A> and <xref:System.Web.UI.Adapters.ControlAdapter.EndRender%2A> might make it unnecessary to override <xref:System.Web.UI.Adapters.ControlAdapter.Render%2A>.</span></span> <span data-ttu-id="314a3-126">默认行为<xref:System.Web.UI.Adapters.ControlAdapter.BeginRender%2A>并<xref:System.Web.UI.Adapters.ControlAdapter.EndRender%2A>方法是调用的相应方法<xref:System.Web.UI.HtmlTextWriter>。</span><span class="sxs-lookup"><span data-stu-id="314a3-126">The default behavior of the <xref:System.Web.UI.Adapters.ControlAdapter.BeginRender%2A> and <xref:System.Web.UI.Adapters.ControlAdapter.EndRender%2A> methods is to call the corresponding methods of the <xref:System.Web.UI.HtmlTextWriter>.</span></span>  
  
 <span data-ttu-id="314a3-127">若要维护其自己的状态信息，控件适配器可以重写<xref:System.Web.UI.Adapters.ControlAdapter.SaveAdapterControlState%2A>， <xref:System.Web.UI.Adapters.ControlAdapter.LoadAdapterControlState%2A>， <xref:System.Web.UI.Adapters.ControlAdapter.SaveAdapterViewState%2A>，和<xref:System.Web.UI.Adapters.ControlAdapter.LoadAdapterViewState%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="314a3-127">To maintain its own state information, a control adapter can override the <xref:System.Web.UI.Adapters.ControlAdapter.SaveAdapterControlState%2A>, <xref:System.Web.UI.Adapters.ControlAdapter.LoadAdapterControlState%2A>, <xref:System.Web.UI.Adapters.ControlAdapter.SaveAdapterViewState%2A>, and <xref:System.Web.UI.Adapters.ControlAdapter.LoadAdapterViewState%2A> methods.</span></span> <span data-ttu-id="314a3-128"><xref:System.Web.UI.Adapters.ControlAdapter.SaveAdapterControlState%2A><xref:System.Web.UI.Adapters.ControlAdapter.SaveAdapterViewState%2A>， <xref:System.Web.UI.Adapters.ControlAdapter.LoadAdapterControlState%2A>，和<xref:System.Web.UI.Adapters.ControlAdapter.LoadAdapterViewState%2A>当保存和加载，分别专用控件和视图状态时调用。</span><span class="sxs-lookup"><span data-stu-id="314a3-128"><xref:System.Web.UI.Adapters.ControlAdapter.SaveAdapterControlState%2A>, <xref:System.Web.UI.Adapters.ControlAdapter.SaveAdapterViewState%2A>, <xref:System.Web.UI.Adapters.ControlAdapter.LoadAdapterControlState%2A>, and <xref:System.Web.UI.Adapters.ControlAdapter.LoadAdapterViewState%2A> are called when the private control and view states are saved and loaded, respectively.</span></span>  
  
 <span data-ttu-id="314a3-129"><xref:System.Web.UI.Adapters.ControlAdapter.OnInit%2A>， <xref:System.Web.UI.Adapters.ControlAdapter.OnLoad%2A>， <xref:System.Web.UI.Adapters.ControlAdapter.OnPreRender%2A>，和<xref:System.Web.UI.Adapters.ControlAdapter.OnUnload%2A>基方法将调用回调的相应<xref:System.Web.UI.Control>类方法。</span><span class="sxs-lookup"><span data-stu-id="314a3-129">The <xref:System.Web.UI.Adapters.ControlAdapter.OnInit%2A>, <xref:System.Web.UI.Adapters.ControlAdapter.OnLoad%2A>, <xref:System.Web.UI.Adapters.ControlAdapter.OnPreRender%2A>, and <xref:System.Web.UI.Adapters.ControlAdapter.OnUnload%2A> base methods call back on the corresponding <xref:System.Web.UI.Control> class methods.</span></span> <span data-ttu-id="314a3-130">因此，其中的任何<xref:System.Web.UI.Adapters.ControlAdapter>将被重写的方法必须调用其基方法; 否则为该事件与<xref:System.Web.UI.Control>类方法将不会引发。</span><span class="sxs-lookup"><span data-stu-id="314a3-130">Thus, any of these <xref:System.Web.UI.Adapters.ControlAdapter> methods that are overridden must call their base methods; otherwise, the event associated with the <xref:System.Web.UI.Control> class method will not be raised.</span></span>  
  
 <span data-ttu-id="314a3-131">控件和适配器可以选择实现<xref:System.Web.UI.IPostBackDataHandler>和<xref:System.Web.UI.IPostBackEventHandler>接口。</span><span class="sxs-lookup"><span data-stu-id="314a3-131">Controls and adapters optionally implement the <xref:System.Web.UI.IPostBackDataHandler> and <xref:System.Web.UI.IPostBackEventHandler> interfaces.</span></span> <span data-ttu-id="314a3-132">.NET Framework 确定适配器是否存在以及是否适配器实现这些接口。</span><span class="sxs-lookup"><span data-stu-id="314a3-132">The .NET Framework determines whether an adapter exists and whether the adapter implements these interfaces.</span></span> <span data-ttu-id="314a3-133">如果是这样，适配器应重写<xref:System.Web.UI.IPostBackDataHandler.LoadPostData%2A>， <xref:System.Web.UI.IPostBackDataHandler.RaisePostDataChangedEvent%2A>，和<xref:System.Web.UI.IPostBackEventHandler.RaisePostBackEvent%2A>方法，根据需要。</span><span class="sxs-lookup"><span data-stu-id="314a3-133">If it does, the adapter should override the <xref:System.Web.UI.IPostBackDataHandler.LoadPostData%2A>, <xref:System.Web.UI.IPostBackDataHandler.RaisePostDataChangedEvent%2A>, and <xref:System.Web.UI.IPostBackEventHandler.RaisePostBackEvent%2A> methods, as necessary.</span></span> <span data-ttu-id="314a3-134">如果回发数据无法识别在适配器中，它必须返回调用控件以对其进行处理。</span><span class="sxs-lookup"><span data-stu-id="314a3-134">If the postback data is not recognized in the adapter, it must call back on the control to process it.</span></span> <span data-ttu-id="314a3-135">后续的事件处理程序还必须调用返回在控件上。</span><span class="sxs-lookup"><span data-stu-id="314a3-135">Subsequent event handlers also must call back on the control.</span></span>  
  
 ]]></format>
    </remarks>
    <block subset="none" type="overrides">
      <para>
        <span data-ttu-id="314a3-136">继承自<see cref="T:System.Web.UI.Adapters.ControlAdapter" />类，需要常规适配器功能的控件应具有相应的适配器基类，在模式中名为<paramref name="ControlType" /><see langword="Adapter" /> (例如， <see langword="TextBoxAdapter" />)。</span>
        <span class="sxs-lookup">
          <span data-stu-id="314a3-136">When you inherit from the <see cref="T:System.Web.UI.Adapters.ControlAdapter" /> class, a control that requires general adapter functionality should have a corresponding adapter base class, named in the pattern <paramref name="ControlType" /><see langword="Adapter" /> (for example, <see langword="TextBoxAdapter" />).</span>
        </span>
        <span data-ttu-id="314a3-137">适配器应至少返回通过控件的强类型实例及其<see cref="P:System.Web.UI.Adapters.ControlAdapter.Control" />属性。</span>
        <span class="sxs-lookup">
          <span data-stu-id="314a3-137">The adapter should at a minimum return a strongly-typed instance of the control through its <see cref="P:System.Web.UI.Adapters.ControlAdapter.Control" /> property.</span>
        </span>
        <span data-ttu-id="314a3-138">1.</span>
        <span class="sxs-lookup">
          <span data-stu-id="314a3-138">1.</span>
        </span>
        <span data-ttu-id="314a3-139">对于给定的控件类型和标记语言应命名模式中控制适配器<paramref name="MarkupControlType" /><see langword="Adapter" /> (例如， <see langword="XhtmlTextBoxAdapter" />)。</span>
        <span class="sxs-lookup">
          <span data-stu-id="314a3-139">Control adapters for a given control type and markup language should be named in the pattern <paramref name="MarkupControlType" /><see langword="Adapter" /> (for example, <see langword="XhtmlTextBoxAdapter" />).</span>
        </span>
        <span data-ttu-id="314a3-140">应在实现控件的适配器<see langword="Adapters" />子命名空间。</span>
        <span class="sxs-lookup">
          <span data-stu-id="314a3-140">Adapters for a control should be implemented in an <see langword="Adapters" /> subnamespace.</span>
        </span>
        <span data-ttu-id="314a3-141">控件适配器应继承自相应的基类，并遵循相同的继承模型为控件。</span>
        <span class="sxs-lookup">
          <span data-stu-id="314a3-141">Control adapters should inherit from the appropriate base class and follow the same inheritance model as the control.</span>
        </span>
        <span data-ttu-id="314a3-142">例如，从继承的控件的适配器<see cref="T:System.Web.UI.Control" />应该继承基类<see cref="T:System.Web.UI.Adapters.ControlAdapter" />类或相关<paramref name="ControlType" /><see langword="Adapter" />类。</span>
        <span class="sxs-lookup">
          <span data-stu-id="314a3-142">For example, an adapter for a control inheriting from the <see cref="T:System.Web.UI.Control" /> base class should inherit from either the <see cref="T:System.Web.UI.Adapters.ControlAdapter" /> class or the relevant <paramref name="ControlType" /><see langword="Adapter" /> class.</span>
        </span>
        <span data-ttu-id="314a3-143">应为专用控件下的所有配置.browser 文件中的设备节点定义任何专用的适配器。</span>
        <span class="sxs-lookup">
          <span data-stu-id="314a3-143">Any specialized adapters should be defined for the specialized control under all of the device nodes in configuration .browser files.</span>
        </span>
        <span data-ttu-id="314a3-144">正确实现的控件不应假定附加了适配器，或附加的适配器实现特定接口。</span>
        <span class="sxs-lookup">
          <span data-stu-id="314a3-144">A properly implemented control should not assume that an adapter is attached, or that the attached adapter implements a specific interface.</span>
        </span>
        <span data-ttu-id="314a3-145">相反，它应检查这些之前调用。</span>
        <span class="sxs-lookup">
          <span data-stu-id="314a3-145">Instead, it should check for these before calling.</span>
        </span>
        <span data-ttu-id="314a3-146">可以模拟重写受保护的事件方法在控件中，如<see cref="M:System.Web.UI.WebControls.LinkButton.OnClick(System.EventArgs)" />方法的<see cref="T:System.Web.UI.WebControls.LinkButton" />。</span>
        <span class="sxs-lookup">
          <span data-stu-id="314a3-146">It is possible to simulate overriding protected event methods in the control, such as the <see cref="M:System.Web.UI.WebControls.LinkButton.OnClick(System.EventArgs)" /> method of the <see cref="T:System.Web.UI.WebControls.LinkButton" />.</span>
        </span>
        <span data-ttu-id="314a3-147">首先，创建一种适配器类与<c>OnClick</c>方法。</span>
        <span class="sxs-lookup">
          <span data-stu-id="314a3-147">First, create an adapter class with an <c>OnClick</c> method.</span>
        </span>
        <span data-ttu-id="314a3-148">然后，创建新的控件派生自<see cref="T:System.Web.UI.WebControls.LinkButton" />并重写<see cref="M:System.Web.UI.WebControls.LinkButton.OnClick(System.EventArgs)" />方法。</span>
        <span class="sxs-lookup">
          <span data-stu-id="314a3-148">Then create a new control derived from <see cref="T:System.Web.UI.WebControls.LinkButton" /> and override the <see cref="M:System.Web.UI.WebControls.LinkButton.OnClick(System.EventArgs)" /> method.</span>
        </span>
        <span data-ttu-id="314a3-149">重写<see cref="M:System.Web.UI.WebControls.LinkButton.OnClick(System.EventArgs)" />方法调用<c>OnClick</c>适配器的方法。</span>
        <span class="sxs-lookup">
          <span data-stu-id="314a3-149">The overriden <see cref="M:System.Web.UI.WebControls.LinkButton.OnClick(System.EventArgs)" /> method calls the <c>OnClick</c> method of the adapter.</span>
        </span>
        <span data-ttu-id="314a3-150">该适配器对象是可通过受保护<see cref="P:System.Web.UI.Control.Adapter" />属性的<see cref="T:System.Web.UI.Control" />类。</span>
        <span class="sxs-lookup">
          <span data-stu-id="314a3-150">The adapter object is available through the protected <see cref="P:System.Web.UI.Control.Adapter" /> property of the <see cref="T:System.Web.UI.Control" /> class.</span>
        </span>
        <span data-ttu-id="314a3-151">
          <see cref="P:System.Web.UI.Control.Adapter" />控件的属性是<see langword="null" />时没有任何关联的适配器，因此任何代码应检查该条件之前调用该适配器的方法。</span>
        <span class="sxs-lookup">
          <span data-stu-id="314a3-151">The <see cref="P:System.Web.UI.Control.Adapter" /> property of the control is <see langword="null" /> when there is no associated adapter, so any code should check for that condition before calling methods of the adapter.</span>
        </span>
      </para>
    </block>
    <altmember cref="T:System.Web.UI.Control" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected ControlAdapter ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Adapters.ControlAdapter.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; ControlAdapter();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="314a3-152">初始化 <see cref="T:System.Web.UI.Adapters.ControlAdapter" /> 类的新实例。</span>
          <span class="sxs-lookup">
            <span data-stu-id="314a3-152">Initializes a new instance of the <see cref="T:System.Web.UI.Adapters.ControlAdapter" /> class.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="314a3-153">.NET Framework 在内部构建此适配器时它会创建相应<xref:System.Web.UI.Control>对象。</span><span class="sxs-lookup"><span data-stu-id="314a3-153">The .NET Framework internally constructs this adapter when it creates the corresponding <xref:System.Web.UI.Control> object.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.Control" />
      </Docs>
    </Member>
    <Member MemberName="BeginRender">
      <MemberSignature Language="C#" Value="protected internal virtual void BeginRender (System.Web.UI.HtmlTextWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void BeginRender(class System.Web.UI.HtmlTextWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Adapters.ControlAdapter.BeginRender(System.Web.UI.HtmlTextWriter)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub BeginRender (writer As HtmlTextWriter)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void BeginRender(System::Web::UI::HtmlTextWriter ^ writer);" />
      <MemberSignature Language="F#" Value="abstract member BeginRender : System.Web.UI.HtmlTextWriter -&gt; unit&#xA;override this.BeginRender : System.Web.UI.HtmlTextWriter -&gt; unit" Usage="controlAdapter.BeginRender writer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Web.UI.HtmlTextWriter" />
      </Parameters>
      <Docs>
        <param name="writer">
          <span data-ttu-id="314a3-154">包含可呈现特定于目标的输出的方法的 <see cref="T:System.Web.UI.HtmlTextWriter" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="314a3-154">The <see cref="T:System.Web.UI.HtmlTextWriter" /> containing methods to render the target-specific output.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="314a3-155">在呈现控件前调用。</span>
          <span class="sxs-lookup">
            <span data-stu-id="314a3-155">Called prior to the rendering of a control.</span>
          </span>
          <span data-ttu-id="314a3-156">在派生的 adapter 类中，生成特定目标需要但 HTML 浏览器不需要的开始标记。</span>
          <span class="sxs-lookup">
            <span data-stu-id="314a3-156">In a derived adapter class, generates opening tags that are required by a specific target but not needed by HTML browsers.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="314a3-157"><xref:System.Web.UI.Adapters.ControlAdapter.BeginRender%2A>之前调用方法<xref:System.Web.UI.Adapters.ControlAdapter.Render%2A>方法，并且用于执行特定于目标的预处理在呈现控件之前。</span><span class="sxs-lookup"><span data-stu-id="314a3-157">The <xref:System.Web.UI.Adapters.ControlAdapter.BeginRender%2A> method is called just before the <xref:System.Web.UI.Adapters.ControlAdapter.Render%2A> method, and is used to perform target-specific preprocessing before the rendering of the control.</span></span>  
  
 <span data-ttu-id="314a3-158">使用<xref:System.Web.UI.Adapters.ControlAdapter.BeginRender%2A>方法结合<xref:System.Web.UI.Adapters.ControlAdapter.EndRender%2A>方法，以确保开始和结束标记的一致性。</span><span class="sxs-lookup"><span data-stu-id="314a3-158">Use the <xref:System.Web.UI.Adapters.ControlAdapter.BeginRender%2A> method in combination with the <xref:System.Web.UI.Adapters.ControlAdapter.EndRender%2A> method to ensure opening and closing tag consistency.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <span data-ttu-id="314a3-159">继承自<see cref="T:System.Web.UI.Adapters.ControlAdapter" />类，<see cref="M:System.Web.UI.Adapters.ControlAdapter.BeginRender(System.Web.UI.HtmlTextWriter)" />基类的方法调用<see cref="M:System.Web.UI.HtmlTextWriter.BeginRender" />方法。</span>
            <span class="sxs-lookup">
              <span data-stu-id="314a3-159">When you inherit from the <see cref="T:System.Web.UI.Adapters.ControlAdapter" /> class, the <see cref="M:System.Web.UI.Adapters.ControlAdapter.BeginRender(System.Web.UI.HtmlTextWriter)" /> base method calls the <see cref="M:System.Web.UI.HtmlTextWriter.BeginRender" /> method.</span>
            </span>
            <span data-ttu-id="314a3-160">因此，重写<see cref="M:System.Web.UI.Adapters.ControlAdapter.BeginRender(System.Web.UI.HtmlTextWriter)" />方法应调用<see cref="M:System.Web.UI.Adapters.ControlAdapter.BeginRender(System.Web.UI.HtmlTextWriter)" />基方法，仅当其处理为除此之外，而不是而不是，<see cref="M:System.Web.UI.HtmlTextWriter.BeginRender" />方法。</span>
            <span class="sxs-lookup">
              <span data-stu-id="314a3-160">Thus, overrides of the <see cref="M:System.Web.UI.Adapters.ControlAdapter.BeginRender(System.Web.UI.HtmlTextWriter)" /> method should call the <see cref="M:System.Web.UI.Adapters.ControlAdapter.BeginRender(System.Web.UI.HtmlTextWriter)" /> base method only if its processing is in addition to, rather than instead of, the <see cref="M:System.Web.UI.HtmlTextWriter.BeginRender" /> method.</span>
            </span>
          </para>
        </block>
        <altmember cref="M:System.Web.UI.HtmlTextWriter.BeginRender" />
        <altmember cref="M:System.Web.UI.Adapters.ControlAdapter.Render(System.Web.UI.HtmlTextWriter)" />
        <altmember cref="M:System.Web.UI.Adapters.ControlAdapter.EndRender(System.Web.UI.HtmlTextWriter)" />
        <altmember cref="T:System.Web.UI.HtmlTextWriter" />
        <altmember cref="T:System.Web.UI.Control" />
      </Docs>
    </Member>
    <Member MemberName="Browser">
      <MemberSignature Language="C#" Value="protected System.Web.HttpBrowserCapabilities Browser { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.HttpBrowserCapabilities Browser" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Adapters.ControlAdapter.Browser" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property Browser As HttpBrowserCapabilities" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property System::Web::HttpBrowserCapabilities ^ Browser { System::Web::HttpBrowserCapabilities ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Browser : System.Web.HttpBrowserCapabilities" Usage="System.Web.UI.Adapters.ControlAdapter.Browser" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.HttpBrowserCapabilities</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="314a3-161">获取对发出当前 HTTP 请求的客户端的浏览器功能的引用。</span>
          <span class="sxs-lookup">
            <span data-stu-id="314a3-161">Gets a reference to the browser capabilities of the client making the current HTTP request.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="314a3-162">一个 <see cref="T:System.Web.HttpBrowserCapabilities" />，指定客户端浏览器和标记功能。</span>
          <span class="sxs-lookup">
            <span data-stu-id="314a3-162">An <see cref="T:System.Web.HttpBrowserCapabilities" /> specifying client browser and markup capabilities.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="314a3-163">一个<xref:System.Web.UI.Adapters.ControlAdapter>对象确定从客户端浏览器功能<xref:System.Web.HttpBrowserCapabilities>返回的对象<xref:System.Web.UI.Adapters.ControlAdapter.Browser%2A>属性。</span><span class="sxs-lookup"><span data-stu-id="314a3-163">A <xref:System.Web.UI.Adapters.ControlAdapter> object determines the client browser capabilities from the <xref:System.Web.HttpBrowserCapabilities> object that is returned by the <xref:System.Web.UI.Adapters.ControlAdapter.Browser%2A> property.</span></span> <span data-ttu-id="314a3-164">这使得<xref:System.Web.UI.Adapters.ControlAdapter>对象来呈现特定于浏览器的标记或以其他方式修改的行为<xref:System.Web.UI.Control>。</span><span class="sxs-lookup"><span data-stu-id="314a3-164">This enables the <xref:System.Web.UI.Adapters.ControlAdapter> object to render browser-specific markup or otherwise modify the behavior of the <xref:System.Web.UI.Control>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="314a3-165">下面的代码示例演示如何使用<xref:System.Web.UI.Adapters.ControlAdapter.Browser%2A>属性来访问请求的浏览器的详细信息。</span><span class="sxs-lookup"><span data-stu-id="314a3-165">The following code example shows how to use the <xref:System.Web.UI.Adapters.ControlAdapter.Browser%2A> property to access the details of the requesting browser.</span></span> <span data-ttu-id="314a3-166">在此示例中，代码会检查以确定是否在浏览器适用于 JavaScript，然后允许开发人员在这种情况下呈现自定义的输出。</span><span class="sxs-lookup"><span data-stu-id="314a3-166">In this example, the code checks to determine whether the browser is compatible with JavaScript, and then allows the developer to render customized output in that case.</span></span>  
  
 [!code-cpp[ControlAdapter_Browser#1](~/samples/snippets/cpp/VS_Snippets_WebNet/ControlAdapter_Browser/CPP/controladapter_browser.cpp#1)]
 [!code-csharp[ControlAdapter_Browser#1](~/samples/snippets/csharp/VS_Snippets_WebNet/ControlAdapter_Browser/CS/controladapter_browser.cs#1)]
 [!code-vb[ControlAdapter_Browser#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/ControlAdapter_Browser/VB/controladapter_browser.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.Control" />
        <altmember cref="T:System.Web.HttpBrowserCapabilities" />
        <altmember cref="T:System.Web.Configuration.HttpCapabilitiesBase" />
      </Docs>
    </Member>
    <Member MemberName="Control">
      <MemberSignature Language="C#" Value="protected System.Web.UI.Control Control { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.Control Control" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Adapters.ControlAdapter.Control" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property Control As Control" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property System::Web::UI::Control ^ Control { System::Web::UI::Control ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Control : System.Web.UI.Control" Usage="System.Web.UI.Adapters.ControlAdapter.Control" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.Control</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="314a3-167">获取对附加了此控件适配器的控件的引用。</span>
          <span class="sxs-lookup">
            <span data-stu-id="314a3-167">Gets a reference to the control to which this control adapter is attached.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="314a3-168">附加此 <see cref="T:System.Web.UI.Control" /> 的 <see cref="T:System.Web.UI.Adapters.ControlAdapter" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="314a3-168">The <see cref="T:System.Web.UI.Control" /> to which this <see cref="T:System.Web.UI.Adapters.ControlAdapter" /> is attached.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="314a3-169">当派生的控件适配器附加到控件时，.NET Framework 调用某些适配器成员而不是控件成员。</span><span class="sxs-lookup"><span data-stu-id="314a3-169">When a derived control adapter is attached to a control, the .NET Framework calls certain adapter members instead of the control members.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="314a3-170">下面的代码示例演示如何从自定义控件从<xref:System.Web.UI.Control>类，然后创建继承自的相应适配器<xref:System.Web.UI.Adapters.ControlAdapter>类。</span><span class="sxs-lookup"><span data-stu-id="314a3-170">The following code example shows how to derive a custom control from the <xref:System.Web.UI.Control> class, and then create a corresponding adapter that inherits from the <xref:System.Web.UI.Adapters.ControlAdapter> class.</span></span> <span data-ttu-id="314a3-171">适配器重写<xref:System.Web.UI.Adapters.ControlAdapter.Control%2A>属性，并返回控件的强类型引用。</span><span class="sxs-lookup"><span data-stu-id="314a3-171">The adapter overrides the <xref:System.Web.UI.Adapters.ControlAdapter.Control%2A> property and returns a strongly-typed reference to the control.</span></span>  
  
 [!code-cpp[ControlAdapter.Control#1](~/samples/snippets/cpp/VS_Snippets_WebNet/ControlAdapter.Control/CPP/controladapter.control.cpp#1)]
 [!code-csharp[ControlAdapter.Control#1](~/samples/snippets/csharp/VS_Snippets_WebNet/ControlAdapter.Control/CS/controladapter.control.cs#1)]
 [!code-vb[ControlAdapter.Control#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/ControlAdapter.Control/VB/controladapter.control.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <span data-ttu-id="314a3-172">继承自<see cref="T:System.Web.UI.Adapters.ControlAdapter" />类，最小值，则应实现<see langword="Control" />属性以返回该控件的强类型实例，如示例部分中所示。</span>
            <span class="sxs-lookup">
              <span data-stu-id="314a3-172">When you inherit from the <see cref="T:System.Web.UI.Adapters.ControlAdapter" /> class, at a minimum, you should implement a <see langword="Control" /> property to return a strongly-typed instance of the control, as shown in the Example section.</span>
            </span>
          </para>
        </block>
        <altmember cref="T:System.Web.UI.Control" />
      </Docs>
    </Member>
    <Member MemberName="CreateChildControls">
      <MemberSignature Language="C#" Value="protected internal virtual void CreateChildControls ();" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void CreateChildControls() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Adapters.ControlAdapter.CreateChildControls" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub CreateChildControls ()" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void CreateChildControls();" />
      <MemberSignature Language="F#" Value="abstract member CreateChildControls : unit -&gt; unit&#xA;override this.CreateChildControls : unit -&gt; unit" Usage="controlAdapter.CreateChildControls " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="314a3-173">为复合控件创建特定于目标的子控件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="314a3-173">Creates the target-specific child controls for a composite control.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="314a3-174">如果没有派生的控件适配器附加到<xref:System.Web.UI.Control>对象和<xref:System.Web.UI.Adapters.ControlAdapter.CreateChildControls%2A>重写方法，而不是调用该重写<xref:System.Web.UI.Control.CreateChildControls%2A?displayProperty=nameWithType>方法。</span><span class="sxs-lookup"><span data-stu-id="314a3-174">If there is a derived control adapter attached to a <xref:System.Web.UI.Control> object and the <xref:System.Web.UI.Adapters.ControlAdapter.CreateChildControls%2A> method is overridden, the override is called instead of the <xref:System.Web.UI.Control.CreateChildControls%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="314a3-175">因此，<xref:System.Web.UI.Adapters.ControlAdapter.CreateChildControls%2A>可用于创建特定于目标的子控件集。</span><span class="sxs-lookup"><span data-stu-id="314a3-175">Thus, <xref:System.Web.UI.Adapters.ControlAdapter.CreateChildControls%2A> can be used to create a target-specific child control set.</span></span>  
  
 <span data-ttu-id="314a3-176">有关组合控件来创建新控件的详细信息，请参阅[复合控件](http://msdn.microsoft.com/library/fb174677-d845-467c-8bf3-cc096b2490b0)。</span><span class="sxs-lookup"><span data-stu-id="314a3-176">For more information about combining controls to create a new control, see [Composite Controls](http://msdn.microsoft.com/library/fb174677-d845-467c-8bf3-cc096b2490b0).</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <span data-ttu-id="314a3-177">如果创建继承的类并重写<see cref="M:System.Web.UI.Adapters.ControlAdapter.CreateChildControls" />方法，则不要调用基方法，除非你想要将控件添加到所创建的基方法。</span>
            <span class="sxs-lookup">
              <span data-stu-id="314a3-177">If you create an inheriting class and override the <see cref="M:System.Web.UI.Adapters.ControlAdapter.CreateChildControls" /> method, do not call the base method unless you want to add controls to those created by the base method.</span>
            </span>
            <span data-ttu-id="314a3-178">否则可以创建两个集的子控件。</span>
            <span class="sxs-lookup">
              <span data-stu-id="314a3-178">Otherwise you could create two sets of child controls.</span>
            </span>
          </para>
        </block>
        <altmember cref="M:System.Web.UI.Control.CreateChildControls" />
        <altmember cref="T:System.Web.UI.Control" />
      </Docs>
    </Member>
    <Member MemberName="EndRender">
      <MemberSignature Language="C#" Value="protected internal virtual void EndRender (System.Web.UI.HtmlTextWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void EndRender(class System.Web.UI.HtmlTextWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Adapters.ControlAdapter.EndRender(System.Web.UI.HtmlTextWriter)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub EndRender (writer As HtmlTextWriter)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void EndRender(System::Web::UI::HtmlTextWriter ^ writer);" />
      <MemberSignature Language="F#" Value="abstract member EndRender : System.Web.UI.HtmlTextWriter -&gt; unit&#xA;override this.EndRender : System.Web.UI.HtmlTextWriter -&gt; unit" Usage="controlAdapter.EndRender writer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Web.UI.HtmlTextWriter" />
      </Parameters>
      <Docs>
        <param name="writer">
          <span data-ttu-id="314a3-179">包含可呈现特定于目标的输出的方法的 <see cref="T:System.Web.UI.HtmlTextWriter" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="314a3-179">The <see cref="T:System.Web.UI.HtmlTextWriter" /> containing methods to render the target-specific output.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="314a3-180">在呈现控件后调用。</span>
          <span class="sxs-lookup">
            <span data-stu-id="314a3-180">Called after the rendering of a control.</span>
          </span>
          <span data-ttu-id="314a3-181">在派生的 adapter 类中，生成特定目标需要但 HTML 浏览器不需要的结束标记。</span>
          <span class="sxs-lookup">
            <span data-stu-id="314a3-181">In a derived adapter class, generates closing tags that are required by a specific target but not needed by HTML browsers.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="314a3-182"><xref:System.Web.UI.Adapters.ControlAdapter.EndRender%2A>紧随其后调用方法<xref:System.Web.UI.Adapters.ControlAdapter.Render%2A>方法，并且用于在呈现控件后执行特定于目标的后续处理。</span><span class="sxs-lookup"><span data-stu-id="314a3-182">The <xref:System.Web.UI.Adapters.ControlAdapter.EndRender%2A> method is called just after the <xref:System.Web.UI.Adapters.ControlAdapter.Render%2A> method, and is used to perform target-specific postprocessing after the rendering of the control.</span></span>  
  
 <span data-ttu-id="314a3-183">使用<xref:System.Web.UI.Adapters.ControlAdapter.EndRender%2A>方法结合<xref:System.Web.UI.Adapters.ControlAdapter.BeginRender%2A>方法，以确保开始和结束标记的一致性。</span><span class="sxs-lookup"><span data-stu-id="314a3-183">Use the <xref:System.Web.UI.Adapters.ControlAdapter.EndRender%2A> method in combination with the <xref:System.Web.UI.Adapters.ControlAdapter.BeginRender%2A> method to ensure opening and closing tag consistency.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <span data-ttu-id="314a3-184">继承自<see cref="T:System.Web.UI.Adapters.ControlAdapter" />类，<see cref="M:System.Web.UI.Adapters.ControlAdapter.EndRender(System.Web.UI.HtmlTextWriter)" />基类的方法调用<see cref="M:System.Web.UI.HtmlTextWriter.EndRender" />方法。</span>
            <span class="sxs-lookup">
              <span data-stu-id="314a3-184">When you inherit from the <see cref="T:System.Web.UI.Adapters.ControlAdapter" /> class, the <see cref="M:System.Web.UI.Adapters.ControlAdapter.EndRender(System.Web.UI.HtmlTextWriter)" /> base method calls the <see cref="M:System.Web.UI.HtmlTextWriter.EndRender" /> method.</span>
            </span>
            <span data-ttu-id="314a3-185">因此，重写<see cref="M:System.Web.UI.Adapters.ControlAdapter.EndRender(System.Web.UI.HtmlTextWriter)" />方法应调用<see cref="M:System.Web.UI.Adapters.ControlAdapter.EndRender(System.Web.UI.HtmlTextWriter)" />基方法，仅当其处理为除此之外，而不是而不是，<see cref="M:System.Web.UI.HtmlTextWriter.EndRender" />方法。</span>
            <span class="sxs-lookup">
              <span data-stu-id="314a3-185">Thus, overrides of the <see cref="M:System.Web.UI.Adapters.ControlAdapter.EndRender(System.Web.UI.HtmlTextWriter)" /> method should call the <see cref="M:System.Web.UI.Adapters.ControlAdapter.EndRender(System.Web.UI.HtmlTextWriter)" /> base method only if its processing is in addition to, rather than instead of, the <see cref="M:System.Web.UI.HtmlTextWriter.EndRender" /> method.</span>
            </span>
          </para>
        </block>
        <altmember cref="M:System.Web.UI.HtmlTextWriter.EndRender" />
        <altmember cref="M:System.Web.UI.Adapters.ControlAdapter.Render(System.Web.UI.HtmlTextWriter)" />
        <altmember cref="M:System.Web.UI.Adapters.ControlAdapter.BeginRender(System.Web.UI.HtmlTextWriter)" />
        <altmember cref="T:System.Web.UI.HtmlTextWriter" />
        <altmember cref="T:System.Web.UI.Control" />
      </Docs>
    </Member>
    <Member MemberName="LoadAdapterControlState">
      <MemberSignature Language="C#" Value="protected internal virtual void LoadAdapterControlState (object state);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void LoadAdapterControlState(object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Adapters.ControlAdapter.LoadAdapterControlState(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub LoadAdapterControlState (state As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void LoadAdapterControlState(System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member LoadAdapterControlState : obj -&gt; unit&#xA;override this.LoadAdapterControlState : obj -&gt; unit" Usage="controlAdapter.LoadAdapterControlState state" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="state">
          <span data-ttu-id="314a3-186">一个 <see cref="T:System.Object" />，其中包含适配器的控件状态信息作为 <see cref="T:System.Web.UI.StateBag" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="314a3-186">An <see cref="T:System.Object" /> that contains the adapter's control state information as a <see cref="T:System.Web.UI.StateBag" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="314a3-187">加载适配器控件状态信息，该信息由 <see cref="M:System.Web.UI.Adapters.ControlAdapter.SaveAdapterControlState" /> 在以前请求与此控件适配器关联的控件所驻留的页时保存。</span>
          <span class="sxs-lookup">
            <span data-stu-id="314a3-187">Loads adapter control state information that was saved by <see cref="M:System.Web.UI.Adapters.ControlAdapter.SaveAdapterControlState" /> during a previous request to the page where the control associated with this control adapter resides.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="314a3-188">控件状态是即使禁用了视图状态所需的基本状态信息。</span><span class="sxs-lookup"><span data-stu-id="314a3-188">Control state is the essential state information needed even if view state is disabled.</span></span> <span data-ttu-id="314a3-189">当适配器需要维护其自己的控件状态信息时，它会重写<xref:System.Web.UI.Adapters.ControlAdapter.LoadAdapterControlState%2A>和<xref:System.Web.UI.Adapters.ControlAdapter.SaveAdapterControlState%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="314a3-189">When an adapter needs to maintain its own control state information, it can override the <xref:System.Web.UI.Adapters.ControlAdapter.LoadAdapterControlState%2A> and <xref:System.Web.UI.Adapters.ControlAdapter.SaveAdapterControlState%2A> methods.</span></span>  
  
 <span data-ttu-id="314a3-190">适配器可能需要在有需要在请求中，独立于关联控件的状态之间维护状态的功能时保持控件状态信息。</span><span class="sxs-lookup"><span data-stu-id="314a3-190">An adapter might need to maintain control state information when there are features that need to have state maintained across requests, independent from the state of the associated control.</span></span> <span data-ttu-id="314a3-191">例如，大型文本显示和一组组成的复合控件<xref:System.Web.UI.WebControls.RadioButton>控件可能会呈现为台式计算机浏览器上的单一视图。</span><span class="sxs-lookup"><span data-stu-id="314a3-191">For example, a composite control consisting of a large textual display and a group of <xref:System.Web.UI.WebControls.RadioButton> controls might render as a single view on desktop computer browsers.</span></span> <span data-ttu-id="314a3-192">在其他浏览器，它可能会拆分其呈现 — 用于文本显示，另一个用于单选按钮组的一个视图。</span><span class="sxs-lookup"><span data-stu-id="314a3-192">On other browsers, it might split its rendering—one view for the textual display and the other for the radio button group.</span></span> <span data-ttu-id="314a3-193">适配器需要维护其自己的特定于目标的信息有关当前处于活动状态的视图。</span><span class="sxs-lookup"><span data-stu-id="314a3-193">The adapter would need to maintain its own target-specific information about the currently active view.</span></span>  
  
 <span data-ttu-id="314a3-194"><xref:System.Web.UI.Adapters.ControlAdapter.LoadAdapterControlState%2A>方法后立即调用<xref:System.Web.UI.Control.LoadControlState%2A?displayProperty=nameWithType>方法，请在`LoadState`生命周期阶段。</span><span class="sxs-lookup"><span data-stu-id="314a3-194">The <xref:System.Web.UI.Adapters.ControlAdapter.LoadAdapterControlState%2A> method is called immediately after the <xref:System.Web.UI.Control.LoadControlState%2A?displayProperty=nameWithType> method, in the `LoadState` lifecycle stage.</span></span> <span data-ttu-id="314a3-195">适配器控件状态是独立且除了该控件的控件状态。</span><span class="sxs-lookup"><span data-stu-id="314a3-195">The adapter control state is separate and in addition to the control state of the control.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Control.LoadControlState(System.Object)" />
        <altmember cref="T:System.Web.UI.Control" />
        <altmember cref="M:System.Web.UI.Adapters.ControlAdapter.SaveAdapterControlState" />
        <altmember cref="M:System.Web.UI.Adapters.ControlAdapter.LoadAdapterViewState(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="LoadAdapterViewState">
      <MemberSignature Language="C#" Value="protected internal virtual void LoadAdapterViewState (object state);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void LoadAdapterViewState(object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Adapters.ControlAdapter.LoadAdapterViewState(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub LoadAdapterViewState (state As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void LoadAdapterViewState(System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member LoadAdapterViewState : obj -&gt; unit&#xA;override this.LoadAdapterViewState : obj -&gt; unit" Usage="controlAdapter.LoadAdapterViewState state" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="state">
          <span data-ttu-id="314a3-196">一个 <see cref="T:System.Object" />，其中包含适配器视图的状态信息作为 <see cref="T:System.Web.UI.StateBag" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="314a3-196">An <see cref="T:System.Object" /> that contains the adapter view state information as a <see cref="T:System.Web.UI.StateBag" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="314a3-197">加载适配器视图状态信息，该信息由 <see cref="M:System.Web.UI.Adapters.ControlAdapter.SaveAdapterViewState" /> 在以前请求与此控件适配器关联的控件所驻留的页时保存。</span>
          <span class="sxs-lookup">
            <span data-stu-id="314a3-197">Loads adapter view state information that was saved by <see cref="M:System.Web.UI.Adapters.ControlAdapter.SaveAdapterViewState" /> during a previous request to the page where the control associated with this control adapter resides.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="314a3-198">当适配器需要维护其自己的视图状态信息时，它会重写<xref:System.Web.UI.Adapters.ControlAdapter.LoadAdapterViewState%2A>和<xref:System.Web.UI.Adapters.ControlAdapter.SaveAdapterViewState%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="314a3-198">When an adapter needs to maintain its own view state information, it can override the <xref:System.Web.UI.Adapters.ControlAdapter.LoadAdapterViewState%2A> and <xref:System.Web.UI.Adapters.ControlAdapter.SaveAdapterViewState%2A> methods.</span></span>  
  
 <span data-ttu-id="314a3-199">适配器需要在请求中，独立于关联控件的视图状态之间必须保持的数据时维护视图状态信息。</span><span class="sxs-lookup"><span data-stu-id="314a3-199">An adapter needs to maintain view state information when there is data that must be maintained across requests, independent from the view state of the associated control.</span></span> <span data-ttu-id="314a3-200">例如，在台式计算机浏览器上的网格控件可能会呈现为单个视图的行和列的值。</span><span class="sxs-lookup"><span data-stu-id="314a3-200">For example, a grid control on desktop computer browsers might render as a single view of rows and columns of values.</span></span> <span data-ttu-id="314a3-201">在其他浏览器，它可能会拆分为多个单独的视图，如行和详细信息的单个行的列表及其呈现。</span><span class="sxs-lookup"><span data-stu-id="314a3-201">On other browsers, it might split its rendering into multiple separate views, such as a list of rows and details of a single row.</span></span> <span data-ttu-id="314a3-202">适配器需要维护视图状态中不是当前处于活动状态的视图的数据。</span><span class="sxs-lookup"><span data-stu-id="314a3-202">The adapter would need to maintain the data for the views that are not currently active in view state.</span></span>  
  
 <span data-ttu-id="314a3-203"><xref:System.Web.UI.Adapters.ControlAdapter.LoadAdapterViewState%2A>方法调用之前<xref:System.Web.UI.Control.LoadViewState%2A?displayProperty=nameWithType>中的方法`LoadState`生命周期阶段。</span><span class="sxs-lookup"><span data-stu-id="314a3-203">The <xref:System.Web.UI.Adapters.ControlAdapter.LoadAdapterViewState%2A> method is called immediately before the <xref:System.Web.UI.Control.LoadViewState%2A?displayProperty=nameWithType> method in the `LoadState` lifecycle stage.</span></span> <span data-ttu-id="314a3-204">适配器视图状态是独立且除了该控件的视图状态。</span><span class="sxs-lookup"><span data-stu-id="314a3-204">The adapter view state is separate and in addition to the view state of the control.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Control.LoadViewState(System.Object)" />
        <altmember cref="T:System.Web.UI.Control" />
        <altmember cref="M:System.Web.UI.Adapters.ControlAdapter.SaveAdapterViewState" />
        <altmember cref="M:System.Web.UI.Adapters.ControlAdapter.LoadAdapterControlState(System.Object)" />
        <altmember cref="P:System.Web.UI.Control.ViewState" />
      </Docs>
    </Member>
    <Member MemberName="OnInit">
      <MemberSignature Language="C#" Value="protected internal virtual void OnInit (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnInit(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Adapters.ControlAdapter.OnInit(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnInit (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnInit(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnInit : EventArgs -&gt; unit&#xA;override this.OnInit : EventArgs -&gt; unit" Usage="controlAdapter.OnInit e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="314a3-205">包含事件数据的 <see cref="T:System.EventArgs" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="314a3-205">An <see cref="T:System.EventArgs" /> that contains the event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="314a3-206">重写关联控件的 <see cref="M:System.Web.UI.Control.OnInit(System.EventArgs)" /> 方法。</span>
          <span class="sxs-lookup">
            <span data-stu-id="314a3-206">Overrides the <see cref="M:System.Web.UI.Control.OnInit(System.EventArgs)" /> method for the associated control.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="314a3-207">如果没有适配器连接到<xref:System.Web.UI.Control>对象和<xref:System.Web.UI.Adapters.ControlAdapter.OnInit%2A>重写方法，重写方法调用而不是<xref:System.Web.UI.Control.OnInit%2A?displayProperty=nameWithType>方法。</span><span class="sxs-lookup"><span data-stu-id="314a3-207">If there is an adapter attached to a <xref:System.Web.UI.Control> object and the <xref:System.Web.UI.Adapters.ControlAdapter.OnInit%2A> method is overridden, the override method is called instead of the <xref:System.Web.UI.Control.OnInit%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="314a3-208">重写<xref:System.Web.UI.Adapters.ControlAdapter.OnInit%2A>来执行特定于目标的处理中`Initialize`控件生命周期阶段。</span><span class="sxs-lookup"><span data-stu-id="314a3-208">Override <xref:System.Web.UI.Adapters.ControlAdapter.OnInit%2A> to perform target-specific processing in the `Initialize` stage of the control lifecycle.</span></span> <span data-ttu-id="314a3-209">通常情况下，它们是创建一个控件时，将执行的函数。</span><span class="sxs-lookup"><span data-stu-id="314a3-209">Typically, these are functions that are performed when a control is created.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="314a3-210">下面的代码示例都派生自定义控件适配器从<xref:System.Web.UI.Adapters.ControlAdapter>类。</span><span class="sxs-lookup"><span data-stu-id="314a3-210">The following code sample derives a custom control adapter from the <xref:System.Web.UI.Adapters.ControlAdapter> class.</span></span> <span data-ttu-id="314a3-211">然后它将替代<xref:System.Web.UI.Adapters.ControlAdapter.OnInit%2A>方法关联的控件上设置属性并调用基方法，以完成控件的初始化。</span><span class="sxs-lookup"><span data-stu-id="314a3-211">It then overrides the <xref:System.Web.UI.Adapters.ControlAdapter.OnInit%2A> method to set a property on the associated control and call the base method to complete the control initialization.</span></span>  
  
 [!code-cpp[ControlAdapter_OnInit#1](~/samples/snippets/cpp/VS_Snippets_WebNet/ControlAdapter_OnInit/CPP/controladapter_oninit.cpp#1)]
 [!code-csharp[ControlAdapter_OnInit#1](~/samples/snippets/csharp/VS_Snippets_WebNet/ControlAdapter_OnInit/CS/controladapter_oninit.cs#1)]
 [!code-vb[ControlAdapter_OnInit#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/ControlAdapter_OnInit/VB/controladapter_oninit.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <span data-ttu-id="314a3-212">继承自<see cref="T:System.Web.UI.Adapters.ControlAdapter" />类，适配器并重写<see cref="M:System.Web.UI.Adapters.ControlAdapter.OnInit(System.EventArgs)" />方法中，适配器必须调用相应的基类方法又调用<see cref="M:System.Web.UI.Control.OnInit(System.EventArgs)" />方法。</span>
            <span class="sxs-lookup">
              <span data-stu-id="314a3-212">When you inherit from the <see cref="T:System.Web.UI.Adapters.ControlAdapter" /> class and the adapter overrides the <see cref="M:System.Web.UI.Adapters.ControlAdapter.OnInit(System.EventArgs)" /> method, the adapter must call the corresponding base class method, which in turn calls the <see cref="M:System.Web.UI.Control.OnInit(System.EventArgs)" /> method.</span>
            </span>
            <span data-ttu-id="314a3-213">如果<see cref="M:System.Web.UI.Control.OnInit(System.EventArgs)" />不会调用方法，<see cref="E:System.Web.UI.Control.Init" />不会引发事件。</span>
            <span class="sxs-lookup">
              <span data-stu-id="314a3-213">If the <see cref="M:System.Web.UI.Control.OnInit(System.EventArgs)" /> method is not called, the <see cref="E:System.Web.UI.Control.Init" /> event will not be raised.</span>
            </span>
          </para>
        </block>
        <altmember cref="E:System.Web.UI.Control.Init" />
        <altmember cref="M:System.Web.UI.Control.OnInit(System.EventArgs)" />
        <altmember cref="T:System.Web.UI.Control" />
      </Docs>
    </Member>
    <Member MemberName="OnLoad">
      <MemberSignature Language="C#" Value="protected internal virtual void OnLoad (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnLoad(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Adapters.ControlAdapter.OnLoad(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnLoad (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnLoad(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnLoad : EventArgs -&gt; unit&#xA;override this.OnLoad : EventArgs -&gt; unit" Usage="controlAdapter.OnLoad e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="314a3-214">包含事件数据的 <see cref="T:System.EventArgs" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="314a3-214">An <see cref="T:System.EventArgs" /> that contains the event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="314a3-215">重写关联控件的 <see cref="M:System.Web.UI.Control.OnLoad(System.EventArgs)" /> 方法。</span>
          <span class="sxs-lookup">
            <span data-stu-id="314a3-215">Overrides the <see cref="M:System.Web.UI.Control.OnLoad(System.EventArgs)" /> method for the associated control.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="314a3-216">如果没有适配器连接到<xref:System.Web.UI.Control>对象和<xref:System.Web.UI.Adapters.ControlAdapter.OnLoad%2A>重写方法，重写方法调用而不是<xref:System.Web.UI.Control.OnLoad%2A?displayProperty=nameWithType>方法。</span><span class="sxs-lookup"><span data-stu-id="314a3-216">If there is an adapter attached to a <xref:System.Web.UI.Control> object and the <xref:System.Web.UI.Adapters.ControlAdapter.OnLoad%2A> method is overridden, the override method is called instead of the <xref:System.Web.UI.Control.OnLoad%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="314a3-217">重写<xref:System.Web.UI.Adapters.ControlAdapter.OnLoad%2A>方法来执行特定于目标的处理中`Load`控件生命周期阶段。</span><span class="sxs-lookup"><span data-stu-id="314a3-217">Override the <xref:System.Web.UI.Adapters.ControlAdapter.OnLoad%2A> method to perform target-specific processing in the `Load` stage of the control lifecycle.</span></span> <span data-ttu-id="314a3-218">通常情况下，它们应为每个客户端请求执行的函数。</span><span class="sxs-lookup"><span data-stu-id="314a3-218">Typically, these are functions that should be performed for each client request.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <span data-ttu-id="314a3-219">继承自<see cref="T:System.Web.UI.Adapters.ControlAdapter" />类，适配器并重写<see cref="M:System.Web.UI.Adapters.ControlAdapter.OnLoad(System.EventArgs)" />方法中，适配器必须调用相应的基类方法又调用<see cref="M:System.Web.UI.Control.OnLoad(System.EventArgs)" />方法。</span>
            <span class="sxs-lookup">
              <span data-stu-id="314a3-219">When you inherit from the <see cref="T:System.Web.UI.Adapters.ControlAdapter" /> class and the adapter overrides the <see cref="M:System.Web.UI.Adapters.ControlAdapter.OnLoad(System.EventArgs)" /> method, the adapter must call the corresponding base class method, which in turn calls the <see cref="M:System.Web.UI.Control.OnLoad(System.EventArgs)" /> method.</span>
            </span>
            <span data-ttu-id="314a3-220">如果<see cref="M:System.Web.UI.Control.OnLoad(System.EventArgs)" />未调用<see cref="E:System.Web.UI.Control.Load" />不会引发事件。</span>
            <span class="sxs-lookup">
              <span data-stu-id="314a3-220">If <see cref="M:System.Web.UI.Control.OnLoad(System.EventArgs)" /> is not called, the <see cref="E:System.Web.UI.Control.Load" /> event will not be raised.</span>
            </span>
          </para>
        </block>
        <altmember cref="E:System.Web.UI.Control.Load" />
        <altmember cref="M:System.Web.UI.Control.OnLoad(System.EventArgs)" />
        <altmember cref="T:System.Web.UI.Control" />
      </Docs>
    </Member>
    <Member MemberName="OnPreRender">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreRender (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreRender(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Adapters.ControlAdapter.OnPreRender(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreRender (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreRender(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreRender : EventArgs -&gt; unit&#xA;override this.OnPreRender : EventArgs -&gt; unit" Usage="controlAdapter.OnPreRender e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="314a3-221">包含事件数据的 <see cref="T:System.EventArgs" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="314a3-221">An <see cref="T:System.EventArgs" /> that contains the event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="314a3-222">重写关联控件的 <see cref="M:System.Web.UI.Control.OnPreRender(System.EventArgs)" /> 方法。</span>
          <span class="sxs-lookup">
            <span data-stu-id="314a3-222">Overrides the <see cref="M:System.Web.UI.Control.OnPreRender(System.EventArgs)" /> method for the associated control.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="314a3-223">如果没有适配器连接到<xref:System.Web.UI.Control>对象和<xref:System.Web.UI.Adapters.ControlAdapter.OnPreRender%2A>重写方法，重写方法调用而不是<xref:System.Web.UI.Control.OnPreRender%2A?displayProperty=nameWithType>方法。</span><span class="sxs-lookup"><span data-stu-id="314a3-223">If there is an adapter attached to a <xref:System.Web.UI.Control> object and the <xref:System.Web.UI.Adapters.ControlAdapter.OnPreRender%2A> method is overridden, the override method is called instead of the <xref:System.Web.UI.Control.OnPreRender%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="314a3-224">重写<xref:System.Web.UI.Adapters.ControlAdapter.OnPreRender%2A>方法来执行特定于目标的处理中`PreRender`控件生命周期阶段。</span><span class="sxs-lookup"><span data-stu-id="314a3-224">Override the <xref:System.Web.UI.Adapters.ControlAdapter.OnPreRender%2A> method to perform target-specific processing in the `PreRender` stage of the control lifecycle.</span></span> <span data-ttu-id="314a3-225">通常情况下，这些是紧跟呈现控件输出的函数。</span><span class="sxs-lookup"><span data-stu-id="314a3-225">Typically, these are functions that immediately precede rendering of the control output.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <span data-ttu-id="314a3-226">继承自<see cref="T:System.Web.UI.Adapters.ControlAdapter" />类，适配器并重写<see cref="M:System.Web.UI.Adapters.ControlAdapter.OnPreRender(System.EventArgs)" />方法中，适配器必须调用相应的基类方法又调用<see cref="M:System.Web.UI.Control.OnPreRender(System.EventArgs)" />方法。</span>
            <span class="sxs-lookup">
              <span data-stu-id="314a3-226">When you inherit from the <see cref="T:System.Web.UI.Adapters.ControlAdapter" /> class and the adapter overrides the <see cref="M:System.Web.UI.Adapters.ControlAdapter.OnPreRender(System.EventArgs)" /> method, the adapter must call the corresponding base class method, which in turn calls the <see cref="M:System.Web.UI.Control.OnPreRender(System.EventArgs)" /> method.</span>
            </span>
            <span data-ttu-id="314a3-227">如果<see cref="M:System.Web.UI.Control.OnPreRender(System.EventArgs)" />不会调用方法，<see cref="E:System.Web.UI.Control.PreRender" />不会引发事件。</span>
            <span class="sxs-lookup">
              <span data-stu-id="314a3-227">If the <see cref="M:System.Web.UI.Control.OnPreRender(System.EventArgs)" /> method is not called, the <see cref="E:System.Web.UI.Control.PreRender" /> event will not be raised.</span>
            </span>
          </para>
        </block>
        <altmember cref="E:System.Web.UI.Control.PreRender" />
        <altmember cref="M:System.Web.UI.Control.OnPreRender(System.EventArgs)" />
        <altmember cref="T:System.Web.UI.Control" />
      </Docs>
    </Member>
    <Member MemberName="OnUnload">
      <MemberSignature Language="C#" Value="protected internal virtual void OnUnload (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnUnload(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Adapters.ControlAdapter.OnUnload(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnUnload (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnUnload(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnUnload : EventArgs -&gt; unit&#xA;override this.OnUnload : EventArgs -&gt; unit" Usage="controlAdapter.OnUnload e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="314a3-228">包含事件数据的 <see cref="T:System.EventArgs" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="314a3-228">An <see cref="T:System.EventArgs" /> that contains the event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="314a3-229">重写关联控件的 <see cref="M:System.Web.UI.Control.OnUnload(System.EventArgs)" /> 方法。</span>
          <span class="sxs-lookup">
            <span data-stu-id="314a3-229">Overrides the <see cref="M:System.Web.UI.Control.OnUnload(System.EventArgs)" /> method for the associated control.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="314a3-230">如果没有适配器连接到<xref:System.Web.UI.Control>对象和<xref:System.Web.UI.Adapters.ControlAdapter.OnUnload%2A>重写方法，重写方法调用而不是<xref:System.Web.UI.Control.OnUnload%2A?displayProperty=nameWithType>方法。</span><span class="sxs-lookup"><span data-stu-id="314a3-230">If there is an adapter attached to a <xref:System.Web.UI.Control> object and the <xref:System.Web.UI.Adapters.ControlAdapter.OnUnload%2A> method is overridden, the override method is called instead of the <xref:System.Web.UI.Control.OnUnload%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="314a3-231">重写<xref:System.Web.UI.Adapters.ControlAdapter.OnUnload%2A>方法来执行特定于目标的处理操作`Unload`控件生命周期阶段。</span><span class="sxs-lookup"><span data-stu-id="314a3-231">Override the <xref:System.Web.UI.Adapters.ControlAdapter.OnUnload%2A> method to do target-specific processing in the `Unload` stage of the control lifecycle.</span></span> <span data-ttu-id="314a3-232">通常情况下，这些是前加上处理控件的清理功能。</span><span class="sxs-lookup"><span data-stu-id="314a3-232">Typically, these are cleanup functions that precede disposition of the control.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <span data-ttu-id="314a3-233">继承自<see cref="T:System.Web.UI.Adapters.ControlAdapter" />类，适配器并重写<see cref="M:System.Web.UI.Adapters.ControlAdapter.OnUnload(System.EventArgs)" />方法中，适配器必须调用相应的基类方法又调用<see cref="M:System.Web.UI.Control.OnUnload(System.EventArgs)" />方法。</span>
            <span class="sxs-lookup">
              <span data-stu-id="314a3-233">When you inherit from the <see cref="T:System.Web.UI.Adapters.ControlAdapter" /> class and the adapter overrides the <see cref="M:System.Web.UI.Adapters.ControlAdapter.OnUnload(System.EventArgs)" /> method, the adapter must call the corresponding base class method, which in turn calls the <see cref="M:System.Web.UI.Control.OnUnload(System.EventArgs)" /> method.</span>
            </span>
            <span data-ttu-id="314a3-234">如果<see cref="M:System.Web.UI.Control.OnUnload(System.EventArgs)" />未调用<see cref="E:System.Web.UI.Control.Unload" />不会引发事件。</span>
            <span class="sxs-lookup">
              <span data-stu-id="314a3-234">If <see cref="M:System.Web.UI.Control.OnUnload(System.EventArgs)" /> is not called, the <see cref="E:System.Web.UI.Control.Unload" /> event will not be raised.</span>
            </span>
          </para>
        </block>
        <altmember cref="E:System.Web.UI.Control.Unload" />
        <altmember cref="M:System.Web.UI.Control.OnUnload(System.EventArgs)" />
        <altmember cref="T:System.Web.UI.Control" />
      </Docs>
    </Member>
    <Member MemberName="Page">
      <MemberSignature Language="C#" Value="protected System.Web.UI.Page Page { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.Page Page" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Adapters.ControlAdapter.Page" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property Page As Page" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property System::Web::UI::Page ^ Page { System::Web::UI::Page ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Page : System.Web.UI.Page" Usage="System.Web.UI.Adapters.ControlAdapter.Page" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.Page</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="314a3-235">获取对与此适配器关联的控件所驻留的页的引用。</span>
          <span class="sxs-lookup">
            <span data-stu-id="314a3-235">Gets a reference to the page where the control associated with this adapter resides.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="314a3-236">一个 <see cref="T:System.Web.UI.Page" />，可提供对关联控件所在的页实例的访问权限。</span>
          <span class="sxs-lookup">
            <span data-stu-id="314a3-236">A <see cref="T:System.Web.UI.Page" /> that provides access to the page instance where the associated control is situated.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="314a3-237"><xref:System.Web.UI.Adapters.ControlAdapter.Page%2A>属性提供对访问<xref:System.Web.UI.Page?displayProperty=nameWithType>控件所在的对象。</span><span class="sxs-lookup"><span data-stu-id="314a3-237">The <xref:System.Web.UI.Adapters.ControlAdapter.Page%2A> property provides access to the <xref:System.Web.UI.Page?displayProperty=nameWithType> object where the control is situated.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.Page" />
        <altmember cref="T:System.Web.UI.Control" />
      </Docs>
    </Member>
    <Member MemberName="PageAdapter">
      <MemberSignature Language="C#" Value="protected System.Web.UI.Adapters.PageAdapter PageAdapter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.Adapters.PageAdapter PageAdapter" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Adapters.ControlAdapter.PageAdapter" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property PageAdapter As PageAdapter" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property System::Web::UI::Adapters::PageAdapter ^ PageAdapter { System::Web::UI::Adapters::PageAdapter ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.PageAdapter : System.Web.UI.Adapters.PageAdapter" Usage="System.Web.UI.Adapters.ControlAdapter.PageAdapter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.Adapters.PageAdapter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="314a3-238">获取对关联控件所驻留的页的页适配器的引用。</span>
          <span class="sxs-lookup">
            <span data-stu-id="314a3-238">Gets a reference to the page adapter for the page where the associated control resides.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="314a3-239">用于与当前 <see cref="T:System.Web.UI.Adapters.PageAdapter" /> 关联的控件所在的页的 <see cref="T:System.Web.UI.Adapters.ControlAdapter" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="314a3-239">A <see cref="T:System.Web.UI.Adapters.PageAdapter" /> for the page where the control associated with the current <see cref="T:System.Web.UI.Adapters.ControlAdapter" /> is situated.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="314a3-240"><xref:System.Web.UI.Adapters.ControlAdapter.PageAdapter%2A>属性提供访问权限<xref:System.Web.UI.Adapters.PageAdapter?displayProperty=nameWithType>对象<xref:System.Web.UI.Page>对象的<xref:System.Web.UI.Control>关联与当前对象<xref:System.Web.UI.Adapters.ControlAdapter>对象的权限。</span><span class="sxs-lookup"><span data-stu-id="314a3-240">The <xref:System.Web.UI.Adapters.ControlAdapter.PageAdapter%2A> property provides access to the <xref:System.Web.UI.Adapters.PageAdapter?displayProperty=nameWithType> object for the <xref:System.Web.UI.Page> object where the <xref:System.Web.UI.Control> object associated with the current <xref:System.Web.UI.Adapters.ControlAdapter> object is situated.</span></span>  
  
 <span data-ttu-id="314a3-241"><xref:System.Web.UI.Adapters.ControlAdapter.PageAdapter%2A>属性可用于访问页面级别的适配器，如常见可应用到的页上的多个控件类型的特定于目标的函数的其他项。</span><span class="sxs-lookup"><span data-stu-id="314a3-241">The <xref:System.Web.UI.Adapters.ControlAdapter.PageAdapter%2A> property can be used to access other items at the page adapter level, such as common target-specific functions that could apply to several control types on the page.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.Adapters.PageAdapter" />
        <altmember cref="T:System.Web.UI.Control" />
      </Docs>
    </Member>
    <Member MemberName="Render">
      <MemberSignature Language="C#" Value="protected internal virtual void Render (System.Web.UI.HtmlTextWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void Render(class System.Web.UI.HtmlTextWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Adapters.ControlAdapter.Render(System.Web.UI.HtmlTextWriter)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub Render (writer As HtmlTextWriter)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void Render(System::Web::UI::HtmlTextWriter ^ writer);" />
      <MemberSignature Language="F#" Value="abstract member Render : System.Web.UI.HtmlTextWriter -&gt; unit&#xA;override this.Render : System.Web.UI.HtmlTextWriter -&gt; unit" Usage="controlAdapter.Render writer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Web.UI.HtmlTextWriter" />
      </Parameters>
      <Docs>
        <param name="writer">
          <span data-ttu-id="314a3-242">用于呈现特定于目标的输出的 <see cref="T:System.Web.UI.HtmlTextWriter" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="314a3-242">The <see cref="T:System.Web.UI.HtmlTextWriter" /> to use to render the target-specific output.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="314a3-243">为附加了控件适配器的控件生成目标特定的标记。</span>
          <span class="sxs-lookup">
            <span data-stu-id="314a3-243">Generates the target-specific markup for the control to which the control adapter is attached.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="314a3-244">重写<xref:System.Web.UI.Adapters.ControlAdapter.Render%2A>方法来生成特定于目标的标记将发送到客户端浏览器。</span><span class="sxs-lookup"><span data-stu-id="314a3-244">Override the <xref:System.Web.UI.Adapters.ControlAdapter.Render%2A> method to generate target-specific markup to send to the client browser.</span></span> <span data-ttu-id="314a3-245"><xref:System.Web.UI.Adapters.ControlAdapter.Render%2A>方法调用来代替<xref:System.Web.UI.Control.Render%2A?displayProperty=nameWithType>方法如果<xref:System.Web.UI.Adapters.ControlAdapter>对象附加到<xref:System.Web.UI.Control>对象。</span><span class="sxs-lookup"><span data-stu-id="314a3-245">The <xref:System.Web.UI.Adapters.ControlAdapter.Render%2A> method is called in place of the <xref:System.Web.UI.Control.Render%2A?displayProperty=nameWithType> method if a <xref:System.Web.UI.Adapters.ControlAdapter> object is attached to a <xref:System.Web.UI.Control> object.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <span data-ttu-id="314a3-246">继承自<see cref="T:System.Web.UI.Adapters.ControlAdapter" />类，<see cref="M:System.Web.UI.Adapters.ControlAdapter.Render(System.Web.UI.HtmlTextWriter)" />基类的方法调用<see cref="M:System.Web.UI.Control.Render(System.Web.UI.HtmlTextWriter)" />方法。</span>
            <span class="sxs-lookup">
              <span data-stu-id="314a3-246">When you inherit from the <see cref="T:System.Web.UI.Adapters.ControlAdapter" /> class, the <see cref="M:System.Web.UI.Adapters.ControlAdapter.Render(System.Web.UI.HtmlTextWriter)" /> base method calls the <see cref="M:System.Web.UI.Control.Render(System.Web.UI.HtmlTextWriter)" /> method.</span>
            </span>
            <span data-ttu-id="314a3-247">因此，重写<see cref="M:System.Web.UI.Adapters.ControlAdapter.Render(System.Web.UI.HtmlTextWriter)" />方法应调用<see cref="M:System.Web.UI.Adapters.ControlAdapter.Render(System.Web.UI.HtmlTextWriter)" />基方法，仅当其处理为除此之外，而不是而不是，<see cref="M:System.Web.UI.Control.Render(System.Web.UI.HtmlTextWriter)" />方法。</span>
            <span class="sxs-lookup">
              <span data-stu-id="314a3-247">Thus, overrides of the <see cref="M:System.Web.UI.Adapters.ControlAdapter.Render(System.Web.UI.HtmlTextWriter)" /> method should call the <see cref="M:System.Web.UI.Adapters.ControlAdapter.Render(System.Web.UI.HtmlTextWriter)" /> base method only if its processing is in addition to, rather than instead of, the <see cref="M:System.Web.UI.Control.Render(System.Web.UI.HtmlTextWriter)" /> method.</span>
            </span>
            <span data-ttu-id="314a3-248">对于复合控件，适配器开发人员必须确保呈现子控件。</span>
            <span class="sxs-lookup">
              <span data-stu-id="314a3-248">For a composite control, the adapter developer must ensure that the child controls are rendered.</span>
            </span>
            <span data-ttu-id="314a3-249">如果<see cref="M:System.Web.UI.Control.Render(System.Web.UI.HtmlTextWriter)" />方法使子控件呈现，但不会生成标记，它可能适合<see cref="M:System.Web.UI.Adapters.ControlAdapter.Render(System.Web.UI.HtmlTextWriter)" />方法以调用其基方法。</span>
            <span class="sxs-lookup">
              <span data-stu-id="314a3-249">If the <see cref="M:System.Web.UI.Control.Render(System.Web.UI.HtmlTextWriter)" /> method causes the child controls to be rendered but does not generate markup, it might be appropriate for the <see cref="M:System.Web.UI.Adapters.ControlAdapter.Render(System.Web.UI.HtmlTextWriter)" /> method to call its base method.</span>
            </span>
            <span data-ttu-id="314a3-250">如果子控件的特定于目标的呈现是必需的适配器应实现<see cref="M:System.Web.UI.Adapters.ControlAdapter.RenderChildren(System.Web.UI.HtmlTextWriter)" />方法并调用<see cref="M:System.Web.UI.Adapters.ControlAdapter.RenderChildren(System.Web.UI.HtmlTextWriter)" />方法从<see cref="M:System.Web.UI.Adapters.ControlAdapter.Render(System.Web.UI.HtmlTextWriter)" />方法。</span>
            <span class="sxs-lookup">
              <span data-stu-id="314a3-250">If target-specific rendering of the child controls is necessary, the adapter should implement the <see cref="M:System.Web.UI.Adapters.ControlAdapter.RenderChildren(System.Web.UI.HtmlTextWriter)" /> method and call the <see cref="M:System.Web.UI.Adapters.ControlAdapter.RenderChildren(System.Web.UI.HtmlTextWriter)" /> method from the <see cref="M:System.Web.UI.Adapters.ControlAdapter.Render(System.Web.UI.HtmlTextWriter)" /> method.</span>
            </span>
          </para>
        </block>
        <altmember cref="M:System.Web.UI.Control.Render(System.Web.UI.HtmlTextWriter)" />
        <altmember cref="T:System.Web.UI.Control" />
        <altmember cref="M:System.Web.UI.Adapters.ControlAdapter.RenderChildren(System.Web.UI.HtmlTextWriter)" />
        <altmember cref="M:System.Web.UI.Control.RenderChildren(System.Web.UI.HtmlTextWriter)" />
        <altmember cref="M:System.Web.UI.Control.RenderControl(System.Web.UI.HtmlTextWriter,System.Web.UI.Adapters.ControlAdapter)" />
      </Docs>
    </Member>
    <Member MemberName="RenderChildren">
      <MemberSignature Language="C#" Value="protected virtual void RenderChildren (System.Web.UI.HtmlTextWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void RenderChildren(class System.Web.UI.HtmlTextWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Adapters.ControlAdapter.RenderChildren(System.Web.UI.HtmlTextWriter)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub RenderChildren (writer As HtmlTextWriter)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void RenderChildren(System::Web::UI::HtmlTextWriter ^ writer);" />
      <MemberSignature Language="F#" Value="abstract member RenderChildren : System.Web.UI.HtmlTextWriter -&gt; unit&#xA;override this.RenderChildren : System.Web.UI.HtmlTextWriter -&gt; unit" Usage="controlAdapter.RenderChildren writer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Web.UI.HtmlTextWriter" />
      </Parameters>
      <Docs>
        <param name="writer">
          <span data-ttu-id="314a3-251">用于呈现特定于目标的输出的 <see cref="T:System.Web.UI.HtmlTextWriter" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="314a3-251">The <see cref="T:System.Web.UI.HtmlTextWriter" /> to use to render the target-specific output.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="314a3-252">为附加了控件适配器的复合控件中的子控件生成特定于目标的标记。</span>
          <span class="sxs-lookup">
            <span data-stu-id="314a3-252">Generates the target-specific markup for the child controls in a composite control to which the control adapter is attached.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="314a3-253">重写<xref:System.Web.UI.Adapters.ControlAdapter.RenderChildren%2A>方法时需要此外到各个子控件的标记生成复合控件的子控件集的特定于目标的标记。</span><span class="sxs-lookup"><span data-stu-id="314a3-253">Override the <xref:System.Web.UI.Adapters.ControlAdapter.RenderChildren%2A> method when it is necessary to generate target-specific markup for the child control set of a composite control, in addition to the markup for the individual child controls.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <span data-ttu-id="314a3-254">继承自<see cref="T:System.Web.UI.Adapters.ControlAdapter" />类，用于复合控件，适配器开发人员必须确保呈现子控件。</span>
            <span class="sxs-lookup">
              <span data-stu-id="314a3-254">When you inherit from the <see cref="T:System.Web.UI.Adapters.ControlAdapter" /> class, for a composite control, the adapter developer must ensure that the child controls are rendered.</span>
            </span>
            <span data-ttu-id="314a3-255">如果适配器重写<see cref="M:System.Web.UI.Adapters.ControlAdapter.RenderChildren(System.Web.UI.HtmlTextWriter)" />方法，则应调用<see cref="M:System.Web.UI.Adapters.ControlAdapter.RenderChildren(System.Web.UI.HtmlTextWriter)" />方法的重写从<see cref="M:System.Web.UI.Adapters.ControlAdapter.Render(System.Web.UI.HtmlTextWriter)" />方法。</span>
            <span class="sxs-lookup">
              <span data-stu-id="314a3-255">If the adapter overrides the <see cref="M:System.Web.UI.Adapters.ControlAdapter.RenderChildren(System.Web.UI.HtmlTextWriter)" /> method, it should call the <see cref="M:System.Web.UI.Adapters.ControlAdapter.RenderChildren(System.Web.UI.HtmlTextWriter)" /> method from an override of the <see cref="M:System.Web.UI.Adapters.ControlAdapter.Render(System.Web.UI.HtmlTextWriter)" /> method.</span>
            </span>
            <span data-ttu-id="314a3-256">如果<see cref="M:System.Web.UI.Control.Render(System.Web.UI.HtmlTextWriter)" />方法使子控件呈现，但本身不会生成标记，它可能适合<see cref="M:System.Web.UI.Adapters.ControlAdapter.Render(System.Web.UI.HtmlTextWriter)" />方法来调用其基方法，调用<see cref="M:System.Web.UI.Control.Render(System.Web.UI.HtmlTextWriter)" />方法，而不是实现的替代<see cref="M:System.Web.UI.Adapters.ControlAdapter.RenderChildren(System.Web.UI.HtmlTextWriter)" />方法。</span>
            <span class="sxs-lookup">
              <span data-stu-id="314a3-256">If the <see cref="M:System.Web.UI.Control.Render(System.Web.UI.HtmlTextWriter)" /> method causes the child controls to be rendered but itself does not generate markup, it might be appropriate for the <see cref="M:System.Web.UI.Adapters.ControlAdapter.Render(System.Web.UI.HtmlTextWriter)" /> method to call its base method, which calls the <see cref="M:System.Web.UI.Control.Render(System.Web.UI.HtmlTextWriter)" /> method, instead of implementing an override for the <see cref="M:System.Web.UI.Adapters.ControlAdapter.RenderChildren(System.Web.UI.HtmlTextWriter)" /> method.</span>
            </span>
          </para>
        </block>
        <altmember cref="M:System.Web.UI.Control.RenderChildren(System.Web.UI.HtmlTextWriter)" />
        <altmember cref="T:System.Web.UI.Control" />
        <altmember cref="M:System.Web.UI.Adapters.ControlAdapter.Render(System.Web.UI.HtmlTextWriter)" />
        <altmember cref="M:System.Web.UI.Control.Render(System.Web.UI.HtmlTextWriter)" />
      </Docs>
    </Member>
    <Member MemberName="SaveAdapterControlState">
      <MemberSignature Language="C#" Value="protected internal virtual object SaveAdapterControlState ();" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance object SaveAdapterControlState() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Adapters.ControlAdapter.SaveAdapterControlState" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Function SaveAdapterControlState () As Object" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual System::Object ^ SaveAdapterControlState();" />
      <MemberSignature Language="F#" Value="abstract member SaveAdapterControlState : unit -&gt; obj&#xA;override this.SaveAdapterControlState : unit -&gt; obj" Usage="controlAdapter.SaveAdapterControlState " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="314a3-257">保存控件适配器的控件状态信息。</span>
          <span class="sxs-lookup">
            <span data-stu-id="314a3-257">Saves control state information for the control adapter.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="314a3-258">一个 <see cref="T:System.Object" />，其中包含适配器的控件状态信息作为 <see cref="T:System.Web.UI.StateBag" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="314a3-258">An <see cref="T:System.Object" /> that contains the adapter's control state information as a <see cref="T:System.Web.UI.StateBag" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="314a3-259">控件状态是即使禁用了视图状态所需的基本状态信息。</span><span class="sxs-lookup"><span data-stu-id="314a3-259">Control state is the essential state information needed even if view state is disabled.</span></span> <span data-ttu-id="314a3-260">当适配器需要维护其自己的控件状态信息时，它会重写<xref:System.Web.UI.Adapters.ControlAdapter.SaveAdapterControlState%2A>和<xref:System.Web.UI.Adapters.ControlAdapter.LoadAdapterControlState%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="314a3-260">When an adapter needs to maintain its own control state information, it can override the <xref:System.Web.UI.Adapters.ControlAdapter.SaveAdapterControlState%2A> and <xref:System.Web.UI.Adapters.ControlAdapter.LoadAdapterControlState%2A> methods.</span></span>  
  
 <span data-ttu-id="314a3-261">适配器可能需要在有需要在请求中，独立于关联控件的状态之间维护状态的功能时保持控件状态信息。</span><span class="sxs-lookup"><span data-stu-id="314a3-261">An adapter might need to maintain control state information when there are features that need to have state maintained across requests, independent from the state of the associated control.</span></span> <span data-ttu-id="314a3-262">例如，大型文本显示和一组组成的复合控件<xref:System.Web.UI.WebControls.RadioButton>控件可能会呈现为台式计算机浏览器上的单一视图。</span><span class="sxs-lookup"><span data-stu-id="314a3-262">For example, a composite control consisting of a large textual display and a group of <xref:System.Web.UI.WebControls.RadioButton> controls might render as a single view on desktop computer browsers.</span></span> <span data-ttu-id="314a3-263">在其他浏览器，它可能会拆分其呈现 — 用于文本显示，另一个用于单选按钮组的一个视图。</span><span class="sxs-lookup"><span data-stu-id="314a3-263">On other browsers, it might split its rendering—one view for the textual display and the other for the radio button group.</span></span> <span data-ttu-id="314a3-264">适配器需要维护其自己的特定于目标的信息有关当前处于活动状态的视图。</span><span class="sxs-lookup"><span data-stu-id="314a3-264">The adapter would need to maintain its own target-specific information about the currently active view.</span></span>  
  
 <span data-ttu-id="314a3-265"><xref:System.Web.UI.Adapters.ControlAdapter.SaveAdapterControlState%2A>方法后立即调用<xref:System.Web.UI.Control.SaveControlState%2A?displayProperty=nameWithType>中的方法`SaveState`生命周期阶段。</span><span class="sxs-lookup"><span data-stu-id="314a3-265">The <xref:System.Web.UI.Adapters.ControlAdapter.SaveAdapterControlState%2A> method is called immediately after the <xref:System.Web.UI.Control.SaveControlState%2A?displayProperty=nameWithType> method in the `SaveState` lifecycle stage.</span></span> <span data-ttu-id="314a3-266">适配器控件状态是独立且除了该控件的控件状态。</span><span class="sxs-lookup"><span data-stu-id="314a3-266">The adapter control state is separate and in addition to the control state of the control.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Control.SaveControlState" />
        <altmember cref="T:System.Web.UI.Control" />
        <altmember cref="M:System.Web.UI.Adapters.ControlAdapter.LoadAdapterControlState(System.Object)" />
        <altmember cref="M:System.Web.UI.Adapters.ControlAdapter.SaveAdapterViewState" />
      </Docs>
    </Member>
    <Member MemberName="SaveAdapterViewState">
      <MemberSignature Language="C#" Value="protected internal virtual object SaveAdapterViewState ();" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance object SaveAdapterViewState() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Adapters.ControlAdapter.SaveAdapterViewState" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Function SaveAdapterViewState () As Object" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual System::Object ^ SaveAdapterViewState();" />
      <MemberSignature Language="F#" Value="abstract member SaveAdapterViewState : unit -&gt; obj&#xA;override this.SaveAdapterViewState : unit -&gt; obj" Usage="controlAdapter.SaveAdapterViewState " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="314a3-267">保存控件适配器的视图状态信息。</span>
          <span class="sxs-lookup">
            <span data-stu-id="314a3-267">Saves view state information for the control adapter.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="314a3-268">一个 <see cref="T:System.Object" />，其中包含适配器视图的状态信息作为 <see cref="T:System.Web.UI.StateBag" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="314a3-268">An <see cref="T:System.Object" /> that contains the adapter view state information as a <see cref="T:System.Web.UI.StateBag" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="314a3-269">当适配器需要维护其自己的视图状态信息时，它会重写<xref:System.Web.UI.Adapters.ControlAdapter.SaveAdapterViewState%2A>和<xref:System.Web.UI.Adapters.ControlAdapter.LoadAdapterViewState%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="314a3-269">When an adapter needs to maintain its own view state information, it can override the <xref:System.Web.UI.Adapters.ControlAdapter.SaveAdapterViewState%2A> and <xref:System.Web.UI.Adapters.ControlAdapter.LoadAdapterViewState%2A> methods.</span></span>  
  
 <span data-ttu-id="314a3-270">适配器需要在请求中，独立于控件的关联的视图状态之间必须保持的数据时维护视图状态信息。</span><span class="sxs-lookup"><span data-stu-id="314a3-270">An adapter needs to maintain view state information when there is data that must be maintained across requests, independent from the associated view state of the control.</span></span> <span data-ttu-id="314a3-271">例如，在台式计算机浏览器上的网格控件可能会呈现为单个视图的行和列的值。</span><span class="sxs-lookup"><span data-stu-id="314a3-271">For example, a grid control on desktop computer browsers might render as a single view of rows and columns of values.</span></span> <span data-ttu-id="314a3-272">在其他浏览器，它可能会拆分为多个单独的视图，如行和详细信息的单个行的列表及其呈现。</span><span class="sxs-lookup"><span data-stu-id="314a3-272">On other browsers, it might split its rendering into multiple separate views, such as a list of rows and details of a single row.</span></span> <span data-ttu-id="314a3-273">适配器需要维护视图状态中不是当前处于活动状态的视图的数据。</span><span class="sxs-lookup"><span data-stu-id="314a3-273">The adapter would need to maintain the data for the views that are not currently active in view state.</span></span>  
  
 <span data-ttu-id="314a3-274"><xref:System.Web.UI.Adapters.ControlAdapter.SaveAdapterViewState%2A>方法调用之前<xref:System.Web.UI.Control.SaveViewState%2A?displayProperty=nameWithType>中的方法`SaveState`生命周期阶段。</span><span class="sxs-lookup"><span data-stu-id="314a3-274">The <xref:System.Web.UI.Adapters.ControlAdapter.SaveAdapterViewState%2A> method is called immediately before the <xref:System.Web.UI.Control.SaveViewState%2A?displayProperty=nameWithType> method in the `SaveState` lifecycle stage.</span></span> <span data-ttu-id="314a3-275">适配器视图状态是独立且除了该控件的视图状态。</span><span class="sxs-lookup"><span data-stu-id="314a3-275">The adapter view state is separate and in addition to the view state of the control.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Control.SaveViewState" />
        <altmember cref="T:System.Web.UI.Control" />
        <altmember cref="M:System.Web.UI.Adapters.ControlAdapter.SaveAdapterControlState" />
        <altmember cref="M:System.Web.UI.Adapters.ControlAdapter.LoadAdapterViewState(System.Object)" />
        <altmember cref="P:System.Web.UI.Control.ViewState" />
      </Docs>
    </Member>
  </Members>
</Type>