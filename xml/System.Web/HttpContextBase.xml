<Type Name="HttpContextBase" FullName="System.Web.HttpContextBase">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="b505f8218b22d479c8d1c2101193201c5441fb14" />
    <Meta Name="ms.sourcegitcommit" Value="5a49536d99d2d0b54e4cb7280870903e043272df" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-CN" />
    <Meta Name="ms.lasthandoff" Value="07/03/2018" />
    <Meta Name="ms.locfileid" Value="37529476" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class HttpContextBase : IServiceProvider" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit HttpContextBase extends System.Object implements class System.IServiceProvider" />
  <TypeSignature Language="DocId" Value="T:System.Web.HttpContextBase" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class HttpContextBase&#xA;Implements IServiceProvider" />
  <TypeSignature Language="C++ CLI" Value="public ref class HttpContextBase abstract : IServiceProvider" />
  <TypeSignature Language="F#" Value="type HttpContextBase = class&#xA;    interface IServiceProvider" />
  <AssemblyInfo>
    <AssemblyName>System.Web</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Web.Abstractions</AssemblyName>
    <AssemblyVersion>3.5.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IServiceProvider</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.CompilerServices.TypeForwardedFrom("System.Web.Abstractions, Version=3.5.0.0, Culture=Neutral, PublicKeyToken=31bf3856ad364e35")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>为包含有关单个 HTTP 请求的 HTTP 特定信息的类充当基类。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpContextBase>类是一个抽象类，包含相同的成员<xref:System.Web.HttpContext>类。 <xref:System.Web.HttpContextBase>类，可创建如下所示的派生的类<xref:System.Web.HttpContext>类，但你可以自定义并使用 ASP.NET 管道外部。 在执行单元测试时，通常使用派生的类以实现具有可满足你正在测试的方案的自定义行为的成员。  
  
 <xref:System.Web.HttpContextWrapper> 类是从 <xref:System.Web.HttpContextBase> 类派生的。 <xref:System.Web.HttpContextWrapper>类用作的包装器<xref:System.Web.HttpContext>类。 在运行时，您通常使用的实例<xref:System.Web.HttpContextWrapper>类上调用成员<xref:System.Web.HttpContext>对象。  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected HttpContextBase ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContextBase.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; HttpContextBase();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Web.Abstractions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>初始化该类供继承的类实例使用。 此构造函数只能由继承的类调用。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AcceptWebSocketRequest">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>在派生类中实现时，接受 <see cref="T:System.Web.WebSockets.AspNetWebSocket" /> 请求。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AcceptWebSocketRequest">
      <MemberSignature Language="C#" Value="public virtual void AcceptWebSocketRequest (Func&lt;System.Web.WebSockets.AspNetWebSocketContext,System.Threading.Tasks.Task&gt; userFunc);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void AcceptWebSocketRequest(class System.Func`2&lt;class System.Web.WebSockets.AspNetWebSocketContext, class System.Threading.Tasks.Task&gt; userFunc) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContextBase.AcceptWebSocketRequest(System.Func{System.Web.WebSockets.AspNetWebSocketContext,System.Threading.Tasks.Task})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub AcceptWebSocketRequest (userFunc As Func(Of AspNetWebSocketContext, Task))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void AcceptWebSocketRequest(Func&lt;System::Web::WebSockets::AspNetWebSocketContext ^, System::Threading::Tasks::Task ^&gt; ^ userFunc);" />
      <MemberSignature Language="F#" Value="abstract member AcceptWebSocketRequest : Func&lt;System.Web.WebSockets.AspNetWebSocketContext, System.Threading.Tasks.Task&gt; -&gt; unit&#xA;override this.AcceptWebSocketRequest : Func&lt;System.Web.WebSockets.AspNetWebSocketContext, System.Threading.Tasks.Task&gt; -&gt; unit" Usage="httpContextBase.AcceptWebSocketRequest userFunc" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="userFunc" Type="System.Func&lt;System.Web.WebSockets.AspNetWebSocketContext,System.Threading.Tasks.Task&gt;" />
      </Parameters>
      <Docs>
        <param name="userFunc">用户函数。</param>
        <summary>在派生类中实现时，接受使用指定用户函数的 <see cref="T:System.Web.WebSockets.AspNetWebSocket" /> 请求。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AcceptWebSocketRequest">
      <MemberSignature Language="C#" Value="public virtual void AcceptWebSocketRequest (Func&lt;System.Web.WebSockets.AspNetWebSocketContext,System.Threading.Tasks.Task&gt; userFunc, System.Web.WebSockets.AspNetWebSocketOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void AcceptWebSocketRequest(class System.Func`2&lt;class System.Web.WebSockets.AspNetWebSocketContext, class System.Threading.Tasks.Task&gt; userFunc, class System.Web.WebSockets.AspNetWebSocketOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContextBase.AcceptWebSocketRequest(System.Func{System.Web.WebSockets.AspNetWebSocketContext,System.Threading.Tasks.Task},System.Web.WebSockets.AspNetWebSocketOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub AcceptWebSocketRequest (userFunc As Func(Of AspNetWebSocketContext, Task), options As AspNetWebSocketOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void AcceptWebSocketRequest(Func&lt;System::Web::WebSockets::AspNetWebSocketContext ^, System::Threading::Tasks::Task ^&gt; ^ userFunc, System::Web::WebSockets::AspNetWebSocketOptions ^ options);" />
      <MemberSignature Language="F#" Value="abstract member AcceptWebSocketRequest : Func&lt;System.Web.WebSockets.AspNetWebSocketContext, System.Threading.Tasks.Task&gt; * System.Web.WebSockets.AspNetWebSocketOptions -&gt; unit&#xA;override this.AcceptWebSocketRequest : Func&lt;System.Web.WebSockets.AspNetWebSocketContext, System.Threading.Tasks.Task&gt; * System.Web.WebSockets.AspNetWebSocketOptions -&gt; unit" Usage="httpContextBase.AcceptWebSocketRequest (userFunc, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="userFunc" Type="System.Func&lt;System.Web.WebSockets.AspNetWebSocketContext,System.Threading.Tasks.Task&gt;" />
        <Parameter Name="options" Type="System.Web.WebSockets.AspNetWebSocketOptions" />
      </Parameters>
      <Docs>
        <param name="userFunc">用户函数。</param>
        <param name="options">选项对象。</param>
        <summary>在派生类中实现时，接受使用指定用户函数和选项对象的 <see cref="T:System.Web.WebSockets.AspNetWebSocket" /> 请求。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddError">
      <MemberSignature Language="C#" Value="public virtual void AddError (Exception errorInfo);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void AddError(class System.Exception errorInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContextBase.AddError(System.Exception)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub AddError (errorInfo As Exception)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void AddError(Exception ^ errorInfo);" />
      <MemberSignature Language="F#" Value="abstract member AddError : Exception -&gt; unit&#xA;override this.AddError : Exception -&gt; unit" Usage="httpContextBase.AddError errorInfo" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Web.Abstractions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="errorInfo" Type="System.Exception" />
      </Parameters>
      <Docs>
        <param name="errorInfo">要添加到异常集合中的异常。</param>
        <summary>当在派生类中重写时，将异常添加到当前 HTTP 请求的异常集合中。</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotImplementedException">始终。</exception>
      </Docs>
    </Member>
    <Member MemberName="AddOnRequestCompleted">
      <MemberSignature Language="C#" Value="public virtual System.Web.ISubscriptionToken AddOnRequestCompleted (Action&lt;System.Web.HttpContextBase&gt; callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Web.ISubscriptionToken AddOnRequestCompleted(class System.Action`1&lt;class System.Web.HttpContextBase&gt; callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContextBase.AddOnRequestCompleted(System.Action{System.Web.HttpContextBase})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function AddOnRequestCompleted (callback As Action(Of HttpContextBase)) As ISubscriptionToken" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Web::ISubscriptionToken ^ AddOnRequestCompleted(Action&lt;System::Web::HttpContextBase ^&gt; ^ callback);" />
      <MemberSignature Language="F#" Value="abstract member AddOnRequestCompleted : Action&lt;System.Web.HttpContextBase&gt; -&gt; System.Web.ISubscriptionToken&#xA;override this.AddOnRequestCompleted : Action&lt;System.Web.HttpContextBase&gt; -&gt; System.Web.ISubscriptionToken" Usage="httpContextBase.AddOnRequestCompleted callback" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.ISubscriptionToken</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.Action&lt;System.Web.HttpContextBase&gt;" />
      </Parameters>
      <Docs>
        <param name="callback">HTTP 上下文对象。</param>
        <summary>在派生类中实现时，引发在请求的 HTTP 部件结束时发生的虚拟事件。</summary>
        <returns>订阅标记。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此事件之前发生<xref:System.Web.WebSockets.AspNetWebSocket>连接开始时。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AllErrors">
      <MemberSignature Language="C#" Value="public virtual Exception[] AllErrors { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Exception[] AllErrors" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContextBase.AllErrors" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property AllErrors As Exception()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property cli::array &lt;Exception ^&gt; ^ AllErrors { cli::array &lt;Exception ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.AllErrors : Exception[]" Usage="System.Web.HttpContextBase.AllErrors" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Web.Abstractions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Exception[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在派生类中重写时，获取在处理 HTTP 请求时累积的错误（如果有）的数组。</summary>
        <value>为当前 HTTP 请求的 <see cref="T:System.Exception" /> 对象的数组；如果在 HTTP 请求处理过程中没有累积任何错误，则为 <see langword="null" />。</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotImplementedException">始终。</exception>
      </Docs>
    </Member>
    <Member MemberName="AllowAsyncDuringSyncStages">
      <MemberSignature Language="C#" Value="public virtual bool AllowAsyncDuringSyncStages { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AllowAsyncDuringSyncStages" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContextBase.AllowAsyncDuringSyncStages" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property AllowAsyncDuringSyncStages As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool AllowAsyncDuringSyncStages { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AllowAsyncDuringSyncStages : bool with get, set" Usage="System.Web.HttpContextBase.AllowAsyncDuringSyncStages" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在派生类中实现时，获取或设置一个值，该值指示 ASP.NET 请求处理过程中是否允许非预期的异步操作。</summary>
        <value>当异步 API 在不是预期的时间使用时 ASP.NET 将引发异常，则为 <see langword="false" />，否则为 <see langword="true" />。 默认值为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 有关详情，请参阅<xref:System.Web.HttpContext.AllowAsyncDuringSyncStages%2A?displayProperty=nameWithType>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Application">
      <MemberSignature Language="C#" Value="public virtual System.Web.HttpApplicationStateBase Application { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.HttpApplicationStateBase Application" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContextBase.Application" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Application As HttpApplicationStateBase" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Web::HttpApplicationStateBase ^ Application { System::Web::HttpApplicationStateBase ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Application : System.Web.HttpApplicationStateBase" Usage="System.Web.HttpContextBase.Application" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Web.Abstractions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.HttpApplicationStateBase</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当在派生类中重写时，获取当前 HTTP 请求的 <see cref="T:System.Web.HttpApplicationState" /> 对象。</summary>
        <value>当前 HTTP 请求的应用程序状态对象。</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotImplementedException">始终。</exception>
      </Docs>
    </Member>
    <Member MemberName="ApplicationInstance">
      <MemberSignature Language="C#" Value="public virtual System.Web.HttpApplication ApplicationInstance { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.HttpApplication ApplicationInstance" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContextBase.ApplicationInstance" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property ApplicationInstance As HttpApplication" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Web::HttpApplication ^ ApplicationInstance { System::Web::HttpApplication ^ get(); void set(System::Web::HttpApplication ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ApplicationInstance : System.Web.HttpApplication with get, set" Usage="System.Web.HttpContextBase.ApplicationInstance" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Web.Abstractions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.HttpApplication</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当在派生类中重写时，获取或设置当前 HTTP 请求的 <see cref="T:System.Web.HttpApplication" /> 对象。</summary>
        <value>当前 HTTP 请求的对象。</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotImplementedException">始终。</exception>
      </Docs>
    </Member>
    <Member MemberName="AsyncPreloadMode">
      <MemberSignature Language="C#" Value="public virtual System.Web.Configuration.AsyncPreloadModeFlags AsyncPreloadMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Web.Configuration.AsyncPreloadModeFlags AsyncPreloadMode" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContextBase.AsyncPreloadMode" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property AsyncPreloadMode As AsyncPreloadModeFlags" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Web::Configuration::AsyncPreloadModeFlags AsyncPreloadMode { System::Web::Configuration::AsyncPreloadModeFlags get(); void set(System::Web::Configuration::AsyncPreloadModeFlags value); };" />
      <MemberSignature Language="F#" Value="member this.AsyncPreloadMode : System.Web.Configuration.AsyncPreloadModeFlags with get, set" Usage="System.Web.HttpContextBase.AsyncPreloadMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.Configuration.AsyncPreloadModeFlags</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在派生类中实现时，获取或设置一个对象，该对象包含适用于异步预加载模式的标志。</summary>
        <value>包含适用于异步预加载模式的标志的对象。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Cache">
      <MemberSignature Language="C#" Value="public virtual System.Web.Caching.Cache Cache { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.Caching.Cache Cache" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContextBase.Cache" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Cache As Cache" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Web::Caching::Cache ^ Cache { System::Web::Caching::Cache ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Cache : System.Web.Caching.Cache" Usage="System.Web.HttpContextBase.Cache" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Web.Abstractions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.Caching.Cache</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在派生类中重写时，获取当前应用程序域的 <see cref="T:System.Web.Caching.Cache" /> 对象。</summary>
        <value>当前应用程序域的缓存。</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotImplementedException">始终。</exception>
      </Docs>
    </Member>
    <Member MemberName="ClearError">
      <MemberSignature Language="C#" Value="public virtual void ClearError ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ClearError() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContextBase.ClearError" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub ClearError ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ClearError();" />
      <MemberSignature Language="F#" Value="abstract member ClearError : unit -&gt; unit&#xA;override this.ClearError : unit -&gt; unit" Usage="httpContextBase.ClearError " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Web.Abstractions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>在派生类中重写时，清除当前 HTTP 请求的所有错误。</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotImplementedException">始终。</exception>
      </Docs>
    </Member>
    <Member MemberName="CurrentHandler">
      <MemberSignature Language="C#" Value="public virtual System.Web.IHttpHandler CurrentHandler { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.IHttpHandler CurrentHandler" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContextBase.CurrentHandler" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property CurrentHandler As IHttpHandler" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Web::IHttpHandler ^ CurrentHandler { System::Web::IHttpHandler ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CurrentHandler : System.Web.IHttpHandler" Usage="System.Web.HttpContextBase.CurrentHandler" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Web.Abstractions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.IHttpHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在派生类中重写时，获取表示当前正在执行的处理程序的 <see cref="T:System.Web.IHttpHandler" /> 对象。</summary>
        <value>一个对象，表示当前正在执行的处理程序。</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotImplementedException">始终。</exception>
      </Docs>
    </Member>
    <Member MemberName="CurrentNotification">
      <MemberSignature Language="C#" Value="public virtual System.Web.RequestNotification CurrentNotification { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Web.RequestNotification CurrentNotification" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContextBase.CurrentNotification" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property CurrentNotification As RequestNotification" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Web::RequestNotification CurrentNotification { System::Web::RequestNotification get(); };" />
      <MemberSignature Language="F#" Value="member this.CurrentNotification : System.Web.RequestNotification" Usage="System.Web.HttpContextBase.CurrentNotification" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Web.Abstractions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.RequestNotification</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在派生类中重写时，获取一个 <see cref="T:System.Web.RequestNotification" /> 值，该值指示当前是否正在处理 <see cref="T:System.Web.HttpApplication" /> 事件。</summary>
        <value>
          <see cref="T:System.Web.RequestNotification" /> 值之一。</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotImplementedException">始终。</exception>
      </Docs>
    </Member>
    <Member MemberName="DisposeOnPipelineCompleted">
      <MemberSignature Language="C#" Value="public virtual System.Web.ISubscriptionToken DisposeOnPipelineCompleted (IDisposable target);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Web.ISubscriptionToken DisposeOnPipelineCompleted(class System.IDisposable target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContextBase.DisposeOnPipelineCompleted(System.IDisposable)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function DisposeOnPipelineCompleted (target As IDisposable) As ISubscriptionToken" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Web::ISubscriptionToken ^ DisposeOnPipelineCompleted(IDisposable ^ target);" />
      <MemberSignature Language="F#" Value="abstract member DisposeOnPipelineCompleted : IDisposable -&gt; System.Web.ISubscriptionToken&#xA;override this.DisposeOnPipelineCompleted : IDisposable -&gt; System.Web.ISubscriptionToken" Usage="httpContextBase.DisposeOnPipelineCompleted target" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.ISubscriptionToken</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.IDisposable" />
      </Parameters>
      <Docs>
        <param name="target">在请求的 <see cref="M:System.IDisposable.Dispose" /> 连接部分完成时必须调动用其 <see cref="T:System.Web.WebSockets.AspNetWebSocket" /> 方法的对象。</param>
        <summary>在派生类中实现时，使对象的 <see cref="M:System.IDisposable.Dispose" /> 方法在此请求的 <see cref="T:System.Web.WebSockets.AspNetWebSocket" /> 连接部分完成时能够被调用。</summary>
        <returns>订阅标记。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Error">
      <MemberSignature Language="C#" Value="public virtual Exception Error { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Exception Error" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContextBase.Error" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Error As Exception" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Exception ^ Error { Exception ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Error : Exception" Usage="System.Web.HttpContextBase.Error" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Web.Abstractions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Exception</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在派生类中重写时，获取在处理 HTTP 请求时累积的第一个错误（如果有）。</summary>
        <value>为当前 HTTP 请求/响应过程的第一个异常；如果在 HTTP 请求处理期间未累积任何错误，则为 <see langword="null" />。</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotImplementedException">始终。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetGlobalResourceObject">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>在派生类中重写时，获取应用程序级别的资源。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetGlobalResourceObject">
      <MemberSignature Language="C#" Value="public virtual object GetGlobalResourceObject (string classKey, string resourceKey);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object GetGlobalResourceObject(string classKey, string resourceKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContextBase.GetGlobalResourceObject(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetGlobalResourceObject (classKey As String, resourceKey As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ GetGlobalResourceObject(System::String ^ classKey, System::String ^ resourceKey);" />
      <MemberSignature Language="F#" Value="abstract member GetGlobalResourceObject : string * string -&gt; obj&#xA;override this.GetGlobalResourceObject : string * string -&gt; obj" Usage="httpContextBase.GetGlobalResourceObject (classKey, resourceKey)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Web.Abstractions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="classKey" Type="System.String" />
        <Parameter Name="resourceKey" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="classKey">一个字符串，表示所请求资源对象的 <see cref="P:System.Web.Compilation.ResourceExpressionFields.ClassKey" /> 属性。</param>
        <param name="resourceKey">一个字符串，表示所请求资源对象的 <see cref="P:System.Web.Compilation.ResourceExpressionFields.ResourceKey" /> 属性。</param>
        <summary>在派生类中重写时，根据指定的 <see cref="P:System.Web.Compilation.ResourceExpressionFields.ClassKey" /> 和 <see cref="P:System.Web.Compilation.ResourceExpressionFields.ResourceKey" /> 属性，获取应用程序级别资源对象。</summary>
        <returns>所请求的应用程序级别资源对象；或者，如果找不到匹配的资源对象，则为 <see langword="null" />。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotImplementedException">始终。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetGlobalResourceObject">
      <MemberSignature Language="C#" Value="public virtual object GetGlobalResourceObject (string classKey, string resourceKey, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object GetGlobalResourceObject(string classKey, string resourceKey, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContextBase.GetGlobalResourceObject(System.String,System.String,System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetGlobalResourceObject (classKey As String, resourceKey As String, culture As CultureInfo) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ GetGlobalResourceObject(System::String ^ classKey, System::String ^ resourceKey, System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="abstract member GetGlobalResourceObject : string * string * System.Globalization.CultureInfo -&gt; obj&#xA;override this.GetGlobalResourceObject : string * string * System.Globalization.CultureInfo -&gt; obj" Usage="httpContextBase.GetGlobalResourceObject (classKey, resourceKey, culture)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Web.Abstractions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="classKey" Type="System.String" />
        <Parameter Name="resourceKey" Type="System.String" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="classKey">一个字符串，表示所请求资源对象的 <see cref="P:System.Web.Compilation.ResourceExpressionFields.ClassKey" /> 属性。</param>
        <param name="resourceKey">一个字符串，表示所请求资源对象的 <see cref="P:System.Web.Compilation.ResourceExpressionFields.ResourceKey" /> 属性。</param>
        <param name="culture">一个字符串，表示所请求资源的 <see cref="T:System.Globalization.CultureInfo" /> 对象。</param>
        <summary>在派生类中重写时，根据指定的 <see cref="P:System.Web.Compilation.ResourceExpressionFields.ClassKey" /> 和 <see cref="P:System.Web.Compilation.ResourceExpressionFields.ResourceKey" /> 属性以及 <see cref="T:System.Globalization.CultureInfo" /> 对象，获取一个应用程序级别资源对象。</summary>
        <returns>所请求的应用程序级别资源对象（针对指定区域性进行了本地化）；或则，如果未找到匹配的资源对象，则为 <see langword="null" />。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotImplementedException">始终。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetLocalResourceObject">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>在派生类中重写时，获取页级别的资源。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetLocalResourceObject">
      <MemberSignature Language="C#" Value="public virtual object GetLocalResourceObject (string virtualPath, string resourceKey);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object GetLocalResourceObject(string virtualPath, string resourceKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContextBase.GetLocalResourceObject(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetLocalResourceObject (virtualPath As String, resourceKey As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ GetLocalResourceObject(System::String ^ virtualPath, System::String ^ resourceKey);" />
      <MemberSignature Language="F#" Value="abstract member GetLocalResourceObject : string * string -&gt; obj&#xA;override this.GetLocalResourceObject : string * string -&gt; obj" Usage="httpContextBase.GetLocalResourceObject (virtualPath, resourceKey)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Web.Abstractions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="virtualPath" Type="System.String" />
        <Parameter Name="resourceKey" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="virtualPath">一个表示本地资源对象的 <see cref="P:System.Web.Compilation.ExpressionBuilderContext.VirtualPath" /> 属性的字符串。</param>
        <param name="resourceKey">一个字符串，表示所请求资源对象的 <see cref="P:System.Web.Compilation.ResourceExpressionFields.ResourceKey" /> 属性。</param>
        <summary>在派生类中重写时，根据指定的 <see cref="P:System.Web.Compilation.ExpressionBuilderContext.VirtualPath" /> 和 <see cref="P:System.Web.Compilation.ResourceExpressionFields.ResourceKey" /> 属性，获取一个页级别资源对象。</summary>
        <returns>所请求的页级别资源对象；或者，如果找不到匹配的资源对象，则为 <see langword="null" />。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotImplementedException">始终。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetLocalResourceObject">
      <MemberSignature Language="C#" Value="public virtual object GetLocalResourceObject (string virtualPath, string resourceKey, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object GetLocalResourceObject(string virtualPath, string resourceKey, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContextBase.GetLocalResourceObject(System.String,System.String,System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetLocalResourceObject (virtualPath As String, resourceKey As String, culture As CultureInfo) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ GetLocalResourceObject(System::String ^ virtualPath, System::String ^ resourceKey, System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="abstract member GetLocalResourceObject : string * string * System.Globalization.CultureInfo -&gt; obj&#xA;override this.GetLocalResourceObject : string * string * System.Globalization.CultureInfo -&gt; obj" Usage="httpContextBase.GetLocalResourceObject (virtualPath, resourceKey, culture)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Web.Abstractions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="virtualPath" Type="System.String" />
        <Parameter Name="resourceKey" Type="System.String" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="virtualPath">一个表示本地资源对象的 <see cref="P:System.Web.Compilation.ExpressionBuilderContext.VirtualPath" /> 属性的字符串。</param>
        <param name="resourceKey">一个字符串，表示所请求资源对象的 <see cref="P:System.Web.Compilation.ResourceExpressionFields.ResourceKey" /> 属性。</param>
        <param name="culture">一个字符串，表示所请求资源对象的 <see cref="T:System.Globalization.CultureInfo" /> 对象。</param>
        <summary>在派生类中重写时，根据指定的 <see cref="P:System.Web.Compilation.ExpressionBuilderContext.VirtualPath" /> 和 <see cref="P:System.Web.Compilation.ResourceExpressionFields.ResourceKey" /> 属性以及 <see cref="T:System.Globalization.CultureInfo" /> 对象，获取一个页级别资源对象。</summary>
        <returns>所请求的本地资源对象（针对指定区域性进行了本地化）；或者，如果未找到匹配的资源对象，则为 <see langword="null" />。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotImplementedException">始终。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetSection">
      <MemberSignature Language="C#" Value="public virtual object GetSection (string sectionName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object GetSection(string sectionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContextBase.GetSection(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetSection (sectionName As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ GetSection(System::String ^ sectionName);" />
      <MemberSignature Language="F#" Value="abstract member GetSection : string -&gt; obj&#xA;override this.GetSection : string -&gt; obj" Usage="httpContextBase.GetSection sectionName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Web.Abstractions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sectionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="sectionName">配置节路径（使用 XPath 格式）和配置元素名称。</param>
        <summary>在派生类中重写时，获取当前应用程序的默认配置的指定配置节。</summary>
        <returns>指定的节；如果该节不存在，则为 <see langword="null" />。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotImplementedException">始终。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetService">
      <MemberSignature Language="C#" Value="public virtual object GetService (Type serviceType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object GetService(class System.Type serviceType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContextBase.GetService(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetService (serviceType As Type) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ GetService(Type ^ serviceType);" />
      <MemberSignature Language="F#" Value="abstract member GetService : Type -&gt; obj&#xA;override this.GetService : Type -&gt; obj" Usage="httpContextBase.GetService serviceType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Web.Abstractions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="serviceType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="serviceType">要获取的服务对象的类型。</param>
        <summary>在派生类中重写时，返回当前服务类型的对象。</summary>
        <returns>当前服务类型；或者，如果找不到任何服务，则为 <see langword="null" />。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotImplementedException">始终。</exception>
      </Docs>
    </Member>
    <Member MemberName="Handler">
      <MemberSignature Language="C#" Value="public virtual System.Web.IHttpHandler Handler { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.IHttpHandler Handler" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContextBase.Handler" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property Handler As IHttpHandler" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Web::IHttpHandler ^ Handler { System::Web::IHttpHandler ^ get(); void set(System::Web::IHttpHandler ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Handler : System.Web.IHttpHandler with get, set" Usage="System.Web.HttpContextBase.Handler" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Web.Abstractions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.IHttpHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在派生类中重写时，获取或设置负责处理 HTTP 请求的 <see cref="T:System.Web.IHttpHandler" /> 对象。</summary>
        <value>负责处理 HTTP 请求的对象。</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotImplementedException">始终。</exception>
      </Docs>
    </Member>
    <Member MemberName="IsCustomErrorEnabled">
      <MemberSignature Language="C#" Value="public virtual bool IsCustomErrorEnabled { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsCustomErrorEnabled" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContextBase.IsCustomErrorEnabled" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsCustomErrorEnabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsCustomErrorEnabled { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsCustomErrorEnabled : bool" Usage="System.Web.HttpContextBase.IsCustomErrorEnabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Web.Abstractions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在派生类中重写时，获取一个值，该值指示是否对当前 HTTP 请求启用自定义错误。</summary>
        <value>如果启用了自定义错误，则为 <see langword="true" />；否则，为 <see langword="false" />。</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotImplementedException">始终。</exception>
      </Docs>
    </Member>
    <Member MemberName="IsDebuggingEnabled">
      <MemberSignature Language="C#" Value="public virtual bool IsDebuggingEnabled { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsDebuggingEnabled" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContextBase.IsDebuggingEnabled" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsDebuggingEnabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsDebuggingEnabled { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsDebuggingEnabled : bool" Usage="System.Web.HttpContextBase.IsDebuggingEnabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Web.Abstractions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在派生类中重写时，获取一个值，该值指示当前 HTTP 请求是否处于调试模式。</summary>
        <value>如果请求处于调试模式，则为 <see langword="true" />；否则，为 <see langword="false" />。</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotImplementedException">始终。</exception>
      </Docs>
    </Member>
    <Member MemberName="IsPostNotification">
      <MemberSignature Language="C#" Value="public virtual bool IsPostNotification { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsPostNotification" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContextBase.IsPostNotification" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsPostNotification As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsPostNotification { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsPostNotification : bool" Usage="System.Web.HttpContextBase.IsPostNotification" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Web.Abstractions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在派生类中重写时，获取一个值，该值指示 <see cref="T:System.Web.HttpApplication" /> 事件是否已完成处理。</summary>
        <value>如果该事件已完成处理，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotImplementedException">始终。</exception>
      </Docs>
    </Member>
    <Member MemberName="IsWebSocketRequest">
      <MemberSignature Language="C#" Value="public virtual bool IsWebSocketRequest { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsWebSocketRequest" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContextBase.IsWebSocketRequest" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsWebSocketRequest As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsWebSocketRequest { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsWebSocketRequest : bool" Usage="System.Web.HttpContextBase.IsWebSocketRequest" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在派生类中实现时，获取一个值，该值指示该请求是否是一个 <see cref="T:System.Web.WebSockets.AspNetWebSocket" /> 连接请求。</summary>
        <value>如果该请求是一个 <see cref="T:System.Web.WebSockets.AspNetWebSocket" /> 请求，则为 <see langword="true" />，否则为 <see langword="false" />。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsWebSocketRequestUpgrading">
      <MemberSignature Language="C#" Value="public virtual bool IsWebSocketRequestUpgrading { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsWebSocketRequestUpgrading" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContextBase.IsWebSocketRequestUpgrading" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsWebSocketRequestUpgrading As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsWebSocketRequestUpgrading { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsWebSocketRequestUpgrading : bool" Usage="System.Web.HttpContextBase.IsWebSocketRequestUpgrading" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在派生类中实现时，获取一个值，该值指示连接是否从 HTTP 连接更新到 <see cref="T:System.Web.WebSockets.AspNetWebSocket" /> 连接。</summary>
        <value>如果连接正在升级，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Items">
      <MemberSignature Language="C#" Value="public virtual System.Collections.IDictionary Items { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.IDictionary Items" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContextBase.Items" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Items As IDictionary" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Collections::IDictionary ^ Items { System::Collections::IDictionary ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Items : System.Collections.IDictionary" Usage="System.Web.HttpContextBase.Items" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Web.Abstractions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IDictionary</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在派生类中重写时，获取可用于在 HTTP 请求过程中在模块和处理程序之间组织和共享数据的键/值集合。</summary>
        <value>键/值集合，通过使用指定的键来提供对集合中个别值的访问。</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotImplementedException">始终。</exception>
      </Docs>
    </Member>
    <Member MemberName="PageInstrumentation">
      <MemberSignature Language="C#" Value="public virtual System.Web.Instrumentation.PageInstrumentationService PageInstrumentation { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.Instrumentation.PageInstrumentationService PageInstrumentation" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContextBase.PageInstrumentation" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property PageInstrumentation As PageInstrumentationService" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Web::Instrumentation::PageInstrumentationService ^ PageInstrumentation { System::Web::Instrumentation::PageInstrumentationService ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.PageInstrumentation : System.Web.Instrumentation.PageInstrumentationService" Usage="System.Web.HttpContextBase.PageInstrumentation" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.Instrumentation.PageInstrumentationService</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在派生类中实现时，获取对此请求的页检测服务实例的引用。</summary>
        <value>此请求的页检测服务实例。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviousHandler">
      <MemberSignature Language="C#" Value="public virtual System.Web.IHttpHandler PreviousHandler { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.IHttpHandler PreviousHandler" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContextBase.PreviousHandler" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property PreviousHandler As IHttpHandler" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Web::IHttpHandler ^ PreviousHandler { System::Web::IHttpHandler ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.PreviousHandler : System.Web.IHttpHandler" Usage="System.Web.HttpContextBase.PreviousHandler" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Web.Abstractions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.IHttpHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在派生类中重写时，获取父处理程序的 <see cref="T:System.Web.IHttpHandler" /> 对象。</summary>
        <value>表示父处理程序的 <see cref="T:System.Web.IHttpHandler" /> 对象，如果未找到任何父处理程序，则为 <see langword="null" />。</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotImplementedException">始终。</exception>
      </Docs>
    </Member>
    <Member MemberName="Profile">
      <MemberSignature Language="C#" Value="public virtual System.Web.Profile.ProfileBase Profile { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.Profile.ProfileBase Profile" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContextBase.Profile" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Profile As ProfileBase" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Web::Profile::ProfileBase ^ Profile { System::Web::Profile::ProfileBase ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Profile : System.Web.Profile.ProfileBase" Usage="System.Web.HttpContextBase.Profile" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Web.Abstractions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.Profile.ProfileBase</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在派生类中重写时，获取当前用户配置文件的 <see cref="T:System.Web.Profile.ProfileBase" /> 对象。</summary>
        <value>如果在应用程序配置文件中定义了配置文件属性，并对应用程序启用了配置文件，则为表示当前用户配置文件的对象；否则为 <see langword="null" />。</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotImplementedException">始终。</exception>
      </Docs>
    </Member>
    <Member MemberName="RemapHandler">
      <MemberSignature Language="C#" Value="public virtual void RemapHandler (System.Web.IHttpHandler handler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RemapHandler(class System.Web.IHttpHandler handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContextBase.RemapHandler(System.Web.IHttpHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub RemapHandler (handler As IHttpHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void RemapHandler(System::Web::IHttpHandler ^ handler);" />
      <MemberSignature Language="F#" Value="abstract member RemapHandler : System.Web.IHttpHandler -&gt; unit&#xA;override this.RemapHandler : System.Web.IHttpHandler -&gt; unit" Usage="httpContextBase.RemapHandler handler" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="handler" Type="System.Web.IHttpHandler" />
      </Parameters>
      <Docs>
        <param name="handler">应处理请求的对象。</param>
        <summary>在派生类中重写时，指定请求的处理程序。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果您设置`handler`到`null`的默认处理程序用于处理该请求。 可以设置`handler`到异步处理或同步处理程序。 该处理程序必须实现<xref:System.Web.IHttpHandler>接口。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">派生的类型无法实现此方法。</exception>
      </Docs>
    </Member>
    <Member MemberName="Request">
      <MemberSignature Language="C#" Value="public virtual System.Web.HttpRequestBase Request { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.HttpRequestBase Request" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContextBase.Request" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Request As HttpRequestBase" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Web::HttpRequestBase ^ Request { System::Web::HttpRequestBase ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Request : System.Web.HttpRequestBase" Usage="System.Web.HttpContextBase.Request" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Web.Abstractions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.HttpRequestBase</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当在派生类中重写时，获取当前 HTTP 请求的 <see cref="T:System.Web.HttpRequest" /> 对象。</summary>
        <value>当前 HTTP 请求。</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotImplementedException">始终。</exception>
      </Docs>
    </Member>
    <Member MemberName="Response">
      <MemberSignature Language="C#" Value="public virtual System.Web.HttpResponseBase Response { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.HttpResponseBase Response" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContextBase.Response" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Response As HttpResponseBase" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Web::HttpResponseBase ^ Response { System::Web::HttpResponseBase ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Response : System.Web.HttpResponseBase" Usage="System.Web.HttpContextBase.Response" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Web.Abstractions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.HttpResponseBase</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在派生类中重写时，获取当前 HTTP 响应的 <see cref="T:System.Web.HttpResponse" /> 对象。</summary>
        <value>当前 HTTP 响应。</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotImplementedException">始终。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="RewritePath">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>在派生类中重写时，分配内部重写路径，使得请求 URL 可以与资源的内部路径不同。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RewritePath">
      <MemberSignature Language="C#" Value="public virtual void RewritePath (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RewritePath(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContextBase.RewritePath(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub RewritePath (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void RewritePath(System::String ^ path);" />
      <MemberSignature Language="F#" Value="abstract member RewritePath : string -&gt; unit&#xA;override this.RewritePath : string -&gt; unit" Usage="httpContextBase.RewritePath path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Web.Abstractions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">替换路径。</param>
        <summary>当在派生类中重写时，通过使用指定的路径重写 URL。</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotImplementedException">始终。</exception>
      </Docs>
    </Member>
    <Member MemberName="RewritePath">
      <MemberSignature Language="C#" Value="public virtual void RewritePath (string path, bool rebaseClientPath);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RewritePath(string path, bool rebaseClientPath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContextBase.RewritePath(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub RewritePath (path As String, rebaseClientPath As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void RewritePath(System::String ^ path, bool rebaseClientPath);" />
      <MemberSignature Language="F#" Value="abstract member RewritePath : string * bool -&gt; unit&#xA;override this.RewritePath : string * bool -&gt; unit" Usage="httpContextBase.RewritePath (path, rebaseClientPath)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Web.Abstractions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="rebaseClientPath" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="path">替换路径。</param>
        <param name="rebaseClientPath">如果重置虚拟路径，则为 <see langword="true" />；如果保持虚拟路径不变，则为 <see langword="false" />。</param>
        <summary>在派生类中重写时，使用指定路径和一个指定是否已修改服务器资源虚拟路径的值，重写 URL。</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotImplementedException">始终。</exception>
      </Docs>
    </Member>
    <Member MemberName="RewritePath">
      <MemberSignature Language="C#" Value="public virtual void RewritePath (string filePath, string pathInfo, string queryString);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RewritePath(string filePath, string pathInfo, string queryString) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContextBase.RewritePath(System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub RewritePath (filePath As String, pathInfo As String, queryString As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void RewritePath(System::String ^ filePath, System::String ^ pathInfo, System::String ^ queryString);" />
      <MemberSignature Language="F#" Value="abstract member RewritePath : string * string * string -&gt; unit&#xA;override this.RewritePath : string * string * string -&gt; unit" Usage="httpContextBase.RewritePath (filePath, pathInfo, queryString)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Web.Abstractions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filePath" Type="System.String" />
        <Parameter Name="pathInfo" Type="System.String" />
        <Parameter Name="queryString" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="filePath">替换路径。</param>
        <param name="pathInfo">资源的附加路径信息。</param>
        <param name="queryString">请求查询字符串。</param>
        <summary>在派生类中重写时，使用指定的路径、路径信息和查询字符串信息重写 URL。</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotImplementedException">始终。</exception>
      </Docs>
    </Member>
    <Member MemberName="RewritePath">
      <MemberSignature Language="C#" Value="public virtual void RewritePath (string filePath, string pathInfo, string queryString, bool setClientFilePath);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RewritePath(string filePath, string pathInfo, string queryString, bool setClientFilePath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContextBase.RewritePath(System.String,System.String,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub RewritePath (filePath As String, pathInfo As String, queryString As String, setClientFilePath As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void RewritePath(System::String ^ filePath, System::String ^ pathInfo, System::String ^ queryString, bool setClientFilePath);" />
      <MemberSignature Language="F#" Value="abstract member RewritePath : string * string * string * bool -&gt; unit&#xA;override this.RewritePath : string * string * string * bool -&gt; unit" Usage="httpContextBase.RewritePath (filePath, pathInfo, queryString, setClientFilePath)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Web.Abstractions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filePath" Type="System.String" />
        <Parameter Name="pathInfo" Type="System.String" />
        <Parameter Name="queryString" Type="System.String" />
        <Parameter Name="setClientFilePath" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="filePath">替换路径。</param>
        <param name="pathInfo">资源的附加路径信息。</param>
        <param name="queryString">请求查询字符串。</param>
        <param name="setClientFilePath">若要将用于客户端资源的文件路径设置为 filePath<c></c> 参数的值，则为 <see langword="true" />；否则为 <see langword="false" />。</param>
        <summary>在派生类中重写时，使用指定路径、路径信息、查询字符串信息和一个值重写 URL，该值指定是否将客户端文件路径设置为重写路径。</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotImplementedException">始终。</exception>
      </Docs>
    </Member>
    <Member MemberName="Server">
      <MemberSignature Language="C#" Value="public virtual System.Web.HttpServerUtilityBase Server { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.HttpServerUtilityBase Server" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContextBase.Server" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Server As HttpServerUtilityBase" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Web::HttpServerUtilityBase ^ Server { System::Web::HttpServerUtilityBase ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Server : System.Web.HttpServerUtilityBase" Usage="System.Web.HttpContextBase.Server" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Web.Abstractions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.HttpServerUtilityBase</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在派生类中重写时，获取 <see cref="T:System.Web.HttpServerUtility" /> 对象，该对象提供在处理 Web 请求时使用的方法。</summary>
        <value>当前 HTTP 请求的服务器实用工具对象。</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotImplementedException">始终。</exception>
      </Docs>
    </Member>
    <Member MemberName="Session">
      <MemberSignature Language="C#" Value="public virtual System.Web.HttpSessionStateBase Session { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.HttpSessionStateBase Session" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContextBase.Session" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Session As HttpSessionStateBase" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Web::HttpSessionStateBase ^ Session { System::Web::HttpSessionStateBase ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Session : System.Web.HttpSessionStateBase" Usage="System.Web.HttpContextBase.Session" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Web.Abstractions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.HttpSessionStateBase</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当在派生类中重写时，获取当前 HTTP 请求的 <see cref="T:System.Web.SessionState.HttpSessionState" /> 对象。</summary>
        <value>当前 HTTP 请求的会话状态对象。</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotImplementedException">始终。</exception>
      </Docs>
    </Member>
    <Member MemberName="SetSessionStateBehavior">
      <MemberSignature Language="C#" Value="public virtual void SetSessionStateBehavior (System.Web.SessionState.SessionStateBehavior sessionStateBehavior);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SetSessionStateBehavior(valuetype System.Web.SessionState.SessionStateBehavior sessionStateBehavior) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContextBase.SetSessionStateBehavior(System.Web.SessionState.SessionStateBehavior)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void SetSessionStateBehavior(System::Web::SessionState::SessionStateBehavior sessionStateBehavior);" />
      <MemberSignature Language="F#" Value="abstract member SetSessionStateBehavior : System.Web.SessionState.SessionStateBehavior -&gt; unit&#xA;override this.SetSessionStateBehavior : System.Web.SessionState.SessionStateBehavior -&gt; unit" Usage="httpContextBase.SetSessionStateBehavior sessionStateBehavior" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sessionStateBehavior" Type="System.Web.SessionState.SessionStateBehavior" />
      </Parameters>
      <Docs>
        <param name="sessionStateBehavior">枚举值之一，该值指定需要什么类型的会话状态行为。</param>
        <summary>在派生类中重写时，设置支持 HTTP 请求所必需的会话状态行为的类型。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpContextBase.SetSessionStateBehavior%2A>方法提供了基方法必须由从此类型继承的类实现。 ASP.NET 为实现此方法在<xref:System.Web.HttpContextWrapper>和<xref:System.Web.HttpContext>类。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">派生的类型无法实现此方法。</exception>
        <altmember cref="M:System.Web.HttpContext.SetSessionStateBehavior(System.Web.SessionState.SessionStateBehavior)" />
      </Docs>
    </Member>
    <Member MemberName="SkipAuthorization">
      <MemberSignature Language="C#" Value="public virtual bool SkipAuthorization { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SkipAuthorization" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContextBase.SkipAuthorization" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property SkipAuthorization As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool SkipAuthorization { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.SkipAuthorization : bool with get, set" Usage="System.Web.HttpContextBase.SkipAuthorization" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Web.Abstractions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在派生类中重写时，获取或设置一个值，该值指定 <see cref="T:System.Web.Security.UrlAuthorizationModule" /> 对象是否应跳过对当前请求的授权检查。</summary>
        <value>如果 <see cref="T:System.Web.Security.UrlAuthorizationModule" /> 应跳过授权检查，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotImplementedException">始终。</exception>
      </Docs>
    </Member>
    <Member MemberName="ThreadAbortOnTimeout">
      <MemberSignature Language="C#" Value="public virtual bool ThreadAbortOnTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ThreadAbortOnTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContextBase.ThreadAbortOnTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property ThreadAbortOnTimeout As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool ThreadAbortOnTimeout { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.ThreadAbortOnTimeout : bool with get, set" Usage="System.Web.HttpContextBase.ThreadAbortOnTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在派生类中实现时，获取或设置一个值，该值指示 ASP.NET 运行时是否应在请求超时时，在为该请求提供服务的线程上调用 <see cref="M:System.Threading.Thread.Abort" />。</summary>
        <value>如果在线程超时时调用 <see cref="M:System.Threading.Thread.Abort" />，则为 <see langword="true" />；否则为 <see langword="false" />。 默认值为 <see langword="true" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 有关详情，请参阅<xref:System.Web.HttpContext.ThreadAbortOnTimeout%2A?displayProperty=nameWithType>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Timestamp">
      <MemberSignature Language="C#" Value="public virtual DateTime Timestamp { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime Timestamp" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContextBase.Timestamp" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Timestamp As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property DateTime Timestamp { DateTime get(); };" />
      <MemberSignature Language="F#" Value="member this.Timestamp : DateTime" Usage="System.Web.HttpContextBase.Timestamp" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Web.Abstractions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在派生类中重写时，获取当前 HTTP 请求的初始时间戳。</summary>
        <value>当前 HTTP 请求的时间戳。</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotImplementedException">始终。</exception>
      </Docs>
    </Member>
    <Member MemberName="Trace">
      <MemberSignature Language="C#" Value="public virtual System.Web.TraceContext Trace { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.TraceContext Trace" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContextBase.Trace" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Trace As TraceContext" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Web::TraceContext ^ Trace { System::Web::TraceContext ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Trace : System.Web.TraceContext" Usage="System.Web.HttpContextBase.Trace" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Web.Abstractions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.TraceContext</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在派生类中重写时，获取当前 HTTP 响应的 <see cref="T:System.Web.TraceContext" /> 对象。</summary>
        <value>当前 HTTP 响应的跟踪对象。</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotImplementedException">始终。</exception>
      </Docs>
    </Member>
    <Member MemberName="User">
      <MemberSignature Language="C#" Value="public virtual System.Security.Principal.IPrincipal User { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Principal.IPrincipal User" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContextBase.User" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property User As IPrincipal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Security::Principal::IPrincipal ^ User { System::Security::Principal::IPrincipal ^ get(); void set(System::Security::Principal::IPrincipal ^ value); };" />
      <MemberSignature Language="F#" Value="member this.User : System.Security.Principal.IPrincipal with get, set" Usage="System.Web.HttpContextBase.User" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Web.Abstractions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Principal.IPrincipal</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当在派生类中重写时，获取或设置当前 HTTP 请求的安全信息。</summary>
        <value>一个对象，它包含当前 HTTP 请求的安全信息。</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotImplementedException">始终。</exception>
      </Docs>
    </Member>
    <Member MemberName="WebSocketNegotiatedProtocol">
      <MemberSignature Language="C#" Value="public virtual string WebSocketNegotiatedProtocol { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string WebSocketNegotiatedProtocol" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContextBase.WebSocketNegotiatedProtocol" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property WebSocketNegotiatedProtocol As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ WebSocketNegotiatedProtocol { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.WebSocketNegotiatedProtocol : string" Usage="System.Web.HttpContextBase.WebSocketNegotiatedProtocol" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在派生类中实现时，为 <see cref="T:System.Web.WebSockets.AspNetWebSocket" /> 连接获取从服务器发送到客户端的协商协议。</summary>
        <value>协商协议。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="WebSocketRequestedProtocols">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IList&lt;string&gt; WebSocketRequestedProtocols { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IList`1&lt;string&gt; WebSocketRequestedProtocols" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContextBase.WebSocketRequestedProtocols" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property WebSocketRequestedProtocols As IList(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Collections::Generic::IList&lt;System::String ^&gt; ^ WebSocketRequestedProtocols { System::Collections::Generic::IList&lt;System::String ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.WebSocketRequestedProtocols : System.Collections.Generic.IList&lt;string&gt;" Usage="System.Web.HttpContextBase.WebSocketRequestedProtocols" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IList&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在派生类中实现时，获取客户端请求的协议的顺序列表。</summary>
        <value>请求的协议，如果不是 <see cref="T:System.Web.WebSockets.AspNetWebSocket" /> 请求，或者列表不存在则为 <see langword="null" />。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>