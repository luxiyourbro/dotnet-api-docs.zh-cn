<Type Name="BindingGroup" FullName="System.Windows.Data.BindingGroup">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="75e5aedb20ccf9bd83f94de09ef1c9ab7f3863a2" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-CN" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30630611" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class BindingGroup : System.Windows.DependencyObject" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit BindingGroup extends System.Windows.DependencyObject" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Data.BindingGroup" />
  <TypeSignature Language="VB.NET" Value="Public Class BindingGroup&#xA;Inherits DependencyObject" />
  <TypeSignature Language="C++ CLI" Value="public ref class BindingGroup : System::Windows::DependencyObject" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.DependencyObject</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>包含绑定集合和用于验证对象的 <see cref="T:System.Windows.Controls.ValidationRule" /> 对象。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A<xref:System.Windows.Data.BindingGroup>创建多个绑定，它可以验证并一起更新之间的关系。 例如，假设应用程序将提示用户输入的地址。 然后，应用程序填充类型的对象`Address`，其中具有属性， `Street`， `City`， `ZipCode`，和`Country`，与用户提供的值。 应用程序具有包含四个面板<xref:System.Windows.Controls.TextBox>控件，其中每个被数据绑定到对象的属性之一。 你可以使用<xref:System.Windows.Controls.ValidationRule>中<xref:System.Windows.Data.BindingGroup>验证`Address`对象。 如果绑定参与相同<xref:System.Windows.Data.BindingGroup>，你可确保邮政编码的有效地址的国家/地区。  
  
 你设置<xref:System.Windows.FrameworkElement.BindingGroup%2A>属性<xref:System.Windows.FrameworkElement>或<xref:System.Windows.FrameworkContentElement>。 子元素继承<xref:System.Windows.Data.BindingGroup>从其父元素，就像使用任何其他可继承的属性。 上的子代元素的绑定添加到<xref:System.Windows.Data.BindingGroup>如果发生以下情况之一：  
  
-   绑定的源和<xref:System.Windows.FrameworkElement.DataContext%2A>具有的元素的<xref:System.Windows.Data.BindingGroup>相同的对象和<xref:System.Windows.Data.BindingBase.BindingGroupName%2A>未设置属性。  
  
-   <xref:System.Windows.Data.BindingBase.BindingGroupName%2A>绑定属性等同于<xref:System.Windows.Data.BindingGroup.Name%2A>的<xref:System.Windows.FrameworkContentElement.BindingGroup%2A>和它们未显式设置为`null`。  
  
 在地址的示例中，假设<xref:System.Windows.FrameworkElement.DataContext%2A>的<xref:System.Windows.Controls.Panel>设置类型的对象为`Address`。 每个绑定<xref:System.Windows.Controls.TextBox>添加到<xref:System.Windows.Data.BindingGroup>的面板。  
  
 你添加<xref:System.Windows.Controls.ValidationRule>对象添加到<xref:System.Windows.Data.BindingGroup>。 <xref:System.Windows.Data.BindingGroup>作为的第一个参数传递<xref:System.Windows.Controls.ValidationRule.Validate%2A>方法时<xref:System.Windows.Controls.ValidationRule>运行。 你可以使用<xref:System.Windows.Data.BindingGroup.TryGetValue%2A>或<xref:System.Windows.Data.BindingGroup.GetValue%28System.Object%2CSystem.String%29>方法，<xref:System.Windows.Data.BindingGroup>若要获取的对象的建议的值和<xref:System.Windows.Data.BindingGroup.Items%2A>要获取的绑定源属性。  
  
 A<xref:System.Windows.Data.BindingGroup>更新在同一时间而不是分别更新每个绑定的绑定源。 当调用其中一个用于验证数据的方法 (<xref:System.Windows.Data.BindingGroup.ValidateWithoutUpdate%2A>， <xref:System.Windows.Data.BindingGroup.UpdateSources%2A>，或<xref:System.Windows.Data.BindingGroup.CommitEdit%2A>)，每个绑定<xref:System.Windows.Controls.TextBox>中示例经过验证，并且可能会更新。 如果绑定是属于<xref:System.Windows.Data.BindingGroup>，直到你调用未更新绑定源<xref:System.Windows.Data.BindingGroup.UpdateSources%2A>或<xref:System.Windows.Data.BindingGroup.CommitEdit%2A>上<xref:System.Windows.Data.BindingGroup>，除非你显式设置<xref:System.Windows.Data.Binding.UpdateSourceTrigger%2A>属性。  
  
   
  
## Examples  
 下面的示例创建的应用程序会提示用户输入的描述和价格的项以及优惠过期的日期。 应用程序将显示窗体下的项的当前信息。 用户可以提交或取消所做的更改。  
  
 应用程序执行以下操作来实现此行为。  
  
-   创建<xref:System.Windows.Data.BindingGroup>并将其添加根<xref:System.Windows.Controls.StackPanel>创建时[!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)]的应用程序。  
  
-   调用<xref:System.Windows.Data.BindingGroup.BeginEdit%2A>， <xref:System.Windows.Data.BindingGroup.CommitEdit%2A>，和<xref:System.Windows.Data.BindingGroup.CancelEdit%2A>中启用的应用程序的逻辑回滚做的更改。  
  
-   调用<xref:System.Windows.Data.BindingGroup.TryGetValue%2A>中<xref:System.Windows.Controls.ValidationRule.Validate%2A>方法以获取用户的输入，然后检查超过 100 美元的项至少为七天中是否可用。  
  
 下面的示例创建[!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)]的应用程序。 根<xref:System.Windows.Controls.StackPanel>具有<xref:System.Windows.Data.BindingGroup>包含<xref:System.Windows.Controls.ValidationRule>来验证该项目，如前面所述。 上的绑定对象`Price`属性和`OfferExpires`的属性变得一部分<xref:System.Windows.Data.BindingGroup>和每个绑定都具有<xref:System.Windows.Controls.ValidationRule>若要确保价格和日期，分别是有效的值。 各个属性的验证规则之前运行<xref:System.Windows.Controls.ValidationRule>上<xref:System.Windows.Data.BindingGroup>。  
  
 [!code-xaml[BindingGroupSnippets#WindowLayout](~/samples/snippets/csharp/VS_Snippets_Wpf/BindingGroupSnippets/CSharp/Window1.xaml#windowlayout)]  
  
 下面的示例演示应用程序的事件处理程序。 当用户单击提交按钮时，在应用程序调用<xref:System.Windows.Data.BindingGroup.CommitEdit%2A>来分别运行<xref:System.Windows.Controls.ValidationRule>关联<xref:System.Windows.Data.BindingGroup>。 如果每个<xref:System.Windows.Controls.ValidationRule>成功，<xref:System.Windows.Data.BindingGroup.CommitEdit%2A>保存对该对象的值，并结束编辑事务。 如果<xref:System.Windows.Data.BindingGroup.CommitEdit%2A>是成功，则应用程序将开始另一个编辑事务。 当<xref:System.Windows.Controls.ValidationRule>失败，<xref:System.Windows.Controls.Validation.Error?displayProperty=nameWithType>事件发生，因为应用程序设置<xref:System.Windows.Data.BindingGroup.NotifyOnValidationError%2A>到`true`上<xref:System.Windows.Data.BindingGroup>（在前面的示例）。 `ItemError` 句柄<xref:System.Windows.Controls.Validation.Error?displayProperty=nameWithType>事件，并显示有关用户的验证错误的信息。 该示例还处理<xref:System.Windows.FrameworkElement.Loaded>事件<xref:System.Windows.Controls.StackPanel>和<xref:System.Windows.Controls.Primitives.ButtonBase.Click>事件**取消**按钮。  
  
 [!code-csharp[BindingGroupSnippets#WindowLogic](~/samples/snippets/csharp/VS_Snippets_Wpf/BindingGroupSnippets/CSharp/Window1.xaml.cs#windowlogic)]
 [!code-vb[BindingGroupSnippets#WindowLogic](~/samples/snippets/visualbasic/VS_Snippets_Wpf/BindingGroupSnippets/visualbasic/window1.xaml.vb#windowlogic)]  
  
 下面的示例演示了自定义<xref:System.Windows.Controls.ValidationRule> `ValidateDateAndPrice`，它被添加到<xref:System.Windows.Data.BindingGroup>中第一个示例。 <xref:System.Windows.Controls.ValidationRule>使用<xref:System.Windows.Data.BindingGroup>中其<xref:System.Windows.Controls.ValidationRule.Validate%2A>方法以获取用户输入到窗体中，然后检查如果项是超过 100 美元，是否将至少为七天的值。  
  
 [!code-csharp[BindingGroupSnippets#ValidateObject](~/samples/snippets/csharp/VS_Snippets_Wpf/BindingGroupSnippets/CSharp/Data.cs#validateobject)]
 [!code-vb[BindingGroupSnippets#ValidateObject](~/samples/snippets/visualbasic/VS_Snippets_Wpf/BindingGroupSnippets/visualbasic/data.vb#validateobject)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BindingGroup ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.BindingGroup.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; BindingGroup();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>初始化 <see cref="T:System.Windows.Data.BindingGroup" /> 类的新实例。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginEdit">
      <MemberSignature Language="C#" Value="public void BeginEdit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BeginEdit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.BindingGroup.BeginEdit" />
      <MemberSignature Language="VB.NET" Value="Public Sub BeginEdit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BeginEdit();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>开始 <see cref="T:System.Windows.Data.BindingGroup" /> 中源上的编辑事务。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果在源<xref:System.Windows.Data.BindingGroup>支持放弃挂起的更改，你可以调用<xref:System.Windows.Data.BindingGroup.BeginEdit%2A>若要开始编辑事务，调用<xref:System.Windows.Data.BindingGroup.CommitEdit%2A>若要保存挂起的更改，请调用<xref:System.Windows.Data.BindingGroup.CancelEdit%2A>可以放弃挂起的更改。  
  
 中每个对象<xref:System.Windows.Data.BindingGroup.Items%2A>实现<xref:System.ComponentModel.IEditableObject>，<xref:System.Windows.Data.BindingGroup.BeginEdit%2A>调用 <xref:System.ComponentModel.IEditableObject.BeginEdit%2A?displayProperty=nameWithType>  
  
   
  
## Examples  
 下面的示例调用<xref:System.Windows.Data.BindingGroup.BeginEdit%2A>窗口加载时若要开始编辑事务。  
  
 [!code-csharp[BindingGroupSnippets#BeginEdit](~/samples/snippets/csharp/VS_Snippets_Wpf/BindingGroupSnippets/CSharp/Window1.xaml.cs#beginedit)]
 [!code-vb[BindingGroupSnippets#BeginEdit](~/samples/snippets/visualbasic/VS_Snippets_Wpf/BindingGroupSnippets/visualbasic/window1.xaml.vb#beginedit)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BindingExpressions">
      <MemberSignature Language="C#" Value="public System.Collections.ObjectModel.Collection&lt;System.Windows.Data.BindingExpressionBase&gt; BindingExpressions { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.ObjectModel.Collection`1&lt;class System.Windows.Data.BindingExpressionBase&gt; BindingExpressions" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Data.BindingGroup.BindingExpressions" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property BindingExpressions As Collection(Of BindingExpressionBase)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::ObjectModel::Collection&lt;System::Windows::Data::BindingExpressionBase ^&gt; ^ BindingExpressions { System::Collections::ObjectModel::Collection&lt;System::Windows::Data::BindingExpressionBase ^&gt; ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.Collection&lt;System.Windows.Data.BindingExpressionBase&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取 <see cref="T:System.Windows.Data.BindingExpression" /> 对象的集合，其中包含有关 <see cref="T:System.Windows.Data.BindingGroup" /> 中每个绑定的信息。</summary>
        <value>一个 <see cref="T:System.Windows.Data.BindingExpression" /> 对象的集合，其中包含有关 <see cref="T:System.Windows.Data.BindingGroup" /> 中每个绑定的信息。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A<xref:System.Windows.Data.BindingExpression>属于<xref:System.Windows.Data.BindingGroup>如果发生以下情况之一：  
  
-   绑定的源和<xref:System.Windows.FrameworkElement.DataContext%2A>具有的元素的<xref:System.Windows.Data.BindingGroup>相同的对象和<xref:System.Windows.Data.BindingBase.BindingGroupName%2A>未设置。  
  
-   <xref:System.Windows.Data.BindingBase.BindingGroupName%2A>绑定属性和<xref:System.Windows.Data.BindingGroup.Name%2A>的<xref:System.Windows.Data.BindingGroup>设置为相同的非 null 值和<xref:System.Windows.Data.BindingGroup>所属的绑定目标元素的父元素。  
  
-   你添加<xref:System.Windows.Data.BindingExpression>到<xref:System.Windows.Data.BindingGroup.BindingExpressions%2A>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CancelEdit">
      <MemberSignature Language="C#" Value="public void CancelEdit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CancelEdit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.BindingGroup.CancelEdit" />
      <MemberSignature Language="VB.NET" Value="Public Sub CancelEdit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CancelEdit();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>结束编辑事务并放弃挂起的更改。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法使源放弃挂起的更改，如果源对象是能够执行此操作并结束编辑事务。 然后该方法使用保存的源值更新目标属性。  
  
 中每个对象<xref:System.Windows.Data.BindingGroup.Items%2A>实现<xref:System.ComponentModel.IEditableObject>，<xref:System.Windows.Data.BindingGroup.CancelEdit%2A>调用 <xref:System.ComponentModel.IEditableObject.CancelEdit%2A?displayProperty=nameWithType>  
  
   
  
## Examples  
 下面的示例调用<xref:System.Windows.Data.BindingGroup.CancelEdit%2A>可以放弃挂起的更改，然后调用<xref:System.Windows.Data.BindingGroup.BeginEdit%2A>准备要重新编辑的源。  
  
 [!code-csharp[BindingGroupSnippets#CancelEdit](~/samples/snippets/csharp/VS_Snippets_Wpf/BindingGroupSnippets/CSharp/Window1.xaml.cs#canceledit)]
 [!code-vb[BindingGroupSnippets#CancelEdit](~/samples/snippets/visualbasic/VS_Snippets_Wpf/BindingGroupSnippets/visualbasic/window1.xaml.vb#canceledit)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanRestoreValues">
      <MemberSignature Language="C#" Value="public bool CanRestoreValues { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanRestoreValues" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Data.BindingGroup.CanRestoreValues" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CanRestoreValues As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CanRestoreValues { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取绑定中的每个源是否都可以放弃挂起的更改并还原原始值。</summary>
        <value>
          如果绑定中的每个源都可以放弃挂起的更改并还原原始值，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 源可以放弃挂起的更改，如果它实现<xref:System.ComponentModel.IEditableObject>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CommitEdit">
      <MemberSignature Language="C#" Value="public bool CommitEdit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool CommitEdit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.BindingGroup.CommitEdit" />
      <MemberSignature Language="VB.NET" Value="Public Function CommitEdit () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool CommitEdit();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>运行所有 <see cref="T:System.Windows.Controls.ValidationRule" /> 对象，并且在所有验证规则都成功时，更新绑定源。</summary>
        <returns>
          如果每个 <see cref="T:System.Windows.Controls.ValidationRule" /> 都成功且将值提交到了源，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果每个<xref:System.Windows.Controls.ValidationRule>成功，此方法使源提交挂起的更改并结束编辑事务，如果源对象是能够执行此操作。  
  
 中每个对象<xref:System.Windows.Data.BindingGroup.Items%2A>实现<xref:System.ComponentModel.IEditableObject>，<xref:System.Windows.Data.BindingGroup.CommitEdit%2A>调用 <xref:System.ComponentModel.IEditableObject.EndEdit%2A?displayProperty=nameWithType>  
  
   
  
## Examples  
 下面的示例调用<xref:System.Windows.Data.BindingGroup.CommitEdit%2A>保存挂起的更改，然后调用<xref:System.Windows.Data.BindingGroup.BeginEdit%2A>准备要重新编辑的源。  
  
 [!code-csharp[BindingGroupSnippets#BeginEdit](~/samples/snippets/csharp/VS_Snippets_Wpf/BindingGroupSnippets/CSharp/Window1.xaml.cs#beginedit)]
 [!code-vb[BindingGroupSnippets#BeginEdit](~/samples/snippets/visualbasic/VS_Snippets_Wpf/BindingGroupSnippets/visualbasic/window1.xaml.vb#beginedit)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public object GetValue (object item, string propertyName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetValue(object item, string propertyName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.BindingGroup.GetValue(System.Object,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetValue (item As Object, propertyName As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetValue(System::Object ^ item, System::String ^ propertyName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="System.Object" />
        <Parameter Name="propertyName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="item">包含指定属性的对象。</param>
        <param name="propertyName">要获取其建议值的属性。</param>
        <summary>返回指定的属性和项的建议值。</summary>
        <returns>建议的属性值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用此方法在<xref:System.Windows.Controls.ValidationRule.Validate%2A?displayProperty=nameWithType>方法以获取要将其提交到源的值。 返回值的类型取决于从该处阶段<xref:System.Windows.Controls.ValidationRule>时发生。 例如，如果<xref:System.Windows.Controls.TextBox>数据绑定到整数类型的属性和<xref:System.Windows.Controls.ValidationRule>调用<xref:System.Windows.Data.BindingGroup.GetValue%28System.Object%2CSystem.String%29>具有其<xref:System.Windows.Controls.ValidationRule.ValidationStep%2A>设置为<xref:System.Windows.Controls.ValidationStep.RawProposedValue>，该方法返回一个字符串。 如果<xref:System.Windows.Controls.ValidationRule>具有其<xref:System.Windows.Controls.ValidationRule.ValidationStep%2A>设置为<xref:System.Windows.Controls.ValidationStep.ConvertedProposedValue>，该方法返回绑定的转换器返回任何类型。 在此示例中，<xref:System.Windows.Data.BindingGroup.GetValue%28System.Object%2CSystem.String%29>通常返回一个整数。  
  
   
  
## Examples  
 下面的示例是应用的提示用户输入多个客户，并将销售代表分配给每个客户的一部分。 应用程序将检查销售代表和客户属于同一区域。 示例所示<xref:System.Windows.Controls.ValidationRule.Validate%2A>方法，它使用<xref:System.Windows.Data.BindingGroup.GetValue%28System.Object%2CSystem.String%29>方法以获取客户输入的值。  
  
 [!code-csharp[BindingGroupSnippets#ItemBindGroupValidationRule](~/samples/snippets/csharp/VS_Snippets_Wpf/BindingGroupSnippets/CSharp/Window2.xaml.cs#itembindgroupvalidationrule)]
 [!code-vb[BindingGroupSnippets#ItemBindGroupValidationRule](~/samples/snippets/visualbasic/VS_Snippets_Wpf/BindingGroupSnippets/visualbasic/window2.xaml.vb#itembindgroupvalidationrule)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">指定项和属性之间没有绑定。</exception>
        <exception cref="T:System.Windows.Data.ValueUnavailableException">由于转换错误或早期验证规则失败，指定的属性值不可用。</exception>
      </Docs>
    </Member>
    <Member MemberName="HasValidationError">
      <MemberSignature Language="C#" Value="public bool HasValidationError { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasValidationError" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Data.BindingGroup.HasValidationError" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HasValidationError As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool HasValidationError { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示 <see cref="T:System.Windows.Data.BindingGroup" /> 是否具有一个失败的验证规则。</summary>
        <value>
          如果 <see cref="T:System.Windows.Data.BindingGroup" /> 具有一个失败的验证规则，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsDirty">
      <MemberSignature Language="C#" Value="public bool IsDirty { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsDirty" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Data.BindingGroup.IsDirty" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsDirty As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsDirty { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置指示 <see cref="T:System.Windows.Data.BindingGroup" /> 是否包含尚未写入到源中的建议值的值。</summary>
        <value>
          如果 <see cref="T:System.Windows.Data.BindingGroup" /> 包含尚未写入到源的建议值，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Items">
      <MemberSignature Language="C#" Value="public System.Collections.IList Items { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.IList Items" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Data.BindingGroup.Items" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Items As IList" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::IList ^ Items { System::Collections::IList ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IList</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取 <see cref="T:System.Windows.Data.BindingGroup" /> 中的绑定对象所使用的源。</summary>
        <value>
          <see cref="T:System.Windows.Data.BindingGroup" /> 中的绑定对象所使用的源。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 用作源添加到每个对象<xref:System.Windows.Data.BindingGroup.Items%2A>属性一次，即使该对象用作多个绑定源。 通常情况下，没有中的只有一项<xref:System.Windows.Data.BindingGroup.Items%2A>，即是对象<xref:System.Windows.FrameworkElement.DataContext%2A>使用的元素<xref:System.Windows.Data.BindingGroup>。 之所以<xref:System.Windows.Data.BindingGroup>但是具有多个源。 例如，如果绑定对象共用同一个<xref:System.Windows.Data.BindingBase.BindingGroupName%2A>但使用不同的源对象，作为源使用每个对象都在<xref:System.Windows.Data.BindingGroup.Items%2A>。  
  
 也可以在多个对象<xref:System.Windows.Data.BindingGroup.Items%2A>如果绑定的路径被解析为嵌套的属性的源。 例如，假设<xref:System.Windows.Controls.TextBox>控件的绑定是的一部分<xref:System.Windows.Data.BindingGroup>及其<xref:System.Windows.FrameworkElement.DataContext%2A>是`Customer`具有类型的属性的对象`Address`。 如果<xref:System.Windows.Data.Binding.Path%2A>的<xref:System.Windows.Data.Binding>是`Address.ZipCode`属性，`Address`添加到<xref:System.Windows.Data.BindingGroup.Items%2A>属性。  
  
   
  
## Examples  
 以下示例是应用的检查用户是否已设置为相等的值的两个对象的属性的一部分。 第一个示例创建两个<xref:System.Windows.Controls.TextBox>控件，其中每个被数据绑定到不同的源。 第一个绑定<xref:System.Windows.Controls.TextBox>获取它的源， `object1`，从<xref:System.Windows.FrameworkElement.DataContext%2A>的<xref:System.Windows.Controls.TextBox>控件的父元素 ( <xref:System.Windows.Controls.StackPanel>)。 在第二个<xref:System.Windows.Controls.TextBox>，绑定源设置为`object2`。 此示例还创建<xref:System.Windows.Controls.Label>显示验证错误。  
  
 [!code-xaml[BindingGroupSnippets#BindingGroupName](~/samples/snippets/csharp/VS_Snippets_Wpf/BindingGroupSnippets/CSharp/Window3.xaml#bindinggroupname)]  
[!code-xaml[BindingGroupSnippets#ValidationAdornerSite](~/samples/snippets/csharp/VS_Snippets_Wpf/BindingGroupSnippets/CSharp/Window3.xaml#validationadornersite)]  
  
 下面的示例演示<xref:System.Windows.Controls.ValidationRule>前面的示例使用。 在<xref:System.Windows.Controls.ValidationRule.Validate%2A>方法，此示例获取从每个源对象<xref:System.Windows.Data.BindingGroup>并检查对象的属性是否相等。  
  
 [!code-csharp[BindingGroupSnippets#BindingGroupNameValidationRule](~/samples/snippets/csharp/VS_Snippets_Wpf/BindingGroupSnippets/CSharp/Window3.xaml.cs#bindinggroupnamevalidationrule)]
 [!code-vb[BindingGroupSnippets#BindingGroupNameValidationRule](~/samples/snippets/visualbasic/VS_Snippets_Wpf/BindingGroupSnippets/visualbasic/window3.xaml.vb#bindinggroupnamevalidationrule)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public string Name { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Data.BindingGroup.Name" />
      <MemberSignature Language="VB.NET" Value="Public Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Name { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置标识 <see cref="T:System.Windows.Data.BindingGroup" /> 的名称，该名称可用于在 <see cref="T:System.Windows.Data.BindingGroup" /> 中包括和排除绑定对象。</summary>
        <value>标识 <see cref="T:System.Windows.Data.BindingGroup" /> 的名称。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果<xref:System.Windows.Data.BindingGroup.Name%2A>是`null`，这些绑定具有的是与相同的对象的源，<xref:System.Windows.FrameworkElement.DataContext%2A>具有的元素的<xref:System.Windows.Data.BindingGroup>参与<xref:System.Windows.Data.BindingGroup>。  
  
 你可以包含具有不同于源的绑定<xref:System.Windows.FrameworkElement.DataContext%2A>具有的父元素的<xref:System.Windows.Data.BindingGroup>通过设置<xref:System.Windows.Data.BindingGroup.Name%2A>的<xref:System.Windows.Data.BindingGroup>和<xref:System.Windows.Data.BindingBase.BindingGroupName%2A>的一种绑定到相同的值的属性。 你可以排除具有相同的源的绑定<xref:System.Windows.FrameworkElement.DataContext%2A>具有的父元素的<xref:System.Windows.Data.BindingGroup>通过设置<xref:System.Windows.Data.BindingGroup.Name%2A>的<xref:System.Windows.Data.BindingGroup>和<xref:System.Windows.Data.BindingBase.BindingGroupName%2A>的一种绑定到不同的值的属性。  
  
   
  
## Examples  
 以下示例是应用的检查用户是否已设置为相等的值的两个对象的属性的一部分。 第一个示例创建两个<xref:System.Windows.Controls.TextBox>控件，其中每个被数据绑定到不同的源。 第一个绑定<xref:System.Windows.Controls.TextBox>属于<xref:System.Windows.Data.BindingGroup>因为<xref:System.Windows.Controls.TextBox>继承<xref:System.Windows.FrameworkElement.DataContext%2A>和<xref:System.Windows.Data.BindingGroup>从其父级<xref:System.Windows.Controls.StackPanel>。  
  
 在第二个绑定<xref:System.Windows.Controls.TextBox>属于<xref:System.Windows.Data.BindingGroup>因为<xref:System.Windows.Data.BindingGroup.Name%2A>的<xref:System.Windows.Data.BindingGroup>和<xref:System.Windows.Data.BindingBase.BindingGroupName%2A>的<xref:System.Windows.Data.Binding>都设置为`bindingGroup`。  
  
 [!code-xaml[BindingGroupSnippets#BindingGroupName](~/samples/snippets/csharp/VS_Snippets_Wpf/BindingGroupSnippets/CSharp/Window3.xaml#bindinggroupname)]  
[!code-xaml[BindingGroupSnippets#ValidationAdornerSite](~/samples/snippets/csharp/VS_Snippets_Wpf/BindingGroupSnippets/CSharp/Window3.xaml#validationadornersite)]  
  
 下面的示例演示<xref:System.Windows.Controls.ValidationRule>前面的示例使用。 在<xref:System.Windows.Controls.ValidationRule.Validate%2A>方法，此示例获取从每个源对象<xref:System.Windows.Data.BindingGroup>并检查对象的属性是否相等。  
  
 [!code-csharp[BindingGroupSnippets#BindingGroupNameValidationRule](~/samples/snippets/csharp/VS_Snippets_Wpf/BindingGroupSnippets/CSharp/Window3.xaml.cs#bindinggroupnamevalidationrule)]
 [!code-vb[BindingGroupSnippets#BindingGroupNameValidationRule](~/samples/snippets/visualbasic/VS_Snippets_Wpf/BindingGroupSnippets/visualbasic/window3.xaml.vb#bindinggroupnamevalidationrule)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="NotifyOnValidationError">
      <MemberSignature Language="C#" Value="public bool NotifyOnValidationError { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool NotifyOnValidationError" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Data.BindingGroup.NotifyOnValidationError" />
      <MemberSignature Language="VB.NET" Value="Public Property NotifyOnValidationError As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool NotifyOnValidationError { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置在 <see cref="E:System.Windows.Controls.Validation.Error" /> 的状态更改时是否发生 <see cref="T:System.Windows.Controls.ValidationRule" /> 事件。</summary>
        <value>
          如果在 <see cref="E:System.Windows.Controls.Validation.Error" /> 的状态更改时发生 <see cref="T:System.Windows.Controls.ValidationRule" /> 事件，则为 <see langword="true" />；否则为 <see langword="false" />。 默认值为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Controls.Validation.Error?displayProperty=nameWithType>上具有的元素的附加的事件发生<xref:System.Windows.Data.BindingGroup>。  
  
   
  
## Examples  
 下面的示例创建<xref:System.Windows.Data.BindingGroup>和设置<xref:System.Windows.Data.BindingGroup.NotifyOnValidationError%2A>到`true`以便应用程序可以处理<xref:System.Windows.Controls.Validation.Error?displayProperty=nameWithType>事件时<xref:System.Windows.Controls.ValidationRule>失败。  
  
 [!code-xaml[BindingGroupSnippets#BindingGroup](~/samples/snippets/csharp/VS_Snippets_Wpf/BindingGroupSnippets/CSharp/Window1.xaml#bindinggroup)]  
  
 下面的示例处理<xref:System.Windows.Controls.Validation.Error?displayProperty=nameWithType>事件。  
  
 [!code-csharp[BindingGroupSnippets#ErrorHandler](~/samples/snippets/csharp/VS_Snippets_Wpf/BindingGroupSnippets/CSharp/Window1.xaml.cs#errorhandler)]
 [!code-vb[BindingGroupSnippets#ErrorHandler](~/samples/snippets/visualbasic/VS_Snippets_Wpf/BindingGroupSnippets/visualbasic/window1.xaml.vb#errorhandler)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Owner">
      <MemberSignature Language="C#" Value="public System.Windows.DependencyObject Owner { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.DependencyObject Owner" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Data.BindingGroup.Owner" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Owner As DependencyObject" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::DependencyObject ^ Owner { System::Windows::DependencyObject ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取 <see cref="T:System.Windows.Data.BindingGroup" /> 分配到的对象。</summary>
        <value>
          <see cref="T:System.Windows.Data.BindingGroup" /> 分配给的对象。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SharesProposedValues">
      <MemberSignature Language="C#" Value="public bool SharesProposedValues { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SharesProposedValues" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Data.BindingGroup.SharesProposedValues" />
      <MemberSignature Language="VB.NET" Value="Public Property SharesProposedValues As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool SharesProposedValues { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值指示 <see cref="T:System.Windows.Data.BindingGroup" /> 是否重新使用尚未提交到源的目标值。</summary>
        <value>
          如果 <see cref="T:System.Windows.Data.BindingGroup" /> 重新使用尚未提交到源的目标值，则为 <see langword="true" />；否则为 <see langword="false" />。 默认值为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 建议的值为一个值，已更改的一个绑定，在目标上但尚未提交到源。 例如，假设上是一个双向绑定<xref:System.Windows.Controls.TextBox>和<xref:System.Windows.Data.Binding.UpdateSourceTrigger%2A>属性设置为<xref:System.Windows.Data.UpdateSourceTrigger.Explicit>。 如果用户更改的值<xref:System.Windows.Controls.TextBox>，建议的值是中的值<xref:System.Windows.Controls.TextBox>才会提交到源。  
  
 当<xref:System.Windows.Data.BindingGroup.SharesProposedValues%2A>是`true`、<xref:System.Windows.Data.BindingGroup>时绑定离开 BindingGroup 和另一个绑定，具有相同的源联接 BindingGroup 使用建议的值。  例如，假设应用程序使用户可以编辑多个字段并通过单击一个按钮更新源对象。 当不编辑字段时，应用程序将显示在<xref:System.Windows.Controls.TextBlock>。 当用户开始编辑字段时，该应用程序将替换<xref:System.Windows.Controls.TextBlock>与<xref:System.Windows.Controls.TextBox>。 当用户完成编辑该字段时，该应用程序将替换<xref:System.Windows.Controls.TextBox>与<xref:System.Windows.Controls.TextBlock>。 因为源还未更新，直到用户单击按钮时，必须有一种方法<xref:System.Windows.Controls.TextBlock>以显示建议的值。 通过设置<xref:System.Windows.Data.BindingGroup.SharesProposedValues%2A>到`true`，应用程序将向字段显示用户的更改，即使尚未更新源。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryGetValue">
      <MemberSignature Language="C#" Value="public bool TryGetValue (object item, string propertyName, out object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryGetValue(object item, string propertyName, [out] object&amp; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.BindingGroup.TryGetValue(System.Object,System.String,System.Object@)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryGetValue (item As Object, propertyName As String, ByRef value As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryGetValue(System::Object ^ item, System::String ^ propertyName, [Runtime::InteropServices::Out] System::Object ^ % value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="System.Object" />
        <Parameter Name="propertyName" Type="System.String" />
        <Parameter Name="value" Type="System.Object&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="item">包含指定属性的对象。</param>
        <param name="propertyName">要获取其建议值的属性。</param>
        <param name="value">此方法在返回时包含一个表示建议的属性值的对象。 此参数未经初始化即被传递。</param>
        <summary>尝试获取指定属性和项的建议值。</summary>
        <returns>
          如果值为指定属性的建议值，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Data.BindingGroup.TryGetValue%2A> 返回`false`如果不存在指定的项和属性的绑定的指定属性的值不可用，由于转换错误或者因为早期的验证规则失败。  
  
 使用此方法在<xref:System.Windows.Controls.ValidationRule.Validate%2A?displayProperty=nameWithType>方法以获取要将其提交到源的值。 类型`value`取决于从该处阶段<xref:System.Windows.Controls.ValidationRule>时发生。 例如，如果<xref:System.Windows.Controls.TextBox>被数据绑定到的整数类型，属性`value`是一个字符串，如果<xref:System.Windows.Controls.ValidationRule>调用<xref:System.Windows.Data.BindingGroup.TryGetValue%2A>具有其<xref:System.Windows.Controls.ValidationRule.ValidationStep%2A>设置为<xref:System.Windows.Controls.ValidationStep.RawProposedValue>。 如果<xref:System.Windows.Controls.ValidationRule>具有其<xref:System.Windows.Controls.ValidationRule.ValidationStep%2A>设置为<xref:System.Windows.Controls.ValidationStep.ConvertedProposedValue>的一种`value`是任何类型，它由绑定的转换器。 在此示例中，`value`通常是一个整数。  
  
   
  
## Examples  
 下面的示例创建一个自定义<xref:System.Windows.Controls.ValidationRule>名为`ValidateDateAndPrice`。 在<xref:System.Windows.Controls.ValidationRule.Validate%2A>方法，该示例使用<xref:System.Windows.Data.BindingGroup.TryGetValue%2A>方法和<xref:System.Windows.Data.BindingGroup.Items%2A>属性来获取用户输入到窗体中的值。 然后该示例检查是否项是超过 100 美元，是否将至少为七天。 此示例摘自的更大的示例在<xref:System.Windows.Data.BindingGroup>类  
  
 [!code-csharp[BindingGroupSnippets#ValidateObject](~/samples/snippets/csharp/VS_Snippets_Wpf/BindingGroupSnippets/CSharp/Data.cs#validateobject)]
 [!code-vb[BindingGroupSnippets#ValidateObject](~/samples/snippets/visualbasic/VS_Snippets_Wpf/BindingGroupSnippets/visualbasic/data.vb#validateobject)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UpdateSources">
      <MemberSignature Language="C#" Value="public bool UpdateSources ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool UpdateSources() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.BindingGroup.UpdateSources" />
      <MemberSignature Language="VB.NET" Value="Public Function UpdateSources () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool UpdateSources();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>如果所有验证规则都成功，则对绑定和将 <see cref="T:System.Windows.Controls.ValidationRule" /> 属性设置为 <see cref="P:System.Windows.Controls.ValidationRule.ValidationStep" />、<see cref="F:System.Windows.Controls.ValidationStep.RawProposedValue" /> 或 <see cref="F:System.Windows.Controls.ValidationStep.ConvertedProposedValue" /> 的 <see cref="F:System.Windows.Controls.ValidationStep.UpdatedValue" /> 对象运行转换器，并将目标值保存到源对象。</summary>
        <returns>
          如果所有验证规则都成功，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法更新源，如果每个<xref:System.Windows.Controls.ValidationRule>成功，但它不会导致源挂起的更改提交并结束编辑事务。 也就是说，如果源对象实现<xref:System.ComponentModel.IEditableObject>。 调用此方法不会导致<xref:System.ComponentModel.IEditableObject.EndEdit%2A>调用。 使用<xref:System.Windows.Data.BindingGroup.CommitEdit%2A>方法，让提交挂起的更改的源。  
  
   
  
## Examples  
 下面的示例是应用的提示用户输入多个客户，并将销售代表分配给每个客户的一部分。 应用程序将检查销售代表和客户属于同一区域。 该示例通过调用<xref:System.Windows.Data.BindingGroup.UpdateSources%2A>验证绑定并将值保存到源，如果所有验证规则都成功。  
  
 [!code-csharp[BindingGroupSnippets#UpdateSources](~/samples/snippets/csharp/VS_Snippets_Wpf/BindingGroupSnippets/CSharp/Window2.xaml.cs#updatesources)]
 [!code-vb[BindingGroupSnippets#UpdateSources](~/samples/snippets/visualbasic/VS_Snippets_Wpf/BindingGroupSnippets/visualbasic/window2.xaml.vb#updatesources)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ValidatesOnNotifyDataError">
      <MemberSignature Language="C#" Value="public bool ValidatesOnNotifyDataError { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ValidatesOnNotifyDataError" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Data.BindingGroup.ValidatesOnNotifyDataError" />
      <MemberSignature Language="VB.NET" Value="Public Property ValidatesOnNotifyDataError As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ValidatesOnNotifyDataError { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值指示是否包含 <see cref="T:System.Windows.Controls.NotifyDataErrorValidationRule" />。</summary>
        <value>
          如果包含 <see cref="T:System.Windows.Controls.NotifyDataErrorValidationRule" />，则为 <see langword="true" />；否则为 <see langword="false" />。 默认值为 <see langword="true" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当<xref:System.Windows.Data.BindingGroup.ValidatesOnNotifyDataError%2A>是`true`的绑定来查看和报告由实现的数据源引发的错误<xref:System.ComponentModel.INotifyDataErrorInfo>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ValidateWithoutUpdate">
      <MemberSignature Language="C#" Value="public bool ValidateWithoutUpdate ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ValidateWithoutUpdate() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.BindingGroup.ValidateWithoutUpdate" />
      <MemberSignature Language="VB.NET" Value="Public Function ValidateWithoutUpdate () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ValidateWithoutUpdate();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>对绑定和将 <see cref="T:System.Windows.Controls.ValidationRule" /> 属性设置为 <see cref="P:System.Windows.Controls.ValidationRule.ValidationStep" /> 或 <see cref="F:System.Windows.Controls.ValidationStep.RawProposedValue" /> 的 <see cref="F:System.Windows.Controls.ValidationStep.ConvertedProposedValue" /> 对象运行转换器。</summary>
        <returns>
          如果验证规则成功，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在调用此方法时，不会更新源。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ValidationErrors">
      <MemberSignature Language="C#" Value="public System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Windows.Controls.ValidationError&gt; ValidationErrors { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;class System.Windows.Controls.ValidationError&gt; ValidationErrors" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Data.BindingGroup.ValidationErrors" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ValidationErrors As ReadOnlyCollection(Of ValidationError)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::ObjectModel::ReadOnlyCollection&lt;System::Windows::Controls::ValidationError ^&gt; ^ ValidationErrors { System::Collections::ObjectModel::ReadOnlyCollection&lt;System::Windows::Controls::ValidationError ^&gt; ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Windows.Controls.ValidationError&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取促使 <see cref="T:System.Windows.Controls.ValidationError" /> 有效的 <see cref="T:System.Windows.Data.BindingGroup" /> 对象的集合。</summary>
        <value>导致 <see cref="T:System.Windows.Controls.ValidationError" /> 无效的 <see cref="T:System.Windows.Data.BindingGroup" /> 对象的集合。  如果没有错误，此值为 <see langword="null" />。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ValidationRules">
      <MemberSignature Language="C#" Value="public System.Collections.ObjectModel.Collection&lt;System.Windows.Controls.ValidationRule&gt; ValidationRules { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.ObjectModel.Collection`1&lt;class System.Windows.Controls.ValidationRule&gt; ValidationRules" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Data.BindingGroup.ValidationRules" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ValidationRules As Collection(Of ValidationRule)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::ObjectModel::Collection&lt;System::Windows::Controls::ValidationRule ^&gt; ^ ValidationRules { System::Collections::ObjectModel::Collection&lt;System::Windows::Controls::ValidationRule ^&gt; ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.Collection&lt;System.Windows.Controls.ValidationRule&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取 <see cref="T:System.Windows.Controls.ValidationRule" /> 对象的集合，这些对象验证 <see cref="T:System.Windows.Data.BindingGroup" /> 中的源对象。</summary>
        <value>
          <see cref="T:System.Windows.Controls.ValidationRule" /> 对象的集合，这些对象验证 <see cref="T:System.Windows.Data.BindingGroup" /> 中的源对象。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当<xref:System.Windows.Controls.ValidationRule>添加到<xref:System.Windows.Data.BindingGroup>、<xref:System.Windows.Data.BindingGroup>中的第一个参数作为传递<xref:System.Windows.Controls.ValidationRule.Validate%2A>方法。 你可以通过获取对象的建议的值<xref:System.Windows.Data.BindingGroup.TryGetValue%2A>或<xref:System.Windows.Data.BindingGroup.GetValue%28System.Object%2CSystem.String%29>方法。 你可以从绑定源的对象<xref:System.Windows.Data.BindingGroup.Items%2A>属性。  
  
   
  
## Examples  
 下面的示例添加自定义<xref:System.Windows.Controls.ValidationRule>，`ValidateDateAndPrice`到<xref:System.Windows.Data.BindingGroup>。  
  
 [!code-xaml[BindingGroupSnippets#BindingGroup](~/samples/snippets/csharp/VS_Snippets_Wpf/BindingGroupSnippets/CSharp/Window1.xaml#bindinggroup)]  
  
 下面的示例展示了 `ValidateDateAndPrice` 类。 <xref:System.Windows.Controls.ValidationRule.Validate%2A>方法使用<xref:System.Windows.Data.BindingGroup>获取用户输入到窗体中，然后检查如果项是超过 100 美元，是否将至少为七天的值。  
  
 [!code-csharp[BindingGroupSnippets#ValidateObject](~/samples/snippets/csharp/VS_Snippets_Wpf/BindingGroupSnippets/CSharp/Data.cs#validateobject)]
 [!code-vb[BindingGroupSnippets#ValidateObject](~/samples/snippets/visualbasic/VS_Snippets_Wpf/BindingGroupSnippets/visualbasic/data.vb#validateobject)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>