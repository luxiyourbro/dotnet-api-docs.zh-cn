<Type Name="EditingCommands" FullName="System.Windows.Documents.EditingCommands">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="30b353139e00ffa86a542c259a68250718297ece" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-CN" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30631391" />
  </Metadata>
  <TypeSignature Language="C#" Value="public static class EditingCommands" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit EditingCommands extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Documents.EditingCommands" />
  <TypeSignature Language="VB.NET" Value="Public Class EditingCommands" />
  <TypeSignature Language="C++ CLI" Value="public ref class EditingCommands abstract sealed" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>提供一组标准的与编辑相关的命令。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表显示了编辑命令和关联的默认键笔势 (与中的键名<xref:System.Windows.Input.Key>和<xref:System.Windows.Input.ModifierKeys>枚举)。  
  
|编辑命令|默认键笔势|  
|---------------------|-------------------------|  
|<xref:System.Windows.Documents.EditingCommands.AlignCenter%2A>|`Ctrl`+`E`|  
|<xref:System.Windows.Documents.EditingCommands.AlignJustify%2A>|`Ctrl`+`J`|  
|<xref:System.Windows.Documents.EditingCommands.AlignLeft%2A>|`Ctrl`+`L`|  
|<xref:System.Windows.Documents.EditingCommands.AlignRight%2A>|`Ctrl`+`R`|  
|<xref:System.Windows.Documents.EditingCommands.Backspace%2A>|`Backspace`|  
|<xref:System.Windows.Documents.EditingCommands.CorrectSpellingError%2A>|无默认键笔势|  
|<xref:System.Windows.Documents.EditingCommands.DecreaseFontSize%2A>|`Ctrl`+`OemOpenBrackets`|  
|<xref:System.Windows.Documents.EditingCommands.DecreaseIndentation%2A>|`Ctrl`+`Shift`+`T`|  
|<xref:System.Windows.Documents.EditingCommands.Delete%2A>|`Delete`|  
|<xref:System.Windows.Documents.EditingCommands.DeleteNextWord%2A>|`Ctrl`+`Delete`|  
|<xref:System.Windows.Documents.EditingCommands.DeletePreviousWord%2A>|`Ctrl`+`Backspace`|  
|<xref:System.Windows.Documents.EditingCommands.EnterLineBreak%2A>|`Shift`+`Enter`|  
|<xref:System.Windows.Documents.EditingCommands.EnterParagraphBreak%2A>|`Enter`|  
|<xref:System.Windows.Documents.EditingCommands.IgnoreSpellingError%2A>|无默认键笔势|  
|<xref:System.Windows.Documents.EditingCommands.IncreaseFontSize%2A>|`Ctrl`+`OemCloseBrackets`|  
|<xref:System.Windows.Documents.EditingCommands.IncreaseIndentation%2A>|`Ctrl`+`T`|  
|<xref:System.Windows.Documents.EditingCommands.MoveDownByLine%2A>|`Down`|  
|<xref:System.Windows.Documents.EditingCommands.MoveDownByPage%2A>|`PageDown`|  
|<xref:System.Windows.Documents.EditingCommands.MoveDownByParagraph%2A>|`Ctrl`+`Down`|  
|<xref:System.Windows.Documents.EditingCommands.MoveLeftByCharacter%2A>|`Left`|  
|<xref:System.Windows.Documents.EditingCommands.MoveLeftByWord%2A>|`Ctrl`+`Left`|  
|<xref:System.Windows.Documents.EditingCommands.MoveRightByCharacter%2A>|`Right`|  
|<xref:System.Windows.Documents.EditingCommands.MoveRightByWord%2A>|`Ctrl`+`Right`|  
|<xref:System.Windows.Documents.EditingCommands.MoveToDocumentEnd%2A>|`Ctrl`+`End`|  
|<xref:System.Windows.Documents.EditingCommands.MoveToDocumentStart%2A>|`Ctrl`+`Home`|  
|<xref:System.Windows.Documents.EditingCommands.MoveToLineEnd%2A>|`End`|  
|<xref:System.Windows.Documents.EditingCommands.MoveToLineStart%2A>|`Home`|  
|<xref:System.Windows.Documents.EditingCommands.MoveUpByLine%2A>|`Up`|  
|<xref:System.Windows.Documents.EditingCommands.MoveUpByPage%2A>|`PageUp`|  
|<xref:System.Windows.Documents.EditingCommands.MoveUpByParagraph%2A>|`Ctrl`+`Up`|  
|<xref:System.Windows.Documents.EditingCommands.SelectDownByLine%2A>|`Shift`+`Down`|  
|<xref:System.Windows.Documents.EditingCommands.SelectDownByPage%2A>|`Shift`+`PageDown`|  
|<xref:System.Windows.Documents.EditingCommands.SelectDownByParagraph%2A>|`Ctrl`+`Shift`+`Down`|  
|<xref:System.Windows.Documents.EditingCommands.SelectLeftByCharacter%2A>|`Shift`+`Left`|  
|<xref:System.Windows.Documents.EditingCommands.SelectLeftByWord%2A>|`Ctrl`+`Shift`+`Left`|  
|<xref:System.Windows.Documents.EditingCommands.SelectRightByCharacter%2A>|`Shift`+`Right`|  
|<xref:System.Windows.Documents.EditingCommands.SelectRightByWord%2A>|`Ctrl`+`Shift`+`Right`|  
|<xref:System.Windows.Documents.EditingCommands.SelectToDocumentEnd%2A>|`Ctrl`+`Shift`+`End`|  
|<xref:System.Windows.Documents.EditingCommands.SelectToDocumentStart%2A>|`Ctrl`+`Shift`+`Home`|  
|<xref:System.Windows.Documents.EditingCommands.SelectToLineEnd%2A>|`Shift`+`End`|  
|<xref:System.Windows.Documents.EditingCommands.SelectToLineStart%2A>|`Shift`+`Home`|  
|<xref:System.Windows.Documents.EditingCommands.SelectUpByLine%2A>|`Shift`+`Up`|  
|<xref:System.Windows.Documents.EditingCommands.SelectUpByPage%2A>|`Shift`+`PageUp`|  
|<xref:System.Windows.Documents.EditingCommands.SelectUpByParagraph%2A>|`Ctrl`+`Shift`+`Up`|  
|<xref:System.Windows.Documents.EditingCommands.TabBackward%2A>|`Shift`+`Tab`|  
|<xref:System.Windows.Documents.EditingCommands.TabForward%2A>|`Tab`|  
|<xref:System.Windows.Documents.EditingCommands.ToggleBold%2A>|`Ctrl`+`B`|  
|<xref:System.Windows.Documents.EditingCommands.ToggleBullets%2A>|`Ctrl`+`Shift`+`L`|  
|<xref:System.Windows.Documents.EditingCommands.ToggleInsert%2A>|`Insert`|  
|<xref:System.Windows.Documents.EditingCommands.ToggleItalic%2A>|`Ctrl`+`I`|  
|<xref:System.Windows.Documents.EditingCommands.ToggleNumbering%2A>|`Ctrl`+`Shift`+`N`|  
|<xref:System.Windows.Documents.EditingCommands.ToggleSubscript%2A>|`Ctrl`+`OemPlus`|  
|<xref:System.Windows.Documents.EditingCommands.ToggleSuperscript%2A>|`Ctrl`+`Shift+OemPlus`|  
|<xref:System.Windows.Documents.EditingCommands.ToggleUnderline%2A>|`Ctrl`+`U`|  
  
 插入符号移动命令和选择扩展命令共享一组公共的默认键笔势，常规的不同就是添加<xref:System.Windows.Input.ModifierKeys.Shift>键以插入符号移动命令区分开来选择命令。  例如，<xref:System.Windows.Documents.EditingCommands.MoveLeftByCharacter%2A>命令具有的默认键笔势<xref:System.Windows.Input.Key.Left>，和相应<xref:System.Windows.Documents.EditingCommands.SelectLeftByCharacter%2A>命令具有的默认键笔势<xref:System.Windows.Input.ModifierKeys.Shift> + <xref:System.Windows.Input.Key.Left>。  
  
 一般情况下，命令定义由<xref:System.Windows.Documents.EditingCommands>类不能使用的命令参数 (`parameter`参数应通过<xref:System.Windows.Input.ICommand.Execute%2A>方法)。  
  
 有关命令和命令的详细信息，请参阅[输入概述](~/docs/framework/wpf/advanced/input-overview.md)。  
  
   
  
## Examples  
 下面的示例演示如何调用上支持该命令的对象的编辑命令。  
  
 对于此示例，<xref:System.Windows.Controls.RichTextBox>用作命令目标。  请注意，<xref:System.Windows.Controls.RichTextBox>实现<xref:System.Windows.IInputElement>接口 (继承自<xref:System.Windows.FrameworkElement>)，它包括对很多编辑命令的本机支持。  
  
 第一个参数<xref:System.Windows.Input.RoutedCommand.Execute%2A>方法是命令参数。  最编辑命令忽略命令参数;一般情况下，此参数应`null`以进行编辑命令。  
  
 第二个参数指定该命令将路由到的对象。  此对象必须实现<xref:System.Windows.IInputElement>接口，并且应包括的处理程序指定的命令。  通常情况下，在不处理该命令的对象上调用时，已忽略命令。  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.Input.MediaCommands" />
    <altmember cref="T:System.Windows.Input.ApplicationCommands" />
    <altmember cref="T:System.Windows.Input.ComponentCommands" />
    <altmember cref="T:System.Windows.Input.RoutedCommand" />
    <altmember cref="T:System.Windows.Input.RoutedUICommand" />
    <altmember cref="T:System.Windows.Input.CommandBinding" />
    <altmember cref="T:System.Windows.Input.CommandManager" />
    <altmember cref="T:System.Windows.Input.NavigationCommands" />
  </Docs>
  <Members>
    <Member MemberName="AlignCenter">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand AlignCenter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand AlignCenter" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.AlignCenter" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property AlignCenter As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ AlignCenter { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>表示 <see cref="P:System.Windows.Documents.EditingCommands.AlignCenter" /> 命令，该命令请求将当前段落或选中的段落居中。</summary>
        <value>请求的命令。  此命令的默认键笔势<see langword="Ctrl" /> + <see langword="E" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此命令在<xref:System.Windows.Documents.Paragraph>级别。  如果对部分选择的内容 （包括插入符号所在段落中的空选择） 段落中调用此命令，则请求的效果将应用于整个段落。  当跨越多个段落的选择内容调用此命令时，产生的效果被应用于参与选择每个段落的全部内容。  
  
 下图显示了为中心的内容的示例。  
  
 ![屏幕快照： TextAlign 属性值 Center](~/add/media/flowdoc-textalign-center.png "屏幕快照： TextAlign 属性值 Center")  
  
 此命令以本机方式支持通过<xref:System.Windows.Controls.RichTextBox>。  
  
<a name="xamlAttributeUsage_AlignCenter"></a>   
## <a name="xaml-attribute-usage"></a>XAML 属性用法  
  
```  
<object property="AlignCenter"/>  
```  
  
   
  
## Examples  
 下面的示例演示如何调用上支持该命令的对象的编辑命令。  
  
 对于此示例，<xref:System.Windows.Controls.RichTextBox>用作命令目标。  请注意，<xref:System.Windows.Controls.RichTextBox>实现<xref:System.Windows.IInputElement>接口 (继承自<xref:System.Windows.FrameworkElement>)，它包括对很多编辑命令的本机支持。  
  
 第一个参数<xref:System.Windows.Input.RoutedCommand.Execute%2A>方法是命令参数。  最编辑命令忽略命令参数;一般情况下，此参数应`null`以进行编辑命令。  
  
 第二个参数指定该命令将路由到的对象。  此对象必须实现<xref:System.Windows.IInputElement>接口，并且应包括的处理程序指定的命令。  通常情况下，在不处理该命令的对象上调用时，已忽略命令。  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.AlignJustify" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.AlignLeft" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.AlignRight" />
      </Docs>
    </Member>
    <Member MemberName="AlignJustify">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand AlignJustify { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand AlignJustify" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.AlignJustify" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property AlignJustify As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ AlignJustify { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>表示 <see cref="P:System.Windows.Documents.EditingCommands.AlignJustify" /> 命令，该命令请求将当前段落或选中的段落两端对齐。</summary>
        <value>请求的命令。  此命令的默认键笔势<see langword="Ctrl" /> + <see langword="J" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此命令在<xref:System.Windows.Documents.Paragraph>级别。  如果对部分选择的内容 （包括插入符号所在段落中的空选择） 段落中调用此命令，则请求的效果将应用于整个段落。  如果选择范围跨越多个段落中调用此命令，将影响适用于所选内容中的所有段落。  
  
 当内容进行两端对齐时，以便对齐的线的相等或几乎相等宽度调整中各行内容的水平间距。  内容通常两端对齐两侧的内容创建平滑的边缘。  
  
 因为它通常是短于 rest，段落中的最后一行后调用此命令可能保留对齐。  
  
 下图显示对齐 （左对齐） 的内容。  
  
 ![屏幕快照： 内容未对齐](~/add/media/content-unjustified.png "屏幕快照： 内容未对齐")  
  
 下图显示相同的内容后两端对齐。  
  
 ![内容的屏幕截图对齐的文本](~/add/media/content-justified.png "内容的屏幕截图对齐的文本")  
  
 并不一定对任何给定的对象; 此命令的响应的实际实现在许多情况下响应命令的实现是应用程序编写器的责任。  
  
 此命令以本机方式支持通过<xref:System.Windows.Controls.RichTextBox>。  
  
<a name="xamlAttributeUsage_AlignJustify"></a>   
## <a name="xaml-attribute-usage"></a>XAML 属性用法  
  
```  
<object property="AlignJustify"/>  
```  
  
   
  
## Examples  
 下面的示例演示如何调用上支持该命令的对象的编辑命令。  
  
 对于此示例，<xref:System.Windows.Controls.RichTextBox>用作命令目标。  请注意，<xref:System.Windows.Controls.RichTextBox>实现<xref:System.Windows.IInputElement>接口 (继承自<xref:System.Windows.FrameworkElement>)，它包括对很多编辑命令的本机支持。  
  
 第一个参数<xref:System.Windows.Input.RoutedCommand.Execute%2A>方法是命令参数。  最编辑命令忽略命令参数;一般情况下，此参数应`null`以进行编辑命令。  
  
 第二个参数指定该命令将路由到的对象。  此对象必须实现<xref:System.Windows.IInputElement>接口，并且应包括的处理程序指定的命令。  通常情况下，在不处理该命令的对象上调用时，已忽略命令。  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.AlignCenter" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.AlignLeft" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.AlignRight" />
      </Docs>
    </Member>
    <Member MemberName="AlignLeft">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand AlignLeft { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand AlignLeft" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.AlignLeft" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property AlignLeft As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ AlignLeft { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>表示 <see cref="P:System.Windows.Documents.EditingCommands.AlignLeft" /> 命令，该命令请求将所选内容左对齐。</summary>
        <value>请求的命令。  此命令的默认键笔势<see langword="Ctrl" /> + <see langword="L" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此命令在<xref:System.Windows.Documents.Paragraph>级别。  如果对部分选择的内容 （包括插入符号所在段落中的空选择） 段落中调用此命令，则请求的效果将应用于整个段落。  当跨越多个段落的选择内容调用此命令时，产生的效果被应用于参与选择每个段落的全部内容。  
  
 下图显示了左对齐内容的示例。  
  
 ![屏幕快照： TextAlign 属性值为左对齐](~/add/media/flowdoc-textalign-left.png "屏幕快照： TextAlign 属性值为左对齐")  
  
 并不一定对任何给定的对象; 此命令的响应的实际实现在许多情况下响应命令的实现是应用程序编写器的责任。  
  
 此命令以本机方式支持通过<xref:System.Windows.Controls.RichTextBox>。  
  
<a name="xamlAttributeUsage_AlignLeft"></a>   
## <a name="xaml-attribute-usage"></a>XAML 属性用法  
  
```  
<object property="AlignLeft"/>  
```  
  
   
  
## Examples  
 下面的示例演示如何调用上支持该命令的对象的编辑命令。  
  
 对于此示例，<xref:System.Windows.Controls.RichTextBox>用作命令目标。  请注意，<xref:System.Windows.Controls.RichTextBox>实现<xref:System.Windows.IInputElement>接口 (继承自<xref:System.Windows.FrameworkElement>)，它包括对很多编辑命令的本机支持。  
  
 第一个参数<xref:System.Windows.Input.RoutedCommand.Execute%2A>方法是命令参数。  最编辑命令忽略命令参数;一般情况下，此参数应`null`以进行编辑命令。  
  
 第二个参数指定该命令将路由到的对象。  此对象必须实现<xref:System.Windows.IInputElement>接口，并且应包括的处理程序指定的命令。  通常情况下，在不处理该命令的对象上调用时，已忽略命令。  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.AlignCenter" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.AlignJustify" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.AlignRight" />
      </Docs>
    </Member>
    <Member MemberName="AlignRight">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand AlignRight { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand AlignRight" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.AlignRight" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property AlignRight As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ AlignRight { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>表示 <see cref="P:System.Windows.Documents.EditingCommands.AlignRight" /> 命令，该命令请求将所选内容右对齐。</summary>
        <value>请求的命令。  此命令的默认键笔势<see langword="Ctrl" /> + <see langword="R" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此命令在<xref:System.Windows.Documents.Paragraph>级别。  如果对部分选择的内容 （包括插入符号所在段落中的空选择） 段落中调用此命令，则请求的效果将应用于整个段落。  当跨越多个段落的选择内容调用此命令时，产生的效果被应用于参与选择每个段落的全部内容。  
  
 下图显示了右对齐的内容的示例。  
  
 ![屏幕快照： TextAlign 值 Right](~/add/media/flowdoc-textalign-right.png "屏幕快照： TextAlign 值 Right")  
  
 并不一定对任何给定的对象; 此命令的响应的实际实现在许多情况下响应命令的实现是应用程序编写器的责任。  
  
 此命令以本机方式支持通过<xref:System.Windows.Controls.RichTextBox>。  
  
<a name="xamlAttributeUsage_AlignRight"></a>   
## <a name="xaml-attribute-usage"></a>XAML 属性用法  
  
```  
<object property="AlignRight"/>  
```  
  
   
  
## Examples  
 下面的示例演示如何调用上支持该命令的对象的编辑命令。  
  
 对于此示例，<xref:System.Windows.Controls.RichTextBox>用作命令目标。  请注意，<xref:System.Windows.Controls.RichTextBox>实现<xref:System.Windows.IInputElement>接口 (继承自<xref:System.Windows.FrameworkElement>)，它包括对很多编辑命令的本机支持。  
  
 第一个参数<xref:System.Windows.Input.RoutedCommand.Execute%2A>方法是命令参数。  最编辑命令忽略命令参数;一般情况下，此参数应`null`以进行编辑命令。  
  
 第二个参数指定该命令将路由到的对象。  此对象必须实现<xref:System.Windows.IInputElement>接口，并且应包括的处理程序指定的命令。  通常情况下，在不处理该命令的对象上调用时，已忽略命令。  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.AlignCenter" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.AlignJustify" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.AlignRight" />
      </Docs>
    </Member>
    <Member MemberName="Backspace">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand Backspace { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand Backspace" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.Backspace" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Backspace As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ Backspace { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>表示 <see cref="P:System.Windows.Documents.EditingCommands.Backspace" /> 命令，该命令请求在当前位置或当前所选内容上输入一个退格。</summary>
        <value>请求的命令。  此命令的默认键笔势为 <see langword="Backspace" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在空选择调用时，此命令将删除之前插入符号的字符或段落分隔符。 在非空选择调用时，此命令将删除所选内容。  
  
 此命令将保留任何格式设置调用此命令后，在同一位置立即插入的内容已删除所选内容。  与之相反<xref:System.Windows.Documents.EditingCommands.Delete%2A>命令，不会保留以前的格式设置。  
  
 并不一定对任何给定的对象; 此命令的响应的实际实现在许多情况下响应命令的实现是应用程序编写器的责任。  
  
 此命令以本机方式支持通过<xref:System.Windows.Controls.RichTextBox>， <xref:System.Windows.Controls.TextBox>，和<xref:System.Windows.Controls.PasswordBox>。  
  
<a name="xamlAttributeUsage_Backspace"></a>   
## <a name="xaml-attribute-usage"></a>XAML 属性用法  
  
```  
<object property="Backspace"/>  
```  
  
   
  
## Examples  
 下面的示例演示如何调用上支持该命令的对象的编辑命令。  
  
 对于此示例，<xref:System.Windows.Controls.RichTextBox>用作命令目标。  请注意，<xref:System.Windows.Controls.RichTextBox>实现<xref:System.Windows.IInputElement>接口 (继承自<xref:System.Windows.FrameworkElement>)，它包括对很多编辑命令的本机支持。  
  
 第一个参数<xref:System.Windows.Input.RoutedCommand.Execute%2A>方法是命令参数。  最编辑命令忽略命令参数;一般情况下，此参数应`null`以进行编辑命令。  
  
 第二个参数指定该命令将路由到的对象。  此对象必须实现<xref:System.Windows.IInputElement>接口，并且应包括的处理程序指定的命令。  通常情况下，在不处理该命令的对象上调用时，已忽略命令。  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CorrectSpellingError">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand CorrectSpellingError { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand CorrectSpellingError" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.CorrectSpellingError" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CorrectSpellingError As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ CorrectSpellingError { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>表示 <see cref="P:System.Windows.Documents.EditingCommands.CorrectSpellingError" /> 命令，该命令请求更正当前位置任何拼写错误的单词。</summary>
        <value>请求的命令。  此命令无默认键笔势。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 并不一定对任何给定的对象; 此命令的响应的实际实现在许多情况下响应命令的实现是应用程序编写器的责任。  
  
<a name="xamlAttributeUsage_CorrectSpellingError"></a>   
## <a name="xaml-attribute-usage"></a>XAML 属性用法  
  
```  
<object property="CorrectSpellingError"/>  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.IgnoreSpellingError" />
      </Docs>
    </Member>
    <Member MemberName="DecreaseFontSize">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand DecreaseFontSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand DecreaseFontSize" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.DecreaseFontSize" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property DecreaseFontSize As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ DecreaseFontSize { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>表示 <see cref="P:System.Windows.Documents.EditingCommands.DecreaseFontSize" /> 命令，该命令请求将当前所选内容的字号缩小 1 磅。</summary>
        <value>请求的命令。  此命令的默认键笔势<see langword="Ctrl" /> + <see langword="OemOpenBrackets" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当其中脱字号是在某个词的空选择调用此命令时，所选内容会自动扩展以将命令应用于整个单词。  
  
 并不一定对任何给定的对象; 此命令的响应的实际实现在许多情况下响应命令的实现是应用程序编写器的责任。  
  
 此命令以本机方式支持通过<xref:System.Windows.Controls.RichTextBox>。  
  
<a name="xamlAttributeUsage_DecreaseFontSize"></a>   
## <a name="xaml-attribute-usage"></a>XAML 属性用法  
  
```  
<object property="DecreaseFontSize"/>  
```  
  
   
  
## Examples  
 下面的示例演示如何调用上支持该命令的对象的编辑命令。  
  
 对于此示例，<xref:System.Windows.Controls.RichTextBox>用作命令目标。  请注意，<xref:System.Windows.Controls.RichTextBox>实现<xref:System.Windows.IInputElement>接口 (继承自<xref:System.Windows.FrameworkElement>)，它包括对很多编辑命令的本机支持。  
  
 第一个参数<xref:System.Windows.Input.RoutedCommand.Execute%2A>方法是命令参数。  最编辑命令忽略命令参数;一般情况下，此参数应`null`以进行编辑命令。  
  
 第二个参数指定该命令将路由到的对象。  此对象必须实现<xref:System.Windows.IInputElement>接口，并且应包括的处理程序指定的命令。  通常情况下，在不处理该命令的对象上调用时，已忽略命令。  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.IncreaseFontSize" />
      </Docs>
    </Member>
    <Member MemberName="DecreaseIndentation">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand DecreaseIndentation { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand DecreaseIndentation" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.DecreaseIndentation" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property DecreaseIndentation As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ DecreaseIndentation { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>表示 <see cref="P:System.Windows.Documents.EditingCommands.DecreaseIndentation" /> 命令，该命令请求将当前段落的缩进减少一个制表位。</summary>
        <value>请求的命令。  此命令的默认键笔势<see langword="Ctrl" /> + <see langword="Shift" /> + <see langword="T" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 并不一定对任何给定的对象; 此命令的响应的实际实现在许多情况下响应命令的实现是应用程序编写器的责任。  
  
 此命令以本机方式支持通过<xref:System.Windows.Controls.RichTextBox>。  
  
> [!IMPORTANT]
>  此命令不起的文本元素除非<xref:System.Windows.Controls.Primitives.TextBoxBase.AcceptsTab%2A>的文本元素的属性设置为`true`。  
  
<a name="xamlAttributeUsage_DecreaseIndentation"></a>   
## <a name="xaml-attribute-usage"></a>XAML 属性用法  
  
```  
<object property="DecreaseIndentation"/>  
```  
  
   
  
## Examples  
 下面的示例演示如何调用上支持该命令的对象的编辑命令。  
  
 对于此示例，<xref:System.Windows.Controls.RichTextBox>用作命令目标。  请注意，<xref:System.Windows.Controls.RichTextBox>实现<xref:System.Windows.IInputElement>接口 (继承自<xref:System.Windows.FrameworkElement>)，它包括对很多编辑命令的本机支持。  
  
 第一个参数<xref:System.Windows.Input.RoutedCommand.Execute%2A>方法是命令参数。  最编辑命令忽略命令参数;一般情况下，此参数应`null`以进行编辑命令。  
  
 第二个参数指定该命令将路由到的对象。  此对象必须实现<xref:System.Windows.IInputElement>接口，并且应包括的处理程序指定的命令。  通常情况下，在不处理该命令的对象上调用时，已忽略命令。  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.IncreaseIndentation" />
      </Docs>
    </Member>
    <Member MemberName="Delete">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand Delete { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand Delete" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.Delete" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Delete As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ Delete { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>表示 <see cref="P:System.Windows.Documents.EditingCommands.Delete" /> 命令，该命令请求删除当前所选内容。</summary>
        <value>请求的命令。  此命令的默认键笔势为 <see langword="Delete" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此命令将放弃任何格式设置从已删除所选内容。  与之相反<xref:System.Windows.Documents.EditingCommands.Backspace%2A>命令，其中保留后调用此命令将立即插入在同一位置的内容的已删除选择的任何格式。  
  
 并不一定对任何给定的对象; 此命令的响应的实际实现在许多情况下响应命令的实现是应用程序编写器的责任。  
  
 此命令以本机方式支持通过<xref:System.Windows.Controls.RichTextBox>， <xref:System.Windows.Controls.TextBox>，和<xref:System.Windows.Controls.PasswordBox>。  
  
<a name="xamlAttributeUsage_Delete"></a>   
## <a name="xaml-attribute-usage"></a>XAML 属性用法  
  
```  
<object property="Delete"/>  
```  
  
   
  
## Examples  
 下面的示例演示如何调用上支持该命令的对象的编辑命令。  
  
 对于此示例，<xref:System.Windows.Controls.RichTextBox>用作命令目标。  请注意，<xref:System.Windows.Controls.RichTextBox>实现<xref:System.Windows.IInputElement>接口 (继承自<xref:System.Windows.FrameworkElement>)，它包括对很多编辑命令的本机支持。  
  
 第一个参数<xref:System.Windows.Input.RoutedCommand.Execute%2A>方法是命令参数。  最编辑命令忽略命令参数;一般情况下，此参数应`null`以进行编辑命令。  
  
 第二个参数指定该命令将路由到的对象。  此对象必须实现<xref:System.Windows.IInputElement>接口，并且应包括的处理程序指定的命令。  通常情况下，在不处理该命令的对象上调用时，已忽略命令。  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DeleteNextWord">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand DeleteNextWord { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand DeleteNextWord" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.DeleteNextWord" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property DeleteNextWord As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ DeleteNextWord { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>表示 <see cref="P:System.Windows.Documents.EditingCommands.DeleteNextWord" /> 命令，该命令请求删除下一单词（相对于当前位置而言）。</summary>
        <value>请求的命令。  此命令的默认键笔势<see langword="Ctrl" /> + <see langword="Delete" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果脱字号为在某个词，则删除之间当前位置单词末尾的单词的其余部分。  
  
 并不一定对任何给定的对象; 此命令的响应的实际实现在许多情况下响应命令的实现是应用程序编写器的责任。  
  
 此命令以本机方式支持通过<xref:System.Windows.Controls.RichTextBox>， <xref:System.Windows.Controls.TextBox>，和<xref:System.Windows.Controls.PasswordBox>。  
  
<a name="xamlAttributeUsage_DeleteNextWord"></a>   
## <a name="xaml-attribute-usage"></a>XAML 属性用法  
  
```  
<object property="DeleteNextWord"/>  
```  
  
   
  
## Examples  
 下面的示例演示如何调用上支持该命令的对象的编辑命令。  
  
 对于此示例，<xref:System.Windows.Controls.RichTextBox>用作命令目标。  请注意，<xref:System.Windows.Controls.RichTextBox>实现<xref:System.Windows.IInputElement>接口 (继承自<xref:System.Windows.FrameworkElement>)，它包括对很多编辑命令的本机支持。  
  
 第一个参数<xref:System.Windows.Input.RoutedCommand.Execute%2A>方法是命令参数。  最编辑命令忽略命令参数;一般情况下，此参数应`null`以进行编辑命令。  
  
 第二个参数指定该命令将路由到的对象。  此对象必须实现<xref:System.Windows.IInputElement>接口，并且应包括的处理程序指定的命令。  通常情况下，在不处理该命令的对象上调用时，已忽略命令。  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.DeletePreviousWord" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveLeftByWord" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveRightByWord" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectLeftByWord" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectRightByWord" />
      </Docs>
    </Member>
    <Member MemberName="DeletePreviousWord">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand DeletePreviousWord { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand DeletePreviousWord" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.DeletePreviousWord" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property DeletePreviousWord As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ DeletePreviousWord { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>表示 <see cref="P:System.Windows.Documents.EditingCommands.DeletePreviousWord" /> 命令，该命令请求删除上一单词（相对于当前位置而言）。</summary>
        <value>请求的命令。  此命令的默认键笔势<see langword="Ctrl" /> + <see langword="Backspace" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果脱字号为在某个词，则删除当前位置单词的开头之间的单词的其余部分。  
  
 并不一定对任何给定的对象; 此命令的响应的实际实现在许多情况下响应命令的实现是应用程序编写器的责任。  
  
 此命令以本机方式支持通过<xref:System.Windows.Controls.RichTextBox>， <xref:System.Windows.Controls.TextBox>，和<xref:System.Windows.Controls.PasswordBox>。  
  
<a name="xamlAttributeUsage_DeletePreviousWord"></a>   
## <a name="xaml-attribute-usage"></a>XAML 属性用法  
  
```  
<object property="DeletePreviousWord"/>  
```  
  
   
  
## Examples  
 下面的示例演示如何调用上支持该命令的对象的编辑命令。  
  
 对于此示例，<xref:System.Windows.Controls.RichTextBox>用作命令目标。  请注意，<xref:System.Windows.Controls.RichTextBox>实现<xref:System.Windows.IInputElement>接口 (继承自<xref:System.Windows.FrameworkElement>)，它包括对很多编辑命令的本机支持。  
  
 第一个参数<xref:System.Windows.Input.RoutedCommand.Execute%2A>方法是命令参数。  最编辑命令忽略命令参数;一般情况下，此参数应`null`以进行编辑命令。  
  
 第二个参数指定该命令将路由到的对象。  此对象必须实现<xref:System.Windows.IInputElement>接口，并且应包括的处理程序指定的命令。  通常情况下，在不处理该命令的对象上调用时，已忽略命令。  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.DeleteNextWord" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveLeftByWord" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveRightByWord" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectLeftByWord" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectRightByWord" />
      </Docs>
    </Member>
    <Member MemberName="EnterLineBreak">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand EnterLineBreak { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand EnterLineBreak" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.EnterLineBreak" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property EnterLineBreak As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ EnterLineBreak { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>表示 <see cref="P:System.Windows.Documents.EditingCommands.EnterLineBreak" /> 命令，该命令请求在当前位置或当前所选内容上插入一个换行符。</summary>
        <value>请求的命令。  此命令的默认键笔势<see langword="Shift" /> + <see langword="Enter" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 为支持流内容，例如编辑器<xref:System.Windows.Controls.RichTextBox>，则此命令原因<xref:System.Windows.Documents.LineBreak>元素要插入当前位置。  
  
 并不一定对任何给定的对象; 此命令的响应的实际实现在许多情况下响应命令的实现是应用程序编写器的责任。  
  
 此命令以本机方式支持通过<xref:System.Windows.Controls.RichTextBox>和<xref:System.Windows.Controls.TextBox>。  
  
<a name="xamlAttributeUsage_EnterLineBreak"></a>   
## <a name="xaml-attribute-usage"></a>XAML 属性用法  
  
```  
<object property="EnterLineBreak"/>  
```  
  
   
  
## Examples  
 下面的示例演示如何调用上支持该命令的对象的编辑命令。  
  
 对于此示例，<xref:System.Windows.Controls.RichTextBox>用作命令目标。  请注意，<xref:System.Windows.Controls.RichTextBox>实现<xref:System.Windows.IInputElement>接口 (继承自<xref:System.Windows.FrameworkElement>)，它包括对很多编辑命令的本机支持。  
  
 第一个参数<xref:System.Windows.Input.RoutedCommand.Execute%2A>方法是命令参数。  最编辑命令忽略命令参数;一般情况下，此参数应`null`以进行编辑命令。  
  
 第二个参数指定该命令将路由到的对象。  此对象必须实现<xref:System.Windows.IInputElement>接口，并且应包括的处理程序指定的命令。  通常情况下，在不处理该命令的对象上调用时，已忽略命令。  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.EnterParagraphBreak" />
      </Docs>
    </Member>
    <Member MemberName="EnterParagraphBreak">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand EnterParagraphBreak { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand EnterParagraphBreak" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.EnterParagraphBreak" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property EnterParagraphBreak As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ EnterParagraphBreak { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>表示 <see cref="P:System.Windows.Documents.EditingCommands.EnterParagraphBreak" /> 命令，该命令请求在当前位置或当前所选内容上插入一个分段符。</summary>
        <value>请求的命令。  此命令的默认键笔势为 <see langword="Enter" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此命令是等效于用户按 ENTER 键。  
  
 并不一定对任何给定的对象; 此命令的响应的实际实现在许多情况下响应命令的实现是应用程序编写器的责任。  
  
 此命令以本机方式支持通过<xref:System.Windows.Controls.RichTextBox>和<xref:System.Windows.Controls.TextBox>(时<xref:System.Windows.Controls.Primitives.TextBoxBase.AcceptsReturn%2A>属性是`true`)。  
  
> [!IMPORTANT]
>  此命令不起的文本元素除非<xref:System.Windows.Controls.Primitives.TextBoxBase.AcceptsReturn%2A>的文本元素的属性设置为`true`。  
  
<a name="xamlAttributeUsage_EnterParagraphBreak"></a>   
## <a name="xaml-attribute-usage"></a>XAML 属性用法  
  
```  
<object property="EnterParagraphBreak"/>  
```  
  
   
  
## Examples  
 下面的示例演示如何调用上支持该命令的对象的编辑命令。  
  
 对于此示例，<xref:System.Windows.Controls.RichTextBox>用作命令目标。  请注意，<xref:System.Windows.Controls.RichTextBox>实现<xref:System.Windows.IInputElement>接口 (继承自<xref:System.Windows.FrameworkElement>)，它包括对很多编辑命令的本机支持。  
  
 第一个参数<xref:System.Windows.Input.RoutedCommand.Execute%2A>方法是命令参数。  最编辑命令忽略命令参数;一般情况下，此参数应`null`以进行编辑命令。  
  
 第二个参数指定该命令将路由到的对象。  此对象必须实现<xref:System.Windows.IInputElement>接口，并且应包括的处理程序指定的命令。  通常情况下，在不处理该命令的对象上调用时，已忽略命令。  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.EnterLineBreak" />
      </Docs>
    </Member>
    <Member MemberName="IgnoreSpellingError">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand IgnoreSpellingError { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand IgnoreSpellingError" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.IgnoreSpellingError" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property IgnoreSpellingError As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ IgnoreSpellingError { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>表示 <see cref="P:System.Windows.Documents.EditingCommands.IgnoreSpellingError" /> 命令，该命令请求忽略当前位置或当前所选内容中任何拼写错误的单词的实例。</summary>
        <value>请求的命令。  此命令无默认键笔势。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 并不一定对任何给定的对象; 此命令的响应的实际实现在许多情况下响应命令的实现是应用程序编写器的责任。  
  
<a name="xamlAttributeUsage_IgnoreSpellingError"></a>   
## <a name="xaml-attribute-usage"></a>XAML 属性用法  
  
```  
<object property="IgnoreSpellingError"/>  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.CorrectSpellingError" />
      </Docs>
    </Member>
    <Member MemberName="IncreaseFontSize">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand IncreaseFontSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand IncreaseFontSize" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.IncreaseFontSize" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property IncreaseFontSize As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ IncreaseFontSize { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>表示 <see cref="P:System.Windows.Documents.EditingCommands.IncreaseFontSize" /> 命令，该命令请求将当前所选内容的字号增加 1 磅。</summary>
        <value>请求的命令。  此命令的默认键笔势<see langword="Ctrl" /> + <see langword="OemCloseBrackets" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果脱字号位置是在某个词的空选择调用此命令，则被扩展所选内容将命令应用于整个单词。  
  
 并不一定对任何给定的对象; 此命令的响应的实际实现在许多情况下响应命令的实现是应用程序编写器的责任。  
  
 此命令以本机方式支持通过<xref:System.Windows.Controls.RichTextBox>。  
  
<a name="xamlAttributeUsage_IncreaseFontSize"></a>   
## <a name="xaml-attribute-usage"></a>XAML 属性用法  
  
```  
<object property="IncreaseFontSize"/>  
```  
  
   
  
## Examples  
 下面的示例演示如何调用上支持该命令的对象的编辑命令。  
  
 对于此示例，<xref:System.Windows.Controls.RichTextBox>用作命令目标。  请注意，<xref:System.Windows.Controls.RichTextBox>实现<xref:System.Windows.IInputElement>接口 (继承自<xref:System.Windows.FrameworkElement>)，它包括对很多编辑命令的本机支持。  
  
 第一个参数<xref:System.Windows.Input.RoutedCommand.Execute%2A>方法是命令参数。  最编辑命令忽略命令参数;一般情况下，此参数应`null`以进行编辑命令。  
  
 第二个参数指定该命令将路由到的对象。  此对象必须实现<xref:System.Windows.IInputElement>接口，并且应包括的处理程序指定的命令。  通常情况下，在不处理该命令的对象上调用时，已忽略命令。  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.DecreaseFontSize" />
      </Docs>
    </Member>
    <Member MemberName="IncreaseIndentation">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand IncreaseIndentation { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand IncreaseIndentation" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.IncreaseIndentation" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property IncreaseIndentation As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ IncreaseIndentation { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>表示 <see cref="P:System.Windows.Documents.EditingCommands.IncreaseIndentation" /> 命令，该命令请求将当前段落的缩进增加一个制表位。</summary>
        <value>请求的命令。  此命令的默认键笔势<see langword="Ctrl" /> + <see langword="T" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 并不一定对任何给定的对象; 此命令的响应的实际实现在许多情况下响应命令的实现是应用程序编写器的责任。  
  
 此命令以本机方式支持通过<xref:System.Windows.Controls.RichTextBox>。  
  
> [!IMPORTANT]
>  此命令不起的文本元素除非<xref:System.Windows.Controls.Primitives.TextBoxBase.AcceptsTab%2A>的文本元素的属性设置为`true`。  
  
<a name="xamlAttributeUsage_IncreaseIndentation"></a>   
## <a name="xaml-attribute-usage"></a>XAML 属性用法  
  
```  
<object property="IncreaseIndentation"/>  
```  
  
   
  
## Examples  
 下面的示例演示如何调用上支持该命令的对象的编辑命令。  
  
 对于此示例，<xref:System.Windows.Controls.RichTextBox>用作命令目标。  请注意，<xref:System.Windows.Controls.RichTextBox>实现<xref:System.Windows.IInputElement>接口 (继承自<xref:System.Windows.FrameworkElement>)，它包括对很多编辑命令的本机支持。  
  
 第一个参数<xref:System.Windows.Input.RoutedCommand.Execute%2A>方法是命令参数。  最编辑命令忽略命令参数;一般情况下，此参数应`null`以进行编辑命令。  
  
 第二个参数指定该命令将路由到的对象。  此对象必须实现<xref:System.Windows.IInputElement>接口，并且应包括的处理程序指定的命令。  通常情况下，在不处理该命令的对象上调用时，已忽略命令。  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.DecreaseIndentation" />
      </Docs>
    </Member>
    <Member MemberName="MoveDownByLine">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand MoveDownByLine { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand MoveDownByLine" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.MoveDownByLine" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MoveDownByLine As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ MoveDownByLine { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>表示 <see cref="P:System.Windows.Documents.EditingCommands.MoveDownByLine" /> 命令，该命令请求将插入符号向下移动一行。</summary>
        <value>请求的命令。  此命令的默认键笔势为 <see langword="Down" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 并不一定对任何给定的对象; 此命令的响应的实际实现在许多情况下响应命令的实现是应用程序编写器的责任。  
  
 此命令以本机方式支持通过<xref:System.Windows.Controls.RichTextBox>和<xref:System.Windows.Controls.TextBox>。  
  
<a name="xamlAttributeUsage_MoveDownByLine"></a>   
## <a name="xaml-attribute-usage"></a>XAML 属性用法  
  
```  
<object property="MoveDownByLine"/>  
```  
  
   
  
## Examples  
 下面的示例演示如何调用上支持该命令的对象的编辑命令。  
  
 对于此示例，<xref:System.Windows.Controls.RichTextBox>用作命令目标。  请注意，<xref:System.Windows.Controls.RichTextBox>实现<xref:System.Windows.IInputElement>接口 (继承自<xref:System.Windows.FrameworkElement>)，它包括对很多编辑命令的本机支持。  
  
 第一个参数<xref:System.Windows.Input.RoutedCommand.Execute%2A>方法是命令参数。  最编辑命令忽略命令参数;一般情况下，此参数应`null`以进行编辑命令。  
  
 第二个参数指定该命令将路由到的对象。  此对象必须实现<xref:System.Windows.IInputElement>接口，并且应包括的处理程序指定的命令。  通常情况下，在不处理该命令的对象上调用时，已忽略命令。  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveUpByLine" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveDownByPage" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveDownByParagraph" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectDownByLine" />
      </Docs>
    </Member>
    <Member MemberName="MoveDownByPage">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand MoveDownByPage { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand MoveDownByPage" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.MoveDownByPage" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MoveDownByPage As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ MoveDownByPage { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>表示 <see cref="P:System.Windows.Documents.EditingCommands.MoveDownByPage" /> 命令，该命令请求将插入符号向下移动一页。</summary>
        <value>请求的命令。  此命令的默认键笔势为 <see langword="PageDown" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 并不一定对任何给定的对象; 此命令的响应的实际实现在许多情况下响应命令的实现是应用程序编写器的责任。  
  
 此命令以本机方式支持通过<xref:System.Windows.Controls.RichTextBox>和<xref:System.Windows.Controls.TextBox>。  
  
<a name="xamlAttributeUsage_MoveDownByPage"></a>   
## <a name="xaml-attribute-usage"></a>XAML 属性用法  
  
```  
<object property="MoveDownByPage"/>  
```  
  
   
  
## Examples  
 下面的示例演示如何调用上支持该命令的对象的编辑命令。  
  
 对于此示例，<xref:System.Windows.Controls.RichTextBox>用作命令目标。  请注意，<xref:System.Windows.Controls.RichTextBox>实现<xref:System.Windows.IInputElement>接口 (继承自<xref:System.Windows.FrameworkElement>)，它包括对很多编辑命令的本机支持。  
  
 第一个参数<xref:System.Windows.Input.RoutedCommand.Execute%2A>方法是命令参数。  最编辑命令忽略命令参数;一般情况下，此参数应`null`以进行编辑命令。  
  
 第二个参数指定该命令将路由到的对象。  此对象必须实现<xref:System.Windows.IInputElement>接口，并且应包括的处理程序指定的命令。  通常情况下，在不处理该命令的对象上调用时，已忽略命令。  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveUpByPage" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveDownByLine" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveDownByParagraph" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectDownByPage" />
      </Docs>
    </Member>
    <Member MemberName="MoveDownByParagraph">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand MoveDownByParagraph { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand MoveDownByParagraph" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.MoveDownByParagraph" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MoveDownByParagraph As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ MoveDownByParagraph { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>表示 <see cref="P:System.Windows.Documents.EditingCommands.MoveDownByParagraph" /> 命令，该命令请求将插入符号向下移动一个段落。</summary>
        <value>请求的命令。  此命令的默认键笔势<see langword="Ctrl" /> + <see langword="Down" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此命令将插入符号下一步段落开头。  
  
 此命令的行为类似<xref:System.Windows.Documents.EditingCommands.MoveToDocumentEnd%2A>调用时， <xref:System.Windows.Controls.TextBox>。  
  
 并不一定对任何给定的对象; 此命令的响应的实际实现在许多情况下响应命令的实现是应用程序编写器的责任。  
  
 此命令以本机方式支持通过<xref:System.Windows.Controls.RichTextBox>和<xref:System.Windows.Controls.TextBox>。  
  
<a name="xamlAttributeUsage_MoveDownByParagraph"></a>   
## <a name="xaml-attribute-usage"></a>XAML 属性用法  
  
```  
<object property="MoveDownByParagraph"/>  
```  
  
   
  
## Examples  
 下面的示例演示如何调用上支持该命令的对象的编辑命令。  
  
 对于此示例，<xref:System.Windows.Controls.RichTextBox>用作命令目标。  请注意，<xref:System.Windows.Controls.RichTextBox>实现<xref:System.Windows.IInputElement>接口 (继承自<xref:System.Windows.FrameworkElement>)，它包括对很多编辑命令的本机支持。  
  
 第一个参数<xref:System.Windows.Input.RoutedCommand.Execute%2A>方法是命令参数。  最编辑命令忽略命令参数;一般情况下，此参数应`null`以进行编辑命令。  
  
 第二个参数指定该命令将路由到的对象。  此对象必须实现<xref:System.Windows.IInputElement>接口，并且应包括的处理程序指定的命令。  通常情况下，在不处理该命令的对象上调用时，已忽略命令。  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveUpByParagraph" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveDownByLine" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveDownByPage" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectDownByParagraph" />
      </Docs>
    </Member>
    <Member MemberName="MoveLeftByCharacter">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand MoveLeftByCharacter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand MoveLeftByCharacter" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.MoveLeftByCharacter" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MoveLeftByCharacter As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ MoveLeftByCharacter { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>表示 <see cref="P:System.Windows.Documents.EditingCommands.MoveLeftByCharacter" /> 命令，该命令请求将插入符号向左移动一个字符。</summary>
        <value>请求的命令。  此命令的默认键笔势为 <see langword="Left" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 并不一定对任何给定的对象; 此命令的响应的实际实现在许多情况下响应命令的实现是应用程序编写器的责任。  
  
 此命令以本机方式支持通过<xref:System.Windows.Controls.RichTextBox>， <xref:System.Windows.Controls.TextBox>，和<xref:System.Windows.Controls.PasswordBox>。  
  
<a name="xamlAttributeUsage_MoveLeftByCharacter"></a>   
## <a name="xaml-attribute-usage"></a>XAML 属性用法  
  
```  
<object property="MoveLeftByCharacter"/>  
```  
  
   
  
## Examples  
 下面的示例演示如何调用上支持该命令的对象的编辑命令。  
  
 对于此示例，<xref:System.Windows.Controls.RichTextBox>用作命令目标。  请注意，<xref:System.Windows.Controls.RichTextBox>实现<xref:System.Windows.IInputElement>接口 (继承自<xref:System.Windows.FrameworkElement>)，它包括对很多编辑命令的本机支持。  
  
 第一个参数<xref:System.Windows.Input.RoutedCommand.Execute%2A>方法是命令参数。  最编辑命令忽略命令参数;一般情况下，此参数应`null`以进行编辑命令。  
  
 第二个参数指定该命令将路由到的对象。  此对象必须实现<xref:System.Windows.IInputElement>接口，并且应包括的处理程序指定的命令。  通常情况下，在不处理该命令的对象上调用时，已忽略命令。  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveRightByCharacter" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveLeftByWord" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectLeftByCharacter" />
      </Docs>
    </Member>
    <Member MemberName="MoveLeftByWord">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand MoveLeftByWord { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand MoveLeftByWord" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.MoveLeftByWord" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MoveLeftByWord As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ MoveLeftByWord { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>表示 <see cref="P:System.Windows.Documents.EditingCommands.MoveLeftByWord" /> 命令，该命令请求将插入符号向左移动一个单词。</summary>
        <value>请求的命令。  此命令的默认键笔势<see langword="Ctrl" /> + <see langword="Left" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果脱字号位于在某个词，此命令将插入符号移动到该单词的开头。  否则，此命令将插入符号移动到前一个单词的开头。  
  
 并不一定对任何给定的对象; 此命令的响应的实际实现在许多情况下响应命令的实现是应用程序编写器的责任。  
  
 此命令以本机方式支持通过<xref:System.Windows.Controls.RichTextBox>， <xref:System.Windows.Controls.TextBox>，和<xref:System.Windows.Controls.PasswordBox>。  
  
<a name="xamlAttributeUsage_MoveLeftByWord"></a>   
## <a name="xaml-attribute-usage"></a>XAML 属性用法  
  
```  
<object property="MoveLeftByWord"/>  
```  
  
   
  
## Examples  
 下面的示例演示如何调用上支持该命令的对象的编辑命令。  
  
 对于此示例，<xref:System.Windows.Controls.RichTextBox>用作命令目标。  请注意，<xref:System.Windows.Controls.RichTextBox>实现<xref:System.Windows.IInputElement>接口 (继承自<xref:System.Windows.FrameworkElement>)，它包括对很多编辑命令的本机支持。  
  
 第一个参数<xref:System.Windows.Input.RoutedCommand.Execute%2A>方法是命令参数。  最编辑命令忽略命令参数;一般情况下，此参数应`null`以进行编辑命令。  
  
 第二个参数指定该命令将路由到的对象。  此对象必须实现<xref:System.Windows.IInputElement>接口，并且应包括的处理程序指定的命令。  通常情况下，在不处理该命令的对象上调用时，已忽略命令。  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveRightByWord" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveLeftByCharacter" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectLeftByWord" />
      </Docs>
    </Member>
    <Member MemberName="MoveRightByCharacter">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand MoveRightByCharacter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand MoveRightByCharacter" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.MoveRightByCharacter" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MoveRightByCharacter As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ MoveRightByCharacter { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>表示 <see cref="P:System.Windows.Documents.EditingCommands.MoveRightByCharacter" /> 命令，该命令请求将插入符号向右移动一个字符。</summary>
        <value>请求的命令。  此命令的默认键笔势为 <see langword="Right" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 并不一定对任何给定的对象; 此命令的响应的实际实现在许多情况下响应命令的实现是应用程序编写器的责任。  
  
 此命令以本机方式支持通过<xref:System.Windows.Controls.RichTextBox>， <xref:System.Windows.Controls.TextBox>，和<xref:System.Windows.Controls.PasswordBox>。  
  
<a name="xamlAttributeUsage_MoveRightByCharacter"></a>   
## <a name="xaml-attribute-usage"></a>XAML 属性用法  
  
```  
<object property="MoveRightByCharacter"/>  
```  
  
   
  
## Examples  
 下面的示例演示如何调用上支持该命令的对象的编辑命令。  
  
 对于此示例，<xref:System.Windows.Controls.RichTextBox>用作命令目标。  请注意，<xref:System.Windows.Controls.RichTextBox>实现<xref:System.Windows.IInputElement>接口 (继承自<xref:System.Windows.FrameworkElement>)，它包括对很多编辑命令的本机支持。  
  
 第一个参数<xref:System.Windows.Input.RoutedCommand.Execute%2A>方法是命令参数。  最编辑命令忽略命令参数;一般情况下，此参数应`null`以进行编辑命令。  
  
 第二个参数指定该命令将路由到的对象。  此对象必须实现<xref:System.Windows.IInputElement>接口，并且应包括的处理程序指定的命令。  通常情况下，在不处理该命令的对象上调用时，已忽略命令。  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveLeftByCharacter" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveRightByWord" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectRightByCharacter" />
      </Docs>
    </Member>
    <Member MemberName="MoveRightByWord">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand MoveRightByWord { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand MoveRightByWord" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.MoveRightByWord" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MoveRightByWord As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ MoveRightByWord { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>表示 <see cref="P:System.Windows.Documents.EditingCommands.MoveRightByWord" /> 命令，该命令请求将插入符号向右移动一个单词。</summary>
        <value>请求的命令。  此命令的默认键笔势<see langword="Ctrl" /> + <see langword="Right" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果脱字号位于在某个词，此命令将插入符号移动到该单词的末尾。  否则，此命令将插入符号移动到下一步的单词的开头。  
  
 并不一定对任何给定的对象; 此命令的响应的实际实现在许多情况下响应命令的实现是应用程序编写器的责任。  
  
 此命令以本机方式支持通过<xref:System.Windows.Controls.RichTextBox>， <xref:System.Windows.Controls.TextBox>，和<xref:System.Windows.Controls.PasswordBox>。  
  
<a name="xamlAttributeUsage_MoveRightByWord"></a>   
## <a name="xaml-attribute-usage"></a>XAML 属性用法  
  
```  
<object property="MoveRightByWord"/>  
```  
  
   
  
## Examples  
 下面的示例演示如何调用上支持该命令的对象的编辑命令。  
  
 对于此示例，<xref:System.Windows.Controls.RichTextBox>用作命令目标。  请注意，<xref:System.Windows.Controls.RichTextBox>实现<xref:System.Windows.IInputElement>接口 (继承自<xref:System.Windows.FrameworkElement>)，它包括对很多编辑命令的本机支持。  
  
 第一个参数<xref:System.Windows.Input.RoutedCommand.Execute%2A>方法是命令参数。  最编辑命令忽略命令参数;一般情况下，此参数应`null`以进行编辑命令。  
  
 第二个参数指定该命令将路由到的对象。  此对象必须实现<xref:System.Windows.IInputElement>接口，并且应包括的处理程序指定的命令。  通常情况下，在不处理该命令的对象上调用时，已忽略命令。  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveLeftByWord" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveRightByCharacter" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectRightByWord" />
      </Docs>
    </Member>
    <Member MemberName="MoveToDocumentEnd">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand MoveToDocumentEnd { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand MoveToDocumentEnd" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.MoveToDocumentEnd" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MoveToDocumentEnd As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ MoveToDocumentEnd { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>表示 <see cref="P:System.Windows.Documents.EditingCommands.MoveToDocumentEnd" /> 命令，该命令请求将插入符号移至内容的末尾。</summary>
        <value>请求的命令。  此命令的默认键笔势<see langword="Ctrl" /> + <see langword="End" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A*文本容器*是窗体的内容手头的最终边框的元素。  <xref:System.Windows.Controls.TextBlock> 和<xref:System.Windows.Documents.FlowDocument>是文本容器的示例。  共同的文本容器内包含的内容被称为*文档*。  
  
 并不一定对任何给定的对象; 此命令的响应的实际实现在许多情况下响应命令的实现是应用程序编写器的责任。  
  
 此命令以本机方式支持通过<xref:System.Windows.Controls.RichTextBox>， <xref:System.Windows.Controls.TextBox>，和<xref:System.Windows.Controls.PasswordBox>。  
  
<a name="xamlAttributeUsage_MoveToDocumentEnd"></a>   
## <a name="xaml-attribute-usage"></a>XAML 属性用法  
  
```  
<object property="MoveToDocumentEnd"/>  
```  
  
   
  
## Examples  
 下面的示例演示如何调用上支持该命令的对象的编辑命令。  
  
 对于此示例，<xref:System.Windows.Controls.RichTextBox>用作命令目标。  请注意，<xref:System.Windows.Controls.RichTextBox>实现<xref:System.Windows.IInputElement>接口 (继承自<xref:System.Windows.FrameworkElement>)，它包括对很多编辑命令的本机支持。  
  
 第一个参数<xref:System.Windows.Input.RoutedCommand.Execute%2A>方法是命令参数。  最编辑命令忽略命令参数;一般情况下，此参数应`null`以进行编辑命令。  
  
 第二个参数指定该命令将路由到的对象。  此对象必须实现<xref:System.Windows.IInputElement>接口，并且应包括的处理程序指定的命令。  通常情况下，在不处理该命令的对象上调用时，已忽略命令。  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectToDocumentStart" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectToDocumentEnd" />
      </Docs>
    </Member>
    <Member MemberName="MoveToDocumentStart">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand MoveToDocumentStart { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand MoveToDocumentStart" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.MoveToDocumentStart" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MoveToDocumentStart As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ MoveToDocumentStart { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>表示 <see cref="P:System.Windows.Documents.EditingCommands.MoveToDocumentStart" /> 命令，该命令请求将插入符号移至内容的开头。</summary>
        <value>请求的命令。  此命令的默认键笔势<see langword="Ctrl" /> + <see langword="Home" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A*文本容器*是窗体的内容手头的最终边框的元素。  <xref:System.Windows.Controls.TextBlock> 和<xref:System.Windows.Documents.FlowDocument>是文本容器的示例。  共同的文本容器内包含的内容被称为*文档*。  
  
 并不一定对任何给定的对象; 此命令的响应的实际实现在许多情况下响应命令的实现是应用程序编写器的责任。  
  
 此命令以本机方式支持通过<xref:System.Windows.Controls.RichTextBox>， <xref:System.Windows.Controls.TextBox>，和<xref:System.Windows.Controls.PasswordBox>。  
  
<a name="xamlAttributeUsage_MoveToDocumentStart"></a>   
## <a name="xaml-attribute-usage"></a>XAML 属性用法  
  
```  
<object property="MoveToDocumentStart"/>  
```  
  
   
  
## Examples  
 下面的示例演示如何调用上支持该命令的对象的编辑命令。  
  
 对于此示例，<xref:System.Windows.Controls.RichTextBox>用作命令目标。  请注意，<xref:System.Windows.Controls.RichTextBox>实现<xref:System.Windows.IInputElement>接口 (继承自<xref:System.Windows.FrameworkElement>)，它包括对很多编辑命令的本机支持。  
  
 第一个参数<xref:System.Windows.Input.RoutedCommand.Execute%2A>方法是命令参数。  最编辑命令忽略命令参数;一般情况下，此参数应`null`以进行编辑命令。  
  
 第二个参数指定该命令将路由到的对象。  此对象必须实现<xref:System.Windows.IInputElement>接口，并且应包括的处理程序指定的命令。  通常情况下，在不处理该命令的对象上调用时，已忽略命令。  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveToDocumentEnd" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectToDocumentStart" />
      </Docs>
    </Member>
    <Member MemberName="MoveToLineEnd">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand MoveToLineEnd { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand MoveToLineEnd" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.MoveToLineEnd" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MoveToLineEnd As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ MoveToLineEnd { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>表示 <see cref="P:System.Windows.Documents.EditingCommands.MoveToLineEnd" /> 命令，该命令请求将插入符号移至当前行的末尾。</summary>
        <value>请求的命令。  此命令的默认键笔势为 <see langword="End" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 并不一定对任何给定的对象; 此命令的响应的实际实现在许多情况下响应命令的实现是应用程序编写器的责任。  
  
 此命令以本机方式支持通过<xref:System.Windows.Controls.RichTextBox>， <xref:System.Windows.Controls.TextBox>，和<xref:System.Windows.Controls.PasswordBox>。  
  
<a name="xamlAttributeUsage_MoveToLineEnd"></a>   
## <a name="xaml-attribute-usage"></a>XAML 属性用法  
  
```  
<object property="MoveToLineEnd"/>  
```  
  
   
  
## Examples  
 下面的示例演示如何调用上支持该命令的对象的编辑命令。  
  
 对于此示例，<xref:System.Windows.Controls.RichTextBox>用作命令目标。  请注意，<xref:System.Windows.Controls.RichTextBox>实现<xref:System.Windows.IInputElement>接口 (继承自<xref:System.Windows.FrameworkElement>)，它包括对很多编辑命令的本机支持。  
  
 第一个参数<xref:System.Windows.Input.RoutedCommand.Execute%2A>方法是命令参数。  最编辑命令忽略命令参数;一般情况下，此参数应`null`以进行编辑命令。  
  
 第二个参数指定该命令将路由到的对象。  此对象必须实现<xref:System.Windows.IInputElement>接口，并且应包括的处理程序指定的命令。  通常情况下，在不处理该命令的对象上调用时，已忽略命令。  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveToLineStart" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectToLineEnd" />
      </Docs>
    </Member>
    <Member MemberName="MoveToLineStart">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand MoveToLineStart { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand MoveToLineStart" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.MoveToLineStart" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MoveToLineStart As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ MoveToLineStart { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>表示 <see cref="P:System.Windows.Documents.EditingCommands.MoveToLineStart" /> 命令，该命令请求将插入符号移至当前行的开头。</summary>
        <value>请求的命令。  此命令的默认键笔势为 <see langword="Home" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 并不一定对任何给定的对象; 此命令的响应的实际实现在许多情况下响应命令的实现是应用程序编写器的责任。  
  
 此命令以本机方式支持通过<xref:System.Windows.Controls.RichTextBox>， <xref:System.Windows.Controls.TextBox>，和<xref:System.Windows.Controls.PasswordBox>。  
  
<a name="xamlAttributeUsage_MoveToLineStart"></a>   
## <a name="xaml-attribute-usage"></a>XAML 属性用法  
  
```  
<object property="MoveToLineStart"/>  
```  
  
   
  
## Examples  
 下面的示例演示如何调用上支持该命令的对象的编辑命令。  
  
 对于此示例，<xref:System.Windows.Controls.RichTextBox>用作命令目标。  请注意，<xref:System.Windows.Controls.RichTextBox>实现<xref:System.Windows.IInputElement>接口 (继承自<xref:System.Windows.FrameworkElement>)，它包括对很多编辑命令的本机支持。  
  
 第一个参数<xref:System.Windows.Input.RoutedCommand.Execute%2A>方法是命令参数。  最编辑命令忽略命令参数;一般情况下，此参数应`null`以进行编辑命令。  
  
 第二个参数指定该命令将路由到的对象。  此对象必须实现<xref:System.Windows.IInputElement>接口，并且应包括的处理程序指定的命令。  通常情况下，在不处理该命令的对象上调用时，已忽略命令。  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveToLineEnd" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectToLineEnd" />
      </Docs>
    </Member>
    <Member MemberName="MoveUpByLine">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand MoveUpByLine { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand MoveUpByLine" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.MoveUpByLine" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MoveUpByLine As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ MoveUpByLine { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>表示 <see cref="P:System.Windows.Documents.EditingCommands.MoveUpByLine" /> 命令，该命令请求将插入符号向上移动一行。</summary>
        <value>请求的命令。  此命令的默认键笔势为 <see langword="Up" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 并不一定对任何给定的对象; 此命令的响应的实际实现在许多情况下响应命令的实现是应用程序编写器的责任。  
  
 此命令以本机方式支持通过<xref:System.Windows.Controls.RichTextBox>和<xref:System.Windows.Controls.TextBox>。  
  
<a name="xamlAttributeUsage_MoveUpByLine"></a>   
## <a name="xaml-attribute-usage"></a>XAML 属性用法  
  
```  
<object property="MoveUpByLine"/>  
```  
  
   
  
## Examples  
 下面的示例演示如何调用上支持该命令的对象的编辑命令。  
  
 对于此示例，<xref:System.Windows.Controls.RichTextBox>用作命令目标。  请注意，<xref:System.Windows.Controls.RichTextBox>实现<xref:System.Windows.IInputElement>接口 (继承自<xref:System.Windows.FrameworkElement>)，它包括对很多编辑命令的本机支持。  
  
 第一个参数<xref:System.Windows.Input.RoutedCommand.Execute%2A>方法是命令参数。  最编辑命令忽略命令参数;一般情况下，此参数应`null`以进行编辑命令。  
  
 第二个参数指定该命令将路由到的对象。  此对象必须实现<xref:System.Windows.IInputElement>接口，并且应包括的处理程序指定的命令。  通常情况下，在不处理该命令的对象上调用时，已忽略命令。  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveDownByLine" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveUpByPage" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveUpByParagraph" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectUpByLine" />
      </Docs>
    </Member>
    <Member MemberName="MoveUpByPage">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand MoveUpByPage { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand MoveUpByPage" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.MoveUpByPage" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MoveUpByPage As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ MoveUpByPage { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>表示 <see cref="P:System.Windows.Documents.EditingCommands.MoveUpByPage" /> 命令，该命令请求将插入符号向上移动一页。</summary>
        <value>请求的命令。  此命令的默认键笔势为 <see langword="PageUp" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 并不一定对任何给定的对象; 此命令的响应的实际实现在许多情况下响应命令的实现是应用程序编写器的责任。  
  
 此命令以本机方式支持通过<xref:System.Windows.Controls.RichTextBox>和<xref:System.Windows.Controls.TextBox>。  
  
<a name="xamlAttributeUsage_MoveUpByPage"></a>   
## <a name="xaml-attribute-usage"></a>XAML 属性用法  
  
```  
<object property="MoveUpByPage"/>  
```  
  
   
  
## Examples  
 下面的示例演示如何调用上支持该命令的对象的编辑命令。  
  
 对于此示例，<xref:System.Windows.Controls.RichTextBox>用作命令目标。  请注意，<xref:System.Windows.Controls.RichTextBox>实现<xref:System.Windows.IInputElement>接口 (继承自<xref:System.Windows.FrameworkElement>)，它包括对很多编辑命令的本机支持。  
  
 第一个参数<xref:System.Windows.Input.RoutedCommand.Execute%2A>方法是命令参数。  最编辑命令忽略命令参数;一般情况下，此参数应`null`以进行编辑命令。  
  
 第二个参数指定该命令将路由到的对象。  此对象必须实现<xref:System.Windows.IInputElement>接口，并且应包括的处理程序指定的命令。  通常情况下，在不处理该命令的对象上调用时，已忽略命令。  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveDownByPage" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveUpByLine" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveUpByParagraph" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectUpByPage" />
      </Docs>
    </Member>
    <Member MemberName="MoveUpByParagraph">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand MoveUpByParagraph { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand MoveUpByParagraph" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.MoveUpByParagraph" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MoveUpByParagraph As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ MoveUpByParagraph { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>表示 <see cref="P:System.Windows.Documents.EditingCommands.MoveUpByParagraph" /> 命令，该命令请求将插入符号向上移动一个段落。</summary>
        <value>请求的命令。  此命令的默认键笔势<see langword="Ctrl" /> + <see langword="Up" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此命令将插入符号下一步段落开头。  
  
 此命令的行为类似<xref:System.Windows.Documents.EditingCommands.MoveToDocumentStart%2A>调用时， <xref:System.Windows.Controls.TextBox>。  
  
 并不一定对任何给定的对象; 此命令的响应的实际实现在许多情况下响应命令的实现是应用程序编写器的责任。  
  
 此命令以本机方式支持通过<xref:System.Windows.Controls.RichTextBox>和<xref:System.Windows.Controls.TextBox>。  
  
<a name="xamlAttributeUsage_MoveUpByParagraph"></a>   
## <a name="xaml-attribute-usage"></a>XAML 属性用法  
  
```  
<object property="MoveUpByParagraph"/>  
```  
  
   
  
## Examples  
 下面的示例演示如何调用上支持该命令的对象的编辑命令。  
  
 对于此示例，<xref:System.Windows.Controls.RichTextBox>用作命令目标。  请注意，<xref:System.Windows.Controls.RichTextBox>实现<xref:System.Windows.IInputElement>接口 (继承自<xref:System.Windows.FrameworkElement>)，它包括对很多编辑命令的本机支持。  
  
 第一个参数<xref:System.Windows.Input.RoutedCommand.Execute%2A>方法是命令参数。  最编辑命令忽略命令参数;一般情况下，此参数应`null`以进行编辑命令。  
  
 第二个参数指定该命令将路由到的对象。  此对象必须实现<xref:System.Windows.IInputElement>接口，并且应包括的处理程序指定的命令。  通常情况下，在不处理该命令的对象上调用时，已忽略命令。  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveDownByParagraph" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveUpByLine" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveUpByPage" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectUpByParagraph" />
      </Docs>
    </Member>
    <Member MemberName="SelectDownByLine">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand SelectDownByLine { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand SelectDownByLine" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.SelectDownByLine" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property SelectDownByLine As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ SelectDownByLine { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>表示 <see cref="P:System.Windows.Documents.EditingCommands.SelectDownByLine" /> 命令，该命令请求将当前选择范围向下扩展一行。</summary>
        <value>请求的命令。  此命令的默认键笔势<see langword="Shift" /> + <see langword="Down" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 并不一定对任何给定的对象; 此命令的响应的实际实现在许多情况下响应命令的实现是应用程序编写器的责任。  
  
 此命令以本机方式支持通过<xref:System.Windows.Controls.RichTextBox>， <xref:System.Windows.Controls.TextBox>，和<xref:System.Windows.Controls.PasswordBox>。  
  
<a name="xamlAttributeUsage_SelectDownByLine"></a>   
## <a name="xaml-attribute-usage"></a>XAML 属性用法  
  
```  
<object property="SelectDownByLine"/>  
```  
  
   
  
## Examples  
 下面的示例演示如何调用上支持该命令的对象的编辑命令。  
  
 对于此示例，<xref:System.Windows.Controls.RichTextBox>用作命令目标。  请注意，<xref:System.Windows.Controls.RichTextBox>实现<xref:System.Windows.IInputElement>接口 (继承自<xref:System.Windows.FrameworkElement>)，它包括对很多编辑命令的本机支持。  
  
 第一个参数<xref:System.Windows.Input.RoutedCommand.Execute%2A>方法是命令参数。  最编辑命令忽略命令参数;一般情况下，此参数应`null`以进行编辑命令。  
  
 第二个参数指定该命令将路由到的对象。  此对象必须实现<xref:System.Windows.IInputElement>接口，并且应包括的处理程序指定的命令。  通常情况下，在不处理该命令的对象上调用时，已忽略命令。  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectUpByLine" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectDownByPage" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectDownByParagraph" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveDownByLine" />
      </Docs>
    </Member>
    <Member MemberName="SelectDownByPage">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand SelectDownByPage { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand SelectDownByPage" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.SelectDownByPage" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property SelectDownByPage As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ SelectDownByPage { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>表示 <see cref="P:System.Windows.Documents.EditingCommands.SelectDownByPage" /> 命令，该命令请求将当前选择范围向下扩展一页。</summary>
        <value>请求的命令。  此命令的默认键笔势<see langword="Shift" /> + <see langword="PageDown" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 并不一定对任何给定的对象; 此命令的响应的实际实现在许多情况下响应命令的实现是应用程序编写器的责任。  
  
 此命令以本机方式支持通过<xref:System.Windows.Controls.RichTextBox>， <xref:System.Windows.Controls.TextBox>，和<xref:System.Windows.Controls.PasswordBox>。  
  
<a name="xamlAttributeUsage_SelectDownByPage"></a>   
## <a name="xaml-attribute-usage"></a>XAML 属性用法  
  
```  
<object property="SelectDownByPage"/>  
```  
  
   
  
## Examples  
 下面的示例演示如何调用上支持该命令的对象的编辑命令。  
  
 对于此示例，<xref:System.Windows.Controls.RichTextBox>用作命令目标。  请注意，<xref:System.Windows.Controls.RichTextBox>实现<xref:System.Windows.IInputElement>接口 (继承自<xref:System.Windows.FrameworkElement>)，它包括对很多编辑命令的本机支持。  
  
 第一个参数<xref:System.Windows.Input.RoutedCommand.Execute%2A>方法是命令参数。  最编辑命令忽略命令参数;一般情况下，此参数应`null`以进行编辑命令。  
  
 第二个参数指定该命令将路由到的对象。  此对象必须实现<xref:System.Windows.IInputElement>接口，并且应包括的处理程序指定的命令。  通常情况下，在不处理该命令的对象上调用时，已忽略命令。  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectUpByPage" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectDownByLine" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectDownByParagraph" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveDownByPage" />
      </Docs>
    </Member>
    <Member MemberName="SelectDownByParagraph">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand SelectDownByParagraph { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand SelectDownByParagraph" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.SelectDownByParagraph" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property SelectDownByParagraph As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ SelectDownByParagraph { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>表示 <see cref="P:System.Windows.Documents.EditingCommands.SelectDownByParagraph" /> 命令，该命令请求将当前选择范围向下扩展一段。</summary>
        <value>请求的命令。  此命令的默认键笔势<see langword="Ctrl" /> + <see langword="Shift" /> + <see langword="Down" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此命令将选择扩展到下一段的开头。  否则，此命令将选择扩展到的当前段落的末尾。  展开选定内容包括段落中断，标记段落的一端。  
  
 并不一定对任何给定的对象; 此命令的响应的实际实现在许多情况下响应命令的实现是应用程序编写器的责任。  
  
 此命令以本机方式支持通过<xref:System.Windows.Controls.RichTextBox>， <xref:System.Windows.Controls.TextBox>，和<xref:System.Windows.Controls.PasswordBox>。  
  
<a name="xamlAttributeUsage_SelectDownByParagraph"></a>   
## <a name="xaml-attribute-usage"></a>XAML 属性用法  
  
```  
<object property="SelectDownByParagraph"/>  
```  
  
   
  
## Examples  
 下面的示例演示如何调用上支持该命令的对象的编辑命令。  
  
 对于此示例，<xref:System.Windows.Controls.RichTextBox>用作命令目标。  请注意，<xref:System.Windows.Controls.RichTextBox>实现<xref:System.Windows.IInputElement>接口 (继承自<xref:System.Windows.FrameworkElement>)，它包括对很多编辑命令的本机支持。  
  
 第一个参数<xref:System.Windows.Input.RoutedCommand.Execute%2A>方法是命令参数。  最编辑命令忽略命令参数;一般情况下，此参数应`null`以进行编辑命令。  
  
 第二个参数指定该命令将路由到的对象。  此对象必须实现<xref:System.Windows.IInputElement>接口，并且应包括的处理程序指定的命令。  通常情况下，在不处理该命令的对象上调用时，已忽略命令。  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectUpByParagraph" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectDownByLine" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectDownByPage" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveDownByParagraph" />
      </Docs>
    </Member>
    <Member MemberName="SelectLeftByCharacter">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand SelectLeftByCharacter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand SelectLeftByCharacter" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.SelectLeftByCharacter" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property SelectLeftByCharacter As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ SelectLeftByCharacter { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>表示 <see cref="P:System.Windows.Documents.EditingCommands.SelectLeftByCharacter" /> 命令，该命令请求将当前选择范围向左扩展一个字符。</summary>
        <value>请求的命令。  此命令的默认键笔势<see langword="Shift" /> + <see langword="Left" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 并不一定对任何给定的对象; 此命令的响应的实际实现在许多情况下响应命令的实现是应用程序编写器的责任。  
  
 此命令以本机方式支持通过<xref:System.Windows.Controls.RichTextBox>， <xref:System.Windows.Controls.TextBox>，和<xref:System.Windows.Controls.PasswordBox>。  
  
<a name="xamlAttributeUsage_SelectLeftByCharacter"></a>   
## <a name="xaml-attribute-usage"></a>XAML 属性用法  
  
```  
<object property="SelectLeftByCharacter"/>  
```  
  
   
  
## Examples  
 下面的示例演示如何调用上支持该命令的对象的编辑命令。  
  
 对于此示例，<xref:System.Windows.Controls.RichTextBox>用作命令目标。  请注意，<xref:System.Windows.Controls.RichTextBox>实现<xref:System.Windows.IInputElement>接口 (继承自<xref:System.Windows.FrameworkElement>)，它包括对很多编辑命令的本机支持。  
  
 第一个参数<xref:System.Windows.Input.RoutedCommand.Execute%2A>方法是命令参数。  最编辑命令忽略命令参数;一般情况下，此参数应`null`以进行编辑命令。  
  
 第二个参数指定该命令将路由到的对象。  此对象必须实现<xref:System.Windows.IInputElement>接口，并且应包括的处理程序指定的命令。  通常情况下，在不处理该命令的对象上调用时，已忽略命令。  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectRightByCharacter" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectLeftByWord" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveLeftByCharacter" />
      </Docs>
    </Member>
    <Member MemberName="SelectLeftByWord">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand SelectLeftByWord { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand SelectLeftByWord" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.SelectLeftByWord" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property SelectLeftByWord As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ SelectLeftByWord { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>表示 <see cref="P:System.Windows.Documents.EditingCommands.SelectLeftByWord" /> 命令，该命令请求将当前选择范围向左扩展一个单词。</summary>
        <value>请求的命令。  此命令的默认键笔势<see langword="Ctrl" /> + <see langword="Shift" /> + <see langword="Left" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果脱字号位于在某个词，此命令将选择扩展到该单词的开头。  否则，此命令将选择扩展到前一个单词的开头。  
  
 展开所选内容不包括单词分隔符。  与之相反<xref:System.Windows.Documents.EditingCommands.SelectRightByWord%2A>，其中包括 word 分隔符中的更多选择。  
  
 并不一定对任何给定的对象; 此命令的响应的实际实现在许多情况下响应命令的实现是应用程序编写器的责任。  
  
 此命令以本机方式支持通过<xref:System.Windows.Controls.RichTextBox>， <xref:System.Windows.Controls.TextBox>，和<xref:System.Windows.Controls.PasswordBox>。  
  
<a name="xamlAttributeUsage_SelectLeftByWord"></a>   
## <a name="xaml-attribute-usage"></a>XAML 属性用法  
  
```  
<object property="SelectLeftByWord"/>  
```  
  
   
  
## Examples  
 下面的示例演示如何调用上支持该命令的对象的编辑命令。  
  
 对于此示例，<xref:System.Windows.Controls.RichTextBox>用作命令目标。  请注意，<xref:System.Windows.Controls.RichTextBox>实现<xref:System.Windows.IInputElement>接口 (继承自<xref:System.Windows.FrameworkElement>)，它包括对很多编辑命令的本机支持。  
  
 第一个参数<xref:System.Windows.Input.RoutedCommand.Execute%2A>方法是命令参数。  最编辑命令忽略命令参数;一般情况下，此参数应`null`以进行编辑命令。  
  
 第二个参数指定该命令将路由到的对象。  此对象必须实现<xref:System.Windows.IInputElement>接口，并且应包括的处理程序指定的命令。  通常情况下，在不处理该命令的对象上调用时，已忽略命令。  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectRightByWord" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectLeftByCharacter" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveLeftByWord" />
      </Docs>
    </Member>
    <Member MemberName="SelectRightByCharacter">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand SelectRightByCharacter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand SelectRightByCharacter" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.SelectRightByCharacter" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property SelectRightByCharacter As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ SelectRightByCharacter { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>表示 <see cref="P:System.Windows.Documents.EditingCommands.SelectRightByCharacter" /> 命令，该命令请求将当前选择范围向右扩展一个字符。</summary>
        <value>请求的命令。  此命令的默认键笔势<see langword="Shift" /> + <see langword="Right" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 并不一定对任何给定的对象; 此命令的响应的实际实现在许多情况下响应命令的实现是应用程序编写器的责任。  
  
 此命令以本机方式支持通过<xref:System.Windows.Controls.RichTextBox>， <xref:System.Windows.Controls.TextBox>，和<xref:System.Windows.Controls.PasswordBox>。  
  
<a name="xamlAttributeUsage_SelectRightByCharacter"></a>   
## <a name="xaml-attribute-usage"></a>XAML 属性用法  
  
```  
<object property="SelectRightByCharacter"/>  
```  
  
   
  
## Examples  
 下面的示例演示如何调用上支持该命令的对象的编辑命令。  
  
 对于此示例，<xref:System.Windows.Controls.RichTextBox>用作命令目标。  请注意，<xref:System.Windows.Controls.RichTextBox>实现<xref:System.Windows.IInputElement>接口 (继承自<xref:System.Windows.FrameworkElement>)，它包括对很多编辑命令的本机支持。  
  
 第一个参数<xref:System.Windows.Input.RoutedCommand.Execute%2A>方法是命令参数。  最编辑命令忽略命令参数;一般情况下，此参数应`null`以进行编辑命令。  
  
 第二个参数指定该命令将路由到的对象。  此对象必须实现<xref:System.Windows.IInputElement>接口，并且应包括的处理程序指定的命令。  通常情况下，在不处理该命令的对象上调用时，已忽略命令。  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectLeftByCharacter" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectRightByWord" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveRightByCharacter" />
      </Docs>
    </Member>
    <Member MemberName="SelectRightByWord">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand SelectRightByWord { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand SelectRightByWord" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.SelectRightByWord" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property SelectRightByWord As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ SelectRightByWord { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>表示 <see cref="P:System.Windows.Documents.EditingCommands.SelectRightByWord" /> 命令，该命令请求将当前选择范围向右扩展一个单词。</summary>
        <value>请求的命令。  此命令的默认键笔势<see langword="Ctrl" /> + <see langword="Shift" /> + <see langword="Right" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果脱字号位于在某个词，此命令将选择扩展到该单词的末尾。  否则，此命令将选择扩展到下一步单词末尾。  
  
 展开选定内容包括单词分隔符。  与之相反<xref:System.Windows.Documents.EditingCommands.SelectLeftByWord%2A>其中不包括单词分隔符中的更多选择。  
  
 并不一定对任何给定的对象; 此命令的响应的实际实现在许多情况下响应命令的实现是应用程序编写器的责任。  
  
 此命令以本机方式支持通过<xref:System.Windows.Controls.RichTextBox>， <xref:System.Windows.Controls.TextBox>，和<xref:System.Windows.Controls.PasswordBox>。  
  
<a name="xamlAttributeUsage_SelectRightByWord"></a>   
## <a name="xaml-attribute-usage"></a>XAML 属性用法  
  
```  
<object property="SelectRightByWord"/>  
```  
  
   
  
## Examples  
 下面的示例演示如何调用上支持该命令的对象的编辑命令。  
  
 对于此示例，<xref:System.Windows.Controls.RichTextBox>用作命令目标。  请注意，<xref:System.Windows.Controls.RichTextBox>实现<xref:System.Windows.IInputElement>接口 (继承自<xref:System.Windows.FrameworkElement>)，它包括对很多编辑命令的本机支持。  
  
 第一个参数<xref:System.Windows.Input.RoutedCommand.Execute%2A>方法是命令参数。  最编辑命令忽略命令参数;一般情况下，此参数应`null`以进行编辑命令。  
  
 第二个参数指定该命令将路由到的对象。  此对象必须实现<xref:System.Windows.IInputElement>接口，并且应包括的处理程序指定的命令。  通常情况下，在不处理该命令的对象上调用时，已忽略命令。  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectLeftByWord" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectRightByCharacter" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveRightByWord" />
      </Docs>
    </Member>
    <Member MemberName="SelectToDocumentEnd">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand SelectToDocumentEnd { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand SelectToDocumentEnd" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.SelectToDocumentEnd" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property SelectToDocumentEnd As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ SelectToDocumentEnd { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>表示 <see cref="P:System.Windows.Documents.EditingCommands.SelectToDocumentEnd" /> 命令，该命令请求将当前选择范围扩展到内容末尾处。</summary>
        <value>请求的命令。  此命令的默认键笔势<see langword="Ctrl" /> + <see langword="Shift" /> + <see langword="End" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A*文本容器*是窗体的内容手头的最终边框的元素。  <xref:System.Windows.Controls.TextBlock> 和<xref:System.Windows.Documents.FlowDocument>是文本容器的示例。  共同的文本容器内包含的内容被称为*文档*。  
  
 并不一定对任何给定的对象; 此命令的响应的实际实现在许多情况下响应命令的实现是应用程序编写器的责任。  
  
 此命令以本机方式支持通过<xref:System.Windows.Controls.RichTextBox>， <xref:System.Windows.Controls.TextBox>，和<xref:System.Windows.Controls.PasswordBox>。  
  
<a name="xamlAttributeUsage_SelectToDocumentEnd"></a>   
## <a name="xaml-attribute-usage"></a>XAML 属性用法  
  
```  
<object property="SelectToDocumentEnd"/>  
```  
  
   
  
## Examples  
 下面的示例演示如何调用上支持该命令的对象的编辑命令。  
  
 对于此示例，<xref:System.Windows.Controls.RichTextBox>用作命令目标。  请注意，<xref:System.Windows.Controls.RichTextBox>实现<xref:System.Windows.IInputElement>接口 (继承自<xref:System.Windows.FrameworkElement>)，它包括对很多编辑命令的本机支持。  
  
 第一个参数<xref:System.Windows.Input.RoutedCommand.Execute%2A>方法是命令参数。  最编辑命令忽略命令参数;一般情况下，此参数应`null`以进行编辑命令。  
  
 第二个参数指定该命令将路由到的对象。  此对象必须实现<xref:System.Windows.IInputElement>接口，并且应包括的处理程序指定的命令。  通常情况下，在不处理该命令的对象上调用时，已忽略命令。  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectToDocumentStart" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveToDocumentEnd" />
      </Docs>
    </Member>
    <Member MemberName="SelectToDocumentStart">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand SelectToDocumentStart { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand SelectToDocumentStart" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.SelectToDocumentStart" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property SelectToDocumentStart As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ SelectToDocumentStart { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>表示 <see cref="P:System.Windows.Documents.EditingCommands.SelectToDocumentStart" /> 命令，该命令请求将当前选择范围扩展到内容开头处。</summary>
        <value>请求的命令。  此命令的默认键笔势<see langword="Ctrl" /> + <see langword="Shift" /> + <see langword="Home" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A*文本容器*是窗体的内容手头的最终边框的元素。  <xref:System.Windows.Controls.TextBlock> 和<xref:System.Windows.Documents.FlowDocument>是文本容器的示例。  共同的文本容器内包含的内容被称为*文档*。  
  
 并不一定对任何给定的对象; 此命令的响应的实际实现在许多情况下响应命令的实现是应用程序编写器的责任。  
  
 此命令以本机方式支持通过<xref:System.Windows.Controls.RichTextBox>， <xref:System.Windows.Controls.TextBox>，和<xref:System.Windows.Controls.PasswordBox>。  
  
<a name="xamlAttributeUsage_SelectToDocumentStart"></a>   
## <a name="xaml-attribute-usage"></a>XAML 属性用法  
  
```  
<object property="SelectToDocumentStart"/>  
```  
  
   
  
## Examples  
 下面的示例演示如何调用上支持该命令的对象的编辑命令。  
  
 对于此示例，<xref:System.Windows.Controls.RichTextBox>用作命令目标。  请注意，<xref:System.Windows.Controls.RichTextBox>实现<xref:System.Windows.IInputElement>接口 (继承自<xref:System.Windows.FrameworkElement>)，它包括对很多编辑命令的本机支持。  
  
 第一个参数<xref:System.Windows.Input.RoutedCommand.Execute%2A>方法是命令参数。  最编辑命令忽略命令参数;一般情况下，此参数应`null`以进行编辑命令。  
  
 第二个参数指定该命令将路由到的对象。  此对象必须实现<xref:System.Windows.IInputElement>接口，并且应包括的处理程序指定的命令。  通常情况下，在不处理该命令的对象上调用时，已忽略命令。  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectToDocumentEnd" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveToDocumentStart" />
      </Docs>
    </Member>
    <Member MemberName="SelectToLineEnd">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand SelectToLineEnd { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand SelectToLineEnd" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.SelectToLineEnd" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property SelectToLineEnd As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ SelectToLineEnd { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>表示 <see cref="P:System.Windows.Documents.EditingCommands.SelectToLineEnd" /> 命令，该命令请求将当前选择范围扩展到当前行的末尾。</summary>
        <value>请求的命令。  此命令的默认键笔势<see langword="Shift" /> + <see langword="End" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 并不一定对任何给定的对象; 此命令的响应的实际实现在许多情况下响应命令的实现是应用程序编写器的责任。  
  
 此命令以本机方式支持通过<xref:System.Windows.Controls.RichTextBox>， <xref:System.Windows.Controls.TextBox>，和<xref:System.Windows.Controls.PasswordBox>。  
  
<a name="xamlAttributeUsage_SelectToLineEnd"></a>   
## <a name="xaml-attribute-usage"></a>XAML 属性用法  
  
```  
<object property="SelectToLineEnd"/>  
```  
  
   
  
## Examples  
 下面的示例演示如何调用上支持该命令的对象的编辑命令。  
  
 对于此示例，<xref:System.Windows.Controls.RichTextBox>用作命令目标。  请注意，<xref:System.Windows.Controls.RichTextBox>实现<xref:System.Windows.IInputElement>接口 (继承自<xref:System.Windows.FrameworkElement>)，它包括对很多编辑命令的本机支持。  
  
 第一个参数<xref:System.Windows.Input.RoutedCommand.Execute%2A>方法是命令参数。  最编辑命令忽略命令参数;一般情况下，此参数应`null`以进行编辑命令。  
  
 第二个参数指定该命令将路由到的对象。  此对象必须实现<xref:System.Windows.IInputElement>接口，并且应包括的处理程序指定的命令。  通常情况下，在不处理该命令的对象上调用时，已忽略命令。  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectToLineStart" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveToLineEnd" />
      </Docs>
    </Member>
    <Member MemberName="SelectToLineStart">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand SelectToLineStart { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand SelectToLineStart" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.SelectToLineStart" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property SelectToLineStart As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ SelectToLineStart { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>表示 <see cref="P:System.Windows.Documents.EditingCommands.SelectToLineStart" /> 命令，该命令请求将当前选择范围扩展到当前行的开头。</summary>
        <value>请求的命令。  此命令的默认键笔势<see langword="Shift" /> + <see langword="Home" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 并不一定对任何给定的对象; 此命令的响应的实际实现在许多情况下响应命令的实现是应用程序编写器的责任。  
  
 此命令以本机方式支持通过<xref:System.Windows.Controls.RichTextBox>， <xref:System.Windows.Controls.TextBox>，和<xref:System.Windows.Controls.PasswordBox>。  
  
<a name="xamlAttributeUsage_SelectToLineStart"></a>   
## <a name="xaml-attribute-usage"></a>XAML 属性用法  
  
```  
<object property="SelectToLineStart"/>  
```  
  
   
  
## Examples  
 下面的示例演示如何调用上支持该命令的对象的编辑命令。  
  
 对于此示例，<xref:System.Windows.Controls.RichTextBox>用作命令目标。  请注意，<xref:System.Windows.Controls.RichTextBox>实现<xref:System.Windows.IInputElement>接口 (继承自<xref:System.Windows.FrameworkElement>)，它包括对很多编辑命令的本机支持。  
  
 第一个参数<xref:System.Windows.Input.RoutedCommand.Execute%2A>方法是命令参数。  最编辑命令忽略命令参数;一般情况下，此参数应`null`以进行编辑命令。  
  
 第二个参数指定该命令将路由到的对象。  此对象必须实现<xref:System.Windows.IInputElement>接口，并且应包括的处理程序指定的命令。  通常情况下，在不处理该命令的对象上调用时，已忽略命令。  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectToLineEnd" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveToLineStart" />
      </Docs>
    </Member>
    <Member MemberName="SelectUpByLine">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand SelectUpByLine { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand SelectUpByLine" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.SelectUpByLine" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property SelectUpByLine As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ SelectUpByLine { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>表示 <see cref="P:System.Windows.Documents.EditingCommands.SelectUpByLine" /> 命令，该命令请求将当前选择范围向上扩展一行。</summary>
        <value>请求的命令。  此命令的默认键笔势<see langword="Shift" /> + <see langword="Up" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 并不一定对任何给定的对象; 此命令的响应的实际实现在许多情况下响应命令的实现是应用程序编写器的责任。  
  
 此命令以本机方式支持通过<xref:System.Windows.Controls.RichTextBox>， <xref:System.Windows.Controls.TextBox>，和<xref:System.Windows.Controls.PasswordBox>。  
  
<a name="xamlAttributeUsage_SelectUpByLine"></a>   
## <a name="xaml-attribute-usage"></a>XAML 属性用法  
  
```  
<object property="SelectUpByLine"/>  
```  
  
   
  
## Examples  
 下面的示例演示如何调用上支持该命令的对象的编辑命令。  
  
 对于此示例，<xref:System.Windows.Controls.RichTextBox>用作命令目标。  请注意，<xref:System.Windows.Controls.RichTextBox>实现<xref:System.Windows.IInputElement>接口 (继承自<xref:System.Windows.FrameworkElement>)，它包括对很多编辑命令的本机支持。  
  
 第一个参数<xref:System.Windows.Input.RoutedCommand.Execute%2A>方法是命令参数。  最编辑命令忽略命令参数;一般情况下，此参数应`null`以进行编辑命令。  
  
 第二个参数指定该命令将路由到的对象。  此对象必须实现<xref:System.Windows.IInputElement>接口，并且应包括的处理程序指定的命令。  通常情况下，在不处理该命令的对象上调用时，已忽略命令。  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectDownByLine" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectUpByPage" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectUpByParagraph" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveUpByLine" />
      </Docs>
    </Member>
    <Member MemberName="SelectUpByPage">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand SelectUpByPage { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand SelectUpByPage" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.SelectUpByPage" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property SelectUpByPage As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ SelectUpByPage { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>表示 <see cref="P:System.Windows.Documents.EditingCommands.SelectUpByPage" /> 命令，该命令请求将当前选择范围向上扩展一页。</summary>
        <value>请求的命令。  此命令的默认键笔势<see langword="Shift" /> + <see langword="PageUp" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 并不一定对任何给定的对象; 此命令的响应的实际实现在许多情况下响应命令的实现是应用程序编写器的责任。  
  
 此命令以本机方式支持通过<xref:System.Windows.Controls.RichTextBox>， <xref:System.Windows.Controls.TextBox>，和<xref:System.Windows.Controls.PasswordBox>。  
  
<a name="xamlAttributeUsage_SelectUpByPage"></a>   
## <a name="xaml-attribute-usage"></a>XAML 属性用法  
  
```  
<object property="SelectUpByPage"/>  
```  
  
   
  
## Examples  
 下面的示例演示如何调用上支持该命令的对象的编辑命令。  
  
 对于此示例，<xref:System.Windows.Controls.RichTextBox>用作命令目标。  请注意，<xref:System.Windows.Controls.RichTextBox>实现<xref:System.Windows.IInputElement>接口 (继承自<xref:System.Windows.FrameworkElement>)，它包括对很多编辑命令的本机支持。  
  
 第一个参数<xref:System.Windows.Input.RoutedCommand.Execute%2A>方法是命令参数。  最编辑命令忽略命令参数;一般情况下，此参数应`null`以进行编辑命令。  
  
 第二个参数指定该命令将路由到的对象。  此对象必须实现<xref:System.Windows.IInputElement>接口，并且应包括的处理程序指定的命令。  通常情况下，在不处理该命令的对象上调用时，已忽略命令。  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectDownByPage" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectUpByParagraph" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectUpByLine" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveUpByPage" />
      </Docs>
    </Member>
    <Member MemberName="SelectUpByParagraph">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand SelectUpByParagraph { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand SelectUpByParagraph" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.SelectUpByParagraph" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property SelectUpByParagraph As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ SelectUpByParagraph { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>表示 <see cref="P:System.Windows.Documents.EditingCommands.SelectUpByParagraph" /> 命令，该命令请求将当前选择范围向上扩展一段。</summary>
        <value>请求的命令。  此命令的默认键笔势<see langword="Ctrl" /> + <see langword="Shift" /> + <see langword="Up" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果脱字号位于开始位置的段落，此命令将选择扩展到上一段的开头。  否则，此命令将选择扩展到的当前段落开头。  
  
 并不一定对任何给定的对象; 此命令的响应的实际实现在许多情况下响应命令的实现是应用程序编写器的责任。  
  
 此命令以本机方式支持通过<xref:System.Windows.Controls.RichTextBox>， <xref:System.Windows.Controls.TextBox>，和<xref:System.Windows.Controls.PasswordBox>。  
  
<a name="xamlAttributeUsage_SelectUpByParagraph"></a>   
## <a name="xaml-attribute-usage"></a>XAML 属性用法  
  
```  
<object property="SelectUpByParagraph"/>  
```  
  
   
  
## Examples  
 下面的示例演示如何调用上支持该命令的对象的编辑命令。  
  
 对于此示例，<xref:System.Windows.Controls.RichTextBox>用作命令目标。  请注意，<xref:System.Windows.Controls.RichTextBox>实现<xref:System.Windows.IInputElement>接口 (继承自<xref:System.Windows.FrameworkElement>)，它包括对很多编辑命令的本机支持。  
  
 第一个参数<xref:System.Windows.Input.RoutedCommand.Execute%2A>方法是命令参数。  最编辑命令忽略命令参数;一般情况下，此参数应`null`以进行编辑命令。  
  
 第二个参数指定该命令将路由到的对象。  此对象必须实现<xref:System.Windows.IInputElement>接口，并且应包括的处理程序指定的命令。  通常情况下，在不处理该命令的对象上调用时，已忽略命令。  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectDownByParagraph" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectUpByLine" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectUpByPage" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveUpByParagraph" />
      </Docs>
    </Member>
    <Member MemberName="TabBackward">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand TabBackward { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand TabBackward" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.TabBackward" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property TabBackward As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ TabBackward { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>表示 <see cref="P:System.Windows.Documents.EditingCommands.TabBackward" /> 命令。</summary>
        <value>请求的命令。  此命令的默认键笔势<see langword="Shift" /> + <see langword="Tab" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此命令的行为取决于当前所选内容。 如果选择项非空，则此命令相当于<xref:System.Windows.Documents.EditingCommands.DecreaseIndentation%2A>。 如果脱字号位于表单元格中 (由表示<xref:System.Windows.Documents.TableCell>元素)，此命令将插入符号移动到上一个单元格。 否则，在当前的位置插入一个 tab 字符。  
  
 并不一定对任何给定的对象; 此命令的响应的实际实现在许多情况下响应命令的实现是应用程序编写器的责任。  
  
 此命令以本机方式支持通过<xref:System.Windows.Controls.RichTextBox>和<xref:System.Windows.Controls.TextBox>(时<xref:System.Windows.Controls.Primitives.TextBoxBase.AcceptsTab%2A>属性是`true`)。  
  
<a name="xamlAttributeUsage_TabBackward"></a>   
## <a name="xaml-attribute-usage"></a>XAML 属性用法  
  
```  
<object property="TabBackward"/>  
```  
  
   
  
## Examples  
 下面的示例演示如何调用上支持该命令的对象的编辑命令。  
  
 对于此示例，<xref:System.Windows.Controls.RichTextBox>用作命令目标。  请注意，<xref:System.Windows.Controls.RichTextBox>实现<xref:System.Windows.IInputElement>接口 (继承自<xref:System.Windows.FrameworkElement>)，它包括对很多编辑命令的本机支持。  
  
 第一个参数<xref:System.Windows.Input.RoutedCommand.Execute%2A>方法是命令参数。  最编辑命令忽略命令参数;一般情况下，此参数应`null`以进行编辑命令。  
  
 第二个参数指定该命令将路由到的对象。  此对象必须实现<xref:System.Windows.IInputElement>接口，并且应包括的处理程序指定的命令。  通常情况下，在不处理该命令的对象上调用时，已忽略命令。  
  
```csharp  
RichTextBox rTB = new RichTextBox();  
  
EditingCommands.ToggleInsert.Execute(null, rTB);  
  
```  
  
```vb  
            Dim rTB As New RichTextBox()  
  
            EditingCommands.ToggleInsert.Execute(Nothing, rTB)  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.TabForward" />
      </Docs>
    </Member>
    <Member MemberName="TabForward">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand TabForward { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand TabForward" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.TabForward" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property TabForward As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ TabForward { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>表示 <see cref="P:System.Windows.Documents.EditingCommands.TabForward" /> 命令。</summary>
        <value>请求的命令。  此命令的默认键笔势为 <see langword="Tab" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此命令的行为取决于当前所选内容。 如果所选内容为非空，或如果所选内容为空且当前插入符号位置位于某一段落开头，则此命令相当于<xref:System.Windows.Documents.EditingCommands.IncreaseIndentation%2A>。 如果脱字号位于表单元格中 (由表示<xref:System.Windows.Documents.TableCell>元素)，此命令将插入符号移动到下一个单元格。 如果脱字号位于表的最后一个单元格中，此命令会导致要追加到表，插入符号放置在新行的第一个单元与新行。  否则，在当前的位置插入一个 tab 字符。  
  
 并不一定对任何给定的对象; 此命令的响应的实际实现在许多情况下响应命令的实现是应用程序编写器的责任。  
  
 此命令以本机方式支持通过<xref:System.Windows.Controls.RichTextBox>和<xref:System.Windows.Controls.TextBox>(时<xref:System.Windows.Controls.Primitives.TextBoxBase.AcceptsTab%2A>属性是`true`)。  
  
<a name="xamlAttributeUsage_TabForward"></a>   
## <a name="xaml-attribute-usage"></a>XAML 属性用法  
  
```  
<object property="TabForward"/>  
```  
  
   
  
## Examples  
 下面的示例演示如何调用上支持该命令的对象的编辑命令。  
  
 对于此示例，<xref:System.Windows.Controls.RichTextBox>用作命令目标。  请注意，<xref:System.Windows.Controls.RichTextBox>实现<xref:System.Windows.IInputElement>接口 (继承自<xref:System.Windows.FrameworkElement>)，它包括对很多编辑命令的本机支持。  
  
 第一个参数<xref:System.Windows.Input.RoutedCommand.Execute%2A>方法是命令参数。  最编辑命令忽略命令参数;一般情况下，此参数应`null`以进行编辑命令。  
  
 第二个参数指定该命令将路由到的对象。  此对象必须实现<xref:System.Windows.IInputElement>接口，并且应包括的处理程序指定的命令。  通常情况下，在不处理该命令的对象上调用时，已忽略命令。  
  
```csharp  
RichTextBox rTB = new RichTextBox();  
  
EditingCommands.ToggleInsert.Execute(null, rTB);  
  
```  
  
```vb  
            Dim rTB As New RichTextBox()  
  
            EditingCommands.ToggleInsert.Execute(Nothing, rTB)  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.TabBackward" />
      </Docs>
    </Member>
    <Member MemberName="ToggleBold">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand ToggleBold { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand ToggleBold" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.ToggleBold" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property ToggleBold As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ ToggleBold { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>表示 <see cref="P:System.Windows.Documents.EditingCommands.ToggleBold" /> 命令，该命令请求对当前所选内容进行 <see cref="T:System.Windows.Documents.Bold" /> 格式切换。</summary>
        <value>请求的命令。  此命令的默认键笔势<see langword="Ctrl" /> + <see langword="B" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果<xref:System.Windows.FontWeight>当前所选内容是从范围中<xref:System.Windows.FontWeights.Thin%2A>到<xref:System.Windows.FontWeights.SemiBold%2A>，<xref:System.Windows.FontWeights.Bold%2A>应用于当前所选内容。  否则为<xref:System.Windows.FontWeights.Normal%2A>应用。  有关比较列表<xref:System.Windows.FontWeight>值，请参阅<xref:System.Windows.FontWeights>。  
  
 当所选内容为空并且脱字号位于在某个词时，所选内容被扩展以包含整个单词。  
  
 并不一定对任何给定的对象; 此命令的响应的实际实现在许多情况下响应命令的实现是应用程序编写器的责任。  
  
 此命令以本机方式支持通过<xref:System.Windows.Controls.RichTextBox>。  
  
<a name="xamlAttributeUsage_ToggleBold"></a>   
## <a name="xaml-attribute-usage"></a>XAML 属性用法  
  
```  
<object property="ToggleBold"/>  
```  
  
   
  
## Examples  
 下面的示例演示如何调用上支持该命令的对象的编辑命令。  
  
 对于此示例，<xref:System.Windows.Controls.RichTextBox>用作命令目标。  请注意，<xref:System.Windows.Controls.RichTextBox>实现<xref:System.Windows.IInputElement>接口 (继承自<xref:System.Windows.FrameworkElement>)，它包括对很多编辑命令的本机支持。  
  
 第一个参数<xref:System.Windows.Input.RoutedCommand.Execute%2A>方法是命令参数。  最编辑命令忽略命令参数;一般情况下，此参数应`null`以进行编辑命令。  
  
 第二个参数指定该命令将路由到的对象。  此对象必须实现<xref:System.Windows.IInputElement>接口，并且应包括的处理程序指定的命令。  通常情况下，在不处理该命令的对象上调用时，已忽略命令。  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.ToggleItalic" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.ToggleUnderline" />
      </Docs>
    </Member>
    <Member MemberName="ToggleBullets">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand ToggleBullets { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand ToggleBullets" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.ToggleBullets" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property ToggleBullets As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ ToggleBullets { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>表示 <see cref="P:System.Windows.Documents.EditingCommands.ToggleBullets" /> 命令，该命令请求对当前所选内容进行无序列表（也称为项目符号列表）格式切换。</summary>
        <value>请求的命令。  此命令的默认键笔势<see langword="Ctrl" /> + <see langword="Shift" /> + <see langword="L" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此命令在<xref:System.Windows.Documents.Paragraph>级别。  如果对部分选择的内容 （包括插入符号所在段落中的空选择） 段落中调用此命令，则请求的效果将应用于整个段落。  当跨越多个段落的选择内容调用此命令时，产生的效果被应用于参与选择每个段落的全部内容。  
  
 并不一定对任何给定的对象; 此命令的响应的实际实现在许多情况下响应命令的实现是应用程序编写器的责任。  
  
 此命令以本机方式支持通过<xref:System.Windows.Controls.RichTextBox>。  
  
<a name="xamlAttributeUsage_ToggleBullets"></a>   
## <a name="xaml-attribute-usage"></a>XAML 属性用法  
  
```  
<object property="ToggleBullets"/>  
```  
  
   
  
## Examples  
 下面的示例演示如何调用上支持该命令的对象的编辑命令。  
  
 对于此示例，<xref:System.Windows.Controls.RichTextBox>用作命令目标。  请注意，<xref:System.Windows.Controls.RichTextBox>实现<xref:System.Windows.IInputElement>接口 (继承自<xref:System.Windows.FrameworkElement>)，它包括对很多编辑命令的本机支持。  
  
 第一个参数<xref:System.Windows.Input.RoutedCommand.Execute%2A>方法是命令参数。  最编辑命令忽略命令参数;一般情况下，此参数应`null`以进行编辑命令。  
  
 第二个参数指定该命令将路由到的对象。  此对象必须实现<xref:System.Windows.IInputElement>接口，并且应包括的处理程序指定的命令。  通常情况下，在不处理该命令的对象上调用时，已忽略命令。  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.ToggleNumbering" />
      </Docs>
    </Member>
    <Member MemberName="ToggleInsert">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand ToggleInsert { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand ToggleInsert" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.ToggleInsert" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property ToggleInsert As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ ToggleInsert { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>表示 <see cref="P:System.Windows.Documents.EditingCommands.ToggleInsert" /> 命令，该命令用于切换“插入”和“改写”键入模式。</summary>
        <value>请求的命令。  此命令的默认键笔势为 <see langword="Insert" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 并不一定对任何给定的对象; 此命令的响应的实际实现在许多情况下响应命令的实现是应用程序编写器的责任。  
  
 此命令以本机方式支持通过<xref:System.Windows.Controls.RichTextBox>， <xref:System.Windows.Controls.TextBox>，和<xref:System.Windows.Controls.PasswordBox>。  
  
<a name="xamlAttributeUsage_ToggleInsert"></a>   
## <a name="xaml-attribute-usage"></a>XAML 属性用法  
  
```  
<object property="ToggleInsert"/>  
```  
  
   
  
## Examples  
 下面的示例演示如何调用上支持该命令的对象的编辑命令。  
  
 对于此示例，<xref:System.Windows.Controls.RichTextBox>用作命令目标。  请注意，<xref:System.Windows.Controls.RichTextBox>实现<xref:System.Windows.IInputElement>接口 (继承自<xref:System.Windows.FrameworkElement>)，它包括对很多编辑命令的本机支持。  
  
 第一个参数<xref:System.Windows.Input.RoutedCommand.Execute%2A>方法是命令参数。  最编辑命令忽略命令参数;一般情况下，此参数应`null`以进行编辑命令。  
  
 第二个参数指定该命令将路由到的对象。  此对象必须实现<xref:System.Windows.IInputElement>接口，并且应包括的处理程序指定的命令。  通常情况下，在不处理该命令的对象上调用时，已忽略命令。  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToggleItalic">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand ToggleItalic { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand ToggleItalic" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.ToggleItalic" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property ToggleItalic As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ ToggleItalic { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>表示 <see cref="P:System.Windows.Documents.EditingCommands.ToggleItalic" /> 命令，该命令请求对当前所选内容进行 <see cref="T:System.Windows.Documents.Italic" /> 格式切换。</summary>
        <value>请求的命令。  此命令的默认键笔势<see langword="Ctrl" /> + <see langword="I" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果<xref:System.Windows.FontStyle>当前所选内容为<xref:System.Windows.FontStyles.Normal%2A>，<xref:System.Windows.FontStyles.Italic%2A>应用于当前所选内容。  否则为<xref:System.Windows.FontStyles.Normal%2A>应用。  
  
 当所选内容为空并且脱字号位于在某个词时，所选内容被扩展以包含整个单词。  
  
 并不一定对任何给定的对象; 此命令的响应的实际实现在许多情况下响应命令的实现是应用程序编写器的责任。  
  
 此命令以本机方式支持通过<xref:System.Windows.Controls.RichTextBox>。  
  
<a name="xamlAttributeUsage_ToggleItalic"></a>   
## <a name="xaml-attribute-usage"></a>XAML 属性用法  
  
```  
<object property="ToggleItalic"/>  
```  
  
   
  
## Examples  
 下面的示例演示如何调用上支持该命令的对象的编辑命令。  
  
 对于此示例，<xref:System.Windows.Controls.RichTextBox>用作命令目标。  请注意，<xref:System.Windows.Controls.RichTextBox>实现<xref:System.Windows.IInputElement>接口 (继承自<xref:System.Windows.FrameworkElement>)，它包括对很多编辑命令的本机支持。  
  
 第一个参数<xref:System.Windows.Input.RoutedCommand.Execute%2A>方法是命令参数。  最编辑命令忽略命令参数;一般情况下，此参数应`null`以进行编辑命令。  
  
 第二个参数指定该命令将路由到的对象。  此对象必须实现<xref:System.Windows.IInputElement>接口，并且应包括的处理程序指定的命令。  通常情况下，在不处理该命令的对象上调用时，已忽略命令。  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.ToggleBold" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.ToggleUnderline" />
      </Docs>
    </Member>
    <Member MemberName="ToggleNumbering">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand ToggleNumbering { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand ToggleNumbering" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.ToggleNumbering" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property ToggleNumbering As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ ToggleNumbering { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>表示 <see cref="P:System.Windows.Documents.EditingCommands.ToggleNumbering" /> 命令，该命令请求对当前所选内容进行排序列表（也称为编号列表）格式切换。</summary>
        <value>请求的命令。  此命令的默认键笔势<see langword="Ctrl" /> + <see langword="Shift" /> + <see langword="N" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此命令在<xref:System.Windows.Documents.Paragraph>级别。  如果对部分选择的内容 （包括插入符号所在段落中的空选择） 段落中调用此命令，则请求的效果将应用于整个段落。  当跨越多个段落的选择内容调用此命令时，产生的效果被应用于参与选择每个段落的全部内容。  
  
 并不一定对任何给定的对象; 此命令的响应的实际实现在许多情况下响应命令的实现是应用程序编写器的责任。  
  
 此命令以本机方式支持通过<xref:System.Windows.Controls.RichTextBox>。  
  
<a name="xamlAttributeUsage_ToggleNumbering"></a>   
## <a name="xaml-attribute-usage"></a>XAML 属性用法  
  
```  
<object property="ToggleNumbering"/>  
```  
  
   
  
## Examples  
 下面的示例演示如何调用上支持该命令的对象的编辑命令。  
  
 对于此示例，<xref:System.Windows.Controls.RichTextBox>用作命令目标。  请注意，<xref:System.Windows.Controls.RichTextBox>实现<xref:System.Windows.IInputElement>接口 (继承自<xref:System.Windows.FrameworkElement>)，它包括对很多编辑命令的本机支持。  
  
 第一个参数<xref:System.Windows.Input.RoutedCommand.Execute%2A>方法是命令参数。  最编辑命令忽略命令参数;一般情况下，此参数应`null`以进行编辑命令。  
  
 第二个参数指定该命令将路由到的对象。  此对象必须实现<xref:System.Windows.IInputElement>接口，并且应包括的处理程序指定的命令。  通常情况下，在不处理该命令的对象上调用时，已忽略命令。  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.ToggleItalic" />
      </Docs>
    </Member>
    <Member MemberName="ToggleSubscript">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand ToggleSubscript { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand ToggleSubscript" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.ToggleSubscript" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property ToggleSubscript As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ ToggleSubscript { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>表示 <see cref="P:System.Windows.Documents.EditingCommands.ToggleSubscript" /> 命令，该命令请求对当前所选内容进行下标格式切换。</summary>
        <value>请求的命令。  此命令的默认键笔势<see langword="Ctrl" /> + <see langword="OemPlus" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 并不一定对任何给定的对象; 此命令的响应的实际实现在许多情况下响应命令的实现是应用程序编写器的责任。  
  
<a name="xamlAttributeUsage_ToggleSubscript"></a>   
## <a name="xaml-attribute-usage"></a>XAML 属性用法  
  
```  
<object property="ToggleSubscript"/>  
```  
  
   
  
## Examples  
 下面的示例演示如何调用上支持该命令的对象的编辑命令。  
  
 对于此示例，<xref:System.Windows.Controls.RichTextBox>用作命令目标。  请注意，<xref:System.Windows.Controls.RichTextBox>实现<xref:System.Windows.IInputElement>接口 (继承自<xref:System.Windows.FrameworkElement>)，它包括对很多编辑命令的本机支持。  
  
 第一个参数<xref:System.Windows.Input.RoutedCommand.Execute%2A>方法是命令参数。  最编辑命令忽略命令参数;一般情况下，此参数应`null`以进行编辑命令。  
  
 第二个参数指定该命令将路由到的对象。  此对象必须实现<xref:System.Windows.IInputElement>接口，并且应包括的处理程序指定的命令。  通常情况下，在不处理该命令的对象上调用时，已忽略命令。  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.ToggleSuperscript" />
      </Docs>
    </Member>
    <Member MemberName="ToggleSuperscript">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand ToggleSuperscript { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand ToggleSuperscript" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.ToggleSuperscript" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property ToggleSuperscript As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ ToggleSuperscript { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>表示 <see cref="P:System.Windows.Documents.EditingCommands.ToggleSuperscript" /> 命令，该命令请求对当前所选内容进行上标格式切换。</summary>
        <value>请求的命令。  此命令的默认键笔势<see langword="Ctrl" /> + <see langword="Shift" /> + <see langword="OemPlus" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 并不一定对任何给定的对象; 此命令的响应的实际实现在许多情况下响应命令的实现是应用程序编写器的责任。  
  
<a name="xamlAttributeUsage_ToggleSuperscript"></a>   
## <a name="xaml-attribute-usage"></a>XAML 属性用法  
  
```  
<object property="ToggleSuperscript"/>  
```  
  
   
  
## Examples  
 下面的示例演示如何调用上支持该命令的对象的编辑命令。  
  
 对于此示例，<xref:System.Windows.Controls.RichTextBox>用作命令目标。  请注意，<xref:System.Windows.Controls.RichTextBox>实现<xref:System.Windows.IInputElement>接口 (继承自<xref:System.Windows.FrameworkElement>)，它包括对很多编辑命令的本机支持。  
  
 第一个参数<xref:System.Windows.Input.RoutedCommand.Execute%2A>方法是命令参数。  最编辑命令忽略命令参数;一般情况下，此参数应`null`以进行编辑命令。  
  
 第二个参数指定该命令将路由到的对象。  此对象必须实现<xref:System.Windows.IInputElement>接口，并且应包括的处理程序指定的命令。  通常情况下，在不处理该命令的对象上调用时，已忽略命令。  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.ToggleSubscript" />
      </Docs>
    </Member>
    <Member MemberName="ToggleUnderline">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand ToggleUnderline { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand ToggleUnderline" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.ToggleUnderline" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property ToggleUnderline As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ ToggleUnderline { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>表示 <see cref="P:System.Windows.Documents.EditingCommands.ToggleUnderline" /> 命令，该命令请求对当前所选内容进行 <see cref="T:System.Windows.Documents.Underline" /> 格式切换。</summary>
        <value>请求的命令。  此命令的默认键笔势<see langword="Ctrl" /> + <see langword="U" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当所选内容为空并且脱字号位于在某个词时，所选内容被扩展以包含整个单词。  
  
 并不一定对任何给定的对象; 此命令的响应的实际实现在许多情况下响应命令的实现是应用程序编写器的责任。  
  
 此命令以本机方式支持通过<xref:System.Windows.Controls.RichTextBox>。  
  
<a name="xamlAttributeUsage_ToggleUnderline"></a>   
## <a name="xaml-attribute-usage"></a>XAML 属性用法  
  
```  
<object property="ToggleUnderline"/>  
```  
  
   
  
## Examples  
 下面的示例演示如何调用上支持该命令的对象的编辑命令。  
  
 对于此示例，<xref:System.Windows.Controls.RichTextBox>用作命令目标。  请注意，<xref:System.Windows.Controls.RichTextBox>实现<xref:System.Windows.IInputElement>接口 (继承自<xref:System.Windows.FrameworkElement>)，它包括对很多编辑命令的本机支持。  
  
 第一个参数<xref:System.Windows.Input.RoutedCommand.Execute%2A>方法是命令参数。  最编辑命令忽略命令参数;一般情况下，此参数应`null`以进行编辑命令。  
  
 第二个参数指定该命令将路由到的对象。  此对象必须实现<xref:System.Windows.IInputElement>接口，并且应包括的处理程序指定的命令。  通常情况下，在不处理该命令的对象上调用时，已忽略命令。  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.ToggleBold" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.ToggleItalic" />
      </Docs>
    </Member>
  </Members>
</Type>