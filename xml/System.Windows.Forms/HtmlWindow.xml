<Type Name="HtmlWindow" FullName="System.Windows.Forms.HtmlWindow">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="c442b5c816d1d289ffc747d7706df5bec7a6b735" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-CN" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36520855" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class HtmlWindow" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit HtmlWindow extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Forms.HtmlWindow" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class HtmlWindow" />
  <TypeSignature Language="C++ CLI" Value="public ref class HtmlWindow sealed" />
  <TypeSignature Language="F#" Value="type HtmlWindow = class" />
  <AssemblyInfo>
    <AssemblyName>System.Windows.Forms</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>表示包含一个或多个 <see cref="T:System.Windows.Forms.HtmlDocument" /> 实例的逻辑窗口。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.HtmlWindow> 不应与在 Windows 窗体或 Win32 API; 窗口的概念混淆没有任何`HWND`或类似 Windows 资源，直接对应的实例<xref:System.Windows.Forms.HtmlWindow>。 相反，<xref:System.Windows.Forms.HtmlWindow>上用户的屏幕，以及用于与通过提示和对话框的用户交互的方法提供的文档的位置的高级说明。 <xref:System.Windows.Forms.HtmlWindow> 充当 Web 页面的文档和其元数据，例如文档的位置和 Web 浏览器的功能的逻辑容器。  
  
 一种 Web 页包含单个文档，或者`FRAMESET`包含一个或多个`FRAME`元素，其中每个承载其自己的文档。 Web 开发人员使用框架集以显示逻辑上相关的页面并排显示 （例如，内容旁边导航页页）。 当包含单个文档的页面时，你可以访问它通过<xref:System.Windows.Forms.HtmlWindow.Document%2A>属性<xref:System.Windows.Forms.HtmlWindow>; 如果则页面使用帧，您可以访问其文档，一直到<xref:System.Windows.Forms.HtmlWindow.Frames%2A>集合，其中包括一个或多个<xref:System.Windows.Forms.HtmlWindow>对象。  
  
 当你的主机<xref:System.Windows.Forms.WebBrowser>控件在 Windows 窗体应用程序，你可以选择与使用标准 Windows 窗体类，如用户交互<xref:System.Windows.Forms.Form>或<xref:System.Windows.Forms.MessageBox>，或者可以在使用方法<xref:System.Windows.Forms.HtmlWindow>针对此用途定义。 <xref:System.Windows.Forms.HtmlWindow.Alert%2A>方法具有自定义文本中显示一个简单的对话框和**确定**按钮;<xref:System.Windows.Forms.HtmlWindow.Prompt%2A>向用户; 呈现自定义文本和文本输入的字段的行和<xref:System.Windows.Forms.HtmlWindow.Confirm%2A>的自定义文本线显示一个对话框和**确定**和**取消**按钮。  
  
 你可以使用<xref:System.Windows.Forms.HtmlWindow>打开包含新的文档的新窗口。 <xref:System.Windows.Forms.HtmlWindow.Open%2A> 将指定的 URL 加载到已命名的窗口中，如果不存在，请创建它，而<xref:System.Windows.Forms.HtmlWindow.OpenNew%2A>始终在新创建的窗口中打开其 URL。  
  
   
  
## Examples  
 下面的代码示例包含两个方法。 第一个将在名为的窗口中打开 URL `displayWindow`，这便会创建的状态栏显示。 第二个在相同的窗口中，打开另一个 URL，但指定应显示仅位置栏。 请注意窗口和显示控件的维度取决于在其上第一次打开 URL。 该代码示例要求你的窗体包含<xref:System.Windows.Forms.WebBrowser>控件名为`WebBrowser1`。  
  
 [!code-csharp[System.Windows.Forms.HtmlWindow#13](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HtmlWindow/CS/Form1.cs#13)]
 [!code-vb[System.Windows.Forms.HtmlWindow#13](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.HtmlWindow/VB/Form1.vb#13)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="Alert">
      <MemberSignature Language="C#" Value="public void Alert (string message);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Alert(string message) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlWindow.Alert(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Alert (message As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Alert(System::String ^ message);" />
      <MemberSignature Language="F#" Value="member this.Alert : string -&gt; unit" Usage="htmlWindow.Alert message" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="message">要在消息框中显示的 <see cref="T:System.String" />。</param>
        <summary>显示消息框。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.MessageBox>类提供的功能更强大版本<xref:System.Windows.Forms.HtmlWindow.Alert%2A>方法。  
  
 尽管<xref:System.Windows.Forms.HtmlWindow.Alert%2A>接受 Unicode 文本作为输入，Internet Explorer 脚本提示符上将不显示非拉丁语言文本适当 Windows 95、 Windows 98、 Windows ME 或 Windows NT 由于操作系统限制。 有关详细信息，请参阅[信息： Internet Explorer 脚本将提示和 MBCS/Unicode](http://support.microsoft.com/default.aspx?scid=kb;en-us;211147)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AttachEventHandler">
      <MemberSignature Language="C#" Value="public void AttachEventHandler (string eventName, EventHandler eventHandler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AttachEventHandler(string eventName, class System.EventHandler eventHandler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlWindow.AttachEventHandler(System.String,System.EventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AttachEventHandler(System::String ^ eventName, EventHandler ^ eventHandler);" />
      <MemberSignature Language="F#" Value="member this.AttachEventHandler : string * EventHandler -&gt; unit" Usage="htmlWindow.AttachEventHandler (eventName, eventHandler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="eventName" Type="System.String" />
        <Parameter Name="eventHandler" Type="System.EventHandler" />
      </Parameters>
      <Docs>
        <param name="eventName">要处理的事件的名称。</param>
        <param name="eventHandler">对处理事件的托管代码的引用。</param>
        <summary>为已命名的 HTML DOM 事件添加事件处理程序。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 文档完成加载之前，不应将事件附加到 HTML 文档或其对象之一。 中的最早，应调用此方法是<xref:System.Windows.Forms.WebBrowser.DocumentCompleted>事件<xref:System.Windows.Forms.WebBrowser>控件。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlWindow.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close();" />
      <MemberSignature Language="F#" Value="member this.Close : unit -&gt; unit" Usage="htmlWindow.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>关闭窗口。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用<xref:System.Windows.Forms.HtmlWindow.IsClosed%2A>属性来确定是否窗口已关闭。 如果窗口已关闭，则此方法将产生任何影响。  
  
 当你创建新的 windows 使用<xref:System.Windows.Forms.HtmlWindow.Open%2A>或<xref:System.Windows.Forms.HtmlWindow.OpenNew%2A>，<xref:System.Windows.Forms.HtmlWindow.Close%2A>导致 HTML 文档对象模型，以便打开 Internet Explorer 的新实例。 如果不调用<xref:System.Windows.Forms.HtmlWindow.Close%2A>上所有已创建的 windows，Internet Explorer 的此实例将保持运行状态甚至在你的应用程序关闭后。  
  
   
  
## Examples  
 下面的代码示例将打开一个窗口，并将其关闭，如果用户在过去 5 分钟内未使用它。 编写的代码示例时，假设你的窗体具有<xref:System.Windows.Forms.WebBrowser>控件名为`WebBrowser1`、<xref:System.Windows.Forms.Button>名为`Button1`，和一个<xref:System.Windows.Forms.Timer>类名为`Timer1`。 若要成功运行此示例中，更改提供给第一个自变量<xref:System.Windows.Forms.HtmlWindow.OpenNew%2A>到有效的 URL。  
  
 [!code-csharp[System.Windows.Forms.HtmlWindow#9](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HtmlWindow/CS/Form1.cs#9)]
 [!code-vb[System.Windows.Forms.HtmlWindow#9](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.HtmlWindow/VB/Form1.vb#9)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Confirm">
      <MemberSignature Language="C#" Value="public bool Confirm (string message);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Confirm(string message) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlWindow.Confirm(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Confirm (message As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Confirm(System::String ^ message);" />
      <MemberSignature Language="F#" Value="member this.Confirm : string -&gt; bool" Usage="htmlWindow.Confirm message" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="message">要显示给用户的文本。</param>
        <summary>显示一个包含一则消息和多个按钮的对话框以请求作出“是”/“否”等响应。</summary>
        <returns>如果用户单击“是”，则为 <see langword="true" />；如果用户单击“否”或关闭对话框，则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.HtmlWindow.Confirm%2A> 显示模式对话框;用户将不能访问而无需先关闭此对话框中的基础的 HTML 页。  
  
 尽管<xref:System.Windows.Forms.HtmlWindow.Confirm%2A>接受 Unicode 文本作为输入，Internet Explorer 脚本提示符上将不显示非拉丁语言文本适当 Windows 95、 Windows 98、 Windows ME 或 Windows NT 由于操作系统限制。 有关详细信息，请参阅[信息： Internet Explorer 脚本将提示和 MBCS/Unicode](http://support.microsoft.com/default.aspx?scid=kb;en-us;211147)。  
  
   
  
## Examples  
 复制以下 HTML 并将其保存到名为 orderForm.htm 的表单：  
  
 `<HTML>`  
  
 `<BODY>`  
  
 `<FORM name="NewOrderForm">`  
  
 `Select Part Type:`  
  
 `<SELECT name="PartType">`  
  
 `<OPTION>AZ-3700`  
  
 `<OPTION>AZ-3701`  
  
 `<OPTION>AZ-3702`  
  
 `<SELECT><br>`  
  
 `Quantity: <INPUT type="text" name="PartQty" size="2" maxsize="2"><br>`  
  
 `Building/Desk:`  
  
 `<INPUT type="text" name="PartBuilding" size="2" maxsize="2"> /`  
  
 `<INPUT type="text" name="PartDesk" size="2" maxsize="2"><p>`  
  
 `<INPUT type="submit" value="Transmit Order">`  
  
 `</FORM>`  
  
 `</BODY>`  
  
 `</HTML>`  
  
 下面的代码示例显示<xref:System.Windows.Forms.HtmlWindow.Confirm%2A>对话框中，当用户提交`NewOrderForm`。  
  
 [!code-csharp[System.Windows.Forms.HtmlWindow#10](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HtmlWindow/CS/Form1.cs#10)]
 [!code-vb[System.Windows.Forms.HtmlWindow#10](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.HtmlWindow/VB/Form1.vb#10)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DetachEventHandler">
      <MemberSignature Language="C#" Value="public void DetachEventHandler (string eventName, EventHandler eventHandler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DetachEventHandler(string eventName, class System.EventHandler eventHandler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlWindow.DetachEventHandler(System.String,System.EventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DetachEventHandler(System::String ^ eventName, EventHandler ^ eventHandler);" />
      <MemberSignature Language="F#" Value="member this.DetachEventHandler : string * EventHandler -&gt; unit" Usage="htmlWindow.DetachEventHandler (eventName, eventHandler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="eventName" Type="System.String" />
        <Parameter Name="eventHandler" Type="System.EventHandler" />
      </Parameters>
      <Docs>
        <param name="eventName">要处理的事件的名称。</param>
        <param name="eventHandler">对处理事件的托管代码的引用。</param>
        <summary>移除已命名的事件处理程序。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Document">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.HtmlDocument Document { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.HtmlDocument Document" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlWindow.Document" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Document As HtmlDocument" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::HtmlDocument ^ Document { System::Windows::Forms::HtmlDocument ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Document : System.Windows.Forms.HtmlDocument" Usage="System.Windows.Forms.HtmlWindow.Document" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlDocument</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取窗口中包含的 HTML 文档。</summary>
        <value>如果已加载了一个文档，则为 <see cref="T:System.Windows.Forms.HtmlDocument" /> 的有效实例。 如果此窗口包含<c>框架集</c>，或者当前未加载任何文档，它将返回<see langword="null" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 通常，你将访问<xref:System.Windows.Forms.HtmlWindow.Document%2A>通过<xref:System.Windows.Forms.WebBrowser.Document%2A>属性<xref:System.Windows.Forms.WebBrowser>控件。 当你需要访问内的文档时使用此属性`FRAME`使用<xref:System.Windows.Forms.HtmlWindow.Frames%2A>集合。  
  
   
  
## Examples  
 下面的代码示例检查包含框架的页内的所有文档，并从将来检查每个页中创建的所有传出的超链接表。  
  
 [!code-csharp[System.Windows.Forms.HtmlWindow#2](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HtmlWindow/CS/Form1.cs#2)]
 [!code-vb[System.Windows.Forms.HtmlWindow#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.HtmlWindow/VB/Form1.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DomWindow">
      <MemberSignature Language="C#" Value="public object DomWindow { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object DomWindow" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlWindow.DomWindow" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DomWindow As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ DomWindow { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DomWindow : obj" Usage="System.Windows.Forms.HtmlWindow.DomWindow" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取此类包装的非托管接口。</summary>
        <value>一个对象，可以强制转换为<see langword="IHTMLWindow2" />， <see langword="IHTMLWindow3" />，或<see langword="IHTMLWindow4" />指针。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用基础非托管的接口指针到文档对象模型 (DOM) 来执行未公开的方法<xref:System.Windows.Forms.HtmlWindow>。  
  
 你必须添加引用到非托管 MSHTML.dll 以使用<xref:System.Windows.Forms.HtmlWindow.DomWindow%2A>。 有关详细信息，请参阅[导入类型库当作程序集](~/docs/framework/interop/importing-a-type-library-as-an-assembly.md)。  
  
   
  
## Examples  
 下面的代码示例获取`IHTMLWindow2`从文档的指针的窗口，并在一个模式窗口中显示新文档。  
  
 [!code-csharp[System.Windows.Forms.HtmlWindow#3](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HtmlWindow/CS/Form1.cs#3)]
 [!code-vb[System.Windows.Forms.HtmlWindow#3](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.HtmlWindow/VB/Form1.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlWindow.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="htmlWindow.Equals obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">要测试的对象。</param>
        <summary>测试对象是否与当前对象相等。</summary>
        <returns>如果对象相等，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Error">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.HtmlElementErrorEventHandler Error;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.HtmlElementErrorEventHandler Error" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.HtmlWindow.Error" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Error As HtmlElementErrorEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::HtmlElementErrorEventHandler ^ Error;" />
      <MemberSignature Language="F#" Value="member this.Error : System.Windows.Forms.HtmlElementErrorEventHandler " Usage="member this.Error : System.Windows.Forms.HtmlElementErrorEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElementErrorEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当窗口内部运行的脚本遇到运行时错误时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 HTML 页面可以包含用 JScript 或 VBScript，当加载页时可以执行通常编写的脚本代码。 <xref:System.Windows.Forms.HtmlWindow.Error> 脚本遇到运行时错误时发生。 因为脚本代码位于后期绑定，这意味着，与对象的调用不被解析直到运行时错误可能包括中引用 null 对象到调用未定义的属性或方法的所有内容。  
  
 你可以设置<xref:System.Windows.Forms.HtmlElementErrorEventArgs.Handled%2A>属性<xref:System.Windows.Forms.HtmlElementErrorEventArgs>为 true，以便防止 Internet 资源管理器中的本机错误对话框显示。
  
   
  
## Examples  
 下面的代码示例捕获结果时在 HTML 页上的脚本尝试访问文档中未定义的对象的错误。 此页必须是完全加载之前<xref:System.Windows.Forms.HtmlWindow.Error>事件处理程序附加，否则此示例将不起作用。  
  
 [!code-csharp[System.Windows.Forms.HtmlWindow#16](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HtmlWindow/CS/Form1.cs#16)]
 [!code-vb[System.Windows.Forms.HtmlWindow#16](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.HtmlWindow/VB/Form1.vb#16)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Focus">
      <MemberSignature Language="C#" Value="public void Focus ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Focus() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlWindow.Focus" />
      <MemberSignature Language="VB.NET" Value="Public Sub Focus ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Focus();" />
      <MemberSignature Language="F#" Value="member this.Focus : unit -&gt; unit" Usage="htmlWindow.Focus " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>将焦点置于当前窗口上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果另一窗口拥有焦点之前<xref:System.Windows.Forms.HtmlWindow.Focus%2A>已调用，该窗口将失去焦点。  
  
 不要调用焦点上一个窗口内的一个元素之前窗口的<xref:System.Windows.Forms.HtmlWindow.Load>引发事件。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Frames">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.HtmlWindowCollection Frames { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.HtmlWindowCollection Frames" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlWindow.Frames" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Frames As HtmlWindowCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::HtmlWindowCollection ^ Frames { System::Windows::Forms::HtmlWindowCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Frames : System.Windows.Forms.HtmlWindowCollection" Usage="System.Windows.Forms.HtmlWindow.Frames" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlWindowCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取在网页中定义的每个 <c>FRAME</c> 元素的一个引用。</summary>
        <value>
          <see cref="T:System.Windows.Forms.HtmlWindowCollection" />的文档的<c>帧</c>和<c>IFRAME</c>对象。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A`FRAME`是一套中定义的 windows `FRAMESET`。 `FRAME`s 启用承载单个文档中的多个文档。 每个`FRAME`被定义为具有一定行和列宽度，并且是相对于其他页上的位置`FRAME`中定义的 s `FRAMESET`; 的位置`FRAME`固定的虽然用户有时可以使用鼠标游标来增加或缩减`FRAME`。 `IFRAME`是类似于的框架，但它不需要定位在固定位置。  
  
 框架将包含的一个实例<xref:System.Windows.Forms.HtmlWindow>每个`FRAME`或`IFRAME`在网页中定义。  
  
   
  
## Examples  
 下面的代码示例检查包含框架的页内的所有文档，并从将来检查每个页中创建的所有传出的超链接表。  
  
 [!code-csharp[System.Windows.Forms.HtmlWindow#2](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HtmlWindow/CS/Form1.cs#2)]
 [!code-vb[System.Windows.Forms.HtmlWindow#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.HtmlWindow/VB/Form1.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlWindow.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="htmlWindow.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>用作特定类型的哈希函数。</summary>
        <returns>当前 <see cref="T:System.Windows.Forms.HtmlWindow" /> 的哈希代码。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GotFocus">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.HtmlElementEventHandler GotFocus;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.HtmlElementEventHandler GotFocus" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.HtmlWindow.GotFocus" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event GotFocus As HtmlElementEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::HtmlElementEventHandler ^ GotFocus;" />
      <MemberSignature Language="F#" Value="member this.GotFocus : System.Windows.Forms.HtmlElementEventHandler " Usage="member this.GotFocus : System.Windows.Forms.HtmlElementEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElementEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在当前窗口获得用户输入焦点时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.HtmlWindow.GotFocus> 将出现：  
  
-   中的第一个窗口`FRAMESET`时`FRAMESET`首次加载。  
  
-   `FRAME` ，最后具有焦点时窗口包含<xref:System.Windows.Forms.WebBrowser>控件置于前台。  
  
-   A`FRAME`单击用户，但只有当用户单击不会将焦点置于窗口内的元素。  
  
 无法取消的默认操作为<xref:System.Windows.Forms.HtmlWindow.GotFocus>事件，或防止冒泡。
  
   
  
## Examples  
 下面的代码示例演示如何使用此成员。 在示例中，事件处理程序报告的匹配项<xref:System.Windows.Forms.HtmlWindow.GotFocus>事件。 此报告可帮助您了解当发生事件，并可以帮助您进行调试。  
  
 若要运行此代码示例，请将其粘贴到包含类型的实例的项目<xref:System.Windows.Forms.HtmlWindow>名为`HtmlWindow1`。 然后，确保与事件处理程序<xref:System.Windows.Forms.HtmlWindow.GotFocus>事件。  
  
 [!code-csharp[System.Windows.Forms.EventExamples#452](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#452)]
 [!code-vb[System.Windows.Forms.EventExamples#452](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#452)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="History">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.HtmlHistory History { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.HtmlHistory History" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlWindow.History" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property History As HtmlHistory" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::HtmlHistory ^ History { System::Windows::Forms::HtmlHistory ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.History : System.Windows.Forms.HtmlHistory" Usage="System.Windows.Forms.HtmlWindow.History" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlHistory</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取包含用户最近访问的 URL 的对象。</summary>
        <value>
          <see cref="T:System.Windows.Forms.HtmlHistory" />当前窗口。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.HtmlWindow.History%2A> 包含在当前窗口中，这被称为导航到的所有 Url*导航堆栈*，并提供用于导航到这些文档的方法。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsClosed">
      <MemberSignature Language="C#" Value="public bool IsClosed { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsClosed" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlWindow.IsClosed" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsClosed As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsClosed { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsClosed : bool" Usage="System.Windows.Forms.HtmlWindow.IsClosed" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示此窗口是处于打开还是关闭状态。</summary>
        <value>如果此窗口在屏幕上仍然处于打开状态，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果<xref:System.Windows.Forms.HtmlWindow>已由用户或通过调用关闭<xref:System.Windows.Forms.HtmlWindow.Close%2A>方法，尝试导航到新 URL 或访问窗口的文档将导致错误。 使用此属性以确定它是否是安全地在当前窗口对象上调用属性和方法。  
  
   
  
## Examples  
 下面的代码示例将打开一个窗口，并将其关闭，如果用户在过去 5 分钟内未使用它。 该代码示例要求你窗体具有<xref:System.Windows.Forms.WebBrowser>控件名为`WebBrowser1`、<xref:System.Windows.Forms.Button>名为`Button1`，和一个<xref:System.Windows.Forms.Timer>类名为`Timer1`。  
  
 [!code-csharp[System.Windows.Forms.HtmlWindow#8](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HtmlWindow/CS/Form1.cs#8)]
 [!code-vb[System.Windows.Forms.HtmlWindow#8](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.HtmlWindow/VB/Form1.vb#8)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.HtmlElementEventHandler Load;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.HtmlElementEventHandler Load" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.HtmlWindow.Load" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Load As HtmlElementEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::HtmlElementEventHandler ^ Load;" />
      <MemberSignature Language="F#" Value="member this.Load : System.Windows.Forms.HtmlElementEventHandler " Usage="member this.Load : System.Windows.Forms.HtmlElementEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElementEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当窗口的文档及其所有元素完成初始化时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.HtmlWindow.Load>事件工作原理类似于<xref:System.Windows.Forms.WebBrowser.DocumentCompleted>上的事件<xref:System.Windows.Forms.WebBrowser>控件： 它发出信号，它是安全的访问 HTML 文档内的元素。  
  
 无法取消的默认操作为<xref:System.Windows.Forms.HtmlWindow.Load>事件。
  
   
  
## Examples  
 下面的代码示例演示如何使用此成员。 在示例中，事件处理程序报告的匹配项<xref:System.Windows.Forms.HtmlWindow.Load>事件。 此报告可帮助您了解当发生事件，并可以帮助您进行调试。 若要报告或频繁发生的事件上多个事件，请考虑替换<xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType>与<xref:System.Console.WriteLine%2A?displayProperty=nameWithType>或追加到一个多行消息<xref:System.Windows.Forms.TextBox>。  
  
 若要运行此代码示例，请将其粘贴到包含类型的实例的项目<xref:System.Windows.Forms.HtmlWindow>名为`HtmlWindow1`。 然后，确保与事件处理程序<xref:System.Windows.Forms.HtmlWindow.Load>事件。  
  
 [!code-csharp[System.Windows.Forms.EventExamples#453](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#453)]
 [!code-vb[System.Windows.Forms.EventExamples#453](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#453)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LostFocus">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.HtmlElementEventHandler LostFocus;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.HtmlElementEventHandler LostFocus" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.HtmlWindow.LostFocus" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event LostFocus As HtmlElementEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::HtmlElementEventHandler ^ LostFocus;" />
      <MemberSignature Language="F#" Value="member this.LostFocus : System.Windows.Forms.HtmlElementEventHandler " Usage="member this.LostFocus : System.Windows.Forms.HtmlElementEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElementEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当用户输入焦点离开窗口时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下面的代码示例演示如何使用此成员。 在示例中，事件处理程序报告的匹配项<xref:System.Windows.Forms.HtmlWindow.LostFocus>事件。 此报告可帮助您了解当发生事件，并可以帮助您进行调试。  
  
 若要运行此代码示例，请将其粘贴到包含类型的实例的项目<xref:System.Windows.Forms.HtmlWindow>名为`HtmlWindow1`。 然后，确保与事件处理程序<xref:System.Windows.Forms.HtmlWindow.LostFocus>事件。  
  
 [!code-csharp[System.Windows.Forms.EventExamples#454](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#454)]
 [!code-vb[System.Windows.Forms.EventExamples#454](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#454)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="MoveTo">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>将窗口移动到屏幕上的指定坐标。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="MoveTo">
      <MemberSignature Language="C#" Value="public void MoveTo (System.Drawing.Point point);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void MoveTo(valuetype System.Drawing.Point point) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlWindow.MoveTo(System.Drawing.Point)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void MoveTo(System::Drawing::Point point);" />
      <MemberSignature Language="F#" Value="member this.MoveTo : System.Drawing.Point -&gt; unit" Usage="htmlWindow.MoveTo point" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="point" Type="System.Drawing.Point" />
      </Parameters>
      <Docs>
        <param name="point">窗口左上角的 x 和 y 坐标。</param>
        <summary>将窗口移动到屏幕上的指定坐标。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 不能使用<xref:System.Windows.Forms.HtmlWindow.MoveTo%2A>到移动从屏幕可见边缘中移出窗口; 此方法还可通过脚本在网页上，并且允许不受信任的脚本来呈现 windows 不可见被视为不安全。  
  
 <xref:System.Windows.Forms.HtmlWindow.MoveTo%2A> 将引发<xref:System.UnauthorizedAccessException>如果想要移动的窗口和其父窗口具有不同的顶级域。 例如，如果您要承载<xref:System.Windows.Forms.WebBrowser>控制指向 a.adatum.com，创建一个新窗口使用<xref:System.Windows.Forms.HtmlWindow.OpenNew%2A>以显示 b.adatum.com。 在这种情况下，这两个窗口被视为是相同的顶级域的一部分，不会引发异常。 但是，如果调用<xref:System.Windows.Forms.HtmlWindow.OpenNew%2A>若要显示 www,microsoft.com，两个窗口，现在具有不同的顶级域，与<xref:System.Windows.Forms.HtmlWindow.MoveTo%2A>操作将导致要引发的异常。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">尝试执行此操作的代码没有操作此窗口的权限。</exception>
      </Docs>
    </Member>
    <Member MemberName="MoveTo">
      <MemberSignature Language="C#" Value="public void MoveTo (int x, int y);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void MoveTo(int32 x, int32 y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlWindow.MoveTo(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub MoveTo (x As Integer, y As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void MoveTo(int x, int y);" />
      <MemberSignature Language="F#" Value="member this.MoveTo : int * int -&gt; unit" Usage="htmlWindow.MoveTo (x, y)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Int32" />
        <Parameter Name="y" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="x">窗口左上角的 x 坐标。</param>
        <param name="y">窗口左上角的 y 坐标。</param>
        <summary>将窗口移动到屏幕上的指定坐标。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 不能使用<xref:System.Windows.Forms.HtmlWindow.MoveTo%2A>到移动从屏幕可见边缘中移出窗口; 此方法还可通过脚本在网页上，并且允许不受信任的脚本来呈现 windows 不可见被视为不安全。  
  
 <xref:System.Windows.Forms.HtmlWindow.MoveTo%2A> 将引发<xref:System.UnauthorizedAccessException>如果想要移动的窗口和其父窗口具有不同的顶级域。 例如，如果您要承载<xref:System.Windows.Forms.WebBrowser>控制和它所指向的 a.adatum.com，创建新的窗口使用<xref:System.Windows.Forms.HtmlWindow.OpenNew%2A>以显示 b.adatum.com。 在这种情况下，这两个窗口被视为是相同的顶级域的一部分，不会引发异常。 但是，如果调用<xref:System.Windows.Forms.HtmlWindow.OpenNew%2A>若要显示 www,microsoft.com，两个窗口，现在具有不同的顶级域，与<xref:System.Windows.Forms.HtmlWindow.MoveTo%2A>操作将导致要引发的异常。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">尝试执行此操作的代码没有操作此窗口的权限。</exception>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public string Name { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlWindow.Name" />
      <MemberSignature Language="VB.NET" Value="Public Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Name { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Name : string with get, set" Usage="System.Windows.Forms.HtmlWindow.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置窗口的名称。</summary>
        <value>表示名称的 <see cref="T:System.String" />。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Navigate">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>显示或下载位于指定 URL 位置的新内容。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Navigate">
      <MemberSignature Language="C#" Value="public void Navigate (string urlString);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Navigate(string urlString) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlWindow.Navigate(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Navigate (urlString As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Navigate(System::String ^ urlString);" />
      <MemberSignature Language="F#" Value="member this.Navigate : string -&gt; unit" Usage="htmlWindow.Navigate urlString" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="urlString" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="urlString">要显示的资源，由统一资源定位器描述。</param>
        <summary>显示或下载位于指定 URL 位置的新内容。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果`url`参数指向 HTML 页，将销毁当前显示在窗口中的页面，并将其替换为新页面持有; 不能在旧的页中的托管 DOM 对象保存你的应用程序的任何引用。 如果`url`点到 Internet 资源管理器无法显示的资源，则用户将看到一个对话框，询问你是否要打开在应用程序，保存它以磁盘，或取消下载操作外部资源。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Navigate">
      <MemberSignature Language="C#" Value="public void Navigate (Uri url);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Navigate(class System.Uri url) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlWindow.Navigate(System.Uri)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Navigate (url As Uri)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Navigate(Uri ^ url);" />
      <MemberSignature Language="F#" Value="member this.Navigate : Uri -&gt; unit" Usage="htmlWindow.Navigate url" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="url" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="url">要在当前窗口中显示的文档或对象的位置，以 <see cref="T:System.Uri" /> 的形式指定。</param>
        <summary>在当前窗口中显示新文档。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (System.Windows.Forms.HtmlWindow left, System.Windows.Forms.HtmlWindow right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(class System.Windows.Forms.HtmlWindow left, class System.Windows.Forms.HtmlWindow right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlWindow.op_Equality(System.Windows.Forms.HtmlWindow,System.Windows.Forms.HtmlWindow)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (left As HtmlWindow, right As HtmlWindow) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(System::Windows::Forms::HtmlWindow ^ left, System::Windows::Forms::HtmlWindow ^ right);" />
      <MemberSignature Language="F#" Value="static member ( = ) : System.Windows.Forms.HtmlWindow * System.Windows.Forms.HtmlWindow -&gt; bool" Usage="left = right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Windows.Forms.HtmlWindow" />
        <Parameter Name="right" Type="System.Windows.Forms.HtmlWindow" />
      </Parameters>
      <Docs>
        <param name="left">第一个 <see cref="T:System.Windows.Forms.HtmlWindow" /> 对象。</param>
        <param name="right">第二个 <see cref="T:System.Windows.Forms.HtmlWindow" /> 对象。</param>
        <summary>测试两个 <see cref="T:System.Windows.Forms.HtmlWindow" /> 对象是否相等。</summary>
        <returns>如果两个参数都为 <see langword="null" />，或是两个元素具有相同的基础 COM 接口，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 相等运算符测试`IUnknown`包装由所提供的基础 COM 对象的指针<xref:System.Windows.Forms.HtmlWindow>类。  
  
 此运算符的等效方法是 <xref:System.Windows.Forms.HtmlWindow.Equals%28System.Object%29?displayProperty=nameWithType>]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (System.Windows.Forms.HtmlWindow left, System.Windows.Forms.HtmlWindow right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(class System.Windows.Forms.HtmlWindow left, class System.Windows.Forms.HtmlWindow right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlWindow.op_Inequality(System.Windows.Forms.HtmlWindow,System.Windows.Forms.HtmlWindow)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (left As HtmlWindow, right As HtmlWindow) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(System::Windows::Forms::HtmlWindow ^ left, System::Windows::Forms::HtmlWindow ^ right);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : System.Windows.Forms.HtmlWindow * System.Windows.Forms.HtmlWindow -&gt; bool" Usage="System.Windows.Forms.HtmlWindow.op_Inequality (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Windows.Forms.HtmlWindow" />
        <Parameter Name="right" Type="System.Windows.Forms.HtmlWindow" />
      </Parameters>
      <Docs>
        <param name="left">第一个 <see cref="T:System.Windows.Forms.HtmlWindow" /> 对象。</param>
        <param name="right">第二个 <see cref="T:System.Windows.Forms.HtmlWindow" /> 对象。</param>
        <summary>测试两个 <see langword="HtmlWindow" /> 对象是否不相等。</summary>
        <returns>如果只有两个对象之一为 <see langword="null" />，或基础 COM 指针不匹配，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Open">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>在已命名的窗口中显示文件。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Open">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.HtmlWindow Open (string urlString, string target, string windowOptions, bool replaceEntry);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Forms.HtmlWindow Open(string urlString, string target, string windowOptions, bool replaceEntry) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlWindow.Open(System.String,System.String,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function Open (urlString As String, target As String, windowOptions As String, replaceEntry As Boolean) As HtmlWindow" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Forms::HtmlWindow ^ Open(System::String ^ urlString, System::String ^ target, System::String ^ windowOptions, bool replaceEntry);" />
      <MemberSignature Language="F#" Value="member this.Open : string * string * string * bool -&gt; System.Windows.Forms.HtmlWindow" Usage="htmlWindow.Open (urlString, target, windowOptions, replaceEntry)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlWindow</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="urlString" Type="System.String" />
        <Parameter Name="target" Type="System.String" />
        <Parameter Name="windowOptions" Type="System.String" />
        <Parameter Name="replaceEntry" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="urlString">描述要加载的文件位置的统一资源定位器。</param>
        <param name="target">要在其中打开资源的窗口的名称。 它可能是开发人员提供的名称或者下列特殊值之一：<c>_blank</c>：在新窗口中打开 <c>url</c>。 与调用 <see cref="M:System.Windows.Forms.HtmlWindow.OpenNew(System.String,System.String)" /> 作用相同。  
  
 <c>_media</c>在“媒体”栏中打开 <c>url</c>。  
  
 <c>_parent</c>在创建当前窗口的窗口中打开 <c>url</c>。  
  
 <c>_search</c>在“搜索”栏中打开 <c>url</c>。  
  
 <c>_self</c>在当前窗口中打开 <c>url</c>。  
  
 <c>_top</c>：如果在属于 <c>FRAME</c> 元素的窗口上调用，则在承载其 <c>FRAMESET</c> 的窗口中打开 <c>url</c>。 否则，与 <c>_self</c> 的作用相同。</param>
        <param name="windowOptions">一个逗号分隔的字符串，由以下零个或多个以 <c>name=value</c> 形式表现的选项组成。 除了采用随机整数的 <c>left</c>、<c>top</c>、<c>height</c> 和 <c>width</c> 选项，每个选项接受 <c>yes</c> 或 <see langword="1" /> 以及 <c>no</c> 或 <see langword="0" /> 作为有效值。  
  
 <c>channelmode</c>：与被否决的 Internet Explorer 4.0 通道技术一起使用。 默认为 <c>no</c>。  
  
 <c>directories</c>：窗口是否应显示目录导航按钮。 默认为 <c>yes</c>。  
  
 <c>height</c>：窗口工作区的高度（以像素为单位）。 最小为 100 个像素；尝试打开小于此标准的窗口时，将根据 Internet Explorer 默认设置打开窗口。  
  
 <c>left</c>：窗口的左边（x 坐标）位置（以像素为单位），相对于用户屏幕的左上角。 必须是一个正整数。  
  
 <c>location</c>：是否显示地址栏，它可以使用户将窗口导航到新的 URL。 默认为 <c>yes</c>。  
  
 <c>menubar</c>：是否在新窗口上显示菜单。 默认为 <c>yes</c>。  
  
 <c>resizable</c>：用户是否可以调整窗口的大小。 默认为 <c>yes</c>。  
  
 <c>scrollbars</c>：窗口是否具有水平滚动条和垂直滚动条。 默认为 <c>yes</c>。  
  
 <c>status</c>：窗口底部是否具有状态栏。 默认为 <c>yes</c>。  
  
 <c>titlebar</c>：是否显示当前页的标题。 将此选项设置为 <c>no</c> 在托管应用程序内无效；始终都会显示标题栏。  
  
 <c>toolbar</c>：工具栏按钮（例如“后退”、“前进”和“停止”）是否可见。 默认为 <c>yes</c>。  
  
 <c>top</c>：窗口的上端（y 坐标）位置（以像素为单位），相对于用户屏幕的左上角。 必须是一个正整数。  
  
 <c>width</c>：窗口工作区的宽度（以像素为单位）。 最小为 100 个像素；尝试打开小于此标准的窗口时，将根据 Internet Explorer 默认设置打开窗口。</param>
        <param name="replaceEntry">
          <c>url</c> 是否替换导航历史记录中当前窗口的 URL。 这将对 <see cref="T:System.Windows.Forms.HtmlHistory" /> 类的方法的操作产生影响。</param>
        <summary>在已命名的窗口中显示文件。</summary>
        <returns>表示新窗口的 <see cref="T:System.Windows.Forms.HtmlWindow" />，或者是以前创建的、由 <paramref name="target" /> 参数命名的窗口。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `target`参数可以名称创建的以前调用的结果为一个窗口<xref:System.Windows.Forms.HtmlWindow.Open%2A>。 参数也可以指向通过单击超链接打开的窗口 (`A`元素) 或`FORM`用元素`TARGET`特性在新窗口中打开其 URL。 以下 HTML 代码将打开一个名为的新窗口`orderWindow`当用户单击它：  
  
 `<A HREF="/startOrder.aspx" TARGET="orderWindow">Click to Start Order</a>`  
  
 如果提供的任何选项`windowOptions`参数，不包含任何选项会自动禁用。 换而言之，如果您仅通过指定`windowOptions`要包含状态栏中，则菜单栏、 工具栏、 标题、 滚动条等将不会显示除非你显式启用它们通过`windowOptions`。  
  
 如果引用的文件`url`是某一 HTML 文件、 文本文件或其他可以在 Internet Explorer 内承载的文件类型它将在已命名的窗口中显示。 如果不能在 Internet Explorer 内显示的文件和名为的目标窗口不存在，则窗口将打开仅足够长的时间 Internet Explorer 下载资源;它将立即关闭之后。  
  
 当你创建新的 windows 使用<xref:System.Windows.Forms.HtmlWindow.Open%2A>或<xref:System.Windows.Forms.HtmlWindow.OpenNew%2A>，它将导致 HTML 文档对象模型，以便打开 Internet Explorer 的新实例。 如果不调用<xref:System.Windows.Forms.HtmlWindow.Close%2A>上所有已创建的 windows，Internet Explorer 的此实例将保持运行状态即使你的应用程序已退出。  
  
 如果你使用<xref:System.Windows.Forms.HtmlWindow.Open%2A>加载在现有窗口中，URL`windowOptions`将被忽略; 维度、 外观和屏幕位置首先由首次调用都将保留窗口<xref:System.Windows.Forms.HtmlWindow.Open%2A>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Open">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.HtmlWindow Open (Uri url, string target, string windowOptions, bool replaceEntry);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Forms.HtmlWindow Open(class System.Uri url, string target, string windowOptions, bool replaceEntry) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlWindow.Open(System.Uri,System.String,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function Open (url As Uri, target As String, windowOptions As String, replaceEntry As Boolean) As HtmlWindow" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Forms::HtmlWindow ^ Open(Uri ^ url, System::String ^ target, System::String ^ windowOptions, bool replaceEntry);" />
      <MemberSignature Language="F#" Value="member this.Open : Uri * string * string * bool -&gt; System.Windows.Forms.HtmlWindow" Usage="htmlWindow.Open (url, target, windowOptions, replaceEntry)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlWindow</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="url" Type="System.Uri" />
        <Parameter Name="target" Type="System.String" />
        <Parameter Name="windowOptions" Type="System.String" />
        <Parameter Name="replaceEntry" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="url">描述要加载的文件位置的统一资源定位器。</param>
        <param name="target">要在其中打开资源的窗口的名称。 它可以是开发人员提供的名称或者下列特殊值之一：<c>_blank</c>：在新窗口中打开 <c>url</c>。 与调用 <see cref="M:System.Windows.Forms.HtmlWindow.OpenNew(System.String,System.String)" /> 作用相同。  
  
 <c>_media</c>在“媒体”栏中打开 <c>url</c>。  
  
 <c>_parent</c>在创建当前窗口的窗口中打开 <c>url</c>。  
  
 <c>_search</c>在“搜索”栏中打开 <c>url</c>。  
  
 <c>_self</c>在当前窗口中打开 <c>url</c>。  
  
 <c>_top</c>：如果在属于 <c>FRAME</c> 元素的窗口上调用，则在承载其 <c>FRAMESET</c> 的窗口中打开 <c>url</c>。 否则，与 <c>_self</c> 的作用相同。</param>
        <param name="windowOptions">一个逗号分隔的字符串，由以下零个或多个以 <c>name=value</c> 形式表现的选项组成。 除了采用随机整数的 <c>left</c>、<c>top</c>、<c>height</c> 和 <c>width</c> 选项，每个选项接受 <c>yes</c> 或 <see langword="1" /> 以及 <c>no</c> 或 <see langword="0" /> 作为有效值。  
  
 <c>channelmode</c>：与被否决的 Internet Explorer 4.0 通道技术一起使用。 默认为 <c>no</c>。  
  
 <c>directories</c>：窗口是否应显示目录导航按钮。 默认为 <c>yes</c>。  
  
 <c>height</c>：窗口工作区的高度（以像素为单位）。 最小为 100 个像素；尝试打开小于此标准的窗口时，将根据 Internet Explorer 默认设置打开窗口。  
  
 <c>left</c>：窗口的左边（x 坐标）位置（以像素为单位），相对于用户屏幕的左上角。 必须是一个正整数。  
  
 <c>location</c>：是否显示地址栏，它可以使用户将窗口导航到新的 URL。 默认为 <c>yes</c>。  
  
 <c>menubar</c>：是否在新窗口上显示菜单。 默认为 <c>yes</c>。  
  
 <c>resizable</c>：用户是否可以调整窗口的大小。 默认为 <c>yes</c>。  
  
 <c>scrollbars</c>：窗口是否具有水平滚动条和垂直滚动条。 默认为 <c>yes</c>。  
  
 <c>status</c>：窗口底部是否具有状态栏。 默认为 <c>yes</c>。  
  
 <c>titlebar</c>：是否显示当前页的标题。 将此选项设置为 <c>no</c> 在托管应用程序内无效；始终都会显示标题栏。  
  
 <c>toolbar</c>：工具栏按钮（例如“后退”、“前进”和“停止”）是否可见。 默认为 <c>yes</c>。  
  
 <c>top</c>：窗口的上端（y 坐标）位置（以像素为单位），相对于用户屏幕的左上角。 必须是一个正整数。  
  
 <c>width</c>：窗口工作区的宽度（以像素为单位）。 最小为 100 个像素；尝试打开小于此标准的窗口时，将根据 Internet Explorer 默认设置打开窗口。</param>
        <param name="replaceEntry">
          <c>url</c> 是否替换导航历史记录中当前窗口的 URL。 这将对 <see cref="T:System.Windows.Forms.HtmlHistory" /> 类的方法的操作产生影响。</param>
        <summary>在已命名的窗口中显示文件。</summary>
        <returns>表示新窗口的 <see cref="T:System.Windows.Forms.HtmlWindow" />，或者是以前创建的、由 <paramref name="target" /> 参数命名的窗口。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `target`参数可以名称创建的以前调用的结果为一个窗口<xref:System.Windows.Forms.HtmlWindow.Open%2A>。 参数也可以指向通过单击超链接打开的窗口 (`A`元素) 或`FORM`用元素`TARGET`特性在新窗口中打开其 URL。 以下 HTML 代码将打开一个名为的新窗口`orderWindow`当用户单击它：  
  
 `<A HREF="/startOrder.aspx" TARGET="orderWindow">Click to Start Order</a>`  
  
 如果提供的任何选项`windowOptions`参数，不包含任何选项会自动禁用。 换而言之，如果您仅通过指定`windowOptions`要包含状态栏中，则菜单栏、 工具栏、 标题、 滚动条等将不会显示除非你显式启用它们通过`windowOptions`。  
  
 如果引用的文件`url`是某一 HTML 文件、 文本文件或其他可以在 Internet Explorer 内承载的文件类型它将在已命名的窗口中显示。 如果不能在 Internet Explorer 内显示的文件和名为的目标窗口不存在，则窗口将打开仅足够长的时间 Internet Explorer 下载资源;它将立即关闭之后。  
  
 当你创建新的 windows 使用<xref:System.Windows.Forms.HtmlWindow.Open%2A>或<xref:System.Windows.Forms.HtmlWindow.OpenNew%2A>，它将导致 HTML 文档对象模型，以便打开 Internet Explorer 的新实例。 如果不调用<xref:System.Windows.Forms.HtmlWindow.Close%2A>上所有已创建的 windows，Internet Explorer 的此实例将保持运行状态即使你的应用程序已退出。  
  
 如果你使用<xref:System.Windows.Forms.HtmlWindow.Open%2A>加载在现有窗口中，URL`windowOptions`将被忽略; 维度、 外观和屏幕位置首先由首次调用都将保留窗口<xref:System.Windows.Forms.HtmlWindow.Open%2A>。  
  
   
  
## Examples  
 下面的代码示例包含两个方法：  
  
-   第一个将在名为的窗口中打开 URL `displayWindow`，这便会创建的状态栏显示。  
  
-   第二个在相同的窗口中，打开另一个 URL，但指定应显示仅位置栏。  
  
 请注意窗口和显示控件的维度取决于在其上第一次打开 URL。 该代码示例要求你的窗体包含<xref:System.Windows.Forms.WebBrowser>控件名为`WebBrowser1`。  
  
 [!code-csharp[System.Windows.Forms.HtmlWindow#13](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HtmlWindow/CS/Form1.cs#13)]
 [!code-vb[System.Windows.Forms.HtmlWindow#13](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.HtmlWindow/VB/Form1.vb#13)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Opener">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.HtmlWindow Opener { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.HtmlWindow Opener" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlWindow.Opener" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Opener As HtmlWindow" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::HtmlWindow ^ Opener { System::Windows::Forms::HtmlWindow ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Opener : System.Windows.Forms.HtmlWindow" Usage="System.Windows.Forms.HtmlWindow.Opener" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlWindow</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取对打开当前窗口的窗口的引用。</summary>
        <value>
          <see cref="T:System.Windows.Forms.HtmlWindow" />，它通过调用 <see cref="M:System.Windows.Forms.HtmlWindow.Open(System.String,System.String,System.String,System.Boolean)" /> 或 <see cref="M:System.Windows.Forms.HtmlWindow.OpenNew(System.String,System.String)" /> 方法创建。 如果该窗口不是使用这些方法之一创建的，此属性将返回 <see langword="null" />。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="OpenNew">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>在新窗口中显示文件。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OpenNew">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.HtmlWindow OpenNew (string urlString, string windowOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Forms.HtmlWindow OpenNew(string urlString, string windowOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlWindow.OpenNew(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function OpenNew (urlString As String, windowOptions As String) As HtmlWindow" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Forms::HtmlWindow ^ OpenNew(System::String ^ urlString, System::String ^ windowOptions);" />
      <MemberSignature Language="F#" Value="member this.OpenNew : string * string -&gt; System.Windows.Forms.HtmlWindow" Usage="htmlWindow.OpenNew (urlString, windowOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlWindow</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="urlString" Type="System.String" />
        <Parameter Name="windowOptions" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="urlString">描述要加载的文件位置的统一资源定位器。</param>
        <param name="windowOptions">一个逗号分隔的字符串，由以下零个或多个以 <c>name=value</c> 形式表现的选项组成。 有关有效选项的完整描述，请参见 <see cref="M:System.Windows.Forms.HtmlWindow.Open(System.String,System.String,System.String,System.Boolean)" />。</param>
        <summary>在新窗口中显示文件。</summary>
        <returns>表示新窗口的 <see cref="T:System.Windows.Forms.HtmlWindow" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果引用的文件`url`是某一 HTML 文件、 文本文件或其他可以在 Internet Explorer 内承载的文件类型将在新窗口中显示。 如果文件不显示在 Internet Explorer 内，则将会打开窗口仅足够长的时间 Internet Explorer 下载资源;它将立即关闭之后。  
  
 当你创建新的 windows 使用<xref:System.Windows.Forms.HtmlWindow.Open%2A>或<xref:System.Windows.Forms.HtmlWindow.OpenNew%2A>，它将导致 HTML 文档对象模型，以便打开 Internet Explorer 的新实例。 如果不调用<xref:System.Windows.Forms.HtmlWindow.Close%2A>上所有已创建的 windows，Internet Explorer 的此实例将保持运行状态即使你的应用程序已退出。  
  
 如果你想要将文档加载到先前打开的窗口，请参阅<xref:System.Windows.Forms.HtmlWindow.Open%2A>方法。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OpenNew">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.HtmlWindow OpenNew (Uri url, string windowOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Forms.HtmlWindow OpenNew(class System.Uri url, string windowOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlWindow.OpenNew(System.Uri,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function OpenNew (url As Uri, windowOptions As String) As HtmlWindow" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Forms::HtmlWindow ^ OpenNew(Uri ^ url, System::String ^ windowOptions);" />
      <MemberSignature Language="F#" Value="member this.OpenNew : Uri * string -&gt; System.Windows.Forms.HtmlWindow" Usage="htmlWindow.OpenNew (url, windowOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlWindow</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="url" Type="System.Uri" />
        <Parameter Name="windowOptions" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="url">描述要加载的文件位置的统一资源定位器。</param>
        <param name="windowOptions">一个逗号分隔的字符串，由以下零个或多个以 <c>name=value</c> 形式表现的选项组成。 有关有效选项的完整描述，请参见 <see cref="M:System.Windows.Forms.HtmlWindow.Open(System.String,System.String,System.String,System.Boolean)" />。</param>
        <summary>在新窗口中显示文件。</summary>
        <returns>表示新窗口的 <see cref="T:System.Windows.Forms.HtmlWindow" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果引用的文件`url`是某一 HTML 文件、 文本文件或其他可以在 Internet Explorer 内承载的文件类型将在新窗口中显示。 如果文件不显示在 Internet Explorer 内，则将会打开窗口仅足够长的时间 Internet Explorer 下载资源;它将立即关闭之后。  
  
 当你创建新的 windows 使用<xref:System.Windows.Forms.HtmlWindow.Open%2A>或<xref:System.Windows.Forms.HtmlWindow.OpenNew%2A>，它将导致 HTML 文档对象模型，以便打开 Internet Explorer 的新实例。 如果不调用<xref:System.Windows.Forms.HtmlWindow.Close%2A>上所有已创建的 windows，Internet Explorer 的此实例将保持运行状态即使你的应用程序已退出。  
  
 如果你想要将文档加载到先前打开的窗口，请参阅<xref:System.Windows.Forms.HtmlWindow.Open%2A>方法。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Parent">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.HtmlWindow Parent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.HtmlWindow Parent" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlWindow.Parent" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Parent As HtmlWindow" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::HtmlWindow ^ Parent { System::Windows::Forms::HtmlWindow ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Parent : System.Windows.Forms.HtmlWindow" Usage="System.Windows.Forms.HtmlWindow.Parent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlWindow</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取驻留在包含框架的页中当前窗口上面的窗口。</summary>
        <value>拥有当前窗口的 <see cref="T:System.Windows.Forms.HtmlWindow" />。 如果当前窗口不<c>帧</c>，或者没有嵌入内<c>帧</c>，它将返回<see langword="null" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 文档中包含的帧，每个`FRAME`内`FRAMESET`充当页上的单独的子窗口。 每个父`FRAME`是`FRAMESET`其中包含`FRAME`。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Position">
      <MemberSignature Language="C#" Value="public System.Drawing.Point Position { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Point Position" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlWindow.Position" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Position As Point" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::Point Position { System::Drawing::Point get(); };" />
      <MemberSignature Language="F#" Value="member this.Position : System.Drawing.Point" Usage="System.Windows.Forms.HtmlWindow.Position" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Point</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取屏幕上窗口工作区的位置。</summary>
        <value>
          <see cref="T:System.Drawing.Point" />，描述屏幕左上角的 x 和 y 坐标（以像素为单位）。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Control.Location%2A>属性<xref:System.Windows.Forms.WebBrowser>控件将返回相对于窗口左上角的窗体控件的位置。 与此相反，<xref:System.Windows.Forms.HtmlWindow.Position%2A>将返回相对于用户的监视器的左上角的文档的显示区域的位置。  
  
   
  
## Examples  
 下面的代码示例打开一个新窗口直接通过<xref:System.Windows.Forms.WebBrowser>窗体上的控件。 该代码示例要求你的窗体包含的实例<xref:System.Windows.Forms.WebBrowser>控件名为`WebBrowser1`。  
  
 [!code-csharp[System.Windows.Forms.HtmlWindow#5](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HtmlWindow/CS/Form1.cs#5)]
 [!code-vb[System.Windows.Forms.HtmlWindow#5](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.HtmlWindow/VB/Form1.vb#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Prompt">
      <MemberSignature Language="C#" Value="public string Prompt (string message, string defaultInputValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Prompt(string message, string defaultInputValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlWindow.Prompt(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Prompt (message As String, defaultInputValue As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Prompt(System::String ^ message, System::String ^ defaultInputValue);" />
      <MemberSignature Language="F#" Value="member this.Prompt : string * string -&gt; string" Usage="htmlWindow.Prompt (message, defaultInputValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
        <Parameter Name="defaultInputValue" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="message">要显示给用户的消息。</param>
        <param name="defaultInputValue">文本框中显示的默认值。</param>
        <summary>显示一个对话框，该对话框向用户显示一条消息和一个文本框。</summary>
        <returns>
          <see cref="T:System.String" />，表示用户输入的文本。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.HtmlWindow.Prompt%2A> 提供一种快速、 简单的方法，以获得用户的简单文本输入。  
  
 尽管<xref:System.Windows.Forms.HtmlWindow.Prompt%2A>接受 Unicode 文本作为输入，Internet Explorer 脚本提示符上将不显示非拉丁语言文本适当 Windows 95、 Windows 98、 Windows ME 或 Windows NT 由于操作系统限制。 有关详细信息，请参阅[信息： Internet Explorer 脚本将提示和 MBCS/Unicode](http://support.microsoft.com/default.aspx?scid=kb;en-us;211147)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveFocus">
      <MemberSignature Language="C#" Value="public void RemoveFocus ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RemoveFocus() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlWindow.RemoveFocus" />
      <MemberSignature Language="VB.NET" Value="Public Sub RemoveFocus ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RemoveFocus();" />
      <MemberSignature Language="F#" Value="member this.RemoveFocus : unit -&gt; unit" Usage="htmlWindow.RemoveFocus " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>将焦点从当前窗口上移走。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在调用`FRAME`中的窗口`FRAMESET`，<xref:System.Windows.Forms.HtmlWindow.RemoveFocus%2A>将导致该窗口来失去焦点，但它不会自动设置焦点在另一个窗口上。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Resize">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.HtmlElementEventHandler Resize;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.HtmlElementEventHandler Resize" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.HtmlWindow.Resize" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Resize As HtmlElementEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::HtmlElementEventHandler ^ Resize;" />
      <MemberSignature Language="F#" Value="member this.Resize : System.Windows.Forms.HtmlElementEventHandler " Usage="member this.Resize : System.Windows.Forms.HtmlElementEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElementEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当用户使用鼠标更改窗口的尺寸时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下面的代码示例演示如何使用此成员。 在示例中，事件处理程序报告的匹配项<xref:System.Windows.Forms.HtmlWindow.Resize>事件。 此报告可帮助您了解当发生事件，并可以帮助您进行调试。 若要报告或频繁发生的事件上多个事件，请考虑替换<xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType>与<xref:System.Console.WriteLine%2A?displayProperty=nameWithType>或追加到一个多行消息<xref:System.Windows.Forms.TextBox>。  
  
 若要运行此代码示例，请将其粘贴到包含类型的实例的项目<xref:System.Windows.Forms.HtmlWindow>名为`HtmlWindow1`。 然后，确保与事件处理程序<xref:System.Windows.Forms.HtmlWindow.Resize>事件。  
  
 [!code-csharp[System.Windows.Forms.EventExamples#455](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#455)]
 [!code-vb[System.Windows.Forms.EventExamples#455](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#455)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ResizeTo">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>将窗口的大小更改为指定的尺寸。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ResizeTo">
      <MemberSignature Language="C#" Value="public void ResizeTo (System.Drawing.Size size);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ResizeTo(valuetype System.Drawing.Size size) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlWindow.ResizeTo(System.Drawing.Size)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ResizeTo(System::Drawing::Size size);" />
      <MemberSignature Language="F#" Value="member this.ResizeTo : System.Drawing.Size -&gt; unit" Usage="htmlWindow.ResizeTo size" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="size" Type="System.Drawing.Size" />
      </Parameters>
      <Docs>
        <param name="size">
          <see cref="T:System.Drawing.Size" />，描述窗口所需的宽度和高度（以像素为单位）。 宽度和高度都必须大于等于 100 个像素。</param>
        <summary>将窗口的大小更改为指定的尺寸。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下面的代码示例将打开一个新窗口，并调整其大小以填充可用的屏幕区域。  
  
 [!code-csharp[System.Windows.Forms.HtmlWindow#15](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HtmlWindow/CS/Form1.cs#15)]
 [!code-vb[System.Windows.Forms.HtmlWindow#15](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.HtmlWindow/VB/Form1.vb#15)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">尝试调整大小的窗口与其父窗口在不同的域中。 此限制是跨框架脚本安全的一部分；有关详细信息，请参阅 [About Cross-Frame Scripting and Security](http://msdn.microsoft.com/library/ms533028.aspx)（关于跨框架脚本编写和安全性）。</exception>
      </Docs>
    </Member>
    <Member MemberName="ResizeTo">
      <MemberSignature Language="C#" Value="public void ResizeTo (int width, int height);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ResizeTo(int32 width, int32 height) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlWindow.ResizeTo(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ResizeTo (width As Integer, height As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ResizeTo(int width, int height);" />
      <MemberSignature Language="F#" Value="member this.ResizeTo : int * int -&gt; unit" Usage="htmlWindow.ResizeTo (width, height)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="width" Type="System.Int32" />
        <Parameter Name="height" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="width">描述窗口所需的宽度（以像素为单位）。 必须大于等于 100 个像素。</param>
        <param name="height">描述窗口所需的高度（以像素为单位）。 必须大于等于 100 个像素。</param>
        <summary>将窗口的大小更改为指定的尺寸。</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.UnauthorizedAccessException">尝试调整大小的窗口与其父窗口在不同的域中。 此限制是跨框架脚本安全的一部分；有关详细信息，请参阅 [About Cross-Frame Scripting and Security](http://msdn.microsoft.com/library/ms533028.aspx)（关于跨框架脚本编写和安全性）。</exception>
      </Docs>
    </Member>
    <Member MemberName="Scroll">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.HtmlElementEventHandler Scroll;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.HtmlElementEventHandler Scroll" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.HtmlWindow.Scroll" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Scroll As HtmlElementEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::HtmlElementEventHandler ^ Scroll;" />
      <MemberSignature Language="F#" Value="member this.Scroll : System.Windows.Forms.HtmlElementEventHandler " Usage="member this.Scroll : System.Windows.Forms.HtmlElementEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElementEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当用户滚动窗口以查看屏幕外的文本时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下面的代码示例演示如何使用此成员。 在示例中，事件处理程序报告的匹配项<xref:System.Windows.Forms.HtmlWindow.Scroll>事件。 此报告可帮助您了解当发生事件，并可以帮助您进行调试。 若要报告或频繁发生的事件上多个事件，请考虑替换<xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType>与<xref:System.Console.WriteLine%2A?displayProperty=nameWithType>或追加到一个多行消息<xref:System.Windows.Forms.TextBox>。  
  
 若要运行此代码示例，请将其粘贴到包含类型的实例的项目<xref:System.Windows.Forms.HtmlWindow>名为`HtmlWindow1`。 然后，确保与事件处理程序<xref:System.Windows.Forms.HtmlWindow.Scroll>事件。  
  
 [!code-csharp[System.Windows.Forms.EventExamples#456](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#456)]
 [!code-vb[System.Windows.Forms.EventExamples#456](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#456)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ScrollTo">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>将窗口滚动到指定的位置。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ScrollTo">
      <MemberSignature Language="C#" Value="public void ScrollTo (System.Drawing.Point point);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ScrollTo(valuetype System.Drawing.Point point) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlWindow.ScrollTo(System.Drawing.Point)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ScrollTo(System::Drawing::Point point);" />
      <MemberSignature Language="F#" Value="member this.ScrollTo : System.Drawing.Point -&gt; unit" Usage="htmlWindow.ScrollTo point" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="point" Type="System.Drawing.Point" />
      </Parameters>
      <Docs>
        <param name="point">页面应该滚动到的 x 和 y 坐标，相对于当前窗口的左上角。</param>
        <summary>将窗口移动到指定的坐标。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.HtmlWindow.ScrollTo%2A> 将导致要向下滚动，以便在文档上的指定的坐标位于文档的窗口的左上角的文档。 如果该文档不是长或不够宽，这种情况，<xref:System.Windows.Forms.HtmlWindow.ScrollTo%2A>将按指定的方向尽可能文档中滚动。  
  
   
  
## Examples  
 下面的代码示例滚动到用户单击的坐标位置的文档。  
  
 [!code-csharp[System.Windows.Forms.HtmlWindow#15](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HtmlWindow/CS/Form1.cs#15)]
 [!code-vb[System.Windows.Forms.HtmlWindow#15](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.HtmlWindow/VB/Form1.vb#15)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ScrollTo">
      <MemberSignature Language="C#" Value="public void ScrollTo (int x, int y);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ScrollTo(int32 x, int32 y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlWindow.ScrollTo(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ScrollTo (x As Integer, y As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ScrollTo(int x, int y);" />
      <MemberSignature Language="F#" Value="member this.ScrollTo : int * int -&gt; unit" Usage="htmlWindow.ScrollTo (x, y)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Int32" />
        <Parameter Name="y" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="x">页面应该滚动到的 x 坐标，相对于当前窗口的左上角。</param>
        <param name="y">页面应该滚动到的 y 坐标，相对于当前窗口的左上角。</param>
        <summary>将窗口滚动到指定的位置。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.HtmlWindow.ScrollTo%2A> 将导致要向下滚动，以便在文档上的指定的坐标位于文档的窗口的左上角的文档。 如果该文档不是长或不够宽，这种情况，<xref:System.Windows.Forms.HtmlWindow.ScrollTo%2A>将按指定的方向尽可能文档中滚动。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Size">
      <MemberSignature Language="C#" Value="public System.Drawing.Size Size { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Size Size" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlWindow.Size" />
      <MemberSignature Language="VB.NET" Value="Public Property Size As Size" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::Size Size { System::Drawing::Size get(); void set(System::Drawing::Size value); };" />
      <MemberSignature Language="F#" Value="member this.Size : System.Drawing.Size with get, set" Usage="System.Windows.Forms.HtmlWindow.Size" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Size</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置当前窗口的大小。</summary>
        <value>
          <see cref="T:System.Drawing.Size" />，描述窗口的大小（以像素为单位）。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="StatusBarText">
      <MemberSignature Language="C#" Value="public string StatusBarText { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string StatusBarText" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlWindow.StatusBarText" />
      <MemberSignature Language="VB.NET" Value="Public Property StatusBarText As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ StatusBarText { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.StatusBarText : string with get, set" Usage="System.Windows.Forms.HtmlWindow.StatusBarText" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置在窗口的状态栏中显示的文本。</summary>
        <value>
          <see cref="T:System.String" />，它包含当前状态文本。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.WebBrowser>控件不显示状态栏。 使用打开任何新窗口<xref:System.Windows.Forms.HtmlWindow.Open%2A>或<xref:System.Windows.Forms.HtmlWindow.OpenNew%2A>方法，但是，默认会显示状态栏。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Unload">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.HtmlElementEventHandler Unload;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.HtmlElementEventHandler Unload" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.HtmlWindow.Unload" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Unload As HtmlElementEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::HtmlElementEventHandler ^ Unload;" />
      <MemberSignature Language="F#" Value="member this.Unload : System.Windows.Forms.HtmlElementEventHandler " Usage="member this.Unload : System.Windows.Forms.HtmlElementEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElementEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当正在卸载当前页，而一个新页即将显示时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下面的代码示例演示如何使用此成员。 在示例中，事件处理程序报告的匹配项<xref:System.Windows.Forms.HtmlWindow.Unload>事件。 此报告可帮助您了解当发生事件，并可以帮助您进行调试。 若要报告或频繁发生的事件上多个事件，请考虑替换<xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType>与<xref:System.Console.WriteLine%2A?displayProperty=nameWithType>或追加到一个多行消息<xref:System.Windows.Forms.TextBox>。  
  
 若要运行此代码示例，请将其粘贴到包含类型的实例的项目<xref:System.Windows.Forms.HtmlWindow>名为`HtmlWindow1`。 然后，确保与事件处理程序<xref:System.Windows.Forms.HtmlWindow.Unload>事件。  
  
 [!code-csharp[System.Windows.Forms.EventExamples#457](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#457)]
 [!code-vb[System.Windows.Forms.EventExamples#457](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#457)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Url">
      <MemberSignature Language="C#" Value="public Uri Url { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Uri Url" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlWindow.Url" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Url As Uri" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Uri ^ Url { Uri ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Url : Uri" Usage="System.Windows.Forms.HtmlWindow.Url" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Uri</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取对应于窗口中显示的当前项的 URL。</summary>
        <value>描述 URL 的 <see cref="T:System.Uri" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此属性是只读的。 若要导航到新文档窗口，请使用<xref:System.Windows.Forms.HtmlWindow.Navigate%2A>方法。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WindowFrameElement">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.HtmlElement WindowFrameElement { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.HtmlElement WindowFrameElement" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlWindow.WindowFrameElement" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property WindowFrameElement As HtmlElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::HtmlElement ^ WindowFrameElement { System::Windows::Forms::HtmlElement ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.WindowFrameElement : System.Windows.Forms.HtmlElement" Usage="System.Windows.Forms.HtmlWindow.WindowFrameElement" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElement</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取对应于此窗口的框架元素。</summary>
        <value>
          <see cref="T:System.Windows.Forms.HtmlElement" />对应于此窗口<c>帧</c>元素。 如果此窗口不是框架，它将返回 <see langword="null" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当检索`FRAME`元素从<xref:System.Windows.Forms.HtmlWindow.Frames%2A>集合，它返回<xref:System.Windows.Forms.HtmlWindow>。 调用<xref:System.Windows.Forms.HtmlWindow.WindowFrameElement%2A>对此对象，如果你需要访问的基础属性`FRAME`元素，如`SRC`属性。  
  
   
  
## Examples  
 下面的代码示例进行比较`SRC`属性中的帧`FRAMESET`与当前的位置。 如果它们不同，帧重置为其原始 Url。  
  
 [!code-csharp[System.Windows.Forms.HtmlWindow#8](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HtmlWindow/CS/Form1.cs#8)]
 [!code-vb[System.Windows.Forms.HtmlWindow#8](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.HtmlWindow/VB/Form1.vb#8)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.UnauthorizedAccessException">无法访问<c>帧</c>元素或<c>帧</c>的文档如果<c>帧</c>位于不同区域比<c>框架集</c>，其中包含它。 有关完整说明，请参阅 [跨框架脚本有关和安全] (http://msdn.microsoft.com/library/ms533028.aspx)。</permission>
      </Docs>
    </Member>
  </Members>
</Type>