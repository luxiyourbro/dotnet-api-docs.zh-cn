<Type Name="ContainerVisual" FullName="System.Windows.Media.ContainerVisual">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="7d6c2b9abc476a467fcf97c44a15588852de8ed1" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-CN" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36469518" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class ContainerVisual : System.Windows.Media.Visual" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit ContainerVisual extends System.Windows.Media.Visual" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Media.ContainerVisual" />
  <TypeSignature Language="VB.NET" Value="Public Class ContainerVisual&#xA;Inherits Visual" />
  <TypeSignature Language="C++ CLI" Value="public ref class ContainerVisual : System::Windows::Media::Visual" />
  <TypeSignature Language="F#" Value="type ContainerVisual = class&#xA;    inherit Visual" />
  <AssemblyInfo>
    <AssemblyName>PresentationCore</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.Media.Visual</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>管理 <see cref="T:System.Windows.Media.Visual" /> 对象集合。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Media.ContainerVisual>类用作的集合的容器<xref:System.Windows.Media.Visual>对象。 <xref:System.Windows.Media.DrawingVisual>类派生自<xref:System.Windows.Media.ContainerVisual>类，以便<xref:System.Windows.Media.DrawingVisual>类也可以包含的视觉对象的集合。  
  
   
  
## Examples  
 下面的示例演示如何创建<xref:System.Windows.Media.ContainerVisual>用作两个父对象<xref:System.Windows.Media.DrawingVisual>对象。 添加到对象<xref:System.Windows.Media.ContainerVisual>对象必须添加相反的 z 顺序 （从底部到顶部），以确保它们呈现在正确的绘制顺序。 为了使可视化树中正确枚举，该示例提供的重写的实现<xref:System.Windows.Media.ContainerVisual.GetVisualChild%2A>方法和<xref:System.Windows.Media.ContainerVisual.VisualChildrenCount%2A>属性。  
  
 [!code-csharp[ContainerVisualHost#ContainerVisualHost01](~/samples/snippets/csharp/VS_Snippets_Wpf/ContainerVisualHost/CSharp/Window1.xaml.cs#containervisualhost01)]
 [!code-vb[ContainerVisualHost#ContainerVisualHost01](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContainerVisualHost/visualbasic/window1.xaml.vb#containervisualhost01)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ContainerVisual ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.ContainerVisual.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ContainerVisual();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>创建 <see cref="T:System.Windows.Media.ContainerVisual" /> 类的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下面的示例演示如何创建的新实例<xref:System.Windows.Media.ContainerVisual>对象，并将子视觉对象添加到它。  
  
 [!code-csharp[ContainerVisualSnippets#ContainerVisualSnippet1](~/samples/snippets/csharp/VS_Snippets_Wpf/ContainerVisualSnippets/CSharp/Window1.xaml.cs#containervisualsnippet1)]
 [!code-vb[ContainerVisualSnippets#ContainerVisualSnippet1](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContainerVisualSnippets/visualbasic/window1.xaml.vb#containervisualsnippet1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BitmapEffect">
      <MemberSignature Language="C#" Value="public System.Windows.Media.Effects.BitmapEffect BitmapEffect { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Media.Effects.BitmapEffect BitmapEffect" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.ContainerVisual.BitmapEffect" />
      <MemberSignature Language="VB.NET" Value="Public Property BitmapEffect As BitmapEffect" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Media::Effects::BitmapEffect ^ BitmapEffect { System::Windows::Media::Effects::BitmapEffect ^ get(); void set(System::Windows::Media::Effects::BitmapEffect ^ value); };" />
      <MemberSignature Language="F#" Value="member this.BitmapEffect : System.Windows.Media.Effects.BitmapEffect with get, set" Usage="System.Windows.Media.ContainerVisual.BitmapEffect" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("BitmapEffects are deprecated and no longer function.  Consider using Effects where appropriate instead.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Effects.BitmapEffect</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置 <see cref="T:System.Windows.Media.Effects.BitmapEffect" /> 的 <see cref="T:System.Windows.Media.ContainerVisual" /> 值。</summary>
        <value>此可视对象的位图效果。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BitmapEffectInput">
      <MemberSignature Language="C#" Value="public System.Windows.Media.Effects.BitmapEffectInput BitmapEffectInput { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Media.Effects.BitmapEffectInput BitmapEffectInput" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.ContainerVisual.BitmapEffectInput" />
      <MemberSignature Language="VB.NET" Value="Public Property BitmapEffectInput As BitmapEffectInput" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Media::Effects::BitmapEffectInput ^ BitmapEffectInput { System::Windows::Media::Effects::BitmapEffectInput ^ get(); void set(System::Windows::Media::Effects::BitmapEffectInput ^ value); };" />
      <MemberSignature Language="F#" Value="member this.BitmapEffectInput : System.Windows.Media.Effects.BitmapEffectInput with get, set" Usage="System.Windows.Media.ContainerVisual.BitmapEffectInput" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("BitmapEffects are deprecated and no longer function.  Consider using Effects where appropriate instead.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Effects.BitmapEffectInput</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置 <see cref="T:System.Windows.Media.Effects.BitmapEffectInput" /> 的 <see cref="T:System.Windows.Media.ContainerVisual" /> 值。</summary>
        <value>此可视对象的位图效果输入值。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CacheMode">
      <MemberSignature Language="C#" Value="public System.Windows.Media.CacheMode CacheMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Media.CacheMode CacheMode" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.ContainerVisual.CacheMode" />
      <MemberSignature Language="VB.NET" Value="Public Property CacheMode As CacheMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Media::CacheMode ^ CacheMode { System::Windows::Media::CacheMode ^ get(); void set(System::Windows::Media::CacheMode ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CacheMode : System.Windows.Media.CacheMode with get, set" Usage="System.Windows.Media.ContainerVisual.CacheMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.CacheMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置 <see cref="T:System.Windows.Media.ContainerVisual" /> 的缓存表示形式。</summary>
        <value>
          <see cref="T:System.Windows.Media.CacheMode" />，用于容纳 <see cref="T:System.Windows.Media.ContainerVisual" /> 的缓存表示形式。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 设置<xref:System.Windows.Media.ContainerVisual.CacheMode%2A>属性时需要增加很长时间才能呈现的内容的性能。 有关详情，请参阅<xref:System.Windows.Media.BitmapCache>。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.UIElement.CacheMode" />
        <altmember cref="P:System.Windows.Media.Visual.VisualCacheMode" />
        <altmember cref="T:System.Windows.Media.BitmapCache" />
        <altmember cref="T:System.Windows.Media.BitmapCacheBrush" />
      </Docs>
    </Member>
    <Member MemberName="Children">
      <MemberSignature Language="C#" Value="public System.Windows.Media.VisualCollection Children { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Media.VisualCollection Children" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.ContainerVisual.Children" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Children As VisualCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Media::VisualCollection ^ Children { System::Windows::Media::VisualCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Children : System.Windows.Media.VisualCollection" Usage="System.Windows.Media.ContainerVisual.Children" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.VisualCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取 <see cref="T:System.Windows.Media.ContainerVisual" /> 的子集合。</summary>
        <value>一个 <see cref="T:System.Windows.Media.VisualCollection" />，包含 <see cref="T:System.Windows.Media.ContainerVisual" /> 的子对象。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下面的示例演示如何检索<xref:System.Windows.Media.VisualCollection>从<xref:System.Windows.Media.ContainerVisual>对象。  
  
 [!code-csharp[ContainerVisualSnippets#ContainerVisualSnippet3](~/samples/snippets/csharp/VS_Snippets_Wpf/ContainerVisualSnippets/CSharp/Window1.xaml.cs#containervisualsnippet3)]
 [!code-vb[ContainerVisualSnippets#ContainerVisualSnippet3](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContainerVisualSnippets/visualbasic/window1.xaml.vb#containervisualsnippet3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Clip">
      <MemberSignature Language="C#" Value="public System.Windows.Media.Geometry Clip { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Media.Geometry Clip" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.ContainerVisual.Clip" />
      <MemberSignature Language="VB.NET" Value="Public Property Clip As Geometry" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Media::Geometry ^ Clip { System::Windows::Media::Geometry ^ get(); void set(System::Windows::Media::Geometry ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Clip : System.Windows.Media.Geometry with get, set" Usage="System.Windows.Media.ContainerVisual.Clip" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Geometry</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置 <see cref="T:System.Windows.Media.ContainerVisual" /> 的剪辑区域。</summary>
        <value>用于定义剪辑区域的 <see cref="T:System.Windows.Media.Geometry" />。</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Windows.UIElement.Clip" />
      </Docs>
    </Member>
    <Member MemberName="ContentBounds">
      <MemberSignature Language="C#" Value="public System.Windows.Rect ContentBounds { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Rect ContentBounds" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.ContainerVisual.ContentBounds" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ContentBounds As Rect" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Rect ContentBounds { System::Windows::Rect get(); };" />
      <MemberSignature Language="F#" Value="member this.ContentBounds : System.Windows.Rect" Usage="System.Windows.Media.ContainerVisual.ContentBounds" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Rect</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取 <see cref="T:System.Windows.Media.ContainerVisual" /> 内容的边界框。</summary>
        <value>一个指定边界框的 <see cref="T:System.Windows.Rect" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用<xref:System.Windows.Media.ContainerVisual.DescendantBounds%2A>属性可返回的所有内容边界框的所有的后代中的联合<xref:System.Windows.Media.ContainerVisual>对象，而不是对象本身。  
  
   
  
## Examples  
 下面的示例演示如何检索的绑定矩形<xref:System.Windows.Media.ContainerVisual>对象。  
  
 [!code-csharp[ContainerVisualSnippets#ContainerVisualSnippet4](~/samples/snippets/csharp/VS_Snippets_Wpf/ContainerVisualSnippets/CSharp/Window1.xaml.cs#containervisualsnippet4)]
 [!code-vb[ContainerVisualSnippets#ContainerVisualSnippet4](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContainerVisualSnippets/visualbasic/window1.xaml.vb#containervisualsnippet4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DescendantBounds">
      <MemberSignature Language="C#" Value="public System.Windows.Rect DescendantBounds { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Rect DescendantBounds" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.ContainerVisual.DescendantBounds" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DescendantBounds As Rect" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Rect DescendantBounds { System::Windows::Rect get(); };" />
      <MemberSignature Language="F#" Value="member this.DescendantBounds : System.Windows.Rect" Usage="System.Windows.Media.ContainerVisual.DescendantBounds" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Rect</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取 <see cref="T:System.Windows.Media.ContainerVisual" /> 所有子代的所有内容边界框的联合，但不包括 <see cref="T:System.Windows.Media.ContainerVisual" /> 的内容。</summary>
        <value>一个指定组合边界框的 <see cref="T:System.Windows.Rect" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 获取<xref:System.Windows.Media.ContainerVisual.ContentBounds%2A>属性以返回有关缓存的边界框矩形<xref:System.Windows.Media.ContainerVisual>本身。  
  
   
  
## Examples  
 下面的示例演示如何检索的绑定矩形<xref:System.Windows.Media.ContainerVisual>对象的后代。  
  
 [!code-csharp[ContainerVisualSnippets#ContainerVisualSnippet4](~/samples/snippets/csharp/VS_Snippets_Wpf/ContainerVisualSnippets/CSharp/Window1.xaml.cs#containervisualsnippet4)]
 [!code-vb[ContainerVisualSnippets#ContainerVisualSnippet4](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContainerVisualSnippets/visualbasic/window1.xaml.vb#containervisualsnippet4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Effect">
      <MemberSignature Language="C#" Value="public System.Windows.Media.Effects.Effect Effect { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Media.Effects.Effect Effect" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.ContainerVisual.Effect" />
      <MemberSignature Language="VB.NET" Value="Public Property Effect As Effect" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Media::Effects::Effect ^ Effect { System::Windows::Media::Effects::Effect ^ get(); void set(System::Windows::Media::Effects::Effect ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Effect : System.Windows.Media.Effects.Effect with get, set" Usage="System.Windows.Media.ContainerVisual.Effect" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Effects.Effect</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置要应用于 <see cref="T:System.Windows.Media.ContainerVisual" /> 的位图效果。</summary>
        <value>一个表示位图效果的 <see cref="T:System.Windows.Media.Effects.Effect" />。</value>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.Windows.Media.Effects.Effect" />
        <altmember cref="T:System.Windows.Media.Effects.ShaderEffect" />
      </Docs>
    </Member>
    <Member MemberName="GetVisualChild">
      <MemberSignature Language="C#" Value="protected override sealed System.Windows.Media.Visual GetVisualChild (int index);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Windows.Media.Visual GetVisualChild(int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.ContainerVisual.GetVisualChild(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides NotOverridable Function GetVisualChild (index As Integer) As Visual" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Windows::Media::Visual ^ GetVisualChild(int index);" />
      <MemberSignature Language="F#" Value="override this.GetVisualChild : int -&gt; System.Windows.Media.Visual" Usage="containerVisual.GetVisualChild index" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Visual</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">一个 32 位带符号整数，表示子 <see cref="T:System.Windows.Media.Visual" /> 的索引值。 <c>index</c> 的值必须介于 0 和 <see cref="P:System.Windows.Media.ContainerVisual.VisualChildrenCount" /> - 1 之间。</param>
        <summary>返回父 <see cref="T:System.Windows.Media.Visual" /> 的指定子 <see cref="T:System.Windows.Media.ContainerVisual" />。</summary>
        <returns>子 <see cref="T:System.Windows.Media.Visual" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 默认情况下，<xref:System.Windows.Media.ContainerVisual>没有任何子级。  
  
   
  
## Examples  
 下面的示例演示如何创建<xref:System.Windows.Media.ContainerVisual>用作两个父对象<xref:System.Windows.Media.DrawingVisual>对象。 添加到对象<xref:System.Windows.Media.ContainerVisual>对象必须添加相反的 z 顺序 （从底部到顶部），以确保它们呈现在正确的绘制顺序。 为了使可视化树中正确枚举，该示例提供的重写的实现<xref:System.Windows.Media.ContainerVisual.GetVisualChild%2A>方法和<xref:System.Windows.Media.ContainerVisual.VisualChildrenCount%2A>属性。  
  
 [!code-csharp[ContainerVisualHost#ContainerVisualHost01](~/samples/snippets/csharp/VS_Snippets_Wpf/ContainerVisualHost/CSharp/Window1.xaml.cs#containervisualhost01)]
 [!code-vb[ContainerVisualHost#ContainerVisualHost01](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContainerVisualHost/visualbasic/window1.xaml.vb#containervisualhost01)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>此调用期间，无法修改的可视化树。</para>
        </block>
        <altmember cref="P:System.Windows.Media.ContainerVisual.VisualChildrenCount" />
      </Docs>
    </Member>
    <MemberGroup MemberName="HitTest">
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>返回命中测试的最顶端可视对象。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="HitTest">
      <MemberSignature Language="C#" Value="public System.Windows.Media.HitTestResult HitTest (System.Windows.Point point);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Media.HitTestResult HitTest(valuetype System.Windows.Point point) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.ContainerVisual.HitTest(System.Windows.Point)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Media::HitTestResult ^ HitTest(System::Windows::Point point);" />
      <MemberSignature Language="F#" Value="override this.HitTest : System.Windows.Point -&gt; System.Windows.Media.HitTestResult" Usage="containerVisual.HitTest point" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.HitTestResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="point" Type="System.Windows.Point" />
      </Parameters>
      <Docs>
        <param name="point">命中测试的点值。</param>
        <summary>通过指定 <see cref="T:System.Windows.Point" /> 返回命中测试最顶端的可视对象。</summary>
        <returns>以 <see cref="T:System.Windows.Media.HitTestResult" /> 类型返回的视觉效果的命中测试结果。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Media.HitTestResult.VisualHit%2A>属性的返回值表示<xref:System.Windows.Media.Visual>命中对象。  
  
   
  
## Examples  
 下面的示例演示如何检索<xref:System.Windows.Media.HitTestResult>返回值从<xref:System.Windows.Media.ContainerVisual.HitTest%2A>方法。  
  
 [!code-csharp[ContainerVisualSnippets#ContainerVisualSnippet2](~/samples/snippets/csharp/VS_Snippets_Wpf/ContainerVisualSnippets/CSharp/Window1.xaml.cs#containervisualsnippet2)]
 [!code-vb[ContainerVisualSnippets#ContainerVisualSnippet2](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContainerVisualSnippets/visualbasic/window1.xaml.vb#containervisualsnippet2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HitTest">
      <MemberSignature Language="C#" Value="public void HitTest (System.Windows.Media.HitTestFilterCallback filterCallback, System.Windows.Media.HitTestResultCallback resultCallback, System.Windows.Media.HitTestParameters hitTestParameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void HitTest(class System.Windows.Media.HitTestFilterCallback filterCallback, class System.Windows.Media.HitTestResultCallback resultCallback, class System.Windows.Media.HitTestParameters hitTestParameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.ContainerVisual.HitTest(System.Windows.Media.HitTestFilterCallback,System.Windows.Media.HitTestResultCallback,System.Windows.Media.HitTestParameters)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void HitTest(System::Windows::Media::HitTestFilterCallback ^ filterCallback, System::Windows::Media::HitTestResultCallback ^ resultCallback, System::Windows::Media::HitTestParameters ^ hitTestParameters);" />
      <MemberSignature Language="F#" Value="override this.HitTest : System.Windows.Media.HitTestFilterCallback * System.Windows.Media.HitTestResultCallback * System.Windows.Media.HitTestParameters -&gt; unit" Usage="containerVisual.HitTest (filterCallback, resultCallback, hitTestParameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filterCallback" Type="System.Windows.Media.HitTestFilterCallback" />
        <Parameter Name="resultCallback" Type="System.Windows.Media.HitTestResultCallback" />
        <Parameter Name="hitTestParameters" Type="System.Windows.Media.HitTestParameters" />
      </Parameters>
      <Docs>
        <param name="filterCallback">允许在处理命中测试结果时忽略无关的可视化树部分的委托。</param>
        <param name="resultCallback">用于控制返回命中测试信息的委托。</param>
        <param name="hitTestParameters">定义命中测试的参数集。</param>
        <summary>使用 <see cref="T:System.Windows.Media.HitTestFilterCallback" /> 和 <see cref="T:System.Windows.Media.HitTestResultCallback" /> 对象启动 <see cref="T:System.Windows.Media.ContainerVisual" /> 上的命中测试。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `filterCallback`参数可以为 null，在这种情况下，它将被忽略。 如果`filterCallback`不`null`之前, 调用`resultCallback`。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Offset">
      <MemberSignature Language="C#" Value="public System.Windows.Vector Offset { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Vector Offset" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.ContainerVisual.Offset" />
      <MemberSignature Language="VB.NET" Value="Public Property Offset As Vector" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Vector Offset { System::Windows::Vector get(); void set(System::Windows::Vector value); };" />
      <MemberSignature Language="F#" Value="member this.Offset : System.Windows.Vector with get, set" Usage="System.Windows.Media.ContainerVisual.Offset" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Vector</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置 <see cref="T:System.Windows.Media.ContainerVisual" /> 相对于其参考点的偏移值。</summary>
        <value>一个 <see cref="T:System.Windows.Vector" />，表示 <see cref="T:System.Windows.Media.ContainerVisual" /> 的偏移值。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Opacity">
      <MemberSignature Language="C#" Value="public double Opacity { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 Opacity" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.ContainerVisual.Opacity" />
      <MemberSignature Language="VB.NET" Value="Public Property Opacity As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double Opacity { double get(); void set(double value); };" />
      <MemberSignature Language="F#" Value="member this.Opacity : double with get, set" Usage="System.Windows.Media.ContainerVisual.Opacity" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置 <see cref="T:System.Windows.Media.ContainerVisual" /> 的不透明度（基于 0=透明，1=不透明）。</summary>
        <value>一个介于 0 到 1 之间的值，它指定从完全透明到完全不透明之间的一个范围。 如果值为 0，则指示 <see cref="T:System.Windows.Media.ContainerVisual" /> 完全透明；如果值为 1，则指示 <see cref="T:System.Windows.Media.ContainerVisual" /> 完全不透明。 值 0.5 指示不透明度为 50%，值 0.725 指示不透明度为 72.5%，依此类推。 小于 0 的值将被视为 0，而大于 1 的值将被视为 1。</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Windows.UIElement.Opacity" />
      </Docs>
    </Member>
    <Member MemberName="OpacityMask">
      <MemberSignature Language="C#" Value="public System.Windows.Media.Brush OpacityMask { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Media.Brush OpacityMask" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.ContainerVisual.OpacityMask" />
      <MemberSignature Language="VB.NET" Value="Public Property OpacityMask As Brush" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Media::Brush ^ OpacityMask { System::Windows::Media::Brush ^ get(); void set(System::Windows::Media::Brush ^ value); };" />
      <MemberSignature Language="F#" Value="member this.OpacityMask : System.Windows.Media.Brush with get, set" Usage="System.Windows.Media.ContainerVisual.OpacityMask" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Brush</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置指定 <see cref="T:System.Windows.Media.ContainerVisual" /> 可能的不透明蒙板的画笔。</summary>
        <value>一个类型为 <see cref="T:System.Windows.Media.Brush" /> 的值，表示 <see cref="T:System.Windows.Media.ContainerVisual" /> 的不透明蒙板值。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 不透明蒙板可用于创建等虚光照等画笔 alpha 通道值为基础的效果。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Parent">
      <MemberSignature Language="C#" Value="public System.Windows.DependencyObject Parent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.DependencyObject Parent" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.ContainerVisual.Parent" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Parent As DependencyObject" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::DependencyObject ^ Parent { System::Windows::DependencyObject ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Parent : System.Windows.DependencyObject" Usage="System.Windows.Media.ContainerVisual.Parent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取 <see cref="T:System.Windows.Media.Visual" /> 的父 <see cref="T:System.Windows.Media.ContainerVisual" />。</summary>
        <value>可见对象的父对象。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 请注意，这作为返回<xref:System.Windows.DependencyObject>，而不是原始对象。  
  
 此属性可能会返回`null`在断开连接的树中，或者已到树根，在窗口级别遍历。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Transform">
      <MemberSignature Language="C#" Value="public System.Windows.Media.Transform Transform { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Media.Transform Transform" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.ContainerVisual.Transform" />
      <MemberSignature Language="VB.NET" Value="Public Property Transform As Transform" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Media::Transform ^ Transform { System::Windows::Media::Transform ^ get(); void set(System::Windows::Media::Transform ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Transform : System.Windows.Media.Transform with get, set" Usage="System.Windows.Media.ContainerVisual.Transform" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Transform</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置应用于 <see cref="T:System.Windows.Media.ContainerVisual" /> 的转换。</summary>
        <value>转换值。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Media.Transform> 是一个统一的转换的多种不同形式的基本类。 有关详细信息，请参阅<xref:System.Windows.Media.Transform>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VisualChildrenCount">
      <MemberSignature Language="C#" Value="protected override sealed int VisualChildrenCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 VisualChildrenCount" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.ContainerVisual.VisualChildrenCount" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides NotOverridable ReadOnly Property VisualChildrenCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property int VisualChildrenCount { int get(); };" />
      <MemberSignature Language="F#" Value="member this.VisualChildrenCount : int" Usage="System.Windows.Media.ContainerVisual.VisualChildrenCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取 <see cref="T:System.Windows.Media.ContainerVisual" /> 的子对象个数。</summary>
        <value>
          <see cref="T:System.Windows.Media.VisualCollection" /> 的 <see cref="T:System.Windows.Media.ContainerVisual" /> 中的子对象个数。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 默认情况下，<xref:System.Windows.Media.ContainerVisual>没有任何子级。  
  
   
  
## Examples  
 下面的示例演示如何创建<xref:System.Windows.Media.ContainerVisual>用作两个父对象<xref:System.Windows.Media.DrawingVisual>对象。 添加到对象<xref:System.Windows.Media.ContainerVisual>对象必须添加相反的 z 顺序 （从底部到顶部），以确保它们呈现在正确的绘制顺序。 为了使可视化树中正确枚举，该示例提供的重写的实现<xref:System.Windows.Media.ContainerVisual.GetVisualChild%2A>方法和<xref:System.Windows.Media.ContainerVisual.VisualChildrenCount%2A>属性。  
  
 [!code-csharp[ContainerVisualHost#ContainerVisualHost01](~/samples/snippets/csharp/VS_Snippets_Wpf/ContainerVisualHost/CSharp/Window1.xaml.cs#containervisualhost01)]
 [!code-vb[ContainerVisualHost#ContainerVisualHost01](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContainerVisualHost/visualbasic/window1.xaml.vb#containervisualhost01)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>派生自的类<see cref="T:System.Windows.Media.ContainerVisual" />必须实现<see cref="P:System.Windows.Media.ContainerVisual.VisualChildrenCount" />要枚举可视子属性。派生的属性必须返回的有关的子级的个数<see cref="T:System.Windows.Media.ContainerVisual" />。此调用期间，无法修改的可视化树。</para>
        </block>
        <altmember cref="M:System.Windows.Media.ContainerVisual.GetVisualChild(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="XSnappingGuidelines">
      <MemberSignature Language="C#" Value="public System.Windows.Media.DoubleCollection XSnappingGuidelines { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Media.DoubleCollection XSnappingGuidelines" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.ContainerVisual.XSnappingGuidelines" />
      <MemberSignature Language="VB.NET" Value="Public Property XSnappingGuidelines As DoubleCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Media::DoubleCollection ^ XSnappingGuidelines { System::Windows::Media::DoubleCollection ^ get(); void set(System::Windows::Media::DoubleCollection ^ value); };" />
      <MemberSignature Language="F#" Value="member this.XSnappingGuidelines : System.Windows.Media.DoubleCollection with get, set" Usage="System.Windows.Media.ContainerVisual.XSnappingGuidelines" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Media.DoubleCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置 <see cref="T:System.Windows.Media.ContainerVisual" /> 的 X（水平）准线。</summary>
        <value>水平准线。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 像素对齐是内容的布局固定，以便对象边缘呈现特定于设备的像素的过程。 [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] 图形系统使用与设备无关的单元来使分辨率和设备独立。 每个与设备无关的像素都会随着系统的 [!INCLUDE[TLA#tla_dpi](~/includes/tlasharptla-dpi-md.md)] 设置自动进行缩放。 这为 [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] 应用程序提供了不同 [!INCLUDE[TLA2#tla_dpi](~/includes/tla2sharptla-dpi-md.md)] 设置的适当缩放，并使应用程序自动感知 [!INCLUDE[TLA2#tla_dpi](~/includes/tla2sharptla-dpi-md.md)]。  
  
 但是，这[!INCLUDE[TLA2#tla_dpi](~/includes/tla2sharptla-dpi-md.md)]独立性可能会由于抗锯齿的不规则的边缘呈现出。 当边缘的位置位于中间设备像素，而不是设备像素之间，会发生这些项目，通常被视为分明，还是"软"边缘。 若要解决此问题，[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]提供一种方法与设备像素为单位通过像素对齐，"对齐"可视化树中的对象边缘消除产生抗锯齿的软边缘。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Media.ContainerVisual.YSnappingGuidelines" />
      </Docs>
    </Member>
    <Member MemberName="YSnappingGuidelines">
      <MemberSignature Language="C#" Value="public System.Windows.Media.DoubleCollection YSnappingGuidelines { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Media.DoubleCollection YSnappingGuidelines" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.ContainerVisual.YSnappingGuidelines" />
      <MemberSignature Language="VB.NET" Value="Public Property YSnappingGuidelines As DoubleCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Media::DoubleCollection ^ YSnappingGuidelines { System::Windows::Media::DoubleCollection ^ get(); void set(System::Windows::Media::DoubleCollection ^ value); };" />
      <MemberSignature Language="F#" Value="member this.YSnappingGuidelines : System.Windows.Media.DoubleCollection with get, set" Usage="System.Windows.Media.ContainerVisual.YSnappingGuidelines" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Media.DoubleCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置 <see cref="T:System.Windows.Media.ContainerVisual" /> 的 Y（垂直）准线。</summary>
        <value>垂直准线。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 像素对齐是内容的布局固定，以便对象边缘呈现特定于设备的像素的过程。 [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] 图形系统使用与设备无关的单元来使分辨率和设备独立。 每个与设备无关的像素都会随着系统的 [!INCLUDE[TLA#tla_dpi](~/includes/tlasharptla-dpi-md.md)] 设置自动进行缩放。 这为 [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] 应用程序提供了不同 [!INCLUDE[TLA2#tla_dpi](~/includes/tla2sharptla-dpi-md.md)] 设置的适当缩放，并使应用程序自动感知 [!INCLUDE[TLA2#tla_dpi](~/includes/tla2sharptla-dpi-md.md)]。  
  
 但是，这[!INCLUDE[TLA2#tla_dpi](~/includes/tla2sharptla-dpi-md.md)]独立性可能会由于抗锯齿的不规则的边缘呈现出。 当边缘的位置位于中间设备像素，而不是设备像素之间，会发生这些项目，通常被视为分明，还是"软"边缘。 若要解决此问题，[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]提供一种方法与设备像素为单位通过像素对齐，"对齐"可视化树中的对象边缘消除产生抗锯齿的软边缘。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Media.ContainerVisual.XSnappingGuidelines" />
      </Docs>
    </Member>
  </Members>
</Type>