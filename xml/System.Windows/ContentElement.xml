<Type Name="ContentElement" FullName="System.Windows.ContentElement">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="f36232678eb3b8a808c2991f5ec80d66a7c9fe6e" />
    <Meta Name="ms.sourcegitcommit" Value="0ec122ee5f3681159b8460ab15b409fd6e3d3ae0" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-CN" />
    <Meta Name="ms.lasthandoff" Value="10/04/2018" />
    <Meta Name="ms.locfileid" Value="48632932" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class ContentElement : System.Windows.DependencyObject, System.Windows.IInputElement, System.Windows.Media.Animation.IAnimatable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi ContentElement extends System.Windows.DependencyObject implements class System.Windows.IInputElement, class System.Windows.Media.Animation.IAnimatable" />
  <TypeSignature Language="DocId" Value="T:System.Windows.ContentElement" />
  <TypeSignature Language="VB.NET" Value="Public Class ContentElement&#xA;Inherits DependencyObject&#xA;Implements IAnimatable, IInputElement" />
  <TypeSignature Language="C++ CLI" Value="public ref class ContentElement : System::Windows::DependencyObject, System::Windows::IInputElement, System::Windows::Media::Animation::IAnimatable" />
  <TypeSignature Language="F#" Value="type ContentElement = class&#xA;    inherit DependencyObject&#xA;    interface IInputElement&#xA;    interface IAnimatable" />
  <AssemblyInfo>
    <AssemblyName>PresentationCore</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.DependencyObject</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Windows.IInputElement</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Windows.Media.Animation.IAnimatable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>
      <span data-ttu-id="f4180-101">为内容元素提供 WPF 核心级基类。</span>
      <span class="sxs-lookup">
        <span data-stu-id="f4180-101">Provides a WPF core-level base class for content elements.</span>
      </span>
      <span data-ttu-id="f4180-102">内容元素设计用于流样式显示，它们使用面向标记的直观布局模型和精心设计的简单对象模型。</span>
      <span class="sxs-lookup">
        <span data-stu-id="f4180-102">Content elements are designed for flow-style presentation, using an intuitive markup-oriented layout model and a deliberately simple object model.</span>
      </span>
    </summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4180-103"><xref:System.Windows.ContentElement> 定义以下内容的共同特征：</span><span class="sxs-lookup"><span data-stu-id="f4180-103"><xref:System.Windows.ContentElement> defines the following common content characteristics:</span></span>  
  
-   <span data-ttu-id="f4180-104">输入： 所有<xref:System.Windows.ContentElement>派生的类提供了从键盘、 鼠标、 拖放操作、 触笔控件和加速器的基本输入捕获的支持。</span><span class="sxs-lookup"><span data-stu-id="f4180-104">Input: All <xref:System.Windows.ContentElement> derived classes provide support for basic input capture from keyboard, mouse, drag-and-drop operations, stylus controls, and accelerators.</span></span>  
  
-   <span data-ttu-id="f4180-105">专注： 所有<xref:System.Windows.ContentElement>派生的类都能够获得焦点。</span><span class="sxs-lookup"><span data-stu-id="f4180-105">Focus: All <xref:System.Windows.ContentElement> derived classes are potentially focusable.</span></span> <span data-ttu-id="f4180-106">(但是的默认可获得焦点状态<xref:System.Windows.ContentElement>基类是`false`。</span><span class="sxs-lookup"><span data-stu-id="f4180-106">(However, the default focusable state for the <xref:System.Windows.ContentElement> base class is `false`.</span></span> <span data-ttu-id="f4180-107">有关详细信息，如何使<xref:System.Windows.ContentElement>可获得焦点，请参阅<xref:System.Windows.ContentElement.Focusable%2A>。)此外，此类包含[!INCLUDE[TLA#tla_api#plural](~/includes/tlasharptla-apisharpplural-md.md)]，您可将用于在相关的元素中遍历焦点。</span><span class="sxs-lookup"><span data-stu-id="f4180-107">For details on how to make a <xref:System.Windows.ContentElement> focusable, see <xref:System.Windows.ContentElement.Focusable%2A>.) In addition, this class contains [!INCLUDE[TLA#tla_api#plural](~/includes/tlasharptla-apisharpplural-md.md)] that you can use for traversing the focus across related elements.</span></span>  
  
-   <span data-ttu-id="f4180-108">事件：<xref:System.Windows.ContentElement>包括事件的输入和焦点相关的; 它还包括在状态中的更改的事件。</span><span class="sxs-lookup"><span data-stu-id="f4180-108">Events: <xref:System.Windows.ContentElement> includes events that are related to input and focus; it also includes events for changes in state.</span></span> <span data-ttu-id="f4180-109">在许多情况下，<xref:System.Windows.ContentElement>事件也是路由的事件。</span><span class="sxs-lookup"><span data-stu-id="f4180-109">In many cases, the <xref:System.Windows.ContentElement> events are routed events.</span></span> <span data-ttu-id="f4180-110">在某些情况下，路由的事件具有隧道和浮升路由策略，为不同的相同状态或条件的响应中的事件引发。</span><span class="sxs-lookup"><span data-stu-id="f4180-110">In some cases, routed events have both tunneling and bubbling routing strategies, raised as separate events in response to the same state or condition.</span></span> <span data-ttu-id="f4180-111">此外，<xref:System.Windows.ContentElement>定义[!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)]可引发路由事件，可以添加或删除事件处理程序。</span><span class="sxs-lookup"><span data-stu-id="f4180-111">Also, <xref:System.Windows.ContentElement> defines [!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)] that can raise routed events and that can add or remove handlers to events.</span></span>  
  
 <span data-ttu-id="f4180-112"><xref:System.Windows.ContentElement> 共享许多公共[!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)]与<xref:System.Windows.UIElement>。</span><span class="sxs-lookup"><span data-stu-id="f4180-112"><xref:System.Windows.ContentElement> shares many common [!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)] with <xref:System.Windows.UIElement>.</span></span> <span data-ttu-id="f4180-113">这些常见[!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)]不是来自共享的类继承。</span><span class="sxs-lookup"><span data-stu-id="f4180-113">These common [!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)] do not come from a shared class inheritance.</span></span> <span data-ttu-id="f4180-114">它们共享公共命名、 类似的行为和类似的内部实现的但[!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)]在每个类。</span><span class="sxs-lookup"><span data-stu-id="f4180-114">But they do share common naming, similar behavior, and similar internal implementation of [!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)] in each class.</span></span> <span data-ttu-id="f4180-115">相似性是因为<xref:System.Windows.ContentElement>和<xref:System.Windows.UIElement>是每个类的基元素，不过每个都有不同的意图对其标记对象模型的行为。</span><span class="sxs-lookup"><span data-stu-id="f4180-115">The similarity is because <xref:System.Windows.ContentElement> and <xref:System.Windows.UIElement> are each classes that are an element base, although each has different intentions for its markup object model behavior.</span></span>  
  
 <span data-ttu-id="f4180-116">具体而言，<xref:System.Windows.UIElement>递减自<xref:System.Windows.Media.Visual>，它提供低级别图形支持的呈现<xref:System.Windows.ContentElement>复合窗口中的矩形区域而<xref:System.Windows.ContentElement>延迟呈现，以便详细的概念更轻松地支持对文档的情况下，例如流和换行，通用的。</span><span class="sxs-lookup"><span data-stu-id="f4180-116">In particular, <xref:System.Windows.UIElement> descends from <xref:System.Windows.Media.Visual>, which provides the lower-level graphics support for rendering a <xref:System.Windows.ContentElement> to a rectangular region within a composited window, whereas <xref:System.Windows.ContentElement> defers rendering so that concepts more common to document scenarios, such as flow and wrapping, are more easily supported.</span></span> <span data-ttu-id="f4180-117">这两个相关类还实现公共接口<xref:System.Windows.IInputElement>和<xref:System.Windows.Media.Animation.IAnimatable>。</span><span class="sxs-lookup"><span data-stu-id="f4180-117">These two related classes also implement the common interfaces <xref:System.Windows.IInputElement> and <xref:System.Windows.Media.Animation.IAnimatable>.</span></span>  
  
 ]]></format>
    </remarks>
    <block subset="none" type="overrides">
      <para>
        <span data-ttu-id="f4180-118">
          <see cref="T:System.Windows.ContentElement" />类尚未定义流样式显示的完整内容元素的所有方面。</span>
        <span class="sxs-lookup">
          <span data-stu-id="f4180-118">The <see cref="T:System.Windows.ContentElement" /> class does not yet define all aspects of a complete content element for flow-style presentation.</span>
        </span>
        <span data-ttu-id="f4180-119">
          <see cref="T:System.Windows.FrameworkContentElement" /> 是一个直接派生的类<see cref="T:System.Windows.ContentElement" />。</span>
        <span class="sxs-lookup">
          <span data-stu-id="f4180-119">
            <see cref="T:System.Windows.FrameworkContentElement" /> is an immediately derived class of <see cref="T:System.Windows.ContentElement" />.</span>
        </span>
        <span data-ttu-id="f4180-120">
          <see cref="T:System.Windows.FrameworkContentElement" /> 包含一组更完整的其他成员以支持呈现<see cref="T:System.Windows.FrameworkContentElement" />内容主机和使用 WPF 框架级别的布局系统中。</span>
        <span class="sxs-lookup">
          <span data-stu-id="f4180-120">
            <see cref="T:System.Windows.FrameworkContentElement" /> includes a more complete set of additional members that support rendering a <see cref="T:System.Windows.FrameworkContentElement" /> within a content host and using the WPF framework-level layout system.</span>
        </span>
      </para>
    </block>
    <altmember cref="T:System.Windows.UIElement" />
    <altmember cref="T:System.Windows.FrameworkContentElement" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ContentElement ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ContentElement();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="f4180-121">初始化 <see cref="T:System.Windows.ContentElement" /> 类的新实例。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-121">Initializes a new instance of the <see cref="T:System.Windows.ContentElement" /> class.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AddHandler">
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="f4180-122">为指定的路由事件添加路由事件处理程序，并将该处理程序添加到当前元素的处理程序集合中。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-122">Adds a routed event handler for a specified routed event, adding the handler to the handler collection on the current element.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddHandler">
      <MemberSignature Language="C#" Value="public void AddHandler (System.Windows.RoutedEvent routedEvent, Delegate handler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void AddHandler(class System.Windows.RoutedEvent routedEvent, class System.Delegate handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.AddHandler(System.Windows.RoutedEvent,System.Delegate)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void AddHandler(System::Windows::RoutedEvent ^ routedEvent, Delegate ^ handler);" />
      <MemberSignature Language="F#" Value="abstract member AddHandler : System.Windows.RoutedEvent * Delegate -&gt; unit&#xA;override this.AddHandler : System.Windows.RoutedEvent * Delegate -&gt; unit" Usage="contentElement.AddHandler (routedEvent, handler)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.IInputElement.AddHandler(System.Windows.RoutedEvent,System.Delegate)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routedEvent" Type="System.Windows.RoutedEvent" />
        <Parameter Name="handler" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="routedEvent">
          <span data-ttu-id="f4180-123">要处理的路由事件的标识符。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-123">An identifier for the routed event to be handled.</span>
          </span>
        </param>
        <param name="handler">
          <span data-ttu-id="f4180-124">对处理程序实现的引用。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-124">A reference to the handler implementation.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f4180-125">为指定的路由事件添加路由事件处理程序，并将该处理程序添加到当前元素的处理程序集合中。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-125">Adds a routed event handler for a specified routed event, adding the handler to the handler collection on the current element.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4180-126">可以将相同事件的同一处理程序添加多个时间并且不会引发异常。</span><span class="sxs-lookup"><span data-stu-id="f4180-126">You can add the same handler for the same event multiple times without raising an exception.</span></span> <span data-ttu-id="f4180-127">但是，实际调用处理程序处理该事件时的多个时间。</span><span class="sxs-lookup"><span data-stu-id="f4180-127">However, the handler is actually invoked multiple times when the event is handled.</span></span> <span data-ttu-id="f4180-128">因此，请考虑此行为可能应该在处理程序实现中考虑的副作用。</span><span class="sxs-lookup"><span data-stu-id="f4180-128">Therefore, consider how this behavior might have side effects that should be accounted for in your handler implementation.</span></span>  
  
 <span data-ttu-id="f4180-129">通常使用此方法提供的"添加"访问器实现[!INCLUDE[TLA#tla_net](~/includes/tlasharptla-net-md.md)]事件的自定义的路由事件的访问模式。</span><span class="sxs-lookup"><span data-stu-id="f4180-129">You typically use this method to provide the implementation of the "add" accessor for the [!INCLUDE[TLA#tla_net](~/includes/tlasharptla-net-md.md)] event access pattern of a custom routed event.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddHandler">
      <MemberSignature Language="C#" Value="public void AddHandler (System.Windows.RoutedEvent routedEvent, Delegate handler, bool handledEventsToo);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddHandler(class System.Windows.RoutedEvent routedEvent, class System.Delegate handler, bool handledEventsToo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.AddHandler(System.Windows.RoutedEvent,System.Delegate,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddHandler(System::Windows::RoutedEvent ^ routedEvent, Delegate ^ handler, bool handledEventsToo);" />
      <MemberSignature Language="F#" Value="member this.AddHandler : System.Windows.RoutedEvent * Delegate * bool -&gt; unit" Usage="contentElement.AddHandler (routedEvent, handler, handledEventsToo)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routedEvent" Type="System.Windows.RoutedEvent" />
        <Parameter Name="handler" Type="System.Delegate" />
        <Parameter Name="handledEventsToo" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="routedEvent">
          <span data-ttu-id="f4180-130">要处理的路由事件的标识符。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-130">An identifier for the.routed event to be handled.</span>
          </span>
        </param>
        <param name="handler">
          <span data-ttu-id="f4180-131">对处理程序实现的引用。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-131">A reference to the handler implementation.</span>
          </span>
        </param>
        <param name="handledEventsToo">
          <span data-ttu-id="f4180-132">如果为 <see langword="true" />，则将按以下方式注册处理程序：即使路由事件在其事件数据中标记为已处理，也会调用处理程序；如果为 <see langword="false" />，则使用默认条件注册处理程序，即当路由事件被标记为已处理时，将不调用处理程序。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-132">
              <see langword="true" /> to register the handler such that it is invoked even when the routed event is marked handled in its event data; <see langword="false" /> to register the handler with the default condition that it will not be invoked if the routed event is already marked handled.</span>
          </span>
          <span data-ttu-id="f4180-133">默认值为 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-133">The default is <see langword="false" />.</span>
          </span>
          <span data-ttu-id="f4180-134">请勿定期请求重新处理路由事件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-134">Do not routinely ask to rehandle a routed event.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f4180-135">为指定的路由事件添加路由事件处理程序，并将该处理程序添加到当前元素的处理程序集合中。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-135">Adds a routed event handler for a specified routed event, adding the handler to the handler collection on the current element.</span>
          </span>
          <span data-ttu-id="f4180-136">将 <paramref name="handledEventsToo" /> 指定为 <see langword="true" />，可为已标记为由事件路由中的其他元素处理的路由事件调用所提供的处理程序。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-136">Specify <paramref name="handledEventsToo" /> as <see langword="true" /> to have the provided handler be invoked for routed event that had already been marked as handled by another element along the event route.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4180-137">以实用方式处理低级别的输入的事件是一个复杂的任务。</span><span class="sxs-lookup"><span data-stu-id="f4180-137">Processing low-level input events in a practical way is a complex task.</span></span> <span data-ttu-id="f4180-138">许多控件实现其中某个事件被标记为已处理，并且另一个更直观的事件会被替换的行为。</span><span class="sxs-lookup"><span data-stu-id="f4180-138">Many controls implement behavior where a certain event is marked as handled, and is replaced by another more intuitive event.</span></span> <span data-ttu-id="f4180-139">通常情况下，控件将仅标记平台输入的事件，为已处理是否存在某个设计意图要求执行此操作。</span><span class="sxs-lookup"><span data-stu-id="f4180-139">Generally, a control will only mark a platform input event as handled if there is some design intention for doing so.</span></span> <span data-ttu-id="f4180-140">在某些情况下，这些设计意图可能不是在特定输入事件的处理要求。</span><span class="sxs-lookup"><span data-stu-id="f4180-140">In certain scenarios, those design intentions might not be what your particular handling of the input event requires.</span></span> <span data-ttu-id="f4180-141">它对于这种情况是该注册处理程序替换`handledEventsToo`作为`true`适用。</span><span class="sxs-lookup"><span data-stu-id="f4180-141">It is for these scenarios that registering handlers with `handledEventsToo` as `true` is appropriate.</span></span> <span data-ttu-id="f4180-142">但不是应定期执行此。</span><span class="sxs-lookup"><span data-stu-id="f4180-142">But you should not do this routinely.</span></span> <span data-ttu-id="f4180-143">调用以响应所有事件处理程序，即使处理将增加你自己的应用程序事件处理逻辑的复杂性。</span><span class="sxs-lookup"><span data-stu-id="f4180-143">Invoking handlers in response to all events even if handled will complicate your own application event processing logic.</span></span> <span data-ttu-id="f4180-144">如果是巨大的处理程序逻辑，可能会降低性能。</span><span class="sxs-lookup"><span data-stu-id="f4180-144">You may see a decrease in performance if the handler logic is substantial.</span></span> <span data-ttu-id="f4180-145">你应保留附加的已处理事件的情况下，您已经发现在开发过程中的某些控件正在处理你仍想要使用的应用程序逻辑来处理的事件处理程序的使用。</span><span class="sxs-lookup"><span data-stu-id="f4180-145">You should reserve the use of attaching handlers for already-handled events for situations where you have already discovered during the development process that certain controls are handling events that you still want to handle with application logic.</span></span>  
  
 <span data-ttu-id="f4180-146">避免处理的某些事件控件组合的行为的类的另一种方法是使用该事件的预览替代方法。</span><span class="sxs-lookup"><span data-stu-id="f4180-146">Another technique for avoiding the class handling behavior of certain event-control combinations is to use that event's preview alternative.</span></span> <span data-ttu-id="f4180-147">例如，如果<xref:System.Windows.ContentElement.MouseLeftButtonDown>标记为已处理类处理，您可以为添加处理程序<xref:System.Windows.ContentElement.PreviewMouseLeftButtonDown>相反。</span><span class="sxs-lookup"><span data-stu-id="f4180-147">For example, if <xref:System.Windows.ContentElement.MouseLeftButtonDown> is marked handled by class handling, you might be able to add handlers for <xref:System.Windows.ContentElement.PreviewMouseLeftButtonDown> instead.</span></span>  
  
 <span data-ttu-id="f4180-148">可以将相同事件的同一处理程序添加多个时间并且不会引发异常。</span><span class="sxs-lookup"><span data-stu-id="f4180-148">You can add the same handler for the same event multiple times without raising an exception.</span></span> <span data-ttu-id="f4180-149">但是，实际调用处理程序处理该事件时的多个时间。</span><span class="sxs-lookup"><span data-stu-id="f4180-149">However, the handler is actually invoked multiple times when the event is handled.</span></span> <span data-ttu-id="f4180-150">因此，请考虑此行为可能应该在处理程序实现中考虑的副作用。</span><span class="sxs-lookup"><span data-stu-id="f4180-150">Therefore, consider how this behavior might have side effects that should be accounted for in your handler implementation.</span></span>  
  
 <span data-ttu-id="f4180-151">通常使用此方法提供的"添加"访问器实现[!INCLUDE[TLA#tla_net](~/includes/tlasharptla-net-md.md)]事件的自定义的路由事件的访问模式。</span><span class="sxs-lookup"><span data-stu-id="f4180-151">You typically use this method to provide the implementation of the "add" accessor for the [!INCLUDE[TLA#tla_net](~/includes/tlasharptla-net-md.md)] event access pattern of a custom routed event.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f4180-152">下面的示例实现一个处理程序上调用<xref:System.Windows.FrameworkElement.Initialized>将定义处理程序附加到一个页面使用的命名元素的页面上的事件`handledEventsToo` `true`。</span><span class="sxs-lookup"><span data-stu-id="f4180-152">The following example implements a handler invoked on the <xref:System.Windows.FrameworkElement.Initialized> event on a page that attaches a defined handler to one of the named elements on the page using `handledEventsToo` `true`.</span></span> <span data-ttu-id="f4180-153">将调用此处理程序，即使路由中的另一个元素标记为已处理到达路由中的处理元素之前的共享的事件数据。</span><span class="sxs-lookup"><span data-stu-id="f4180-153">This handler would be invoked even if another element along the route marked the shared event data as handled before reaching the handling element in the route.</span></span>  
  
 [!code-csharp[EventOvwSupport#AddHandlerHandledToo](~/samples/snippets/csharp/VS_Snippets_Wpf/EventOvwSupport/CSharp/page2.xaml.cs#addhandlerhandledtoo)]
 [!code-vb[EventOvwSupport#AddHandlerHandledToo](~/samples/snippets/visualbasic/VS_Snippets_Wpf/EventOvwSupport/visualbasic/page2.xaml.vb#addhandlerhandledtoo)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddToEventRoute">
      <MemberSignature Language="C#" Value="public void AddToEventRoute (System.Windows.EventRoute route, System.Windows.RoutedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddToEventRoute(class System.Windows.EventRoute route, class System.Windows.RoutedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.AddToEventRoute(System.Windows.EventRoute,System.Windows.RoutedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddToEventRoute (route As EventRoute, e As RoutedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddToEventRoute(System::Windows::EventRoute ^ route, System::Windows::RoutedEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.AddToEventRoute : System.Windows.EventRoute * System.Windows.RoutedEventArgs -&gt; unit" Usage="contentElement.AddToEventRoute (route, e)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="route" Type="System.Windows.EventRoute" />
        <Parameter Name="e" Type="System.Windows.RoutedEventArgs" />
      </Parameters>
      <Docs>
        <param name="route">
          <span data-ttu-id="f4180-154">要向其添加处理程序的事件路由。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-154">The event route that handlers are added to.</span>
          </span>
        </param>
        <param name="e">
          <span data-ttu-id="f4180-155">用于添加处理程序的事件数据。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-155">The event data that is used to add the handlers.</span>
          </span>
          <span data-ttu-id="f4180-156">此方法使用参数的 <see cref="P:System.Windows.RoutedEventArgs.RoutedEvent" /> 属性来创建处理程序。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-156">This method uses the <see cref="P:System.Windows.RoutedEventArgs.RoutedEvent" /> property of the arguments to create the handlers.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f4180-157">将处理程序添加到当前 <see cref="T:System.Windows.EventRoute" /> 事件处理程序集合的指定 <see cref="T:System.Windows.ContentElement" /> 中。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-157">Adds handlers to the specified <see cref="T:System.Windows.EventRoute" /> for the current <see cref="T:System.Windows.ContentElement" /> event handler collection.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4180-158">使用此方法的内容宿主元素 (无论它们是否实现<xref:System.Windows.IContentHost>) 要将内容主机子元素的处理程序添加到主机<xref:System.Windows.EventRoute>。</span><span class="sxs-lookup"><span data-stu-id="f4180-158">Use this method for content host elements (regardless whether they implement <xref:System.Windows.IContentHost>) in order to add handlers for the content host child elements to the host <xref:System.Windows.EventRoute>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AllowDrop">
      <MemberSignature Language="C#" Value="public bool AllowDrop { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AllowDrop" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.AllowDrop" />
      <MemberSignature Language="VB.NET" Value="Public Property AllowDrop As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AllowDrop { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AllowDrop : bool with get, set" Usage="System.Windows.ContentElement.AllowDrop" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f4180-159">获取或设置一个值，该值指示此元素能否用作拖放操作的目标。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-159">Gets or sets a value that indicates whether this element can be used as the target of a drag-and-drop operation.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="f4180-160">如果此元素可用作拖放操作的目标，则为 <see langword="true" />；否则为 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-160">
              <see langword="true" /> if this element can be used as the target of a drag-and-drop operation; otherwise, <see langword="false" />.</span>
          </span>
          <span data-ttu-id="f4180-161">默认值为 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-161">The default value is <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4180-162">拖放操作默认情况下，不启用，必须通过设置有意启用<xref:System.Windows.ContentElement.AllowDrop%2A>到`true`。</span><span class="sxs-lookup"><span data-stu-id="f4180-162">Drag-and-drop operations are not enabled by default, and must be enabled deliberately by setting <xref:System.Windows.ContentElement.AllowDrop%2A> to  `true`.</span></span> <span data-ttu-id="f4180-163">除了此基本设置，拖放行为则完全是特定于实现的并且不由<xref:System.Windows.ContentElement>或任何其他基元素类。</span><span class="sxs-lookup"><span data-stu-id="f4180-163">Beyond this basic setting, drag-and-drop behavior is entirely implementation specific and is not defined by <xref:System.Windows.ContentElement> or any other base element class.</span></span> <span data-ttu-id="f4180-164">例如，某些控件<xref:System.Windows.Controls.RichTextBox>，默认行为，但不会有<xref:System.Windows.ContentElement>派生的类具有这样的行为。</span><span class="sxs-lookup"><span data-stu-id="f4180-164">Certain controls, for example, <xref:System.Windows.Controls.RichTextBox>, do have a default behavior, but no <xref:System.Windows.ContentElement> derived classes have such a behavior.</span></span> <span data-ttu-id="f4180-165">拖放功能的详细信息，请参阅[拖放概述](~/docs/framework/wpf/advanced/drag-and-drop-overview.md)。</span><span class="sxs-lookup"><span data-stu-id="f4180-165">For more information on drag and drop, see [Drag and Drop Overview](~/docs/framework/wpf/advanced/drag-and-drop-overview.md).</span></span>  
  
 <span data-ttu-id="f4180-166"><xref:System.Windows.FrameworkContentElement> 重写此依赖关系属性在其实现中的元数据。</span><span class="sxs-lookup"><span data-stu-id="f4180-166"><xref:System.Windows.FrameworkContentElement> overrides the metadata for this dependency property in its implementation.</span></span> <span data-ttu-id="f4180-167">具体而言，<xref:System.Windows.FrameworkContentElement>指定此属性允许属性值继承 (<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>是`true`元数据中)。</span><span class="sxs-lookup"><span data-stu-id="f4180-167">Specifically, <xref:System.Windows.FrameworkContentElement> designates that this property allows property value inheritance (<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> is `true` in metadata).</span></span> <span data-ttu-id="f4180-168">在此上下文中的属性值继承意味着，如果有与任何其他值的子元素<xref:System.Windows.ContentElement.AllowDrop%2A>通过本地值或样式，分配 （也是在样式中，默认情况下此值与最接近的父元素的值分配值或本地值），则该父元素中的值通过属性系统分配给所有未分配的子元素。</span><span class="sxs-lookup"><span data-stu-id="f4180-168">Property value inheritance in this context means that if there are child elements with no other value for <xref:System.Windows.ContentElement.AllowDrop%2A> assigned through local values or styles, the value of the nearest parent element with this value assigned (again, either in styles, by default values, or a local value), then the value from that parent element is assigned to all unassigned child elements by the property system.</span></span> <span data-ttu-id="f4180-169">这意味着您可以指定是否允许在根元素上的删除操作，然后传播到所有的值<xref:System.Windows.FrameworkContentElement>具有不专门为其分配的值的子元素`false`。</span><span class="sxs-lookup"><span data-stu-id="f4180-169">This means that you can specify whether to allow drop operations at the root element and then propagate the value to all <xref:System.Windows.FrameworkContentElement> child elements that have not specifically assigned it a value of `false`.</span></span>  
  
<a name="dependencyPropertyInfo_AllowDrop"></a>   
## <a name="dependency-property-information"></a><span data-ttu-id="f4180-170">依赖项属性信息</span><span class="sxs-lookup"><span data-stu-id="f4180-170">Dependency Property Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="f4180-171">标识符字段</span><span class="sxs-lookup"><span data-stu-id="f4180-171">Identifier field</span></span>|<xref:System.Windows.ContentElement.AllowDropProperty>|  
|<span data-ttu-id="f4180-172">元数据属性设置为 `true`</span><span class="sxs-lookup"><span data-stu-id="f4180-172">Metadata properties set to `true`</span></span>|<span data-ttu-id="f4180-173">无</span><span class="sxs-lookup"><span data-stu-id="f4180-173">None</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="f4180-174">下面的示例设置<xref:System.Windows.ContentElement.AllowDrop%2A>在[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]。</span><span class="sxs-lookup"><span data-stu-id="f4180-174">The following example sets <xref:System.Windows.ContentElement.AllowDrop%2A> in [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].</span></span>  
  
 [!code-xaml[ContentElementsSmorgasbord#AllowDrop](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml#allowdrop)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AllowDropProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty AllowDropProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty AllowDropProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.AllowDropProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly AllowDropProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ AllowDropProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable AllowDropProperty : System.Windows.DependencyProperty" Usage="System.Windows.ContentElement.AllowDropProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f4180-175">标识 <see cref="P:System.Windows.ContentElement.AllowDrop" /> 依赖项属性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-175">Identifies the <see cref="P:System.Windows.ContentElement.AllowDrop" /> dependency property.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ApplyAnimationClock">
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="f4180-176">将动画应用到此元素的指定依赖属性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-176">Applies an animation to a specified dependency property on this element.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ApplyAnimationClock">
      <MemberSignature Language="C#" Value="public void ApplyAnimationClock (System.Windows.DependencyProperty dp, System.Windows.Media.Animation.AnimationClock clock);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ApplyAnimationClock(class System.Windows.DependencyProperty dp, class System.Windows.Media.Animation.AnimationClock clock) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.ApplyAnimationClock(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationClock)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ApplyAnimationClock (dp As DependencyProperty, clock As AnimationClock)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ApplyAnimationClock(System::Windows::DependencyProperty ^ dp, System::Windows::Media::Animation::AnimationClock ^ clock);" />
      <MemberSignature Language="F#" Value="abstract member ApplyAnimationClock : System.Windows.DependencyProperty * System.Windows.Media.Animation.AnimationClock -&gt; unit&#xA;override this.ApplyAnimationClock : System.Windows.DependencyProperty * System.Windows.Media.Animation.AnimationClock -&gt; unit" Usage="contentElement.ApplyAnimationClock (dp, clock)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Media.Animation.IAnimatable.ApplyAnimationClock(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationClock)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="clock" Type="System.Windows.Media.Animation.AnimationClock" />
      </Parameters>
      <Docs>
        <param name="dp">
          <span data-ttu-id="f4180-177">要进行动画处理的属性的标识符。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-177">The identifier for the property to animate.</span>
          </span>
        </param>
        <param name="clock">
          <span data-ttu-id="f4180-178">控制和声明动画的动画时钟。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-178">The animation clock that controls and declares the animation.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f4180-179">将动画应用到此元素的指定依赖属性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-179">Applies an animation to a specified dependency property on this element.</span>
          </span>
          <span data-ttu-id="f4180-180">任何现有动画均停止并替换为新动画。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-180">Any existing animations are stopped and replaced with the new animation.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4180-181">若要从属性中删除动画，指定为该属性的标识符`dp`并指定`clock`作为`null`。</span><span class="sxs-lookup"><span data-stu-id="f4180-181">To remove an animation from a property, specify the identifier for that property as `dp` and specify `clock` as `null`.</span></span> <span data-ttu-id="f4180-182">这会删除动画，动画的属性设置为其基值。</span><span class="sxs-lookup"><span data-stu-id="f4180-182">This removes the animation and the animated property is set to its base value.</span></span> <span data-ttu-id="f4180-183">但是，不会停止最初关联的动画时钟。</span><span class="sxs-lookup"><span data-stu-id="f4180-183">However, the originally associated animation clock is not stopped.</span></span> <span data-ttu-id="f4180-184">其他任何分配给该时钟的动画将继续运行。</span><span class="sxs-lookup"><span data-stu-id="f4180-184">Any other animations assigned to that clock will continue to run.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ApplyAnimationClock">
      <MemberSignature Language="C#" Value="public void ApplyAnimationClock (System.Windows.DependencyProperty dp, System.Windows.Media.Animation.AnimationClock clock, System.Windows.Media.Animation.HandoffBehavior handoffBehavior);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ApplyAnimationClock(class System.Windows.DependencyProperty dp, class System.Windows.Media.Animation.AnimationClock clock, valuetype System.Windows.Media.Animation.HandoffBehavior handoffBehavior) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.ApplyAnimationClock(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationClock,System.Windows.Media.Animation.HandoffBehavior)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ApplyAnimationClock(System::Windows::DependencyProperty ^ dp, System::Windows::Media::Animation::AnimationClock ^ clock, System::Windows::Media::Animation::HandoffBehavior handoffBehavior);" />
      <MemberSignature Language="F#" Value="abstract member ApplyAnimationClock : System.Windows.DependencyProperty * System.Windows.Media.Animation.AnimationClock * System.Windows.Media.Animation.HandoffBehavior -&gt; unit&#xA;override this.ApplyAnimationClock : System.Windows.DependencyProperty * System.Windows.Media.Animation.AnimationClock * System.Windows.Media.Animation.HandoffBehavior -&gt; unit" Usage="contentElement.ApplyAnimationClock (dp, clock, handoffBehavior)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Media.Animation.IAnimatable.ApplyAnimationClock(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationClock,System.Windows.Media.Animation.HandoffBehavior)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="clock" Type="System.Windows.Media.Animation.AnimationClock" />
        <Parameter Name="handoffBehavior" Type="System.Windows.Media.Animation.HandoffBehavior" />
      </Parameters>
      <Docs>
        <param name="dp">
          <span data-ttu-id="f4180-185">要进行动画处理的属性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-185">The property to animate.</span>
          </span>
        </param>
        <param name="clock">
          <span data-ttu-id="f4180-186">控制和声明动画的动画时钟。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-186">The animation clock that controls and declares the animation.</span>
          </span>
        </param>
        <param name="handoffBehavior">
          <span data-ttu-id="f4180-187">枚举的一个值。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-187">A value of the enumeration.</span>
          </span>
          <span data-ttu-id="f4180-188">默认值为 <see cref="F:System.Windows.Media.Animation.HandoffBehavior.SnapshotAndReplace" />，这会停止任何现有动画并将其替换为新动画。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-188">The default is <see cref="F:System.Windows.Media.Animation.HandoffBehavior.SnapshotAndReplace" />, which will stop any existing animation and replace with the new one.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f4180-189">向此元素的指定依赖属性应用动画，并且可以指定当该属性已有正在运行的动画时所要执行的操作。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-189">Applies an animation to a specified dependency property on this element, with the ability to specify what happens if the property already has a running animation.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4180-190">若要从属性中删除动画，指定为该属性的标识符`dp`并指定`clock`作为`null`。</span><span class="sxs-lookup"><span data-stu-id="f4180-190">To remove an animation from a property, specify the identifier for that property as `dp` and specify `clock` as `null`.</span></span> <span data-ttu-id="f4180-191">这会删除动画，动画的属性设置为其基值。</span><span class="sxs-lookup"><span data-stu-id="f4180-191">This removes the animation and the animated property is set to its base value.</span></span> <span data-ttu-id="f4180-192">但是，不会停止最初关联的动画时钟。</span><span class="sxs-lookup"><span data-stu-id="f4180-192">However, the originally associated animation clock is not stopped.</span></span> <span data-ttu-id="f4180-193">其他任何分配给该时钟的动画将继续运行。</span><span class="sxs-lookup"><span data-stu-id="f4180-193">Any other animations assigned to that clock will continue to run.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AreAnyTouchesCaptured">
      <MemberSignature Language="C#" Value="public bool AreAnyTouchesCaptured { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AreAnyTouchesCaptured" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.AreAnyTouchesCaptured" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AreAnyTouchesCaptured As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AreAnyTouchesCaptured { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.AreAnyTouchesCaptured : bool" Usage="System.Windows.ContentElement.AreAnyTouchesCaptured" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f4180-194">获取一个值，该值指示在此元素上是否至少捕获了一次触摸。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-194">Gets a value that indicates whether at least one touch is captured to this element.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="f4180-195">如果在此元素上至少捕获了一次触摸，则为 <see langword="true" />；否则为 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-195">
              <see langword="true" /> if at least one touch is captured to this element; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AreAnyTouchesCapturedProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty AreAnyTouchesCapturedProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty AreAnyTouchesCapturedProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.AreAnyTouchesCapturedProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly AreAnyTouchesCapturedProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ AreAnyTouchesCapturedProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable AreAnyTouchesCapturedProperty : System.Windows.DependencyProperty" Usage="System.Windows.ContentElement.AreAnyTouchesCapturedProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f4180-196">标识 <see cref="P:System.Windows.ContentElement.AreAnyTouchesCaptured" /> 依赖项属性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-196">Identifies the <see cref="P:System.Windows.ContentElement.AreAnyTouchesCaptured" /> dependency property.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AreAnyTouchesCapturedWithin">
      <MemberSignature Language="C#" Value="public bool AreAnyTouchesCapturedWithin { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AreAnyTouchesCapturedWithin" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.AreAnyTouchesCapturedWithin" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AreAnyTouchesCapturedWithin As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AreAnyTouchesCapturedWithin { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.AreAnyTouchesCapturedWithin : bool" Usage="System.Windows.ContentElement.AreAnyTouchesCapturedWithin" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f4180-197">获取一个值，该值指示在此元素或其可视化树中的任何子元素上是否至少捕获了一次触摸。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-197">Gets a value that indicates whether at least one touch is captured to this element or to any child elements in its visual tree.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="f4180-198">如果在此元素或其可视化树中的任何子元素上至少捕获了一次触摸，则为 <see langword="true" />；否则为 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-198">
              <see langword="true" /> if at least one touch is captured to this element or any child elements in its visual tree; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AreAnyTouchesCapturedWithinProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty AreAnyTouchesCapturedWithinProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty AreAnyTouchesCapturedWithinProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.AreAnyTouchesCapturedWithinProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly AreAnyTouchesCapturedWithinProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ AreAnyTouchesCapturedWithinProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable AreAnyTouchesCapturedWithinProperty : System.Windows.DependencyProperty" Usage="System.Windows.ContentElement.AreAnyTouchesCapturedWithinProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f4180-199">标识 <see cref="P:System.Windows.ContentElement.AreAnyTouchesCapturedWithin" /> 依赖项属性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-199">Identifies the <see cref="P:System.Windows.ContentElement.AreAnyTouchesCapturedWithin" /> dependency property.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AreAnyTouchesDirectlyOver">
      <MemberSignature Language="C#" Value="public bool AreAnyTouchesDirectlyOver { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AreAnyTouchesDirectlyOver" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.AreAnyTouchesDirectlyOver" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AreAnyTouchesDirectlyOver As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AreAnyTouchesDirectlyOver { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.AreAnyTouchesDirectlyOver : bool" Usage="System.Windows.ContentElement.AreAnyTouchesDirectlyOver" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f4180-200">获取一个值，该值指示在此元素上是否至少按下了一次触摸设备。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-200">Gets a value that indicates whether at least one touch is pressed over this element.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="f4180-201">如果在此元素上至少按下了一次触摸设备，则为 <see langword="true" />；否则为 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-201">
              <see langword="true" /> if at least one touch is pressed over this element; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AreAnyTouchesDirectlyOverProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty AreAnyTouchesDirectlyOverProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty AreAnyTouchesDirectlyOverProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.AreAnyTouchesDirectlyOverProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly AreAnyTouchesDirectlyOverProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ AreAnyTouchesDirectlyOverProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable AreAnyTouchesDirectlyOverProperty : System.Windows.DependencyProperty" Usage="System.Windows.ContentElement.AreAnyTouchesDirectlyOverProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f4180-202">标识 <see cref="P:System.Windows.ContentElement.AreAnyTouchesDirectlyOver" /> 依赖项属性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-202">Identifies the <see cref="P:System.Windows.ContentElement.AreAnyTouchesDirectlyOver" /> dependency property.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AreAnyTouchesOver">
      <MemberSignature Language="C#" Value="public bool AreAnyTouchesOver { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AreAnyTouchesOver" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.AreAnyTouchesOver" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AreAnyTouchesOver As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AreAnyTouchesOver { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.AreAnyTouchesOver : bool" Usage="System.Windows.ContentElement.AreAnyTouchesOver" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f4180-203">获取一个值，该值指示在此元素或其可视化树中的任何子元素上是否至少按下了一次触摸设备。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-203">Gets a value that indicates whether at least one touch is pressed over this element or any child elements in its visual tree.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="f4180-204">如果在此元素或其可视化树中的任何子元素上至少按下了一次触摸设备，则为 <see langword="true" />；否则为 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-204">
              <see langword="true" /> if at least one touch is pressed over this element or any child elements in its visual tree; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AreAnyTouchesOverProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty AreAnyTouchesOverProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty AreAnyTouchesOverProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.AreAnyTouchesOverProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly AreAnyTouchesOverProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ AreAnyTouchesOverProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable AreAnyTouchesOverProperty : System.Windows.DependencyProperty" Usage="System.Windows.ContentElement.AreAnyTouchesOverProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f4180-205">标识 <see cref="P:System.Windows.ContentElement.AreAnyTouchesOver" /> 依赖项属性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-205">Identifies the <see cref="P:System.Windows.ContentElement.AreAnyTouchesOver" /> dependency property.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginAnimation">
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="f4180-206">为此元素的指定要进行动画处理的属性启动动画。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-206">Starts an animation for a specified animated property on this element.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginAnimation">
      <MemberSignature Language="C#" Value="public void BeginAnimation (System.Windows.DependencyProperty dp, System.Windows.Media.Animation.AnimationTimeline animation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void BeginAnimation(class System.Windows.DependencyProperty dp, class System.Windows.Media.Animation.AnimationTimeline animation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.BeginAnimation(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationTimeline)" />
      <MemberSignature Language="VB.NET" Value="Public Sub BeginAnimation (dp As DependencyProperty, animation As AnimationTimeline)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void BeginAnimation(System::Windows::DependencyProperty ^ dp, System::Windows::Media::Animation::AnimationTimeline ^ animation);" />
      <MemberSignature Language="F#" Value="abstract member BeginAnimation : System.Windows.DependencyProperty * System.Windows.Media.Animation.AnimationTimeline -&gt; unit&#xA;override this.BeginAnimation : System.Windows.DependencyProperty * System.Windows.Media.Animation.AnimationTimeline -&gt; unit" Usage="contentElement.BeginAnimation (dp, animation)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Media.Animation.IAnimatable.BeginAnimation(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationTimeline)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="animation" Type="System.Windows.Media.Animation.AnimationTimeline" />
      </Parameters>
      <Docs>
        <param name="dp">
          <span data-ttu-id="f4180-207">要进行动画处理的属性，它被指定为依赖项属性标识符。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-207">The property to animate, which is specified as a dependency property identifier.</span>
          </span>
        </param>
        <param name="animation">
          <span data-ttu-id="f4180-208">要启动的动画的时间线。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-208">The timeline of the animation to start.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f4180-209">为此元素的指定要进行动画处理的属性启动动画。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-209">Starts an animation for a specified animated property on this element.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4180-210">选中属性进行动画处理，请注意，动画将开始考虑经过动画处理的非动画的起始点以外的第一帧呈现时。</span><span class="sxs-lookup"><span data-stu-id="f4180-210">When you check whether a property is animated, note that the animation will begin and be considered animated when the first frame beyond the non-animated starting point is rendered.</span></span>  
  
 <span data-ttu-id="f4180-211">如果<xref:System.Windows.Media.Animation.Timeline.BeginTime%2A>有关`animation`是`null`，然后删除任何当前动画并保持的属性的当前值。</span><span class="sxs-lookup"><span data-stu-id="f4180-211">If the <xref:System.Windows.Media.Animation.Timeline.BeginTime%2A> for `animation` is `null`, then any current animations are removed and the current value of the property is held.</span></span>  
  
 <span data-ttu-id="f4180-212">如果整个`animation`值是`null`、 从属性中移除所有动画和属性值会恢复为其基值。</span><span class="sxs-lookup"><span data-stu-id="f4180-212">If the entire `animation` value is `null`, all animations are removed from the property and the property value reverts to its base value.</span></span> <span data-ttu-id="f4180-213">但是，不会停止最初关联的动画时间线。</span><span class="sxs-lookup"><span data-stu-id="f4180-213">However, the originally associated animation timeline is not stopped.</span></span> <span data-ttu-id="f4180-214">分配给该时间线中的其他任何动画将继续运行。</span><span class="sxs-lookup"><span data-stu-id="f4180-214">Any other animations assigned to that timeline will continue to run.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginAnimation">
      <MemberSignature Language="C#" Value="public void BeginAnimation (System.Windows.DependencyProperty dp, System.Windows.Media.Animation.AnimationTimeline animation, System.Windows.Media.Animation.HandoffBehavior handoffBehavior);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void BeginAnimation(class System.Windows.DependencyProperty dp, class System.Windows.Media.Animation.AnimationTimeline animation, valuetype System.Windows.Media.Animation.HandoffBehavior handoffBehavior) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.BeginAnimation(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationTimeline,System.Windows.Media.Animation.HandoffBehavior)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void BeginAnimation(System::Windows::DependencyProperty ^ dp, System::Windows::Media::Animation::AnimationTimeline ^ animation, System::Windows::Media::Animation::HandoffBehavior handoffBehavior);" />
      <MemberSignature Language="F#" Value="abstract member BeginAnimation : System.Windows.DependencyProperty * System.Windows.Media.Animation.AnimationTimeline * System.Windows.Media.Animation.HandoffBehavior -&gt; unit&#xA;override this.BeginAnimation : System.Windows.DependencyProperty * System.Windows.Media.Animation.AnimationTimeline * System.Windows.Media.Animation.HandoffBehavior -&gt; unit" Usage="contentElement.BeginAnimation (dp, animation, handoffBehavior)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Media.Animation.IAnimatable.BeginAnimation(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationTimeline,System.Windows.Media.Animation.HandoffBehavior)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="animation" Type="System.Windows.Media.Animation.AnimationTimeline" />
        <Parameter Name="handoffBehavior" Type="System.Windows.Media.Animation.HandoffBehavior" />
      </Parameters>
      <Docs>
        <param name="dp">
          <span data-ttu-id="f4180-215">要进行动画处理的属性，它被指定为依赖项属性标识符。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-215">The property to animate, which is specified as the dependency property identifier.</span>
          </span>
        </param>
        <param name="animation">
          <span data-ttu-id="f4180-216">要应用的动画的时间线。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-216">The timeline of the animation to be applied.</span>
          </span>
        </param>
        <param name="handoffBehavior">
          <span data-ttu-id="f4180-217">一个枚举值，用来指定新动画如何与已在影响属性值的任何当前（正在运行的）动画进行交互。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-217">A value of the enumeration that specifies how the new animation interacts with any current (running) animations that are already affecting the property value.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f4180-218">为此元素的指定要进行动画处理的属性启动特定的动画，并可以指定当该属性已有正在运行的动画时所要执行的操作。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-218">Starts a specific animation for a specified animated property on this element, with the option of specifying what happens if the property already has a running animation.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4180-219">选中属性进行动画处理，请注意，动画将开始考虑经过动画处理的非动画的起始点以外的第一帧呈现时。</span><span class="sxs-lookup"><span data-stu-id="f4180-219">When you check whether a property is animated, note that the animation will begin and be considered animated when the first frame beyond the non-animated starting point is rendered.</span></span>  
  
 <span data-ttu-id="f4180-220">如果<xref:System.Windows.Media.Animation.Timeline.BeginTime%2A>有关`animation`是`null`，然后删除任何当前动画并保持的属性的当前值。</span><span class="sxs-lookup"><span data-stu-id="f4180-220">If the <xref:System.Windows.Media.Animation.Timeline.BeginTime%2A> for `animation` is `null`, then any current animations are removed and the current value of the property is held.</span></span>  
  
 <span data-ttu-id="f4180-221">如果整个`animation`值是`null`、 从属性中移除所有动画和属性值会恢复为其基值。</span><span class="sxs-lookup"><span data-stu-id="f4180-221">If the entire `animation` value is `null`, all animations are removed from the property and the property value reverts to its base value.</span></span> <span data-ttu-id="f4180-222">但是，不会停止最初关联的动画时间线。</span><span class="sxs-lookup"><span data-stu-id="f4180-222">However, the originally associated animation timeline is not stopped.</span></span> <span data-ttu-id="f4180-223">分配给该时间线中的其他任何动画将继续运行。</span><span class="sxs-lookup"><span data-stu-id="f4180-223">Any other animations assigned to that timeline will continue to run.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CaptureMouse">
      <MemberSignature Language="C#" Value="public bool CaptureMouse ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool CaptureMouse() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.CaptureMouse" />
      <MemberSignature Language="VB.NET" Value="Public Function CaptureMouse () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool CaptureMouse();" />
      <MemberSignature Language="F#" Value="abstract member CaptureMouse : unit -&gt; bool&#xA;override this.CaptureMouse : unit -&gt; bool" Usage="contentElement.CaptureMouse " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.IInputElement.CaptureMouse</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="f4180-224">尝试将鼠标强制捕获到此元素。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-224">Attempts to force capture of the mouse to this element.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f4180-225">如果成功捕获了鼠标，则为 <see langword="true" />；否则为 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-225">
              <see langword="true" /> if the mouse is successfully captured; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4180-226">若要捕获，必须启用一个元素。</span><span class="sxs-lookup"><span data-stu-id="f4180-226">To be captured, an element must be enabled.</span></span> <span data-ttu-id="f4180-227">检查是否<xref:System.Windows.ContentElement.IsEnabled%2A>是`true`在调用之前<xref:System.Windows.ContentElement.CaptureMouse%2A>。</span><span class="sxs-lookup"><span data-stu-id="f4180-227">Check whether <xref:System.Windows.ContentElement.IsEnabled%2A> is `true` before you call <xref:System.Windows.ContentElement.CaptureMouse%2A>.</span></span>  
  
 <span data-ttu-id="f4180-228">如果调用<xref:System.Windows.ContentElement.CaptureMouse%2A>将返回`true`，然后<xref:System.Windows.ContentElement.IsMouseCaptured%2A>也是`true`。</span><span class="sxs-lookup"><span data-stu-id="f4180-228">If calling <xref:System.Windows.ContentElement.CaptureMouse%2A> returns `true`, then <xref:System.Windows.ContentElement.IsMouseCaptured%2A> is also `true`.</span></span>  
  
 <span data-ttu-id="f4180-229">如果调用<xref:System.Windows.ContentElement.CaptureMouse%2A>返回`true`，然后<xref:System.Windows.ContentElement.GotMouseCapture>并<xref:System.Windows.ContentElement.IsMouseCapturedChanged>引发事件，与<xref:System.Windows.RoutedEventArgs.Source%2A?displayProperty=nameWithType>在事件数据报告为元素其中<xref:System.Windows.ContentElement.CaptureMouse%2A>调用方法。</span><span class="sxs-lookup"><span data-stu-id="f4180-229">If calling <xref:System.Windows.ContentElement.CaptureMouse%2A> returns `true`, then the <xref:System.Windows.ContentElement.GotMouseCapture> and <xref:System.Windows.ContentElement.IsMouseCapturedChanged> events are raised, with <xref:System.Windows.RoutedEventArgs.Source%2A?displayProperty=nameWithType> in the event data reported as the element where the <xref:System.Windows.ContentElement.CaptureMouse%2A> method is called.</span></span> <span data-ttu-id="f4180-230">如果强制捕获，您可能会妨碍现有捕获 — 尤其是在使用与拖放鼠标捕获。</span><span class="sxs-lookup"><span data-stu-id="f4180-230">If you force capture, you might interfere with existing captures—especially with captures that relate to drag-and-drop with the mouse.</span></span>  
  
 <span data-ttu-id="f4180-231">若要清除的所有元素的鼠标捕获，请调用<xref:System.Windows.Input.Mouse.Capture%2A?displayProperty=nameWithType>与`element`参数作为提供`null`。</span><span class="sxs-lookup"><span data-stu-id="f4180-231">To clear mouse capture from all elements, call <xref:System.Windows.Input.Mouse.Capture%2A?displayProperty=nameWithType> with the `element` parameter provided as `null`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f4180-232">下面的示例捕获鼠标或释放捕获，基于由该元素是否已捕获鼠标。</span><span class="sxs-lookup"><span data-stu-id="f4180-232">The following example captures the mouse or releases capture, based on whether the mouse is already captured by the element.</span></span> <span data-ttu-id="f4180-233">请注意，此示例将转换为预期的捕获目标元素到<xref:System.Windows.IInputElement>接口，并因此最初调用<xref:System.Windows.IInputElement.CaptureMouse%2A?displayProperty=nameWithType>方法。</span><span class="sxs-lookup"><span data-stu-id="f4180-233">Note that this example casts the prospective capture target element to the <xref:System.Windows.IInputElement> interface, and is thus initially calling the <xref:System.Windows.IInputElement.CaptureMouse%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="f4180-234">将强制转换为<xref:System.Windows.IInputElement>是一种方法，如果您不确定是否想要使用了捕获的元素鼠标是非常有用<xref:System.Windows.UIElement>或<xref:System.Windows.ContentElement>。</span><span class="sxs-lookup"><span data-stu-id="f4180-234">Casting to <xref:System.Windows.IInputElement> is a technique that is useful if you are unsure whether the element you want to have capture the mouse is a <xref:System.Windows.UIElement> or a <xref:System.Windows.ContentElement>.</span></span> <span data-ttu-id="f4180-235">接口 cast 和接口方法调用然后调用相应的特定于类型的 CaptureMouse 实现在内部而无需强制转换为的试用版<xref:System.Windows.UIElement>或<xref:System.Windows.ContentElement>。</span><span class="sxs-lookup"><span data-stu-id="f4180-235">The interface cast and the interface method call then calls the appropriate type-specific CaptureMouse implementation internally without requiring a trial cast to either <xref:System.Windows.UIElement> or <xref:System.Windows.ContentElement>.</span></span> <span data-ttu-id="f4180-236">此相同的强制转换技术也适用于其他成员的<xref:System.Windows.IInputElement>定义，例如的很多与输入相关的事件和其他与输入相关的方法。</span><span class="sxs-lookup"><span data-stu-id="f4180-236">This same casting technique works for other members that <xref:System.Windows.IInputElement> defines, for instance many of the input-related events, and other input-related methods.</span></span>  
  
 [!code-csharp[ContentElementsSmorgasbord#IsMouseCaptured](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml.cs#ismousecaptured)]
 [!code-vb[ContentElementsSmorgasbord#IsMouseCaptured](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContentElementsSmorgasbord/visualbasic/page1.xaml.vb#ismousecaptured)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.ContentElement.IsMouseCaptured" />
      </Docs>
    </Member>
    <Member MemberName="CaptureStylus">
      <MemberSignature Language="C#" Value="public bool CaptureStylus ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool CaptureStylus() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.CaptureStylus" />
      <MemberSignature Language="VB.NET" Value="Public Function CaptureStylus () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool CaptureStylus();" />
      <MemberSignature Language="F#" Value="abstract member CaptureStylus : unit -&gt; bool&#xA;override this.CaptureStylus : unit -&gt; bool" Usage="contentElement.CaptureStylus " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.IInputElement.CaptureStylus</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="f4180-237">尝试将触笔强制捕获到此元素。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-237">Attempts to force capture of the stylus to this element.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f4180-238">如果成功捕获了触笔，则为 <see langword="true" />；否则为 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-238">
              <see langword="true" /> if the stylus is successfully captured; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4180-239">始终根据基础默认触笔设备的默认实现返回`true`。</span><span class="sxs-lookup"><span data-stu-id="f4180-239">The default implementation based on the underlying default stylus device always returns `true`.</span></span> <span data-ttu-id="f4180-240">但是，如果你要扩展提供在输入系统的设备实现的输入的设备，就可以创建的系统可能会返回不同结果的替代触笔设备实现。</span><span class="sxs-lookup"><span data-stu-id="f4180-240">However, if you are extending the input devices that provide the device implementation for the input system, it is possible to create a system with an alternative stylus device implementation that might return different results.</span></span>  
  
 <span data-ttu-id="f4180-241">在元素捕获触笔，它会接收触笔输入，即使在触笔位于其边界外。</span><span class="sxs-lookup"><span data-stu-id="f4180-241">When an element captures the stylus, it receives stylus input even if the stylus is outside its bounds.</span></span> <span data-ttu-id="f4180-242">只有在拖放操作通常捕获触笔。</span><span class="sxs-lookup"><span data-stu-id="f4180-242">The stylus is typically captured only during drag-and-drop operations.</span></span>  
  
 <span data-ttu-id="f4180-243">调用此方法调用一个基础的静态<xref:System.Windows.Input.Stylus>方法<xref:System.Windows.Input.Stylus.Capture%2A>。</span><span class="sxs-lookup"><span data-stu-id="f4180-243">Calling this method calls an underlying static <xref:System.Windows.Input.Stylus> method <xref:System.Windows.Input.Stylus.Capture%2A>.</span></span> <span data-ttu-id="f4180-244">由活动触笔设备实现实现的实际捕获行为。</span><span class="sxs-lookup"><span data-stu-id="f4180-244">The actual capture behavior is implemented by the active stylus device implementation.</span></span>  
  
 <span data-ttu-id="f4180-245">若要捕获，必须启用一个元素。</span><span class="sxs-lookup"><span data-stu-id="f4180-245">To be captured, an element must be enabled.</span></span> <span data-ttu-id="f4180-246">检查是否<xref:System.Windows.ContentElement.IsEnabled%2A>是`true`返回在调用之前<xref:System.Windows.ContentElement.CaptureStylus%2A>。</span><span class="sxs-lookup"><span data-stu-id="f4180-246">Check whether <xref:System.Windows.ContentElement.IsEnabled%2A> is `true` return before you call <xref:System.Windows.ContentElement.CaptureStylus%2A>.</span></span>  
  
 <span data-ttu-id="f4180-247">如果调用<xref:System.Windows.ContentElement.CaptureStylus%2A>将返回`true`，<xref:System.Windows.ContentElement.IsStylusCaptured%2A>也是`true`。</span><span class="sxs-lookup"><span data-stu-id="f4180-247">If calling <xref:System.Windows.ContentElement.CaptureStylus%2A> returns `true`, <xref:System.Windows.ContentElement.IsStylusCaptured%2A> is also `true`.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CaptureTouch">
      <MemberSignature Language="C#" Value="public bool CaptureTouch (System.Windows.Input.TouchDevice touchDevice);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool CaptureTouch(class System.Windows.Input.TouchDevice touchDevice) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.CaptureTouch(System.Windows.Input.TouchDevice)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool CaptureTouch(System::Windows::Input::TouchDevice ^ touchDevice);" />
      <MemberSignature Language="F#" Value="member this.CaptureTouch : System.Windows.Input.TouchDevice -&gt; bool" Usage="contentElement.CaptureTouch touchDevice" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="touchDevice" Type="System.Windows.Input.TouchDevice" />
      </Parameters>
      <Docs>
        <param name="touchDevice">
          <span data-ttu-id="f4180-248">要捕获的设备。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-248">The device to capture.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f4180-249">尝试将触摸屏输入强制捕获到此元素。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-249">Attempts to force capture of a touch to this element.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f4180-250">如果将指定触摸屏输入捕获到此元素，则为 <see langword="true" /> ；否则为 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-250">
              <see langword="true" /> if the specified touch is captured to this element; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4180-251"><xref:System.Windows.ContentElement.CaptureTouch%2A> 将返回`false`如果<xref:System.Windows.Input.TouchDevice>当前捕获到另一个元素。</span><span class="sxs-lookup"><span data-stu-id="f4180-251"><xref:System.Windows.ContentElement.CaptureTouch%2A> will return `false` if the <xref:System.Windows.Input.TouchDevice> is currently captured to another element.</span></span>  
  
 <span data-ttu-id="f4180-252">如果<xref:System.Windows.ContentElement.CaptureTouch%2A>将返回`true`，则<xref:System.Windows.ContentElement.GotTouchCapture>引发事件。</span><span class="sxs-lookup"><span data-stu-id="f4180-252">If <xref:System.Windows.ContentElement.CaptureTouch%2A> returns `true`, then the <xref:System.Windows.ContentElement.GotTouchCapture> event is raised.</span></span>  
  
 <span data-ttu-id="f4180-253">若要释放的单个触摸屏输入从此元素的捕获，请使用<xref:System.Windows.ContentElement.ReleaseTouchCapture%2A>方法并指定要发布的触摸设备。</span><span class="sxs-lookup"><span data-stu-id="f4180-253">To release capture of a single touch from this element, use the <xref:System.Windows.ContentElement.ReleaseTouchCapture%2A> method and specify the touch device to release.</span></span> <span data-ttu-id="f4180-254">若要释放此元素上的所有触摸，使用<xref:System.Windows.ContentElement.ReleaseAllTouchCaptures%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="f4180-254">To release all touches from this element, use the <xref:System.Windows.ContentElement.ReleaseAllTouchCaptures%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f4180-255">
            <paramref name="touchDevice" /> 为 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-255">
              <paramref name="touchDevice" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <altmember cref="M:System.Windows.Input.TouchDevice.Capture(System.Windows.IInputElement)" />
      </Docs>
    </Member>
    <Member MemberName="CommandBindings">
      <MemberSignature Language="C#" Value="public System.Windows.Input.CommandBindingCollection CommandBindings { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Input.CommandBindingCollection CommandBindings" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.CommandBindings" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CommandBindings As CommandBindingCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Input::CommandBindingCollection ^ CommandBindings { System::Windows::Input::CommandBindingCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CommandBindings : System.Windows.Input.CommandBindingCollection" Usage="System.Windows.ContentElement.CommandBindings" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Content)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Input.CommandBindingCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f4180-256">获取与此元素关联的 <see cref="T:System.Windows.Input.CommandBinding" /> 对象的集合。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-256">Gets a collection of <see cref="T:System.Windows.Input.CommandBinding" /> objects that are associated with this element.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="f4180-257">所有 <see cref="T:System.Windows.Input.CommandBinding" /> 对象的集合。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-257">The collection of all <see cref="T:System.Windows.Input.CommandBinding" /> objects.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4180-258">一个<xref:System.Windows.Input.CommandBinding>启用此元素的特定命令的命令处理并声明命令、 其事件和由此元素附加的处理程序之间的链接。</span><span class="sxs-lookup"><span data-stu-id="f4180-258">A <xref:System.Windows.Input.CommandBinding> enables command handling of a specific command for this element and declares the linkage between a command, its events, and the handlers that are attached by this element.</span></span>  
  
 <span data-ttu-id="f4180-259">另一种典型的方法来填充<xref:System.Windows.ContentElement.CommandBindings%2A>集合是使用<xref:System.Windows.Input.CommandManager>方法以编程方式。</span><span class="sxs-lookup"><span data-stu-id="f4180-259">Another typical way to populate the <xref:System.Windows.ContentElement.CommandBindings%2A> collection is to use <xref:System.Windows.Input.CommandManager> methods programmatically.</span></span>  
  
<a name="xamlPropertyElementUsage_CommandBindings"></a>   
## <a name="xaml-property-element-usage"></a><span data-ttu-id="f4180-260">XAML 属性元素用法</span><span class="sxs-lookup"><span data-stu-id="f4180-260">XAML Property Element Usage</span></span>  
  
```  
<object>  
  <object.CommandBindings>  
    oneOrMoreCommandBindings  </object.CommandBindings>  
</object>  
```  
  
<a name="xamlValues_CommandBindings"></a>   
## <a name="xaml-values"></a><span data-ttu-id="f4180-261">XAML 值</span><span class="sxs-lookup"><span data-stu-id="f4180-261">XAML Values</span></span>  
 <span data-ttu-id="f4180-262">*oneOrMoreCommandBindings*</span><span class="sxs-lookup"><span data-stu-id="f4180-262">*oneOrMoreCommandBindings*</span></span>  
 <span data-ttu-id="f4180-263">一个或多个<xref:System.Windows.Input.CommandBinding>元素。</span><span class="sxs-lookup"><span data-stu-id="f4180-263">One or more <xref:System.Windows.Input.CommandBinding> elements.</span></span> <span data-ttu-id="f4180-264">其中每项功能都应有<xref:System.Windows.Input.CommandBinding.Command%2A>属性设置为已知命令和属性设置为<xref:System.Windows.Input.CommandBinding.CanExecute>和<xref:System.Windows.Input.CommandBinding.Executed>的处理程序实现。</span><span class="sxs-lookup"><span data-stu-id="f4180-264">Each of these should have a <xref:System.Windows.Input.CommandBinding.Command%2A> attribute set to a known command, and attributes set for the <xref:System.Windows.Input.CommandBinding.CanExecute> and <xref:System.Windows.Input.CommandBinding.Executed> handler implementations.</span></span> <span data-ttu-id="f4180-265">有关详细信息，请参阅 <xref:System.Windows.Input.CommandBinding>。</span><span class="sxs-lookup"><span data-stu-id="f4180-265">For more information see <xref:System.Windows.Input.CommandBinding>.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Input.CommandManager" />
      </Docs>
    </Member>
    <Member MemberName="DragEnter">
      <MemberSignature Language="C#" Value="public event System.Windows.DragEventHandler DragEnter;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DragEventHandler DragEnter" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.DragEnter" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DragEnter As DragEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DragEventHandler ^ DragEnter;" />
      <MemberSignature Language="F#" Value="member this.DragEnter : System.Windows.DragEventHandler " Usage="member this.DragEnter : System.Windows.DragEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DragEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f4180-266">在输入系统报告出现以此元素为拖动目标的基础拖动事件时发生。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-266">Occurs when the input system reports an underlying drag event with this element as the drag target.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4180-267">此事件创建一个别名<xref:System.Windows.DragDrop.DragEnter?displayProperty=nameWithType>附加事件对于此类，以便<xref:System.Windows.ContentElement.DragEnter?displayProperty=nameWithType>属于类的成员列出时<xref:System.Windows.ContentElement>作为基元素继承。</span><span class="sxs-lookup"><span data-stu-id="f4180-267">This event creates an alias for the <xref:System.Windows.DragDrop.DragEnter?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.DragEnter?displayProperty=nameWithType> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="f4180-268">事件处理程序附加到<xref:System.Windows.ContentElement.DragEnter>事件附加到基础<xref:System.Windows.DragDrop.DragEnter?displayProperty=nameWithType>附加事件，并接收相同的事件数据实例。</span><span class="sxs-lookup"><span data-stu-id="f4180-268">Event handlers that are attached to the <xref:System.Windows.ContentElement.DragEnter> event are attached to the underlying <xref:System.Windows.DragDrop.DragEnter?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
<a name="routedEventInfo_DragEnter"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="f4180-269">路由事件信息</span><span class="sxs-lookup"><span data-stu-id="f4180-269">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="f4180-270">标识符字段</span><span class="sxs-lookup"><span data-stu-id="f4180-270">Identifier field</span></span>|<xref:System.Windows.ContentElement.DragEnterEvent>|  
|<span data-ttu-id="f4180-271">路由策略</span><span class="sxs-lookup"><span data-stu-id="f4180-271">Routing strategy</span></span>|<span data-ttu-id="f4180-272">浮升</span><span class="sxs-lookup"><span data-stu-id="f4180-272">Bubbling</span></span>|  
|<span data-ttu-id="f4180-273">委托</span><span class="sxs-lookup"><span data-stu-id="f4180-273">Delegate</span></span>|<xref:System.Windows.DragEventHandler>|  
  
-   <span data-ttu-id="f4180-274">相应的隧道事件是<xref:System.Windows.ContentElement.PreviewDragEnter>。</span><span class="sxs-lookup"><span data-stu-id="f4180-274">The corresponding tunneling event is <xref:System.Windows.ContentElement.PreviewDragEnter>.</span></span>  
  
-   <span data-ttu-id="f4180-275">重写<xref:System.Windows.ContentElement.OnDragEnter%2A>实现类处理此事件在派生类中。</span><span class="sxs-lookup"><span data-stu-id="f4180-275">Override <xref:System.Windows.ContentElement.OnDragEnter%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.DragLeave" />
        <altmember cref="E:System.Windows.ContentElement.DragOver" />
      </Docs>
    </Member>
    <Member MemberName="DragEnterEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent DragEnterEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent DragEnterEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.DragEnterEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly DragEnterEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ DragEnterEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable DragEnterEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.DragEnterEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f4180-276">标识 <see cref="E:System.Windows.ContentElement.DragEnter" /> 路由事件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-276">Identifies the <see cref="E:System.Windows.ContentElement.DragEnter" /> routed event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4180-277">在注册路由事件时创建路由事件标识符。</span><span class="sxs-lookup"><span data-stu-id="f4180-277">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="f4180-278">这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。</span><span class="sxs-lookup"><span data-stu-id="f4180-278">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="f4180-279">可以使用这些标识符添加类处理程序。</span><span class="sxs-lookup"><span data-stu-id="f4180-279">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="f4180-280">有关注册路由事件的更多信息，请参见 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="f4180-280">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="f4180-281">有关使用路由事件标识符添加类处理程序的更多信息，请参见 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="f4180-281">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DragLeave">
      <MemberSignature Language="C#" Value="public event System.Windows.DragEventHandler DragLeave;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DragEventHandler DragLeave" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.DragLeave" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DragLeave As DragEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DragEventHandler ^ DragLeave;" />
      <MemberSignature Language="F#" Value="member this.DragLeave : System.Windows.DragEventHandler " Usage="member this.DragLeave : System.Windows.DragEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DragEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f4180-282">在输入系统报告出现以此元素为拖动起点的基础拖动事件时发生。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-282">Occurs when the input system reports an underlying drag event with this element as the drag origin.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4180-283">此事件创建一个别名<xref:System.Windows.DragDrop.DragLeave?displayProperty=nameWithType>附加的此类事件，以便<xref:System.Windows.ContentElement.DragLeave?displayProperty=nameWithType>属于类的成员列出时<xref:System.Windows.ContentElement>作为基元素继承。</span><span class="sxs-lookup"><span data-stu-id="f4180-283">This event creates an alias for the <xref:System.Windows.DragDrop.DragLeave?displayProperty=nameWithType> attached event for this class so that <xref:System.Windows.ContentElement.DragLeave?displayProperty=nameWithType> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="f4180-284">事件处理程序附加到<xref:System.Windows.ContentElement.DragLeave>事件附加到基础<xref:System.Windows.DragDrop.DragLeave?displayProperty=nameWithType>附加事件，并接收相同的事件数据实例。</span><span class="sxs-lookup"><span data-stu-id="f4180-284">Event handlers that are attached to the <xref:System.Windows.ContentElement.DragLeave> event are attached to the underlying <xref:System.Windows.DragDrop.DragLeave?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
<a name="routedEventInfo_DragLeave"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="f4180-285">路由事件信息</span><span class="sxs-lookup"><span data-stu-id="f4180-285">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="f4180-286">标识符字段</span><span class="sxs-lookup"><span data-stu-id="f4180-286">Identifier field</span></span>|<xref:System.Windows.ContentElement.DragLeaveEvent>|  
|<span data-ttu-id="f4180-287">路由策略</span><span class="sxs-lookup"><span data-stu-id="f4180-287">Routing strategy</span></span>|<span data-ttu-id="f4180-288">浮升</span><span class="sxs-lookup"><span data-stu-id="f4180-288">Bubbling</span></span>|  
|<span data-ttu-id="f4180-289">委托</span><span class="sxs-lookup"><span data-stu-id="f4180-289">Delegate</span></span>|<xref:System.Windows.DragEventHandler>|  
  
-   <span data-ttu-id="f4180-290">相应的隧道事件是<xref:System.Windows.DragDrop.PreviewDragLeave>。</span><span class="sxs-lookup"><span data-stu-id="f4180-290">The corresponding tunneling event is <xref:System.Windows.DragDrop.PreviewDragLeave>.</span></span>  
  
-   <span data-ttu-id="f4180-291">重写<xref:System.Windows.ContentElement.OnDragLeave%2A>实现类处理此事件在派生类中。</span><span class="sxs-lookup"><span data-stu-id="f4180-291">Override <xref:System.Windows.ContentElement.OnDragLeave%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.DragEnter" />
        <altmember cref="E:System.Windows.ContentElement.DragOver" />
        <altmember cref="E:System.Windows.ContentElement.GiveFeedback" />
      </Docs>
    </Member>
    <Member MemberName="DragLeaveEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent DragLeaveEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent DragLeaveEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.DragLeaveEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly DragLeaveEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ DragLeaveEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable DragLeaveEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.DragLeaveEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f4180-292">标识 <see cref="E:System.Windows.ContentElement.DragLeave" /> 路由事件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-292">Identifies the <see cref="E:System.Windows.ContentElement.DragLeave" /> routed event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4180-293">在注册路由事件时创建路由事件标识符。</span><span class="sxs-lookup"><span data-stu-id="f4180-293">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="f4180-294">这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。</span><span class="sxs-lookup"><span data-stu-id="f4180-294">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="f4180-295">可以使用这些标识符添加类处理程序。</span><span class="sxs-lookup"><span data-stu-id="f4180-295">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="f4180-296">有关注册路由事件的更多信息，请参见 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="f4180-296">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="f4180-297">有关使用路由事件标识符添加类处理程序的更多信息，请参见 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="f4180-297">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DragOver">
      <MemberSignature Language="C#" Value="public event System.Windows.DragEventHandler DragOver;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DragEventHandler DragOver" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.DragOver" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DragOver As DragEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DragEventHandler ^ DragOver;" />
      <MemberSignature Language="F#" Value="member this.DragOver : System.Windows.DragEventHandler " Usage="member this.DragOver : System.Windows.DragEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DragEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f4180-298">在输入系统报告出现以此元素为可能放置目标的基础拖动事件时发生。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-298">Occurs when the input system reports an underlying drag event with this element as the potential drop target.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4180-299">即使拖动源自于的元素边界时发生此事件。</span><span class="sxs-lookup"><span data-stu-id="f4180-299">This event occurs even if the drag originates in the element bounds.</span></span> <span data-ttu-id="f4180-300">如果拖动边界之外启动，然后将移动内容，也会引发此事件，以及<xref:System.Windows.ContentElement.DragEnter>和相关的预览事件。</span><span class="sxs-lookup"><span data-stu-id="f4180-300">If the drag starts outside the bounds and then moves inside, this event is also raised, as well as <xref:System.Windows.ContentElement.DragEnter> and related preview events.</span></span>  
  
 <span data-ttu-id="f4180-301">此事件创建一个别名<xref:System.Windows.DragDrop.DragOver?displayProperty=nameWithType>附加的此类事件，以便<xref:System.Windows.ContentElement.DragOver?displayProperty=nameWithType>属于类的成员列出时<xref:System.Windows.ContentElement>作为基元素继承。</span><span class="sxs-lookup"><span data-stu-id="f4180-301">This event creates an alias for the <xref:System.Windows.DragDrop.DragOver?displayProperty=nameWithType> attached event for this class so that <xref:System.Windows.ContentElement.DragOver?displayProperty=nameWithType> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="f4180-302">事件处理程序附加到<xref:System.Windows.ContentElement.DragOver>事件附加到基础<xref:System.Windows.DragDrop.DragOver?displayProperty=nameWithType>附加事件，并接收相同的事件数据实例。</span><span class="sxs-lookup"><span data-stu-id="f4180-302">Event handlers that are attached to the <xref:System.Windows.ContentElement.DragOver> event are attached to the underlying <xref:System.Windows.DragDrop.DragOver?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
<a name="routedEventInfo_DragOver"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="f4180-303">路由事件信息</span><span class="sxs-lookup"><span data-stu-id="f4180-303">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="f4180-304">标识符字段</span><span class="sxs-lookup"><span data-stu-id="f4180-304">Identifier field</span></span>|<xref:System.Windows.ContentElement.DragOverEvent>|  
|<span data-ttu-id="f4180-305">路由策略</span><span class="sxs-lookup"><span data-stu-id="f4180-305">Routing strategy</span></span>|<span data-ttu-id="f4180-306">浮升</span><span class="sxs-lookup"><span data-stu-id="f4180-306">Bubbling</span></span>|  
|<span data-ttu-id="f4180-307">委托</span><span class="sxs-lookup"><span data-stu-id="f4180-307">Delegate</span></span>|<xref:System.Windows.DragEventHandler>|  
  
-   <span data-ttu-id="f4180-308">相应的隧道事件是<xref:System.Windows.DragDrop.PreviewDragOver>。</span><span class="sxs-lookup"><span data-stu-id="f4180-308">The corresponding tunneling event is <xref:System.Windows.DragDrop.PreviewDragOver>.</span></span>  
  
-   <span data-ttu-id="f4180-309">重写<xref:System.Windows.ContentElement.OnDragOver%2A>实现类处理此事件在派生类中。</span><span class="sxs-lookup"><span data-stu-id="f4180-309">Override <xref:System.Windows.ContentElement.OnDragOver%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.DragEnter" />
        <altmember cref="E:System.Windows.ContentElement.DragLeave" />
        <altmember cref="E:System.Windows.ContentElement.Drop" />
      </Docs>
    </Member>
    <Member MemberName="DragOverEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent DragOverEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent DragOverEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.DragOverEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly DragOverEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ DragOverEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable DragOverEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.DragOverEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f4180-310">标识 <see cref="E:System.Windows.ContentElement.DragOver" /> 路由事件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-310">Identifies the <see cref="E:System.Windows.ContentElement.DragOver" /> routed event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4180-311">在注册路由事件时创建路由事件标识符。</span><span class="sxs-lookup"><span data-stu-id="f4180-311">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="f4180-312">这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。</span><span class="sxs-lookup"><span data-stu-id="f4180-312">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="f4180-313">可以使用这些标识符添加类处理程序。</span><span class="sxs-lookup"><span data-stu-id="f4180-313">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="f4180-314">有关注册路由事件的更多信息，请参见 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="f4180-314">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="f4180-315">有关使用路由事件标识符添加类处理程序的更多信息，请参见 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="f4180-315">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Drop">
      <MemberSignature Language="C#" Value="public event System.Windows.DragEventHandler Drop;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DragEventHandler Drop" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.Drop" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Drop As DragEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DragEventHandler ^ Drop;" />
      <MemberSignature Language="F#" Value="member this.Drop : System.Windows.DragEventHandler " Usage="member this.Drop : System.Windows.DragEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DragEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f4180-316">在输入系统报告出现将此元素作为放置目标的基础放置事件时发生。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-316">Occurs when the input system reports an underlying drop event with this element as the drop target.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4180-317">此事件创建一个别名<xref:System.Windows.DragDrop.Drop?displayProperty=nameWithType>附加的此类事件，以便<xref:System.Windows.ContentElement.Drop?displayProperty=nameWithType>属于类的成员列出时<xref:System.Windows.ContentElement>作为基元素继承。</span><span class="sxs-lookup"><span data-stu-id="f4180-317">This event creates an alias for the <xref:System.Windows.DragDrop.Drop?displayProperty=nameWithType> attached event for this class so that <xref:System.Windows.ContentElement.Drop?displayProperty=nameWithType> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="f4180-318">事件处理程序附加到<xref:System.Windows.ContentElement.Drop>事件附加到基础<xref:System.Windows.DragDrop.Drop?displayProperty=nameWithType>附加事件，并接收相同的事件数据实例。</span><span class="sxs-lookup"><span data-stu-id="f4180-318">Event handlers that are attached to the <xref:System.Windows.ContentElement.Drop> event are attached to the underlying <xref:System.Windows.DragDrop.Drop?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
<a name="routedEventInfo_Drop"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="f4180-319">路由事件信息</span><span class="sxs-lookup"><span data-stu-id="f4180-319">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="f4180-320">标识符字段</span><span class="sxs-lookup"><span data-stu-id="f4180-320">Identifier field</span></span>|<xref:System.Windows.ContentElement.DropEvent>|  
|<span data-ttu-id="f4180-321">路由策略</span><span class="sxs-lookup"><span data-stu-id="f4180-321">Routing strategy</span></span>|<span data-ttu-id="f4180-322">浮升</span><span class="sxs-lookup"><span data-stu-id="f4180-322">Bubbling</span></span>|  
|<span data-ttu-id="f4180-323">委托</span><span class="sxs-lookup"><span data-stu-id="f4180-323">Delegate</span></span>|<xref:System.Windows.DragEventHandler>|  
  
-   <span data-ttu-id="f4180-324">相应的隧道事件是<xref:System.Windows.ContentElement.PreviewDrop>。</span><span class="sxs-lookup"><span data-stu-id="f4180-324">The corresponding tunneling event is <xref:System.Windows.ContentElement.PreviewDrop>.</span></span>  
  
-   <span data-ttu-id="f4180-325">重写<xref:System.Windows.ContentElement.OnDrop%2A>实现类处理此事件在派生类中。</span><span class="sxs-lookup"><span data-stu-id="f4180-325">Override <xref:System.Windows.ContentElement.OnDrop%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.DragOver" />
        <altmember cref="E:System.Windows.ContentElement.MouseLeftButtonUp" />
      </Docs>
    </Member>
    <Member MemberName="DropEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent DropEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent DropEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.DropEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly DropEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ DropEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable DropEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.DropEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f4180-326">标识 <see cref="E:System.Windows.ContentElement.Drop" /> 路由事件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-326">Identifies the <see cref="E:System.Windows.ContentElement.Drop" /> routed event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4180-327">在注册路由事件时创建路由事件标识符。</span><span class="sxs-lookup"><span data-stu-id="f4180-327">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="f4180-328">这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。</span><span class="sxs-lookup"><span data-stu-id="f4180-328">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="f4180-329">可以使用这些标识符添加类处理程序。</span><span class="sxs-lookup"><span data-stu-id="f4180-329">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="f4180-330">有关注册路由事件的更多信息，请参见 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="f4180-330">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="f4180-331">有关使用路由事件标识符添加类处理程序的更多信息，请参见 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="f4180-331">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Focus">
      <MemberSignature Language="C#" Value="public bool Focus ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Focus() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.Focus" />
      <MemberSignature Language="VB.NET" Value="Public Function Focus () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Focus();" />
      <MemberSignature Language="F#" Value="abstract member Focus : unit -&gt; bool&#xA;override this.Focus : unit -&gt; bool" Usage="contentElement.Focus " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.IInputElement.Focus</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="f4180-332">尝试将焦点设定到此元素上。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-332">Attempts to set focus to this element.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f4180-333">如果键盘焦点可设定到此元素上，则为 <see langword="true" />；如果此方法调用未强制设置焦点，则为 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-333">
              <see langword="true" /> if keyboard focus could be set to this element; <see langword="false" /> if this method call did not force focus.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4180-334">可获得焦点，<xref:System.Windows.ContentElement.Focusable%2A>并<xref:System.Windows.ContentElement.IsEnabled%2A>都必须`true`。</span><span class="sxs-lookup"><span data-stu-id="f4180-334">To be focusable, <xref:System.Windows.ContentElement.Focusable%2A> and <xref:System.Windows.ContentElement.IsEnabled%2A> must both be `true`.</span></span> <span data-ttu-id="f4180-335">请注意，几乎所有<xref:System.Windows.ContentElement>派生的类不是<xref:System.Windows.ContentElement.Focusable%2A>默认情况下。</span><span class="sxs-lookup"><span data-stu-id="f4180-335">Note that nearly all <xref:System.Windows.ContentElement> derived classes are not <xref:System.Windows.ContentElement.Focusable%2A> by default.</span></span>  
  
 <span data-ttu-id="f4180-336">即使元素是特定树中的可获得焦点并已启用，事件处理，（例如，针对复合控件） 可能会响应预览焦点事件通过不允许焦点，因此此方法将返回`false`。</span><span class="sxs-lookup"><span data-stu-id="f4180-336">Even if an element is focusable and enabled, event handling within a specific tree, (such as for a composite control) might respond to the preview focus events by not allowing focus there, thus this method would return `false`.</span></span>  
  
 <span data-ttu-id="f4180-337">焦点通常受两个不同的概念： 键盘焦点和逻辑焦点，并不总是相同。</span><span class="sxs-lookup"><span data-stu-id="f4180-337">Focus in general is governed by two separate concepts: keyboard focus and logical focus, which are not always identical.</span></span> <span data-ttu-id="f4180-338">此方法设置逻辑焦点。</span><span class="sxs-lookup"><span data-stu-id="f4180-338">This method sets the logical focus.</span></span> <span data-ttu-id="f4180-339">没有专门; 设置键盘焦点的编程方法键盘焦点取决于用户输入。</span><span class="sxs-lookup"><span data-stu-id="f4180-339">There is no programmatic means to set keyboard focus specifically; keyboard focus is determined by user input.</span></span> <span data-ttu-id="f4180-340">有关详细信息，请参阅[焦点概述](~/docs/framework/wpf/advanced/focus-overview.md)并[输入概述](~/docs/framework/wpf/advanced/input-overview.md)。</span><span class="sxs-lookup"><span data-stu-id="f4180-340">For more information, see [Focus Overview](~/docs/framework/wpf/advanced/focus-overview.md) and [Input Overview](~/docs/framework/wpf/advanced/input-overview.md).</span></span>  
  
 <span data-ttu-id="f4180-341">如果调用<xref:System.Windows.ContentElement.Focus%2A>将返回`true`，<xref:System.Windows.ContentElement.IsKeyboardFocused%2A>并<xref:System.Windows.ContentElement.IsKeyboardFocusWithin%2A>还有`true`。</span><span class="sxs-lookup"><span data-stu-id="f4180-341">If calling <xref:System.Windows.ContentElement.Focus%2A> returns `true`, <xref:System.Windows.ContentElement.IsKeyboardFocused%2A> and <xref:System.Windows.ContentElement.IsKeyboardFocusWithin%2A> are also `true`.</span></span>  
  
 <span data-ttu-id="f4180-342">如果相关的属性不是已经`true`，则在调用<xref:System.Windows.ContentElement.Focus%2A>，按以下顺序引发一个或多个以下事件： <xref:System.Windows.ContentElement.PreviewLostKeyboardFocus>， <xref:System.Windows.ContentElement.PreviewGotKeyboardFocus> （来源为新的焦点目标）， <xref:System.Windows.ContentElement.IsKeyboardFocusedChanged>， <xref:System.Windows.ContentElement.IsKeyboardFocusWithinChanged>，<xref:System.Windows.ContentElement.LostKeyboardFocus>， <xref:System.Windows.ContentElement.GotKeyboardFocus> （来源为新的焦点目标）。</span><span class="sxs-lookup"><span data-stu-id="f4180-342">If the related properties are not already `true`, when you call <xref:System.Windows.ContentElement.Focus%2A>, one or more of the following events are raised in the following order: <xref:System.Windows.ContentElement.PreviewLostKeyboardFocus>, <xref:System.Windows.ContentElement.PreviewGotKeyboardFocus> (source is the new focus target), <xref:System.Windows.ContentElement.IsKeyboardFocusedChanged>, <xref:System.Windows.ContentElement.IsKeyboardFocusWithinChanged>, <xref:System.Windows.ContentElement.LostKeyboardFocus>, <xref:System.Windows.ContentElement.GotKeyboardFocus> (source is the new focus target).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f4180-343">以下示例查找指定的名为文档中的段落是页面加载的事件处理程序，并将焦点设置到它。</span><span class="sxs-lookup"><span data-stu-id="f4180-343">The following example is a page-loaded event handler that finds a specified named paragraph in the document and sets focus to it.</span></span> <span data-ttu-id="f4180-344">段落不是默认设置。 可获得焦点此特定段落已应用了样式的 （未显示） 使用的样式<xref:System.Windows.Setter>以使其可获得焦点。</span><span class="sxs-lookup"><span data-stu-id="f4180-344">Paragraphs are not focusable by default; this particular paragraph had a style applied (not shown) that used a style <xref:System.Windows.Setter> to make it focusable.</span></span>  
  
 [!code-csharp[ContentElementsSmorgasbord#Focus](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml.cs#focus)]
 [!code-vb[ContentElementsSmorgasbord#Focus](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContentElementsSmorgasbord/visualbasic/page1.xaml.vb#focus)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.ContentElement.MoveFocus(System.Windows.Input.TraversalRequest)" />
        <altmember cref="P:System.Windows.ContentElement.Focusable" />
      </Docs>
    </Member>
    <Member MemberName="Focusable">
      <MemberSignature Language="C#" Value="public bool Focusable { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Focusable" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.Focusable" />
      <MemberSignature Language="VB.NET" Value="Public Property Focusable As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Focusable { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Focusable : bool with get, set" Usage="System.Windows.ContentElement.Focusable" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.IInputElement.Focusable</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f4180-345">获取或设置一个值，该值指示元素能否得到焦点。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-345">Gets or sets a value that indicates whether the element can receive focus.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="f4180-346">如果该元素可获得焦点，则为 <see langword="true" />；否则为 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-346">
              <see langword="true" /> if the element is focusable; otherwise <see langword="false" />.</span>
          </span>
          <span data-ttu-id="f4180-347">默认值为 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-347">The default is <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4180-348">具有焦点的元素接收键盘输入。</span><span class="sxs-lookup"><span data-stu-id="f4180-348">Only the focused element receives keyboard input.</span></span>  
  
 <span data-ttu-id="f4180-349">某些派生的类可能会替代此依赖属性元数据，以便派生的类是默认情况下可获得焦点。</span><span class="sxs-lookup"><span data-stu-id="f4180-349">Certain derived classes might override metadata for this dependency property such that the derived class is focusable by default.</span></span>  
  
 <span data-ttu-id="f4180-350">当由继承<xref:System.Windows.Documents.Hyperlink>或其派生的类，<xref:System.Windows.Documents.Hyperlink>重写此依赖项属性的元数据，并将此属性才能为默认值重新定义`true`。</span><span class="sxs-lookup"><span data-stu-id="f4180-350">When inherited by <xref:System.Windows.Documents.Hyperlink> or its derived classes, <xref:System.Windows.Documents.Hyperlink> overrides the metadata for this dependency property and redefines the default value of this property to be `true`.</span></span>  
  
<a name="dependencyPropertyInfo_Focusable"></a>   
## <a name="dependency-property-information"></a><span data-ttu-id="f4180-351">依赖项属性信息</span><span class="sxs-lookup"><span data-stu-id="f4180-351">Dependency Property Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="f4180-352">标识符字段</span><span class="sxs-lookup"><span data-stu-id="f4180-352">Identifier field</span></span>|<xref:System.Windows.ContentElement.FocusableProperty>|  
|<span data-ttu-id="f4180-353">元数据属性设置为 `true`</span><span class="sxs-lookup"><span data-stu-id="f4180-353">Metadata properties set to `true`</span></span>|<span data-ttu-id="f4180-354">无</span><span class="sxs-lookup"><span data-stu-id="f4180-354">None</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="f4180-355">下面的示例创建一种使方式<xref:System.Windows.Documents.Paragraph>默认情况下可获得焦点并接收焦点时为其提供可视行为。</span><span class="sxs-lookup"><span data-stu-id="f4180-355">The following example creates a style that makes a <xref:System.Windows.Documents.Paragraph> focusable by default and gives it a visual behavior when it receives focus.</span></span>  
  
 [!code-xaml[ContentElementsSmorgasbord#Focusable](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml#focusable)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <span data-ttu-id="f4180-356">从类派生时<see cref="T:System.Windows.ContentElement" />，请考虑是希望您获得焦点，因为默认情况下它将不能获得焦点的元素。</span>
            <span class="sxs-lookup">
              <span data-stu-id="f4180-356">When you derive from <see cref="T:System.Windows.ContentElement" />, consider whether you want your element to be focusable, because by default it will not be focusable.</span>
            </span>
            <span data-ttu-id="f4180-357">如果您希望您可获得焦点的元素，重写此属性在派生的类静态构造函数中的元数据，如下所示：</span>
            <span class="sxs-lookup">
              <span data-stu-id="f4180-357">If you want your element to be focusable, override the metadata for this property in your derived class static constructor as follows:</span>
            </span>
            <span data-ttu-id="f4180-358">[！ 代码 csharp[CorePseudocode #UIElementShortOverride](~/samples/snippets/csharp/VS_Snippets_Wpf/CorePseudocode/CSharp/corepseudocode.cs#uielementshortoverride)] [！ 代码 vb[CorePseudocode #UIElementShortOverride](~/samples/snippets/visualbasic/VS_Snippets_Wpf/CorePseudocode/visualbasic/corepseudocode.vb#uielementshortoverride)]</span>
            <span class="sxs-lookup">
              <span data-stu-id="f4180-358">[!code-csharp[CorePseudocode#UIElementShortOverride](~/samples/snippets/csharp/VS_Snippets_Wpf/CorePseudocode/CSharp/corepseudocode.cs#uielementshortoverride)] [!code-vb[CorePseudocode#UIElementShortOverride](~/samples/snippets/visualbasic/VS_Snippets_Wpf/CorePseudocode/visualbasic/corepseudocode.vb#uielementshortoverride)]</span>
            </span>
            <span data-ttu-id="f4180-359">其中<paramref name="myElement" />是会重写元数据值的类型的类名称。</span>
            <span class="sxs-lookup">
              <span data-stu-id="f4180-359">where <paramref name="myElement" /> is the class name of the type that you are overriding the metadata value on.</span>
            </span>
          </para>
        </block>
        <altmember cref="M:System.Windows.FrameworkElement.MoveFocus(System.Windows.Input.TraversalRequest)" />
        <altmember cref="E:System.Windows.UIElement.GotKeyboardFocus" />
        <altmember cref="E:System.Windows.UIElement.LostKeyboardFocus" />
      </Docs>
    </Member>
    <Member MemberName="FocusableChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.DependencyPropertyChangedEventHandler FocusableChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DependencyPropertyChangedEventHandler FocusableChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.FocusableChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event FocusableChanged As DependencyPropertyChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DependencyPropertyChangedEventHandler ^ FocusableChanged;" />
      <MemberSignature Language="F#" Value="member this.FocusableChanged : System.Windows.DependencyPropertyChangedEventHandler " Usage="member this.FocusableChanged : System.Windows.DependencyPropertyChangedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f4180-360">当 <see cref="P:System.Windows.ContentElement.Focusable" /> 属性的值更改时发生。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-360">Occurs when the value of the <see cref="P:System.Windows.ContentElement.Focusable" /> property changes.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4180-361">此成员是[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]事件、 不是路由的事件。</span><span class="sxs-lookup"><span data-stu-id="f4180-361">This member is a [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] event, not a routed event.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.ContentElement.Focusable" />
      </Docs>
    </Member>
    <Member MemberName="FocusableProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty FocusableProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty FocusableProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.FocusableProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly FocusableProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ FocusableProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable FocusableProperty : System.Windows.DependencyProperty" Usage="System.Windows.ContentElement.FocusableProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f4180-362">标识 <see cref="P:System.Windows.ContentElement.Focusable" /> 依赖项属性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-362">Identifies the <see cref="P:System.Windows.ContentElement.Focusable" /> dependency property.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetAnimationBaseValue">
      <MemberSignature Language="C#" Value="public object GetAnimationBaseValue (System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object GetAnimationBaseValue(class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.GetAnimationBaseValue(System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAnimationBaseValue (dp As DependencyProperty) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ GetAnimationBaseValue(System::Windows::DependencyProperty ^ dp);" />
      <MemberSignature Language="F#" Value="abstract member GetAnimationBaseValue : System.Windows.DependencyProperty -&gt; obj&#xA;override this.GetAnimationBaseValue : System.Windows.DependencyProperty -&gt; obj" Usage="contentElement.GetAnimationBaseValue dp" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Media.Animation.IAnimatable.GetAnimationBaseValue(System.Windows.DependencyProperty)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="dp">
          <span data-ttu-id="f4180-363">要选中的依赖属性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-363">The.dependency property to check.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f4180-364">为此元素上的指定属性返回基属性值，忽略任何可能来自正在运行或已停止的动画的动画值。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-364">Returns the base property value for the specified property on this element, disregarding any possible animated value from a running or stopped animation.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f4180-365">就像没有动画被附加到指定的依赖属性一样的属性值。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-365">The property value as if no animations are attached to the specified dependency property.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4180-366">如果没有动画附加到属性，则<xref:System.Windows.ContentElement.GetAnimationBaseValue%2A>返回值也始终等于<xref:System.Windows.DependencyObject.GetValue%2A>返回值。</span><span class="sxs-lookup"><span data-stu-id="f4180-366">If no animations are attached to the property, then the <xref:System.Windows.ContentElement.GetAnimationBaseValue%2A> return value is always identical to the <xref:System.Windows.DependencyObject.GetValue%2A> return value.</span></span> <span data-ttu-id="f4180-367">如果有附加的动画，然后所有可能的动画派生值包括开始和停止值将被忽略，并根据所有其他可能的输入确定的属性值。</span><span class="sxs-lookup"><span data-stu-id="f4180-367">If there are animations attached, then all possible animation derived values including the start and stop values are ignored, and the property value is determined based on all other possible inputs.</span></span> <span data-ttu-id="f4180-368">有关详细信息，请参阅[依赖属性值优先级](~/docs/framework/wpf/advanced/dependency-property-value-precedence.md)。</span><span class="sxs-lookup"><span data-stu-id="f4180-368">For more information, see [Dependency Property Value Precedence](~/docs/framework/wpf/advanced/dependency-property-value-precedence.md).</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.DependencyObject.GetValue(System.Windows.DependencyProperty)" />
      </Docs>
    </Member>
    <Member MemberName="GetUIParentCore">
      <MemberSignature Language="C#" Value="protected internal virtual System.Windows.DependencyObject GetUIParentCore ();" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance class System.Windows.DependencyObject GetUIParentCore() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.GetUIParentCore" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Function GetUIParentCore () As DependencyObject" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual System::Windows::DependencyObject ^ GetUIParentCore();" />
      <MemberSignature Language="F#" Value="abstract member GetUIParentCore : unit -&gt; System.Windows.DependencyObject&#xA;override this.GetUIParentCore : unit -&gt; System.Windows.DependencyObject" Usage="contentElement.GetUIParentCore " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="f4180-369">在派生类中重写时，如果不存在可视父级，则返回其他[!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)] 父级。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-369">When overridden in a derived class, returns an alternative [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)] parent for this element if no visual parent exists.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f4180-370">如果派生类的实现具有要报告的替代父级连接，则为一个对象。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-370">An object, if implementation of a derived class has an alternate parent connection to report.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4180-371">此方法的默认虚拟实现返回`null`。</span><span class="sxs-lookup"><span data-stu-id="f4180-371">The default virtual implementation of this method returns `null`.</span></span> <span data-ttu-id="f4180-372"><xref:System.Windows.FrameworkContentElement> 提供了实际的实现。</span><span class="sxs-lookup"><span data-stu-id="f4180-372"><xref:System.Windows.FrameworkContentElement> provides a practical implementation.</span></span>  
  
 <span data-ttu-id="f4180-373">替代父级的用于事件路由，在其中元素创建的替代父结构以便将其事件路由有何区别路由到标准的父级，在可视树的标准模式的方式的情况下或在向下预览路由策略。</span><span class="sxs-lookup"><span data-stu-id="f4180-373">Alternative parents are used for event routing, in cases where an element creates an alternative parent structure so that its events are routed in a way that diverges from the standard pattern of routing up the visual tree to the standard parent, or downward in the preview routing strategy.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GiveFeedback">
      <MemberSignature Language="C#" Value="public event System.Windows.GiveFeedbackEventHandler GiveFeedback;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.GiveFeedbackEventHandler GiveFeedback" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.GiveFeedback" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event GiveFeedback As GiveFeedbackEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::GiveFeedbackEventHandler ^ GiveFeedback;" />
      <MemberSignature Language="F#" Value="member this.GiveFeedback : System.Windows.GiveFeedbackEventHandler " Usage="member this.GiveFeedback : System.Windows.GiveFeedbackEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.GiveFeedbackEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f4180-374">在输入系统报告出现涉及此元素的基础拖放操作时发生。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-374">Occurs when the input system reports an underlying drag-and-drop event that involves this element.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4180-375"><xref:System.Windows.ContentElement.GiveFeedback>事件允许拖动事件，可以修改鼠标指针的外观，以便为用户可视反馈提供拖放操作期间的源。</span><span class="sxs-lookup"><span data-stu-id="f4180-375">The <xref:System.Windows.ContentElement.GiveFeedback> event allows the source of a drag event to modify the appearance of the mouse pointer in order to give the user visual feedback during a drag-and-drop operation.</span></span> <span data-ttu-id="f4180-376">视觉反馈用于强调拖放操作正在进行。</span><span class="sxs-lookup"><span data-stu-id="f4180-376">The visual feedback reinforces that a drag-and-drop operation is in process.</span></span>  
  
 <span data-ttu-id="f4180-377">此事件创建一个别名<xref:System.Windows.DragDrop.GiveFeedback?displayProperty=nameWithType>附加的此类事件，以便<xref:System.Windows.ContentElement.GiveFeedback>属于类的成员列出时<xref:System.Windows.ContentElement>作为基元素继承。</span><span class="sxs-lookup"><span data-stu-id="f4180-377">This event creates an alias for the <xref:System.Windows.DragDrop.GiveFeedback?displayProperty=nameWithType> attached event for this class so that <xref:System.Windows.ContentElement.GiveFeedback> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="f4180-378">事件处理程序附加到<xref:System.Windows.ContentElement.GiveFeedback>事件附加到基础<xref:System.Windows.DragDrop.GiveFeedback?displayProperty=nameWithType>附加事件，并接收相同的事件数据实例。</span><span class="sxs-lookup"><span data-stu-id="f4180-378">Event handlers that are attached to the <xref:System.Windows.ContentElement.GiveFeedback> event are attached to the underlying <xref:System.Windows.DragDrop.GiveFeedback?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
<a name="routedEventInfo_GiveFeedback"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="f4180-379">路由事件信息</span><span class="sxs-lookup"><span data-stu-id="f4180-379">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="f4180-380">标识符字段</span><span class="sxs-lookup"><span data-stu-id="f4180-380">Identifier field</span></span>|<xref:System.Windows.ContentElement.GiveFeedbackEvent>|  
|<span data-ttu-id="f4180-381">路由策略</span><span class="sxs-lookup"><span data-stu-id="f4180-381">Routing strategy</span></span>|<span data-ttu-id="f4180-382">浮升</span><span class="sxs-lookup"><span data-stu-id="f4180-382">Bubbling</span></span>|  
|<span data-ttu-id="f4180-383">委托</span><span class="sxs-lookup"><span data-stu-id="f4180-383">Delegate</span></span>|<xref:System.Windows.GiveFeedbackEventHandler>|  
  
-   <span data-ttu-id="f4180-384">相应的隧道事件是<xref:System.Windows.ContentElement.PreviewGiveFeedback>。</span><span class="sxs-lookup"><span data-stu-id="f4180-384">The corresponding tunneling event is <xref:System.Windows.ContentElement.PreviewGiveFeedback>.</span></span>  
  
-   <span data-ttu-id="f4180-385">重写<xref:System.Windows.ContentElement.OnGiveFeedback%2A>实现类处理此事件在派生类中。</span><span class="sxs-lookup"><span data-stu-id="f4180-385">Override <xref:System.Windows.ContentElement.OnGiveFeedback%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.DragLeave" />
      </Docs>
    </Member>
    <Member MemberName="GiveFeedbackEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent GiveFeedbackEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent GiveFeedbackEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.GiveFeedbackEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly GiveFeedbackEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ GiveFeedbackEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable GiveFeedbackEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.GiveFeedbackEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f4180-386">标识 <see cref="E:System.Windows.ContentElement.GiveFeedback" /> 路由事件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-386">Identifies the <see cref="E:System.Windows.ContentElement.GiveFeedback" /> routed event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4180-387">在注册路由事件时创建路由事件标识符。</span><span class="sxs-lookup"><span data-stu-id="f4180-387">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="f4180-388">这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。</span><span class="sxs-lookup"><span data-stu-id="f4180-388">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="f4180-389">可以使用这些标识符添加类处理程序。</span><span class="sxs-lookup"><span data-stu-id="f4180-389">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="f4180-390">有关注册路由事件的更多信息，请参见 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="f4180-390">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="f4180-391">有关使用路由事件标识符添加类处理程序的更多信息，请参见 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="f4180-391">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GotFocus">
      <MemberSignature Language="C#" Value="public event System.Windows.RoutedEventHandler GotFocus;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.RoutedEventHandler GotFocus" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.GotFocus" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event GotFocus As RoutedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::RoutedEventHandler ^ GotFocus;" />
      <MemberSignature Language="F#" Value="member this.GotFocus : System.Windows.RoutedEventHandler " Usage="member this.GotFocus : System.Windows.RoutedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f4180-392">在此元素获得逻辑焦点时发生。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-392">Occurs when this element gets logical focus.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4180-393">如果焦点有意强制使用方法调用，但前一个键盘焦点位于不同的作用域将与键盘焦点不同逻辑焦点。</span><span class="sxs-lookup"><span data-stu-id="f4180-393">Logical focus differs from keyboard focus if focus is deliberately forced by using a method call but the previous keyboard focus exists in a different scope.</span></span> <span data-ttu-id="f4180-394">在此方案中，键盘焦点将保持其所在位置和元素其中<xref:System.Windows.ContentElement.Focus%2A>方法称为仍获得逻辑焦点。</span><span class="sxs-lookup"><span data-stu-id="f4180-394">In this scenario, keyboard focus remains where it is and the element where a <xref:System.Windows.ContentElement.Focus%2A> method is called still gets logical focus.</span></span>  
  
 <span data-ttu-id="f4180-395">此事件的更精确地解释是它时引发的值<xref:System.Windows.ContentElement.IsFocused%2A>路由中元素的属性有所不同`false`到`true`。</span><span class="sxs-lookup"><span data-stu-id="f4180-395">A more precise interpretation of this event is that it is raised when the value of the <xref:System.Windows.ContentElement.IsFocused%2A> property of an element in the route is changed from `false` to `true`.</span></span>  
  
 <span data-ttu-id="f4180-396">此事件使用冒泡路由，因为接收焦点的元素可能是而不是元素的子元素实际附加事件处理程序。</span><span class="sxs-lookup"><span data-stu-id="f4180-396">Because this event uses bubbling routing, the element that receives focus might be a child element instead of the element where the event handler is actually attached.</span></span> <span data-ttu-id="f4180-397">检查<xref:System.Windows.RoutedEventArgs.Source%2A>事件数据以确定实际获得焦点的元素中。</span><span class="sxs-lookup"><span data-stu-id="f4180-397">Check the <xref:System.Windows.RoutedEventArgs.Source%2A> in the event data to determine the actual element that gained focus.</span></span>  
  
<a name="routedEventInfo_GotFocus"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="f4180-398">路由事件信息</span><span class="sxs-lookup"><span data-stu-id="f4180-398">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="f4180-399">标识符字段</span><span class="sxs-lookup"><span data-stu-id="f4180-399">Identifier field</span></span>|<xref:System.Windows.ContentElement.GotFocusEvent>|  
|<span data-ttu-id="f4180-400">路由策略</span><span class="sxs-lookup"><span data-stu-id="f4180-400">Routing strategy</span></span>|<span data-ttu-id="f4180-401">浮升</span><span class="sxs-lookup"><span data-stu-id="f4180-401">Bubbling</span></span>|  
|<span data-ttu-id="f4180-402">委托</span><span class="sxs-lookup"><span data-stu-id="f4180-402">Delegate</span></span>|<xref:System.Windows.RoutedEventHandler>|  
  
-   <span data-ttu-id="f4180-403">没有相应的隧道事件。</span><span class="sxs-lookup"><span data-stu-id="f4180-403">There is no corresponding tunneling event.</span></span>  
  
-   <span data-ttu-id="f4180-404">重写<xref:System.Windows.ContentElement.OnGotFocus%2A>实现类处理此事件在派生类中。</span><span class="sxs-lookup"><span data-stu-id="f4180-404">Override <xref:System.Windows.ContentElement.OnGotFocus%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.GotKeyboardFocus" />
        <altmember cref="M:System.Windows.ContentElement.Focus" />
      </Docs>
    </Member>
    <Member MemberName="GotFocusEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent GotFocusEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent GotFocusEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.GotFocusEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly GotFocusEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ GotFocusEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable GotFocusEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.GotFocusEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f4180-405">标识 <see cref="E:System.Windows.ContentElement.GotFocus" /> 路由事件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-405">Identifies the <see cref="E:System.Windows.ContentElement.GotFocus" /> routed event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4180-406">在注册路由事件时创建路由事件标识符。</span><span class="sxs-lookup"><span data-stu-id="f4180-406">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="f4180-407">这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。</span><span class="sxs-lookup"><span data-stu-id="f4180-407">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="f4180-408">可以使用这些标识符添加类处理程序。</span><span class="sxs-lookup"><span data-stu-id="f4180-408">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="f4180-409">有关注册路由事件的更多信息，请参见 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="f4180-409">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="f4180-410">有关使用路由事件标识符添加类处理程序的更多信息，请参见 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="f4180-410">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GotKeyboardFocus">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.KeyboardFocusChangedEventHandler GotKeyboardFocus;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.KeyboardFocusChangedEventHandler GotKeyboardFocus" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.GotKeyboardFocus" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event GotKeyboardFocus As KeyboardFocusChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::KeyboardFocusChangedEventHandler ^ GotKeyboardFocus;" />
      <MemberSignature Language="F#" Value="member this.GotKeyboardFocus : System.Windows.Input.KeyboardFocusChangedEventHandler " Usage="member this.GotKeyboardFocus : System.Windows.Input.KeyboardFocusChangedEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.GotKeyboardFocus</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.KeyboardFocusChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f4180-411">在此元素聚焦于键盘时发生。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-411">Occurs when the keyboard is focused on this element.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4180-412"><xref:System.Windows.ContentElement.IsKeyboardFocusedChanged> 是一个类似的事件，跟踪中维护一个元素; 的焦点状态的属性的状态更改<xref:System.Windows.ContentElement.GotKeyboardFocus>中许多相同的情况下引发事件。</span><span class="sxs-lookup"><span data-stu-id="f4180-412"><xref:System.Windows.ContentElement.IsKeyboardFocusedChanged> is a similar event that tracks status changes in a property that maintains the focus state for an element; the <xref:System.Windows.ContentElement.GotKeyboardFocus> event is raised in many of the same circumstances.</span></span>  
  
 <span data-ttu-id="f4180-413">此事件使用冒泡路由，因为具有焦点的元素可能是而不是元素的子元素实际附加事件处理程序。</span><span class="sxs-lookup"><span data-stu-id="f4180-413">Because this event uses bubbling routing, the element that has focus might be a child element instead of the element where the event handler is actually attached.</span></span> <span data-ttu-id="f4180-414">检查<xref:System.Windows.RoutedEventArgs.Source%2A>事件数据以确定实际具有焦点的元素中。</span><span class="sxs-lookup"><span data-stu-id="f4180-414">Check the <xref:System.Windows.RoutedEventArgs.Source%2A> in the event data to determine the actual element that has focus.</span></span>  
  
 <span data-ttu-id="f4180-415">此事件创建一个别名<xref:System.Windows.Input.Keyboard.GotKeyboardFocus?displayProperty=nameWithType>附加的此类事件，以便<xref:System.Windows.ContentElement.GotKeyboardFocus>属于类的成员列出时<xref:System.Windows.ContentElement>作为基元素继承。</span><span class="sxs-lookup"><span data-stu-id="f4180-415">This event creates an alias for the <xref:System.Windows.Input.Keyboard.GotKeyboardFocus?displayProperty=nameWithType> attached event for this class so that <xref:System.Windows.ContentElement.GotKeyboardFocus> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="f4180-416">事件处理程序附加到<xref:System.Windows.ContentElement.GotKeyboardFocus>事件附加到基础<xref:System.Windows.Input.Keyboard.GotKeyboardFocus?displayProperty=nameWithType>附加事件，并接收相同的事件数据实例。</span><span class="sxs-lookup"><span data-stu-id="f4180-416">Event handlers that are attached to the <xref:System.Windows.ContentElement.GotKeyboardFocus> event are attached to the underlying <xref:System.Windows.Input.Keyboard.GotKeyboardFocus?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
<a name="routedEventInfo_GotKeyboardFocus"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="f4180-417">路由事件信息</span><span class="sxs-lookup"><span data-stu-id="f4180-417">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="f4180-418">标识符字段</span><span class="sxs-lookup"><span data-stu-id="f4180-418">Identifier field</span></span>|<xref:System.Windows.ContentElement.GotKeyboardFocusEvent>|  
|<span data-ttu-id="f4180-419">路由策略</span><span class="sxs-lookup"><span data-stu-id="f4180-419">Routing strategy</span></span>|<span data-ttu-id="f4180-420">浮升</span><span class="sxs-lookup"><span data-stu-id="f4180-420">Bubbling</span></span>|  
|<span data-ttu-id="f4180-421">委托</span><span class="sxs-lookup"><span data-stu-id="f4180-421">Delegate</span></span>|<xref:System.Windows.Input.KeyboardFocusChangedEventHandler>|  
  
-   <span data-ttu-id="f4180-422">相应的隧道事件是<xref:System.Windows.ContentElement.PreviewGotKeyboardFocus>。</span><span class="sxs-lookup"><span data-stu-id="f4180-422">The corresponding tunneling event is <xref:System.Windows.ContentElement.PreviewGotKeyboardFocus>.</span></span>  
  
-   <span data-ttu-id="f4180-423">重写<xref:System.Windows.ContentElement.OnGotKeyboardFocus%2A>实现类处理此事件在派生类中。</span><span class="sxs-lookup"><span data-stu-id="f4180-423">Override <xref:System.Windows.ContentElement.OnGotKeyboardFocus%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.LostKeyboardFocus" />
      </Docs>
    </Member>
    <Member MemberName="GotKeyboardFocusEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent GotKeyboardFocusEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent GotKeyboardFocusEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.GotKeyboardFocusEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly GotKeyboardFocusEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ GotKeyboardFocusEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable GotKeyboardFocusEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.GotKeyboardFocusEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f4180-424">标识 <see cref="E:System.Windows.ContentElement.GotKeyboardFocus" /> 路由事件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-424">Identifies the <see cref="E:System.Windows.ContentElement.GotKeyboardFocus" /> routed event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4180-425">在注册路由事件时创建路由事件标识符。</span><span class="sxs-lookup"><span data-stu-id="f4180-425">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="f4180-426">这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。</span><span class="sxs-lookup"><span data-stu-id="f4180-426">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="f4180-427">可以使用这些标识符添加类处理程序。</span><span class="sxs-lookup"><span data-stu-id="f4180-427">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="f4180-428">有关注册路由事件的更多信息，请参见 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="f4180-428">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="f4180-429">有关使用路由事件标识符添加类处理程序的更多信息，请参见 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="f4180-429">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GotMouseCapture">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseEventHandler GotMouseCapture;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseEventHandler GotMouseCapture" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.GotMouseCapture" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event GotMouseCapture As MouseEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::MouseEventHandler ^ GotMouseCapture;" />
      <MemberSignature Language="F#" Value="member this.GotMouseCapture : System.Windows.Input.MouseEventHandler " Usage="member this.GotMouseCapture : System.Windows.Input.MouseEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.GotMouseCapture</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f4180-430">在此元素捕获鼠标时发生。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-430">Occurs when this element captures the mouse.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4180-431">在元素捕获鼠标，它会接收鼠标输入，即使在鼠标指针位于其边界外。</span><span class="sxs-lookup"><span data-stu-id="f4180-431">When an element captures the mouse, it receives mouse input even if the mouse pointer is outside its bounds.</span></span> <span data-ttu-id="f4180-432">鼠标通常仅在拖放操作期间捕获和保持捕获，直到发生拖放操作。</span><span class="sxs-lookup"><span data-stu-id="f4180-432">The mouse is typically captured only during drag-and-drop operations and remains captured until the drop action of the drag-and-drop operation occurs.</span></span>  
  
 <span data-ttu-id="f4180-433">此事件使用冒泡路由，因为具有捕获的元素可能是而不是元素的子元素实际附加事件处理程序。</span><span class="sxs-lookup"><span data-stu-id="f4180-433">Because this event uses bubbling routing, the element that has capture might be a child element instead of the element where the event handler is actually attached.</span></span> <span data-ttu-id="f4180-434">检查<xref:System.Windows.RoutedEventArgs.Source%2A>在事件数据，以确定实际元素具有鼠标捕获。</span><span class="sxs-lookup"><span data-stu-id="f4180-434">Check the <xref:System.Windows.RoutedEventArgs.Source%2A> in the event data to determine the actual element that has mouse capture.</span></span>  
  
 <span data-ttu-id="f4180-435">此事件创建一个别名<xref:System.Windows.Input.Mouse.GotMouseCapture?displayProperty=nameWithType>附加的此类事件，以便<xref:System.Windows.ContentElement.GotMouseCapture>属于类的成员列出时<xref:System.Windows.ContentElement>作为基元素继承。</span><span class="sxs-lookup"><span data-stu-id="f4180-435">This event creates an alias for the <xref:System.Windows.Input.Mouse.GotMouseCapture?displayProperty=nameWithType> attached event for  this class so that <xref:System.Windows.ContentElement.GotMouseCapture> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="f4180-436">事件处理程序附加到<xref:System.Windows.ContentElement.GotMouseCapture>事件附加到基础<xref:System.Windows.Input.Mouse.GotMouseCapture?displayProperty=nameWithType>附加事件，并接收相同的事件数据实例。</span><span class="sxs-lookup"><span data-stu-id="f4180-436">Event handlers that are attached to the <xref:System.Windows.ContentElement.GotMouseCapture> event are attached to the underlying <xref:System.Windows.Input.Mouse.GotMouseCapture?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
<a name="routedEventInfo_GotMouseCapture"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="f4180-437">路由事件信息</span><span class="sxs-lookup"><span data-stu-id="f4180-437">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="f4180-438">标识符字段</span><span class="sxs-lookup"><span data-stu-id="f4180-438">Identifier field</span></span>|<xref:System.Windows.ContentElement.GotMouseCaptureEvent>|  
|<span data-ttu-id="f4180-439">路由策略</span><span class="sxs-lookup"><span data-stu-id="f4180-439">Routing strategy</span></span>|<span data-ttu-id="f4180-440">浮升</span><span class="sxs-lookup"><span data-stu-id="f4180-440">Bubbling</span></span>|  
|<span data-ttu-id="f4180-441">委托</span><span class="sxs-lookup"><span data-stu-id="f4180-441">Delegate</span></span>|<xref:System.Windows.Input.MouseEventHandler>|  
  
-   <span data-ttu-id="f4180-442">没有定义相应的隧道事件。</span><span class="sxs-lookup"><span data-stu-id="f4180-442">There is no defined corresponding tunneling event.</span></span>  
  
-   <span data-ttu-id="f4180-443">重写<xref:System.Windows.ContentElement.OnGotMouseCapture%2A>实现类处理此事件在派生类中。</span><span class="sxs-lookup"><span data-stu-id="f4180-443">Override <xref:System.Windows.ContentElement.OnGotMouseCapture%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.ContentElement.CaptureMouse" />
      </Docs>
    </Member>
    <Member MemberName="GotMouseCaptureEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent GotMouseCaptureEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent GotMouseCaptureEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.GotMouseCaptureEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly GotMouseCaptureEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ GotMouseCaptureEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable GotMouseCaptureEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.GotMouseCaptureEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f4180-444">标识 <see cref="E:System.Windows.ContentElement.GotMouseCapture" /> 路由事件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-444">Identifies the <see cref="E:System.Windows.ContentElement.GotMouseCapture" /> routed event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4180-445">在注册路由事件时创建路由事件标识符。</span><span class="sxs-lookup"><span data-stu-id="f4180-445">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="f4180-446">这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。</span><span class="sxs-lookup"><span data-stu-id="f4180-446">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="f4180-447">可以使用这些标识符添加类处理程序。</span><span class="sxs-lookup"><span data-stu-id="f4180-447">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="f4180-448">有关注册路由事件的更多信息，请参见 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="f4180-448">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="f4180-449">有关使用路由事件标识符添加类处理程序的更多信息，请参见 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="f4180-449">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GotStylusCapture">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusEventHandler GotStylusCapture;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusEventHandler GotStylusCapture" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.GotStylusCapture" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event GotStylusCapture As StylusEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusEventHandler ^ GotStylusCapture;" />
      <MemberSignature Language="F#" Value="member this.GotStylusCapture : System.Windows.Input.StylusEventHandler " Usage="member this.GotStylusCapture : System.Windows.Input.StylusEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.GotStylusCapture</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f4180-450">在此元素捕获触笔时发生。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-450">Occurs when this element captures the stylus.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4180-451">在元素捕获触笔，它会接收触笔输入，即使在指针位于其边界外。</span><span class="sxs-lookup"><span data-stu-id="f4180-451">When an element captures the stylus, it receives stylus input even if the pointer is outside its bounds.</span></span> <span data-ttu-id="f4180-452">在触笔通常仅在拖放操作期间捕获和捕获之前发生拖放操作的状态将保持。</span><span class="sxs-lookup"><span data-stu-id="f4180-452">The stylus is typically captured only during drag-and-drop operations and retains capture until the drop action of the drag-and-drop operation occurs.</span></span>  
  
 <span data-ttu-id="f4180-453">此事件使用冒泡路由，因为具有捕获的元素可能是而不是元素的子元素实际附加事件处理程序。</span><span class="sxs-lookup"><span data-stu-id="f4180-453">Because this event uses bubbling routing, the element that has capture might be a child element instead of the element where the event handler is actually attached.</span></span> <span data-ttu-id="f4180-454">检查<xref:System.Windows.RoutedEventArgs.Source%2A>事件数据来确定具有捕获的实际元素中。</span><span class="sxs-lookup"><span data-stu-id="f4180-454">Check the <xref:System.Windows.RoutedEventArgs.Source%2A> in the event data to determine the actual element that has capture.</span></span>  
  
 <span data-ttu-id="f4180-455">此事件创建此类的附加事件的别名，以便<xref:System.Windows.ContentElement.GotStylusCapture>属于类的成员列出时<xref:System.Windows.ContentElement>作为基元素继承。</span><span class="sxs-lookup"><span data-stu-id="f4180-455">This event creates an alias for the  attached event for this class so that <xref:System.Windows.ContentElement.GotStylusCapture> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="f4180-456">事件处理程序附加到<xref:System.Windows.ContentElement.GotStylusCapture>事件附加到基础<xref:System.Windows.Input.Stylus.GotStylusCapture?displayProperty=nameWithType>附加事件，并接收相同的事件数据实例。</span><span class="sxs-lookup"><span data-stu-id="f4180-456">Event handlers that are attached to the <xref:System.Windows.ContentElement.GotStylusCapture> event are attached to the underlying <xref:System.Windows.Input.Stylus.GotStylusCapture?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
<a name="routedEventInfo_GotStylusCapture"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="f4180-457">路由事件信息</span><span class="sxs-lookup"><span data-stu-id="f4180-457">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="f4180-458">标识符字段</span><span class="sxs-lookup"><span data-stu-id="f4180-458">Identifier field</span></span>|<xref:System.Windows.ContentElement.GotStylusCaptureEvent>|  
|<span data-ttu-id="f4180-459">路由策略</span><span class="sxs-lookup"><span data-stu-id="f4180-459">Routing strategy</span></span>|<span data-ttu-id="f4180-460">浮升</span><span class="sxs-lookup"><span data-stu-id="f4180-460">Bubbling</span></span>|  
|<span data-ttu-id="f4180-461">委托</span><span class="sxs-lookup"><span data-stu-id="f4180-461">Delegate</span></span>|<xref:System.Windows.Input.StylusEventHandler>|  
  
-   <span data-ttu-id="f4180-462">没有定义相应的隧道事件。</span><span class="sxs-lookup"><span data-stu-id="f4180-462">There is no defined corresponding tunneling event.</span></span>  
  
-   <span data-ttu-id="f4180-463">重写<xref:System.Windows.ContentElement.OnGotStylusCapture%2A>实现类处理此事件在派生类中。</span><span class="sxs-lookup"><span data-stu-id="f4180-463">Override <xref:System.Windows.ContentElement.OnGotStylusCapture%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GotStylusCaptureEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent GotStylusCaptureEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent GotStylusCaptureEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.GotStylusCaptureEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly GotStylusCaptureEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ GotStylusCaptureEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable GotStylusCaptureEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.GotStylusCaptureEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f4180-464">标识 <see cref="E:System.Windows.ContentElement.GotStylusCapture" /> 路由事件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-464">Identifies the <see cref="E:System.Windows.ContentElement.GotStylusCapture" /> routed event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4180-465">在注册路由事件时创建路由事件标识符。</span><span class="sxs-lookup"><span data-stu-id="f4180-465">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="f4180-466">这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。</span><span class="sxs-lookup"><span data-stu-id="f4180-466">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="f4180-467">可以使用这些标识符添加类处理程序。</span><span class="sxs-lookup"><span data-stu-id="f4180-467">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="f4180-468">有关注册路由事件的更多信息，请参见 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="f4180-468">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="f4180-469">有关使用路由事件标识符添加类处理程序的更多信息，请参见 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="f4180-469">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GotTouchCapture">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; GotTouchCapture;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Input.TouchEventArgs&gt; GotTouchCapture" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.GotTouchCapture" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event GotTouchCapture As EventHandler(Of TouchEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Windows::Input::TouchEventArgs ^&gt; ^ GotTouchCapture;" />
      <MemberSignature Language="F#" Value="member this.GotTouchCapture : EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; " Usage="member this.GotTouchCapture : System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f4180-470">在此元素上捕获触摸屏输入时发生。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-470">Occurs when a touch is captured to this element.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="routedEventInfo_GotTouchCapture"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="f4180-471">路由事件信息</span><span class="sxs-lookup"><span data-stu-id="f4180-471">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="f4180-472">标识符字段</span><span class="sxs-lookup"><span data-stu-id="f4180-472">Identifier field</span></span>|<xref:System.Windows.ContentElement.GotTouchCaptureEvent>|  
|<span data-ttu-id="f4180-473">路由策略</span><span class="sxs-lookup"><span data-stu-id="f4180-473">Routing strategy</span></span>|<span data-ttu-id="f4180-474">浮升</span><span class="sxs-lookup"><span data-stu-id="f4180-474">Bubbling</span></span>|  
|<span data-ttu-id="f4180-475">委托</span><span class="sxs-lookup"><span data-stu-id="f4180-475">Delegate</span></span>|<span data-ttu-id="f4180-476"><xref:System.EventHandler%601>类型<xref:System.Windows.Input.TouchEventArgs>。</span><span class="sxs-lookup"><span data-stu-id="f4180-476"><xref:System.EventHandler%601> of type <xref:System.Windows.Input.TouchEventArgs>.</span></span>|  
  
-   <span data-ttu-id="f4180-477">重写<xref:System.Windows.ContentElement.OnGotTouchCapture%2A>实现类处理此事件在派生类中。</span><span class="sxs-lookup"><span data-stu-id="f4180-477">Override <xref:System.Windows.ContentElement.OnGotTouchCapture%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GotTouchCaptureEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent GotTouchCaptureEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent GotTouchCaptureEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.GotTouchCaptureEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly GotTouchCaptureEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ GotTouchCaptureEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable GotTouchCaptureEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.GotTouchCaptureEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f4180-478">标识 <see cref="E:System.Windows.ContentElement.GotTouchCapture" /> 路由事件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-478">Identifies the <see cref="E:System.Windows.ContentElement.GotTouchCapture" /> routed event.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="HasAnimatedProperties">
      <MemberSignature Language="C#" Value="public bool HasAnimatedProperties { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasAnimatedProperties" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.HasAnimatedProperties" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HasAnimatedProperties As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool HasAnimatedProperties { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.HasAnimatedProperties : bool" Usage="System.Windows.ContentElement.HasAnimatedProperties" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.Media.Animation.IAnimatable.HasAnimatedProperties</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f4180-479">获取一个值，该值指示此元素是否具有任何进行动画处理的属性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-479">Gets a value that indicates whether this element has any animated properties.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="f4180-480">如果此元素具有附加到其任何属性的动画，则为 <see langword="true" />；否则为 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-480">
              <see langword="true" /> if this element has animations attached to any of its properties; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4180-481">此属性返回`true`为永久性的 （无时间限制，始终运行的） 动画或具有特定的时间线的动画。</span><span class="sxs-lookup"><span data-stu-id="f4180-481">This property returns `true` either for persistent (unclocked, always-running) animations or for animations that have a specific timeline.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InputBindings">
      <MemberSignature Language="C#" Value="public System.Windows.Input.InputBindingCollection InputBindings { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Input.InputBindingCollection InputBindings" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.InputBindings" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property InputBindings As InputBindingCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Input::InputBindingCollection ^ InputBindings { System::Windows::Input::InputBindingCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.InputBindings : System.Windows.Input.InputBindingCollection" Usage="System.Windows.ContentElement.InputBindings" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Content)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Input.InputBindingCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f4180-482">获取与此元素关联的输入绑定的集合。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-482">Gets the collection of input bindings that are associated with this element.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="f4180-483">输入绑定的集合。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-483">The collection of input bindings.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4180-484">输入的绑定支持命令来输入设备的绑定。</span><span class="sxs-lookup"><span data-stu-id="f4180-484">Input bindings support the binding of commands to input devices.</span></span> <span data-ttu-id="f4180-485">例如，<xref:System.Windows.Input.MouseBinding>实现的输入包括特定于鼠标设备的属性的绑定。</span><span class="sxs-lookup"><span data-stu-id="f4180-485">For example, <xref:System.Windows.Input.MouseBinding> implements input bindings that include properties that are specific to mouse devices.</span></span>  
  
 <span data-ttu-id="f4180-486">输入绑定的集合包括适用于类型的输入的绑定和还声明的实例的输入的绑定。</span><span class="sxs-lookup"><span data-stu-id="f4180-486">The collection of input bindings includes both input bindings that pertain to the type and also input bindings that are declared on the instance.</span></span>  
  
 <span data-ttu-id="f4180-487">相关的属性， <xref:System.Windows.ContentElement.CommandBindings%2A>，维护命令绑定的集合。</span><span class="sxs-lookup"><span data-stu-id="f4180-487">A related property, <xref:System.Windows.ContentElement.CommandBindings%2A>, maintains a collection of command bindings.</span></span> <span data-ttu-id="f4180-488">这些绑定不同于输入绑定，因为它们表示下一级别的命令处理为其绑定到已知的命令和特定于的类处理程序的操作。</span><span class="sxs-lookup"><span data-stu-id="f4180-488">These bindings differ from input bindings in that they represent the next level down of command processing - actions that are tied to known commands and class-specific handlers for them.</span></span>  
  
<a name="xamlPropertyElementUsage_InputBindings"></a>   
## <a name="xaml-property-element-usage"></a><span data-ttu-id="f4180-489">XAML 属性元素用法</span><span class="sxs-lookup"><span data-stu-id="f4180-489">XAML Property Element Usage</span></span>  
  
```  
<object>  
  <object.InputBindings>  
    oneOrMoreInputBindings  </object.InputBindings>  
</object>  
```  
  
<a name="xamlValues_InputBindings"></a>   
## <a name="xaml-values"></a><span data-ttu-id="f4180-490">XAML 值</span><span class="sxs-lookup"><span data-stu-id="f4180-490">XAML Values</span></span>  
 <span data-ttu-id="f4180-491">*oneOrMoreInputBindings*</span><span class="sxs-lookup"><span data-stu-id="f4180-491">*oneOrMoreInputBindings*</span></span>  
 <span data-ttu-id="f4180-492">一个或多个<xref:System.Windows.Input.InputBinding>元素 (通常<xref:System.Windows.Input.KeyBinding>或<xref:System.Windows.Input.MouseBinding>派生类)。</span><span class="sxs-lookup"><span data-stu-id="f4180-492">One or more <xref:System.Windows.Input.InputBinding> elements (typically the <xref:System.Windows.Input.KeyBinding> or <xref:System.Windows.Input.MouseBinding> derived classes).</span></span> <span data-ttu-id="f4180-493">其中每项功能都必须具有<xref:System.Windows.Input.InputBinding.Command%2A>和<xref:System.Windows.Input.InputBinding.Gesture%2A>属性设置。</span><span class="sxs-lookup"><span data-stu-id="f4180-493">Each of these is expected to have a <xref:System.Windows.Input.InputBinding.Command%2A> and <xref:System.Windows.Input.InputBinding.Gesture%2A> attribute set.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsEnabled">
      <MemberSignature Language="C#" Value="public bool IsEnabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsEnabled" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.IsEnabled" />
      <MemberSignature Language="VB.NET" Value="Public Property IsEnabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsEnabled { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.IsEnabled : bool with get, set" Usage="System.Windows.ContentElement.IsEnabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f4180-494">获取或设置一个值，该值指示是否在[!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)] 中启用了此元素。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-494">Gets or sets a value that indicates whether this element is enabled in the [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)].</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="f4180-495">如果启用了该元素，则为 <see langword="true" />；否则为 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-495">
              <see langword="true" /> if the element is enabled; otherwise, <see langword="false" />.</span>
          </span>
          <span data-ttu-id="f4180-496">默认值为 <see langword="true" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-496">The default value is <see langword="true" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="dependencyPropertyInfo_IsEnabled"></a>   
## <a name="dependency-property-information"></a><span data-ttu-id="f4180-497">依赖项属性信息</span><span class="sxs-lookup"><span data-stu-id="f4180-497">Dependency Property Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="f4180-498">标识符字段</span><span class="sxs-lookup"><span data-stu-id="f4180-498">Identifier field</span></span>|<xref:System.Windows.ContentElement.IsEnabledProperty>|  
|<span data-ttu-id="f4180-499">元数据属性设置为 `true`</span><span class="sxs-lookup"><span data-stu-id="f4180-499">Metadata properties set to `true`</span></span>|<span data-ttu-id="f4180-500">无</span><span class="sxs-lookup"><span data-stu-id="f4180-500">None</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="f4180-501">下面的示例创建包含提供备用的可视行为的属性 setter 的样式时<xref:System.Windows.Documents.Hyperlink>设置为<xref:System.Windows.ContentElement.IsEnabled%2A> `false`。</span><span class="sxs-lookup"><span data-stu-id="f4180-501">The following example creates a style that includes a property setter that gives an alternate visual behavior when a <xref:System.Windows.Documents.Hyperlink> is set to <xref:System.Windows.ContentElement.IsEnabled%2A> `false`.</span></span>  
  
 [!code-xaml[ContentElementsSmorgasbord#IsEnabledIsMouseOver](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml#isenabledismouseover)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsEnabledChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.DependencyPropertyChangedEventHandler IsEnabledChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DependencyPropertyChangedEventHandler IsEnabledChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.IsEnabledChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event IsEnabledChanged As DependencyPropertyChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DependencyPropertyChangedEventHandler ^ IsEnabledChanged;" />
      <MemberSignature Language="F#" Value="member this.IsEnabledChanged : System.Windows.DependencyPropertyChangedEventHandler " Usage="member this.IsEnabledChanged : System.Windows.DependencyPropertyChangedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f4180-502">在此元素的 <see cref="P:System.Windows.ContentElement.IsEnabled" /> 属性值更改时发生。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-502">Occurs when the value of the <see cref="P:System.Windows.ContentElement.IsEnabled" /> property on this element changes.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4180-503">此成员是[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]事件、 不是路由的事件。</span><span class="sxs-lookup"><span data-stu-id="f4180-503">This member is a [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] event, not a routed event.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsEnabledCore">
      <MemberSignature Language="C#" Value="protected virtual bool IsEnabledCore { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsEnabledCore" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.IsEnabledCore" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable ReadOnly Property IsEnabledCore As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property bool IsEnabledCore { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsEnabledCore : bool" Usage="System.Windows.ContentElement.IsEnabledCore" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f4180-504">获取一个值，该值成为派生类中 <see cref="P:System.Windows.ContentElement.IsEnabled" /> 的返回值。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-504">Gets a value that becomes the return value of <see cref="P:System.Windows.ContentElement.IsEnabled" /> in derived classes.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="f4180-505">如果启用了该元素，则为 <see langword="true" />；否则为 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-505">
              <see langword="true" /> if the element is enabled; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides">
          <para>
            <span data-ttu-id="f4180-506">此属性的默认实现缓存的值，也会计算是否启用此元素的父元素。</span>
            <span class="sxs-lookup">
              <span data-stu-id="f4180-506">The default implementation of this property caches the value and also calculates whether the parent element of this element is enabled.</span>
            </span>
            <span data-ttu-id="f4180-507">(如果未启用父，子元素不能有效地启用中实际[!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)]。)如果您选择重写此实现，请确保调用基实现，以保留此行为。</span>
            <span class="sxs-lookup">
              <span data-stu-id="f4180-507">(If the parent is not enabled, the child element cannot be effectively enabled in practical [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)].) If you choose to override this implementation, make certain that you call the base implementation to preserve this behavior.</span>
            </span>
          </para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="IsEnabledProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsEnabledProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsEnabledProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.IsEnabledProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IsEnabledProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ IsEnabledProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable IsEnabledProperty : System.Windows.DependencyProperty" Usage="System.Windows.ContentElement.IsEnabledProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f4180-508">标识 <see cref="P:System.Windows.ContentElement.IsEnabled" /> 依赖项属性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-508">Identifies the <see cref="P:System.Windows.ContentElement.IsEnabled" /> dependency property.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsFocused">
      <MemberSignature Language="C#" Value="public bool IsFocused { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFocused" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.IsFocused" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsFocused As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsFocused { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsFocused : bool" Usage="System.Windows.ContentElement.IsFocused" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f4180-509">获取一个值，该值确定此元素是否具有逻辑焦点。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-509">Gets a value that determines whether this element has logical focus.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="f4180-510">如果此元素具有逻辑焦点，则为 <see langword="true" />；否则为 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-510">
              <see langword="true" /> if this element has logical focus; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4180-511">如果应用程序具有多个焦点部门，如菜单的内容和应用程序的其余部分之间，可能与键盘焦点不同逻辑焦点。</span><span class="sxs-lookup"><span data-stu-id="f4180-511">Logical focus might differ from keyboard focus if an application has multiple focus divisions, such as between menu contents and the remainder of the application.</span></span> <span data-ttu-id="f4180-512">在此方案中，键盘焦点仅可对应用程序 UI 中的一个元素，但是，其他焦点分支中的某些元素仍可能会保留逻辑焦点。</span><span class="sxs-lookup"><span data-stu-id="f4180-512">In this scenario, keyboard focus can only be on one element of the application  UI, however, certain elements in other focus divisions might still retain logical focus.</span></span> <span data-ttu-id="f4180-513">有关逻辑焦点的详细信息，请参阅[输入概述](~/docs/framework/wpf/advanced/input-overview.md)并[焦点概述](~/docs/framework/wpf/advanced/focus-overview.md)。</span><span class="sxs-lookup"><span data-stu-id="f4180-513">For more information on logical focus, see [Input Overview](~/docs/framework/wpf/advanced/input-overview.md) and [Focus Overview](~/docs/framework/wpf/advanced/focus-overview.md).</span></span>  
  
<a name="dependencyPropertyInfo_IsFocused"></a>   
## <a name="dependency-property-information"></a><span data-ttu-id="f4180-514">依赖项属性信息</span><span class="sxs-lookup"><span data-stu-id="f4180-514">Dependency Property Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="f4180-515">标识符字段</span><span class="sxs-lookup"><span data-stu-id="f4180-515">Identifier field</span></span>|<xref:System.Windows.ContentElement.IsFocusedProperty>|  
|<span data-ttu-id="f4180-516">元数据属性设置为 `true`</span><span class="sxs-lookup"><span data-stu-id="f4180-516">Metadata properties set to `true`</span></span>|<span data-ttu-id="f4180-517">无</span><span class="sxs-lookup"><span data-stu-id="f4180-517">None</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="f4180-518">下面的示例创建一种使方式<xref:System.Windows.Documents.Paragraph>默认情况下可获得焦点并接收焦点时为其提供可视行为。</span><span class="sxs-lookup"><span data-stu-id="f4180-518">The following example creates a style that makes a <xref:System.Windows.Documents.Paragraph> focusable by default and gives it a visual behavior when it receives focus.</span></span>  
  
 [!code-xaml[ContentElementsSmorgasbord#Focusable](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml#focusable)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.ContentElement.Focusable" />
      </Docs>
    </Member>
    <Member MemberName="IsFocusedProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsFocusedProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsFocusedProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.IsFocusedProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IsFocusedProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ IsFocusedProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable IsFocusedProperty : System.Windows.DependencyProperty" Usage="System.Windows.ContentElement.IsFocusedProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f4180-519">标识 <see cref="P:System.Windows.ContentElement.IsFocused" /> 依赖项属性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-519">Identifies the <see cref="P:System.Windows.ContentElement.IsFocused" /> dependency property.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsInputMethodEnabled">
      <MemberSignature Language="C#" Value="public bool IsInputMethodEnabled { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsInputMethodEnabled" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.IsInputMethodEnabled" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsInputMethodEnabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsInputMethodEnabled { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsInputMethodEnabled : bool" Usage="System.Windows.ContentElement.IsInputMethodEnabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f4180-520">获取一个值，该值指示是否启用一个输入法系统（如[!INCLUDE[TLA#tla_ime](~/includes/tlasharptla-ime-md.md)]），以便用于处理此元素的输入。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-520">Gets a value that indicates whether an input method system, such as an [!INCLUDE[TLA#tla_ime](~/includes/tlasharptla-ime-md.md)], is enabled for processing the input to this element.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="f4180-521">如果输入法处于活动状态，则为 <see langword="true" />；否则为 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-521">
              <see langword="true" /> if an input method is active; otherwise, <see langword="false" />.</span>
          </span>
          <span data-ttu-id="f4180-522">基础附加属性的默认值是<see langword="true" />; 但是，此值会在运行时的输入法状态的影响。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-522">The default value of the underlying attached property is <see langword="true" />; however, this value is influenced by the state of input methods at runtime.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4180-523">此属性返回的附加属性返回的值<xref:System.Windows.Input.InputMethod.IsInputMethodEnabled%2A?displayProperty=nameWithType>的当前已启用输入法 （键盘、 语音和其他输入的设备）。</span><span class="sxs-lookup"><span data-stu-id="f4180-523">This property returns the value that is returned by the attached property <xref:System.Windows.Input.InputMethod.IsInputMethodEnabled%2A?displayProperty=nameWithType> for the currently enabled input methods (keyboard, speech, and other input devices).</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsKeyboardFocused">
      <MemberSignature Language="C#" Value="public bool IsKeyboardFocused { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsKeyboardFocused" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.IsKeyboardFocused" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsKeyboardFocused As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsKeyboardFocused { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsKeyboardFocused : bool" Usage="System.Windows.ContentElement.IsKeyboardFocused" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.IInputElement.IsKeyboardFocused</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f4180-524">获取一个值，该值表示此元素是否具有键盘焦点。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-524">Gets a value that indicates whether this element has keyboard focus.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="f4180-525">如果此元素具有键盘焦点，则为 <see langword="true" />；否则为 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-525">
              <see langword="true" /> if this element has keyboard focus; otherwise, <see langword="false" />.</span>
          </span>
          <span data-ttu-id="f4180-526">默认值为 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-526">The default is <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="dependencyPropertyInfo_IsKeyboardFocused"></a>   
## <a name="dependency-property-information"></a><span data-ttu-id="f4180-527">依赖项属性信息</span><span class="sxs-lookup"><span data-stu-id="f4180-527">Dependency Property Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="f4180-528">标识符字段</span><span class="sxs-lookup"><span data-stu-id="f4180-528">Identifier field</span></span>|<xref:System.Windows.ContentElement.IsKeyboardFocusedProperty>|  
|<span data-ttu-id="f4180-529">元数据属性设置为 `true`</span><span class="sxs-lookup"><span data-stu-id="f4180-529">Metadata properties set to `true`</span></span>|<span data-ttu-id="f4180-530">无</span><span class="sxs-lookup"><span data-stu-id="f4180-530">None</span></span>|  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.GotFocus" />
        <altmember cref="E:System.Windows.ContentElement.LostFocus" />
      </Docs>
    </Member>
    <Member MemberName="IsKeyboardFocusedChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.DependencyPropertyChangedEventHandler IsKeyboardFocusedChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DependencyPropertyChangedEventHandler IsKeyboardFocusedChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.IsKeyboardFocusedChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event IsKeyboardFocusedChanged As DependencyPropertyChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DependencyPropertyChangedEventHandler ^ IsKeyboardFocusedChanged;" />
      <MemberSignature Language="F#" Value="member this.IsKeyboardFocusedChanged : System.Windows.DependencyPropertyChangedEventHandler " Usage="member this.IsKeyboardFocusedChanged : System.Windows.DependencyPropertyChangedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f4180-531">在此元素的 <see cref="P:System.Windows.ContentElement.IsKeyboardFocused" /> 属性值更改时发生。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-531">Occurs when the value of the <see cref="P:System.Windows.ContentElement.IsKeyboardFocused" /> property changes on this element.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4180-532">此成员是[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]事件、 不是路由的事件。</span><span class="sxs-lookup"><span data-stu-id="f4180-532">This member is a [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] event, not a routed event.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsKeyboardFocusedProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsKeyboardFocusedProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsKeyboardFocusedProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.IsKeyboardFocusedProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IsKeyboardFocusedProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ IsKeyboardFocusedProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable IsKeyboardFocusedProperty : System.Windows.DependencyProperty" Usage="System.Windows.ContentElement.IsKeyboardFocusedProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f4180-533">标识 <see cref="P:System.Windows.ContentElement.IsKeyboardFocused" /> 依赖项属性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-533">Identifies the <see cref="P:System.Windows.ContentElement.IsKeyboardFocused" /> dependency property.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsKeyboardFocusWithin">
      <MemberSignature Language="C#" Value="public bool IsKeyboardFocusWithin { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsKeyboardFocusWithin" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.IsKeyboardFocusWithin" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsKeyboardFocusWithin As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsKeyboardFocusWithin { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsKeyboardFocusWithin : bool" Usage="System.Windows.ContentElement.IsKeyboardFocusWithin" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.IInputElement.IsKeyboardFocusWithin</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f4180-534">获取一个值，该值指示键盘焦点是否位于元素或子元素内的任意位置。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-534">Gets a value that indicates whether keyboard focus is anywhere within the element or child elements.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="f4180-535">如果键盘焦点在元素或其子元素上，则为 <see langword="true" />；否则为 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-535">
              <see langword="true" /> if keyboard focus is on the element or its child elements; otherwise, <see langword="false" />.</span>
          </span>
          <span data-ttu-id="f4180-536">默认值为 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-536">The default is <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4180-537">更改此属性的值通常会引发<xref:System.Windows.ContentElement.IsKeyboardFocusWithinChanged>事件，除非在派生的类已重写<xref:System.Windows.ContentElement.OnIsKeyboardFocusWithinChanged%2A>若要禁止显示该事件。</span><span class="sxs-lookup"><span data-stu-id="f4180-537">Changes to the value of this property typically raise the <xref:System.Windows.ContentElement.IsKeyboardFocusWithinChanged> event, unless a derived class has overridden <xref:System.Windows.ContentElement.OnIsKeyboardFocusWithinChanged%2A> to suppress the event.</span></span>  
  
 <span data-ttu-id="f4180-538">不能直接，设置此属性，但您可以通过调用将焦点设置到元素<xref:System.Windows.ContentElement.Focus%2A>，或通过使<xref:System.Windows.ContentElement.MoveFocus%2A>请求。</span><span class="sxs-lookup"><span data-stu-id="f4180-538">You do not set this property directly, but you can set the focus to the element by calling <xref:System.Windows.ContentElement.Focus%2A>, or by making a <xref:System.Windows.ContentElement.MoveFocus%2A> request.</span></span> <span data-ttu-id="f4180-539">这些方法调用之一可能会更改此属性的值。</span><span class="sxs-lookup"><span data-stu-id="f4180-539">Either of these method calls might change this property value.</span></span>  
  
<a name="dependencyPropertyInfo_IsKeyboardFocusWithin"></a>   
## <a name="dependency-property-information"></a><span data-ttu-id="f4180-540">依赖项属性信息</span><span class="sxs-lookup"><span data-stu-id="f4180-540">Dependency Property Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="f4180-541">标识符字段</span><span class="sxs-lookup"><span data-stu-id="f4180-541">Identifier field</span></span>|<xref:System.Windows.ContentElement.IsKeyboardFocusWithinProperty>|  
|<span data-ttu-id="f4180-542">元数据属性设置为 `true`</span><span class="sxs-lookup"><span data-stu-id="f4180-542">Metadata properties set to `true`</span></span>|<span data-ttu-id="f4180-543">无</span><span class="sxs-lookup"><span data-stu-id="f4180-543">None</span></span>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsKeyboardFocusWithinChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.DependencyPropertyChangedEventHandler IsKeyboardFocusWithinChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DependencyPropertyChangedEventHandler IsKeyboardFocusWithinChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.IsKeyboardFocusWithinChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event IsKeyboardFocusWithinChanged As DependencyPropertyChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DependencyPropertyChangedEventHandler ^ IsKeyboardFocusWithinChanged;" />
      <MemberSignature Language="F#" Value="member this.IsKeyboardFocusWithinChanged : System.Windows.DependencyPropertyChangedEventHandler " Usage="member this.IsKeyboardFocusWithinChanged : System.Windows.DependencyPropertyChangedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f4180-544">在此元素的 <see cref="E:System.Windows.ContentElement.IsKeyboardFocusWithinChanged" /> 属性值更改时发生。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-544">Occurs when the value of the <see cref="E:System.Windows.ContentElement.IsKeyboardFocusWithinChanged" /> property changes on this element.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4180-545">此成员是[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]事件、 不是路由的事件。</span><span class="sxs-lookup"><span data-stu-id="f4180-545">This member is a [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] event, not a routed event.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.IsKeyboardFocusedChanged" />
      </Docs>
    </Member>
    <Member MemberName="IsKeyboardFocusWithinProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsKeyboardFocusWithinProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsKeyboardFocusWithinProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.IsKeyboardFocusWithinProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IsKeyboardFocusWithinProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ IsKeyboardFocusWithinProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable IsKeyboardFocusWithinProperty : System.Windows.DependencyProperty" Usage="System.Windows.ContentElement.IsKeyboardFocusWithinProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f4180-546">标识 <see cref="P:System.Windows.ContentElement.IsKeyboardFocusWithin" /> 依赖项属性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-546">Identifies the <see cref="P:System.Windows.ContentElement.IsKeyboardFocusWithin" /> dependency property.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsMouseCaptured">
      <MemberSignature Language="C#" Value="public bool IsMouseCaptured { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsMouseCaptured" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.IsMouseCaptured" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsMouseCaptured As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsMouseCaptured { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsMouseCaptured : bool" Usage="System.Windows.ContentElement.IsMouseCaptured" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.IInputElement.IsMouseCaptured</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f4180-547">获取一个值，该值指示此元素是否捕获了鼠标。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-547">Gets a value that indicates whether the mouse is captured by this element.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="f4180-548">如果元素具有鼠标捕获，则为 <see langword="true" />；否则为 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-548">
              <see langword="true" /> if the element has mouse capture; otherwise, <see langword="false" />.</span>
          </span>
          <span data-ttu-id="f4180-549">默认值为 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-549">The default is <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4180-550">鼠标捕获状态相关于进程内拖放操作。</span><span class="sxs-lookup"><span data-stu-id="f4180-550">Mouse capture state is related to in-process drag-and-drop operations.</span></span>  
  
<a name="dependencyPropertyInfo_IsMouseCaptured"></a>   
## <a name="dependency-property-information"></a><span data-ttu-id="f4180-551">依赖项属性信息</span><span class="sxs-lookup"><span data-stu-id="f4180-551">Dependency Property Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="f4180-552">标识符字段</span><span class="sxs-lookup"><span data-stu-id="f4180-552">Identifier field</span></span>|<xref:System.Windows.ContentElement.IsMouseCapturedProperty>|  
|<span data-ttu-id="f4180-553">元数据属性设置为 `true`</span><span class="sxs-lookup"><span data-stu-id="f4180-553">Metadata properties set to `true`</span></span>|<span data-ttu-id="f4180-554">无</span><span class="sxs-lookup"><span data-stu-id="f4180-554">None</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="f4180-555">下面的示例将鼠标捕获状态打开或关闭基础上的元素是否已捕获鼠标。</span><span class="sxs-lookup"><span data-stu-id="f4180-555">The following example turns the mouse capture state on or off based on whether the mouse is already captured by the element.</span></span>  
  
 [!code-csharp[ContentElementsSmorgasbord#IsMouseCaptured](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml.cs#ismousecaptured)]
 [!code-vb[ContentElementsSmorgasbord#IsMouseCaptured](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContentElementsSmorgasbord/visualbasic/page1.xaml.vb#ismousecaptured)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.ContentElement.CaptureMouse" />
        <altmember cref="E:System.Windows.ContentElement.GotMouseCapture" />
        <altmember cref="E:System.Windows.ContentElement.LostMouseCapture" />
      </Docs>
    </Member>
    <Member MemberName="IsMouseCapturedChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.DependencyPropertyChangedEventHandler IsMouseCapturedChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DependencyPropertyChangedEventHandler IsMouseCapturedChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.IsMouseCapturedChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event IsMouseCapturedChanged As DependencyPropertyChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DependencyPropertyChangedEventHandler ^ IsMouseCapturedChanged;" />
      <MemberSignature Language="F#" Value="member this.IsMouseCapturedChanged : System.Windows.DependencyPropertyChangedEventHandler " Usage="member this.IsMouseCapturedChanged : System.Windows.DependencyPropertyChangedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f4180-556">在此元素的 <see cref="P:System.Windows.ContentElement.IsMouseCaptured" /> 属性值更改时发生。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-556">Occurs when the value of the <see cref="P:System.Windows.ContentElement.IsMouseCaptured" /> property changes on this element.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4180-557">此成员是[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]事件、 不是路由的事件。</span><span class="sxs-lookup"><span data-stu-id="f4180-557">This member is a [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] event, not a routed event.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsMouseCapturedProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsMouseCapturedProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsMouseCapturedProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.IsMouseCapturedProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IsMouseCapturedProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ IsMouseCapturedProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable IsMouseCapturedProperty : System.Windows.DependencyProperty" Usage="System.Windows.ContentElement.IsMouseCapturedProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f4180-558">标识 <see cref="P:System.Windows.ContentElement.IsMouseCaptured" /> 依赖项属性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-558">Identifies the <see cref="P:System.Windows.ContentElement.IsMouseCaptured" /> dependency property.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsMouseCaptureWithin">
      <MemberSignature Language="C#" Value="public bool IsMouseCaptureWithin { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsMouseCaptureWithin" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.IsMouseCaptureWithin" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsMouseCaptureWithin As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsMouseCaptureWithin { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsMouseCaptureWithin : bool" Usage="System.Windows.ContentElement.IsMouseCaptureWithin" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f4180-559">获取一个值，该值确定此元素或其元素树中的子元素是否有鼠标捕获。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-559">Gets a value that determines whether mouse capture is held by this element or by child elements in its element tree.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="f4180-560">如果此元素或其包含的元素具有鼠标捕获，则为 <see langword="true" />；否则为 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-560">
              <see langword="true" /> if this element or a contained element has mouse capture; otherwise, <see langword="false" />.</span>
          </span>
          <span data-ttu-id="f4180-561">默认值为 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-561">The default is <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="dependencyPropertyInfo_IsMouseCaptureWithin"></a>   
## <a name="dependency-property-information"></a><span data-ttu-id="f4180-562">依赖项属性信息</span><span class="sxs-lookup"><span data-stu-id="f4180-562">Dependency Property Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="f4180-563">标识符字段</span><span class="sxs-lookup"><span data-stu-id="f4180-563">Identifier field</span></span>|<xref:System.Windows.ContentElement.IsMouseCaptureWithinProperty>|  
|<span data-ttu-id="f4180-564">元数据属性设置为 `true`</span><span class="sxs-lookup"><span data-stu-id="f4180-564">Metadata properties set to `true`</span></span>|<span data-ttu-id="f4180-565">无</span><span class="sxs-lookup"><span data-stu-id="f4180-565">None</span></span>|  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.ContentElement.IsMouseCaptured" />
        <altmember cref="M:System.Windows.ContentElement.CaptureMouse" />
      </Docs>
    </Member>
    <Member MemberName="IsMouseCaptureWithinChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.DependencyPropertyChangedEventHandler IsMouseCaptureWithinChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DependencyPropertyChangedEventHandler IsMouseCaptureWithinChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.IsMouseCaptureWithinChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event IsMouseCaptureWithinChanged As DependencyPropertyChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DependencyPropertyChangedEventHandler ^ IsMouseCaptureWithinChanged;" />
      <MemberSignature Language="F#" Value="member this.IsMouseCaptureWithinChanged : System.Windows.DependencyPropertyChangedEventHandler " Usage="member this.IsMouseCaptureWithinChanged : System.Windows.DependencyPropertyChangedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f4180-566">在此元素的 <see cref="F:System.Windows.ContentElement.IsMouseCaptureWithinProperty" /> 值更改时发生。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-566">Occurs when the value of the <see cref="F:System.Windows.ContentElement.IsMouseCaptureWithinProperty" /> changes on this element.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4180-567">此成员是[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]事件、 不是路由的事件。</span><span class="sxs-lookup"><span data-stu-id="f4180-567">This member is a [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] event, not a routed event.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsMouseCaptureWithinProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsMouseCaptureWithinProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsMouseCaptureWithinProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.IsMouseCaptureWithinProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IsMouseCaptureWithinProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ IsMouseCaptureWithinProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable IsMouseCaptureWithinProperty : System.Windows.DependencyProperty" Usage="System.Windows.ContentElement.IsMouseCaptureWithinProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f4180-568">标识 <see cref="P:System.Windows.ContentElement.IsMouseCaptureWithin" /> 依赖项属性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-568">Identifies the <see cref="P:System.Windows.ContentElement.IsMouseCaptureWithin" /> dependency property.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsMouseDirectlyOver">
      <MemberSignature Language="C#" Value="public bool IsMouseDirectlyOver { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsMouseDirectlyOver" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.IsMouseDirectlyOver" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsMouseDirectlyOver As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsMouseDirectlyOver { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsMouseDirectlyOver : bool" Usage="System.Windows.ContentElement.IsMouseDirectlyOver" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.IInputElement.IsMouseDirectlyOver</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f4180-569">获取一个值，该值指示在考虑元素组合的情况下，鼠标指针的位置是否与命中测试结果相对应。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-569">Gets a value that indicates whether the position of the mouse pointer corresponds to hit test results, which take element compositing into account.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="f4180-570">
            <see langword="true" /> 如果鼠标指针位于与命中测试; 位于同一元素结果否则为<see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-570">
              <see langword="true" /> if the mouse pointer is over the same element result as a hit test; otherwise, <see langword="false" />.</span>
          </span>
          <span data-ttu-id="f4180-571">默认值为 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-571">The default is <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4180-572">与不同<xref:System.Windows.ContentElement.IsMouseOver%2A>，此属性才是`true`如果鼠标指针悬停于文本元素，它是否与命中测试一样。</span><span class="sxs-lookup"><span data-stu-id="f4180-572">Unlike <xref:System.Windows.ContentElement.IsMouseOver%2A>, this property is only `true` if the mouse pointer is over the literal element—as it is for a hit test.</span></span> <span data-ttu-id="f4180-573">而如果鼠标指针位于子元素上，特别是对所包含的元素的更深层的模板和组合的情况下，元素，此属性将为`false`。</span><span class="sxs-lookup"><span data-stu-id="f4180-573">If the mouse pointer is instead over a child element, in particular over elements that are part of an element's deeper template and compositing, this property will be `false`.</span></span> <span data-ttu-id="f4180-574">除非你知道如何控件的组合 （例如，使用此属性在自定义控件模板中定义的控件），此属性可能返回意外的结果。</span><span class="sxs-lookup"><span data-stu-id="f4180-574">Unless you know how a control is composited (for example, you use this property in a custom control template for a control that you define), this property might return unexpected results.</span></span> <span data-ttu-id="f4180-575">对于大多数情况下不创作控件的情况，请使用<xref:System.Windows.ContentElement.IsMouseOver%2A>相反。</span><span class="sxs-lookup"><span data-stu-id="f4180-575">For most scenarios where you are not authoring controls, use <xref:System.Windows.ContentElement.IsMouseOver%2A> instead.</span></span>  
  
 <span data-ttu-id="f4180-576">如果此元素捕获鼠标，并且此属性是`true`在捕获时，此属性将继续返回`true`直到失去鼠标捕获，并且指针不是其边界上。</span><span class="sxs-lookup"><span data-stu-id="f4180-576">If the mouse is captured by this element, and this property is `true` at time of capture, this property will continue to return `true` until mouse capture is lost and the pointer is not over its bounds.</span></span>  
  
<a name="dependencyPropertyInfo_IsMouseDirectlyOver"></a>   
## <a name="dependency-property-information"></a><span data-ttu-id="f4180-577">依赖项属性信息</span><span class="sxs-lookup"><span data-stu-id="f4180-577">Dependency Property Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="f4180-578">标识符字段</span><span class="sxs-lookup"><span data-stu-id="f4180-578">Identifier field</span></span>|<xref:System.Windows.ContentElement.IsMouseDirectlyOverProperty>|  
|<span data-ttu-id="f4180-579">元数据属性设置为 `true`</span><span class="sxs-lookup"><span data-stu-id="f4180-579">Metadata properties set to `true`</span></span>|<span data-ttu-id="f4180-580">无</span><span class="sxs-lookup"><span data-stu-id="f4180-580">None</span></span>|  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.MouseEnter" />
        <altmember cref="E:System.Windows.ContentElement.MouseLeave" />
      </Docs>
    </Member>
    <Member MemberName="IsMouseDirectlyOverChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.DependencyPropertyChangedEventHandler IsMouseDirectlyOverChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DependencyPropertyChangedEventHandler IsMouseDirectlyOverChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.IsMouseDirectlyOverChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event IsMouseDirectlyOverChanged As DependencyPropertyChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DependencyPropertyChangedEventHandler ^ IsMouseDirectlyOverChanged;" />
      <MemberSignature Language="F#" Value="member this.IsMouseDirectlyOverChanged : System.Windows.DependencyPropertyChangedEventHandler " Usage="member this.IsMouseDirectlyOverChanged : System.Windows.DependencyPropertyChangedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f4180-581">在此元素的 <see cref="P:System.Windows.ContentElement.IsMouseDirectlyOver" /> 属性值更改时发生。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-581">Occurs when the value of the <see cref="P:System.Windows.ContentElement.IsMouseDirectlyOver" /> property changes on this element.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4180-582">此成员是[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]事件、 不是路由的事件。</span><span class="sxs-lookup"><span data-stu-id="f4180-582">This member is a [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] event, not a routed event.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsMouseDirectlyOverProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsMouseDirectlyOverProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsMouseDirectlyOverProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.IsMouseDirectlyOverProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IsMouseDirectlyOverProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ IsMouseDirectlyOverProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable IsMouseDirectlyOverProperty : System.Windows.DependencyProperty" Usage="System.Windows.ContentElement.IsMouseDirectlyOverProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f4180-583">标识 <see cref="P:System.Windows.ContentElement.IsMouseDirectlyOver" /> 依赖项属性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-583">Identifies the <see cref="P:System.Windows.ContentElement.IsMouseDirectlyOver" /> dependency property.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsMouseOver">
      <MemberSignature Language="C#" Value="public bool IsMouseOver { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsMouseOver" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.IsMouseOver" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsMouseOver As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsMouseOver { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsMouseOver : bool" Usage="System.Windows.ContentElement.IsMouseOver" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.IInputElement.IsMouseOver</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f4180-584">获取一个值，该值指示鼠标指针是否位于此元素（包括可视子元素或其控件组合）上。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-584">Gets a value that indicates whether the mouse pointer is located over this element (including visual child elements, or its control compositing).</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="f4180-585">如果鼠标指针悬停于此元素或其子元素上，则为 <see langword="true" />；否则为 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-585">
              <see langword="true" /> if mouse pointer is over the element or its child elements; otherwise, <see langword="false" />.</span>
          </span>
          <span data-ttu-id="f4180-586">默认值为 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-586">The default is <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4180-587">尽管类似"等效于"事件不存在，将通过几个类似的事件。</span><span class="sxs-lookup"><span data-stu-id="f4180-587">Although an analogous "IsMouseOverChanged" event does not exist, several similar events do.</span></span> <span data-ttu-id="f4180-588">例如，可以使用<xref:System.Windows.ContentElement.MouseEnter>， <xref:System.Windows.ContentElement.MouseMove>，和<xref:System.Windows.ContentElement.IsMouseDirectlyOverChanged>。</span><span class="sxs-lookup"><span data-stu-id="f4180-588">For example, you can use <xref:System.Windows.ContentElement.MouseEnter>, <xref:System.Windows.ContentElement.MouseMove>, and <xref:System.Windows.ContentElement.IsMouseDirectlyOverChanged>.</span></span>  
  
 <span data-ttu-id="f4180-589">如果此元素捕获鼠标时，此属性将保持`true`直到失去鼠标捕获并且鼠标指针离开元素边界。</span><span class="sxs-lookup"><span data-stu-id="f4180-589">If this element captures the mouse, this property remains `true` until mouse capture is lost and the mouse pointer leaves the element bounds.</span></span>  
  
<a name="dependencyPropertyInfo_IsMouseOver"></a>   
## <a name="dependency-property-information"></a><span data-ttu-id="f4180-590">依赖项属性信息</span><span class="sxs-lookup"><span data-stu-id="f4180-590">Dependency Property Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="f4180-591">标识符字段</span><span class="sxs-lookup"><span data-stu-id="f4180-591">Identifier field</span></span>|<xref:System.Windows.ContentElement.IsMouseOverProperty>|  
|<span data-ttu-id="f4180-592">元数据属性设置为 `true`</span><span class="sxs-lookup"><span data-stu-id="f4180-592">Metadata properties set to `true`</span></span>|<span data-ttu-id="f4180-593">无</span><span class="sxs-lookup"><span data-stu-id="f4180-593">None</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="f4180-594">下面的示例创建包含提供备用的可视行为的属性 setter 的样式时<xref:System.Windows.Documents.Hyperlink>报表<xref:System.Windows.ContentElement.IsMouseOver%2A> `true`。</span><span class="sxs-lookup"><span data-stu-id="f4180-594">The following example creates a style that includes a property setter that gives an alternate visual behavior when a <xref:System.Windows.Documents.Hyperlink> reports <xref:System.Windows.ContentElement.IsMouseOver%2A> `true`.</span></span>  
  
 [!code-xaml[ContentElementsSmorgasbord#IsEnabledIsMouseOver](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml#isenabledismouseover)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsMouseOverProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsMouseOverProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsMouseOverProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.IsMouseOverProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IsMouseOverProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ IsMouseOverProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable IsMouseOverProperty : System.Windows.DependencyProperty" Usage="System.Windows.ContentElement.IsMouseOverProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f4180-595">标识 <see cref="P:System.Windows.ContentElement.IsMouseOver" /> 依赖项属性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-595">Identifies the <see cref="P:System.Windows.ContentElement.IsMouseOver" /> dependency property.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsStylusCaptured">
      <MemberSignature Language="C#" Value="public bool IsStylusCaptured { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsStylusCaptured" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.IsStylusCaptured" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsStylusCaptured As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsStylusCaptured { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsStylusCaptured : bool" Usage="System.Windows.ContentElement.IsStylusCaptured" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.IInputElement.IsStylusCaptured</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f4180-596">获取一个值，该值指示是否将触笔捕获到此元素。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-596">Gets a value that indicates whether the stylus is captured to this element.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="f4180-597">如果元素具有触笔捕获，则为 <see langword="true" />；否则为 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-597">
              <see langword="true" /> if the element has stylus capture; otherwise, <see langword="false" />.</span>
          </span>
          <span data-ttu-id="f4180-598">默认值为 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-598">The default is <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4180-599">触摸、 鼠标和触笔输入中的特定关系存在。</span><span class="sxs-lookup"><span data-stu-id="f4180-599">Touch, mouse, and stylus input exist in a particular relationship.</span></span> <span data-ttu-id="f4180-600">有关详细信息，请参阅[输入概述](~/docs/framework/wpf/advanced/input-overview.md)。</span><span class="sxs-lookup"><span data-stu-id="f4180-600">For more information, see [Input Overview](~/docs/framework/wpf/advanced/input-overview.md).</span></span>  
  
<a name="dependencyPropertyInfo_IsStylusCaptured"></a>   
## <a name="dependency-property-information"></a><span data-ttu-id="f4180-601">依赖项属性信息</span><span class="sxs-lookup"><span data-stu-id="f4180-601">Dependency Property Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="f4180-602">标识符字段</span><span class="sxs-lookup"><span data-stu-id="f4180-602">Identifier field</span></span>|<xref:System.Windows.ContentElement.IsStylusCapturedProperty>|  
|<span data-ttu-id="f4180-603">元数据属性设置为 `true`</span><span class="sxs-lookup"><span data-stu-id="f4180-603">Metadata properties set to `true`</span></span>|<span data-ttu-id="f4180-604">无</span><span class="sxs-lookup"><span data-stu-id="f4180-604">None</span></span>|  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.ContentElement.CaptureStylus" />
        <altmember cref="E:System.Windows.ContentElement.GotStylusCapture" />
        <altmember cref="E:System.Windows.ContentElement.LostStylusCapture" />
      </Docs>
    </Member>
    <Member MemberName="IsStylusCapturedChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.DependencyPropertyChangedEventHandler IsStylusCapturedChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DependencyPropertyChangedEventHandler IsStylusCapturedChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.IsStylusCapturedChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event IsStylusCapturedChanged As DependencyPropertyChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DependencyPropertyChangedEventHandler ^ IsStylusCapturedChanged;" />
      <MemberSignature Language="F#" Value="member this.IsStylusCapturedChanged : System.Windows.DependencyPropertyChangedEventHandler " Usage="member this.IsStylusCapturedChanged : System.Windows.DependencyPropertyChangedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f4180-605">在此元素的 <see cref="P:System.Windows.ContentElement.IsStylusCaptured" /> 属性值更改时发生。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-605">Occurs when the value of the <see cref="P:System.Windows.ContentElement.IsStylusCaptured" /> property changes on this element.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4180-606">此成员是[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]事件、 不是路由的事件。</span><span class="sxs-lookup"><span data-stu-id="f4180-606">This member is a [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] event, not a routed event.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsStylusCapturedProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsStylusCapturedProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsStylusCapturedProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.IsStylusCapturedProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IsStylusCapturedProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ IsStylusCapturedProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable IsStylusCapturedProperty : System.Windows.DependencyProperty" Usage="System.Windows.ContentElement.IsStylusCapturedProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f4180-607">标识 <see cref="P:System.Windows.ContentElement.IsStylusCaptured" /> 依赖项属性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-607">Identifies the <see cref="P:System.Windows.ContentElement.IsStylusCaptured" /> dependency property.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsStylusCaptureWithin">
      <MemberSignature Language="C#" Value="public bool IsStylusCaptureWithin { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsStylusCaptureWithin" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.IsStylusCaptureWithin" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsStylusCaptureWithin As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsStylusCaptureWithin { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsStylusCaptureWithin : bool" Usage="System.Windows.ContentElement.IsStylusCaptureWithin" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f4180-608">获取一个值，该值确定此元素（包括子元素和控件组合）是否具有触笔捕获。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-608">Gets a value that determines whether stylus capture is held by this element, including child elements and control compositing.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="f4180-609">如果在此元素中具有触笔捕获，则为 <see langword="true" />；否则为 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-609">
              <see langword="true" /> if stylus capture is held within this element; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4180-610">触摸、 鼠标和触笔输入中的特定关系存在。</span><span class="sxs-lookup"><span data-stu-id="f4180-610">Touch, mouse, and stylus input exist in a particular relationship.</span></span> <span data-ttu-id="f4180-611">有关详细信息，请参阅[输入概述](~/docs/framework/wpf/advanced/input-overview.md)。</span><span class="sxs-lookup"><span data-stu-id="f4180-611">For more information, see [Input Overview](~/docs/framework/wpf/advanced/input-overview.md).</span></span>  
  
<a name="dependencyPropertyInfo_IsStylusCaptureWithin"></a>   
## <a name="dependency-property-information"></a><span data-ttu-id="f4180-612">依赖项属性信息</span><span class="sxs-lookup"><span data-stu-id="f4180-612">Dependency Property Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="f4180-613">标识符字段</span><span class="sxs-lookup"><span data-stu-id="f4180-613">Identifier field</span></span>|<xref:System.Windows.ContentElement.IsStylusCaptureWithinProperty>|  
|<span data-ttu-id="f4180-614">元数据属性设置为 `true`</span><span class="sxs-lookup"><span data-stu-id="f4180-614">Metadata properties set to `true`</span></span>|<span data-ttu-id="f4180-615">无</span><span class="sxs-lookup"><span data-stu-id="f4180-615">None</span></span>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsStylusCaptureWithinChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.DependencyPropertyChangedEventHandler IsStylusCaptureWithinChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DependencyPropertyChangedEventHandler IsStylusCaptureWithinChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.IsStylusCaptureWithinChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event IsStylusCaptureWithinChanged As DependencyPropertyChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DependencyPropertyChangedEventHandler ^ IsStylusCaptureWithinChanged;" />
      <MemberSignature Language="F#" Value="member this.IsStylusCaptureWithinChanged : System.Windows.DependencyPropertyChangedEventHandler " Usage="member this.IsStylusCaptureWithinChanged : System.Windows.DependencyPropertyChangedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f4180-616">在此元素的 <see cref="P:System.Windows.ContentElement.IsStylusCaptureWithin" /> 属性值更改时发生。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-616">Occurs when the value of the <see cref="P:System.Windows.ContentElement.IsStylusCaptureWithin" /> property changes on this element.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4180-617">此成员是[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]事件、 不是路由的事件。</span><span class="sxs-lookup"><span data-stu-id="f4180-617">This member is a [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] event, not a routed event.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsStylusCaptureWithinProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsStylusCaptureWithinProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsStylusCaptureWithinProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.IsStylusCaptureWithinProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IsStylusCaptureWithinProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ IsStylusCaptureWithinProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable IsStylusCaptureWithinProperty : System.Windows.DependencyProperty" Usage="System.Windows.ContentElement.IsStylusCaptureWithinProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f4180-618">标识 <see cref="P:System.Windows.ContentElement.IsStylusCaptureWithin" /> 依赖项属性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-618">Identifies the <see cref="P:System.Windows.ContentElement.IsStylusCaptureWithin" /> dependency property.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsStylusDirectlyOver">
      <MemberSignature Language="C#" Value="public bool IsStylusDirectlyOver { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsStylusDirectlyOver" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.IsStylusDirectlyOver" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsStylusDirectlyOver As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsStylusDirectlyOver { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsStylusDirectlyOver : bool" Usage="System.Windows.ContentElement.IsStylusDirectlyOver" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.IInputElement.IsStylusDirectlyOver</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f4180-619">获取一个值，该值指示在考虑元素组合的情况下，触笔的位置是否与命中测试结果相对应。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-619">Gets a value that indicates whether the stylus position corresponds to hit test results, which take element compositing into account.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="f4180-620">如果触笔与命中测试位于同一元素上，则为 <see langword="true" />；否则为 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-620">
              <see langword="true" /> if the stylus is over the same element as a hit test; otherwise, <see langword="false" />.</span>
          </span>
          <span data-ttu-id="f4180-621">默认值为 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-621">The default is <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4180-622">与不同<xref:System.Windows.ContentElement.IsStylusOver%2A>，此属性才是`true`如果触笔位于元素上。</span><span class="sxs-lookup"><span data-stu-id="f4180-622">Unlike <xref:System.Windows.ContentElement.IsStylusOver%2A>, this property is only `true` if the stylus is over the element.</span></span> <span data-ttu-id="f4180-623">如果触笔改为通过子元素或属于某个元素的更深入地组合的元素，此属性将为`false`。</span><span class="sxs-lookup"><span data-stu-id="f4180-623">If the stylus is instead over a child element or over elements that are part of an element's deeper compositing, this property will be `false`.</span></span>  
  
 <span data-ttu-id="f4180-624">除非你知道如何控件的组合 （例如，使用此属性在自定义控件模板中定义的控件），此属性可能返回意外的结果。</span><span class="sxs-lookup"><span data-stu-id="f4180-624">Unless you know how a control is composited (for example, you use this property in a custom control template for a control that you define), this property might return unexpected results.</span></span> <span data-ttu-id="f4180-625">对于大多数情况下不创作控件的情况，请使用<xref:System.Windows.ContentElement.IsStylusOver%2A>相反。</span><span class="sxs-lookup"><span data-stu-id="f4180-625">For most scenarios where you are not authoring controls, use <xref:System.Windows.ContentElement.IsStylusOver%2A> instead.</span></span>  
  
 <span data-ttu-id="f4180-626">如果此元素具有触笔捕获，并且此属性是`true`捕获时，此属性将保持`true`直到触笔捕获，丢失和触笔不能通过其边界。</span><span class="sxs-lookup"><span data-stu-id="f4180-626">If this element has stylus capture and this property is `true` at the time of capture, this property remains `true` until stylus capture is lost and the stylus is not over its bounds.</span></span>  
  
 <span data-ttu-id="f4180-627">触摸、 鼠标和触笔输入中的特定关系存在。</span><span class="sxs-lookup"><span data-stu-id="f4180-627">Touch, mouse, and stylus input exist in a particular relationship.</span></span> <span data-ttu-id="f4180-628">有关详细信息，请参阅[输入概述](~/docs/framework/wpf/advanced/input-overview.md)。</span><span class="sxs-lookup"><span data-stu-id="f4180-628">For more information, see [Input Overview](~/docs/framework/wpf/advanced/input-overview.md).</span></span>  
  
<a name="dependencyPropertyInfo_IsStylusDirectlyOver"></a>   
## <a name="dependency-property-information"></a><span data-ttu-id="f4180-629">依赖项属性信息</span><span class="sxs-lookup"><span data-stu-id="f4180-629">Dependency Property Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="f4180-630">标识符字段</span><span class="sxs-lookup"><span data-stu-id="f4180-630">Identifier field</span></span>|<xref:System.Windows.ContentElement.IsStylusDirectlyOverProperty>|  
|<span data-ttu-id="f4180-631">元数据属性设置为 `true`</span><span class="sxs-lookup"><span data-stu-id="f4180-631">Metadata properties set to `true`</span></span>|<span data-ttu-id="f4180-632">无</span><span class="sxs-lookup"><span data-stu-id="f4180-632">None</span></span>|  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.ContentElement.IsMouseDirectlyOver" />
      </Docs>
    </Member>
    <Member MemberName="IsStylusDirectlyOverChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.DependencyPropertyChangedEventHandler IsStylusDirectlyOverChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DependencyPropertyChangedEventHandler IsStylusDirectlyOverChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.IsStylusDirectlyOverChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event IsStylusDirectlyOverChanged As DependencyPropertyChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DependencyPropertyChangedEventHandler ^ IsStylusDirectlyOverChanged;" />
      <MemberSignature Language="F#" Value="member this.IsStylusDirectlyOverChanged : System.Windows.DependencyPropertyChangedEventHandler " Usage="member this.IsStylusDirectlyOverChanged : System.Windows.DependencyPropertyChangedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f4180-633">在此元素的 <see cref="P:System.Windows.ContentElement.IsStylusDirectlyOver" /> 属性值更改时发生。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-633">Occurs when the value of the <see cref="P:System.Windows.ContentElement.IsStylusDirectlyOver" /> property changes on this element.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4180-634">此成员是[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]事件、 不是路由的事件。</span><span class="sxs-lookup"><span data-stu-id="f4180-634">This member is a [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] event, not a routed event.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsStylusDirectlyOverProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsStylusDirectlyOverProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsStylusDirectlyOverProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.IsStylusDirectlyOverProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IsStylusDirectlyOverProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ IsStylusDirectlyOverProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable IsStylusDirectlyOverProperty : System.Windows.DependencyProperty" Usage="System.Windows.ContentElement.IsStylusDirectlyOverProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f4180-635">标识 <see cref="P:System.Windows.ContentElement.IsStylusDirectlyOver" /> 依赖项属性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-635">Identifies the <see cref="P:System.Windows.ContentElement.IsStylusDirectlyOver" /> dependency property.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsStylusOver">
      <MemberSignature Language="C#" Value="public bool IsStylusOver { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsStylusOver" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.IsStylusOver" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsStylusOver As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsStylusOver { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsStylusOver : bool" Usage="System.Windows.ContentElement.IsStylusOver" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.IInputElement.IsStylusOver</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f4180-636">获取一个值，该值指示触笔是否位于此元素（包括可视子元素）上。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-636">Gets a value that indicates whether the stylus is located over this element (including visual child elements).</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="f4180-637">如果触笔位于此元素或其子元素上，则为 <see langword="true" />；否则为 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-637">
              <see langword="true" /> if the stylus is over the element or its child elements; otherwise, <see langword="false" />.</span>
          </span>
          <span data-ttu-id="f4180-638">默认值为 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-638">The default is <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4180-639">如果此元素具有触笔捕获，则此属性保持`true`直到丢失触笔捕获并且鼠标指针离开其边界。</span><span class="sxs-lookup"><span data-stu-id="f4180-639">If this element has stylus capture, this property remains `true` until stylus capture is lost and the pointer is out of its bounds.</span></span>  
  
 <span data-ttu-id="f4180-640">触摸、 鼠标和触笔输入中的特定关系存在。</span><span class="sxs-lookup"><span data-stu-id="f4180-640">Touch, mouse, and stylus input exist in a particular relationship.</span></span> <span data-ttu-id="f4180-641">有关详细信息，请参阅[输入概述](~/docs/framework/wpf/advanced/input-overview.md)。</span><span class="sxs-lookup"><span data-stu-id="f4180-641">For more information, see [Input Overview](~/docs/framework/wpf/advanced/input-overview.md).</span></span>  
  
<a name="dependencyPropertyInfo_IsStylusOver"></a>   
## <a name="dependency-property-information"></a><span data-ttu-id="f4180-642">依赖项属性信息</span><span class="sxs-lookup"><span data-stu-id="f4180-642">Dependency Property Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="f4180-643">标识符字段</span><span class="sxs-lookup"><span data-stu-id="f4180-643">Identifier field</span></span>|<xref:System.Windows.ContentElement.IsStylusOverProperty>|  
|<span data-ttu-id="f4180-644">元数据属性设置为 `true`</span><span class="sxs-lookup"><span data-stu-id="f4180-644">Metadata properties set to `true`</span></span>|<span data-ttu-id="f4180-645">无</span><span class="sxs-lookup"><span data-stu-id="f4180-645">None</span></span>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsStylusOverProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsStylusOverProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsStylusOverProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.IsStylusOverProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IsStylusOverProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ IsStylusOverProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable IsStylusOverProperty : System.Windows.DependencyProperty" Usage="System.Windows.ContentElement.IsStylusOverProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f4180-646">标识 <see cref="P:System.Windows.ContentElement.IsStylusOver" /> 依赖项属性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-646">Identifies the <see cref="P:System.Windows.ContentElement.IsStylusOver" /> dependency property.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="KeyDown">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.KeyEventHandler KeyDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.KeyEventHandler KeyDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.KeyDown" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event KeyDown As KeyEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::KeyEventHandler ^ KeyDown;" />
      <MemberSignature Language="F#" Value="member this.KeyDown : System.Windows.Input.KeyEventHandler " Usage="member this.KeyDown : System.Windows.Input.KeyEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.KeyDown</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.KeyEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f4180-647">当焦点在该元素上时按下某个键后发生。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-647">Occurs when a key is pressed while focus is on this element.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4180-648">密钥处理与其他平台功能，例如命令和文本组合进行交互。</span><span class="sxs-lookup"><span data-stu-id="f4180-648">Key handling interacts with other platform features such as commanding and text composition.</span></span> <span data-ttu-id="f4180-649"><xref:System.Windows.ContentElement.KeyDown>事件是一个较低级别的文本输入的事件，可能不会像预期某些控件上。</span><span class="sxs-lookup"><span data-stu-id="f4180-649">The <xref:System.Windows.ContentElement.KeyDown> event is a lower-level text input event that might not behave as expected on certain controls.</span></span> <span data-ttu-id="f4180-650">这是文本的因为某些控件具有控件组合或提供更高级版本的类处理输入处理和相关的事件。</span><span class="sxs-lookup"><span data-stu-id="f4180-650">This is because some controls have control compositing or class handling that provides a higher-level version of text input handling and related events.</span></span>  
  
 <span data-ttu-id="f4180-651">此事件创建一个别名<xref:System.Windows.Input.Keyboard.KeyDown?displayProperty=nameWithType>附加的此类事件，以便<xref:System.Windows.ContentElement.KeyDown>属于类的成员列出时<xref:System.Windows.ContentElement>作为基元素继承。</span><span class="sxs-lookup"><span data-stu-id="f4180-651">This event creates an alias for the <xref:System.Windows.Input.Keyboard.KeyDown?displayProperty=nameWithType> attached event for this class so that <xref:System.Windows.ContentElement.KeyDown> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="f4180-652">事件处理程序附加到<xref:System.Windows.ContentElement.KeyDown>事件附加到基础<xref:System.Windows.Input.Keyboard.KeyDown?displayProperty=nameWithType>附加事件，并接收相同的事件数据实例。</span><span class="sxs-lookup"><span data-stu-id="f4180-652">Event handlers that are attached to the <xref:System.Windows.ContentElement.KeyDown> event are attached to the underlying <xref:System.Windows.Input.Keyboard.KeyDown?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
<a name="routedEventInfo_KeyDown"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="f4180-653">路由事件信息</span><span class="sxs-lookup"><span data-stu-id="f4180-653">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="f4180-654">标识符字段</span><span class="sxs-lookup"><span data-stu-id="f4180-654">Identifier field</span></span>|<xref:System.Windows.ContentElement.KeyDownEvent>|  
|<span data-ttu-id="f4180-655">路由策略</span><span class="sxs-lookup"><span data-stu-id="f4180-655">Routing strategy</span></span>|<span data-ttu-id="f4180-656">浮升</span><span class="sxs-lookup"><span data-stu-id="f4180-656">Bubbling</span></span>|  
|<span data-ttu-id="f4180-657">委托</span><span class="sxs-lookup"><span data-stu-id="f4180-657">Delegate</span></span>|<xref:System.Windows.Input.KeyEventHandler>|  
  
-   <span data-ttu-id="f4180-658">相应的隧道事件是<xref:System.Windows.ContentElement.PreviewKeyDown>。</span><span class="sxs-lookup"><span data-stu-id="f4180-658">The corresponding tunneling event is <xref:System.Windows.ContentElement.PreviewKeyDown>.</span></span>  
  
-   <span data-ttu-id="f4180-659">重写<xref:System.Windows.ContentElement.OnKeyDown%2A>实现类处理此事件在派生类中。</span><span class="sxs-lookup"><span data-stu-id="f4180-659">Override <xref:System.Windows.ContentElement.OnKeyDown%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.KeyUp" />
      </Docs>
    </Member>
    <Member MemberName="KeyDownEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent KeyDownEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent KeyDownEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.KeyDownEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly KeyDownEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ KeyDownEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable KeyDownEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.KeyDownEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f4180-660">标识 <see cref="E:System.Windows.ContentElement.KeyDown" /> 路由事件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-660">Identifies the <see cref="E:System.Windows.ContentElement.KeyDown" /> routed event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4180-661">在注册路由事件时创建路由事件标识符。</span><span class="sxs-lookup"><span data-stu-id="f4180-661">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="f4180-662">这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。</span><span class="sxs-lookup"><span data-stu-id="f4180-662">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="f4180-663">可以使用这些标识符添加类处理程序。</span><span class="sxs-lookup"><span data-stu-id="f4180-663">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="f4180-664">有关注册路由事件的更多信息，请参见 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="f4180-664">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="f4180-665">有关使用路由事件标识符添加类处理程序的更多信息，请参见 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="f4180-665">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="KeyUp">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.KeyEventHandler KeyUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.KeyEventHandler KeyUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.KeyUp" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event KeyUp As KeyEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::KeyEventHandler ^ KeyUp;" />
      <MemberSignature Language="F#" Value="member this.KeyUp : System.Windows.Input.KeyEventHandler " Usage="member this.KeyUp : System.Windows.Input.KeyEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.KeyUp</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.KeyEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f4180-666">当焦点在该元素上时松开某个键后发生。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-666">Occurs when a key is released while focus is on this element.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4180-667">此事件创建一个别名<xref:System.Windows.Input.Keyboard.KeyUp?displayProperty=nameWithType>附加的此类事件，以便<xref:System.Windows.ContentElement.KeyUp>属于类的成员列出时<xref:System.Windows.ContentElement>作为基元素继承。</span><span class="sxs-lookup"><span data-stu-id="f4180-667">This event creates an alias for the <xref:System.Windows.Input.Keyboard.KeyUp?displayProperty=nameWithType> attached event for this class so that  <xref:System.Windows.ContentElement.KeyUp> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="f4180-668">事件处理程序附加到<xref:System.Windows.ContentElement.KeyUp>事件附加到基础<xref:System.Windows.Input.Keyboard.KeyUp?displayProperty=nameWithType>附加事件，并接收相同的事件数据实例。</span><span class="sxs-lookup"><span data-stu-id="f4180-668">Event handlers that are attached to the <xref:System.Windows.ContentElement.KeyUp> event are attached to the underlying <xref:System.Windows.Input.Keyboard.KeyUp?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
<a name="routedEventInfo_KeyUp"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="f4180-669">路由事件信息</span><span class="sxs-lookup"><span data-stu-id="f4180-669">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="f4180-670">标识符字段</span><span class="sxs-lookup"><span data-stu-id="f4180-670">Identifier field</span></span>|<xref:System.Windows.ContentElement.KeyUpEvent>|  
|<span data-ttu-id="f4180-671">路由策略</span><span class="sxs-lookup"><span data-stu-id="f4180-671">Routing strategy</span></span>|<span data-ttu-id="f4180-672">浮升</span><span class="sxs-lookup"><span data-stu-id="f4180-672">Bubbling</span></span>|  
|<span data-ttu-id="f4180-673">委托</span><span class="sxs-lookup"><span data-stu-id="f4180-673">Delegate</span></span>|<xref:System.Windows.Input.KeyEventHandler>|  
  
-   <span data-ttu-id="f4180-674">相应的隧道事件是<xref:System.Windows.ContentElement.PreviewKeyUp>。</span><span class="sxs-lookup"><span data-stu-id="f4180-674">The corresponding tunneling event is <xref:System.Windows.ContentElement.PreviewKeyUp>.</span></span>  
  
-   <span data-ttu-id="f4180-675">重写<xref:System.Windows.ContentElement.OnKeyUp%2A>实现类处理此事件在派生类中。</span><span class="sxs-lookup"><span data-stu-id="f4180-675">Override <xref:System.Windows.ContentElement.OnKeyUp%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.KeyDown" />
      </Docs>
    </Member>
    <Member MemberName="KeyUpEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent KeyUpEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent KeyUpEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.KeyUpEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly KeyUpEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ KeyUpEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable KeyUpEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.KeyUpEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f4180-676">标识 <see cref="E:System.Windows.ContentElement.KeyUp" /> 路由事件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-676">Identifies the <see cref="E:System.Windows.ContentElement.KeyUp" /> routed event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4180-677">在注册路由事件时创建路由事件标识符。</span><span class="sxs-lookup"><span data-stu-id="f4180-677">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="f4180-678">这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。</span><span class="sxs-lookup"><span data-stu-id="f4180-678">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="f4180-679">可以使用这些标识符添加类处理程序。</span><span class="sxs-lookup"><span data-stu-id="f4180-679">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="f4180-680">有关注册路由事件的更多信息，请参见 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="f4180-680">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="f4180-681">有关使用路由事件标识符添加类处理程序的更多信息，请参见 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="f4180-681">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LostFocus">
      <MemberSignature Language="C#" Value="public event System.Windows.RoutedEventHandler LostFocus;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.RoutedEventHandler LostFocus" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.LostFocus" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event LostFocus As RoutedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::RoutedEventHandler ^ LostFocus;" />
      <MemberSignature Language="F#" Value="member this.LostFocus : System.Windows.RoutedEventHandler " Usage="member this.LostFocus : System.Windows.RoutedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f4180-682">在此元素丢失逻辑焦点时发生。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-682">Occurs when this element loses logical focus.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4180-683">如果有意通过某个方法调用强制失去了焦点，而前一个键盘焦点位于不同的范围内，则逻辑焦点将与键盘焦点不同。</span><span class="sxs-lookup"><span data-stu-id="f4180-683">Logical focus differs from keyboard focus if focus is deliberately forced away by using a method call but the previous keyboard focus exists in a different scope.</span></span> <span data-ttu-id="f4180-684">在此方案，其中是键盘焦点将保留和元素其中<xref:System.Windows.ContentElement.Focus%2A>方法称为仍获得逻辑焦点。</span><span class="sxs-lookup"><span data-stu-id="f4180-684">In this scenario, keyboard focus remains where it is, and the element where a <xref:System.Windows.ContentElement.Focus%2A> method is called still gets logical focus.</span></span>  
  
 <span data-ttu-id="f4180-685">此事件的更精确地解释是它时引发的值<xref:System.Windows.ContentElement.IsFocused%2A>路由中的元素的属性从更改`true`到`false`。</span><span class="sxs-lookup"><span data-stu-id="f4180-685">A more precise interpretation of this event is that it is raised when the value of the <xref:System.Windows.ContentElement.IsFocused%2A> property of an element in the route changes from `true` to `false`.</span></span>  
  
 <span data-ttu-id="f4180-686">由于此事件使用冒泡路由，因此失去焦点的元素可能是而不是元素的子元素实际附加事件处理程序。</span><span class="sxs-lookup"><span data-stu-id="f4180-686">Because this event uses bubbling routing, the element that loses focus might be a child element instead of the element where the event handler is actually attached.</span></span> <span data-ttu-id="f4180-687">检查<xref:System.Windows.RoutedEventArgs.Source%2A>事件数据以确定实际获得焦点的元素中。</span><span class="sxs-lookup"><span data-stu-id="f4180-687">Check the <xref:System.Windows.RoutedEventArgs.Source%2A> in the event data to determine the actual element that gained focus.</span></span>  
  
<a name="routedEventInfo_LostFocus"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="f4180-688">路由事件信息</span><span class="sxs-lookup"><span data-stu-id="f4180-688">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="f4180-689">标识符字段</span><span class="sxs-lookup"><span data-stu-id="f4180-689">Identifier field</span></span>|<xref:System.Windows.ContentElement.LostFocusEvent>|  
|<span data-ttu-id="f4180-690">路由策略</span><span class="sxs-lookup"><span data-stu-id="f4180-690">Routing strategy</span></span>|<span data-ttu-id="f4180-691">浮升</span><span class="sxs-lookup"><span data-stu-id="f4180-691">Bubbling</span></span>|  
|<span data-ttu-id="f4180-692">委托</span><span class="sxs-lookup"><span data-stu-id="f4180-692">Delegate</span></span>|<xref:System.Windows.RoutedEventHandler>|  
  
-   <span data-ttu-id="f4180-693">没有相应的隧道事件。</span><span class="sxs-lookup"><span data-stu-id="f4180-693">There is no corresponding tunneling event.</span></span>  
  
-   <span data-ttu-id="f4180-694">重写<xref:System.Windows.ContentElement.OnLostFocus%2A>实现类处理此事件在派生类中。</span><span class="sxs-lookup"><span data-stu-id="f4180-694">Override <xref:System.Windows.ContentElement.OnLostFocus%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.LostKeyboardFocus" />
        <altmember cref="M:System.Windows.ContentElement.Focus" />
      </Docs>
    </Member>
    <Member MemberName="LostFocusEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent LostFocusEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent LostFocusEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.LostFocusEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly LostFocusEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ LostFocusEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable LostFocusEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.LostFocusEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f4180-695">标识 <see cref="E:System.Windows.ContentElement.LostFocus" /> 路由事件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-695">Identifies the <see cref="E:System.Windows.ContentElement.LostFocus" /> routed event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4180-696">在注册路由事件时创建路由事件标识符。</span><span class="sxs-lookup"><span data-stu-id="f4180-696">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="f4180-697">这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。</span><span class="sxs-lookup"><span data-stu-id="f4180-697">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="f4180-698">可以使用这些标识符添加类处理程序。</span><span class="sxs-lookup"><span data-stu-id="f4180-698">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="f4180-699">有关注册路由事件的更多信息，请参见 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="f4180-699">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="f4180-700">有关使用路由事件标识符添加类处理程序的更多信息，请参见 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="f4180-700">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LostKeyboardFocus">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.KeyboardFocusChangedEventHandler LostKeyboardFocus;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.KeyboardFocusChangedEventHandler LostKeyboardFocus" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.LostKeyboardFocus" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event LostKeyboardFocus As KeyboardFocusChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::KeyboardFocusChangedEventHandler ^ LostKeyboardFocus;" />
      <MemberSignature Language="F#" Value="member this.LostKeyboardFocus : System.Windows.Input.KeyboardFocusChangedEventHandler " Usage="member this.LostKeyboardFocus : System.Windows.Input.KeyboardFocusChangedEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.LostKeyboardFocus</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.KeyboardFocusChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f4180-701">在此元素不再聚焦于键盘时发生。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-701">Occurs when the keyboard is no longer focused on this element.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4180-702">由于此事件使用冒泡路由，因此失去焦点的元素可能是而不是元素的子元素实际附加事件处理程序。</span><span class="sxs-lookup"><span data-stu-id="f4180-702">Because this event uses bubbling routing, the element that lost focus might be a child element instead of the element where the event handler is actually attached.</span></span> <span data-ttu-id="f4180-703">检查<xref:System.Windows.RoutedEventArgs.Source%2A>事件数据来确定实际失去焦点的元素中。</span><span class="sxs-lookup"><span data-stu-id="f4180-703">Check the <xref:System.Windows.RoutedEventArgs.Source%2A> in the event data to determine the actual element that lost focus.</span></span>  
  
 <span data-ttu-id="f4180-704">此事件创建一个别名<xref:System.Windows.Input.Keyboard.LostKeyboardFocus?displayProperty=nameWithType>附加事件对于此类，以便<xref:System.Windows.ContentElement.LostKeyboardFocus>属于类的成员列出时<xref:System.Windows.ContentElement>作为基元素继承。</span><span class="sxs-lookup"><span data-stu-id="f4180-704">This event creates an alias for the <xref:System.Windows.Input.Keyboard.LostKeyboardFocus?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.LostKeyboardFocus> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="f4180-705">事件处理程序附加到<xref:System.Windows.ContentElement.LostKeyboardFocus>事件附加到基础<xref:System.Windows.Input.Keyboard.LostKeyboardFocus?displayProperty=nameWithType>附加事件，并接收相同的事件数据实例。</span><span class="sxs-lookup"><span data-stu-id="f4180-705">Event handlers that are attached to the <xref:System.Windows.ContentElement.LostKeyboardFocus> event are attached to the underlying <xref:System.Windows.Input.Keyboard.LostKeyboardFocus?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
<a name="routedEventInfo_LostKeyboardFocus"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="f4180-706">路由事件信息</span><span class="sxs-lookup"><span data-stu-id="f4180-706">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="f4180-707">标识符字段</span><span class="sxs-lookup"><span data-stu-id="f4180-707">Identifier field</span></span>|<xref:System.Windows.ContentElement.LostKeyboardFocusEvent>|  
|<span data-ttu-id="f4180-708">路由策略</span><span class="sxs-lookup"><span data-stu-id="f4180-708">Routing strategy</span></span>|<span data-ttu-id="f4180-709">浮升</span><span class="sxs-lookup"><span data-stu-id="f4180-709">Bubbling</span></span>|  
|<span data-ttu-id="f4180-710">委托</span><span class="sxs-lookup"><span data-stu-id="f4180-710">Delegate</span></span>|<xref:System.Windows.Input.KeyboardFocusChangedEventHandler>|  
  
-   <span data-ttu-id="f4180-711">相应的隧道事件是<xref:System.Windows.ContentElement.PreviewLostKeyboardFocus>。</span><span class="sxs-lookup"><span data-stu-id="f4180-711">The corresponding tunneling event is <xref:System.Windows.ContentElement.PreviewLostKeyboardFocus>.</span></span>  
  
-   <span data-ttu-id="f4180-712">重写<xref:System.Windows.ContentElement.OnLostKeyboardFocus%2A>实现类处理此事件在派生类中。</span><span class="sxs-lookup"><span data-stu-id="f4180-712">Override <xref:System.Windows.ContentElement.OnLostKeyboardFocus%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LostKeyboardFocusEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent LostKeyboardFocusEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent LostKeyboardFocusEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.LostKeyboardFocusEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly LostKeyboardFocusEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ LostKeyboardFocusEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable LostKeyboardFocusEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.LostKeyboardFocusEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f4180-713">标识 <see cref="E:System.Windows.ContentElement.LostKeyboardFocus" /> 路由事件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-713">Identifies the <see cref="E:System.Windows.ContentElement.LostKeyboardFocus" /> routed event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4180-714">在注册路由事件时创建路由事件标识符。</span><span class="sxs-lookup"><span data-stu-id="f4180-714">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="f4180-715">这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。</span><span class="sxs-lookup"><span data-stu-id="f4180-715">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="f4180-716">可以使用这些标识符添加类处理程序。</span><span class="sxs-lookup"><span data-stu-id="f4180-716">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="f4180-717">有关注册路由事件的更多信息，请参见 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="f4180-717">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="f4180-718">有关使用路由事件标识符添加类处理程序的更多信息，请参见 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="f4180-718">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LostMouseCapture">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseEventHandler LostMouseCapture;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseEventHandler LostMouseCapture" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.LostMouseCapture" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event LostMouseCapture As MouseEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::MouseEventHandler ^ LostMouseCapture;" />
      <MemberSignature Language="F#" Value="member this.LostMouseCapture : System.Windows.Input.MouseEventHandler " Usage="member this.LostMouseCapture : System.Windows.Input.MouseEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.LostMouseCapture</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f4180-719">在此元素丢失鼠标捕获时发生。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-719">Occurs when this element loses mouse capture.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4180-720">在元素捕获鼠标，它会接收鼠标输入，即使在指针位于其边界外。</span><span class="sxs-lookup"><span data-stu-id="f4180-720">When an element captures the mouse, it receives mouse input even if the pointer is outside its bounds.</span></span> <span data-ttu-id="f4180-721">只有在拖放操作通常捕获鼠标。</span><span class="sxs-lookup"><span data-stu-id="f4180-721">The mouse is typically captured only during drag-and-drop operations.</span></span>  
  
 <span data-ttu-id="f4180-722">此事件使用冒泡路由，因为丢失捕获的元素可能是而不是元素的子元素实际附加事件处理程序。</span><span class="sxs-lookup"><span data-stu-id="f4180-722">Because this event uses bubbling routing, the element that loses capture might be a child element instead of the element where the event handler is actually attached.</span></span> <span data-ttu-id="f4180-723">检查<xref:System.Windows.RoutedEventArgs.Source%2A>事件数据来确定实际失去捕获的元素中。</span><span class="sxs-lookup"><span data-stu-id="f4180-723">Check the <xref:System.Windows.RoutedEventArgs.Source%2A> in the event data to determine the actual element that lost capture.</span></span>  
  
 <span data-ttu-id="f4180-724">此事件创建一个别名<xref:System.Windows.Input.Mouse.LostMouseCapture?displayProperty=nameWithType>附加事件对于此类，以便<xref:System.Windows.ContentElement.LostMouseCapture>属于类的成员列出时<xref:System.Windows.ContentElement>作为基元素继承。</span><span class="sxs-lookup"><span data-stu-id="f4180-724">This event creates an alias for the <xref:System.Windows.Input.Mouse.LostMouseCapture?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.LostMouseCapture> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="f4180-725">事件处理程序附加到<xref:System.Windows.ContentElement.LostMouseCapture>事件附加到基础<xref:System.Windows.Input.Mouse.LostMouseCapture?displayProperty=nameWithType>附加事件，并接收相同的事件数据实例。</span><span class="sxs-lookup"><span data-stu-id="f4180-725">Event handlers that are attached to the <xref:System.Windows.ContentElement.LostMouseCapture> event are attached to the underlying <xref:System.Windows.Input.Mouse.LostMouseCapture?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
<a name="routedEventInfo_LostMouseCapture"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="f4180-726">路由事件信息</span><span class="sxs-lookup"><span data-stu-id="f4180-726">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="f4180-727">标识符字段</span><span class="sxs-lookup"><span data-stu-id="f4180-727">Identifier field</span></span>|<xref:System.Windows.ContentElement.LostMouseCaptureEvent>|  
|<span data-ttu-id="f4180-728">路由策略</span><span class="sxs-lookup"><span data-stu-id="f4180-728">Routing strategy</span></span>|<span data-ttu-id="f4180-729">浮升</span><span class="sxs-lookup"><span data-stu-id="f4180-729">Bubbling</span></span>|  
|<span data-ttu-id="f4180-730">委托</span><span class="sxs-lookup"><span data-stu-id="f4180-730">Delegate</span></span>|<xref:System.Windows.Input.MouseEventHandler>|  
  
-   <span data-ttu-id="f4180-731">没有定义相应的隧道事件。</span><span class="sxs-lookup"><span data-stu-id="f4180-731">There is no defined corresponding tunneling event.</span></span>  
  
-   <span data-ttu-id="f4180-732">重写<xref:System.Windows.ContentElement.OnLostMouseCapture%2A>实现类处理此事件在派生类中。</span><span class="sxs-lookup"><span data-stu-id="f4180-732">Override <xref:System.Windows.ContentElement.OnLostMouseCapture%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LostMouseCaptureEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent LostMouseCaptureEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent LostMouseCaptureEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.LostMouseCaptureEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly LostMouseCaptureEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ LostMouseCaptureEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable LostMouseCaptureEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.LostMouseCaptureEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f4180-733">标识 <see cref="E:System.Windows.ContentElement.LostMouseCapture" /> 路由事件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-733">Identifies the <see cref="E:System.Windows.ContentElement.LostMouseCapture" /> routed event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4180-734">在注册路由事件时创建路由事件标识符。</span><span class="sxs-lookup"><span data-stu-id="f4180-734">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="f4180-735">这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。</span><span class="sxs-lookup"><span data-stu-id="f4180-735">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="f4180-736">可以使用这些标识符添加类处理程序。</span><span class="sxs-lookup"><span data-stu-id="f4180-736">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="f4180-737">有关注册路由事件的更多信息，请参见 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="f4180-737">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="f4180-738">有关使用路由事件标识符添加类处理程序的更多信息，请参见 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="f4180-738">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LostStylusCapture">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusEventHandler LostStylusCapture;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusEventHandler LostStylusCapture" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.LostStylusCapture" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event LostStylusCapture As StylusEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusEventHandler ^ LostStylusCapture;" />
      <MemberSignature Language="F#" Value="member this.LostStylusCapture : System.Windows.Input.StylusEventHandler " Usage="member this.LostStylusCapture : System.Windows.Input.StylusEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.LostStylusCapture</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f4180-739">在此元素丢失触笔捕获时发生。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-739">Occurs when this element loses stylus capture.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4180-740">在元素捕获触笔，它会接收触笔输入，即使在指针位于其边界外。</span><span class="sxs-lookup"><span data-stu-id="f4180-740">When an element captures the stylus, it receives stylus input even if the pointer is outside its bounds.</span></span> <span data-ttu-id="f4180-741">只有在拖放操作通常捕获触笔。</span><span class="sxs-lookup"><span data-stu-id="f4180-741">The stylus is typically captured only during drag-and-drop operations.</span></span>  
  
 <span data-ttu-id="f4180-742">由于此事件使用冒泡路由，因此失去焦点的元素可能是而不是元素的子元素实际附加事件处理程序。</span><span class="sxs-lookup"><span data-stu-id="f4180-742">Because this event uses bubbling routing, the element that loses focus might be a child element instead of the element where the event handler is actually attached.</span></span> <span data-ttu-id="f4180-743">检查<xref:System.Windows.RoutedEventArgs.Source%2A>事件数据来确定实际失去焦点的元素中。</span><span class="sxs-lookup"><span data-stu-id="f4180-743">Check the <xref:System.Windows.RoutedEventArgs.Source%2A> in the event data to determine the actual element that lost focus.</span></span>  
  
 <span data-ttu-id="f4180-744">此事件创建一个别名<xref:System.Windows.Input.Stylus.LostStylusCapture?displayProperty=nameWithType>附加事件对于此类，以便<xref:System.Windows.ContentElement.LostStylusCapture>属于类的成员列出时<xref:System.Windows.ContentElement>作为基元素继承。</span><span class="sxs-lookup"><span data-stu-id="f4180-744">This event creates an alias for the <xref:System.Windows.Input.Stylus.LostStylusCapture?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.LostStylusCapture> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="f4180-745">事件处理程序附加到<xref:System.Windows.ContentElement.LostStylusCapture>事件附加到基础<xref:System.Windows.Input.Stylus.LostStylusCapture?displayProperty=nameWithType>附加事件，并接收相同的事件数据实例。</span><span class="sxs-lookup"><span data-stu-id="f4180-745">Event handlers that are attached to the <xref:System.Windows.ContentElement.LostStylusCapture> event are attached to the underlying <xref:System.Windows.Input.Stylus.LostStylusCapture?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
<a name="routedEventInfo_LostStylusCapture"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="f4180-746">路由事件信息</span><span class="sxs-lookup"><span data-stu-id="f4180-746">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="f4180-747">标识符字段</span><span class="sxs-lookup"><span data-stu-id="f4180-747">Identifier field</span></span>|<xref:System.Windows.ContentElement.LostStylusCaptureEvent>|  
|<span data-ttu-id="f4180-748">路由策略</span><span class="sxs-lookup"><span data-stu-id="f4180-748">Routing strategy</span></span>|<span data-ttu-id="f4180-749">浮升</span><span class="sxs-lookup"><span data-stu-id="f4180-749">Bubbling</span></span>|  
|<span data-ttu-id="f4180-750">委托</span><span class="sxs-lookup"><span data-stu-id="f4180-750">Delegate</span></span>|<xref:System.Windows.Input.StylusEventHandler>|  
  
-   <span data-ttu-id="f4180-751">没有定义相应的隧道事件。</span><span class="sxs-lookup"><span data-stu-id="f4180-751">There is no defined corresponding tunneling event.</span></span>  
  
-   <span data-ttu-id="f4180-752">重写<xref:System.Windows.ContentElement.OnLostStylusCapture%2A>实现类处理此事件在派生类中。</span><span class="sxs-lookup"><span data-stu-id="f4180-752">Override <xref:System.Windows.ContentElement.OnLostStylusCapture%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LostStylusCaptureEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent LostStylusCaptureEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent LostStylusCaptureEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.LostStylusCaptureEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly LostStylusCaptureEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ LostStylusCaptureEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable LostStylusCaptureEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.LostStylusCaptureEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f4180-753">标识 <see cref="E:System.Windows.ContentElement.LostStylusCapture" /> 路由事件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-753">Identifies the <see cref="E:System.Windows.ContentElement.LostStylusCapture" /> routed event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4180-754">在注册路由事件时创建路由事件标识符。</span><span class="sxs-lookup"><span data-stu-id="f4180-754">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="f4180-755">这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。</span><span class="sxs-lookup"><span data-stu-id="f4180-755">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="f4180-756">可以使用这些标识符添加类处理程序。</span><span class="sxs-lookup"><span data-stu-id="f4180-756">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="f4180-757">有关注册路由事件的更多信息，请参见 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="f4180-757">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="f4180-758">有关使用路由事件标识符添加类处理程序的更多信息，请参见 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="f4180-758">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LostTouchCapture">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; LostTouchCapture;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Input.TouchEventArgs&gt; LostTouchCapture" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.LostTouchCapture" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event LostTouchCapture As EventHandler(Of TouchEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Windows::Input::TouchEventArgs ^&gt; ^ LostTouchCapture;" />
      <MemberSignature Language="F#" Value="member this.LostTouchCapture : EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; " Usage="member this.LostTouchCapture : System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f4180-759">在此元素失去触摸屏输入捕获时发生。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-759">Occurs when this element loses a touch capture.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="routedEventInfo_LostTouchCapture"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="f4180-760">路由事件信息</span><span class="sxs-lookup"><span data-stu-id="f4180-760">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="f4180-761">标识符字段</span><span class="sxs-lookup"><span data-stu-id="f4180-761">Identifier field</span></span>|<xref:System.Windows.ContentElement.LostTouchCaptureEvent>|  
|<span data-ttu-id="f4180-762">路由策略</span><span class="sxs-lookup"><span data-stu-id="f4180-762">Routing strategy</span></span>|<span data-ttu-id="f4180-763">浮升</span><span class="sxs-lookup"><span data-stu-id="f4180-763">Bubbling</span></span>|  
|<span data-ttu-id="f4180-764">委托</span><span class="sxs-lookup"><span data-stu-id="f4180-764">Delegate</span></span>|<span data-ttu-id="f4180-765"><xref:System.EventHandler%601>类型<xref:System.Windows.Input.TouchEventArgs>。</span><span class="sxs-lookup"><span data-stu-id="f4180-765"><xref:System.EventHandler%601> of type <xref:System.Windows.Input.TouchEventArgs>.</span></span>|  
  
-   <span data-ttu-id="f4180-766">重写<xref:System.Windows.ContentElement.OnLostTouchCapture%2A>实现类处理此事件在派生类中。</span><span class="sxs-lookup"><span data-stu-id="f4180-766">Override <xref:System.Windows.ContentElement.OnLostTouchCapture%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LostTouchCaptureEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent LostTouchCaptureEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent LostTouchCaptureEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.LostTouchCaptureEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly LostTouchCaptureEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ LostTouchCaptureEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable LostTouchCaptureEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.LostTouchCaptureEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f4180-767">标识 <see cref="E:System.Windows.ContentElement.LostTouchCapture" /> 路由事件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-767">Identifies the <see cref="E:System.Windows.ContentElement.LostTouchCapture" /> routed event.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseDown">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseButtonEventHandler MouseDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseButtonEventHandler MouseDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.MouseDown" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseDown As MouseButtonEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Input::MouseButtonEventHandler ^ MouseDown;" />
      <MemberSignature Language="F#" Value="member this.MouseDown : System.Windows.Input.MouseButtonEventHandler " Usage="member this.MouseDown : System.Windows.Input.MouseButtonEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f4180-768">在指针位于此元素上并且按下任意鼠标按钮时发生。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-768">Occurs when any mouse button is pressed while the pointer is over this element.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4180-769">此事件创建一个别名<xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType>附加事件对于此类，以便<xref:System.Windows.ContentElement.MouseDown>属于类的成员列出时<xref:System.Windows.ContentElement>作为基元素继承。</span><span class="sxs-lookup"><span data-stu-id="f4180-769">This event creates an alias for the <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.MouseDown> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="f4180-770">事件处理程序附加到<xref:System.Windows.ContentElement.MouseDown>事件附加到基础<xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType>附加事件，并接收相同的事件数据实例。</span><span class="sxs-lookup"><span data-stu-id="f4180-770">Event handlers that are attached to the <xref:System.Windows.ContentElement.MouseDown> event are attached to the underlying <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
 <span data-ttu-id="f4180-771"><xref:System.Windows.ContentElement.MouseDown>任意一个协同通常引发事件<xref:System.Windows.ContentElement.MouseLeftButtonDown>或<xref:System.Windows.ContentElement.MouseRightButtonDown>，对应于一个两个标准鼠标按钮按下。</span><span class="sxs-lookup"><span data-stu-id="f4180-771">The <xref:System.Windows.ContentElement.MouseDown> event is often raised together with either <xref:System.Windows.ContentElement.MouseLeftButtonDown> or <xref:System.Windows.ContentElement.MouseRightButtonDown>, which correspond to a press of one of the two standard mouse buttons.</span></span> <span data-ttu-id="f4180-772"><xref:System.Windows.ContentElement.MouseLeftButtonDown> 并<xref:System.Windows.ContentElement.MouseRightButtonDown>也是路由的事件，但它们是直接路由的事件，并引发相应的特定于按钮的事件时<xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType>事件到达事件路由中的此元素。</span><span class="sxs-lookup"><span data-stu-id="f4180-772"><xref:System.Windows.ContentElement.MouseLeftButtonDown> and <xref:System.Windows.ContentElement.MouseRightButtonDown> are also routed events, but they are direct routed events, and the appropriate button-specific event is raised when the <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType> event reaches this element along the event route.</span></span> <span data-ttu-id="f4180-773">请参阅备注<xref:System.Windows.ContentElement.MouseLeftButtonDown>或<xref:System.Windows.ContentElement.MouseRightButtonDown>。</span><span class="sxs-lookup"><span data-stu-id="f4180-773">See Remarks for <xref:System.Windows.ContentElement.MouseLeftButtonDown> or <xref:System.Windows.ContentElement.MouseRightButtonDown>.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="f4180-774">少量<xref:System.Windows.ContentElement>派生的类具有类似控件的行为，例如， <xref:System.Windows.Documents.Hyperlink>，可能会具有固有的鼠标按钮事件处理的类。</span><span class="sxs-lookup"><span data-stu-id="f4180-774">A few <xref:System.Windows.ContentElement> derived classes that have control-like behavior, for example, <xref:System.Windows.Documents.Hyperlink>, might have inherent class handling for mouse button events.</span></span> <span data-ttu-id="f4180-775">鼠标左键按下事件是最有可能的事件，以便使类处理在控件中。</span><span class="sxs-lookup"><span data-stu-id="f4180-775">The left mouse button down event is the most likely event to have class handling in a control.</span></span> <span data-ttu-id="f4180-776">类通常处理标记基础<xref:System.Windows.Input.Mouse>为已处理的类事件。</span><span class="sxs-lookup"><span data-stu-id="f4180-776">The class handling often marks the underlying <xref:System.Windows.Input.Mouse> class event as handled.</span></span> <span data-ttu-id="f4180-777">一旦该事件标记为已处理，其他实例处理程序附加到该元素通常不会引发。</span><span class="sxs-lookup"><span data-stu-id="f4180-777">Once the event is marked handled, other instance handlers that are attached to that element are not ordinarily raised.</span></span> <span data-ttu-id="f4180-778">通常也不会引发的任何其他类或实例处理程序附加到针对 UI 树的根节点的浮升方向中的元素。</span><span class="sxs-lookup"><span data-stu-id="f4180-778">Any other class or instance handlers that are attached to elements in the bubbling direction towards the root in the UI tree are also not ordinarily raised.</span></span>  
  
 <span data-ttu-id="f4180-779">您可以解决的问题，在前面的重要说明中所述和仍接收<xref:System.Windows.ContentElement.MouseDown>鼠标左键按下具有类处理通过使用这些解决方案的派生类上的事件的事件：</span><span class="sxs-lookup"><span data-stu-id="f4180-779">You can resolve the issue that is outlined in the preceding Important and still receive <xref:System.Windows.ContentElement.MouseDown> events for left mouse button down events on a derived class that has class handling by using either of these solutions:</span></span>  
  
-   <span data-ttu-id="f4180-780">附加处理程序<xref:System.Windows.ContentElement.PreviewMouseDown>未标记为已由控件处理的事件。</span><span class="sxs-lookup"><span data-stu-id="f4180-780">Attach handlers for the <xref:System.Windows.ContentElement.PreviewMouseDown> event, which is not marked as handled by the controls.</span></span> <span data-ttu-id="f4180-781">请注意，由于这是预览事件，该路由从根开始，隧道下行控件。</span><span class="sxs-lookup"><span data-stu-id="f4180-781">Notice that because this is a preview event, the route starts at the root and tunnels down to the control.</span></span>  
  
-   <span data-ttu-id="f4180-782">虽然通过调用注册该控件上的处理程序<xref:System.Windows.ContentElement.AddHandler%2A>，然后选择使处理程序以侦听事件，即使它们已标记为已处理路由的事件数据中的签名选项。</span><span class="sxs-lookup"><span data-stu-id="f4180-782">Register a handler on the control procedurally by calling <xref:System.Windows.ContentElement.AddHandler%2A> and choosing the signature option that enables handlers to listen for events even if they are already marked as handled in the routed event data.</span></span>  
  
<a name="routedEventInfo_MouseDown"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="f4180-783">路由事件信息</span><span class="sxs-lookup"><span data-stu-id="f4180-783">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="f4180-784">标识符字段</span><span class="sxs-lookup"><span data-stu-id="f4180-784">Identifier field</span></span>|<xref:System.Windows.ContentElement.MouseDownEvent>|  
|<span data-ttu-id="f4180-785">路由策略</span><span class="sxs-lookup"><span data-stu-id="f4180-785">Routing strategy</span></span>|<span data-ttu-id="f4180-786">浮升</span><span class="sxs-lookup"><span data-stu-id="f4180-786">Bubbling</span></span>|  
|<span data-ttu-id="f4180-787">委托</span><span class="sxs-lookup"><span data-stu-id="f4180-787">Delegate</span></span>|<xref:System.Windows.Input.MouseButtonEventHandler>|  
  
-   <span data-ttu-id="f4180-788">相应的隧道事件是<xref:System.Windows.ContentElement.PreviewMouseDown>。</span><span class="sxs-lookup"><span data-stu-id="f4180-788">The corresponding tunneling event is <xref:System.Windows.ContentElement.PreviewMouseDown>.</span></span>  
  
-   <span data-ttu-id="f4180-789">重写<xref:System.Windows.ContentElement.OnMouseDown%2A>实现类处理此事件在派生类中。</span><span class="sxs-lookup"><span data-stu-id="f4180-789">Override <xref:System.Windows.ContentElement.OnMouseDown%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseDownEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent MouseDownEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent MouseDownEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.MouseDownEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MouseDownEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ MouseDownEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable MouseDownEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.MouseDownEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f4180-790">标识 <see cref="E:System.Windows.ContentElement.MouseDown" /> 路由事件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-790">Identifies the <see cref="E:System.Windows.ContentElement.MouseDown" /> routed event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4180-791">在注册路由事件时创建路由事件标识符。</span><span class="sxs-lookup"><span data-stu-id="f4180-791">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="f4180-792">这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。</span><span class="sxs-lookup"><span data-stu-id="f4180-792">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="f4180-793">可以使用这些标识符添加类处理程序。</span><span class="sxs-lookup"><span data-stu-id="f4180-793">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="f4180-794">有关注册路由事件的更多信息，请参见 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="f4180-794">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="f4180-795">有关使用路由事件标识符添加类处理程序的更多信息，请参见 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="f4180-795">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseEnter">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseEventHandler MouseEnter;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseEventHandler MouseEnter" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.MouseEnter" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseEnter As MouseEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::MouseEventHandler ^ MouseEnter;" />
      <MemberSignature Language="F#" Value="member this.MouseEnter : System.Windows.Input.MouseEventHandler " Usage="member this.MouseEnter : System.Windows.Input.MouseEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.MouseEnter</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f4180-796">在鼠标指针进入此元素的边界时发生。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-796">Occurs when the mouse pointer enters the bounds of this element.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4180-797"><xref:System.Windows.ContentElement.MouseEnter> 是[路由事件概述](~/docs/framework/wpf/advanced/routed-events-overview.md)，它使用直接事件处理路由策略。</span><span class="sxs-lookup"><span data-stu-id="f4180-797"><xref:System.Windows.ContentElement.MouseEnter> is a [Routed Events Overview](~/docs/framework/wpf/advanced/routed-events-overview.md) that uses the direct event handling routing strategy.</span></span> <span data-ttu-id="f4180-798">直接路由的事件不会引发在路由过程;相反，它们被处理的同一元素中引发位置。</span><span class="sxs-lookup"><span data-stu-id="f4180-798">Direct routed events are not raised along a route; instead, they are handled in the same element where they are raised.</span></span> <span data-ttu-id="f4180-799">但是，它们启用了路由的事件的行为，如在样式中的事件触发的其他方面。</span><span class="sxs-lookup"><span data-stu-id="f4180-799">However, they do enable other aspects of routed event behavior, such as event triggers in styles.</span></span>  
  
 <span data-ttu-id="f4180-800">尽管<xref:System.Windows.ContentElement.MouseEnter>跟踪当鼠标指针进入元素，此事件的多个边界确切地报告<xref:System.Windows.ContentElement.IsMouseOver%2A>属性值已从`false`到`true`此元素上。</span><span class="sxs-lookup"><span data-stu-id="f4180-800">Although <xref:System.Windows.ContentElement.MouseEnter> tracks when the mouse pointer enters the bounds of an element, this event more literally reports that the <xref:System.Windows.ContentElement.IsMouseOver%2A> property value has changed from `false` to `true` on this element.</span></span>  
  
 <span data-ttu-id="f4180-801">此事件创建一个别名<xref:System.Windows.Input.Mouse.MouseEnter?displayProperty=nameWithType>附加事件对于此类，以便<xref:System.Windows.ContentElement.MouseEnter>属于类的成员列出时<xref:System.Windows.ContentElement>作为基元素继承。</span><span class="sxs-lookup"><span data-stu-id="f4180-801">This event creates an alias for the <xref:System.Windows.Input.Mouse.MouseEnter?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.MouseEnter> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="f4180-802">事件处理程序附加到<xref:System.Windows.ContentElement.MouseEnter>事件附加到基础<xref:System.Windows.Input.Mouse.MouseEnter?displayProperty=nameWithType>附加事件，并接收相同的事件数据实例。</span><span class="sxs-lookup"><span data-stu-id="f4180-802">Event handlers that are attached to the <xref:System.Windows.ContentElement.MouseEnter> event are attached to the underlying <xref:System.Windows.Input.Mouse.MouseEnter?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
<a name="routedEventInfo_MouseEnter"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="f4180-803">路由事件信息</span><span class="sxs-lookup"><span data-stu-id="f4180-803">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="f4180-804">标识符字段</span><span class="sxs-lookup"><span data-stu-id="f4180-804">Identifier field</span></span>|<xref:System.Windows.ContentElement.MouseEnterEvent>|  
|<span data-ttu-id="f4180-805">路由策略</span><span class="sxs-lookup"><span data-stu-id="f4180-805">Routing strategy</span></span>|<span data-ttu-id="f4180-806">直接</span><span class="sxs-lookup"><span data-stu-id="f4180-806">Direct</span></span>|  
|<span data-ttu-id="f4180-807">委托</span><span class="sxs-lookup"><span data-stu-id="f4180-807">Delegate</span></span>|<xref:System.Windows.Input.MouseEventHandler>|  
  
-   <span data-ttu-id="f4180-808">重写<xref:System.Windows.ContentElement.OnMouseEnter%2A>实现类处理此事件在派生类中。</span><span class="sxs-lookup"><span data-stu-id="f4180-808">Override <xref:System.Windows.ContentElement.OnMouseEnter%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseEnterEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent MouseEnterEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent MouseEnterEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.MouseEnterEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MouseEnterEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ MouseEnterEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable MouseEnterEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.MouseEnterEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f4180-809">标识 <see cref="E:System.Windows.ContentElement.MouseEnter" /> 路由事件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-809">Identifies the <see cref="E:System.Windows.ContentElement.MouseEnter" /> routed event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4180-810">在注册路由事件时创建路由事件标识符。</span><span class="sxs-lookup"><span data-stu-id="f4180-810">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="f4180-811">这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。</span><span class="sxs-lookup"><span data-stu-id="f4180-811">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="f4180-812">可以使用这些标识符添加类处理程序。</span><span class="sxs-lookup"><span data-stu-id="f4180-812">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="f4180-813">有关注册路由事件的更多信息，请参见 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="f4180-813">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="f4180-814">有关使用路由事件标识符添加类处理程序的更多信息，请参见 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="f4180-814">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseLeave">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseEventHandler MouseLeave;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseEventHandler MouseLeave" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.MouseLeave" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseLeave As MouseEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::MouseEventHandler ^ MouseLeave;" />
      <MemberSignature Language="F#" Value="member this.MouseLeave : System.Windows.Input.MouseEventHandler " Usage="member this.MouseLeave : System.Windows.Input.MouseEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.MouseLeave</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f4180-815">在鼠标指针离开此元素的边界时发生。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-815">Occurs when the mouse pointer leaves the bounds of this element.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4180-816"><xref:System.Windows.ContentElement.MouseLeave> 是[路由事件概述](~/docs/framework/wpf/advanced/routed-events-overview.md)，它使用直接事件处理路由策略。</span><span class="sxs-lookup"><span data-stu-id="f4180-816"><xref:System.Windows.ContentElement.MouseLeave> is a [Routed Events Overview](~/docs/framework/wpf/advanced/routed-events-overview.md) that uses the direct event handling routing strategy.</span></span> <span data-ttu-id="f4180-817">直接路由的事件不会引发在路由过程;相反，它们被处理的同一元素中引发位置。</span><span class="sxs-lookup"><span data-stu-id="f4180-817">Direct routed events are not raised along a route; instead, they are handled in the same element where they are raised.</span></span> <span data-ttu-id="f4180-818">但是，它们启用了路由的事件的行为，如在样式中的事件触发的其他方面。</span><span class="sxs-lookup"><span data-stu-id="f4180-818">However, they do enable other aspects of routed event behavior, such as event triggers in styles.</span></span>  
  
 <span data-ttu-id="f4180-819">尽管<xref:System.Windows.ContentElement.MouseLeave>跟踪何时鼠标离开某个元素，此事件的详细信息按原义报告<xref:System.Windows.ContentElement.IsMouseOver%2A>属性值已从`true`到`false`此元素上。</span><span class="sxs-lookup"><span data-stu-id="f4180-819">Although <xref:System.Windows.ContentElement.MouseLeave> tracks when the mouse leaves an element, this event more literally reports that the <xref:System.Windows.ContentElement.IsMouseOver%2A> property value has changed from `true` to `false` on this element.</span></span>  
  
 <span data-ttu-id="f4180-820">此事件创建一个别名<xref:System.Windows.Input.Mouse.MouseLeave?displayProperty=nameWithType>附加事件对于此类，以便<xref:System.Windows.ContentElement.MouseLeave>属于类的成员列出时<xref:System.Windows.ContentElement>作为基元素继承。</span><span class="sxs-lookup"><span data-stu-id="f4180-820">This event creates an alias for the <xref:System.Windows.Input.Mouse.MouseLeave?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.MouseLeave> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="f4180-821">事件处理程序附加到<xref:System.Windows.ContentElement.MouseLeave>事件附加到基础<xref:System.Windows.Input.Mouse.MouseLeave?displayProperty=nameWithType>附加事件，并接收相同的事件数据实例。</span><span class="sxs-lookup"><span data-stu-id="f4180-821">Event handlers that are attached to the <xref:System.Windows.ContentElement.MouseLeave> event are attached to the underlying <xref:System.Windows.Input.Mouse.MouseLeave?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
<a name="routedEventInfo_MouseLeave"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="f4180-822">路由事件信息</span><span class="sxs-lookup"><span data-stu-id="f4180-822">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="f4180-823">标识符字段</span><span class="sxs-lookup"><span data-stu-id="f4180-823">Identifier field</span></span>|<xref:System.Windows.ContentElement.MouseLeaveEvent>|  
|<span data-ttu-id="f4180-824">路由策略</span><span class="sxs-lookup"><span data-stu-id="f4180-824">Routing strategy</span></span>|<span data-ttu-id="f4180-825">直接</span><span class="sxs-lookup"><span data-stu-id="f4180-825">Direct</span></span>|  
|<span data-ttu-id="f4180-826">委托</span><span class="sxs-lookup"><span data-stu-id="f4180-826">Delegate</span></span>|<xref:System.Windows.Input.MouseEventHandler>|  
  
-   <span data-ttu-id="f4180-827">重写<xref:System.Windows.ContentElement.OnMouseLeave%2A>实现类处理此事件在派生类中。</span><span class="sxs-lookup"><span data-stu-id="f4180-827">Override <xref:System.Windows.ContentElement.OnMouseLeave%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseLeaveEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent MouseLeaveEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent MouseLeaveEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.MouseLeaveEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MouseLeaveEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ MouseLeaveEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable MouseLeaveEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.MouseLeaveEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f4180-828">标识 <see cref="E:System.Windows.ContentElement.MouseLeave" /> 路由事件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-828">Identifies the <see cref="E:System.Windows.ContentElement.MouseLeave" /> routed event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4180-829">在注册路由事件时创建路由事件标识符。</span><span class="sxs-lookup"><span data-stu-id="f4180-829">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="f4180-830">这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。</span><span class="sxs-lookup"><span data-stu-id="f4180-830">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="f4180-831">可以使用这些标识符添加类处理程序。</span><span class="sxs-lookup"><span data-stu-id="f4180-831">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="f4180-832">有关注册路由事件的更多信息，请参见 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="f4180-832">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="f4180-833">有关使用路由事件标识符添加类处理程序的更多信息，请参见 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="f4180-833">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseLeftButtonDown">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseButtonEventHandler MouseLeftButtonDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseButtonEventHandler MouseLeftButtonDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.MouseLeftButtonDown" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseLeftButtonDown As MouseButtonEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::MouseButtonEventHandler ^ MouseLeftButtonDown;" />
      <MemberSignature Language="F#" Value="member this.MouseLeftButtonDown : System.Windows.Input.MouseButtonEventHandler " Usage="member this.MouseLeftButtonDown : System.Windows.Input.MouseButtonEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.MouseLeftButtonDown</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f4180-834">在鼠标指针位于此元素上并且按下鼠标左键时发生。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-834">Occurs when the left mouse button is pressed while the mouse pointer is over this element.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4180-835">尽管这[路由事件概述](~/docs/framework/wpf/advanced/routed-events-overview.md)似乎按照浮升路由通过元素树，它实际上是引发并由每个重新沿元素树的直接路由的事件<xref:System.Windows.ContentElement>。</span><span class="sxs-lookup"><span data-stu-id="f4180-835">Although this [Routed Events Overview](~/docs/framework/wpf/advanced/routed-events-overview.md) seems to follow a bubbling route through an element tree, it actually is a direct routed event that is raised and reraised along the element tree by each <xref:System.Windows.ContentElement>.</span></span>  
  
 <span data-ttu-id="f4180-836">此事件是一个报告基础的鼠标按钮具体情况的多个相关事件<xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType>事件，它是由在事件路由的每个元素处理附加的事件。</span><span class="sxs-lookup"><span data-stu-id="f4180-836">This event is one of several related events that report the mouse-button specifics of an underlying <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType> event, which is an attached event that is processed by each element along an event route.</span></span>  
  
 <span data-ttu-id="f4180-837">此事件的基础参数公开<xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType>事件。</span><span class="sxs-lookup"><span data-stu-id="f4180-837">The arguments of this event expose the arguments of the underlying <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType> event.</span></span> <span data-ttu-id="f4180-838">如果该事件被标记为已处理事件路由过程，则仍会引发鼠标按钮特定事件;但是，必须通过显式调用添加的鼠标按钮特定事件的处理程序<xref:System.Windows.ContentElement.AddHandler%2A>，使用选项来处理已标记为已处理的事件，以便将该事件的侦听器。</span><span class="sxs-lookup"><span data-stu-id="f4180-838">If that event is marked as handled along the event route, the mouse-button specific events are still raised; however, handlers of the mouse-button specific events must be added by explicitly calling <xref:System.Windows.ContentElement.AddHandler%2A>, with the option to handle events that are already marked as handled, in order to be listeners to the event.</span></span>  
  
 <span data-ttu-id="f4180-839">从概念上讲，将此事件 (和其他鼠标事件<xref:System.Windows.ContentElement>) 为鼠标"服务"(使用提供的服务定义<xref:System.Windows.Input.Mouse>类)。</span><span class="sxs-lookup"><span data-stu-id="f4180-839">Conceptually, think of this event (and other mouse-button events on <xref:System.Windows.ContentElement>) to be a mouse "service" (with the service definition provided by the <xref:System.Windows.Input.Mouse> class).</span></span> <span data-ttu-id="f4180-840">事件添加了方便的不需要检查原始的鼠标事件在事件数据中的鼠标按钮状态 （左-右、 向上向下）。</span><span class="sxs-lookup"><span data-stu-id="f4180-840">The event adds the convenience of not needing to check the mouse button states (left-right, up-down) of the original mouse events in the event data.</span></span> <span data-ttu-id="f4180-841">对于更高级的方案，例如非标准按钮的状态检查，您可能需要使用[!INCLUDE[TLA#tla_api#plural](~/includes/tlasharptla-apisharpplural-md.md)]上<xref:System.Windows.Input.Mouse>而不是这些类上<xref:System.Windows.ContentElement>。</span><span class="sxs-lookup"><span data-stu-id="f4180-841">For more advanced scenarios, such as checking for states of non-standard buttons, you might need to use the [!INCLUDE[TLA#tla_api#plural](~/includes/tlasharptla-apisharpplural-md.md)] on the <xref:System.Windows.Input.Mouse> class rather than those on <xref:System.Windows.ContentElement>.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="f4180-842">少量<xref:System.Windows.ContentElement>派生的类具有类似控件的行为，例如， <xref:System.Windows.Documents.Hyperlink>，可能会具有固有的鼠标按钮事件处理的类。</span><span class="sxs-lookup"><span data-stu-id="f4180-842">A few <xref:System.Windows.ContentElement> derived classes that have control-like behavior, for example, <xref:System.Windows.Documents.Hyperlink>, might have inherent class handling for mouse button events.</span></span> <span data-ttu-id="f4180-843">鼠标左键按下事件是最有可能的事件，以便使类处理在控件中。</span><span class="sxs-lookup"><span data-stu-id="f4180-843">The left mouse button down event is the most likely event to have class handling in a control.</span></span> <span data-ttu-id="f4180-844">类通常处理标记基础<xref:System.Windows.Input.Mouse>为已处理的类事件。</span><span class="sxs-lookup"><span data-stu-id="f4180-844">The class handling often marks the underlying <xref:System.Windows.Input.Mouse> class event as handled.</span></span> <span data-ttu-id="f4180-845">一旦该事件标记为已处理，其他实例处理程序附加到该元素通常不会引发。</span><span class="sxs-lookup"><span data-stu-id="f4180-845">Once the event is marked handled, other instance handlers that are attached to that element are not ordinarily raised.</span></span> <span data-ttu-id="f4180-846">通常也不会引发的任何其他类或实例处理程序附加到针对 UI 树的根节点的浮升方向中的元素。</span><span class="sxs-lookup"><span data-stu-id="f4180-846">Any other class or instance handlers that are attached to elements in the bubbling direction towards the root in the UI tree are also not ordinarily raised.</span></span>  
  
 <span data-ttu-id="f4180-847">您可以解决的问题，在前面的重要说明中所述和仍接收<xref:System.Windows.ContentElement.MouseLeftButtonDown>鼠标左键按下具有类处理通过使用这些解决方案的派生类上的事件的事件：</span><span class="sxs-lookup"><span data-stu-id="f4180-847">You can resolve the issue that is outlined in the preceding Important and still receive <xref:System.Windows.ContentElement.MouseLeftButtonDown> events for left mouse button down events on a derived class that has class handling by using either of these solutions:</span></span>  
  
-   <span data-ttu-id="f4180-848">附加处理程序<xref:System.Windows.ContentElement.PreviewMouseDown>未标记为已由控件处理的事件。</span><span class="sxs-lookup"><span data-stu-id="f4180-848">Attach handlers for the <xref:System.Windows.ContentElement.PreviewMouseDown> event, which is not marked as handled by the controls.</span></span> <span data-ttu-id="f4180-849">请注意，由于这是预览事件，该路由从根开始，隧道下行控件。</span><span class="sxs-lookup"><span data-stu-id="f4180-849">Notice that because this is a preview event, the route starts at the root and tunnels down to the control.</span></span>  
  
-   <span data-ttu-id="f4180-850">虽然通过调用注册该控件上的处理程序<xref:System.Windows.ContentElement.AddHandler%2A>，然后选择使处理程序以侦听事件，即使它们已标记为已处理路由的事件数据中的签名选项。</span><span class="sxs-lookup"><span data-stu-id="f4180-850">Register a handler on the control procedurally by calling <xref:System.Windows.ContentElement.AddHandler%2A> and choosing the signature option that enables handlers to listen for events even if they are already marked as handled in the routed event data.</span></span>  
  
<a name="routedEventInfo_MouseLeftButtonDown"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="f4180-851">路由事件信息</span><span class="sxs-lookup"><span data-stu-id="f4180-851">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="f4180-852">标识符字段</span><span class="sxs-lookup"><span data-stu-id="f4180-852">Identifier field</span></span>|<xref:System.Windows.ContentElement.MouseLeftButtonDownEvent>|  
|<span data-ttu-id="f4180-853">路由策略</span><span class="sxs-lookup"><span data-stu-id="f4180-853">Routing strategy</span></span>|<span data-ttu-id="f4180-854">直接</span><span class="sxs-lookup"><span data-stu-id="f4180-854">Direct</span></span>|  
|<span data-ttu-id="f4180-855">委托</span><span class="sxs-lookup"><span data-stu-id="f4180-855">Delegate</span></span>|<xref:System.Windows.Input.MouseButtonEventHandler>|  
  
-   <span data-ttu-id="f4180-856">重写<xref:System.Windows.ContentElement.OnMouseLeftButtonDown%2A>实现类处理此事件在派生类中。</span><span class="sxs-lookup"><span data-stu-id="f4180-856">Override <xref:System.Windows.ContentElement.OnMouseLeftButtonDown%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewMouseLeftButtonDown" />
      </Docs>
    </Member>
    <Member MemberName="MouseLeftButtonDownEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent MouseLeftButtonDownEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent MouseLeftButtonDownEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.MouseLeftButtonDownEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MouseLeftButtonDownEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ MouseLeftButtonDownEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable MouseLeftButtonDownEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.MouseLeftButtonDownEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f4180-857">标识 <see cref="E:System.Windows.ContentElement.MouseLeftButtonDown" /> 路由事件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-857">Identifies the <see cref="E:System.Windows.ContentElement.MouseLeftButtonDown" /> routed event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4180-858">在注册路由事件时创建路由事件标识符。</span><span class="sxs-lookup"><span data-stu-id="f4180-858">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="f4180-859">这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。</span><span class="sxs-lookup"><span data-stu-id="f4180-859">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="f4180-860">可以使用这些标识符添加类处理程序。</span><span class="sxs-lookup"><span data-stu-id="f4180-860">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="f4180-861">有关注册路由事件的更多信息，请参见 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="f4180-861">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="f4180-862">有关使用路由事件标识符添加类处理程序的更多信息，请参见 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="f4180-862">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseLeftButtonUp">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseButtonEventHandler MouseLeftButtonUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseButtonEventHandler MouseLeftButtonUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.MouseLeftButtonUp" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseLeftButtonUp As MouseButtonEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::MouseButtonEventHandler ^ MouseLeftButtonUp;" />
      <MemberSignature Language="F#" Value="member this.MouseLeftButtonUp : System.Windows.Input.MouseButtonEventHandler " Usage="member this.MouseLeftButtonUp : System.Windows.Input.MouseButtonEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.MouseLeftButtonUp</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f4180-863">在鼠标指针位于此元素上并且松开鼠标左键时发生。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-863">Occurs when the left mouse button is released while the mouse pointer is over this element.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4180-864">尽管这[路由事件概述](~/docs/framework/wpf/advanced/routed-events-overview.md)似乎按照浮升路由通过元素树，它实际上是引发并由每个重新沿元素树的直接路由的事件<xref:System.Windows.ContentElement>。</span><span class="sxs-lookup"><span data-stu-id="f4180-864">Although this [Routed Events Overview](~/docs/framework/wpf/advanced/routed-events-overview.md) seems to follow a bubbling route through an element tree, it actually is a direct routed event that is raised and reraised along the element tree by each <xref:System.Windows.ContentElement>.</span></span>  
  
 <span data-ttu-id="f4180-865">此事件是一个报告基础的鼠标按钮具体情况的多个相关事件<xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType>事件，它是由在事件路由的每个元素处理附加的事件。</span><span class="sxs-lookup"><span data-stu-id="f4180-865">This event is one of several related events that report the mouse-button specifics of an underlying <xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType> event, which is an attached event that is processed by each element along an event route.</span></span>  
  
 <span data-ttu-id="f4180-866">此事件的基础参数公开<xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType>事件。</span><span class="sxs-lookup"><span data-stu-id="f4180-866">The arguments of this event expose the arguments of the underlying <xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType> event.</span></span> <span data-ttu-id="f4180-867">如果该事件被标记为已处理事件路由过程，则仍会引发鼠标按钮特定事件;但是，必须通过显式调用添加的鼠标按钮特定事件的处理程序<xref:System.Windows.ContentElement.AddHandler%2A>，使用选项来处理已标记为已处理的事件，以便将该事件的侦听器。</span><span class="sxs-lookup"><span data-stu-id="f4180-867">If that event is marked as handled along the event route, the mouse-button specific events are still raised; however, handlers of the mouse-button specific events must be added by explicitly calling <xref:System.Windows.ContentElement.AddHandler%2A>, with the option to handle events that are already marked as handled, in order to be listeners to the event.</span></span>  
  
 <span data-ttu-id="f4180-868">从概念上讲，将此事件 (和其他鼠标事件<xref:System.Windows.ContentElement>) 为鼠标"服务"(使用提供的服务定义<xref:System.Windows.Input.Mouse>类)。</span><span class="sxs-lookup"><span data-stu-id="f4180-868">Conceptually, think of this event (and other mouse-button events on <xref:System.Windows.ContentElement>) to be a mouse "service" (with the service definition provided by the <xref:System.Windows.Input.Mouse> class).</span></span> <span data-ttu-id="f4180-869">事件添加了方便的不需要检查原始的鼠标事件在事件数据中的鼠标按钮状态 （左-右、 向上向下）。</span><span class="sxs-lookup"><span data-stu-id="f4180-869">The event adds the convenience of not needing to check the mouse button states (left-right, up-down) of the original mouse events in the event data.</span></span> <span data-ttu-id="f4180-870">对于更高级的方案，例如非标准按钮的状态检查，您可能需要使用[!INCLUDE[TLA#tla_api#plural](~/includes/tlasharptla-apisharpplural-md.md)]上<xref:System.Windows.Input.Mouse>而不是这些类上<xref:System.Windows.ContentElement>。</span><span class="sxs-lookup"><span data-stu-id="f4180-870">For more advanced scenarios, such as checking for states of non-standard buttons, you might need to use the [!INCLUDE[TLA#tla_api#plural](~/includes/tlasharptla-apisharpplural-md.md)] on the <xref:System.Windows.Input.Mouse> class rather than those on <xref:System.Windows.ContentElement>.</span></span>  
  
<a name="routedEventInfo_MouseLeftButtonUp"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="f4180-871">路由事件信息</span><span class="sxs-lookup"><span data-stu-id="f4180-871">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="f4180-872">标识符字段</span><span class="sxs-lookup"><span data-stu-id="f4180-872">Identifier field</span></span>|<xref:System.Windows.ContentElement.MouseLeftButtonUpEvent>|  
|<span data-ttu-id="f4180-873">路由策略</span><span class="sxs-lookup"><span data-stu-id="f4180-873">Routing strategy</span></span>|<span data-ttu-id="f4180-874">直接</span><span class="sxs-lookup"><span data-stu-id="f4180-874">Direct</span></span>|  
|<span data-ttu-id="f4180-875">委托</span><span class="sxs-lookup"><span data-stu-id="f4180-875">Delegate</span></span>|<xref:System.Windows.Input.MouseButtonEventHandler>|  
  
-   <span data-ttu-id="f4180-876">重写<xref:System.Windows.ContentElement.OnMouseLeftButtonUp%2A>实现类处理此事件在派生类中。</span><span class="sxs-lookup"><span data-stu-id="f4180-876">Override <xref:System.Windows.ContentElement.OnMouseLeftButtonUp%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewMouseLeftButtonUp" />
      </Docs>
    </Member>
    <Member MemberName="MouseLeftButtonUpEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent MouseLeftButtonUpEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent MouseLeftButtonUpEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.MouseLeftButtonUpEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MouseLeftButtonUpEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ MouseLeftButtonUpEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable MouseLeftButtonUpEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.MouseLeftButtonUpEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f4180-877">标识 <see cref="E:System.Windows.ContentElement.MouseLeftButtonUp" /> 路由事件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-877">Identifies the <see cref="E:System.Windows.ContentElement.MouseLeftButtonUp" /> routed event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4180-878">在注册路由事件时创建路由事件标识符。</span><span class="sxs-lookup"><span data-stu-id="f4180-878">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="f4180-879">这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。</span><span class="sxs-lookup"><span data-stu-id="f4180-879">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="f4180-880">可以使用这些标识符添加类处理程序。</span><span class="sxs-lookup"><span data-stu-id="f4180-880">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="f4180-881">有关注册路由事件的更多信息，请参见 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="f4180-881">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="f4180-882">有关使用路由事件标识符添加类处理程序的更多信息，请参见 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="f4180-882">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseMove">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseEventHandler MouseMove;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseEventHandler MouseMove" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.MouseMove" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseMove As MouseEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::MouseEventHandler ^ MouseMove;" />
      <MemberSignature Language="F#" Value="member this.MouseMove : System.Windows.Input.MouseEventHandler " Usage="member this.MouseMove : System.Windows.Input.MouseEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.MouseMove</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f4180-883">在鼠标指针位于此元素上并且移动鼠标指针时发生。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-883">Occurs when the mouse pointer moves while over this element.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4180-884">此事件创建一个别名<xref:System.Windows.Input.Mouse.MouseMove?displayProperty=nameWithType>附加事件对于此类，以便<xref:System.Windows.ContentElement.MouseMove>属于类的成员列出时<xref:System.Windows.ContentElement>作为基元素继承。</span><span class="sxs-lookup"><span data-stu-id="f4180-884">This event creates an alias for the <xref:System.Windows.Input.Mouse.MouseMove?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.MouseMove> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="f4180-885">事件处理程序附加到<xref:System.Windows.ContentElement.MouseMove>事件附加到基础<xref:System.Windows.Input.Mouse.MouseMove?displayProperty=nameWithType>附加事件，并接收相同的事件数据实例。</span><span class="sxs-lookup"><span data-stu-id="f4180-885">Event handlers that are attached to the <xref:System.Windows.ContentElement.MouseMove> event are attached to the underlying <xref:System.Windows.Input.Mouse.MouseMove?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
<a name="routedEventInfo_MouseMove"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="f4180-886">路由事件信息</span><span class="sxs-lookup"><span data-stu-id="f4180-886">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="f4180-887">标识符字段</span><span class="sxs-lookup"><span data-stu-id="f4180-887">Identifier field</span></span>|<xref:System.Windows.ContentElement.MouseMoveEvent>|  
|<span data-ttu-id="f4180-888">路由策略</span><span class="sxs-lookup"><span data-stu-id="f4180-888">Routing strategy</span></span>|<span data-ttu-id="f4180-889">浮升</span><span class="sxs-lookup"><span data-stu-id="f4180-889">Bubbling</span></span>|  
|<span data-ttu-id="f4180-890">委托</span><span class="sxs-lookup"><span data-stu-id="f4180-890">Delegate</span></span>|<xref:System.Windows.Input.MouseEventHandler>|  
  
-   <span data-ttu-id="f4180-891">相应的隧道事件是<xref:System.Windows.ContentElement.PreviewMouseMove>。</span><span class="sxs-lookup"><span data-stu-id="f4180-891">The corresponding tunneling event is <xref:System.Windows.ContentElement.PreviewMouseMove>.</span></span>  
  
-   <span data-ttu-id="f4180-892">重写<xref:System.Windows.ContentElement.OnMouseMove%2A>实现类处理此事件在派生类中。</span><span class="sxs-lookup"><span data-stu-id="f4180-892">Override <xref:System.Windows.ContentElement.OnMouseMove%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.MouseEnter" />
        <altmember cref="E:System.Windows.ContentElement.MouseLeave" />
      </Docs>
    </Member>
    <Member MemberName="MouseMoveEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent MouseMoveEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent MouseMoveEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.MouseMoveEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MouseMoveEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ MouseMoveEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable MouseMoveEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.MouseMoveEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f4180-893">标识 <see cref="E:System.Windows.ContentElement.MouseMove" /> 路由事件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-893">Identifies the <see cref="E:System.Windows.ContentElement.MouseMove" /> routed event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4180-894">在注册路由事件时创建路由事件标识符。</span><span class="sxs-lookup"><span data-stu-id="f4180-894">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="f4180-895">这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。</span><span class="sxs-lookup"><span data-stu-id="f4180-895">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="f4180-896">可以使用这些标识符添加类处理程序。</span><span class="sxs-lookup"><span data-stu-id="f4180-896">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="f4180-897">有关注册路由事件的更多信息，请参见 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="f4180-897">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="f4180-898">有关使用路由事件标识符添加类处理程序的更多信息，请参见 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="f4180-898">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseRightButtonDown">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseButtonEventHandler MouseRightButtonDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseButtonEventHandler MouseRightButtonDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.MouseRightButtonDown" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseRightButtonDown As MouseButtonEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::MouseButtonEventHandler ^ MouseRightButtonDown;" />
      <MemberSignature Language="F#" Value="member this.MouseRightButtonDown : System.Windows.Input.MouseButtonEventHandler " Usage="member this.MouseRightButtonDown : System.Windows.Input.MouseButtonEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.MouseRightButtonDown</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f4180-899">在鼠标指针位于此元素上并且按下鼠标右键时发生。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-899">Occurs when the right mouse button is pressed while the mouse pointer is over this element.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4180-900">尽管这[路由事件概述](~/docs/framework/wpf/advanced/routed-events-overview.md)似乎按照浮升路由通过元素树，它实际上是引发并由每个重新沿元素树的直接路由的事件<xref:System.Windows.ContentElement>。</span><span class="sxs-lookup"><span data-stu-id="f4180-900">Although this [Routed Events Overview](~/docs/framework/wpf/advanced/routed-events-overview.md) seems to follow a bubbling route through an element tree, it actually is a direct routed event that is raised and reraised along the element tree by each <xref:System.Windows.ContentElement>.</span></span>  
  
 <span data-ttu-id="f4180-901">此事件是一个报告基础的鼠标按钮具体情况的多个相关事件<xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType>事件，它是由在事件路由的每个元素处理附加的事件。</span><span class="sxs-lookup"><span data-stu-id="f4180-901">This event is one of several related events that report the mouse-button specifics of an underlying <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType> event, which is an attached event that is processed by each element along an event route.</span></span>  
  
 <span data-ttu-id="f4180-902">此事件的基础参数公开<xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType>事件。</span><span class="sxs-lookup"><span data-stu-id="f4180-902">The arguments of this event expose the arguments of the underlying <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType> event.</span></span> <span data-ttu-id="f4180-903">如果该事件被标记为已处理事件路由过程，则仍会引发鼠标按钮特定事件;但是，必须通过显式调用添加的鼠标按钮特定事件的处理程序<xref:System.Windows.ContentElement.AddHandler%2A>，使用选项来处理已标记为已处理的事件，以便将该事件的侦听器。</span><span class="sxs-lookup"><span data-stu-id="f4180-903">If that event is marked as handled along the event route, the mouse-button specific events are still raised; however, handlers of the mouse-button specific events must be added by explicitly calling <xref:System.Windows.ContentElement.AddHandler%2A>, with the option to handle events that are already marked as handled, in order to be listeners to the event.</span></span>  
  
 <span data-ttu-id="f4180-904">从概念上讲，将此事件 (和其他鼠标事件<xref:System.Windows.ContentElement>) 为鼠标"服务"(使用提供的服务定义<xref:System.Windows.Input.Mouse>类)。</span><span class="sxs-lookup"><span data-stu-id="f4180-904">Conceptually, think of this event (and other mouse-button events on <xref:System.Windows.ContentElement>) to be a mouse "service" (with the service definition provided by the <xref:System.Windows.Input.Mouse> class).</span></span> <span data-ttu-id="f4180-905">事件添加了方便的不需要检查原始的鼠标事件在事件数据中的鼠标按钮状态 （左-右、 向上向下）。</span><span class="sxs-lookup"><span data-stu-id="f4180-905">The event adds the convenience of not needing to check the mouse button states (left-right, up-down) of the original mouse events in the event data.</span></span> <span data-ttu-id="f4180-906">对于更高级的方案，例如非标准按钮的状态检查，您可能需要使用[!INCLUDE[TLA#tla_api#plural](~/includes/tlasharptla-apisharpplural-md.md)]上<xref:System.Windows.Input.Mouse>而不是这些类上<xref:System.Windows.ContentElement>。</span><span class="sxs-lookup"><span data-stu-id="f4180-906">For more advanced scenarios, such as checking for states of non-standard buttons, you might need to use the [!INCLUDE[TLA#tla_api#plural](~/includes/tlasharptla-apisharpplural-md.md)] on the <xref:System.Windows.Input.Mouse> class rather than those on <xref:System.Windows.ContentElement>.</span></span>  
  
 <span data-ttu-id="f4180-907">右侧的按钮的鼠标事件中经常会有本机处理应用程序方案。</span><span class="sxs-lookup"><span data-stu-id="f4180-907">Right button mouse events frequently have native handling in application scenarios.</span></span> <span data-ttu-id="f4180-908">例如，鼠标左键按下的可能会显示上下文菜单。</span><span class="sxs-lookup"><span data-stu-id="f4180-908">For instance, a right mouse button down might display a context menu.</span></span> <span data-ttu-id="f4180-909">请参阅[ContextMenu 概述](~/docs/framework/wpf/controls/contextmenu-overview.md)。</span><span class="sxs-lookup"><span data-stu-id="f4180-909">See [ContextMenu Overview](~/docs/framework/wpf/controls/contextmenu-overview.md).</span></span>  
  
<a name="routedEventInfo_MouseRightButtonDown"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="f4180-910">路由事件信息</span><span class="sxs-lookup"><span data-stu-id="f4180-910">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="f4180-911">标识符字段</span><span class="sxs-lookup"><span data-stu-id="f4180-911">Identifier field</span></span>|<xref:System.Windows.ContentElement.MouseRightButtonDownEvent>|  
|<span data-ttu-id="f4180-912">路由策略</span><span class="sxs-lookup"><span data-stu-id="f4180-912">Routing strategy</span></span>|<span data-ttu-id="f4180-913">直接</span><span class="sxs-lookup"><span data-stu-id="f4180-913">Direct</span></span>|  
|<span data-ttu-id="f4180-914">委托</span><span class="sxs-lookup"><span data-stu-id="f4180-914">Delegate</span></span>|<xref:System.Windows.Input.MouseButtonEventHandler>|  
  
-   <span data-ttu-id="f4180-915">重写<xref:System.Windows.ContentElement.OnMouseRightButtonDown%2A>实现类处理此事件在派生类中。</span><span class="sxs-lookup"><span data-stu-id="f4180-915">Override <xref:System.Windows.ContentElement.OnMouseRightButtonDown%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewMouseRightButtonDown" />
      </Docs>
    </Member>
    <Member MemberName="MouseRightButtonDownEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent MouseRightButtonDownEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent MouseRightButtonDownEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.MouseRightButtonDownEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MouseRightButtonDownEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ MouseRightButtonDownEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable MouseRightButtonDownEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.MouseRightButtonDownEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f4180-916">标识 <see cref="E:System.Windows.ContentElement.MouseRightButtonDown" /> 路由事件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-916">Identifies the <see cref="E:System.Windows.ContentElement.MouseRightButtonDown" /> routed event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4180-917">在注册路由事件时创建路由事件标识符。</span><span class="sxs-lookup"><span data-stu-id="f4180-917">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="f4180-918">这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。</span><span class="sxs-lookup"><span data-stu-id="f4180-918">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="f4180-919">可以使用这些标识符添加类处理程序。</span><span class="sxs-lookup"><span data-stu-id="f4180-919">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="f4180-920">有关注册路由事件的更多信息，请参见 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="f4180-920">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="f4180-921">有关使用路由事件标识符添加类处理程序的更多信息，请参见 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="f4180-921">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseRightButtonUp">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseButtonEventHandler MouseRightButtonUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseButtonEventHandler MouseRightButtonUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.MouseRightButtonUp" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseRightButtonUp As MouseButtonEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::MouseButtonEventHandler ^ MouseRightButtonUp;" />
      <MemberSignature Language="F#" Value="member this.MouseRightButtonUp : System.Windows.Input.MouseButtonEventHandler " Usage="member this.MouseRightButtonUp : System.Windows.Input.MouseButtonEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.MouseRightButtonUp</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f4180-922">在鼠标指针位于此元素上并且松开鼠标右键时发生。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-922">Occurs when the right mouse button is released while the mouse pointer is over this element.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4180-923">尽管这[路由事件概述](~/docs/framework/wpf/advanced/routed-events-overview.md)似乎按照浮升路由通过元素树，它实际上是引发并由每个重新沿元素树的直接路由的事件<xref:System.Windows.ContentElement>。</span><span class="sxs-lookup"><span data-stu-id="f4180-923">Although this [Routed Events Overview](~/docs/framework/wpf/advanced/routed-events-overview.md) seems to follow a bubbling route through an element tree, it actually is a direct routed event that is raised and reraised along the element tree by each <xref:System.Windows.ContentElement>.</span></span>  
  
 <span data-ttu-id="f4180-924">此事件是一个报告基础的鼠标按钮具体情况的多个相关事件<xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType>事件，它是由在事件路由的每个元素处理附加的事件。</span><span class="sxs-lookup"><span data-stu-id="f4180-924">This event is one of several related events that report the mouse-button specifics of an underlying <xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType> event, which is an attached event that is processed by each element along an event route.</span></span>  
  
 <span data-ttu-id="f4180-925">此事件的基础参数公开<xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType>事件。</span><span class="sxs-lookup"><span data-stu-id="f4180-925">The arguments of this event expose the arguments of the underlying <xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType> event.</span></span> <span data-ttu-id="f4180-926">如果该事件被标记为已处理事件路由过程，则仍会引发鼠标按钮特定事件;但是，必须通过显式调用添加的鼠标按钮特定事件的处理程序<xref:System.Windows.ContentElement.AddHandler%2A>，使用选项来处理已标记为已处理的事件，以便将该事件的侦听器。</span><span class="sxs-lookup"><span data-stu-id="f4180-926">If that event is marked as handled along the event route, the mouse-button specific events are still raised; however, handlers of the mouse-button specific events must be added by explicitly calling <xref:System.Windows.ContentElement.AddHandler%2A>, with the option to handle events that are already marked as handled, in order to be listeners to the event.</span></span>  
  
 <span data-ttu-id="f4180-927">从概念上讲，将此事件 (和其他鼠标事件<xref:System.Windows.ContentElement>) 为鼠标"服务"(使用提供的服务定义<xref:System.Windows.Input.Mouse>类)。</span><span class="sxs-lookup"><span data-stu-id="f4180-927">Conceptually, think of this event (and other mouse-button events on <xref:System.Windows.ContentElement>) to be a mouse "service" (with the service definition provided by the <xref:System.Windows.Input.Mouse> class).</span></span> <span data-ttu-id="f4180-928">事件添加了方便的不需要检查原始的鼠标事件在事件数据中的鼠标按钮状态 （左-右、 向上向下）。</span><span class="sxs-lookup"><span data-stu-id="f4180-928">The event adds the convenience of not needing to check the mouse button states (left-right, up-down) of the original mouse events in the event data.</span></span> <span data-ttu-id="f4180-929">对于更高级的方案，例如非标准按钮的状态检查，您可能需要使用[!INCLUDE[TLA#tla_api#plural](~/includes/tlasharptla-apisharpplural-md.md)]上<xref:System.Windows.Input.Mouse>而不是这些类上<xref:System.Windows.ContentElement>。</span><span class="sxs-lookup"><span data-stu-id="f4180-929">For more advanced scenarios, such as checking for states of non-standard buttons, you might need to use the [!INCLUDE[TLA#tla_api#plural](~/includes/tlasharptla-apisharpplural-md.md)] on the <xref:System.Windows.Input.Mouse> class rather than those on <xref:System.Windows.ContentElement>.</span></span>  
  
<a name="routedEventInfo_MouseRightButtonUp"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="f4180-930">路由事件信息</span><span class="sxs-lookup"><span data-stu-id="f4180-930">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="f4180-931">标识符字段</span><span class="sxs-lookup"><span data-stu-id="f4180-931">Identifier field</span></span>|<xref:System.Windows.ContentElement.MouseRightButtonUpEvent>|  
|<span data-ttu-id="f4180-932">路由策略</span><span class="sxs-lookup"><span data-stu-id="f4180-932">Routing strategy</span></span>|<span data-ttu-id="f4180-933">直接</span><span class="sxs-lookup"><span data-stu-id="f4180-933">Direct</span></span>|  
|<span data-ttu-id="f4180-934">委托</span><span class="sxs-lookup"><span data-stu-id="f4180-934">Delegate</span></span>|<xref:System.Windows.Input.MouseButtonEventHandler>|  
  
-   <span data-ttu-id="f4180-935">重写<xref:System.Windows.ContentElement.OnMouseRightButtonUp%2A>实现类处理此事件在派生类中。</span><span class="sxs-lookup"><span data-stu-id="f4180-935">Override <xref:System.Windows.ContentElement.OnMouseRightButtonUp%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewMouseRightButtonUp" />
      </Docs>
    </Member>
    <Member MemberName="MouseRightButtonUpEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent MouseRightButtonUpEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent MouseRightButtonUpEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.MouseRightButtonUpEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MouseRightButtonUpEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ MouseRightButtonUpEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable MouseRightButtonUpEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.MouseRightButtonUpEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f4180-936">标识 <see cref="E:System.Windows.ContentElement.MouseRightButtonUp" /> 路由事件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-936">Identifies the <see cref="E:System.Windows.ContentElement.MouseRightButtonUp" /> routed event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4180-937">在注册路由事件时创建路由事件标识符。</span><span class="sxs-lookup"><span data-stu-id="f4180-937">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="f4180-938">这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。</span><span class="sxs-lookup"><span data-stu-id="f4180-938">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="f4180-939">可以使用这些标识符添加类处理程序。</span><span class="sxs-lookup"><span data-stu-id="f4180-939">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="f4180-940">有关注册路由事件的更多信息，请参见 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="f4180-940">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="f4180-941">有关使用路由事件标识符添加类处理程序的更多信息，请参见 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="f4180-941">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseUp">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseButtonEventHandler MouseUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseButtonEventHandler MouseUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.MouseUp" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseUp As MouseButtonEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Input::MouseButtonEventHandler ^ MouseUp;" />
      <MemberSignature Language="F#" Value="member this.MouseUp : System.Windows.Input.MouseButtonEventHandler " Usage="member this.MouseUp : System.Windows.Input.MouseButtonEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f4180-942">在鼠标指针位于此元素上并且松开任意鼠标按钮时发生。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-942">Occurs when any mouse button is released over this element.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4180-943">此事件创建一个别名<xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType>附加事件对于此类，以便<xref:System.Windows.ContentElement.MouseUp>属于类的成员列出时<xref:System.Windows.ContentElement>作为基元素继承。</span><span class="sxs-lookup"><span data-stu-id="f4180-943">This event creates an alias for the <xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.MouseUp> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="f4180-944">事件处理程序附加到<xref:System.Windows.ContentElement.MouseUp>事件附加到基础<xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType>附加事件，并接收相同的事件数据实例。</span><span class="sxs-lookup"><span data-stu-id="f4180-944">Event handlers that are attached to the <xref:System.Windows.ContentElement.MouseUp> event are attached to the underlying <xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
 <span data-ttu-id="f4180-945"><xref:System.Windows.ContentElement.MouseUp>任意一个协同通常引发事件<xref:System.Windows.ContentElement.MouseLeftButtonUp>或<xref:System.Windows.ContentElement.MouseRightButtonUp>，对应于版本的两个标准鼠标按钮之一。</span><span class="sxs-lookup"><span data-stu-id="f4180-945">The <xref:System.Windows.ContentElement.MouseUp> event is often raised together with either <xref:System.Windows.ContentElement.MouseLeftButtonUp> or <xref:System.Windows.ContentElement.MouseRightButtonUp>, which correspond to a release of one of the two standard mouse buttons.</span></span> <span data-ttu-id="f4180-946"><xref:System.Windows.ContentElement.MouseLeftButtonUp> 并<xref:System.Windows.ContentElement.MouseRightButtonUp>也是路由的事件，但它们是直接路由的事件，并引发相应的特定于按钮的事件时<xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType>事件到达事件路由中的此元素。</span><span class="sxs-lookup"><span data-stu-id="f4180-946"><xref:System.Windows.ContentElement.MouseLeftButtonUp> and <xref:System.Windows.ContentElement.MouseRightButtonUp> are also routed events, but they are direct routed events, and the appropriate button-specific event is raised when the <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType> event reaches this element along the event route.</span></span> <span data-ttu-id="f4180-947">请参阅备注<xref:System.Windows.ContentElement.MouseLeftButtonUp>或<xref:System.Windows.ContentElement.MouseRightButtonUp>。</span><span class="sxs-lookup"><span data-stu-id="f4180-947">See Remarks for <xref:System.Windows.ContentElement.MouseLeftButtonUp> or <xref:System.Windows.ContentElement.MouseRightButtonUp>.</span></span>  
  
<a name="routedEventInfo_MouseUp"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="f4180-948">路由事件信息</span><span class="sxs-lookup"><span data-stu-id="f4180-948">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="f4180-949">标识符字段</span><span class="sxs-lookup"><span data-stu-id="f4180-949">Identifier field</span></span>|<xref:System.Windows.ContentElement.MouseUpEvent>|  
|<span data-ttu-id="f4180-950">路由策略</span><span class="sxs-lookup"><span data-stu-id="f4180-950">Routing strategy</span></span>|<span data-ttu-id="f4180-951">浮升</span><span class="sxs-lookup"><span data-stu-id="f4180-951">Bubbling</span></span>|  
|<span data-ttu-id="f4180-952">委托</span><span class="sxs-lookup"><span data-stu-id="f4180-952">Delegate</span></span>|<xref:System.Windows.Input.MouseButtonEventHandler>|  
  
-   <span data-ttu-id="f4180-953">相应的隧道事件是<xref:System.Windows.ContentElement.PreviewMouseUp>。</span><span class="sxs-lookup"><span data-stu-id="f4180-953">The corresponding tunneling event is <xref:System.Windows.ContentElement.PreviewMouseUp>.</span></span>  
  
-   <span data-ttu-id="f4180-954">重写<xref:System.Windows.ContentElement.OnMouseUp%2A>实现类处理此事件在派生类中。</span><span class="sxs-lookup"><span data-stu-id="f4180-954">Override <xref:System.Windows.ContentElement.OnMouseUp%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseUpEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent MouseUpEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent MouseUpEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.MouseUpEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MouseUpEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ MouseUpEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable MouseUpEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.MouseUpEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f4180-955">标识 <see cref="E:System.Windows.ContentElement.MouseUp" /> 路由事件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-955">Identifies the <see cref="E:System.Windows.ContentElement.MouseUp" /> routed event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4180-956">在注册路由事件时创建路由事件标识符。</span><span class="sxs-lookup"><span data-stu-id="f4180-956">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="f4180-957">这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。</span><span class="sxs-lookup"><span data-stu-id="f4180-957">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="f4180-958">可以使用这些标识符添加类处理程序。</span><span class="sxs-lookup"><span data-stu-id="f4180-958">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="f4180-959">有关注册路由事件的更多信息，请参见 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="f4180-959">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="f4180-960">有关使用路由事件标识符添加类处理程序的更多信息，请参见 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="f4180-960">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseWheel">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseWheelEventHandler MouseWheel;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseWheelEventHandler MouseWheel" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.MouseWheel" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseWheel As MouseWheelEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::MouseWheelEventHandler ^ MouseWheel;" />
      <MemberSignature Language="F#" Value="member this.MouseWheel : System.Windows.Input.MouseWheelEventHandler " Usage="member this.MouseWheel : System.Windows.Input.MouseWheelEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.MouseWheel</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseWheelEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f4180-961">在鼠标指针位于此元素上并且用户滚动鼠标滚轮时发生。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-961">Occurs when the user rotates the mouse wheel while the mouse pointer is over this element.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4180-962">焦点或鼠标捕获优先于在鼠标指针位于其中;因此，如果你收到<xref:System.Windows.ContentElement.MouseWheel>从已设定焦点或捕获的元素的事件，鼠标指针可能实际上是另一个元素上。</span><span class="sxs-lookup"><span data-stu-id="f4180-962">Focus or mouse capture take precedence over where the mouse pointer is; therefore, if you receive the <xref:System.Windows.ContentElement.MouseWheel> event from a focused or captured element, the mouse pointer might actually be over another element.</span></span>  
  
 <span data-ttu-id="f4180-963">此事件创建一个别名<xref:System.Windows.Input.Mouse.MouseWheel?displayProperty=nameWithType>附加事件对于此类，以便<xref:System.Windows.ContentElement.MouseWheel>属于类的成员列出时<xref:System.Windows.ContentElement>作为基元素继承。</span><span class="sxs-lookup"><span data-stu-id="f4180-963">This event creates an alias for the <xref:System.Windows.Input.Mouse.MouseWheel?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.MouseWheel> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="f4180-964">事件处理程序附加到<xref:System.Windows.ContentElement.MouseWheel>事件附加到基础<xref:System.Windows.Input.Mouse.MouseWheel?displayProperty=nameWithType>附加事件，并接收相同的事件数据实例。</span><span class="sxs-lookup"><span data-stu-id="f4180-964">Event handlers that are attached to the <xref:System.Windows.ContentElement.MouseWheel> event are attached to the underlying <xref:System.Windows.Input.Mouse.MouseWheel?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
<a name="routedEventInfo_MouseWheel"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="f4180-965">路由事件信息</span><span class="sxs-lookup"><span data-stu-id="f4180-965">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="f4180-966">标识符字段</span><span class="sxs-lookup"><span data-stu-id="f4180-966">Identifier field</span></span>|<xref:System.Windows.ContentElement.MouseWheelEvent>|  
|<span data-ttu-id="f4180-967">路由策略</span><span class="sxs-lookup"><span data-stu-id="f4180-967">Routing strategy</span></span>|<span data-ttu-id="f4180-968">浮升</span><span class="sxs-lookup"><span data-stu-id="f4180-968">Bubbling</span></span>|  
|<span data-ttu-id="f4180-969">委托</span><span class="sxs-lookup"><span data-stu-id="f4180-969">Delegate</span></span>|<xref:System.Windows.Input.MouseWheelEventHandler>|  
  
-   <span data-ttu-id="f4180-970">相应的隧道事件是<xref:System.Windows.ContentElement.PreviewMouseWheel>。</span><span class="sxs-lookup"><span data-stu-id="f4180-970">The corresponding tunneling event is <xref:System.Windows.ContentElement.PreviewMouseWheel>.</span></span>  
  
-   <span data-ttu-id="f4180-971">重写<xref:System.Windows.ContentElement.OnMouseWheel%2A>实现类处理此事件在派生类中。</span><span class="sxs-lookup"><span data-stu-id="f4180-971">Override <xref:System.Windows.ContentElement.OnMouseWheel%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseWheelEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent MouseWheelEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent MouseWheelEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.MouseWheelEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MouseWheelEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ MouseWheelEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable MouseWheelEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.MouseWheelEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f4180-972">标识 <see cref="E:System.Windows.ContentElement.MouseWheel" /> 路由事件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-972">Identifies the <see cref="E:System.Windows.ContentElement.MouseWheel" /> routed event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4180-973">在注册路由事件时创建路由事件标识符。</span><span class="sxs-lookup"><span data-stu-id="f4180-973">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="f4180-974">这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。</span><span class="sxs-lookup"><span data-stu-id="f4180-974">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="f4180-975">可以使用这些标识符添加类处理程序。</span><span class="sxs-lookup"><span data-stu-id="f4180-975">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="f4180-976">有关注册路由事件的更多信息，请参见 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="f4180-976">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="f4180-977">有关使用路由事件标识符添加类处理程序的更多信息，请参见 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="f4180-977">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MoveFocus">
      <MemberSignature Language="C#" Value="public virtual bool MoveFocus (System.Windows.Input.TraversalRequest request);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool MoveFocus(class System.Windows.Input.TraversalRequest request) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.MoveFocus(System.Windows.Input.TraversalRequest)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function MoveFocus (request As TraversalRequest) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool MoveFocus(System::Windows::Input::TraversalRequest ^ request);" />
      <MemberSignature Language="F#" Value="abstract member MoveFocus : System.Windows.Input.TraversalRequest -&gt; bool&#xA;override this.MoveFocus : System.Windows.Input.TraversalRequest -&gt; bool" Usage="contentElement.MoveFocus request" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="request" Type="System.Windows.Input.TraversalRequest" />
      </Parameters>
      <Docs>
        <param name="request">
          <span data-ttu-id="f4180-978">一个遍历请求，其中包含一个属性，该属性指示以现有 Tab 键顺序遍历的模式或视觉移动的方向。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-978">A traversal request, which contains a property that indicates either a mode to traverse in existing tab order, or a direction to move visually.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f4180-979">尝试将焦点从此元素移到其他元素。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-979">Attempts to move focus from this element to another element.</span>
          </span>
          <span data-ttu-id="f4180-980">移动焦点的方向由指导方向指定，该方向在此元素的可视父级的组织结构中解释。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-980">The direction to move focus is specified by a guidance direction, which is interpreted within the organization of the visual parent for this element.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f4180-981">如果执行了请求的遍历，则为 <see langword="true" />；否则为 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-981">
              <see langword="true" /> if the requested traversal was performed; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4180-982">请务必检查此方法的返回值。</span><span class="sxs-lookup"><span data-stu-id="f4180-982">Make sure you check the return value of this method.</span></span> <span data-ttu-id="f4180-983">返回值为`false`如果遍历遇到控件的组合所定义的制表位并且遍历请求未请求来包装可能会返回。</span><span class="sxs-lookup"><span data-stu-id="f4180-983">A return value of `false` might be returned if the traversal runs into a tab stop that is defined by a control's composition, and the traversal request did not request to wrap.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.ContentElement.Focus" />
      </Docs>
    </Member>
    <Member MemberName="OnCreateAutomationPeer">
      <MemberSignature Language="C#" Value="protected virtual System.Windows.Automation.Peers.AutomationPeer OnCreateAutomationPeer ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Windows.Automation.Peers.AutomationPeer OnCreateAutomationPeer() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnCreateAutomationPeer" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function OnCreateAutomationPeer () As AutomationPeer" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Windows::Automation::Peers::AutomationPeer ^ OnCreateAutomationPeer();" />
      <MemberSignature Language="F#" Value="abstract member OnCreateAutomationPeer : unit -&gt; System.Windows.Automation.Peers.AutomationPeer&#xA;override this.OnCreateAutomationPeer : unit -&gt; System.Windows.Automation.Peers.AutomationPeer" Usage="contentElement.OnCreateAutomationPeer " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Automation.Peers.AutomationPeer</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="f4180-984">为 [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] 基础结构返回特定于类的 <see cref="T:System.Windows.Automation.Peers.AutomationPeer" /> 实现。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-984">Returns class-specific <see cref="T:System.Windows.Automation.Peers.AutomationPeer" /> implementations for the [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] infrastructure.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f4180-985">特定于类型的 <see cref="T:System.Windows.Automation.Peers.AutomationPeer" /> 实现。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-985">The type-specific <see cref="T:System.Windows.Automation.Peers.AutomationPeer" /> implementation.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides">
          <para>
            <span data-ttu-id="f4180-986">此方法的实现通常是调用特定构造函数<see cref="T:System.Windows.Automation.Peers.AutomationPeer" />实现中，并将其返回作为返回值。</span>
            <span class="sxs-lookup">
              <span data-stu-id="f4180-986">The implementation of this method is typically to call the constructor of a specific <see cref="T:System.Windows.Automation.Peers.AutomationPeer" /> implementation, and return it as the return value.</span>
            </span>
            <span data-ttu-id="f4180-987">所有<see cref="T:System.Windows.ContentElement" />派生的类应实现此方法以提供其各自的特定<see cref="T:System.Windows.Automation.Peers.AutomationPeer" />实现到[!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)]基础结构。</span>
            <span class="sxs-lookup">
              <span data-stu-id="f4180-987">All <see cref="T:System.Windows.ContentElement" /> derived classes should implement this method in order to provide their own specific <see cref="T:System.Windows.Automation.Peers.AutomationPeer" /> implementations to the [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] infrastructure.</span>
            </span>
            <span data-ttu-id="f4180-988">有关实现此模式的详细信息，请参阅<see cref="T:System.Windows.Automation.Peers.AutomationPeer" />。</span>
            <span class="sxs-lookup">
              <span data-stu-id="f4180-988">For details on implementing this pattern, see <see cref="T:System.Windows.Automation.Peers.AutomationPeer" />.</span>
            </span>
          </para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnDragEnter">
      <MemberSignature Language="C#" Value="protected internal virtual void OnDragEnter (System.Windows.DragEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnDragEnter(class System.Windows.DragEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnDragEnter(System.Windows.DragEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnDragEnter (e As DragEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnDragEnter(System::Windows::DragEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnDragEnter : System.Windows.DragEventArgs -&gt; unit&#xA;override this.OnDragEnter : System.Windows.DragEventArgs -&gt; unit" Usage="contentElement.OnDragEnter e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DragEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="f4180-989">包含事件数据的 <see cref="T:System.Windows.DragEventArgs" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-989">The <see cref="T:System.Windows.DragEventArgs" /> that contains the event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f4180-990">当某个未处理的 <see cref="E:System.Windows.DragDrop.DragEnter" /> 附加事件在其路由中到达派生自此类的某个元素时调用。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-990">Invoked when an unhandled <see cref="E:System.Windows.DragDrop.DragEnter" /> attached event reaches an element in its route that is derived from this class.</span>
          </span>
          <span data-ttu-id="f4180-991">实现此方法可为此事件添加类处理。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-991">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4180-992">此方法具有默认实现。</span><span class="sxs-lookup"><span data-stu-id="f4180-992">This method has no default implementation.</span></span> <span data-ttu-id="f4180-993">因为中间类继承中的可能会实现此方法，我们建议在实现中调用基实现。</span><span class="sxs-lookup"><span data-stu-id="f4180-993">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="f4180-994">此方法的用途是类似于[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]事件模式 On \* 方法： 此方法提供了通过建立类处理程序而不是实例处理程序来处理从派生类的匹配事件的方法。</span><span class="sxs-lookup"><span data-stu-id="f4180-994">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="f4180-995">在这种情况下匹配事件是路由的事件。</span><span class="sxs-lookup"><span data-stu-id="f4180-995">In this case the matching event is a routed event.</span></span> <span data-ttu-id="f4180-996">On \* 方法的实现模式是不同的路由事件，因为可以由子元素，它不一定是将调用处理程序的元素引发路由的事件。</span><span class="sxs-lookup"><span data-stu-id="f4180-996">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="f4180-997">因此，您的实现需要检查的事件数据源属性。</span><span class="sxs-lookup"><span data-stu-id="f4180-997">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="f4180-998">它不应尝试再次引发该事件在大多数情况下。</span><span class="sxs-lookup"><span data-stu-id="f4180-998">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="f4180-999">通过重写此方法或通过注册类处理程序替换<xref:System.Windows.EventManager.RegisterClassHandler%2A>，派生类的<xref:System.Windows.ContentElement>为由事件路由收到事件时，可以调用私有类处理程序方法。</span><span class="sxs-lookup"><span data-stu-id="f4180-999">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="f4180-1000">类处理是相应的一种方案是操作事件数据并将路由的事件标记为已处理。</span><span class="sxs-lookup"><span data-stu-id="f4180-1000">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.DragEnter" />
      </Docs>
    </Member>
    <Member MemberName="OnDragLeave">
      <MemberSignature Language="C#" Value="protected internal virtual void OnDragLeave (System.Windows.DragEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnDragLeave(class System.Windows.DragEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnDragLeave(System.Windows.DragEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnDragLeave (e As DragEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnDragLeave(System::Windows::DragEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnDragLeave : System.Windows.DragEventArgs -&gt; unit&#xA;override this.OnDragLeave : System.Windows.DragEventArgs -&gt; unit" Usage="contentElement.OnDragLeave e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DragEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="f4180-1001">包含事件数据的 <see cref="T:System.Windows.DragEventArgs" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-1001">The <see cref="T:System.Windows.DragEventArgs" /> that contains the event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f4180-1002">当某个未处理的 <see cref="E:System.Windows.DragDrop.DragLeave" /> 附加事件在其路由中到达派生自此类的某个元素时调用。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-1002">Invoked when an unhandled <see cref="E:System.Windows.DragDrop.DragLeave" /> attached event reaches an element in its route that is derived from this class.</span>
          </span>
          <span data-ttu-id="f4180-1003">实现此方法可为此事件添加类处理。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-1003">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4180-1004">此方法具有默认实现。</span><span class="sxs-lookup"><span data-stu-id="f4180-1004">This method has no default implementation.</span></span> <span data-ttu-id="f4180-1005">因为中间类继承中的可能会实现此方法，我们建议在实现中调用基实现。</span><span class="sxs-lookup"><span data-stu-id="f4180-1005">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="f4180-1006">此方法的用途是类似于[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]事件模式 On \* 方法： 此方法提供了通过建立类处理程序而不是实例处理程序来处理从派生类的匹配事件的方法。</span><span class="sxs-lookup"><span data-stu-id="f4180-1006">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="f4180-1007">在这种情况下匹配事件是路由的事件。</span><span class="sxs-lookup"><span data-stu-id="f4180-1007">In this case the matching event is a routed event.</span></span> <span data-ttu-id="f4180-1008">On \* 方法的实现模式是不同的路由事件，因为可以由子元素，它不一定是将调用处理程序的元素引发路由的事件。</span><span class="sxs-lookup"><span data-stu-id="f4180-1008">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="f4180-1009">因此，您的实现需要检查的事件数据源属性。</span><span class="sxs-lookup"><span data-stu-id="f4180-1009">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="f4180-1010">它不应尝试再次引发该事件在大多数情况下。</span><span class="sxs-lookup"><span data-stu-id="f4180-1010">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="f4180-1011">通过重写此方法或通过注册类处理程序替换<xref:System.Windows.EventManager.RegisterClassHandler%2A>，派生类的<xref:System.Windows.ContentElement>为由事件路由收到事件时，可以调用私有类处理程序方法。</span><span class="sxs-lookup"><span data-stu-id="f4180-1011">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="f4180-1012">类处理是相应的一种方案是操作事件数据并将路由的事件标记为已处理。</span><span class="sxs-lookup"><span data-stu-id="f4180-1012">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.DragLeave" />
      </Docs>
    </Member>
    <Member MemberName="OnDragOver">
      <MemberSignature Language="C#" Value="protected internal virtual void OnDragOver (System.Windows.DragEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnDragOver(class System.Windows.DragEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnDragOver(System.Windows.DragEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnDragOver (e As DragEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnDragOver(System::Windows::DragEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnDragOver : System.Windows.DragEventArgs -&gt; unit&#xA;override this.OnDragOver : System.Windows.DragEventArgs -&gt; unit" Usage="contentElement.OnDragOver e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DragEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="f4180-1013">包含事件数据的 <see cref="T:System.Windows.DragEventArgs" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-1013">The <see cref="T:System.Windows.DragEventArgs" /> that contains the event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f4180-1014">当某个未处理的 <see cref="E:System.Windows.DragDrop.DragOver" /> 附加事件在其路由中到达派生自此类的某个元素时调用。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-1014">Invoked when an unhandled <see cref="E:System.Windows.DragDrop.DragOver" /> attached event reaches an element in its route that is derived from this class.</span>
          </span>
          <span data-ttu-id="f4180-1015">实现此方法可为此事件添加类处理。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-1015">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4180-1016">此方法具有默认实现。</span><span class="sxs-lookup"><span data-stu-id="f4180-1016">This method has no default implementation.</span></span> <span data-ttu-id="f4180-1017">因为中间类继承中的可能会实现此方法，我们建议在实现中调用基实现。</span><span class="sxs-lookup"><span data-stu-id="f4180-1017">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="f4180-1018">此方法的用途是类似于[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]事件模式 On \* 方法： 此方法提供了通过建立类处理程序而不是实例处理程序来处理从派生类的匹配事件的方法。</span><span class="sxs-lookup"><span data-stu-id="f4180-1018">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="f4180-1019">在这种情况下匹配事件是路由的事件。</span><span class="sxs-lookup"><span data-stu-id="f4180-1019">In this case the matching event is a routed event.</span></span> <span data-ttu-id="f4180-1020">On \* 方法的实现模式是不同的路由事件，因为可以由子元素，它不一定是将调用处理程序的元素引发路由的事件。</span><span class="sxs-lookup"><span data-stu-id="f4180-1020">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="f4180-1021">因此，您的实现需要检查的事件数据源属性。</span><span class="sxs-lookup"><span data-stu-id="f4180-1021">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="f4180-1022">它不应尝试再次引发该事件在大多数情况下。</span><span class="sxs-lookup"><span data-stu-id="f4180-1022">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="f4180-1023">通过重写此方法或通过注册类处理程序替换<xref:System.Windows.EventManager.RegisterClassHandler%2A>，派生类的<xref:System.Windows.ContentElement>为由事件路由收到事件时，可以调用私有类处理程序方法。</span><span class="sxs-lookup"><span data-stu-id="f4180-1023">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="f4180-1024">类处理是相应的一种方案是操作事件数据并将路由的事件标记为已处理。</span><span class="sxs-lookup"><span data-stu-id="f4180-1024">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.DragOver" />
      </Docs>
    </Member>
    <Member MemberName="OnDrop">
      <MemberSignature Language="C#" Value="protected internal virtual void OnDrop (System.Windows.DragEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnDrop(class System.Windows.DragEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnDrop(System.Windows.DragEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnDrop (e As DragEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnDrop(System::Windows::DragEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnDrop : System.Windows.DragEventArgs -&gt; unit&#xA;override this.OnDrop : System.Windows.DragEventArgs -&gt; unit" Usage="contentElement.OnDrop e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DragEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="f4180-1025">包含事件数据的 <see cref="T:System.Windows.DragEventArgs" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-1025">The <see cref="T:System.Windows.DragEventArgs" /> that contains the event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f4180-1026">当某个未处理的 <see cref="E:System.Windows.DragDrop.DragEnter" /> 附加事件在其路由中到达派生自此类的某个元素时调用。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-1026">Invoked when an unhandled <see cref="E:System.Windows.DragDrop.DragEnter" /> attached event reaches an element in its route that is derived from this class.</span>
          </span>
          <span data-ttu-id="f4180-1027">实现此方法可为此事件添加类处理。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-1027">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4180-1028">此方法具有默认实现。</span><span class="sxs-lookup"><span data-stu-id="f4180-1028">This method has no default implementation.</span></span> <span data-ttu-id="f4180-1029">因为中间类继承中的可能会实现此方法，我们建议在实现中调用基实现。</span><span class="sxs-lookup"><span data-stu-id="f4180-1029">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="f4180-1030">此方法的用途是类似于[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]事件模式 On \* 方法： 此方法提供了通过建立类处理程序而不是实例处理程序来处理从派生类的匹配事件的方法。</span><span class="sxs-lookup"><span data-stu-id="f4180-1030">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="f4180-1031">在这种情况下匹配事件是路由的事件。</span><span class="sxs-lookup"><span data-stu-id="f4180-1031">In this case the matching event is a routed event.</span></span> <span data-ttu-id="f4180-1032">On \* 方法的实现模式是不同的路由事件，因为可以由子元素，它不一定是将调用处理程序的元素引发路由的事件。</span><span class="sxs-lookup"><span data-stu-id="f4180-1032">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="f4180-1033">因此，您的实现需要检查的事件数据源属性。</span><span class="sxs-lookup"><span data-stu-id="f4180-1033">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="f4180-1034">它不应尝试再次引发该事件在大多数情况下。</span><span class="sxs-lookup"><span data-stu-id="f4180-1034">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="f4180-1035">通过重写此方法或通过注册类处理程序替换<xref:System.Windows.EventManager.RegisterClassHandler%2A>，派生类的<xref:System.Windows.ContentElement>为由事件路由收到事件时，可以调用私有类处理程序方法。</span><span class="sxs-lookup"><span data-stu-id="f4180-1035">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="f4180-1036">类处理是相应的一种方案是操作事件数据并将路由的事件标记为已处理。</span><span class="sxs-lookup"><span data-stu-id="f4180-1036">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.Drop" />
      </Docs>
    </Member>
    <Member MemberName="OnGiveFeedback">
      <MemberSignature Language="C#" Value="protected internal virtual void OnGiveFeedback (System.Windows.GiveFeedbackEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnGiveFeedback(class System.Windows.GiveFeedbackEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnGiveFeedback(System.Windows.GiveFeedbackEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnGiveFeedback (e As GiveFeedbackEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnGiveFeedback(System::Windows::GiveFeedbackEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnGiveFeedback : System.Windows.GiveFeedbackEventArgs -&gt; unit&#xA;override this.OnGiveFeedback : System.Windows.GiveFeedbackEventArgs -&gt; unit" Usage="contentElement.OnGiveFeedback e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.GiveFeedbackEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="f4180-1037">包含事件数据的 <see cref="T:System.Windows.GiveFeedbackEventArgs" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-1037">The <see cref="T:System.Windows.GiveFeedbackEventArgs" /> that contains the event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f4180-1038">当某个未处理的 <see cref="E:System.Windows.DragDrop.GiveFeedback" /> 附加事件在其路由中到达派生自此类的某个元素时调用。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-1038">Invoked when an unhandled <see cref="E:System.Windows.DragDrop.GiveFeedback" /> attached event reaches an element in its route that is derived from this class.</span>
          </span>
          <span data-ttu-id="f4180-1039">实现此方法可为此事件添加类处理。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-1039">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4180-1040">此方法具有默认实现。</span><span class="sxs-lookup"><span data-stu-id="f4180-1040">This method has no default implementation.</span></span> <span data-ttu-id="f4180-1041">因为中间类继承中的可能会实现此方法，我们建议在实现中调用基实现。</span><span class="sxs-lookup"><span data-stu-id="f4180-1041">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="f4180-1042">此方法的用途是类似于[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]事件模式 On \* 方法： 此方法提供了通过建立类处理程序而不是实例处理程序来处理从派生类的匹配事件的方法。</span><span class="sxs-lookup"><span data-stu-id="f4180-1042">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="f4180-1043">在这种情况下匹配事件是路由的事件。</span><span class="sxs-lookup"><span data-stu-id="f4180-1043">In this case the matching event is a routed event.</span></span> <span data-ttu-id="f4180-1044">On \* 方法的实现模式是不同的路由事件，因为可以由子元素，它不一定是将调用处理程序的元素引发路由的事件。</span><span class="sxs-lookup"><span data-stu-id="f4180-1044">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="f4180-1045">因此，您的实现需要检查的事件数据源属性。</span><span class="sxs-lookup"><span data-stu-id="f4180-1045">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="f4180-1046">它不应尝试再次引发该事件在大多数情况下。</span><span class="sxs-lookup"><span data-stu-id="f4180-1046">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="f4180-1047">通过重写此方法或通过注册类处理程序替换<xref:System.Windows.EventManager.RegisterClassHandler%2A>，派生类的<xref:System.Windows.ContentElement>为由事件路由收到事件时，可以调用私有类处理程序方法。</span><span class="sxs-lookup"><span data-stu-id="f4180-1047">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="f4180-1048">类处理是相应的一种方案是操作事件数据并将路由的事件标记为已处理。</span><span class="sxs-lookup"><span data-stu-id="f4180-1048">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.GiveFeedback" />
      </Docs>
    </Member>
    <Member MemberName="OnGotFocus">
      <MemberSignature Language="C#" Value="protected virtual void OnGotFocus (System.Windows.RoutedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnGotFocus(class System.Windows.RoutedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnGotFocus(System.Windows.RoutedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnGotFocus (e As RoutedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnGotFocus(System::Windows::RoutedEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnGotFocus : System.Windows.RoutedEventArgs -&gt; unit&#xA;override this.OnGotFocus : System.Windows.RoutedEventArgs -&gt; unit" Usage="contentElement.OnGotFocus e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.RoutedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="f4180-1049">包含事件数据的 <see cref="T:System.Windows.RoutedEventArgs" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-1049">A <see cref="T:System.Windows.RoutedEventArgs" /> that contains event data.</span>
          </span>
          <span data-ttu-id="f4180-1050">此事件数据必须包含 <see cref="E:System.Windows.ContentElement.GotFocus" /> 事件的标识符。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-1050">This event data must contain the identifier for the <see cref="E:System.Windows.ContentElement.GotFocus" /> event.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f4180-1051">使用所提供的事件数据引发 <see cref="E:System.Windows.ContentElement.GotFocus" /> 路由事件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-1051">Raises the <see cref="E:System.Windows.ContentElement.GotFocus" /> routed event by using the event data provided.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4180-1052">此方法，尽管虚拟的但有一个默认实现，引发事件。</span><span class="sxs-lookup"><span data-stu-id="f4180-1052">This method, although virtual, does have a default implementation that raises the event.</span></span>  
  
 <span data-ttu-id="f4180-1053">这在 \* 方法实现用于引发事件，并在内部调用此方法的实现来引发事件时<xref:System.Windows.ContentElement.IsFocused%2A>属性值发生更改。</span><span class="sxs-lookup"><span data-stu-id="f4180-1053">This On\* method implementation is intended to raise the event, and this same method implementation is invoked internally to raise the event when the <xref:System.Windows.ContentElement.IsFocused%2A> property value changes.</span></span> <span data-ttu-id="f4180-1054"><xref:System.Windows.ContentElement.OnGotFocus%2A>实现不同于其他某些[!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)]上 \* 实现，后者仅提供了方便地为该事件添加类处理。</span><span class="sxs-lookup"><span data-stu-id="f4180-1054">The <xref:System.Windows.ContentElement.OnGotFocus%2A> implementation differs from some other [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] On\* implementations, which only provide a convenient way to add class handling for that event.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <span data-ttu-id="f4180-1055">除非你有有意或不寻常的需求不引发焦点事件，请确保您的实现将调用基实现。</span>
            <span class="sxs-lookup">
              <span data-stu-id="f4180-1055">Unless you have a deliberate and unusual need to not raise the focus events, make sure that your implementation calls the base implementation.</span>
            </span>
            <span data-ttu-id="f4180-1056">否则为<see cref="E:System.Windows.ContentElement.GotFocus" />通常将焦点设置到此元素的典型用户操作中不引发事件。</span>
            <span class="sxs-lookup">
              <span data-stu-id="f4180-1056">Otherwise, the <see cref="E:System.Windows.ContentElement.GotFocus" /> event is not raised during typical user operations that ordinarily set focus to this element.</span>
            </span>
            <span data-ttu-id="f4180-1057">如果不想您可获得焦点的元素，您可以通过将阻止元素<see cref="P:System.Windows.ContentElement.Focusable" />到<see langword="false" />。</span>
            <span class="sxs-lookup">
              <span data-stu-id="f4180-1057">If you do not intend your element to be focusable, you can prevent the element from being focusable by setting <see cref="P:System.Windows.ContentElement.Focusable" /> to <see langword="false" />.</span>
            </span>
            <span data-ttu-id="f4180-1058">请注意，默认情况下<see cref="P:System.Windows.ContentElement.Focusable" />不是可获得焦点，因此设置<see cref="P:System.Windows.ContentElement.Focusable" />有意不可能有必要。</span>
            <span class="sxs-lookup">
              <span data-stu-id="f4180-1058">Note that by default a <see cref="P:System.Windows.ContentElement.Focusable" /> is not focusable, therefore setting <see cref="P:System.Windows.ContentElement.Focusable" /> deliberately might not be necessary.</span>
            </span>
          </para>
        </block>
        <altmember cref="P:System.Windows.ContentElement.Focusable" />
        <altmember cref="E:System.Windows.ContentElement.GotFocus" />
      </Docs>
    </Member>
    <Member MemberName="OnGotKeyboardFocus">
      <MemberSignature Language="C#" Value="protected internal virtual void OnGotKeyboardFocus (System.Windows.Input.KeyboardFocusChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnGotKeyboardFocus(class System.Windows.Input.KeyboardFocusChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnGotKeyboardFocus(System.Windows.Input.KeyboardFocusChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnGotKeyboardFocus (e As KeyboardFocusChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnGotKeyboardFocus(System::Windows::Input::KeyboardFocusChangedEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnGotKeyboardFocus : System.Windows.Input.KeyboardFocusChangedEventArgs -&gt; unit&#xA;override this.OnGotKeyboardFocus : System.Windows.Input.KeyboardFocusChangedEventArgs -&gt; unit" Usage="contentElement.OnGotKeyboardFocus e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.KeyboardFocusChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="f4180-1059">包含事件数据的 <see cref="T:System.Windows.Input.KeyboardFocusChangedEventArgs" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-1059">The <see cref="T:System.Windows.Input.KeyboardFocusChangedEventArgs" /> that contains the event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f4180-1060">当某个未处理的 <see cref="E:System.Windows.Input.Keyboard.GotKeyboardFocus" /> 附加事件在其路由中到达派生自此类的某个元素时调用。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-1060">Invoked when an unhandled <see cref="E:System.Windows.Input.Keyboard.GotKeyboardFocus" /> attached event reaches an element in its route that is derived from this class.</span>
          </span>
          <span data-ttu-id="f4180-1061">实现此方法可为此事件添加类处理。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-1061">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4180-1062">此方法具有默认实现。</span><span class="sxs-lookup"><span data-stu-id="f4180-1062">This method has no default implementation.</span></span> <span data-ttu-id="f4180-1063">因为中间类继承中的可能会实现此方法，我们建议在实现中调用基实现。</span><span class="sxs-lookup"><span data-stu-id="f4180-1063">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="f4180-1064">此方法的用途是类似于[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]事件模式 On \* 方法： 此方法提供了通过建立类处理程序而不是实例处理程序来处理从派生类的匹配事件的方法。</span><span class="sxs-lookup"><span data-stu-id="f4180-1064">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="f4180-1065">在这种情况下匹配事件是路由的事件。</span><span class="sxs-lookup"><span data-stu-id="f4180-1065">In this case the matching event is a routed event.</span></span> <span data-ttu-id="f4180-1066">On \* 方法的实现模式是不同的路由事件，因为可以由子元素，它不一定是将调用处理程序的元素引发路由的事件。</span><span class="sxs-lookup"><span data-stu-id="f4180-1066">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="f4180-1067">因此，您的实现需要检查的事件数据源属性。</span><span class="sxs-lookup"><span data-stu-id="f4180-1067">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="f4180-1068">它不应尝试再次引发该事件在大多数情况下。</span><span class="sxs-lookup"><span data-stu-id="f4180-1068">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="f4180-1069">通过重写此方法或通过注册类处理程序替换<xref:System.Windows.EventManager.RegisterClassHandler%2A>，派生类的<xref:System.Windows.ContentElement>为由事件路由收到事件时，可以调用私有类处理程序方法。</span><span class="sxs-lookup"><span data-stu-id="f4180-1069">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="f4180-1070">类处理是相应的一种方案是操作事件数据并将路由的事件标记为已处理。</span><span class="sxs-lookup"><span data-stu-id="f4180-1070">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.GotKeyboardFocus" />
      </Docs>
    </Member>
    <Member MemberName="OnGotMouseCapture">
      <MemberSignature Language="C#" Value="protected internal virtual void OnGotMouseCapture (System.Windows.Input.MouseEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnGotMouseCapture(class System.Windows.Input.MouseEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnGotMouseCapture(System.Windows.Input.MouseEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnGotMouseCapture (e As MouseEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnGotMouseCapture(System::Windows::Input::MouseEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnGotMouseCapture : System.Windows.Input.MouseEventArgs -&gt; unit&#xA;override this.OnGotMouseCapture : System.Windows.Input.MouseEventArgs -&gt; unit" Usage="contentElement.OnGotMouseCapture e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="f4180-1071">包含事件数据的 <see cref="T:System.Windows.Input.MouseEventArgs" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-1071">The <see cref="T:System.Windows.Input.MouseEventArgs" /> that contains the event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f4180-1072">当某个未处理的 <see cref="E:System.Windows.Input.Mouse.GotMouseCapture" /> 附加事件在其路由中到达派生自此类的某个元素时调用。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-1072">Invoked when an unhandled <see cref="E:System.Windows.Input.Mouse.GotMouseCapture" /> attached event reaches an element in its route that is derived from this class.</span>
          </span>
          <span data-ttu-id="f4180-1073">实现此方法可为此事件添加类处理。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-1073">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4180-1074">此方法具有默认实现。</span><span class="sxs-lookup"><span data-stu-id="f4180-1074">This method has no default implementation.</span></span> <span data-ttu-id="f4180-1075">因为中间类继承中的可能会实现此方法，我们建议在实现中调用基实现。</span><span class="sxs-lookup"><span data-stu-id="f4180-1075">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="f4180-1076">此方法的用途是类似于[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]事件模式 On \* 方法： 此方法提供了通过建立类处理程序而不是实例处理程序来处理从派生类的匹配事件的方法。</span><span class="sxs-lookup"><span data-stu-id="f4180-1076">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="f4180-1077">在这种情况下匹配事件是路由的事件。</span><span class="sxs-lookup"><span data-stu-id="f4180-1077">In this case the matching event is a routed event.</span></span> <span data-ttu-id="f4180-1078">On \* 方法的实现模式是不同的路由事件，因为可以由子元素，它不一定是将调用处理程序的元素引发路由的事件。</span><span class="sxs-lookup"><span data-stu-id="f4180-1078">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="f4180-1079">因此，您的实现需要检查的事件数据源属性。</span><span class="sxs-lookup"><span data-stu-id="f4180-1079">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="f4180-1080">它不应尝试再次引发该事件在大多数情况下。</span><span class="sxs-lookup"><span data-stu-id="f4180-1080">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="f4180-1081">通过重写此方法或通过注册类处理程序替换<xref:System.Windows.EventManager.RegisterClassHandler%2A>，派生类的<xref:System.Windows.ContentElement>为由事件路由收到事件时，可以调用私有类处理程序方法。</span><span class="sxs-lookup"><span data-stu-id="f4180-1081">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="f4180-1082">类处理是相应的一种方案是操作事件数据并将路由的事件标记为已处理。</span><span class="sxs-lookup"><span data-stu-id="f4180-1082">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.GotMouseCapture" />
      </Docs>
    </Member>
    <Member MemberName="OnGotStylusCapture">
      <MemberSignature Language="C#" Value="protected internal virtual void OnGotStylusCapture (System.Windows.Input.StylusEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnGotStylusCapture(class System.Windows.Input.StylusEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnGotStylusCapture(System.Windows.Input.StylusEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnGotStylusCapture (e As StylusEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnGotStylusCapture(System::Windows::Input::StylusEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnGotStylusCapture : System.Windows.Input.StylusEventArgs -&gt; unit&#xA;override this.OnGotStylusCapture : System.Windows.Input.StylusEventArgs -&gt; unit" Usage="contentElement.OnGotStylusCapture e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="f4180-1083">包含事件数据的 <see cref="T:System.Windows.Input.StylusEventArgs" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-1083">The <see cref="T:System.Windows.Input.StylusEventArgs" /> that contains the event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f4180-1084">当某个未处理的 <see cref="E:System.Windows.Input.Stylus.GotStylusCapture" /> 附加事件在其路由中到达派生自此类的某个元素时调用。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-1084">Invoked when an unhandled <see cref="E:System.Windows.Input.Stylus.GotStylusCapture" /> attached event reaches an element in its route that is derived from this class.</span>
          </span>
          <span data-ttu-id="f4180-1085">实现此方法可为此事件添加类处理。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-1085">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4180-1086">此方法具有默认实现。</span><span class="sxs-lookup"><span data-stu-id="f4180-1086">This method has no default implementation.</span></span> <span data-ttu-id="f4180-1087">因为中间类继承中的可能会实现此方法，我们建议在实现中调用基实现。</span><span class="sxs-lookup"><span data-stu-id="f4180-1087">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="f4180-1088">此方法的用途是类似于[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]事件模式 On \* 方法： 此方法提供了通过建立类处理程序而不是实例处理程序来处理从派生类的匹配事件的方法。</span><span class="sxs-lookup"><span data-stu-id="f4180-1088">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="f4180-1089">在这种情况下匹配事件是路由的事件。</span><span class="sxs-lookup"><span data-stu-id="f4180-1089">In this case the matching event is a routed event.</span></span> <span data-ttu-id="f4180-1090">On \* 方法的实现模式是不同的路由事件，因为可以由子元素，它不一定是将调用处理程序的元素引发路由的事件。</span><span class="sxs-lookup"><span data-stu-id="f4180-1090">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="f4180-1091">因此，您的实现需要检查的事件数据源属性。</span><span class="sxs-lookup"><span data-stu-id="f4180-1091">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="f4180-1092">它不应尝试再次引发该事件在大多数情况下。</span><span class="sxs-lookup"><span data-stu-id="f4180-1092">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="f4180-1093">通过重写此方法或通过注册类处理程序替换<xref:System.Windows.EventManager.RegisterClassHandler%2A>，派生类的<xref:System.Windows.ContentElement>为由事件路由收到事件时，可以调用私有类处理程序方法。</span><span class="sxs-lookup"><span data-stu-id="f4180-1093">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="f4180-1094">类处理是相应的一种方案是操作事件数据并将路由的事件标记为已处理。</span><span class="sxs-lookup"><span data-stu-id="f4180-1094">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.GotStylusCapture" />
      </Docs>
    </Member>
    <Member MemberName="OnGotTouchCapture">
      <MemberSignature Language="C#" Value="protected internal virtual void OnGotTouchCapture (System.Windows.Input.TouchEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnGotTouchCapture(class System.Windows.Input.TouchEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnGotTouchCapture(System.Windows.Input.TouchEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnGotTouchCapture (e As TouchEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnGotTouchCapture(System::Windows::Input::TouchEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnGotTouchCapture : System.Windows.Input.TouchEventArgs -&gt; unit&#xA;override this.OnGotTouchCapture : System.Windows.Input.TouchEventArgs -&gt; unit" Usage="contentElement.OnGotTouchCapture e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.TouchEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="f4180-1095">包含事件数据的 <see cref="T:System.Windows.Input.TouchEventArgs" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-1095">A <see cref="T:System.Windows.Input.TouchEventArgs" /> that contains the event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f4180-1096">为在此元素上捕获触摸屏输入时发生的 <see cref="E:System.Windows.ContentElement.GotTouchCapture" /> 路由事件提供类处理。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-1096">Provides class handling for the <see cref="E:System.Windows.ContentElement.GotTouchCapture" /> routed event that occurs when a touch is captured to this element.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4180-1097"><xref:System.Windows.ContentElement.OnGotTouchCapture%2A>方法具有默认实现。</span><span class="sxs-lookup"><span data-stu-id="f4180-1097">The <xref:System.Windows.ContentElement.OnGotTouchCapture%2A> method has no default implementation.</span></span> <span data-ttu-id="f4180-1098">重写<xref:System.Windows.ContentElement.OnGotTouchCapture%2A>中派生的类来处理<xref:System.Windows.ContentElement.GotTouchCapture>事件。</span><span class="sxs-lookup"><span data-stu-id="f4180-1098">Override <xref:System.Windows.ContentElement.OnGotTouchCapture%2A> in a derived class to handle the <xref:System.Windows.ContentElement.GotTouchCapture> event.</span></span> <span data-ttu-id="f4180-1099">请务必调用基类的<xref:System.Windows.ContentElement.OnGotTouchCapture%2A>方法，从而基本类接收事件。</span><span class="sxs-lookup"><span data-stu-id="f4180-1099">Be sure to call the base class’s <xref:System.Windows.ContentElement.OnGotTouchCapture%2A> method so that base classes receive the event.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnIsKeyboardFocusedChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnIsKeyboardFocusedChanged (System.Windows.DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnIsKeyboardFocusedChanged(valuetype System.Windows.DependencyPropertyChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnIsKeyboardFocusedChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnIsKeyboardFocusedChanged (e As DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnIsKeyboardFocusedChanged(System::Windows::DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="F#" Value="abstract member OnIsKeyboardFocusedChanged : System.Windows.DependencyPropertyChangedEventArgs -&gt; unit&#xA;override this.OnIsKeyboardFocusedChanged : System.Windows.DependencyPropertyChangedEventArgs -&gt; unit" Usage="contentElement.OnIsKeyboardFocusedChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DependencyPropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="f4180-1100">包含事件数据的 <see cref="T:System.Windows.DependencyPropertyChangedEventArgs" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-1100">The <see cref="T:System.Windows.DependencyPropertyChangedEventArgs" /> that contains the event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f4180-1101">在此元素上引发未处理的 <see cref="E:System.Windows.ContentElement.IsKeyboardFocusedChanged" /> 事件时，调用此方法。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-1101">Invoked when an unhandled <see cref="E:System.Windows.ContentElement.IsKeyboardFocusedChanged" /> event is raised on this element.</span>
          </span>
          <span data-ttu-id="f4180-1102">实现此方法可为此事件添加类处理。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-1102">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4180-1103">此虚方法引发时的值<xref:System.Windows.ContentElement.IsKeyboardFocused%2A>依赖关系属性更改。</span><span class="sxs-lookup"><span data-stu-id="f4180-1103">This virtual method is raised when the value of the <xref:System.Windows.ContentElement.IsKeyboardFocused%2A> dependency property changes.</span></span> <span data-ttu-id="f4180-1104">虚拟方法首先引发，并可以处理在必要时的事件数据。</span><span class="sxs-lookup"><span data-stu-id="f4180-1104">The virtual method is raised first and can manipulate the event data as necessary.</span></span> <span data-ttu-id="f4180-1105">然后<xref:System.Windows.ContentElement.IsKeyboardFocusedChanged>与该相同的事件数据实例引发事件。</span><span class="sxs-lookup"><span data-stu-id="f4180-1105">Then the <xref:System.Windows.ContentElement.IsKeyboardFocusedChanged> event is raised with that same event data instance.</span></span> <span data-ttu-id="f4180-1106">请注意，<xref:System.Windows.ContentElement.IsKeyboardFocusedChanged>事件不是路由的事件。</span><span class="sxs-lookup"><span data-stu-id="f4180-1106">Notice that the  <xref:System.Windows.ContentElement.IsKeyboardFocusedChanged> event is not a routed event.</span></span> <span data-ttu-id="f4180-1107">因此，您不能将其标记为已处理的类处理程序中。</span><span class="sxs-lookup"><span data-stu-id="f4180-1107">Therefore, you cannot mark it as handled in the class handler.</span></span>  
  
 <span data-ttu-id="f4180-1108">此方法具有默认实现。</span><span class="sxs-lookup"><span data-stu-id="f4180-1108">This method has no default implementation.</span></span> <span data-ttu-id="f4180-1109">因为中间类继承中的可能会实现此方法，我们建议在实现中调用基实现。</span><span class="sxs-lookup"><span data-stu-id="f4180-1109">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span> <span data-ttu-id="f4180-1110">您可以调用基之前或之后应用特殊处理，具体取决于您的要求。</span><span class="sxs-lookup"><span data-stu-id="f4180-1110">You may call base either before or after your special handling, depending on your requirements.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnIsKeyboardFocusWithinChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnIsKeyboardFocusWithinChanged (System.Windows.DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnIsKeyboardFocusWithinChanged(valuetype System.Windows.DependencyPropertyChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnIsKeyboardFocusWithinChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnIsKeyboardFocusWithinChanged (e As DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnIsKeyboardFocusWithinChanged(System::Windows::DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="F#" Value="abstract member OnIsKeyboardFocusWithinChanged : System.Windows.DependencyPropertyChangedEventArgs -&gt; unit&#xA;override this.OnIsKeyboardFocusWithinChanged : System.Windows.DependencyPropertyChangedEventArgs -&gt; unit" Usage="contentElement.OnIsKeyboardFocusWithinChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DependencyPropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="f4180-1111">包含事件数据的 <see cref="T:System.Windows.DependencyPropertyChangedEventArgs" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-1111">A <see cref="T:System.Windows.DependencyPropertyChangedEventArgs" /> that contains the event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f4180-1112">在此元素引发 <see cref="E:System.Windows.ContentElement.IsKeyboardFocusWithinChanged" /> 事件前的那一刻调用此方法。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-1112">Invoked just before the <see cref="E:System.Windows.ContentElement.IsKeyboardFocusWithinChanged" /> event is raised by this element.</span>
          </span>
          <span data-ttu-id="f4180-1113">实现此方法可为此事件添加类处理。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-1113">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4180-1114">此虚方法引发时的值<xref:System.Windows.ContentElement.IsKeyboardFocusWithin%2A>依赖项属性更改其值。</span><span class="sxs-lookup"><span data-stu-id="f4180-1114">This virtual method is raised when the value of the <xref:System.Windows.ContentElement.IsKeyboardFocusWithin%2A> dependency property changes its value.</span></span> <span data-ttu-id="f4180-1115">虚拟方法首先引发，并可以处理在必要时的事件数据。</span><span class="sxs-lookup"><span data-stu-id="f4180-1115">The virtual method is raised first and can manipulate the event data as necessary.</span></span> <span data-ttu-id="f4180-1116">然后<xref:System.Windows.ContentElement.IsKeyboardFocusWithinChanged>与该相同的事件数据实例引发事件。</span><span class="sxs-lookup"><span data-stu-id="f4180-1116">Then the <xref:System.Windows.ContentElement.IsKeyboardFocusWithinChanged> event is raised with that same event data instance.</span></span> <span data-ttu-id="f4180-1117">请注意，<xref:System.Windows.ContentElement.IsKeyboardFocusWithinChanged>事件不是路由的事件。</span><span class="sxs-lookup"><span data-stu-id="f4180-1117">Notice that the <xref:System.Windows.ContentElement.IsKeyboardFocusWithinChanged> event is not a routed event.</span></span> <span data-ttu-id="f4180-1118">因此，您不能将其标记为已处理的类处理程序中。</span><span class="sxs-lookup"><span data-stu-id="f4180-1118">Therefore, you cannot mark it as handled in the class handler.</span></span>  
  
 <span data-ttu-id="f4180-1119">此方法具有默认实现。</span><span class="sxs-lookup"><span data-stu-id="f4180-1119">This method has no default implementation.</span></span> <span data-ttu-id="f4180-1120">因为中间类继承中的可能会实现此方法，我们建议在实现中调用基实现。</span><span class="sxs-lookup"><span data-stu-id="f4180-1120">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span> <span data-ttu-id="f4180-1121">您可以调用基之前或之后应用特殊处理，具体取决于您的要求。</span><span class="sxs-lookup"><span data-stu-id="f4180-1121">You may call base either before or after your special handling, depending on your requirements.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnIsMouseCapturedChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnIsMouseCapturedChanged (System.Windows.DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnIsMouseCapturedChanged(valuetype System.Windows.DependencyPropertyChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnIsMouseCapturedChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnIsMouseCapturedChanged (e As DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnIsMouseCapturedChanged(System::Windows::DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="F#" Value="abstract member OnIsMouseCapturedChanged : System.Windows.DependencyPropertyChangedEventArgs -&gt; unit&#xA;override this.OnIsMouseCapturedChanged : System.Windows.DependencyPropertyChangedEventArgs -&gt; unit" Usage="contentElement.OnIsMouseCapturedChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DependencyPropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="f4180-1122">包含事件数据的 <see cref="T:System.Windows.DependencyPropertyChangedEventArgs" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-1122">The <see cref="T:System.Windows.DependencyPropertyChangedEventArgs" /> that contains the event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f4180-1123">在此元素上引发未处理的 <see cref="E:System.Windows.ContentElement.IsMouseCapturedChanged" /> 事件时，调用此方法。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-1123">Invoked when an unhandled <see cref="E:System.Windows.ContentElement.IsMouseCapturedChanged" /> event is raised on this element.</span>
          </span>
          <span data-ttu-id="f4180-1124">实现此方法可为此事件添加类处理。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-1124">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4180-1125">此虚方法引发时的值<xref:System.Windows.ContentElement.IsMouseCaptured%2A>依赖项属性更改其值。</span><span class="sxs-lookup"><span data-stu-id="f4180-1125">This virtual method is raised when the value of the <xref:System.Windows.ContentElement.IsMouseCaptured%2A> dependency property changes its value.</span></span> <span data-ttu-id="f4180-1126">虚拟方法首先引发，并可以处理在必要时的事件数据。</span><span class="sxs-lookup"><span data-stu-id="f4180-1126">The virtual method is raised first and can manipulate the event data as necessary.</span></span> <span data-ttu-id="f4180-1127">然后<xref:System.Windows.ContentElement.IsMouseCapturedChanged>与该相同的事件数据实例引发事件。</span><span class="sxs-lookup"><span data-stu-id="f4180-1127">Then the <xref:System.Windows.ContentElement.IsMouseCapturedChanged> event is raised with that same event data instance.</span></span> <span data-ttu-id="f4180-1128">请注意，<xref:System.Windows.ContentElement.IsMouseCapturedChanged>事件不是路由的事件。</span><span class="sxs-lookup"><span data-stu-id="f4180-1128">Notice that the <xref:System.Windows.ContentElement.IsMouseCapturedChanged> event is not a routed event.</span></span> <span data-ttu-id="f4180-1129">因此，您不能将其标记为已处理的类处理程序中。</span><span class="sxs-lookup"><span data-stu-id="f4180-1129">Therefore, you cannot mark it as handled in the class handler.</span></span>  
  
 <span data-ttu-id="f4180-1130">此方法具有默认实现。</span><span class="sxs-lookup"><span data-stu-id="f4180-1130">This method has no default implementation.</span></span> <span data-ttu-id="f4180-1131">因为中间类继承中的可能会实现此方法，我们建议在实现中调用基实现。</span><span class="sxs-lookup"><span data-stu-id="f4180-1131">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span> <span data-ttu-id="f4180-1132">您可以调用基之前或之后应用特殊处理，具体取决于您的要求。</span><span class="sxs-lookup"><span data-stu-id="f4180-1132">You may call base either before or after your special handling, depending on your requirements.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnIsMouseCaptureWithinChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnIsMouseCaptureWithinChanged (System.Windows.DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnIsMouseCaptureWithinChanged(valuetype System.Windows.DependencyPropertyChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnIsMouseCaptureWithinChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnIsMouseCaptureWithinChanged (e As DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnIsMouseCaptureWithinChanged(System::Windows::DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="F#" Value="abstract member OnIsMouseCaptureWithinChanged : System.Windows.DependencyPropertyChangedEventArgs -&gt; unit&#xA;override this.OnIsMouseCaptureWithinChanged : System.Windows.DependencyPropertyChangedEventArgs -&gt; unit" Usage="contentElement.OnIsMouseCaptureWithinChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DependencyPropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="f4180-1133">包含事件数据的 <see cref="T:System.Windows.DependencyPropertyChangedEventArgs" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-1133">A <see cref="T:System.Windows.DependencyPropertyChangedEventArgs" /> that contains the event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f4180-1134">在此元素上引发未处理的 <see cref="E:System.Windows.ContentElement.IsMouseCaptureWithinChanged" /> 事件时，调用此方法。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-1134">Invoked when an unhandled <see cref="E:System.Windows.ContentElement.IsMouseCaptureWithinChanged" /> event is raised on this element.</span>
          </span>
          <span data-ttu-id="f4180-1135">实现此方法可为此事件添加类处理。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-1135">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides">
          <para>
            <span data-ttu-id="f4180-1136">此虚方法引发时的值<see cref="P:System.Windows.ContentElement.IsMouseCaptureWithin" />依赖项属性更改其值。</span>
            <span class="sxs-lookup">
              <span data-stu-id="f4180-1136">This virtual method is raised when the value of the <see cref="P:System.Windows.ContentElement.IsMouseCaptureWithin" /> dependency property changes its value.</span>
            </span>
            <span data-ttu-id="f4180-1137">虚拟方法首先引发，并可以处理在必要时的事件数据。</span>
            <span class="sxs-lookup">
              <span data-stu-id="f4180-1137">The virtual method is raised first and can manipulate the event data as necessary.</span>
            </span>
            <span data-ttu-id="f4180-1138">然后<see cref="E:System.Windows.ContentElement.IsMouseCaptureWithinChanged" />与该相同的事件数据实例引发事件。</span>
            <span class="sxs-lookup">
              <span data-stu-id="f4180-1138">Then the <see cref="E:System.Windows.ContentElement.IsMouseCaptureWithinChanged" /> event is raised with that same event data instance.</span>
            </span>
            <span data-ttu-id="f4180-1139">请注意，事件不是路由的事件。因此，您不能将其标记为已处理的类处理程序中。</span>
            <span class="sxs-lookup">
              <span data-stu-id="f4180-1139">Notice that the event is not a routed event; Therefore,  you cannot mark it as handled in the class handler.</span>
            </span>
            <span data-ttu-id="f4180-1140">此方法具有默认实现。</span>
            <span class="sxs-lookup">
              <span data-stu-id="f4180-1140">This method has no default implementation.</span>
            </span>
            <span data-ttu-id="f4180-1141">因为中间类继承中的可能会实现此方法，我们建议在实现中调用基实现。</span>
            <span class="sxs-lookup">
              <span data-stu-id="f4180-1141">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span>
            </span>
            <span data-ttu-id="f4180-1142">您可以调用基之前或之后应用特殊处理，具体取决于您的要求。</span>
            <span class="sxs-lookup">
              <span data-stu-id="f4180-1142">You may call base either before or after your special handling, depending on your requirements.</span>
            </span>
          </para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnIsMouseDirectlyOverChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnIsMouseDirectlyOverChanged (System.Windows.DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnIsMouseDirectlyOverChanged(valuetype System.Windows.DependencyPropertyChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnIsMouseDirectlyOverChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnIsMouseDirectlyOverChanged (e As DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnIsMouseDirectlyOverChanged(System::Windows::DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="F#" Value="abstract member OnIsMouseDirectlyOverChanged : System.Windows.DependencyPropertyChangedEventArgs -&gt; unit&#xA;override this.OnIsMouseDirectlyOverChanged : System.Windows.DependencyPropertyChangedEventArgs -&gt; unit" Usage="contentElement.OnIsMouseDirectlyOverChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DependencyPropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="f4180-1143">包含事件数据的 <see cref="T:System.Windows.DependencyPropertyChangedEventArgs" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-1143">The <see cref="T:System.Windows.DependencyPropertyChangedEventArgs" /> that contains the event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f4180-1144">在此元素上引发未处理的 <see cref="E:System.Windows.ContentElement.IsMouseDirectlyOverChanged" /> 事件时，调用此方法。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-1144">Invoked when an unhandled <see cref="E:System.Windows.ContentElement.IsMouseDirectlyOverChanged" /> event is raised on this element.</span>
          </span>
          <span data-ttu-id="f4180-1145">实现此方法可为此事件添加类处理。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-1145">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4180-1146">此虚方法引发时的值<xref:System.Windows.ContentElement.IsMouseDirectlyOver%2A>依赖项属性更改其值。</span><span class="sxs-lookup"><span data-stu-id="f4180-1146">This virtual method is raised when the value of the <xref:System.Windows.ContentElement.IsMouseDirectlyOver%2A> dependency property changes its value.</span></span> <span data-ttu-id="f4180-1147">虚拟方法首先引发，并可以处理在必要时的事件数据。</span><span class="sxs-lookup"><span data-stu-id="f4180-1147">The virtual method is raised first and can manipulate the event data as necessary.</span></span> <span data-ttu-id="f4180-1148">然后<xref:System.Windows.ContentElement.IsMouseDirectlyOverChanged>与该相同的事件数据实例引发事件。</span><span class="sxs-lookup"><span data-stu-id="f4180-1148">Then the <xref:System.Windows.ContentElement.IsMouseDirectlyOverChanged> event is raised with that same event data instance.</span></span> <span data-ttu-id="f4180-1149">请注意，<xref:System.Windows.ContentElement.IsMouseDirectlyOverChanged>事件不是路由的事件。</span><span class="sxs-lookup"><span data-stu-id="f4180-1149">Notice that the <xref:System.Windows.ContentElement.IsMouseDirectlyOverChanged> event is not a routed event.</span></span> <span data-ttu-id="f4180-1150">因此，您不能将其标记为已处理的类处理程序中。</span><span class="sxs-lookup"><span data-stu-id="f4180-1150">Therefore, you cannot mark it as handled in the class handler.</span></span>  
  
 <span data-ttu-id="f4180-1151">此方法具有默认实现。</span><span class="sxs-lookup"><span data-stu-id="f4180-1151">This method has no default implementation.</span></span> <span data-ttu-id="f4180-1152">因为中间类继承中的可能会实现此方法，我们建议在实现中调用基实现。</span><span class="sxs-lookup"><span data-stu-id="f4180-1152">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span> <span data-ttu-id="f4180-1153">您可以调用基之前或之后应用特殊处理，具体取决于您的要求。</span><span class="sxs-lookup"><span data-stu-id="f4180-1153">You may call base either before or after your special handling, depending on your requirements.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnIsStylusCapturedChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnIsStylusCapturedChanged (System.Windows.DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnIsStylusCapturedChanged(valuetype System.Windows.DependencyPropertyChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnIsStylusCapturedChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnIsStylusCapturedChanged (e As DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnIsStylusCapturedChanged(System::Windows::DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="F#" Value="abstract member OnIsStylusCapturedChanged : System.Windows.DependencyPropertyChangedEventArgs -&gt; unit&#xA;override this.OnIsStylusCapturedChanged : System.Windows.DependencyPropertyChangedEventArgs -&gt; unit" Usage="contentElement.OnIsStylusCapturedChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DependencyPropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="f4180-1154">包含事件数据的 <see cref="T:System.Windows.DependencyPropertyChangedEventArgs" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-1154">A <see cref="T:System.Windows.DependencyPropertyChangedEventArgs" /> that contains the event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f4180-1155">在此元素上引发未处理的 <see cref="E:System.Windows.ContentElement.IsStylusCapturedChanged" /> 事件时，调用此方法。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-1155">Invoked when an unhandled <see cref="E:System.Windows.ContentElement.IsStylusCapturedChanged" /> event is raised on this element.</span>
          </span>
          <span data-ttu-id="f4180-1156">实现此方法可为此事件添加类处理。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-1156">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4180-1157">此虚方法引发时的值<xref:System.Windows.ContentElement.IsStylusCaptured%2A>依赖项属性更改其值。</span><span class="sxs-lookup"><span data-stu-id="f4180-1157">This virtual method is raised when the value of the <xref:System.Windows.ContentElement.IsStylusCaptured%2A> dependency property changes its value.</span></span> <span data-ttu-id="f4180-1158">虚拟方法首先引发，并可以处理在必要时的事件数据。</span><span class="sxs-lookup"><span data-stu-id="f4180-1158">The virtual method is raised first and can manipulate the event data as necessary.</span></span> <span data-ttu-id="f4180-1159">然后<xref:System.Windows.ContentElement.IsStylusCapturedChanged>与该相同的事件数据实例引发事件。</span><span class="sxs-lookup"><span data-stu-id="f4180-1159">Then the <xref:System.Windows.ContentElement.IsStylusCapturedChanged> event is raised with that same event data instance.</span></span> <span data-ttu-id="f4180-1160">请注意，该事件不是路由的事件。</span><span class="sxs-lookup"><span data-stu-id="f4180-1160">Notice that the event is not a routed event.</span></span> <span data-ttu-id="f4180-1161">因此，您不能将其标记为已处理的类处理程序中。</span><span class="sxs-lookup"><span data-stu-id="f4180-1161">Therefore, you cannot mark it as handled in the class handler.</span></span>  
  
 <span data-ttu-id="f4180-1162">此方法具有默认实现。</span><span class="sxs-lookup"><span data-stu-id="f4180-1162">This method has no default implementation.</span></span> <span data-ttu-id="f4180-1163">因为中间类继承中的可能会实现此方法，我们建议在实现中调用基实现。</span><span class="sxs-lookup"><span data-stu-id="f4180-1163">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span> <span data-ttu-id="f4180-1164">您可以调用基之前或之后应用特殊处理，具体取决于您的要求。</span><span class="sxs-lookup"><span data-stu-id="f4180-1164">You may call base either before or after your special handling, depending on your requirements.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnIsStylusCaptureWithinChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnIsStylusCaptureWithinChanged (System.Windows.DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnIsStylusCaptureWithinChanged(valuetype System.Windows.DependencyPropertyChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnIsStylusCaptureWithinChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnIsStylusCaptureWithinChanged (e As DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnIsStylusCaptureWithinChanged(System::Windows::DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="F#" Value="abstract member OnIsStylusCaptureWithinChanged : System.Windows.DependencyPropertyChangedEventArgs -&gt; unit&#xA;override this.OnIsStylusCaptureWithinChanged : System.Windows.DependencyPropertyChangedEventArgs -&gt; unit" Usage="contentElement.OnIsStylusCaptureWithinChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DependencyPropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="f4180-1165">包含事件数据的 <see cref="T:System.Windows.DependencyPropertyChangedEventArgs" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-1165">The <see cref="T:System.Windows.DependencyPropertyChangedEventArgs" /> that contains the event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f4180-1166">在此元素上引发未处理的 <see cref="E:System.Windows.ContentElement.IsStylusCaptureWithinChanged" /> 事件时，调用此方法。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-1166">Invoked when an unhandled <see cref="E:System.Windows.ContentElement.IsStylusCaptureWithinChanged" /> event is raised on this element.</span>
          </span>
          <span data-ttu-id="f4180-1167">实现此方法可为此事件添加类处理。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-1167">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4180-1168">此虚方法引发时的值<xref:System.Windows.ContentElement.IsStylusCaptureWithin%2A>依赖项属性更改其值。</span><span class="sxs-lookup"><span data-stu-id="f4180-1168">This virtual method is raised when the value of the <xref:System.Windows.ContentElement.IsStylusCaptureWithin%2A> dependency property changes its value.</span></span> <span data-ttu-id="f4180-1169">虚拟方法首先引发，并可以处理在必要时的事件数据。</span><span class="sxs-lookup"><span data-stu-id="f4180-1169">The virtual method is raised first and can manipulate the event data as necessary.</span></span> <span data-ttu-id="f4180-1170">然后<xref:System.Windows.ContentElement.IsStylusCaptureWithinChanged>与该相同的事件数据实例引发事件。</span><span class="sxs-lookup"><span data-stu-id="f4180-1170">Then the <xref:System.Windows.ContentElement.IsStylusCaptureWithinChanged> event is raised with that same event data instance.</span></span> <span data-ttu-id="f4180-1171">请注意，该事件不是路由的事件。</span><span class="sxs-lookup"><span data-stu-id="f4180-1171">Notice that the event is not a routed event.</span></span> <span data-ttu-id="f4180-1172">因此，您不能将其标记为已处理的类处理程序中。</span><span class="sxs-lookup"><span data-stu-id="f4180-1172">Therefore, you cannot mark it as handled in the class handler.</span></span>  
  
 <span data-ttu-id="f4180-1173">此方法具有默认实现。</span><span class="sxs-lookup"><span data-stu-id="f4180-1173">This method has no default implementation.</span></span> <span data-ttu-id="f4180-1174">因为中间类继承中的可能会实现此方法，我们建议在实现中调用基实现。</span><span class="sxs-lookup"><span data-stu-id="f4180-1174">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span> <span data-ttu-id="f4180-1175">您可以调用基之前或之后应用特殊处理，具体取决于您的要求。</span><span class="sxs-lookup"><span data-stu-id="f4180-1175">You may call base either before or after your special handling, depending on your requirements.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnIsStylusDirectlyOverChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnIsStylusDirectlyOverChanged (System.Windows.DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnIsStylusDirectlyOverChanged(valuetype System.Windows.DependencyPropertyChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnIsStylusDirectlyOverChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnIsStylusDirectlyOverChanged (e As DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnIsStylusDirectlyOverChanged(System::Windows::DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="F#" Value="abstract member OnIsStylusDirectlyOverChanged : System.Windows.DependencyPropertyChangedEventArgs -&gt; unit&#xA;override this.OnIsStylusDirectlyOverChanged : System.Windows.DependencyPropertyChangedEventArgs -&gt; unit" Usage="contentElement.OnIsStylusDirectlyOverChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DependencyPropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="f4180-1176">包含事件数据的 <see cref="T:System.Windows.DependencyPropertyChangedEventArgs" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-1176">The <see cref="T:System.Windows.DependencyPropertyChangedEventArgs" /> that contains the event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f4180-1177">在此元素上引发未处理的 <see cref="E:System.Windows.ContentElement.IsStylusDirectlyOverChanged" /> 事件时，调用此方法。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-1177">Invoked when an unhandled <see cref="E:System.Windows.ContentElement.IsStylusDirectlyOverChanged" /> event is raised on this element.</span>
          </span>
          <span data-ttu-id="f4180-1178">实现此方法可为此事件添加类处理。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-1178">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4180-1179">此虚方法引发时的值<xref:System.Windows.ContentElement.IsStylusDirectlyOver%2A>依赖项属性更改其值。</span><span class="sxs-lookup"><span data-stu-id="f4180-1179">This virtual method is raised when the value of the <xref:System.Windows.ContentElement.IsStylusDirectlyOver%2A> dependency property changes its value.</span></span> <span data-ttu-id="f4180-1180">虚拟方法首先引发，并可以处理在必要时的事件数据。</span><span class="sxs-lookup"><span data-stu-id="f4180-1180">The virtual method is raised first and can manipulate the event data as necessary.</span></span> <span data-ttu-id="f4180-1181">然后<xref:System.Windows.ContentElement.IsStylusDirectlyOverChanged>与该相同的事件数据实例引发事件。</span><span class="sxs-lookup"><span data-stu-id="f4180-1181">Then the <xref:System.Windows.ContentElement.IsStylusDirectlyOverChanged> event is raised with that same event data instance.</span></span> <span data-ttu-id="f4180-1182">请注意，该事件不是路由的事件。</span><span class="sxs-lookup"><span data-stu-id="f4180-1182">Notice that the event is not a routed event.</span></span> <span data-ttu-id="f4180-1183">因此您不能将其标记为已处理的类处理程序中。</span><span class="sxs-lookup"><span data-stu-id="f4180-1183">Therefore you cannot mark it as handled in the class handler.</span></span>  
  
 <span data-ttu-id="f4180-1184">此方法具有默认实现。</span><span class="sxs-lookup"><span data-stu-id="f4180-1184">This method has no default implementation.</span></span> <span data-ttu-id="f4180-1185">因为中间类继承中的可能会实现此方法，我们建议在实现中调用基实现。</span><span class="sxs-lookup"><span data-stu-id="f4180-1185">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span> <span data-ttu-id="f4180-1186">您可以调用基之前或之后应用特殊处理，具体取决于您的要求。</span><span class="sxs-lookup"><span data-stu-id="f4180-1186">You may call base either before or after your special handling, depending on your requirements.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnKeyDown">
      <MemberSignature Language="C#" Value="protected internal virtual void OnKeyDown (System.Windows.Input.KeyEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnKeyDown(class System.Windows.Input.KeyEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnKeyDown(System.Windows.Input.KeyEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnKeyDown (e As KeyEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnKeyDown(System::Windows::Input::KeyEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnKeyDown : System.Windows.Input.KeyEventArgs -&gt; unit&#xA;override this.OnKeyDown : System.Windows.Input.KeyEventArgs -&gt; unit" Usage="contentElement.OnKeyDown e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.KeyEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="f4180-1187">包含事件数据的 <see cref="T:System.Windows.Input.KeyEventArgs" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-1187">The <see cref="T:System.Windows.Input.KeyEventArgs" /> that contains the event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f4180-1188">当某个未处理的 <see cref="E:System.Windows.Input.Keyboard.KeyDown" /> 附加事件在其路由中到达派生自此类的某个元素时调用。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-1188">Invoked when an unhandled <see cref="E:System.Windows.Input.Keyboard.KeyDown" /> attached event reaches an element in its route that is derived from this class.</span>
          </span>
          <span data-ttu-id="f4180-1189">实现此方法可为此事件添加类处理。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-1189">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4180-1190">击键通过专用的输入管理器进行处理。</span><span class="sxs-lookup"><span data-stu-id="f4180-1190">Keystrokes are handled by a dedicated input manager.</span></span> <span data-ttu-id="f4180-1191">其他编程功能，依赖于击键，例如，输入和命令绑定，可能会在键击公开为常规击键之前处理。</span><span class="sxs-lookup"><span data-stu-id="f4180-1191">Other programming features that rely on keystrokes, for example, input and command bindings, might handle the keystroke before it is exposed as a general keystroke.</span></span> <span data-ttu-id="f4180-1192">如果这些输入系统功能将事件标记为已处理，然后<xref:System.Windows.ContentElement.OnKeyDown%2A>不调用。</span><span class="sxs-lookup"><span data-stu-id="f4180-1192">If these input system features mark the event as handled, then <xref:System.Windows.ContentElement.OnKeyDown%2A> is not invoked.</span></span>  
  
 <span data-ttu-id="f4180-1193">此方法具有默认实现。</span><span class="sxs-lookup"><span data-stu-id="f4180-1193">This method has no default implementation.</span></span> <span data-ttu-id="f4180-1194">因为中间类继承中的可能会实现此方法，我们建议在实现中调用基实现。</span><span class="sxs-lookup"><span data-stu-id="f4180-1194">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="f4180-1195">此方法的用途是类似于[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]事件模式 On \* 方法： 此方法提供了通过建立类处理程序而不是实例处理程序来处理从派生类的匹配事件的方法。</span><span class="sxs-lookup"><span data-stu-id="f4180-1195">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="f4180-1196">在这种情况下匹配事件是路由的事件。</span><span class="sxs-lookup"><span data-stu-id="f4180-1196">In this case the matching event is a routed event.</span></span> <span data-ttu-id="f4180-1197">On \* 方法的实现模式是不同的路由事件，因为可以由子元素，它不一定是将调用处理程序的元素引发路由的事件。</span><span class="sxs-lookup"><span data-stu-id="f4180-1197">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="f4180-1198">因此，您的实现需要检查的事件数据源属性。</span><span class="sxs-lookup"><span data-stu-id="f4180-1198">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="f4180-1199">它不应尝试再次引发该事件在大多数情况下。</span><span class="sxs-lookup"><span data-stu-id="f4180-1199">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="f4180-1200">通过重写此方法或通过注册类处理程序替换<xref:System.Windows.EventManager.RegisterClassHandler%2A>，派生类的<xref:System.Windows.ContentElement>为由事件路由收到事件时，可以调用私有类处理程序方法。</span><span class="sxs-lookup"><span data-stu-id="f4180-1200">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="f4180-1201">类处理是相应的一种方案是操作事件数据并将路由的事件标记为已处理。</span><span class="sxs-lookup"><span data-stu-id="f4180-1201">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.KeyDown" />
      </Docs>
    </Member>
    <Member MemberName="OnKeyUp">
      <MemberSignature Language="C#" Value="protected internal virtual void OnKeyUp (System.Windows.Input.KeyEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnKeyUp(class System.Windows.Input.KeyEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnKeyUp(System.Windows.Input.KeyEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnKeyUp (e As KeyEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnKeyUp(System::Windows::Input::KeyEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnKeyUp : System.Windows.Input.KeyEventArgs -&gt; unit&#xA;override this.OnKeyUp : System.Windows.Input.KeyEventArgs -&gt; unit" Usage="contentElement.OnKeyUp e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.KeyEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="f4180-1202">包含事件数据的 <see cref="T:System.Windows.Input.KeyEventArgs" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-1202">The <see cref="T:System.Windows.Input.KeyEventArgs" /> that contains the event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f4180-1203">当某个未处理的 <see cref="E:System.Windows.Input.Keyboard.KeyUp" /> 附加事件在其路由中到达派生自此类的某个元素时调用。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-1203">Invoked when an unhandled <see cref="E:System.Windows.Input.Keyboard.KeyUp" /> attached event reaches an element in its route that is derived from this class.</span>
          </span>
          <span data-ttu-id="f4180-1204">实现此方法可为此事件添加类处理。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-1204">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4180-1205">击键通过专用的输入管理器进行处理。</span><span class="sxs-lookup"><span data-stu-id="f4180-1205">Keystrokes are handled by a dedicated input manager.</span></span> <span data-ttu-id="f4180-1206">其他编程功能，依赖于击键，例如，输入和命令绑定，可能会在键击公开为常规击键之前处理。</span><span class="sxs-lookup"><span data-stu-id="f4180-1206">Other programming features that rely on keystrokes, for example, input and command bindings, might handle the keystroke before it is exposed as a general keystroke.</span></span> <span data-ttu-id="f4180-1207">如果这些输入系统功能将事件标记为已处理，然后<xref:System.Windows.ContentElement.OnKeyUp%2A>不调用。</span><span class="sxs-lookup"><span data-stu-id="f4180-1207">If these input system features mark the event as handled, then <xref:System.Windows.ContentElement.OnKeyUp%2A> is not invoked.</span></span>  
  
 <span data-ttu-id="f4180-1208">此方法具有默认实现。</span><span class="sxs-lookup"><span data-stu-id="f4180-1208">This method has no default implementation.</span></span> <span data-ttu-id="f4180-1209">因为中间类继承中的可能会实现此方法，我们建议在实现中调用基实现。</span><span class="sxs-lookup"><span data-stu-id="f4180-1209">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="f4180-1210">此方法的用途是类似于[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]事件模式 On \* 方法： 此方法提供了通过建立类处理程序而不是实例处理程序来处理从派生类的匹配事件的方法。</span><span class="sxs-lookup"><span data-stu-id="f4180-1210">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="f4180-1211">在这种情况下匹配事件是路由的事件。</span><span class="sxs-lookup"><span data-stu-id="f4180-1211">In this case the matching event is a routed event.</span></span> <span data-ttu-id="f4180-1212">On \* 方法的实现模式是不同的路由事件，因为可以由子元素，它不一定是将调用处理程序的元素引发路由的事件。</span><span class="sxs-lookup"><span data-stu-id="f4180-1212">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="f4180-1213">因此，您的实现需要检查的事件数据源属性。</span><span class="sxs-lookup"><span data-stu-id="f4180-1213">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="f4180-1214">它不应尝试再次引发该事件在大多数情况下。</span><span class="sxs-lookup"><span data-stu-id="f4180-1214">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="f4180-1215">通过重写此方法或通过注册类处理程序替换<xref:System.Windows.EventManager.RegisterClassHandler%2A>，派生类的<xref:System.Windows.ContentElement>为由事件路由收到事件时，可以调用私有类处理程序方法。</span><span class="sxs-lookup"><span data-stu-id="f4180-1215">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="f4180-1216">类处理是相应的一种方案是操作事件数据并将路由的事件标记为已处理。</span><span class="sxs-lookup"><span data-stu-id="f4180-1216">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.KeyUp" />
      </Docs>
    </Member>
    <Member MemberName="OnLostFocus">
      <MemberSignature Language="C#" Value="protected virtual void OnLostFocus (System.Windows.RoutedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnLostFocus(class System.Windows.RoutedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnLostFocus(System.Windows.RoutedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnLostFocus (e As RoutedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnLostFocus(System::Windows::RoutedEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnLostFocus : System.Windows.RoutedEventArgs -&gt; unit&#xA;override this.OnLostFocus : System.Windows.RoutedEventArgs -&gt; unit" Usage="contentElement.OnLostFocus e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.RoutedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="f4180-1217">包含事件数据的 <see cref="T:System.Windows.RoutedEventArgs" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-1217">A <see cref="T:System.Windows.RoutedEventArgs" /> that contains event data.</span>
          </span>
          <span data-ttu-id="f4180-1218">此事件数据必须包含 <see cref="E:System.Windows.ContentElement.LostFocus" /> 事件的标识符。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-1218">This event data must contain the identifier for the <see cref="E:System.Windows.ContentElement.LostFocus" /> event.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f4180-1219">使用提供的事件数据引发 <see cref="E:System.Windows.ContentElement.LostFocus" /> 路由事件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-1219">Raises the <see cref="E:System.Windows.ContentElement.LostFocus" /> routed event by using the event data that is provided.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4180-1220">此方法，尽管虚拟的但有一个默认实现，引发事件。</span><span class="sxs-lookup"><span data-stu-id="f4180-1220">This method, although virtual, does have a default implementation that raises the event.</span></span>  
  
 <span data-ttu-id="f4180-1221">这在 \* 方法实现用于引发事件，并在内部调用此方法的实现来引发事件时<xref:System.Windows.ContentElement.IsFocused%2A>属性值发生更改。</span><span class="sxs-lookup"><span data-stu-id="f4180-1221">This On\* method implementation is intended to raise the event, and this same method implementation is invoked internally to raise the event when the <xref:System.Windows.ContentElement.IsFocused%2A> property value changes.</span></span> <span data-ttu-id="f4180-1222">此实现不同于其他某些[!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)]上 \* 实现，后者仅提供了方便地为该事件添加类处理。</span><span class="sxs-lookup"><span data-stu-id="f4180-1222">This implementation differs from some other [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] On\* implementations, which only provide a convenient way to add class handling for that event.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <span data-ttu-id="f4180-1223">除非你有有意或不寻常的需求不引发焦点事件，请确保您的实现将调用基实现。</span>
            <span class="sxs-lookup">
              <span data-stu-id="f4180-1223">Unless you have a deliberate and unusual need to not raise the focus events, make sure that your implementation calls the base implementation.</span>
            </span>
            <span data-ttu-id="f4180-1224">否则为<see cref="E:System.Windows.ContentElement.LostFocus" />通常将焦点设置到此元素的典型用户操作中不引发事件。</span>
            <span class="sxs-lookup">
              <span data-stu-id="f4180-1224">Otherwise, the <see cref="E:System.Windows.ContentElement.LostFocus" /> event is not raised during typical user operations that ordinarily set focus to this element.</span>
            </span>
            <span data-ttu-id="f4180-1225">如果不想您可获得焦点的元素，您可以通过将阻止元素<see cref="P:System.Windows.ContentElement.Focusable" />到<see langword="false" />。</span>
            <span class="sxs-lookup">
              <span data-stu-id="f4180-1225">If you do not intend your element to be focusable, you can prevent the element from being focusable by setting <see cref="P:System.Windows.ContentElement.Focusable" /> to <see langword="false" />.</span>
            </span>
          </para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnLostKeyboardFocus">
      <MemberSignature Language="C#" Value="protected internal virtual void OnLostKeyboardFocus (System.Windows.Input.KeyboardFocusChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnLostKeyboardFocus(class System.Windows.Input.KeyboardFocusChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnLostKeyboardFocus(System.Windows.Input.KeyboardFocusChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnLostKeyboardFocus (e As KeyboardFocusChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnLostKeyboardFocus(System::Windows::Input::KeyboardFocusChangedEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnLostKeyboardFocus : System.Windows.Input.KeyboardFocusChangedEventArgs -&gt; unit&#xA;override this.OnLostKeyboardFocus : System.Windows.Input.KeyboardFocusChangedEventArgs -&gt; unit" Usage="contentElement.OnLostKeyboardFocus e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.KeyboardFocusChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="f4180-1226">包含事件数据的 <see cref="T:System.Windows.Input.KeyboardFocusChangedEventArgs" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-1226">The <see cref="T:System.Windows.Input.KeyboardFocusChangedEventArgs" /> that contains event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f4180-1227">当某个未处理的 <see cref="E:System.Windows.Input.Keyboard.LostKeyboardFocus" /> 附加事件在其路由中到达派生自此类的某个元素时调用。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-1227">Invoked when an unhandled <see cref="E:System.Windows.Input.Keyboard.LostKeyboardFocus" /> attached event reaches an element in its route that is derived from this class.</span>
          </span>
          <span data-ttu-id="f4180-1228">实现此方法可为此事件添加类处理。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-1228">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4180-1229">此方法具有默认实现。</span><span class="sxs-lookup"><span data-stu-id="f4180-1229">This method has no default implementation.</span></span> <span data-ttu-id="f4180-1230">因为中间类继承中的可能会实现此方法，我们建议在实现中调用基实现。</span><span class="sxs-lookup"><span data-stu-id="f4180-1230">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="f4180-1231">此方法的用途是类似于[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]事件模式 On \* 方法： 此方法提供了通过建立类处理程序而不是实例处理程序来处理从派生类的匹配事件的方法。</span><span class="sxs-lookup"><span data-stu-id="f4180-1231">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="f4180-1232">在这种情况下匹配事件是路由的事件。</span><span class="sxs-lookup"><span data-stu-id="f4180-1232">In this case the matching event is a routed event.</span></span> <span data-ttu-id="f4180-1233">On \* 方法的实现模式是不同的路由事件，因为可以由子元素，它不一定是将调用处理程序的元素引发路由的事件。</span><span class="sxs-lookup"><span data-stu-id="f4180-1233">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="f4180-1234">因此，您的实现需要检查的事件数据源属性。</span><span class="sxs-lookup"><span data-stu-id="f4180-1234">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="f4180-1235">它不应尝试再次引发该事件在大多数情况下。</span><span class="sxs-lookup"><span data-stu-id="f4180-1235">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="f4180-1236">通过重写此方法或通过注册类处理程序替换<xref:System.Windows.EventManager.RegisterClassHandler%2A>，派生类的<xref:System.Windows.ContentElement>为由事件路由收到事件时，可以调用私有类处理程序方法。</span><span class="sxs-lookup"><span data-stu-id="f4180-1236">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="f4180-1237">类处理是相应的一种方案是操作事件数据并将路由的事件标记为已处理。</span><span class="sxs-lookup"><span data-stu-id="f4180-1237">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.LostKeyboardFocus" />
      </Docs>
    </Member>
    <Member MemberName="OnLostMouseCapture">
      <MemberSignature Language="C#" Value="protected internal virtual void OnLostMouseCapture (System.Windows.Input.MouseEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnLostMouseCapture(class System.Windows.Input.MouseEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnLostMouseCapture(System.Windows.Input.MouseEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnLostMouseCapture (e As MouseEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnLostMouseCapture(System::Windows::Input::MouseEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnLostMouseCapture : System.Windows.Input.MouseEventArgs -&gt; unit&#xA;override this.OnLostMouseCapture : System.Windows.Input.MouseEventArgs -&gt; unit" Usage="contentElement.OnLostMouseCapture e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="f4180-1238">包含事件数据的 <see cref="T:System.Windows.Input.MouseEventArgs" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-1238">The <see cref="T:System.Windows.Input.MouseEventArgs" /> that contains event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f4180-1239">当某个未处理的 <see cref="E:System.Windows.Input.Mouse.LostMouseCapture" /> 附加事件在其路由中到达派生自此类的某个元素时调用。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-1239">Invoked when an unhandled <see cref="E:System.Windows.Input.Mouse.LostMouseCapture" /> attached event reaches an element in its route that is derived from this class.</span>
          </span>
          <span data-ttu-id="f4180-1240">实现此方法可为此事件添加类处理。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-1240">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4180-1241">此方法具有默认实现。</span><span class="sxs-lookup"><span data-stu-id="f4180-1241">This method has no default implementation.</span></span> <span data-ttu-id="f4180-1242">因为中间类继承中的可能会实现此方法，我们建议在实现中调用基实现。</span><span class="sxs-lookup"><span data-stu-id="f4180-1242">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="f4180-1243">此方法的用途是类似于[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]事件模式 On \* 方法： 此方法提供了通过建立类处理程序而不是实例处理程序来处理从派生类的匹配事件的方法。</span><span class="sxs-lookup"><span data-stu-id="f4180-1243">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="f4180-1244">在这种情况下匹配事件是路由的事件。</span><span class="sxs-lookup"><span data-stu-id="f4180-1244">In this case the matching event is a routed event.</span></span> <span data-ttu-id="f4180-1245">On \* 方法的实现模式是不同的路由事件，因为可以由子元素，它不一定是将调用处理程序的元素引发路由的事件。</span><span class="sxs-lookup"><span data-stu-id="f4180-1245">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="f4180-1246">因此，您的实现需要检查的事件数据源属性。</span><span class="sxs-lookup"><span data-stu-id="f4180-1246">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="f4180-1247">它不应尝试再次引发该事件在大多数情况下。</span><span class="sxs-lookup"><span data-stu-id="f4180-1247">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="f4180-1248">通过重写此方法或通过注册类处理程序替换<xref:System.Windows.EventManager.RegisterClassHandler%2A>，派生类的<xref:System.Windows.ContentElement>为由事件路由收到事件时，可以调用私有类处理程序方法。</span><span class="sxs-lookup"><span data-stu-id="f4180-1248">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="f4180-1249">类处理是相应的一种方案是操作事件数据并将路由的事件标记为已处理。</span><span class="sxs-lookup"><span data-stu-id="f4180-1249">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.LostMouseCapture" />
      </Docs>
    </Member>
    <Member MemberName="OnLostStylusCapture">
      <MemberSignature Language="C#" Value="protected internal virtual void OnLostStylusCapture (System.Windows.Input.StylusEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnLostStylusCapture(class System.Windows.Input.StylusEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnLostStylusCapture(System.Windows.Input.StylusEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnLostStylusCapture (e As StylusEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnLostStylusCapture(System::Windows::Input::StylusEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnLostStylusCapture : System.Windows.Input.StylusEventArgs -&gt; unit&#xA;override this.OnLostStylusCapture : System.Windows.Input.StylusEventArgs -&gt; unit" Usage="contentElement.OnLostStylusCapture e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="f4180-1250">包含事件数据的 <see cref="T:System.Windows.Input.StylusEventArgs" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-1250">The <see cref="T:System.Windows.Input.StylusEventArgs" /> that contains event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f4180-1251">当某个未处理的 <see cref="E:System.Windows.Input.Stylus.LostStylusCapture" /> 附加事件在其路由中到达派生自此类的某个元素时调用。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-1251">Invoked when an unhandled <see cref="E:System.Windows.Input.Stylus.LostStylusCapture" /> attached event reaches an element in its route that is derived from this class.</span>
          </span>
          <span data-ttu-id="f4180-1252">实现此方法可为此事件添加类处理。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-1252">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4180-1253">此方法具有默认实现。</span><span class="sxs-lookup"><span data-stu-id="f4180-1253">This method has no default implementation.</span></span> <span data-ttu-id="f4180-1254">因为中间类继承中的可能会实现此方法，我们建议在实现中调用基实现。</span><span class="sxs-lookup"><span data-stu-id="f4180-1254">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="f4180-1255">此方法的用途是类似于[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]事件模式 On \* 方法： 此方法提供了通过建立类处理程序而不是实例处理程序来处理从派生类的匹配事件的方法。</span><span class="sxs-lookup"><span data-stu-id="f4180-1255">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="f4180-1256">在这种情况下匹配事件是路由的事件。</span><span class="sxs-lookup"><span data-stu-id="f4180-1256">In this case the matching event is a routed event.</span></span> <span data-ttu-id="f4180-1257">On \* 方法的实现模式是不同的路由事件，因为可以由子元素，它不一定是将调用处理程序的元素引发路由的事件。</span><span class="sxs-lookup"><span data-stu-id="f4180-1257">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="f4180-1258">因此，您的实现需要检查的事件数据源属性。</span><span class="sxs-lookup"><span data-stu-id="f4180-1258">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="f4180-1259">它不应尝试再次引发该事件在大多数情况下。</span><span class="sxs-lookup"><span data-stu-id="f4180-1259">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="f4180-1260">通过重写此方法或通过注册类处理程序替换<xref:System.Windows.EventManager.RegisterClassHandler%2A>，派生类的<xref:System.Windows.ContentElement>为由事件路由收到事件时，可以调用私有类处理程序方法。</span><span class="sxs-lookup"><span data-stu-id="f4180-1260">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="f4180-1261">类处理是相应的一种方案是操作事件数据并将路由的事件标记为已处理。</span><span class="sxs-lookup"><span data-stu-id="f4180-1261">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.LostStylusCapture" />
      </Docs>
    </Member>
    <Member MemberName="OnLostTouchCapture">
      <MemberSignature Language="C#" Value="protected internal virtual void OnLostTouchCapture (System.Windows.Input.TouchEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnLostTouchCapture(class System.Windows.Input.TouchEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnLostTouchCapture(System.Windows.Input.TouchEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnLostTouchCapture (e As TouchEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnLostTouchCapture(System::Windows::Input::TouchEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnLostTouchCapture : System.Windows.Input.TouchEventArgs -&gt; unit&#xA;override this.OnLostTouchCapture : System.Windows.Input.TouchEventArgs -&gt; unit" Usage="contentElement.OnLostTouchCapture e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.TouchEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="f4180-1262">包含事件数据的 <see cref="T:System.Windows.Input.TouchEventArgs" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-1262">A <see cref="T:System.Windows.Input.TouchEventArgs" /> that contains the event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f4180-1263">为在此元素失去触摸屏输入捕获时发生的 <see cref="E:System.Windows.ContentElement.LostTouchCapture" /> 路由事件提供类处理。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-1263">Provides class handling for the <see cref="E:System.Windows.ContentElement.LostTouchCapture" /> routed event that occurs when this element loses a touch capture.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4180-1264"><xref:System.Windows.ContentElement.OnLostTouchCapture%2A>方法具有默认实现。</span><span class="sxs-lookup"><span data-stu-id="f4180-1264">The <xref:System.Windows.ContentElement.OnLostTouchCapture%2A> method has no default implementation.</span></span> <span data-ttu-id="f4180-1265">重写<xref:System.Windows.ContentElement.OnLostTouchCapture%2A>中派生的类来处理<xref:System.Windows.ContentElement.LostTouchCapture>事件。</span><span class="sxs-lookup"><span data-stu-id="f4180-1265">Override <xref:System.Windows.ContentElement.OnLostTouchCapture%2A> in a derived class to handle the <xref:System.Windows.ContentElement.LostTouchCapture> event.</span></span> <span data-ttu-id="f4180-1266">请务必调用基类的<xref:System.Windows.ContentElement.OnLostTouchCapture%2A>方法，从而基本类接收事件。</span><span class="sxs-lookup"><span data-stu-id="f4180-1266">Be sure to call the base class’s <xref:System.Windows.ContentElement.OnLostTouchCapture%2A> method so that base classes receive the event.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnMouseDown">
      <MemberSignature Language="C#" Value="protected internal virtual void OnMouseDown (System.Windows.Input.MouseButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnMouseDown(class System.Windows.Input.MouseButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnMouseDown(System.Windows.Input.MouseButtonEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnMouseDown (e As MouseButtonEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnMouseDown(System::Windows::Input::MouseButtonEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnMouseDown : System.Windows.Input.MouseButtonEventArgs -&gt; unit&#xA;override this.OnMouseDown : System.Windows.Input.MouseButtonEventArgs -&gt; unit" Usage="contentElement.OnMouseDown e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="f4180-1267">包含事件数据的 <see cref="T:System.Windows.Input.MouseButtonEventArgs" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-1267">The <see cref="T:System.Windows.Input.MouseButtonEventArgs" /> that contains the event data.</span>
          </span>
          <span data-ttu-id="f4180-1268">此事件数据报告有关按下鼠标按钮和已处理状态的详细信息。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-1268">This event data reports details about the mouse button that was pressed and the handled state.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f4180-1269">当某个未处理的 <see cref="E:System.Windows.Input.Mouse.MouseDown" /> 附加事件在其路由中到达派生自此类的某个元素时调用。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-1269">Invoked when an unhandled <see cref="E:System.Windows.Input.Mouse.MouseDown" /> attached event reaches an element in its route that is derived from this class.</span>
          </span>
          <span data-ttu-id="f4180-1270">实现此方法可为此事件添加类处理。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-1270">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4180-1271">处理鼠标按钮操作也是通过专用的输入管理器。</span><span class="sxs-lookup"><span data-stu-id="f4180-1271">Mouse button actions are also handled by a dedicated input manager.</span></span> <span data-ttu-id="f4180-1272">公开为常规鼠标按钮操作之前，其他编程功能，依赖于鼠标按钮操作，例如输入和命令绑定，可能会调用处理程序的操作。</span><span class="sxs-lookup"><span data-stu-id="f4180-1272">Other programming features that rely on mouse button actions, such as input and command bindings, might invoke handlers for the action before it is exposed as a general mouse button action.</span></span> <span data-ttu-id="f4180-1273">如果这些输入系统功能标记<xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType>事件处理，如<xref:System.Windows.ContentElement.OnMouseDown%2A>不调用。</span><span class="sxs-lookup"><span data-stu-id="f4180-1273">If these input system features mark the <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType> event as handled, <xref:System.Windows.ContentElement.OnMouseDown%2A> is not invoked.</span></span>  
  
 <span data-ttu-id="f4180-1274">如果使用此类处理程序将事件标记为已处理，则可能会影响以下事件：<xref:System.Windows.ContentElement.MouseLeftButtonDown>和<xref:System.Windows.ContentElement.MouseRightButtonDown>。</span><span class="sxs-lookup"><span data-stu-id="f4180-1274">If you use this class handler to mark the event as handled, you potentially impact the following events: <xref:System.Windows.ContentElement.MouseLeftButtonDown> and <xref:System.Windows.ContentElement.MouseRightButtonDown>.</span></span> <span data-ttu-id="f4180-1275">上述任一事件可能会在接收元素上引发时<xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType>收到。</span><span class="sxs-lookup"><span data-stu-id="f4180-1275">Either of these events may be raised on the receiving element when <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType> is received.</span></span>  
  
 <span data-ttu-id="f4180-1276">如果标记为已处理的类中处理此事件，则仍会引发子事件;但是，它们通过中的事件数据的处理的状态。</span><span class="sxs-lookup"><span data-stu-id="f4180-1276">If you mark this event as handled in class handling, subevents are still raised; however, they pass the handled state in the event data.</span></span> <span data-ttu-id="f4180-1277">除非您显式使用类处理在处理该事件时，如果不调用为子事件的实例处理<xref:System.Windows.ContentElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29>与`handledEventsToo``true`才能附加处理程序。</span><span class="sxs-lookup"><span data-stu-id="f4180-1277">If the event is handled in class handling, instance handlers for the subevents are not invoked unless you explicitly use <xref:System.Windows.ContentElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> with `handledEventsToo` `true` in order to attach handlers.</span></span> <span data-ttu-id="f4180-1278">类处理程序也不会调用与注册了这些类处理程序，除非<xref:System.Windows.EventManager.RegisterClassHandler%28System.Type%2CSystem.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29>带签名`handledEventsToo` `true`。</span><span class="sxs-lookup"><span data-stu-id="f4180-1278">Class handlers also are not invoked unless those class handlers were registered with the <xref:System.Windows.EventManager.RegisterClassHandler%28System.Type%2CSystem.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> signature with `handledEventsToo` `true`.</span></span> <span data-ttu-id="f4180-1279">通过处理<xref:System.Windows.ContentElement.OnMouseDown%2A>，则意味着你类处理负责所有可能的鼠标按钮按下操作。</span><span class="sxs-lookup"><span data-stu-id="f4180-1279">By handling <xref:System.Windows.ContentElement.OnMouseDown%2A>, you are implying that your class handling accounted for all possible mouse button down actions.</span></span> <span data-ttu-id="f4180-1280">此行为可能不需要;因此，此虚拟方法用于将事件标记为已处理时要格外小心。</span><span class="sxs-lookup"><span data-stu-id="f4180-1280">This behavior might be unwanted; therefore, use caution when you use this virtual method to mark events as handled.</span></span>  
  
 <span data-ttu-id="f4180-1281">每个特定于按钮的直接事件也有一个虚拟 On \* 方法;请考虑是否重写这些特定于按钮的类处理程序可能会更合适。</span><span class="sxs-lookup"><span data-stu-id="f4180-1281">Each of the button-specific direct events also has a virtual On\* method; consider whether overriding these button-specific class handlers might be more appropriate.</span></span>  
  
 <span data-ttu-id="f4180-1282">此方法具有默认实现。</span><span class="sxs-lookup"><span data-stu-id="f4180-1282">This method has no default implementation.</span></span> <span data-ttu-id="f4180-1283">因为中间类继承中的可能会实现此方法，我们建议在实现中调用基实现。</span><span class="sxs-lookup"><span data-stu-id="f4180-1283">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="f4180-1284">此方法的用途是类似于[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]事件模式 On \* 方法： 此方法提供了通过建立类处理程序而不是实例处理程序来处理从派生类的匹配事件的方法。</span><span class="sxs-lookup"><span data-stu-id="f4180-1284">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="f4180-1285">在这种情况下匹配事件是路由的事件。</span><span class="sxs-lookup"><span data-stu-id="f4180-1285">In this case the matching event is a routed event.</span></span> <span data-ttu-id="f4180-1286">On \* 方法的实现模式是不同的路由事件，因为可以由子元素，它不一定是将调用处理程序的元素引发路由的事件。</span><span class="sxs-lookup"><span data-stu-id="f4180-1286">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="f4180-1287">因此，您的实现需要检查的事件数据源属性。</span><span class="sxs-lookup"><span data-stu-id="f4180-1287">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="f4180-1288">它不应尝试再次引发该事件在大多数情况下。</span><span class="sxs-lookup"><span data-stu-id="f4180-1288">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="f4180-1289">通过重写此方法或通过注册类处理程序替换<xref:System.Windows.EventManager.RegisterClassHandler%2A>，派生类的<xref:System.Windows.ContentElement>为由事件路由收到事件时，可以调用私有类处理程序方法。</span><span class="sxs-lookup"><span data-stu-id="f4180-1289">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="f4180-1290">类处理是相应的一种方案是操作事件数据并将路由的事件标记为已处理。</span><span class="sxs-lookup"><span data-stu-id="f4180-1290">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.MouseDown" />
      </Docs>
    </Member>
    <Member MemberName="OnMouseEnter">
      <MemberSignature Language="C#" Value="protected internal virtual void OnMouseEnter (System.Windows.Input.MouseEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnMouseEnter(class System.Windows.Input.MouseEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnMouseEnter(System.Windows.Input.MouseEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnMouseEnter (e As MouseEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnMouseEnter(System::Windows::Input::MouseEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnMouseEnter : System.Windows.Input.MouseEventArgs -&gt; unit&#xA;override this.OnMouseEnter : System.Windows.Input.MouseEventArgs -&gt; unit" Usage="contentElement.OnMouseEnter e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="f4180-1291">包含事件数据的 <see cref="T:System.Windows.Input.MouseEventArgs" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-1291">The <see cref="T:System.Windows.Input.MouseEventArgs" /> that contains the event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f4180-1292">当此元素引发未处理的 <see cref="E:System.Windows.Input.Mouse.MouseEnter" /> 附加事件时调用。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-1292">Invoked when an unhandled <see cref="E:System.Windows.Input.Mouse.MouseEnter" /> attached event is raised on this element.</span>
          </span>
          <span data-ttu-id="f4180-1293">实现此方法可为此事件添加类处理。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-1293">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4180-1294">此方法具有默认实现。</span><span class="sxs-lookup"><span data-stu-id="f4180-1294">This method has no default implementation.</span></span> <span data-ttu-id="f4180-1295">因为中间类继承中的可能会实现此方法，我们建议在实现中调用基实现。</span><span class="sxs-lookup"><span data-stu-id="f4180-1295">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span> <span data-ttu-id="f4180-1296">您可以调用基之前或之后应用特殊处理，具体取决于您的要求。</span><span class="sxs-lookup"><span data-stu-id="f4180-1296">You may call base either before or after your special handling, depending on your requirements.</span></span>  
  
 <span data-ttu-id="f4180-1297">此方法的用途是类似于[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]事件模式 On \* 方法： 此方法提供了通过建立类处理程序而不是实例处理程序来处理从派生类的匹配事件的方法。</span><span class="sxs-lookup"><span data-stu-id="f4180-1297">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="f4180-1298">在这种情况下匹配事件是路由的事件，具有直接的路由策略。</span><span class="sxs-lookup"><span data-stu-id="f4180-1298">In this case the matching event is a routed event, with a direct routing strategy.</span></span> <span data-ttu-id="f4180-1299">将事件标记为已处理是仍有助于防止典型实例处理程序 (未指定的那些`handledEventsToo`) 调用。</span><span class="sxs-lookup"><span data-stu-id="f4180-1299">Marking the event as handled is still useful for preventing the typical instance handlers (those that do not specify `handledEventsToo`) from being invoked.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.MouseEnter" />
      </Docs>
    </Member>
    <Member MemberName="OnMouseLeave">
      <MemberSignature Language="C#" Value="protected internal virtual void OnMouseLeave (System.Windows.Input.MouseEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnMouseLeave(class System.Windows.Input.MouseEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnMouseLeave(System.Windows.Input.MouseEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnMouseLeave (e As MouseEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnMouseLeave(System::Windows::Input::MouseEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnMouseLeave : System.Windows.Input.MouseEventArgs -&gt; unit&#xA;override this.OnMouseLeave : System.Windows.Input.MouseEventArgs -&gt; unit" Usage="contentElement.OnMouseLeave e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="f4180-1300">包含事件数据的 <see cref="T:System.Windows.Input.MouseEventArgs" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-1300">The <see cref="T:System.Windows.Input.MouseEventArgs" /> that contains the event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f4180-1301">当此元素引发未处理的 <see cref="E:System.Windows.Input.Mouse.MouseLeave" /> 附加事件时调用。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-1301">Invoked when an unhandled <see cref="E:System.Windows.Input.Mouse.MouseLeave" /> attached event is raised on this element.</span>
          </span>
          <span data-ttu-id="f4180-1302">实现此方法可为此事件添加类处理。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-1302">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4180-1303">此方法具有默认实现。</span><span class="sxs-lookup"><span data-stu-id="f4180-1303">This method has no default implementation.</span></span> <span data-ttu-id="f4180-1304">因为中间类继承中的可能会实现此方法，我们建议在实现中调用基实现。</span><span class="sxs-lookup"><span data-stu-id="f4180-1304">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span> <span data-ttu-id="f4180-1305">您可以调用基之前或之后应用特殊处理，具体取决于您的要求。</span><span class="sxs-lookup"><span data-stu-id="f4180-1305">You may call base either before or after your special handling, depending on your requirements.</span></span>  
  
 <span data-ttu-id="f4180-1306">此方法的用途是类似于[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]事件模式 On \* 方法： 此方法提供了通过建立类处理程序而不是实例处理程序来处理从派生类的匹配事件的方法。</span><span class="sxs-lookup"><span data-stu-id="f4180-1306">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="f4180-1307">在这种情况下匹配事件是路由的事件，具有直接的路由策略。</span><span class="sxs-lookup"><span data-stu-id="f4180-1307">In this case the matching event is a routed event, with a direct routing strategy.</span></span> <span data-ttu-id="f4180-1308">将事件标记为已处理是仍有助于防止典型实例处理程序 (未指定的那些`handledEventsToo`) 调用。</span><span class="sxs-lookup"><span data-stu-id="f4180-1308">Marking the event as handled is still useful for preventing the typical instance handlers (those that do not specify `handledEventsToo`) from being invoked.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.MouseLeave" />
      </Docs>
    </Member>
    <Member MemberName="OnMouseLeftButtonDown">
      <MemberSignature Language="C#" Value="protected internal virtual void OnMouseLeftButtonDown (System.Windows.Input.MouseButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnMouseLeftButtonDown(class System.Windows.Input.MouseButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnMouseLeftButtonDown(System.Windows.Input.MouseButtonEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnMouseLeftButtonDown (e As MouseButtonEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnMouseLeftButtonDown(System::Windows::Input::MouseButtonEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnMouseLeftButtonDown : System.Windows.Input.MouseButtonEventArgs -&gt; unit&#xA;override this.OnMouseLeftButtonDown : System.Windows.Input.MouseButtonEventArgs -&gt; unit" Usage="contentElement.OnMouseLeftButtonDown e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="f4180-1309">包含事件数据的 <see cref="T:System.Windows.Input.MouseButtonEventArgs" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-1309">The <see cref="T:System.Windows.Input.MouseButtonEventArgs" /> that contains the event data.</span>
          </span>
          <span data-ttu-id="f4180-1310">事件数据报告称已按下鼠标左键。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-1310">The event data reports that the left mouse button was pressed.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f4180-1311">当此元素引发未处理的 <see cref="E:System.Windows.ContentElement.MouseLeftButtonDown" /> 路由事件时调用。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-1311">Invoked when an unhandled <see cref="E:System.Windows.ContentElement.MouseLeftButtonDown" /> routed event is raised on this element.</span>
          </span>
          <span data-ttu-id="f4180-1312">实现此方法可为此事件添加类处理。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-1312">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4180-1313"><xref:System.Windows.ContentElement.MouseLeftButtonDown>看起来进行浮升路由事件，但实际上是以间接方式。</span><span class="sxs-lookup"><span data-stu-id="f4180-1313">The <xref:System.Windows.ContentElement.MouseLeftButtonDown> event appears to travel a bubbling route but actually travels in an indirect way.</span></span> <span data-ttu-id="f4180-1314"><xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType> 是基础事件是冒泡路由，并且每个<xref:System.Windows.ContentElement>沿着事件路由使用相同的处理引发的直接路由的事件<xref:System.Windows.ContentElement.MouseLeftButtonDown>。</span><span class="sxs-lookup"><span data-stu-id="f4180-1314"><xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType> is the underlying event that is bubble routed, and each <xref:System.Windows.ContentElement> along the event route uses identical handling to raise the direct routed event <xref:System.Windows.ContentElement.MouseLeftButtonDown>.</span></span> <span data-ttu-id="f4180-1315">尽管可以将标记<xref:System.Windows.ContentElement.MouseLeftButtonDown>为此元素的已处理的事件，处理的状态不会不保留到其他元素为由事件路由。</span><span class="sxs-lookup"><span data-stu-id="f4180-1315">Although you can mark the <xref:System.Windows.ContentElement.MouseLeftButtonDown> event as handled for purposes of this element, the handled state does not perpetuate to other elements along the event route.</span></span> <span data-ttu-id="f4180-1316">但是，你可能想要将事件标记为已处理以防止常规实例处理程序 (未指定的那些`handledEventsToo`) 调用。</span><span class="sxs-lookup"><span data-stu-id="f4180-1316">However, you might want to mark the event as handled in order to prevent general instance handlers (those that did not specify `handledEventsToo`) from being invoked.</span></span>  
  
 <span data-ttu-id="f4180-1317">常规鼠标事件处理中的默认实现<xref:System.Windows.ContentElement>侦听<xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType>并将其转换为相应的本地事件。</span><span class="sxs-lookup"><span data-stu-id="f4180-1317">The default implementation for general mouse event handling in <xref:System.Windows.ContentElement> listens for <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType> and converts it to an appropriate local event.</span></span> <span data-ttu-id="f4180-1318">如果你想要覆盖此逻辑，必须创建派生的类。</span><span class="sxs-lookup"><span data-stu-id="f4180-1318">If you want to override this logic, you must create a derived class.</span></span> <span data-ttu-id="f4180-1319">在派生类的静态构造函数，将注册的替代类处理程序<xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="f4180-1319">In the static constructor of your derived class, register an alternative class handler for <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType>.</span></span> <span data-ttu-id="f4180-1320">不能更改处理行为的鼠标<xref:System.Windows.ContentElement>通过重写<xref:System.Windows.ContentElement.OnMouseLeftButtonDown%2A>。</span><span class="sxs-lookup"><span data-stu-id="f4180-1320">You cannot change the mouse handling behavior of <xref:System.Windows.ContentElement> by overriding <xref:System.Windows.ContentElement.OnMouseLeftButtonDown%2A>.</span></span>  
  
 <span data-ttu-id="f4180-1321">或者，可以以更改的事件处理特定的鼠标状态来重写此方法。</span><span class="sxs-lookup"><span data-stu-id="f4180-1321">Alternatively, you can override this method in order to change event handling for a specific mouse state.</span></span> <span data-ttu-id="f4180-1322">您是否选择调用基实现取决于你的方案。</span><span class="sxs-lookup"><span data-stu-id="f4180-1322">Whether you choose to call the base implementation depends on your scenario.</span></span> <span data-ttu-id="f4180-1323">未能调用基禁用默认为基实现，也应调用该鼠标事件的输入的处理<xref:System.Windows.ContentElement.OnMouseLeftButtonDown%2A>。</span><span class="sxs-lookup"><span data-stu-id="f4180-1323">Failing to call base disables default input handling for that mouse event on ancestor classes that also expect to invoke <xref:System.Windows.ContentElement.OnMouseLeftButtonDown%2A>.</span></span> <span data-ttu-id="f4180-1324">例如，您可以从其中<xref:System.Windows.Controls.Button>并重写<xref:System.Windows.ContentElement.OnMouseLeftButtonDown%2A>在派生类而不会调用基实现; 但是，此重写禁用<xref:System.Windows.Controls.Primitives.ButtonBase.Click>事件。</span><span class="sxs-lookup"><span data-stu-id="f4180-1324">For example, you can derive from <xref:System.Windows.Controls.Button> and override <xref:System.Windows.ContentElement.OnMouseLeftButtonDown%2A> in your derived class without calling the base implementation; however, this override disables the <xref:System.Windows.Controls.Primitives.ButtonBase.Click> event.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnMouseLeftButtonUp">
      <MemberSignature Language="C#" Value="protected internal virtual void OnMouseLeftButtonUp (System.Windows.Input.MouseButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnMouseLeftButtonUp(class System.Windows.Input.MouseButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnMouseLeftButtonUp(System.Windows.Input.MouseButtonEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnMouseLeftButtonUp (e As MouseButtonEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnMouseLeftButtonUp(System::Windows::Input::MouseButtonEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnMouseLeftButtonUp : System.Windows.Input.MouseButtonEventArgs -&gt; unit&#xA;override this.OnMouseLeftButtonUp : System.Windows.Input.MouseButtonEventArgs -&gt; unit" Usage="contentElement.OnMouseLeftButtonUp e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="f4180-1325">包含事件数据的 <see cref="T:System.Windows.Input.MouseButtonEventArgs" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-1325">The <see cref="T:System.Windows.Input.MouseButtonEventArgs" /> that contains the event data.</span>
          </span>
          <span data-ttu-id="f4180-1326">事件数据报告称已松开鼠标左键。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-1326">The event data reports that the left mouse button was released.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f4180-1327">当某个未处理的 <see cref="E:System.Windows.ContentElement.MouseLeftButtonUp" /> 路由事件在其路由中到达派生自此类的某个元素时调用。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-1327">Invoked when an unhandled <see cref="E:System.Windows.ContentElement.MouseLeftButtonUp" /> routed event reaches an element in its route that is derived from this class.</span>
          </span>
          <span data-ttu-id="f4180-1328">实现此方法可为此事件添加类处理。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-1328">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4180-1329"><xref:System.Windows.ContentElement.MouseLeftButtonUp>看起来进行浮升路由事件，但实际上是以间接方式。</span><span class="sxs-lookup"><span data-stu-id="f4180-1329">The <xref:System.Windows.ContentElement.MouseLeftButtonUp> event appears to travel a bubbling route but actually travels in an indirect way.</span></span> <span data-ttu-id="f4180-1330"><xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType> 是基础事件是冒泡路由，并且每个<xref:System.Windows.ContentElement>沿着事件路由使用相同的处理引发的直接路由的事件<xref:System.Windows.ContentElement.MouseLeftButtonUp>。</span><span class="sxs-lookup"><span data-stu-id="f4180-1330"><xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType> is the underlying event that is bubble routed, and each <xref:System.Windows.ContentElement> along the event route uses identical handling to raise the direct routed event <xref:System.Windows.ContentElement.MouseLeftButtonUp>.</span></span> <span data-ttu-id="f4180-1331">尽管可以将标记<xref:System.Windows.ContentElement.MouseLeftButtonUp>为此元素的已处理的事件，处理的状态不会不保留到其他元素为由事件路由。</span><span class="sxs-lookup"><span data-stu-id="f4180-1331">Although you can mark the <xref:System.Windows.ContentElement.MouseLeftButtonUp> event as handled for purposes of this element, the handled state does not perpetuate to other elements along the event route.</span></span> <span data-ttu-id="f4180-1332">但是，你可能想要将事件标记为已处理以防止常规实例处理程序 (未指定的那些`handledEventsToo`) 调用。</span><span class="sxs-lookup"><span data-stu-id="f4180-1332">However, you might want to mark the event as handled in order to prevent general instance handlers (those that did not specify `handledEventsToo`) from being invoked.</span></span>  
  
 <span data-ttu-id="f4180-1333">常规鼠标事件处理中的默认实现<xref:System.Windows.ContentElement>侦听<xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType>并将其转换为相应的本地事件。</span><span class="sxs-lookup"><span data-stu-id="f4180-1333">The default implementation for general mouse event handling in <xref:System.Windows.ContentElement> listens for <xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType> and converts it to an appropriate local event.</span></span> <span data-ttu-id="f4180-1334">如果你想要覆盖此逻辑，必须创建派生的类。</span><span class="sxs-lookup"><span data-stu-id="f4180-1334">If you want to override this logic, you must create a derived class.</span></span> <span data-ttu-id="f4180-1335">在派生类的静态构造函数，将注册的替代类处理程序<xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="f4180-1335">In the static constructor of your derived class, register an alternative class handler for <xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType>.</span></span> <span data-ttu-id="f4180-1336">不能更改处理行为的鼠标<xref:System.Windows.ContentElement>通过重写<xref:System.Windows.ContentElement.OnMouseLeftButtonUp%2A>。</span><span class="sxs-lookup"><span data-stu-id="f4180-1336">You cannot change the mouse handling behavior of <xref:System.Windows.ContentElement> by overriding <xref:System.Windows.ContentElement.OnMouseLeftButtonUp%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnMouseMove">
      <MemberSignature Language="C#" Value="protected internal virtual void OnMouseMove (System.Windows.Input.MouseEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnMouseMove(class System.Windows.Input.MouseEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnMouseMove(System.Windows.Input.MouseEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnMouseMove (e As MouseEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnMouseMove(System::Windows::Input::MouseEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnMouseMove : System.Windows.Input.MouseEventArgs -&gt; unit&#xA;override this.OnMouseMove : System.Windows.Input.MouseEventArgs -&gt; unit" Usage="contentElement.OnMouseMove e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="f4180-1337">包含事件数据的 <see cref="T:System.Windows.Input.MouseEventArgs" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-1337">The <see cref="T:System.Windows.Input.MouseEventArgs" /> that contains the event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f4180-1338">当某个未处理的 <see cref="E:System.Windows.Input.Mouse.MouseMove" /> 附加事件在其路由中到达派生自此类的某个元素时调用。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-1338">Invoked when an unhandled <see cref="E:System.Windows.Input.Mouse.MouseMove" /> attached event reaches an element in its route that is derived from this class.</span>
          </span>
          <span data-ttu-id="f4180-1339">实现此方法可为此事件添加类处理。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-1339">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4180-1340">此方法具有默认实现。</span><span class="sxs-lookup"><span data-stu-id="f4180-1340">This method has no default implementation.</span></span> <span data-ttu-id="f4180-1341">因为中间类继承中的可能会实现此方法，我们建议在实现中调用基实现。</span><span class="sxs-lookup"><span data-stu-id="f4180-1341">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="f4180-1342">此方法的用途是类似于[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]事件模式 On \* 方法： 此方法提供了通过建立类处理程序而不是实例处理程序来处理从派生类的匹配事件的方法。</span><span class="sxs-lookup"><span data-stu-id="f4180-1342">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="f4180-1343">在这种情况下匹配事件是路由的事件。</span><span class="sxs-lookup"><span data-stu-id="f4180-1343">In this case the matching event is a routed event.</span></span> <span data-ttu-id="f4180-1344">On \* 方法的实现模式是不同的路由事件，因为可以由子元素，它不一定是将调用处理程序的元素引发路由的事件。</span><span class="sxs-lookup"><span data-stu-id="f4180-1344">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="f4180-1345">因此，您的实现需要检查的事件数据源属性。</span><span class="sxs-lookup"><span data-stu-id="f4180-1345">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="f4180-1346">它不应尝试再次引发该事件在大多数情况下。</span><span class="sxs-lookup"><span data-stu-id="f4180-1346">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="f4180-1347">通过重写此方法或通过注册类处理程序替换<xref:System.Windows.EventManager.RegisterClassHandler%2A>，派生类的<xref:System.Windows.ContentElement>为由事件路由收到事件时，可以调用私有类处理程序方法。</span><span class="sxs-lookup"><span data-stu-id="f4180-1347">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="f4180-1348">类处理是相应的一种方案是操作事件数据并将路由的事件标记为已处理。</span><span class="sxs-lookup"><span data-stu-id="f4180-1348">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.MouseMove" />
      </Docs>
    </Member>
    <Member MemberName="OnMouseRightButtonDown">
      <MemberSignature Language="C#" Value="protected internal virtual void OnMouseRightButtonDown (System.Windows.Input.MouseButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnMouseRightButtonDown(class System.Windows.Input.MouseButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnMouseRightButtonDown(System.Windows.Input.MouseButtonEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnMouseRightButtonDown (e As MouseButtonEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnMouseRightButtonDown(System::Windows::Input::MouseButtonEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnMouseRightButtonDown : System.Windows.Input.MouseButtonEventArgs -&gt; unit&#xA;override this.OnMouseRightButtonDown : System.Windows.Input.MouseButtonEventArgs -&gt; unit" Usage="contentElement.OnMouseRightButtonDown e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="f4180-1349">包含事件数据的 <see cref="T:System.Windows.Input.MouseButtonEventArgs" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-1349">The <see cref="T:System.Windows.Input.MouseButtonEventArgs" /> that contains the event data.</span>
          </span>
          <span data-ttu-id="f4180-1350">事件数据报告称已按下鼠标右键。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-1350">The event data reports that the right mouse button was pressed.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f4180-1351">当某个未处理的 <see cref="E:System.Windows.ContentElement.MouseRightButtonDown" /> 路由事件在其路由中到达派生自此类的某个元素时调用。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-1351">Invoked when an unhandled <see cref="E:System.Windows.ContentElement.MouseRightButtonDown" /> routed event reaches an element in its route that is derived from this class.</span>
          </span>
          <span data-ttu-id="f4180-1352">实现此方法可为此事件添加类处理。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-1352">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4180-1353"><xref:System.Windows.ContentElement.MouseRightButtonDown>看起来进行浮升路由事件，但实际上是以间接方式。</span><span class="sxs-lookup"><span data-stu-id="f4180-1353">The <xref:System.Windows.ContentElement.MouseRightButtonDown> event appears to travel a bubbling route but actually travels in an indirect way.</span></span> <span data-ttu-id="f4180-1354"><xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType> 是基础事件是冒泡路由，并且每个<xref:System.Windows.ContentElement>沿着事件路由使用相同的处理引发的直接路由的事件<xref:System.Windows.ContentElement.MouseRightButtonDown>。</span><span class="sxs-lookup"><span data-stu-id="f4180-1354"><xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType> is the underlying event that is bubble routed, and each <xref:System.Windows.ContentElement> along the event route uses identical handling to raise the direct routed event <xref:System.Windows.ContentElement.MouseRightButtonDown>.</span></span> <span data-ttu-id="f4180-1355">尽管可以将标记<xref:System.Windows.ContentElement.MouseRightButtonDown>为此元素的已处理的事件，处理的状态不会不保留到其他元素为由事件路由。</span><span class="sxs-lookup"><span data-stu-id="f4180-1355">Although you can mark the <xref:System.Windows.ContentElement.MouseRightButtonDown> event as handled for purposes of this element, the handled state does not perpetuate to other elements along the event route.</span></span> <span data-ttu-id="f4180-1356">但是，你可能想要将事件标记为已处理以防止常规实例处理程序 (未指定的那些`handledEventsToo`) 调用。</span><span class="sxs-lookup"><span data-stu-id="f4180-1356">However, you might want to mark the event as handled in order to prevent general instance handlers (those that did not specify `handledEventsToo`) from being invoked.</span></span>  
  
 <span data-ttu-id="f4180-1357">常规鼠标事件处理中的默认实现<xref:System.Windows.ContentElement>侦听<xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType>并将其转换为相应的本地事件。</span><span class="sxs-lookup"><span data-stu-id="f4180-1357">The default implementation for general mouse event handling in <xref:System.Windows.ContentElement> listens for <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType> and converts it to an appropriate local event.</span></span> <span data-ttu-id="f4180-1358">如果你想要覆盖此逻辑，必须创建派生的类。</span><span class="sxs-lookup"><span data-stu-id="f4180-1358">If you want to override this logic, you must create a derived class.</span></span> <span data-ttu-id="f4180-1359">在派生类的静态构造函数，将注册的替代类处理程序<xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="f4180-1359">In the static constructor of your derived class, register an alternative class handler for <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType>.</span></span> <span data-ttu-id="f4180-1360">不能更改处理行为的鼠标<xref:System.Windows.ContentElement>通过重写<xref:System.Windows.ContentElement.OnMouseRightButtonDown%2A>。</span><span class="sxs-lookup"><span data-stu-id="f4180-1360">You cannot change the mouse handling behavior of <xref:System.Windows.ContentElement> by overriding <xref:System.Windows.ContentElement.OnMouseRightButtonDown%2A>.</span></span>  
  
 <span data-ttu-id="f4180-1361">或者，可以以更改的事件处理特定的鼠标状态来重写此方法。</span><span class="sxs-lookup"><span data-stu-id="f4180-1361">Alternatively, you can override this method in order to change event handling for a specific mouse state.</span></span> <span data-ttu-id="f4180-1362">您是否选择调用基实现取决于你的方案。</span><span class="sxs-lookup"><span data-stu-id="f4180-1362">Whether you choose to call the base implementation depends on your scenario.</span></span> <span data-ttu-id="f4180-1363">未能调用基禁用默认为基实现，也应调用该鼠标事件的输入的处理<xref:System.Windows.ContentElement.OnMouseRightButtonDown%2A>。</span><span class="sxs-lookup"><span data-stu-id="f4180-1363">Failing to call base disables default input handling for that mouse event on ancestor classes that also expect to invoke <xref:System.Windows.ContentElement.OnMouseRightButtonDown%2A>.</span></span> <span data-ttu-id="f4180-1364">例如，您可以从其中<xref:System.Windows.Controls.Control>并重写<xref:System.Windows.ContentElement.OnMouseRightButtonDown%2A>但是，而无需调用基实现; 在派生类中此替代禁用上下文菜单上的服务控件，都是一部分的<xref:System.Windows.Controls.Control>默认行为。</span><span class="sxs-lookup"><span data-stu-id="f4180-1364">For example, you can derive from <xref:System.Windows.Controls.Control> and override <xref:System.Windows.ContentElement.OnMouseRightButtonDown%2A> in your derived class without calling base; however, this override disables the context menu services on your control, which are part of the <xref:System.Windows.Controls.Control> default behavior.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnMouseRightButtonUp">
      <MemberSignature Language="C#" Value="protected internal virtual void OnMouseRightButtonUp (System.Windows.Input.MouseButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnMouseRightButtonUp(class System.Windows.Input.MouseButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnMouseRightButtonUp(System.Windows.Input.MouseButtonEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnMouseRightButtonUp (e As MouseButtonEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnMouseRightButtonUp(System::Windows::Input::MouseButtonEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnMouseRightButtonUp : System.Windows.Input.MouseButtonEventArgs -&gt; unit&#xA;override this.OnMouseRightButtonUp : System.Windows.Input.MouseButtonEventArgs -&gt; unit" Usage="contentElement.OnMouseRightButtonUp e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="f4180-1365">包含事件数据的 <see cref="T:System.Windows.Input.MouseButtonEventArgs" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-1365">The <see cref="T:System.Windows.Input.MouseButtonEventArgs" /> that contains the event data.</span>
          </span>
          <span data-ttu-id="f4180-1366">事件数据报告称已释放鼠标右键。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-1366">The event data reports that the right mouse button was released.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f4180-1367">当某个未处理的 <see cref="E:System.Windows.ContentElement.MouseRightButtonUp" /> 路由事件在其路由中到达派生自此类的某个元素时调用。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-1367">Invoked when an unhandled <see cref="E:System.Windows.ContentElement.MouseRightButtonUp" /> routed event reaches an element in its route that is derived from this class.</span>
          </span>
          <span data-ttu-id="f4180-1368">实现此方法可为此事件添加类处理。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-1368">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4180-1369"><xref:System.Windows.ContentElement.MouseRightButtonUp>看起来进行浮升路由事件，但实际上是以间接方式。</span><span class="sxs-lookup"><span data-stu-id="f4180-1369">The <xref:System.Windows.ContentElement.MouseRightButtonUp> event appears to travel a bubbling route but actually travels in an indirect way.</span></span> <span data-ttu-id="f4180-1370"><xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType> 是基础事件是冒泡路由，并且每个<xref:System.Windows.ContentElement>沿着事件路由使用相同的处理引发的直接路由的事件<xref:System.Windows.ContentElement.MouseRightButtonUp>。</span><span class="sxs-lookup"><span data-stu-id="f4180-1370"><xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType> is the underlying event that is bubble routed, and each <xref:System.Windows.ContentElement> along the event route uses identical handling to raise the direct routed event <xref:System.Windows.ContentElement.MouseRightButtonUp>.</span></span> <span data-ttu-id="f4180-1371">尽管可以将标记<xref:System.Windows.ContentElement.MouseRightButtonUp>为此元素的已处理的事件，处理的状态不会不保留到其他元素为由事件路由。</span><span class="sxs-lookup"><span data-stu-id="f4180-1371">Although you can mark the <xref:System.Windows.ContentElement.MouseRightButtonUp> event as handled for purposes of this element, the handled state does not perpetuate to other elements along the event route.</span></span> <span data-ttu-id="f4180-1372">但是，你可能想要将事件标记为已处理以防止常规实例处理程序 (未指定的那些`handledEventsToo`) 调用。</span><span class="sxs-lookup"><span data-stu-id="f4180-1372">However, you might want to mark the event as handled in order to prevent general instance handlers (those that did not specify `handledEventsToo`) from being invoked.</span></span>  
  
 <span data-ttu-id="f4180-1373">常规鼠标事件处理中的默认实现<xref:System.Windows.ContentElement>侦听<xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType>并将其转换为相应的本地事件。</span><span class="sxs-lookup"><span data-stu-id="f4180-1373">The default implementation for general mouse event handling in <xref:System.Windows.ContentElement> listens for <xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType> and converts it to an appropriate local event.</span></span> <span data-ttu-id="f4180-1374">如果你想要覆盖此逻辑，必须创建派生的类。</span><span class="sxs-lookup"><span data-stu-id="f4180-1374">If you want to override this logic, you must create a derived class.</span></span> <span data-ttu-id="f4180-1375">在派生类的静态构造函数，将注册的替代类处理程序<xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="f4180-1375">In the static constructor of your derived class, register an alternative class handler for <xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType>.</span></span> <span data-ttu-id="f4180-1376">不能更改处理行为的鼠标<xref:System.Windows.ContentElement>通过重写<xref:System.Windows.ContentElement.OnMouseRightButtonUp%2A>。</span><span class="sxs-lookup"><span data-stu-id="f4180-1376">You cannot change the mouse handling behavior of <xref:System.Windows.ContentElement> by overriding <xref:System.Windows.ContentElement.OnMouseRightButtonUp%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnMouseUp">
      <MemberSignature Language="C#" Value="protected internal virtual void OnMouseUp (System.Windows.Input.MouseButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnMouseUp(class System.Windows.Input.MouseButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnMouseUp(System.Windows.Input.MouseButtonEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnMouseUp (e As MouseButtonEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnMouseUp(System::Windows::Input::MouseButtonEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnMouseUp : System.Windows.Input.MouseButtonEventArgs -&gt; unit&#xA;override this.OnMouseUp : System.Windows.Input.MouseButtonEventArgs -&gt; unit" Usage="contentElement.OnMouseUp e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="f4180-1377">包含事件数据的 <see cref="T:System.Windows.Input.MouseButtonEventArgs" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-1377">The <see cref="T:System.Windows.Input.MouseButtonEventArgs" /> that contains the event data.</span>
          </span>
          <span data-ttu-id="f4180-1378">事件数据将报告已松开了鼠标按钮。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-1378">The event data reports that the mouse button was released.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f4180-1379">当某个未处理的 <see cref="E:System.Windows.Input.Mouse.MouseUp" /> 路由事件在其路由中到达派生自此类的某个元素时调用。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-1379">Invoked when an unhandled <see cref="E:System.Windows.Input.Mouse.MouseUp" /> routed event reaches an element in its route that is derived from this class.</span>
          </span>
          <span data-ttu-id="f4180-1380">实现此方法可为此事件添加类处理。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-1380">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4180-1381">处理鼠标按钮操作也是通过专用的输入管理器。</span><span class="sxs-lookup"><span data-stu-id="f4180-1381">Mouse button actions are also handled by a dedicated input manager.</span></span> <span data-ttu-id="f4180-1382">公开为常规鼠标按钮操作之前，其他编程功能，依赖于鼠标按钮操作，例如输入和命令绑定，可能会调用处理程序的操作。</span><span class="sxs-lookup"><span data-stu-id="f4180-1382">Other programming features that rely on mouse button actions, such as input and command bindings, might invoke handlers for the action before it is exposed as a general mouse button action.</span></span> <span data-ttu-id="f4180-1383">如果这些输入系统功能标记<xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType>事件处理，如<xref:System.Windows.ContentElement.OnMouseUp%2A>不调用。</span><span class="sxs-lookup"><span data-stu-id="f4180-1383">If these input system features mark the <xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType> event as handled, <xref:System.Windows.ContentElement.OnMouseUp%2A> is not invoked.</span></span>  
  
 <span data-ttu-id="f4180-1384">如果使用此类处理程序将事件标记为已处理，则可能会影响以下事件：<xref:System.Windows.ContentElement.MouseLeftButtonUp>和<xref:System.Windows.ContentElement.MouseRightButtonUp>。</span><span class="sxs-lookup"><span data-stu-id="f4180-1384">If you use this class handler to mark the event as handled, you potentially impact the following events: <xref:System.Windows.ContentElement.MouseLeftButtonUp> and <xref:System.Windows.ContentElement.MouseRightButtonUp>.</span></span> <span data-ttu-id="f4180-1385">上述任一事件可能会在接收元素上引发时<xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType>收到。</span><span class="sxs-lookup"><span data-stu-id="f4180-1385">Either of these events might be raised on the receiving element when <xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType> is received.</span></span>  
  
 <span data-ttu-id="f4180-1386">如果标记为已处理的类中处理此事件，则仍会引发子事件;但是，它们通过中的事件数据的处理的状态。</span><span class="sxs-lookup"><span data-stu-id="f4180-1386">If you mark this event as handled in class handling, subevents are still raised; however, they pass the handled state in the event data.</span></span> <span data-ttu-id="f4180-1387">除非您显式使用类处理在处理该事件时，如果不调用为子事件的实例处理<xref:System.Windows.ContentElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29>与`handledEventsToo``true`才能附加处理程序。</span><span class="sxs-lookup"><span data-stu-id="f4180-1387">If the event is handled in class handling, instance handlers for the subevents are not invoked unless you explicitly use <xref:System.Windows.ContentElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> with `handledEventsToo` `true` in order to attach handlers.</span></span> <span data-ttu-id="f4180-1388">类处理程序也不会调用与注册了这些类处理程序，除非<xref:System.Windows.EventManager.RegisterClassHandler%28System.Type%2CSystem.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29>带签名`handledEventsToo` `true`。</span><span class="sxs-lookup"><span data-stu-id="f4180-1388">Class handlers also are not invoked unless those class handlers were registered with the <xref:System.Windows.EventManager.RegisterClassHandler%28System.Type%2CSystem.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> signature with `handledEventsToo` `true`.</span></span> <span data-ttu-id="f4180-1389">通过处理<xref:System.Windows.ContentElement.OnMouseUp%2A>，则意味着类处理负责操作的所有可能的鼠标按钮。</span><span class="sxs-lookup"><span data-stu-id="f4180-1389">By handling <xref:System.Windows.ContentElement.OnMouseUp%2A>, you are implying that your class handling accounted for all possible mouse button up actions.</span></span> <span data-ttu-id="f4180-1390">此行为可能不需要;因此，此虚拟方法用于将事件标记为已处理时要格外小心。</span><span class="sxs-lookup"><span data-stu-id="f4180-1390">This behavior might be unwanted; Therefore, use caution when you use this virtual method to mark events as handled.</span></span>  
  
 <span data-ttu-id="f4180-1391">每个特定于按钮的直接事件也有一个虚拟 On \* 方法;请考虑是否重写这些特定于按钮的类处理程序可能会更合适。</span><span class="sxs-lookup"><span data-stu-id="f4180-1391">Each of the button-specific direct events also has a virtual On\* method; consider whether overriding these button-specific class handlers might be more appropriate.</span></span>  
  
 <span data-ttu-id="f4180-1392">此方法具有默认实现。</span><span class="sxs-lookup"><span data-stu-id="f4180-1392">This method has no default implementation.</span></span> <span data-ttu-id="f4180-1393">因为中间类继承中的可能会实现此方法，我们建议在实现中调用基实现。</span><span class="sxs-lookup"><span data-stu-id="f4180-1393">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="f4180-1394">此方法的用途是类似于[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]事件模式 On \* 方法： 此方法提供了通过建立类处理程序而不是实例处理程序来处理从派生类的匹配事件的方法。</span><span class="sxs-lookup"><span data-stu-id="f4180-1394">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="f4180-1395">在这种情况下匹配事件是路由的事件。</span><span class="sxs-lookup"><span data-stu-id="f4180-1395">In this case the matching event is a routed event.</span></span> <span data-ttu-id="f4180-1396">On \* 方法的实现模式是不同的路由事件，因为可以由子元素，它不一定是将调用处理程序的元素引发路由的事件。</span><span class="sxs-lookup"><span data-stu-id="f4180-1396">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="f4180-1397">因此，您的实现需要检查的事件数据源属性。</span><span class="sxs-lookup"><span data-stu-id="f4180-1397">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="f4180-1398">它不应尝试再次引发该事件在大多数情况下。</span><span class="sxs-lookup"><span data-stu-id="f4180-1398">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="f4180-1399">通过重写此方法或通过注册类处理程序替换<xref:System.Windows.EventManager.RegisterClassHandler%2A>，派生类的<xref:System.Windows.ContentElement>为由事件路由收到事件时，可以调用私有类处理程序方法。</span><span class="sxs-lookup"><span data-stu-id="f4180-1399">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="f4180-1400">类处理是相应的一种方案是操作事件数据并将路由的事件标记为已处理。</span><span class="sxs-lookup"><span data-stu-id="f4180-1400">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnMouseWheel">
      <MemberSignature Language="C#" Value="protected internal virtual void OnMouseWheel (System.Windows.Input.MouseWheelEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnMouseWheel(class System.Windows.Input.MouseWheelEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnMouseWheel(System.Windows.Input.MouseWheelEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnMouseWheel (e As MouseWheelEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnMouseWheel(System::Windows::Input::MouseWheelEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnMouseWheel : System.Windows.Input.MouseWheelEventArgs -&gt; unit&#xA;override this.OnMouseWheel : System.Windows.Input.MouseWheelEventArgs -&gt; unit" Usage="contentElement.OnMouseWheel e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseWheelEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="f4180-1401">包含事件数据的 <see cref="T:System.Windows.Input.MouseWheelEventArgs" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-1401">The <see cref="T:System.Windows.Input.MouseWheelEventArgs" /> that contains the event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f4180-1402">当某个未处理的 <see cref="E:System.Windows.Input.Mouse.MouseWheel" /> 附加事件在其路由中到达派生自此类的某个元素时调用。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-1402">Invoked when an unhandled <see cref="E:System.Windows.Input.Mouse.MouseWheel" /> attached event reaches an element in its route that is derived from this class.</span>
          </span>
          <span data-ttu-id="f4180-1403">实现此方法可为此事件添加类处理。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-1403">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4180-1404">此方法具有默认实现。</span><span class="sxs-lookup"><span data-stu-id="f4180-1404">This method has no default implementation.</span></span> <span data-ttu-id="f4180-1405">因为中间类继承中的可能会实现此方法，我们建议在实现中调用基实现。</span><span class="sxs-lookup"><span data-stu-id="f4180-1405">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="f4180-1406">此方法的用途是类似于[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]事件模式 On \* 方法： 此方法提供了通过建立类处理程序而不是实例处理程序来处理从派生类的匹配事件的方法。</span><span class="sxs-lookup"><span data-stu-id="f4180-1406">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="f4180-1407">在这种情况下匹配事件是路由的事件。</span><span class="sxs-lookup"><span data-stu-id="f4180-1407">In this case the matching event is a routed event.</span></span> <span data-ttu-id="f4180-1408">On \* 方法的实现模式是不同的路由事件，因为可以由子元素，它不一定是将调用处理程序的元素引发路由的事件。</span><span class="sxs-lookup"><span data-stu-id="f4180-1408">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="f4180-1409">因此，您的实现需要检查的事件数据源属性。</span><span class="sxs-lookup"><span data-stu-id="f4180-1409">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="f4180-1410">它不应尝试再次引发该事件在大多数情况下。</span><span class="sxs-lookup"><span data-stu-id="f4180-1410">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="f4180-1411">通过重写此方法或通过注册类处理程序替换<xref:System.Windows.EventManager.RegisterClassHandler%2A>，派生类的<xref:System.Windows.ContentElement>为由事件路由收到事件时，可以调用私有类处理程序方法。</span><span class="sxs-lookup"><span data-stu-id="f4180-1411">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="f4180-1412">类处理是相应的一种方案是操作事件数据并将路由的事件标记为已处理。</span><span class="sxs-lookup"><span data-stu-id="f4180-1412">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.MouseWheel" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewDragEnter">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewDragEnter (System.Windows.DragEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewDragEnter(class System.Windows.DragEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewDragEnter(System.Windows.DragEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewDragEnter (e As DragEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewDragEnter(System::Windows::DragEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewDragEnter : System.Windows.DragEventArgs -&gt; unit&#xA;override this.OnPreviewDragEnter : System.Windows.DragEventArgs -&gt; unit" Usage="contentElement.OnPreviewDragEnter e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DragEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="f4180-1413">包含事件数据的 <see cref="T:System.Windows.DragEventArgs" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-1413">The <see cref="T:System.Windows.DragEventArgs" /> that contains the event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f4180-1414">当某个未处理的 <see cref="E:System.Windows.DragDrop.PreviewDragEnter" /> 附加事件在其路由中到达派生自此类的某个元素时调用。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-1414">Invoked when an unhandled <see cref="E:System.Windows.DragDrop.PreviewDragEnter" /> attached event reaches an element in its route that is derived from this class.</span>
          </span>
          <span data-ttu-id="f4180-1415">实现此方法可为此事件添加类处理。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-1415">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4180-1416">此方法具有默认实现。</span><span class="sxs-lookup"><span data-stu-id="f4180-1416">This method has no default implementation.</span></span> <span data-ttu-id="f4180-1417">因为中间类继承中的可能会实现此方法，我们建议在实现中调用基实现。</span><span class="sxs-lookup"><span data-stu-id="f4180-1417">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="f4180-1418">此方法的用途是类似于[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]事件模式 On \* 方法： 此方法提供了通过建立类处理程序而不是实例处理程序来处理从派生类的匹配事件的方法。</span><span class="sxs-lookup"><span data-stu-id="f4180-1418">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="f4180-1419">在这种情况下匹配事件是路由的事件。</span><span class="sxs-lookup"><span data-stu-id="f4180-1419">In this case the matching event is a routed event.</span></span> <span data-ttu-id="f4180-1420">On \* 方法的实现模式是不同的路由事件，因为可以由子元素，它不一定是将调用处理程序的元素引发路由的事件。</span><span class="sxs-lookup"><span data-stu-id="f4180-1420">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="f4180-1421">因此，您的实现需要检查的事件数据源属性。</span><span class="sxs-lookup"><span data-stu-id="f4180-1421">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="f4180-1422">它不应尝试再次引发该事件在大多数情况下。</span><span class="sxs-lookup"><span data-stu-id="f4180-1422">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="f4180-1423">通过重写此方法或通过注册类处理程序替换<xref:System.Windows.EventManager.RegisterClassHandler%2A>，派生类的<xref:System.Windows.ContentElement>为由事件路由收到事件时，可以调用私有类处理程序方法。</span><span class="sxs-lookup"><span data-stu-id="f4180-1423">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="f4180-1424">类处理是相应的一种方案是操作事件数据并将路由的事件标记为已处理。</span><span class="sxs-lookup"><span data-stu-id="f4180-1424">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span> <span data-ttu-id="f4180-1425">专用于预览事件的另一个方案是将已处理，以便匹配冒泡类处理程序不会调用其标记。</span><span class="sxs-lookup"><span data-stu-id="f4180-1425">Another scenario that is specifically for Preview events is to mark them handled so that the matching bubbling class handlers are not invoked.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewDragEnter" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewDragLeave">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewDragLeave (System.Windows.DragEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewDragLeave(class System.Windows.DragEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewDragLeave(System.Windows.DragEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewDragLeave (e As DragEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewDragLeave(System::Windows::DragEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewDragLeave : System.Windows.DragEventArgs -&gt; unit&#xA;override this.OnPreviewDragLeave : System.Windows.DragEventArgs -&gt; unit" Usage="contentElement.OnPreviewDragLeave e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DragEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="f4180-1426">包含事件数据的 <see cref="T:System.Windows.DragEventArgs" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-1426">The <see cref="T:System.Windows.DragEventArgs" /> that contains the event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f4180-1427">当某个未处理的 <see cref="E:System.Windows.DragDrop.PreviewDragLeave" /> 附加事件在其路由中到达派生自此类的某个元素时调用。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-1427">Invoked when an unhandled <see cref="E:System.Windows.DragDrop.PreviewDragLeave" /> attached event reaches an element in its route that is derived from this class.</span>
          </span>
          <span data-ttu-id="f4180-1428">实现此方法可为此事件添加类处理。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-1428">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4180-1429">此方法具有默认实现。</span><span class="sxs-lookup"><span data-stu-id="f4180-1429">This method has no default implementation.</span></span> <span data-ttu-id="f4180-1430">因为中间类继承中的可能会实现此方法，我们建议在实现中调用基实现。</span><span class="sxs-lookup"><span data-stu-id="f4180-1430">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="f4180-1431">此方法的用途是类似于[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]事件模式 On \* 方法： 此方法提供了通过建立类处理程序而不是实例处理程序来处理从派生类的匹配事件的方法。</span><span class="sxs-lookup"><span data-stu-id="f4180-1431">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="f4180-1432">在这种情况下匹配事件是路由的事件。</span><span class="sxs-lookup"><span data-stu-id="f4180-1432">In this case the matching event is a routed event.</span></span> <span data-ttu-id="f4180-1433">On \* 方法的实现模式是不同的路由事件，因为可以由子元素，它不一定是将调用处理程序的元素引发路由的事件。</span><span class="sxs-lookup"><span data-stu-id="f4180-1433">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="f4180-1434">因此，您的实现需要检查的事件数据源属性。</span><span class="sxs-lookup"><span data-stu-id="f4180-1434">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="f4180-1435">它不应尝试再次引发该事件在大多数情况下。</span><span class="sxs-lookup"><span data-stu-id="f4180-1435">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="f4180-1436">通过重写此方法或通过注册类处理程序替换<xref:System.Windows.EventManager.RegisterClassHandler%2A>，派生类的<xref:System.Windows.ContentElement>为由事件路由收到事件时，可以调用私有类处理程序方法。</span><span class="sxs-lookup"><span data-stu-id="f4180-1436">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="f4180-1437">类处理是相应的一种方案是操作事件数据并将路由的事件标记为已处理。</span><span class="sxs-lookup"><span data-stu-id="f4180-1437">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span> <span data-ttu-id="f4180-1438">专用于预览事件的另一个方案是将已处理，以便匹配冒泡类处理程序不会调用其标记。</span><span class="sxs-lookup"><span data-stu-id="f4180-1438">Another scenario that is specifically for Preview events is to mark them handled so that the matching bubbling class handlers are not invoked.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewDragLeave" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewDragOver">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewDragOver (System.Windows.DragEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewDragOver(class System.Windows.DragEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewDragOver(System.Windows.DragEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewDragOver (e As DragEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewDragOver(System::Windows::DragEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewDragOver : System.Windows.DragEventArgs -&gt; unit&#xA;override this.OnPreviewDragOver : System.Windows.DragEventArgs -&gt; unit" Usage="contentElement.OnPreviewDragOver e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DragEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="f4180-1439">包含事件数据的 <see cref="T:System.Windows.DragEventArgs" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-1439">The <see cref="T:System.Windows.DragEventArgs" /> that contains the event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f4180-1440">当某个未处理的 <see cref="E:System.Windows.DragDrop.PreviewDragOver" /> 附加事件在其路由中到达派生自此类的某个元素时调用。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-1440">Invoked when an unhandled <see cref="E:System.Windows.DragDrop.PreviewDragOver" /> attached event reaches an element in its route that is derived from this class.</span>
          </span>
          <span data-ttu-id="f4180-1441">实现此方法可为此事件添加类处理。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-1441">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4180-1442">此方法具有默认实现。</span><span class="sxs-lookup"><span data-stu-id="f4180-1442">This method has no default implementation.</span></span> <span data-ttu-id="f4180-1443">因为中间类继承中的可能会实现此方法，我们建议在实现中调用基实现。</span><span class="sxs-lookup"><span data-stu-id="f4180-1443">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="f4180-1444">此方法的用途是类似于[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]事件模式 On \* 方法： 此方法提供了通过建立类处理程序而不是实例处理程序来处理从派生类的匹配事件的方法。</span><span class="sxs-lookup"><span data-stu-id="f4180-1444">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="f4180-1445">在这种情况下匹配事件是路由的事件。</span><span class="sxs-lookup"><span data-stu-id="f4180-1445">In this case the matching event is a routed event.</span></span> <span data-ttu-id="f4180-1446">On \* 方法的实现模式是不同的路由事件，因为可以由子元素，它不一定是将调用处理程序的元素引发路由的事件。</span><span class="sxs-lookup"><span data-stu-id="f4180-1446">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="f4180-1447">因此，您的实现需要检查的事件数据源属性。</span><span class="sxs-lookup"><span data-stu-id="f4180-1447">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="f4180-1448">它不应尝试再次引发该事件在大多数情况下。</span><span class="sxs-lookup"><span data-stu-id="f4180-1448">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="f4180-1449">通过重写此方法或通过注册类处理程序替换<xref:System.Windows.EventManager.RegisterClassHandler%2A>，派生类的<xref:System.Windows.ContentElement>为由事件路由收到事件时，可以调用私有类处理程序方法。</span><span class="sxs-lookup"><span data-stu-id="f4180-1449">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="f4180-1450">类处理是相应的一种方案是操作事件数据并将路由的事件标记为已处理。</span><span class="sxs-lookup"><span data-stu-id="f4180-1450">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span> <span data-ttu-id="f4180-1451">专用于预览事件的另一个方案是将已处理，以便匹配冒泡类处理程序不会调用其标记。</span><span class="sxs-lookup"><span data-stu-id="f4180-1451">Another scenario that is specifically for Preview events is to mark them handled so that the matching bubbling class handlers are not invoked.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewDragOver" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewDrop">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewDrop (System.Windows.DragEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewDrop(class System.Windows.DragEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewDrop(System.Windows.DragEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewDrop (e As DragEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewDrop(System::Windows::DragEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewDrop : System.Windows.DragEventArgs -&gt; unit&#xA;override this.OnPreviewDrop : System.Windows.DragEventArgs -&gt; unit" Usage="contentElement.OnPreviewDrop e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DragEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="f4180-1452">包含事件数据的 <see cref="T:System.Windows.DragEventArgs" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-1452">The <see cref="T:System.Windows.DragEventArgs" /> that contains the event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f4180-1453">当某个未处理的 <see cref="E:System.Windows.DragDrop.PreviewDrop" /> 附加事件在其路由中到达派生自此类的某个元素时调用。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-1453">Invoked when an unhandled <see cref="E:System.Windows.DragDrop.PreviewDrop" /> attached event reaches an element in its route that is derived from this class.</span>
          </span>
          <span data-ttu-id="f4180-1454">实现此方法可为此事件添加类处理。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-1454">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4180-1455">此方法具有默认实现。</span><span class="sxs-lookup"><span data-stu-id="f4180-1455">This method has no default implementation.</span></span> <span data-ttu-id="f4180-1456">因为中间类继承中的可能会实现此方法，我们建议在实现中调用基实现。</span><span class="sxs-lookup"><span data-stu-id="f4180-1456">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="f4180-1457">此方法的用途是类似于[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]事件模式 On \* 方法： 此方法提供了通过建立类处理程序而不是实例处理程序来处理从派生类的匹配事件的方法。</span><span class="sxs-lookup"><span data-stu-id="f4180-1457">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="f4180-1458">在这种情况下匹配事件是路由的事件。</span><span class="sxs-lookup"><span data-stu-id="f4180-1458">In this case the matching event is a routed event.</span></span> <span data-ttu-id="f4180-1459">On \* 方法的实现模式是不同的路由事件，因为可以由子元素，它不一定是将调用处理程序的元素引发路由的事件。</span><span class="sxs-lookup"><span data-stu-id="f4180-1459">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="f4180-1460">因此，您的实现需要检查的事件数据源属性。</span><span class="sxs-lookup"><span data-stu-id="f4180-1460">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="f4180-1461">它不应尝试再次引发该事件在大多数情况下。</span><span class="sxs-lookup"><span data-stu-id="f4180-1461">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="f4180-1462">通过重写此方法或通过注册类处理程序替换<xref:System.Windows.EventManager.RegisterClassHandler%2A>，派生类的<xref:System.Windows.ContentElement>为由事件路由收到事件时，可以调用私有类处理程序方法。</span><span class="sxs-lookup"><span data-stu-id="f4180-1462">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="f4180-1463">类处理是相应的一种方案是操作事件数据并将路由的事件标记为已处理。</span><span class="sxs-lookup"><span data-stu-id="f4180-1463">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span> <span data-ttu-id="f4180-1464">专用于预览事件的另一个方案是将已处理，以便匹配冒泡类处理程序不会调用其标记。</span><span class="sxs-lookup"><span data-stu-id="f4180-1464">Another scenario that is specifically for Preview events is to mark them handled so that the matching bubbling class handlers are not invoked.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewDrop" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewGiveFeedback">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewGiveFeedback (System.Windows.GiveFeedbackEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewGiveFeedback(class System.Windows.GiveFeedbackEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewGiveFeedback(System.Windows.GiveFeedbackEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewGiveFeedback (e As GiveFeedbackEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewGiveFeedback(System::Windows::GiveFeedbackEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewGiveFeedback : System.Windows.GiveFeedbackEventArgs -&gt; unit&#xA;override this.OnPreviewGiveFeedback : System.Windows.GiveFeedbackEventArgs -&gt; unit" Usage="contentElement.OnPreviewGiveFeedback e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.GiveFeedbackEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="f4180-1465">包含事件数据的 <see cref="T:System.Windows.GiveFeedbackEventArgs" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-1465">The <see cref="T:System.Windows.GiveFeedbackEventArgs" /> that contains the event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f4180-1466">当某个未处理的 <see cref="E:System.Windows.DragDrop.PreviewGiveFeedback" /> 附加事件在其路由中到达派生自此类的某个元素时调用。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-1466">Invoked when an unhandled <see cref="E:System.Windows.DragDrop.PreviewGiveFeedback" /> attached event reaches an element in its route that is derived from this class.</span>
          </span>
          <span data-ttu-id="f4180-1467">实现此方法可为此事件添加类处理。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-1467">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4180-1468">此方法具有默认实现。</span><span class="sxs-lookup"><span data-stu-id="f4180-1468">This method has no default implementation.</span></span> <span data-ttu-id="f4180-1469">因为中间类继承中的可能会实现此方法，我们建议在实现中调用基实现。</span><span class="sxs-lookup"><span data-stu-id="f4180-1469">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="f4180-1470">此方法的用途是类似于[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]事件模式 On \* 方法： 此方法提供了通过建立类处理程序而不是实例处理程序来处理从派生类的匹配事件的方法。</span><span class="sxs-lookup"><span data-stu-id="f4180-1470">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="f4180-1471">在这种情况下匹配事件是路由的事件。</span><span class="sxs-lookup"><span data-stu-id="f4180-1471">In this case the matching event is a routed event.</span></span> <span data-ttu-id="f4180-1472">On \* 方法的实现模式是不同的路由事件，因为可以由子元素，它不一定是将调用处理程序的元素引发路由的事件。</span><span class="sxs-lookup"><span data-stu-id="f4180-1472">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="f4180-1473">因此，您的实现需要检查的事件数据源属性。</span><span class="sxs-lookup"><span data-stu-id="f4180-1473">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="f4180-1474">它不应尝试再次引发该事件在大多数情况下。</span><span class="sxs-lookup"><span data-stu-id="f4180-1474">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="f4180-1475">通过重写此方法或通过注册类处理程序替换<xref:System.Windows.EventManager.RegisterClassHandler%2A>，派生类的<xref:System.Windows.ContentElement>为由事件路由收到事件时，可以调用私有类处理程序方法。</span><span class="sxs-lookup"><span data-stu-id="f4180-1475">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="f4180-1476">类处理是相应的一种方案是操作事件数据并将路由的事件标记为已处理。</span><span class="sxs-lookup"><span data-stu-id="f4180-1476">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span> <span data-ttu-id="f4180-1477">专用于预览事件的另一个方案是将已处理，以便匹配冒泡类处理程序不会调用其标记。</span><span class="sxs-lookup"><span data-stu-id="f4180-1477">Another scenario that is specifically for Preview events is to mark them handled so that the matching bubbling class handlers are not invoked.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewGiveFeedback" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewGotKeyboardFocus">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewGotKeyboardFocus (System.Windows.Input.KeyboardFocusChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewGotKeyboardFocus(class System.Windows.Input.KeyboardFocusChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewGotKeyboardFocus(System.Windows.Input.KeyboardFocusChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewGotKeyboardFocus (e As KeyboardFocusChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewGotKeyboardFocus(System::Windows::Input::KeyboardFocusChangedEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewGotKeyboardFocus : System.Windows.Input.KeyboardFocusChangedEventArgs -&gt; unit&#xA;override this.OnPreviewGotKeyboardFocus : System.Windows.Input.KeyboardFocusChangedEventArgs -&gt; unit" Usage="contentElement.OnPreviewGotKeyboardFocus e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.KeyboardFocusChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="f4180-1478">包含事件数据的 <see cref="T:System.Windows.Input.KeyboardFocusChangedEventArgs" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-1478">The <see cref="T:System.Windows.Input.KeyboardFocusChangedEventArgs" /> that contains the event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f4180-1479">当某个未处理的 <see cref="E:System.Windows.Input.Keyboard.PreviewGotKeyboardFocus" /> 附加事件在其路由中到达派生自此类的某个元素时调用。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-1479">Invoked when an unhandled <see cref="E:System.Windows.Input.Keyboard.PreviewGotKeyboardFocus" /> attached event reaches an element in its route that is derived from this class.</span>
          </span>
          <span data-ttu-id="f4180-1480">实现此方法可为此事件添加类处理。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-1480">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4180-1481">此方法具有默认实现。</span><span class="sxs-lookup"><span data-stu-id="f4180-1481">This method has no default implementation.</span></span> <span data-ttu-id="f4180-1482">因为中间类继承中的可能会实现此方法，我们建议在实现中调用基实现。</span><span class="sxs-lookup"><span data-stu-id="f4180-1482">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="f4180-1483">此方法的用途是类似于[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]事件模式 On \* 方法： 此方法提供了通过建立类处理程序而不是实例处理程序来处理从派生类的匹配事件的方法。</span><span class="sxs-lookup"><span data-stu-id="f4180-1483">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="f4180-1484">在这种情况下匹配事件是路由的事件。</span><span class="sxs-lookup"><span data-stu-id="f4180-1484">In this case the matching event is a routed event.</span></span> <span data-ttu-id="f4180-1485">On \* 方法的实现模式是不同的路由事件，因为可以由子元素，它不一定是将调用处理程序的元素引发路由的事件。</span><span class="sxs-lookup"><span data-stu-id="f4180-1485">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="f4180-1486">因此，您的实现需要检查的事件数据源属性。</span><span class="sxs-lookup"><span data-stu-id="f4180-1486">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="f4180-1487">它不应尝试再次引发该事件在大多数情况下。</span><span class="sxs-lookup"><span data-stu-id="f4180-1487">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="f4180-1488">通过重写此方法或通过注册类处理程序替换<xref:System.Windows.EventManager.RegisterClassHandler%2A>，派生类的<xref:System.Windows.ContentElement>为由事件路由收到事件时，可以调用私有类处理程序方法。</span><span class="sxs-lookup"><span data-stu-id="f4180-1488">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="f4180-1489">类处理是相应的一种方案是操作事件数据并将路由的事件标记为已处理。</span><span class="sxs-lookup"><span data-stu-id="f4180-1489">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span> <span data-ttu-id="f4180-1490">专用于预览事件的另一个方案是将已处理，以便匹配冒泡类处理程序不会调用其标记。</span><span class="sxs-lookup"><span data-stu-id="f4180-1490">Another scenario that is specifically for Preview events is to mark them handled so that the matching bubbling class handlers are not invoked.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewGotKeyboardFocus" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewKeyDown">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewKeyDown (System.Windows.Input.KeyEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewKeyDown(class System.Windows.Input.KeyEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewKeyDown(System.Windows.Input.KeyEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewKeyDown (e As KeyEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewKeyDown(System::Windows::Input::KeyEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewKeyDown : System.Windows.Input.KeyEventArgs -&gt; unit&#xA;override this.OnPreviewKeyDown : System.Windows.Input.KeyEventArgs -&gt; unit" Usage="contentElement.OnPreviewKeyDown e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.KeyEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="f4180-1491">包含事件数据的 <see cref="T:System.Windows.Input.KeyEventArgs" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-1491">The <see cref="T:System.Windows.Input.KeyEventArgs" /> that contains the event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f4180-1492">当某个未处理的 <see cref="E:System.Windows.Input.Keyboard.PreviewKeyDown" /> 附加事件在其路由中到达派生自此类的某个元素时调用。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-1492">Invoked when an unhandled <see cref="E:System.Windows.Input.Keyboard.PreviewKeyDown" /> attached event reaches an element in its route that is derived from this class.</span>
          </span>
          <span data-ttu-id="f4180-1493">实现此方法可为此事件添加类处理。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-1493">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4180-1494">此方法具有默认实现。</span><span class="sxs-lookup"><span data-stu-id="f4180-1494">This method has no default implementation.</span></span> <span data-ttu-id="f4180-1495">因为中间类继承中的可能会实现此方法，我们建议在实现中调用基实现。</span><span class="sxs-lookup"><span data-stu-id="f4180-1495">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="f4180-1496">此方法的用途是类似于[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]事件模式 On \* 方法： 此方法提供了通过建立类处理程序而不是实例处理程序来处理从派生类的匹配事件的方法。</span><span class="sxs-lookup"><span data-stu-id="f4180-1496">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="f4180-1497">在这种情况下匹配事件是路由的事件。</span><span class="sxs-lookup"><span data-stu-id="f4180-1497">In this case the matching event is a routed event.</span></span> <span data-ttu-id="f4180-1498">On \* 方法的实现模式是不同的路由事件，因为可以由子元素，它不一定是将调用处理程序的元素引发路由的事件。</span><span class="sxs-lookup"><span data-stu-id="f4180-1498">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="f4180-1499">因此，您的实现需要检查的事件数据源属性。</span><span class="sxs-lookup"><span data-stu-id="f4180-1499">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="f4180-1500">它不应尝试再次引发该事件在大多数情况下。</span><span class="sxs-lookup"><span data-stu-id="f4180-1500">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="f4180-1501">通过重写此方法或通过注册类处理程序替换<xref:System.Windows.EventManager.RegisterClassHandler%2A>，派生类的<xref:System.Windows.ContentElement>为由事件路由收到事件时，可以调用私有类处理程序方法。</span><span class="sxs-lookup"><span data-stu-id="f4180-1501">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="f4180-1502">类处理是相应的一种方案是操作事件数据并将路由的事件标记为已处理。</span><span class="sxs-lookup"><span data-stu-id="f4180-1502">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span> <span data-ttu-id="f4180-1503">专用于预览事件的另一个方案是将已处理，以便匹配冒泡类处理程序不会调用其标记。</span><span class="sxs-lookup"><span data-stu-id="f4180-1503">Another scenario that is specifically for Preview events is to mark them handled so that the matching bubbling class handlers are not invoked.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewKeyDown" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewKeyUp">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewKeyUp (System.Windows.Input.KeyEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewKeyUp(class System.Windows.Input.KeyEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewKeyUp(System.Windows.Input.KeyEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewKeyUp (e As KeyEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewKeyUp(System::Windows::Input::KeyEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewKeyUp : System.Windows.Input.KeyEventArgs -&gt; unit&#xA;override this.OnPreviewKeyUp : System.Windows.Input.KeyEventArgs -&gt; unit" Usage="contentElement.OnPreviewKeyUp e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.KeyEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="f4180-1504">包含事件数据的 <see cref="T:System.Windows.Input.KeyEventArgs" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-1504">The <see cref="T:System.Windows.Input.KeyEventArgs" /> that contains the event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f4180-1505">当某个未处理的 <see cref="E:System.Windows.Input.Keyboard.PreviewKeyUp" /> 附加事件在其路由中到达派生自此类的某个元素时调用。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-1505">Invoked when an unhandled <see cref="E:System.Windows.Input.Keyboard.PreviewKeyUp" /> attached event reaches an element in its route that is derived from this class.</span>
          </span>
          <span data-ttu-id="f4180-1506">实现此方法可为此事件添加类处理。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-1506">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4180-1507">此方法具有默认实现。</span><span class="sxs-lookup"><span data-stu-id="f4180-1507">This method has no default implementation.</span></span> <span data-ttu-id="f4180-1508">因为中间类继承中的可能会实现此方法，我们建议在实现中调用基实现。</span><span class="sxs-lookup"><span data-stu-id="f4180-1508">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="f4180-1509">此方法的用途是类似于[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]事件模式 On \* 方法： 此方法提供了通过建立类处理程序而不是实例处理程序来处理从派生类的匹配事件的方法。</span><span class="sxs-lookup"><span data-stu-id="f4180-1509">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="f4180-1510">在这种情况下匹配事件是路由的事件。</span><span class="sxs-lookup"><span data-stu-id="f4180-1510">In this case the matching event is a routed event.</span></span> <span data-ttu-id="f4180-1511">On \* 方法的实现模式是不同的路由事件，因为可以由子元素，它不一定是将调用处理程序的元素引发路由的事件。</span><span class="sxs-lookup"><span data-stu-id="f4180-1511">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="f4180-1512">因此，您的实现需要检查的事件数据源属性。</span><span class="sxs-lookup"><span data-stu-id="f4180-1512">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="f4180-1513">它不应尝试再次引发该事件在大多数情况下。</span><span class="sxs-lookup"><span data-stu-id="f4180-1513">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="f4180-1514">通过重写此方法或通过注册类处理程序替换<xref:System.Windows.EventManager.RegisterClassHandler%2A>，派生类的<xref:System.Windows.ContentElement>为由事件路由收到事件时，可以调用私有类处理程序方法。</span><span class="sxs-lookup"><span data-stu-id="f4180-1514">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="f4180-1515">类处理是相应的一种方案是操作事件数据并将路由的事件标记为已处理。</span><span class="sxs-lookup"><span data-stu-id="f4180-1515">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span> <span data-ttu-id="f4180-1516">专用于预览事件的另一个方案是将已处理，以便匹配冒泡类处理程序不会调用其标记。</span><span class="sxs-lookup"><span data-stu-id="f4180-1516">Another scenario that is specifically for Preview events is to mark them handled so that the matching bubbling class handlers are not invoked.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewKeyUp" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewLostKeyboardFocus">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewLostKeyboardFocus (System.Windows.Input.KeyboardFocusChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewLostKeyboardFocus(class System.Windows.Input.KeyboardFocusChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewLostKeyboardFocus(System.Windows.Input.KeyboardFocusChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewLostKeyboardFocus (e As KeyboardFocusChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewLostKeyboardFocus(System::Windows::Input::KeyboardFocusChangedEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewLostKeyboardFocus : System.Windows.Input.KeyboardFocusChangedEventArgs -&gt; unit&#xA;override this.OnPreviewLostKeyboardFocus : System.Windows.Input.KeyboardFocusChangedEventArgs -&gt; unit" Usage="contentElement.OnPreviewLostKeyboardFocus e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.KeyboardFocusChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="f4180-1517">包含事件数据的 <see cref="T:System.Windows.Input.KeyboardFocusChangedEventArgs" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-1517">The <see cref="T:System.Windows.Input.KeyboardFocusChangedEventArgs" /> that contains the event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f4180-1518">当某个未处理的 <see cref="E:System.Windows.Input.Keyboard.PreviewKeyDown" /> 附加事件在其路由中到达派生自此类的某个元素时调用。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-1518">Invoked when an unhandled <see cref="E:System.Windows.Input.Keyboard.PreviewKeyDown" /> attached event reaches an element in its route that is derived from this class.</span>
          </span>
          <span data-ttu-id="f4180-1519">实现此方法可为此事件添加类处理。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-1519">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4180-1520">此方法具有默认实现。</span><span class="sxs-lookup"><span data-stu-id="f4180-1520">This method has no default implementation.</span></span> <span data-ttu-id="f4180-1521">因为中间类继承中的可能会实现此方法，我们建议在实现中调用基实现。</span><span class="sxs-lookup"><span data-stu-id="f4180-1521">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="f4180-1522">此方法的用途是类似于[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]事件模式 On \* 方法： 此方法提供了通过建立类处理程序而不是实例处理程序来处理从派生类的匹配事件的方法。</span><span class="sxs-lookup"><span data-stu-id="f4180-1522">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="f4180-1523">在这种情况下匹配事件是路由的事件。</span><span class="sxs-lookup"><span data-stu-id="f4180-1523">In this case the matching event is a routed event.</span></span> <span data-ttu-id="f4180-1524">On \* 方法的实现模式是不同的路由事件，因为可以由子元素，它不一定是将调用处理程序的元素引发路由的事件。</span><span class="sxs-lookup"><span data-stu-id="f4180-1524">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="f4180-1525">因此，您的实现需要检查的事件数据源属性。</span><span class="sxs-lookup"><span data-stu-id="f4180-1525">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="f4180-1526">它不应尝试再次引发该事件在大多数情况下。</span><span class="sxs-lookup"><span data-stu-id="f4180-1526">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="f4180-1527">通过重写此方法或通过注册类处理程序替换<xref:System.Windows.EventManager.RegisterClassHandler%2A>，派生类的<xref:System.Windows.ContentElement>为由事件路由收到事件时，可以调用私有类处理程序方法。</span><span class="sxs-lookup"><span data-stu-id="f4180-1527">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="f4180-1528">类处理是相应的一种方案是操作事件数据并将路由的事件标记为已处理。</span><span class="sxs-lookup"><span data-stu-id="f4180-1528">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span> <span data-ttu-id="f4180-1529">专用于预览事件的另一个方案是将已处理，以便匹配冒泡类处理程序不会调用其标记。</span><span class="sxs-lookup"><span data-stu-id="f4180-1529">Another scenario that is specifically for Preview events is to mark them handled so that the matching bubbling class handlers are not invoked.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewLostKeyboardFocus" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewMouseDown">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewMouseDown (System.Windows.Input.MouseButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewMouseDown(class System.Windows.Input.MouseButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewMouseDown(System.Windows.Input.MouseButtonEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewMouseDown (e As MouseButtonEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewMouseDown(System::Windows::Input::MouseButtonEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewMouseDown : System.Windows.Input.MouseButtonEventArgs -&gt; unit&#xA;override this.OnPreviewMouseDown : System.Windows.Input.MouseButtonEventArgs -&gt; unit" Usage="contentElement.OnPreviewMouseDown e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="f4180-1530">包含事件数据的 <see cref="T:System.Windows.Input.MouseButtonEventArgs" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-1530">The <see cref="T:System.Windows.Input.MouseButtonEventArgs" /> that contains the event data.</span>
          </span>
          <span data-ttu-id="f4180-1531">事件数据报告称已按下一个或多个鼠标按钮。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-1531">The event data reports that one or more mouse buttons were pressed.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f4180-1532">当某个未处理的 <see cref="E:System.Windows.Input.Mouse.PreviewMouseDown" /> 附加路由事件在其路由中到达派生自此类的某个元素时调用。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-1532">Invoked when an unhandled <see cref="E:System.Windows.Input.Mouse.PreviewMouseDown" /> attached routed event reaches an element in its route that is derived from this class.</span>
          </span>
          <span data-ttu-id="f4180-1533">实现此方法可为此事件添加类处理。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-1533">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4180-1534">处理鼠标按钮操作也是通过专用的输入管理器。</span><span class="sxs-lookup"><span data-stu-id="f4180-1534">Mouse button actions are also handled by a dedicated input manager.</span></span> <span data-ttu-id="f4180-1535">公开为常规鼠标按钮操作之前，其他编程功能，依赖于鼠标按钮操作，例如输入和命令绑定，可能会调用处理程序的操作。</span><span class="sxs-lookup"><span data-stu-id="f4180-1535">Other programming features that rely on mouse button actions, such as input and command bindings, might invoke handlers for the action before it is exposed as a general mouse button action.</span></span> <span data-ttu-id="f4180-1536">如果这些输入系统功能标记<xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType>事件处理，如<xref:System.Windows.ContentElement.OnPreviewMouseDown%2A>不调用。</span><span class="sxs-lookup"><span data-stu-id="f4180-1536">If these input system features mark the <xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType> event as handled, <xref:System.Windows.ContentElement.OnPreviewMouseDown%2A> is not invoked.</span></span>  
  
 <span data-ttu-id="f4180-1537">如果使用此类处理程序将事件标记为已处理，则可能会影响以下事件：<xref:System.Windows.ContentElement.PreviewMouseLeftButtonDown>和<xref:System.Windows.ContentElement.PreviewMouseRightButtonDown>。</span><span class="sxs-lookup"><span data-stu-id="f4180-1537">If you use this class handler to mark the event as handled, you potentially impact the following events: <xref:System.Windows.ContentElement.PreviewMouseLeftButtonDown> and <xref:System.Windows.ContentElement.PreviewMouseRightButtonDown>.</span></span> <span data-ttu-id="f4180-1538">上述任一事件可能会在接收元素上引发时<xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType>收到。</span><span class="sxs-lookup"><span data-stu-id="f4180-1538">Either of these events may be raised on the receiving element when <xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType> is received.</span></span>  
  
 <span data-ttu-id="f4180-1539">如果标记为已处理的类中处理此事件，则仍会引发子事件;但是，它们通过中的事件数据的处理的状态。</span><span class="sxs-lookup"><span data-stu-id="f4180-1539">If you mark this event as handled in class handling, subevents are still raised; however, they pass the handled state in the event data.</span></span> <span data-ttu-id="f4180-1540">除非您显式使用类处理在处理该事件时，如果不调用为子事件的实例处理<xref:System.Windows.ContentElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29>与`handledEventsToo``true`才能附加处理程序。</span><span class="sxs-lookup"><span data-stu-id="f4180-1540">If the event is handled in class handling, instance handlers for the subevents are not invoked unless you explicitly use <xref:System.Windows.ContentElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> with `handledEventsToo` `true` in order to attach handlers.</span></span> <span data-ttu-id="f4180-1541">类处理程序也不会调用与注册了这些类处理程序，除非<xref:System.Windows.EventManager.RegisterClassHandler%28System.Type%2CSystem.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29>带签名`handledEventsToo` `true`。</span><span class="sxs-lookup"><span data-stu-id="f4180-1541">Class handlers also are not invoked unless those class handlers were registered with the <xref:System.Windows.EventManager.RegisterClassHandler%28System.Type%2CSystem.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> signature with `handledEventsToo` `true`.</span></span> <span data-ttu-id="f4180-1542">通过处理<xref:System.Windows.ContentElement.OnPreviewMouseDown%2A>，则意味着你类处理负责所有可能的鼠标按钮按下操作。</span><span class="sxs-lookup"><span data-stu-id="f4180-1542">By handling <xref:System.Windows.ContentElement.OnPreviewMouseDown%2A>, you are implying that your class handling accounted for all possible mouse button down actions.</span></span> <span data-ttu-id="f4180-1543">此行为可能不需要;因此，此虚拟方法用于将事件标记为已处理时要格外小心。</span><span class="sxs-lookup"><span data-stu-id="f4180-1543">This behavior might be unwanted; Therefore, use caution when you use this virtual method to mark events as handled.</span></span>  
  
 <span data-ttu-id="f4180-1544">每个特定于按钮的直接事件也有一个虚拟 On \* 方法;请考虑是否重写这些特定于按钮的类处理程序可能会更合适。</span><span class="sxs-lookup"><span data-stu-id="f4180-1544">Each of the button-specific direct events also has a virtual On\* method; consider whether overriding these button-specific class handlers might be more appropriate.</span></span>  
  
 <span data-ttu-id="f4180-1545">此方法具有默认实现。</span><span class="sxs-lookup"><span data-stu-id="f4180-1545">This method has no default implementation.</span></span> <span data-ttu-id="f4180-1546">因为中间类继承中的可能会实现此方法，我们建议在实现中调用基实现。</span><span class="sxs-lookup"><span data-stu-id="f4180-1546">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="f4180-1547">此方法的用途是类似于[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]事件模式 On \* 方法： 此方法提供了通过建立类处理程序而不是实例处理程序来处理从派生类的匹配事件的方法。</span><span class="sxs-lookup"><span data-stu-id="f4180-1547">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="f4180-1548">在这种情况下匹配事件是路由的事件。</span><span class="sxs-lookup"><span data-stu-id="f4180-1548">In this case the matching event is a routed event.</span></span> <span data-ttu-id="f4180-1549">On \* 方法的实现模式是不同的路由事件，因为可以由子元素，它不一定是将调用处理程序的元素引发路由的事件。</span><span class="sxs-lookup"><span data-stu-id="f4180-1549">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="f4180-1550">因此，您的实现需要检查的事件数据源属性。</span><span class="sxs-lookup"><span data-stu-id="f4180-1550">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="f4180-1551">它不应尝试再次引发该事件在大多数情况下。</span><span class="sxs-lookup"><span data-stu-id="f4180-1551">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="f4180-1552">通过重写此方法或通过注册类处理程序替换<xref:System.Windows.EventManager.RegisterClassHandler%2A>，派生类的<xref:System.Windows.ContentElement>为由事件路由收到事件时，可以调用私有类处理程序方法。</span><span class="sxs-lookup"><span data-stu-id="f4180-1552">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="f4180-1553">类处理是相应的一种方案是操作事件数据并将路由的事件标记为已处理。</span><span class="sxs-lookup"><span data-stu-id="f4180-1553">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span> <span data-ttu-id="f4180-1554">专用于预览事件的另一个方案是将已处理，以便匹配冒泡类处理程序不会调用其标记。</span><span class="sxs-lookup"><span data-stu-id="f4180-1554">Another scenario that is specifically for Preview events is to mark them handled so that the matching bubbling class handlers are not invoked.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewMouseDown" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewMouseLeftButtonDown">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewMouseLeftButtonDown (System.Windows.Input.MouseButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewMouseLeftButtonDown(class System.Windows.Input.MouseButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewMouseLeftButtonDown(System.Windows.Input.MouseButtonEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewMouseLeftButtonDown (e As MouseButtonEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewMouseLeftButtonDown(System::Windows::Input::MouseButtonEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewMouseLeftButtonDown : System.Windows.Input.MouseButtonEventArgs -&gt; unit&#xA;override this.OnPreviewMouseLeftButtonDown : System.Windows.Input.MouseButtonEventArgs -&gt; unit" Usage="contentElement.OnPreviewMouseLeftButtonDown e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="f4180-1555">包含事件数据的 <see cref="T:System.Windows.Input.MouseButtonEventArgs" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-1555">The <see cref="T:System.Windows.Input.MouseButtonEventArgs" /> that contains the event data.</span>
          </span>
          <span data-ttu-id="f4180-1556">事件数据报告称已按下鼠标左键。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-1556">The event data reports that the left mouse button was pressed.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f4180-1557">当某个未处理的 <see cref="E:System.Windows.ContentElement.PreviewMouseLeftButtonDown" /> 路由事件在其路由中到达派生自此类的某个元素时调用。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-1557">Invoked when an unhandled <see cref="E:System.Windows.ContentElement.PreviewMouseLeftButtonDown" /> routed event reaches an element in its route that is derived from this class.</span>
          </span>
          <span data-ttu-id="f4180-1558">实现此方法可为此事件添加类处理。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-1558">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4180-1559"><xref:System.Windows.ContentElement.PreviewMouseLeftButtonDown>事件看起来进行隧道路由，但实际上是以间接方式。</span><span class="sxs-lookup"><span data-stu-id="f4180-1559">The <xref:System.Windows.ContentElement.PreviewMouseLeftButtonDown> event appears to travel a tunneling route but actually travels in an indirect way.</span></span> <span data-ttu-id="f4180-1560"><xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType> 是的基础事件是隧道路由，并且每个<xref:System.Windows.ContentElement>沿着事件路由使用相同的处理引发的直接路由的事件<xref:System.Windows.ContentElement.PreviewMouseLeftButtonDown>。</span><span class="sxs-lookup"><span data-stu-id="f4180-1560"><xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType> is the underlying event that is tunnel routed, and each <xref:System.Windows.ContentElement> along the event route uses identical handling to raise the direct routed event <xref:System.Windows.ContentElement.PreviewMouseLeftButtonDown>.</span></span> <span data-ttu-id="f4180-1561">尽管可以将标记<xref:System.Windows.ContentElement.PreviewMouseLeftButtonDown>为此元素的已处理的事件，处理的状态不会不保留到其他元素为由事件路由。</span><span class="sxs-lookup"><span data-stu-id="f4180-1561">Although you can mark the <xref:System.Windows.ContentElement.PreviewMouseLeftButtonDown> event as handled for purposes of this element, the handled state does not perpetuate to other elements along the event route.</span></span> <span data-ttu-id="f4180-1562">但是，你可能想要将事件标记为已处理以防止常规实例处理程序 (未指定的那些`handledEventsToo`) 调用。</span><span class="sxs-lookup"><span data-stu-id="f4180-1562">However, you might want to mark the event as handled in order to prevent general instance handlers (those that did not specify `handledEventsToo`) from being invoked.</span></span>  
  
 <span data-ttu-id="f4180-1563">常规鼠标事件处理中的默认实现<xref:System.Windows.ContentElement>侦听<xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType>并将其转换为相应的本地事件。</span><span class="sxs-lookup"><span data-stu-id="f4180-1563">The default implementation for general mouse event handling in <xref:System.Windows.ContentElement> listens for <xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType> and converts it to an appropriate local event.</span></span> <span data-ttu-id="f4180-1564">如果你想要覆盖此逻辑，必须创建派生的类。</span><span class="sxs-lookup"><span data-stu-id="f4180-1564">If you want to override this logic, you must create a derived class.</span></span> <span data-ttu-id="f4180-1565">在派生类的静态构造函数，将注册的替代类处理程序<xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="f4180-1565">In the static constructor of your derived class, register an alternative class handler for <xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType>.</span></span> <span data-ttu-id="f4180-1566">不能更改处理行为的鼠标<xref:System.Windows.ContentElement>通过重写<xref:System.Windows.ContentElement.OnPreviewMouseLeftButtonDown%2A>。</span><span class="sxs-lookup"><span data-stu-id="f4180-1566">You cannot change the mouse handling behavior of <xref:System.Windows.ContentElement> by overriding <xref:System.Windows.ContentElement.OnPreviewMouseLeftButtonDown%2A>.</span></span>  
  
 <span data-ttu-id="f4180-1567">或者，可以以更改的事件处理特定的鼠标状态来重写此方法。</span><span class="sxs-lookup"><span data-stu-id="f4180-1567">Alternatively, you can override this method in order to change event handling for a specific mouse state.</span></span> <span data-ttu-id="f4180-1568">您是否选择调用基实现取决于你的方案。</span><span class="sxs-lookup"><span data-stu-id="f4180-1568">Whether you choose to call the base implementation depends on your scenario.</span></span> <span data-ttu-id="f4180-1569">未能调用基禁用默认为基实现，也应调用该鼠标事件的输入的处理<xref:System.Windows.ContentElement.OnPreviewMouseLeftButtonDown%2A>。</span><span class="sxs-lookup"><span data-stu-id="f4180-1569">Failing to call base disables default input handling for that mouse event on ancestor classes that also expect to invoke <xref:System.Windows.ContentElement.OnPreviewMouseLeftButtonDown%2A>.</span></span> <span data-ttu-id="f4180-1570">例如，您可以从其中<xref:System.Windows.Controls.Button>并重写<xref:System.Windows.ContentElement.OnPreviewMouseLeftButtonDown%2A>在派生类而不会调用基实现; 但是，此重写禁用<xref:System.Windows.Controls.Primitives.ButtonBase.Click>事件。</span><span class="sxs-lookup"><span data-stu-id="f4180-1570">For example, you can derive from <xref:System.Windows.Controls.Button> and override <xref:System.Windows.ContentElement.OnPreviewMouseLeftButtonDown%2A> in your derived class without calling the base implementation; however, this override disables the <xref:System.Windows.Controls.Primitives.ButtonBase.Click> event.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnPreviewMouseLeftButtonUp">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewMouseLeftButtonUp (System.Windows.Input.MouseButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewMouseLeftButtonUp(class System.Windows.Input.MouseButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewMouseLeftButtonUp(System.Windows.Input.MouseButtonEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewMouseLeftButtonUp (e As MouseButtonEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewMouseLeftButtonUp(System::Windows::Input::MouseButtonEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewMouseLeftButtonUp : System.Windows.Input.MouseButtonEventArgs -&gt; unit&#xA;override this.OnPreviewMouseLeftButtonUp : System.Windows.Input.MouseButtonEventArgs -&gt; unit" Usage="contentElement.OnPreviewMouseLeftButtonUp e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="f4180-1571">包含事件数据的 <see cref="T:System.Windows.Input.MouseButtonEventArgs" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-1571">The <see cref="T:System.Windows.Input.MouseButtonEventArgs" /> that contains the event data.</span>
          </span>
          <span data-ttu-id="f4180-1572">事件数据报告称已松开鼠标左键。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-1572">The event data reports that the left mouse button was released.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f4180-1573">当某个未处理的 <see cref="E:System.Windows.ContentElement.PreviewMouseLeftButtonUp" /> 路由事件在其路由中到达派生自此类的某个元素时调用。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-1573">Invoked when an unhandled <see cref="E:System.Windows.ContentElement.PreviewMouseLeftButtonUp" /> routed event reaches an element in its route that is derived from this class.</span>
          </span>
          <span data-ttu-id="f4180-1574">实现此方法可为此事件添加类处理。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-1574">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4180-1575"><xref:System.Windows.ContentElement.PreviewMouseLeftButtonUp>事件看起来进行隧道路由，但实际上是以间接方式。</span><span class="sxs-lookup"><span data-stu-id="f4180-1575">The <xref:System.Windows.ContentElement.PreviewMouseLeftButtonUp> event appears to travel a tunneling route but actually travels in an indirect way.</span></span> <span data-ttu-id="f4180-1576"><xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType> 是的基础事件是隧道路由，并且每个<xref:System.Windows.ContentElement>沿着事件路由使用相同的处理引发的直接路由的事件<xref:System.Windows.ContentElement.PreviewMouseLeftButtonUp>。</span><span class="sxs-lookup"><span data-stu-id="f4180-1576"><xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType> is the underlying event that is tunnel routed, and each <xref:System.Windows.ContentElement> along the event route uses identical handling to raise the direct routed event <xref:System.Windows.ContentElement.PreviewMouseLeftButtonUp>.</span></span> <span data-ttu-id="f4180-1577">尽管可以将标记<xref:System.Windows.ContentElement.PreviewMouseLeftButtonUp>为此元素的已处理的事件，处理的状态不会不保留到其他元素为由事件路由。</span><span class="sxs-lookup"><span data-stu-id="f4180-1577">Although you can mark the <xref:System.Windows.ContentElement.PreviewMouseLeftButtonUp> event as handled for purposes of this element, the handled state does not perpetuate to other elements along the event route.</span></span> <span data-ttu-id="f4180-1578">但是，你可能想要将事件标记为已处理以防止常规实例处理程序 (未指定的那些`handledEventsToo`) 调用。</span><span class="sxs-lookup"><span data-stu-id="f4180-1578">However, you might want to mark the event as handled in order to prevent general instance handlers (those that did not specify `handledEventsToo`) from being invoked.</span></span>  
  
 <span data-ttu-id="f4180-1579">常规鼠标事件处理中的默认实现<xref:System.Windows.ContentElement>侦听<xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType>并将其转换为相应的本地事件。</span><span class="sxs-lookup"><span data-stu-id="f4180-1579">The default implementation for general mouse event handling in <xref:System.Windows.ContentElement> listens for <xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType> and converts it to an appropriate local event.</span></span> <span data-ttu-id="f4180-1580">如果你想要覆盖此逻辑，必须创建派生的类。</span><span class="sxs-lookup"><span data-stu-id="f4180-1580">If you want to override this logic, you must create a derived class.</span></span> <span data-ttu-id="f4180-1581">在派生类的静态构造函数，将注册的替代类处理程序<xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="f4180-1581">In the static constructor of your derived class, register an alternative class handler for <xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType>.</span></span> <span data-ttu-id="f4180-1582">不能更改处理行为的鼠标<xref:System.Windows.ContentElement>通过重写<xref:System.Windows.ContentElement.OnPreviewMouseLeftButtonUp%2A>。</span><span class="sxs-lookup"><span data-stu-id="f4180-1582">You cannot change the mouse handling behavior of <xref:System.Windows.ContentElement> by overriding <xref:System.Windows.ContentElement.OnPreviewMouseLeftButtonUp%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnPreviewMouseMove">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewMouseMove (System.Windows.Input.MouseEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewMouseMove(class System.Windows.Input.MouseEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewMouseMove(System.Windows.Input.MouseEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewMouseMove (e As MouseEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewMouseMove(System::Windows::Input::MouseEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewMouseMove : System.Windows.Input.MouseEventArgs -&gt; unit&#xA;override this.OnPreviewMouseMove : System.Windows.Input.MouseEventArgs -&gt; unit" Usage="contentElement.OnPreviewMouseMove e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="f4180-1583">包含事件数据的 <see cref="T:System.Windows.Input.MouseEventArgs" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-1583">The <see cref="T:System.Windows.Input.MouseEventArgs" /> that contains the event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f4180-1584">当某个未处理的 <see cref="E:System.Windows.Input.Mouse.PreviewMouseMove" /> 附加事件在其路由中到达派生自此类的某个元素时调用。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-1584">Invoked when an unhandled <see cref="E:System.Windows.Input.Mouse.PreviewMouseMove" /> attached event reaches an element in its route that is derived from this class.</span>
          </span>
          <span data-ttu-id="f4180-1585">实现此方法可为此事件添加类处理。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-1585">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4180-1586">此方法具有默认实现。</span><span class="sxs-lookup"><span data-stu-id="f4180-1586">This method has no default implementation.</span></span> <span data-ttu-id="f4180-1587">因为中间类继承中的可能会实现此方法，我们建议在实现中调用基实现。</span><span class="sxs-lookup"><span data-stu-id="f4180-1587">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="f4180-1588">此方法的用途是类似于[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]事件模式 On \* 方法： 此方法提供了通过建立类处理程序而不是实例处理程序来处理从派生类的匹配事件的方法。</span><span class="sxs-lookup"><span data-stu-id="f4180-1588">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="f4180-1589">在这种情况下匹配事件是路由的事件。</span><span class="sxs-lookup"><span data-stu-id="f4180-1589">In this case the matching event is a routed event.</span></span> <span data-ttu-id="f4180-1590">On \* 方法的实现模式是不同的路由事件，因为可以由子元素，它不一定是将调用处理程序的元素引发路由的事件。</span><span class="sxs-lookup"><span data-stu-id="f4180-1590">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="f4180-1591">因此，您的实现需要检查的事件数据源属性。</span><span class="sxs-lookup"><span data-stu-id="f4180-1591">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="f4180-1592">它不应尝试再次引发该事件在大多数情况下。</span><span class="sxs-lookup"><span data-stu-id="f4180-1592">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="f4180-1593">通过重写此方法或通过注册类处理程序替换<xref:System.Windows.EventManager.RegisterClassHandler%2A>，派生类的<xref:System.Windows.ContentElement>为由事件路由收到事件时，可以调用私有类处理程序方法。</span><span class="sxs-lookup"><span data-stu-id="f4180-1593">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="f4180-1594">类处理是相应的一种方案是操作事件数据并将路由的事件标记为已处理。</span><span class="sxs-lookup"><span data-stu-id="f4180-1594">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span> <span data-ttu-id="f4180-1595">专用于预览事件的另一个方案是将已处理，以便匹配冒泡类处理程序不会调用其标记。</span><span class="sxs-lookup"><span data-stu-id="f4180-1595">Another scenario that is specifically for Preview events is to mark them handled so that the matching bubbling class handlers are not invoked.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewMouseMove" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewMouseRightButtonDown">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewMouseRightButtonDown (System.Windows.Input.MouseButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewMouseRightButtonDown(class System.Windows.Input.MouseButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewMouseRightButtonDown(System.Windows.Input.MouseButtonEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewMouseRightButtonDown (e As MouseButtonEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewMouseRightButtonDown(System::Windows::Input::MouseButtonEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewMouseRightButtonDown : System.Windows.Input.MouseButtonEventArgs -&gt; unit&#xA;override this.OnPreviewMouseRightButtonDown : System.Windows.Input.MouseButtonEventArgs -&gt; unit" Usage="contentElement.OnPreviewMouseRightButtonDown e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="f4180-1596">包含事件数据的 <see cref="T:System.Windows.Input.MouseButtonEventArgs" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-1596">The <see cref="T:System.Windows.Input.MouseButtonEventArgs" /> that contains the event data.</span>
          </span>
          <span data-ttu-id="f4180-1597">事件数据报告称已按下鼠标右键。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-1597">The event data reports that the right mouse button was pressed.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f4180-1598">当某个未处理的 <see cref="E:System.Windows.ContentElement.PreviewMouseRightButtonDown" /> 路由事件在其路由中到达派生自此类的某个元素时调用。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-1598">Invoked when an unhandled <see cref="E:System.Windows.ContentElement.PreviewMouseRightButtonDown" /> routed event reaches an element in its route that is derived from this class.</span>
          </span>
          <span data-ttu-id="f4180-1599">实现此方法可为此事件添加类处理。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-1599">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4180-1600"><xref:System.Windows.ContentElement.PreviewMouseRightButtonDown>事件看起来进行隧道路由，但实际上是以间接方式。</span><span class="sxs-lookup"><span data-stu-id="f4180-1600">The <xref:System.Windows.ContentElement.PreviewMouseRightButtonDown> event appears to travel a tunneling route but actually travels in an indirect way.</span></span> <span data-ttu-id="f4180-1601"><xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType> 是的基础事件是隧道路由，并且每个<xref:System.Windows.ContentElement>沿着事件路由使用相同的处理引发的直接路由的事件<xref:System.Windows.ContentElement.MouseRightButtonDown>。</span><span class="sxs-lookup"><span data-stu-id="f4180-1601"><xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType> is the underlying event that is tunnel routed, and each <xref:System.Windows.ContentElement> along the event route uses identical handling to raise the direct routed event <xref:System.Windows.ContentElement.MouseRightButtonDown>.</span></span> <span data-ttu-id="f4180-1602">尽管可以将标记<xref:System.Windows.ContentElement.PreviewMouseRightButtonDown>为此元素的已处理的事件，处理的状态不会不保留到其他元素为由事件路由。</span><span class="sxs-lookup"><span data-stu-id="f4180-1602">Although you can mark the <xref:System.Windows.ContentElement.PreviewMouseRightButtonDown> event as handled for purposes of this element, the handled state does not perpetuate to other elements along the event route.</span></span> <span data-ttu-id="f4180-1603">但是，你可能想要将事件标记为已处理以防止常规实例处理程序 (未指定的那些`handledEventsToo`) 调用。</span><span class="sxs-lookup"><span data-stu-id="f4180-1603">However, you might want to mark the event as handled in order to prevent general instance handlers (those that did not specify `handledEventsToo`) from being invoked.</span></span>  
  
 <span data-ttu-id="f4180-1604">常规鼠标事件处理中的默认实现<xref:System.Windows.ContentElement>侦听<xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType>并将其转换为相应的本地事件。</span><span class="sxs-lookup"><span data-stu-id="f4180-1604">The default implementation for general mouse event handling in <xref:System.Windows.ContentElement> listens for <xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType> and converts it to an appropriate local event.</span></span> <span data-ttu-id="f4180-1605">如果你想要覆盖此逻辑，必须创建派生的类。</span><span class="sxs-lookup"><span data-stu-id="f4180-1605">If you want to override this logic, you must create a derived class.</span></span> <span data-ttu-id="f4180-1606">在派生类的静态构造函数，将注册的替代类处理程序<xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="f4180-1606">In the static constructor of your derived class, register an alternative class handler for <xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType>.</span></span> <span data-ttu-id="f4180-1607">不能更改处理行为的鼠标<xref:System.Windows.ContentElement>通过重写<xref:System.Windows.ContentElement.OnPreviewMouseRightButtonDown%2A>。</span><span class="sxs-lookup"><span data-stu-id="f4180-1607">You cannot change the mouse handling behavior of <xref:System.Windows.ContentElement> by overriding <xref:System.Windows.ContentElement.OnPreviewMouseRightButtonDown%2A>.</span></span>  
  
 <span data-ttu-id="f4180-1608">或者，可以以更改的事件处理特定的鼠标状态来重写此方法。</span><span class="sxs-lookup"><span data-stu-id="f4180-1608">Alternatively, you can override this method in order to change event handling for a specific mouse state.</span></span> <span data-ttu-id="f4180-1609">您是否选择调用基实现取决于你的方案。</span><span class="sxs-lookup"><span data-stu-id="f4180-1609">Whether you choose to call the base implementation depends on your scenario.</span></span> <span data-ttu-id="f4180-1610">未能调用基禁用默认为基实现，也应调用该鼠标事件的输入的处理<xref:System.Windows.ContentElement.OnPreviewMouseRightButtonDown%2A>。</span><span class="sxs-lookup"><span data-stu-id="f4180-1610">Failing to call base disables default input handling for that mouse event on ancestor classes that also expect to invoke <xref:System.Windows.ContentElement.OnPreviewMouseRightButtonDown%2A>.</span></span> <span data-ttu-id="f4180-1611">例如，您可以从其中<xref:System.Windows.Controls.Control>并重写<xref:System.Windows.ContentElement.OnPreviewMouseRightButtonDown%2A>但是，而无需调用基实现; 在派生类中此替代禁用上下文菜单上的服务控件，都是一部分的<xref:System.Windows.Controls.Control>默认行为。</span><span class="sxs-lookup"><span data-stu-id="f4180-1611">For example, you can derive from <xref:System.Windows.Controls.Control> and override <xref:System.Windows.ContentElement.OnPreviewMouseRightButtonDown%2A> in your derived class without calling base; however, this override disables the context menu services on your control, which are part of the <xref:System.Windows.Controls.Control> default behavior.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnPreviewMouseRightButtonUp">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewMouseRightButtonUp (System.Windows.Input.MouseButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewMouseRightButtonUp(class System.Windows.Input.MouseButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewMouseRightButtonUp(System.Windows.Input.MouseButtonEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewMouseRightButtonUp (e As MouseButtonEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewMouseRightButtonUp(System::Windows::Input::MouseButtonEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewMouseRightButtonUp : System.Windows.Input.MouseButtonEventArgs -&gt; unit&#xA;override this.OnPreviewMouseRightButtonUp : System.Windows.Input.MouseButtonEventArgs -&gt; unit" Usage="contentElement.OnPreviewMouseRightButtonUp e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="f4180-1612">包含事件数据的 <see cref="T:System.Windows.Input.MouseButtonEventArgs" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-1612">The <see cref="T:System.Windows.Input.MouseButtonEventArgs" /> that contains the event data.</span>
          </span>
          <span data-ttu-id="f4180-1613">事件数据报告称已释放鼠标右键。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-1613">The event data reports that the right mouse button was released.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f4180-1614">当某个未处理的 <see cref="E:System.Windows.ContentElement.PreviewMouseRightButtonUp" /> 路由事件在其路由中到达派生自此类的某个元素时调用。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-1614">Invoked when an unhandled <see cref="E:System.Windows.ContentElement.PreviewMouseRightButtonUp" /> routed event reaches an element in its route that is derived from this class.</span>
          </span>
          <span data-ttu-id="f4180-1615">实现此方法可为此事件添加类处理。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-1615">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4180-1616"><xref:System.Windows.ContentElement.PreviewMouseRightButtonUp>事件看起来进行隧道路由，但实际上是以间接方式。</span><span class="sxs-lookup"><span data-stu-id="f4180-1616">The <xref:System.Windows.ContentElement.PreviewMouseRightButtonUp> event appears to travel a tunneling route but actually travels in an indirect way.</span></span> <span data-ttu-id="f4180-1617"><xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType> 是的基础事件是隧道路由，并且每个<xref:System.Windows.ContentElement>沿着事件路由使用相同的处理引发的直接路由的事件<xref:System.Windows.ContentElement.PreviewMouseRightButtonUp>。</span><span class="sxs-lookup"><span data-stu-id="f4180-1617"><xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType> is the underlying event that is tunnel routed, and each <xref:System.Windows.ContentElement> along the event route uses identical handling to raise the direct routed event <xref:System.Windows.ContentElement.PreviewMouseRightButtonUp>.</span></span> <span data-ttu-id="f4180-1618">尽管可以将标记<xref:System.Windows.ContentElement.PreviewMouseRightButtonUp>为此元素的已处理的事件，处理的状态不会不保留到其他元素为由事件路由。</span><span class="sxs-lookup"><span data-stu-id="f4180-1618">Although you can mark the <xref:System.Windows.ContentElement.PreviewMouseRightButtonUp> event as handled for purposes of this element, the handled state does not perpetuate to other elements along the event route.</span></span> <span data-ttu-id="f4180-1619">但是，你可能想要将事件标记为已处理以防止常规实例处理程序 (未指定的那些`handledEventsToo`) 调用。</span><span class="sxs-lookup"><span data-stu-id="f4180-1619">However, you might want to mark the event as handled in order to prevent general instance handlers (those that did not specify `handledEventsToo`) from being invoked.</span></span>  
  
 <span data-ttu-id="f4180-1620">常规鼠标事件处理中的默认实现<xref:System.Windows.ContentElement>侦听<xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType>并将其转换为相应的本地事件。</span><span class="sxs-lookup"><span data-stu-id="f4180-1620">The default implementation for general mouse event handling in <xref:System.Windows.ContentElement> listens for <xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType> and converts it to an appropriate local event.</span></span> <span data-ttu-id="f4180-1621">如果你想要覆盖此逻辑，必须创建派生的类。</span><span class="sxs-lookup"><span data-stu-id="f4180-1621">If you want to override this logic, you must create a derived class.</span></span> <span data-ttu-id="f4180-1622">在派生类的静态构造函数，将注册的替代类处理程序<xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="f4180-1622">In the static constructor of your derived class, register an alternative class handler for <xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType>.</span></span> <span data-ttu-id="f4180-1623">不能更改处理行为的鼠标<xref:System.Windows.ContentElement>通过重写<xref:System.Windows.ContentElement.OnPreviewMouseRightButtonUp%2A>。</span><span class="sxs-lookup"><span data-stu-id="f4180-1623">You cannot change the mouse handling behavior of <xref:System.Windows.ContentElement> by overriding <xref:System.Windows.ContentElement.OnPreviewMouseRightButtonUp%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnPreviewMouseUp">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewMouseUp (System.Windows.Input.MouseButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewMouseUp(class System.Windows.Input.MouseButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewMouseUp(System.Windows.Input.MouseButtonEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewMouseUp (e As MouseButtonEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewMouseUp(System::Windows::Input::MouseButtonEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewMouseUp : System.Windows.Input.MouseButtonEventArgs -&gt; unit&#xA;override this.OnPreviewMouseUp : System.Windows.Input.MouseButtonEventArgs -&gt; unit" Usage="contentElement.OnPreviewMouseUp e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="f4180-1624">包含事件数据的 <see cref="T:System.Windows.Input.MouseButtonEventArgs" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-1624">The <see cref="T:System.Windows.Input.MouseButtonEventArgs" /> that contains the event data.</span>
          </span>
          <span data-ttu-id="f4180-1625">事件数据将报告已释放了一个或多个鼠标按钮。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-1625">The event data reports that one or more mouse buttons were released.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f4180-1626">当某个未处理的 <see cref="E:System.Windows.Input.Mouse.PreviewMouseUp" /> 附加事件在其路由中到达派生自此类的某个元素时调用。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-1626">Invoked when an unhandled <see cref="E:System.Windows.Input.Mouse.PreviewMouseUp" /> attached event reaches an element in its route that is derived from this class.</span>
          </span>
          <span data-ttu-id="f4180-1627">实现此方法可为此事件添加类处理。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-1627">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4180-1628">处理鼠标按钮操作也是通过专用的输入管理器。</span><span class="sxs-lookup"><span data-stu-id="f4180-1628">Mouse button actions are also handled by a dedicated input manager.</span></span> <span data-ttu-id="f4180-1629">公开为常规鼠标按钮操作之前，其他编程功能，依赖于鼠标按钮操作，例如输入和命令绑定，可能会调用处理程序的操作。</span><span class="sxs-lookup"><span data-stu-id="f4180-1629">Other programming features that rely on mouse button actions, such as input and command bindings, might invoke handlers for the action before it is exposed as a general mouse button action.</span></span> <span data-ttu-id="f4180-1630">如果这些输入系统功能标记<xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType>事件处理，如<xref:System.Windows.ContentElement.OnPreviewMouseUp%2A>不调用。</span><span class="sxs-lookup"><span data-stu-id="f4180-1630">If these input system features mark the <xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType> event as handled, <xref:System.Windows.ContentElement.OnPreviewMouseUp%2A> is not invoked.</span></span>  
  
 <span data-ttu-id="f4180-1631">如果使用此类处理程序将事件标记为已处理，则可能会影响以下事件：<xref:System.Windows.ContentElement.PreviewMouseLeftButtonUp>和<xref:System.Windows.ContentElement.PreviewMouseRightButtonUp>。</span><span class="sxs-lookup"><span data-stu-id="f4180-1631">If you use this class handler to mark the event as handled, you potentially impact the following events: <xref:System.Windows.ContentElement.PreviewMouseLeftButtonUp> and <xref:System.Windows.ContentElement.PreviewMouseRightButtonUp>.</span></span> <span data-ttu-id="f4180-1632">上述任一事件可能会在接收元素上引发时<xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType>收到。</span><span class="sxs-lookup"><span data-stu-id="f4180-1632">Either of these events might be raised on the receiving element when <xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType> is received.</span></span>  
  
 <span data-ttu-id="f4180-1633">如果标记为已处理的类中处理此事件，则仍会引发子事件;但是，它们通过中的事件数据的处理的状态。</span><span class="sxs-lookup"><span data-stu-id="f4180-1633">If you mark this event as handled in class handling, subevents are still raised; however, they pass the handled state in the event data.</span></span> <span data-ttu-id="f4180-1634">除非您显式使用类处理在处理该事件时，如果不调用为子事件的实例处理<xref:System.Windows.ContentElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29>与`handledEventsToo``true`才能附加处理程序。</span><span class="sxs-lookup"><span data-stu-id="f4180-1634">If the event is handled in class handling, instance handlers for the subevents are not invoked unless you explicitly use <xref:System.Windows.ContentElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> with `handledEventsToo` `true` in order to attach handlers.</span></span> <span data-ttu-id="f4180-1635">类处理程序也不会调用与注册了这些类处理程序，除非<xref:System.Windows.EventManager.RegisterClassHandler%28System.Type%2CSystem.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29>带签名`handledEventsToo` `true`。</span><span class="sxs-lookup"><span data-stu-id="f4180-1635">Class handlers also are not invoked unless those class handlers were registered with the <xref:System.Windows.EventManager.RegisterClassHandler%28System.Type%2CSystem.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> signature with `handledEventsToo` `true`.</span></span> <span data-ttu-id="f4180-1636">通过处理<xref:System.Windows.ContentElement.OnPreviewMouseUp%2A>，则意味着类处理负责操作的所有可能的鼠标按钮。</span><span class="sxs-lookup"><span data-stu-id="f4180-1636">By handling <xref:System.Windows.ContentElement.OnPreviewMouseUp%2A>, you are implying that your class handling accounted for all possible mouse button up actions.</span></span> <span data-ttu-id="f4180-1637">此行为可能不需要;因此，此虚拟方法用于将事件标记为已处理时要格外小心。</span><span class="sxs-lookup"><span data-stu-id="f4180-1637">This behavior might be unwanted; Therefore, use caution when you use this virtual method to mark events as handled.</span></span>  
  
 <span data-ttu-id="f4180-1638">每个特定于按钮的直接事件也有一个虚拟 On \* 方法;请考虑是否重写这些特定于按钮的类处理程序可能会更合适。</span><span class="sxs-lookup"><span data-stu-id="f4180-1638">Each of the button-specific direct events also has a virtual On\* method; consider whether overriding these button-specific class handlers might be more appropriate.</span></span>  
  
 <span data-ttu-id="f4180-1639">此方法具有默认实现。</span><span class="sxs-lookup"><span data-stu-id="f4180-1639">This method has no default implementation.</span></span> <span data-ttu-id="f4180-1640">因为中间类继承中的可能会实现此方法，我们建议在实现中调用基实现。</span><span class="sxs-lookup"><span data-stu-id="f4180-1640">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="f4180-1641">此方法的用途是类似于[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]事件模式 On \* 方法： 此方法提供了通过建立类处理程序而不是实例处理程序来处理从派生类的匹配事件的方法。</span><span class="sxs-lookup"><span data-stu-id="f4180-1641">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="f4180-1642">在这种情况下匹配事件是路由的事件。</span><span class="sxs-lookup"><span data-stu-id="f4180-1642">In this case the matching event is a routed event.</span></span> <span data-ttu-id="f4180-1643">On \* 方法的实现模式是不同的路由事件，因为可以由子元素，它不一定是将调用处理程序的元素引发路由的事件。</span><span class="sxs-lookup"><span data-stu-id="f4180-1643">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="f4180-1644">因此，您的实现需要检查的事件数据源属性。</span><span class="sxs-lookup"><span data-stu-id="f4180-1644">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="f4180-1645">它不应尝试再次引发该事件在大多数情况下。</span><span class="sxs-lookup"><span data-stu-id="f4180-1645">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="f4180-1646">通过重写此方法或通过注册类处理程序替换<xref:System.Windows.EventManager.RegisterClassHandler%2A>，派生类的<xref:System.Windows.ContentElement>为由事件路由收到事件时，可以调用私有类处理程序方法。</span><span class="sxs-lookup"><span data-stu-id="f4180-1646">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="f4180-1647">类处理是相应的一种方案是操作事件数据并将路由的事件标记为已处理。</span><span class="sxs-lookup"><span data-stu-id="f4180-1647">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewMouseUp" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewMouseWheel">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewMouseWheel (System.Windows.Input.MouseWheelEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewMouseWheel(class System.Windows.Input.MouseWheelEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewMouseWheel(System.Windows.Input.MouseWheelEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewMouseWheel (e As MouseWheelEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewMouseWheel(System::Windows::Input::MouseWheelEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewMouseWheel : System.Windows.Input.MouseWheelEventArgs -&gt; unit&#xA;override this.OnPreviewMouseWheel : System.Windows.Input.MouseWheelEventArgs -&gt; unit" Usage="contentElement.OnPreviewMouseWheel e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseWheelEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="f4180-1648">包含事件数据的 <see cref="T:System.Windows.Input.MouseWheelEventArgs" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-1648">The <see cref="T:System.Windows.Input.MouseWheelEventArgs" /> that contains the event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f4180-1649">当某个未处理的 <see cref="E:System.Windows.Input.Mouse.PreviewMouseWheel" /> 附加事件在其路由中到达派生自此类的某个元素时调用。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-1649">Invoked when an unhandled <see cref="E:System.Windows.Input.Mouse.PreviewMouseWheel" /> attached event reaches an element in its route that is derived from this class.</span>
          </span>
          <span data-ttu-id="f4180-1650">实现此方法可为此事件添加类处理。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-1650">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4180-1651">此方法具有默认实现。</span><span class="sxs-lookup"><span data-stu-id="f4180-1651">This method has no default implementation.</span></span> <span data-ttu-id="f4180-1652">因为中间类继承中的可能会实现此方法，我们建议在实现中调用基实现。</span><span class="sxs-lookup"><span data-stu-id="f4180-1652">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="f4180-1653">此方法的用途是类似于[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]事件模式 On \* 方法： 此方法提供了通过建立类处理程序而不是实例处理程序来处理从派生类的匹配事件的方法。</span><span class="sxs-lookup"><span data-stu-id="f4180-1653">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="f4180-1654">在这种情况下匹配事件是路由的事件。</span><span class="sxs-lookup"><span data-stu-id="f4180-1654">In this case the matching event is a routed event.</span></span> <span data-ttu-id="f4180-1655">On \* 方法的实现模式是不同的路由事件，因为可以由子元素，它不一定是将调用处理程序的元素引发路由的事件。</span><span class="sxs-lookup"><span data-stu-id="f4180-1655">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="f4180-1656">因此，您的实现需要检查的事件数据源属性。</span><span class="sxs-lookup"><span data-stu-id="f4180-1656">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="f4180-1657">它不应尝试再次引发该事件在大多数情况下。</span><span class="sxs-lookup"><span data-stu-id="f4180-1657">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="f4180-1658">通过重写此方法或通过注册类处理程序替换<xref:System.Windows.EventManager.RegisterClassHandler%2A>，派生类的<xref:System.Windows.ContentElement>为由事件路由收到事件时，可以调用私有类处理程序方法。</span><span class="sxs-lookup"><span data-stu-id="f4180-1658">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="f4180-1659">类处理是相应的一种方案是操作事件数据并将路由的事件标记为已处理。</span><span class="sxs-lookup"><span data-stu-id="f4180-1659">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span> <span data-ttu-id="f4180-1660">专用于预览事件的另一个方案是将已处理，以便匹配冒泡类处理程序不会调用其标记。</span><span class="sxs-lookup"><span data-stu-id="f4180-1660">Another scenario that is specifically for Preview events is to mark them handled so that the matching bubbling class handlers are not invoked.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewMouseWheel" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewQueryContinueDrag">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewQueryContinueDrag (System.Windows.QueryContinueDragEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewQueryContinueDrag(class System.Windows.QueryContinueDragEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewQueryContinueDrag(System.Windows.QueryContinueDragEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewQueryContinueDrag (e As QueryContinueDragEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewQueryContinueDrag(System::Windows::QueryContinueDragEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewQueryContinueDrag : System.Windows.QueryContinueDragEventArgs -&gt; unit&#xA;override this.OnPreviewQueryContinueDrag : System.Windows.QueryContinueDragEventArgs -&gt; unit" Usage="contentElement.OnPreviewQueryContinueDrag e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.QueryContinueDragEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="f4180-1661">包含事件数据的 <see cref="T:System.Windows.QueryContinueDragEventArgs" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-1661">The <see cref="T:System.Windows.QueryContinueDragEventArgs" /> that contains the event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f4180-1662">当某个未处理的 <see cref="E:System.Windows.DragDrop.PreviewQueryContinueDrag" /> 附加事件在其路由中到达派生自此类的某个元素时调用。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-1662">Invoked when an unhandled <see cref="E:System.Windows.DragDrop.PreviewQueryContinueDrag" /> attached event reaches an element in its route that is derived from this class.</span>
          </span>
          <span data-ttu-id="f4180-1663">实现此方法可为此事件添加类处理。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-1663">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4180-1664">此方法具有默认实现。</span><span class="sxs-lookup"><span data-stu-id="f4180-1664">This method has no default implementation.</span></span> <span data-ttu-id="f4180-1665">因为中间类继承中的可能会实现此方法，我们建议在实现中调用基实现。</span><span class="sxs-lookup"><span data-stu-id="f4180-1665">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="f4180-1666">此方法的用途是类似于[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]事件模式 On \* 方法： 此方法提供了通过建立类处理程序而不是实例处理程序来处理从派生类的匹配事件的方法。</span><span class="sxs-lookup"><span data-stu-id="f4180-1666">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="f4180-1667">在这种情况下匹配事件是路由的事件。</span><span class="sxs-lookup"><span data-stu-id="f4180-1667">In this case the matching event is a routed event.</span></span> <span data-ttu-id="f4180-1668">On \* 方法的实现模式是不同的路由事件，因为可以由子元素，它不一定是将调用处理程序的元素引发路由的事件。</span><span class="sxs-lookup"><span data-stu-id="f4180-1668">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="f4180-1669">因此，您的实现需要检查的事件数据源属性。</span><span class="sxs-lookup"><span data-stu-id="f4180-1669">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="f4180-1670">它不应尝试再次引发该事件在大多数情况下。</span><span class="sxs-lookup"><span data-stu-id="f4180-1670">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="f4180-1671">通过重写此方法或通过注册类处理程序替换<xref:System.Windows.EventManager.RegisterClassHandler%2A>，派生类的<xref:System.Windows.ContentElement>为由事件路由收到事件时，可以调用私有类处理程序方法。</span><span class="sxs-lookup"><span data-stu-id="f4180-1671">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="f4180-1672">类处理是相应的一种方案是操作事件数据并将路由的事件标记为已处理。</span><span class="sxs-lookup"><span data-stu-id="f4180-1672">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span> <span data-ttu-id="f4180-1673">专用于预览事件的另一个方案是将已处理，以便匹配冒泡类处理程序不会调用其标记。</span><span class="sxs-lookup"><span data-stu-id="f4180-1673">Another scenario that is specifically for Preview events is to mark them handled so that the matching bubbling class handlers are not invoked.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewQueryContinueDrag" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewStylusButtonDown">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewStylusButtonDown (System.Windows.Input.StylusButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewStylusButtonDown(class System.Windows.Input.StylusButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewStylusButtonDown(System.Windows.Input.StylusButtonEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewStylusButtonDown (e As StylusButtonEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewStylusButtonDown(System::Windows::Input::StylusButtonEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewStylusButtonDown : System.Windows.Input.StylusButtonEventArgs -&gt; unit&#xA;override this.OnPreviewStylusButtonDown : System.Windows.Input.StylusButtonEventArgs -&gt; unit" Usage="contentElement.OnPreviewStylusButtonDown e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="f4180-1674">包含事件数据的 <see cref="T:System.Windows.Input.StylusButtonEventArgs" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-1674">The <see cref="T:System.Windows.Input.StylusButtonEventArgs" /> that contains the event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f4180-1675">当某个未处理的 <see cref="E:System.Windows.Input.Stylus.PreviewStylusButtonDown" /> 附加事件在其路由中到达派生自此类的某个元素时调用。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-1675">Invoked when an unhandled <see cref="E:System.Windows.Input.Stylus.PreviewStylusButtonDown" /> attached event reaches an element in its route that is derived from this class.</span>
          </span>
          <span data-ttu-id="f4180-1676">实现此方法可为此事件添加类处理。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-1676">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4180-1677">此方法具有默认实现。</span><span class="sxs-lookup"><span data-stu-id="f4180-1677">This method has no default implementation.</span></span> <span data-ttu-id="f4180-1678">因为中间类继承中的可能会实现此方法，我们建议在实现中调用基实现。</span><span class="sxs-lookup"><span data-stu-id="f4180-1678">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="f4180-1679">此方法的用途是类似于[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]事件模式 On \* 方法： 此方法提供了通过建立类处理程序而不是实例处理程序来处理从派生类的匹配事件的方法。</span><span class="sxs-lookup"><span data-stu-id="f4180-1679">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="f4180-1680">在这种情况下匹配事件是路由的事件。</span><span class="sxs-lookup"><span data-stu-id="f4180-1680">In this case the matching event is a routed event.</span></span> <span data-ttu-id="f4180-1681">On \* 方法的实现模式是不同的路由事件，因为可以由子元素，它不一定是将调用处理程序的元素引发路由的事件。</span><span class="sxs-lookup"><span data-stu-id="f4180-1681">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="f4180-1682">因此，您的实现需要检查的事件数据源属性。</span><span class="sxs-lookup"><span data-stu-id="f4180-1682">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="f4180-1683">它不应尝试再次引发该事件在大多数情况下。</span><span class="sxs-lookup"><span data-stu-id="f4180-1683">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="f4180-1684">通过重写此方法或通过注册类处理程序替换<xref:System.Windows.EventManager.RegisterClassHandler%2A>，派生类的<xref:System.Windows.ContentElement>为由事件路由收到事件时，可以调用私有类处理程序方法。</span><span class="sxs-lookup"><span data-stu-id="f4180-1684">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="f4180-1685">类处理是相应的一种方案是操作事件数据并将路由的事件标记为已处理。</span><span class="sxs-lookup"><span data-stu-id="f4180-1685">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span> <span data-ttu-id="f4180-1686">专用于预览事件的另一个方案是将已处理，以便匹配冒泡类处理程序不会调用其标记。</span><span class="sxs-lookup"><span data-stu-id="f4180-1686">Another scenario that is specifically for Preview events is to mark them handled so that the matching bubbling class handlers are not invoked.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewStylusButtonDown" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewStylusButtonUp">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewStylusButtonUp (System.Windows.Input.StylusButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewStylusButtonUp(class System.Windows.Input.StylusButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewStylusButtonUp(System.Windows.Input.StylusButtonEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewStylusButtonUp (e As StylusButtonEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewStylusButtonUp(System::Windows::Input::StylusButtonEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewStylusButtonUp : System.Windows.Input.StylusButtonEventArgs -&gt; unit&#xA;override this.OnPreviewStylusButtonUp : System.Windows.Input.StylusButtonEventArgs -&gt; unit" Usage="contentElement.OnPreviewStylusButtonUp e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="f4180-1687">包含事件数据的 <see cref="T:System.Windows.Input.StylusButtonEventArgs" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-1687">The <see cref="T:System.Windows.Input.StylusButtonEventArgs" /> that contains the event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f4180-1688">当某个未处理的 <see cref="E:System.Windows.Input.Stylus.PreviewStylusButtonUp" /> 附加事件在其路由中到达派生自此类的某个元素时调用。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-1688">Invoked when an unhandled <see cref="E:System.Windows.Input.Stylus.PreviewStylusButtonUp" /> attached event reaches an element in its route that is derived from this class.</span>
          </span>
          <span data-ttu-id="f4180-1689">实现此方法可为此事件添加类处理。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-1689">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4180-1690">此方法具有默认实现。</span><span class="sxs-lookup"><span data-stu-id="f4180-1690">This method has no default implementation.</span></span> <span data-ttu-id="f4180-1691">因为中间类继承中的可能会实现此方法，我们建议在实现中调用基实现。</span><span class="sxs-lookup"><span data-stu-id="f4180-1691">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="f4180-1692">此方法的用途是类似于[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]事件模式 On \* 方法： 此方法提供了通过建立类处理程序而不是实例处理程序来处理从派生类的匹配事件的方法。</span><span class="sxs-lookup"><span data-stu-id="f4180-1692">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="f4180-1693">在这种情况下匹配事件是路由的事件。</span><span class="sxs-lookup"><span data-stu-id="f4180-1693">In this case the matching event is a routed event.</span></span> <span data-ttu-id="f4180-1694">On \* 方法的实现模式是不同的路由事件，因为可以由子元素，它不一定是将调用处理程序的元素引发路由的事件。</span><span class="sxs-lookup"><span data-stu-id="f4180-1694">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="f4180-1695">因此，您的实现需要检查的事件数据源属性。</span><span class="sxs-lookup"><span data-stu-id="f4180-1695">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="f4180-1696">它不应尝试再次引发该事件在大多数情况下。</span><span class="sxs-lookup"><span data-stu-id="f4180-1696">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="f4180-1697">通过重写此方法或通过注册类处理程序替换<xref:System.Windows.EventManager.RegisterClassHandler%2A>，派生类的<xref:System.Windows.ContentElement>为由事件路由收到事件时，可以调用私有类处理程序方法。</span><span class="sxs-lookup"><span data-stu-id="f4180-1697">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="f4180-1698">类处理是相应的一种方案是操作事件数据并将路由的事件标记为已处理。</span><span class="sxs-lookup"><span data-stu-id="f4180-1698">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span> <span data-ttu-id="f4180-1699">专用于预览事件的另一个方案是将已处理，以便匹配冒泡类处理程序不会调用其标记。</span><span class="sxs-lookup"><span data-stu-id="f4180-1699">Another scenario that is specifically for Preview events is to mark them handled so that the matching bubbling class handlers are not invoked.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewStylusButtonUp" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewStylusDown">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewStylusDown (System.Windows.Input.StylusDownEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewStylusDown(class System.Windows.Input.StylusDownEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewStylusDown(System.Windows.Input.StylusDownEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewStylusDown (e As StylusDownEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewStylusDown(System::Windows::Input::StylusDownEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewStylusDown : System.Windows.Input.StylusDownEventArgs -&gt; unit&#xA;override this.OnPreviewStylusDown : System.Windows.Input.StylusDownEventArgs -&gt; unit" Usage="contentElement.OnPreviewStylusDown e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusDownEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="f4180-1700">包含事件数据的 <see cref="T:System.Windows.Input.StylusDownEventArgs" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-1700">The <see cref="T:System.Windows.Input.StylusDownEventArgs" /> that contains the event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f4180-1701">当某个未处理的 <see cref="E:System.Windows.Input.Stylus.PreviewStylusDown" /> 附加事件在其路由中到达派生自此类的某个元素时调用。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-1701">Invoked when an unhandled <see cref="E:System.Windows.Input.Stylus.PreviewStylusDown" /> attached event reaches an element in its route that is derived from this class.</span>
          </span>
          <span data-ttu-id="f4180-1702">实现此方法可为此事件添加类处理。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-1702">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4180-1703">此方法具有默认实现。</span><span class="sxs-lookup"><span data-stu-id="f4180-1703">This method has no default implementation.</span></span> <span data-ttu-id="f4180-1704">因为中间类继承中的可能会实现此方法，我们建议在实现中调用基实现。</span><span class="sxs-lookup"><span data-stu-id="f4180-1704">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="f4180-1705">此方法的用途是类似于[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]事件模式 On \* 方法： 此方法提供了通过建立类处理程序而不是实例处理程序来处理从派生类的匹配事件的方法。</span><span class="sxs-lookup"><span data-stu-id="f4180-1705">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="f4180-1706">在这种情况下匹配事件是路由的事件。</span><span class="sxs-lookup"><span data-stu-id="f4180-1706">In this case the matching event is a routed event.</span></span> <span data-ttu-id="f4180-1707">On \* 方法的实现模式是不同的路由事件，因为可以由子元素，它不一定是将调用处理程序的元素引发路由的事件。</span><span class="sxs-lookup"><span data-stu-id="f4180-1707">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="f4180-1708">因此，您的实现需要检查的事件数据源属性。</span><span class="sxs-lookup"><span data-stu-id="f4180-1708">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="f4180-1709">它不应尝试再次引发该事件在大多数情况下。</span><span class="sxs-lookup"><span data-stu-id="f4180-1709">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="f4180-1710">通过重写此方法或通过注册类处理程序替换<xref:System.Windows.EventManager.RegisterClassHandler%2A>，派生类的<xref:System.Windows.ContentElement>为由事件路由收到事件时，可以调用私有类处理程序方法。</span><span class="sxs-lookup"><span data-stu-id="f4180-1710">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="f4180-1711">类处理是相应的一种方案是操作事件数据并将路由的事件标记为已处理。</span><span class="sxs-lookup"><span data-stu-id="f4180-1711">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span> <span data-ttu-id="f4180-1712">专用于预览事件的另一个方案是将已处理，以便匹配冒泡类处理程序不会调用其标记。</span><span class="sxs-lookup"><span data-stu-id="f4180-1712">Another scenario that is specifically for Preview events is to mark them handled so that the matching bubbling class handlers are not invoked.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewStylusDown" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewStylusInAirMove">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewStylusInAirMove (System.Windows.Input.StylusEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewStylusInAirMove(class System.Windows.Input.StylusEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewStylusInAirMove(System.Windows.Input.StylusEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewStylusInAirMove (e As StylusEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewStylusInAirMove(System::Windows::Input::StylusEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewStylusInAirMove : System.Windows.Input.StylusEventArgs -&gt; unit&#xA;override this.OnPreviewStylusInAirMove : System.Windows.Input.StylusEventArgs -&gt; unit" Usage="contentElement.OnPreviewStylusInAirMove e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="f4180-1713">包含事件数据的 <see cref="T:System.Windows.Input.StylusEventArgs" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-1713">The <see cref="T:System.Windows.Input.StylusEventArgs" /> that contains the event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f4180-1714">当某个未处理的 <see cref="E:System.Windows.Input.Stylus.PreviewStylusInAirMove" /> 附加事件在其路由中到达派生自此类的某个元素时调用。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-1714">Invoked when an unhandled <see cref="E:System.Windows.Input.Stylus.PreviewStylusInAirMove" /> attached event reaches an element in its route that is derived from this class.</span>
          </span>
          <span data-ttu-id="f4180-1715">实现此方法可为此事件添加类处理。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-1715">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4180-1716">此方法具有默认实现。</span><span class="sxs-lookup"><span data-stu-id="f4180-1716">This method has no default implementation.</span></span> <span data-ttu-id="f4180-1717">因为中间类继承中的可能会实现此方法，我们建议在实现中调用基实现。</span><span class="sxs-lookup"><span data-stu-id="f4180-1717">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="f4180-1718">此方法的用途是类似于[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]事件模式 On \* 方法： 此方法提供了通过建立类处理程序而不是实例处理程序来处理从派生类的匹配事件的方法。</span><span class="sxs-lookup"><span data-stu-id="f4180-1718">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="f4180-1719">在这种情况下匹配事件是路由的事件。</span><span class="sxs-lookup"><span data-stu-id="f4180-1719">In this case the matching event is a routed event.</span></span> <span data-ttu-id="f4180-1720">On \* 方法的实现模式是不同的路由事件，因为可以由子元素，它不一定是将调用处理程序的元素引发路由的事件。</span><span class="sxs-lookup"><span data-stu-id="f4180-1720">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="f4180-1721">因此，您的实现需要检查的事件数据源属性。</span><span class="sxs-lookup"><span data-stu-id="f4180-1721">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="f4180-1722">它不应尝试再次引发该事件在大多数情况下。</span><span class="sxs-lookup"><span data-stu-id="f4180-1722">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="f4180-1723">通过重写此方法或通过注册类处理程序替换<xref:System.Windows.EventManager.RegisterClassHandler%2A>，派生类的<xref:System.Windows.ContentElement>为由事件路由收到事件时，可以调用私有类处理程序方法。</span><span class="sxs-lookup"><span data-stu-id="f4180-1723">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="f4180-1724">类处理是相应的一种方案是操作事件数据并将路由的事件标记为已处理。</span><span class="sxs-lookup"><span data-stu-id="f4180-1724">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span> <span data-ttu-id="f4180-1725">专用于预览事件的另一个方案是将已处理，以便匹配冒泡类处理程序不会调用其标记。</span><span class="sxs-lookup"><span data-stu-id="f4180-1725">Another scenario that is specifically for Preview events is to mark them handled so that the matching bubbling class handlers are not invoked.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewStylusInAirMove" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewStylusInRange">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewStylusInRange (System.Windows.Input.StylusEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewStylusInRange(class System.Windows.Input.StylusEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewStylusInRange(System.Windows.Input.StylusEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewStylusInRange (e As StylusEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewStylusInRange(System::Windows::Input::StylusEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewStylusInRange : System.Windows.Input.StylusEventArgs -&gt; unit&#xA;override this.OnPreviewStylusInRange : System.Windows.Input.StylusEventArgs -&gt; unit" Usage="contentElement.OnPreviewStylusInRange e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="f4180-1726">包含事件数据的 <see cref="T:System.Windows.Input.StylusEventArgs" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-1726">The <see cref="T:System.Windows.Input.StylusEventArgs" /> that contains the event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f4180-1727">当某个未处理的 <see cref="E:System.Windows.Input.Stylus.PreviewStylusInRange" /> 附加事件在其路由中到达派生自此类的某个元素时调用。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-1727">Invoked when an unhandled <see cref="E:System.Windows.Input.Stylus.PreviewStylusInRange" /> attached event reaches an element in its route that is derived from this class.</span>
          </span>
          <span data-ttu-id="f4180-1728">实现此方法可为此事件添加类处理。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-1728">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4180-1729">此方法具有默认实现。</span><span class="sxs-lookup"><span data-stu-id="f4180-1729">This method has no default implementation.</span></span> <span data-ttu-id="f4180-1730">因为中间类继承中的可能会实现此方法，我们建议在实现中调用基实现。</span><span class="sxs-lookup"><span data-stu-id="f4180-1730">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="f4180-1731">此方法的用途是类似于[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]事件模式 On \* 方法： 此方法提供了通过建立类处理程序而不是实例处理程序来处理从派生类的匹配事件的方法。</span><span class="sxs-lookup"><span data-stu-id="f4180-1731">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="f4180-1732">在这种情况下匹配事件是路由的事件。</span><span class="sxs-lookup"><span data-stu-id="f4180-1732">In this case the matching event is a routed event.</span></span> <span data-ttu-id="f4180-1733">On \* 方法的实现模式是不同的路由事件，因为可以由子元素，它不一定是将调用处理程序的元素引发路由的事件。</span><span class="sxs-lookup"><span data-stu-id="f4180-1733">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="f4180-1734">因此，您的实现需要检查的事件数据源属性。</span><span class="sxs-lookup"><span data-stu-id="f4180-1734">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="f4180-1735">它不应尝试再次引发该事件在大多数情况下。</span><span class="sxs-lookup"><span data-stu-id="f4180-1735">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="f4180-1736">通过重写此方法或通过注册类处理程序替换<xref:System.Windows.EventManager.RegisterClassHandler%2A>，派生类的<xref:System.Windows.ContentElement>为由事件路由收到事件时，可以调用私有类处理程序方法。</span><span class="sxs-lookup"><span data-stu-id="f4180-1736">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="f4180-1737">类处理是相应的一种方案是操作事件数据并将路由的事件标记为已处理。</span><span class="sxs-lookup"><span data-stu-id="f4180-1737">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span> <span data-ttu-id="f4180-1738">专用于预览事件的另一个方案是将已处理，以便匹配冒泡类处理程序不会调用其标记。</span><span class="sxs-lookup"><span data-stu-id="f4180-1738">Another scenario that is specifically for Preview events is to mark them handled so that the matching bubbling class handlers are not invoked.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewStylusInRange" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewStylusMove">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewStylusMove (System.Windows.Input.StylusEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewStylusMove(class System.Windows.Input.StylusEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewStylusMove(System.Windows.Input.StylusEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewStylusMove (e As StylusEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewStylusMove(System::Windows::Input::StylusEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewStylusMove : System.Windows.Input.StylusEventArgs -&gt; unit&#xA;override this.OnPreviewStylusMove : System.Windows.Input.StylusEventArgs -&gt; unit" Usage="contentElement.OnPreviewStylusMove e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="f4180-1739">包含事件数据的 <see cref="T:System.Windows.Input.StylusEventArgs" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-1739">The <see cref="T:System.Windows.Input.StylusEventArgs" /> that contains the event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f4180-1740">当某个未处理的 <see cref="E:System.Windows.Input.Stylus.PreviewStylusMove" /> 附加事件在其路由中到达派生自此类的某个元素时调用。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-1740">Invoked when an unhandled <see cref="E:System.Windows.Input.Stylus.PreviewStylusMove" /> attached event reaches an element in its route that is derived from this class.</span>
          </span>
          <span data-ttu-id="f4180-1741">实现此方法可为此事件添加类处理。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-1741">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4180-1742">此方法具有默认实现。</span><span class="sxs-lookup"><span data-stu-id="f4180-1742">This method has no default implementation.</span></span> <span data-ttu-id="f4180-1743">因为中间类继承中的可能会实现此方法，我们建议在实现中调用基实现。</span><span class="sxs-lookup"><span data-stu-id="f4180-1743">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="f4180-1744">此方法的用途是类似于[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]事件模式 On \* 方法： 此方法提供了通过建立类处理程序而不是实例处理程序来处理从派生类的匹配事件的方法。</span><span class="sxs-lookup"><span data-stu-id="f4180-1744">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="f4180-1745">在这种情况下匹配事件是路由的事件。</span><span class="sxs-lookup"><span data-stu-id="f4180-1745">In this case the matching event is a routed event.</span></span> <span data-ttu-id="f4180-1746">On \* 方法的实现模式是不同的路由事件，因为可以由子元素，它不一定是将调用处理程序的元素引发路由的事件。</span><span class="sxs-lookup"><span data-stu-id="f4180-1746">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="f4180-1747">因此，您的实现需要检查的事件数据源属性。</span><span class="sxs-lookup"><span data-stu-id="f4180-1747">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="f4180-1748">它不应尝试再次引发该事件在大多数情况下。</span><span class="sxs-lookup"><span data-stu-id="f4180-1748">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="f4180-1749">通过重写此方法或通过注册类处理程序替换<xref:System.Windows.EventManager.RegisterClassHandler%2A>，派生类的<xref:System.Windows.ContentElement>为由事件路由收到事件时，可以调用私有类处理程序方法。</span><span class="sxs-lookup"><span data-stu-id="f4180-1749">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="f4180-1750">类处理是相应的一种方案是操作事件数据并将路由的事件标记为已处理。</span><span class="sxs-lookup"><span data-stu-id="f4180-1750">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span> <span data-ttu-id="f4180-1751">专用于预览事件的另一个方案是将已处理，以便匹配冒泡类处理程序不会调用其标记。</span><span class="sxs-lookup"><span data-stu-id="f4180-1751">Another scenario that is specifically for Preview events is to mark them handled so that the matching bubbling class handlers are not invoked.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewStylusMove" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewStylusOutOfRange">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewStylusOutOfRange (System.Windows.Input.StylusEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewStylusOutOfRange(class System.Windows.Input.StylusEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewStylusOutOfRange(System.Windows.Input.StylusEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewStylusOutOfRange (e As StylusEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewStylusOutOfRange(System::Windows::Input::StylusEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewStylusOutOfRange : System.Windows.Input.StylusEventArgs -&gt; unit&#xA;override this.OnPreviewStylusOutOfRange : System.Windows.Input.StylusEventArgs -&gt; unit" Usage="contentElement.OnPreviewStylusOutOfRange e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="f4180-1752">包含事件数据的 <see cref="T:System.Windows.Input.StylusEventArgs" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-1752">The <see cref="T:System.Windows.Input.StylusEventArgs" /> that contains the event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f4180-1753">当某个未处理的 <see cref="E:System.Windows.Input.Stylus.PreviewStylusOutOfRange" /> 附加事件在其路由中到达派生自此类的某个元素时调用。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-1753">Invoked when an unhandled <see cref="E:System.Windows.Input.Stylus.PreviewStylusOutOfRange" /> attached event reaches an element in its route that is derived from this class.</span>
          </span>
          <span data-ttu-id="f4180-1754">实现此方法可为此事件添加类处理。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-1754">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4180-1755">此方法具有默认实现。</span><span class="sxs-lookup"><span data-stu-id="f4180-1755">This method has no default implementation.</span></span> <span data-ttu-id="f4180-1756">因为中间类继承中的可能会实现此方法，我们建议在实现中调用基实现。</span><span class="sxs-lookup"><span data-stu-id="f4180-1756">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="f4180-1757">此方法的用途是类似于[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]事件模式 On \* 方法： 此方法提供了通过建立类处理程序而不是实例处理程序来处理从派生类的匹配事件的方法。</span><span class="sxs-lookup"><span data-stu-id="f4180-1757">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="f4180-1758">在这种情况下匹配事件是路由的事件。</span><span class="sxs-lookup"><span data-stu-id="f4180-1758">In this case the matching event is a routed event.</span></span> <span data-ttu-id="f4180-1759">On \* 方法的实现模式是不同的路由事件，因为可以由子元素，它不一定是将调用处理程序的元素引发路由的事件。</span><span class="sxs-lookup"><span data-stu-id="f4180-1759">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="f4180-1760">因此，您的实现需要检查的事件数据源属性。</span><span class="sxs-lookup"><span data-stu-id="f4180-1760">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="f4180-1761">它不应尝试再次引发该事件在大多数情况下。</span><span class="sxs-lookup"><span data-stu-id="f4180-1761">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="f4180-1762">通过重写此方法或通过注册类处理程序替换<xref:System.Windows.EventManager.RegisterClassHandler%2A>，派生类的<xref:System.Windows.ContentElement>为由事件路由收到事件时，可以调用私有类处理程序方法。</span><span class="sxs-lookup"><span data-stu-id="f4180-1762">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="f4180-1763">类处理是相应的一种方案是操作事件数据并将路由的事件标记为已处理。</span><span class="sxs-lookup"><span data-stu-id="f4180-1763">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span> <span data-ttu-id="f4180-1764">专用于预览事件的另一个方案是将已处理，以便匹配冒泡类处理程序不会调用其标记。</span><span class="sxs-lookup"><span data-stu-id="f4180-1764">Another scenario that is specifically for Preview events is to mark them handled so that the matching bubbling class handlers are not invoked.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewStylusOutOfRange" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewStylusSystemGesture">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewStylusSystemGesture (System.Windows.Input.StylusSystemGestureEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewStylusSystemGesture(class System.Windows.Input.StylusSystemGestureEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewStylusSystemGesture(System.Windows.Input.StylusSystemGestureEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewStylusSystemGesture (e As StylusSystemGestureEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewStylusSystemGesture(System::Windows::Input::StylusSystemGestureEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewStylusSystemGesture : System.Windows.Input.StylusSystemGestureEventArgs -&gt; unit&#xA;override this.OnPreviewStylusSystemGesture : System.Windows.Input.StylusSystemGestureEventArgs -&gt; unit" Usage="contentElement.OnPreviewStylusSystemGesture e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusSystemGestureEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="f4180-1765">包含事件数据的 <see cref="T:System.Windows.Input.StylusSystemGestureEventArgs" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-1765">The <see cref="T:System.Windows.Input.StylusSystemGestureEventArgs" /> that contains the event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f4180-1766">当某个未处理的 <see cref="E:System.Windows.Input.Stylus.PreviewStylusSystemGesture" /> 附加事件在其路由中到达派生自此类的某个元素时调用。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-1766">Invoked when an unhandled <see cref="E:System.Windows.Input.Stylus.PreviewStylusSystemGesture" /> attached event reaches an element in its route that is derived from this class.</span>
          </span>
          <span data-ttu-id="f4180-1767">实现此方法可为此事件添加类处理。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-1767">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4180-1768">此方法具有默认实现。</span><span class="sxs-lookup"><span data-stu-id="f4180-1768">This method has no default implementation.</span></span> <span data-ttu-id="f4180-1769">因为中间类继承中的可能会实现此方法，我们建议在实现中调用基实现。</span><span class="sxs-lookup"><span data-stu-id="f4180-1769">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="f4180-1770">此方法的用途是类似于[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]事件模式 On \* 方法： 此方法提供了通过建立类处理程序而不是实例处理程序来处理从派生类的匹配事件的方法。</span><span class="sxs-lookup"><span data-stu-id="f4180-1770">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="f4180-1771">在这种情况下匹配事件是路由的事件。</span><span class="sxs-lookup"><span data-stu-id="f4180-1771">In this case the matching event is a routed event.</span></span> <span data-ttu-id="f4180-1772">On \* 方法的实现模式是不同的路由事件，因为可以由子元素，它不一定是将调用处理程序的元素引发路由的事件。</span><span class="sxs-lookup"><span data-stu-id="f4180-1772">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="f4180-1773">因此，您的实现需要检查的事件数据源属性。</span><span class="sxs-lookup"><span data-stu-id="f4180-1773">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="f4180-1774">它不应尝试再次引发该事件在大多数情况下。</span><span class="sxs-lookup"><span data-stu-id="f4180-1774">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="f4180-1775">通过重写此方法或通过注册类处理程序替换<xref:System.Windows.EventManager.RegisterClassHandler%2A>，派生类的<xref:System.Windows.ContentElement>为由事件路由收到事件时，可以调用私有类处理程序方法。</span><span class="sxs-lookup"><span data-stu-id="f4180-1775">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="f4180-1776">类处理是相应的一种方案是操作事件数据并将路由的事件标记为已处理。</span><span class="sxs-lookup"><span data-stu-id="f4180-1776">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span> <span data-ttu-id="f4180-1777">专用于预览事件的另一个方案是将已处理，以便匹配冒泡类处理程序不会调用其标记。</span><span class="sxs-lookup"><span data-stu-id="f4180-1777">Another scenario that is specifically for Preview events is to mark them handled so that the matching bubbling class handlers are not invoked.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewStylusSystemGesture" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewStylusUp">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewStylusUp (System.Windows.Input.StylusEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewStylusUp(class System.Windows.Input.StylusEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewStylusUp(System.Windows.Input.StylusEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewStylusUp (e As StylusEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewStylusUp(System::Windows::Input::StylusEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewStylusUp : System.Windows.Input.StylusEventArgs -&gt; unit&#xA;override this.OnPreviewStylusUp : System.Windows.Input.StylusEventArgs -&gt; unit" Usage="contentElement.OnPreviewStylusUp e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="f4180-1778">包含事件数据的 <see cref="T:System.Windows.Input.StylusEventArgs" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-1778">The <see cref="T:System.Windows.Input.StylusEventArgs" /> that contains the event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f4180-1779">当某个未处理的 <see cref="E:System.Windows.Input.Stylus.PreviewStylusUp" /> 附加事件在其路由中到达派生自此类的某个元素时调用。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-1779">Invoked when an unhandled <see cref="E:System.Windows.Input.Stylus.PreviewStylusUp" /> attached event reaches an element in its route that is derived from this class.</span>
          </span>
          <span data-ttu-id="f4180-1780">实现此方法可为此事件添加类处理。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-1780">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4180-1781">此方法具有默认实现。</span><span class="sxs-lookup"><span data-stu-id="f4180-1781">This method has no default implementation.</span></span> <span data-ttu-id="f4180-1782">因为中间类继承中的可能会实现此方法，我们建议在实现中调用基实现。</span><span class="sxs-lookup"><span data-stu-id="f4180-1782">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="f4180-1783">此方法的用途是类似于[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]事件模式 On \* 方法： 此方法提供了通过建立类处理程序而不是实例处理程序来处理从派生类的匹配事件的方法。</span><span class="sxs-lookup"><span data-stu-id="f4180-1783">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="f4180-1784">在这种情况下匹配事件是路由的事件。</span><span class="sxs-lookup"><span data-stu-id="f4180-1784">In this case the matching event is a routed event.</span></span> <span data-ttu-id="f4180-1785">On \* 方法的实现模式是不同的路由事件，因为可以由子元素，它不一定是将调用处理程序的元素引发路由的事件。</span><span class="sxs-lookup"><span data-stu-id="f4180-1785">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="f4180-1786">因此，您的实现需要检查的事件数据源属性。</span><span class="sxs-lookup"><span data-stu-id="f4180-1786">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="f4180-1787">它不应尝试再次引发该事件在大多数情况下。</span><span class="sxs-lookup"><span data-stu-id="f4180-1787">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="f4180-1788">通过重写此方法或通过注册类处理程序替换<xref:System.Windows.EventManager.RegisterClassHandler%2A>，派生类的<xref:System.Windows.ContentElement>为由事件路由收到事件时，可以调用私有类处理程序方法。</span><span class="sxs-lookup"><span data-stu-id="f4180-1788">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="f4180-1789">类处理是相应的一种方案是操作事件数据并将路由的事件标记为已处理。</span><span class="sxs-lookup"><span data-stu-id="f4180-1789">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span> <span data-ttu-id="f4180-1790">专用于预览事件的另一个方案是将已处理，以便匹配冒泡类处理程序不会调用其标记。</span><span class="sxs-lookup"><span data-stu-id="f4180-1790">Another scenario that is specifically for Preview events is to mark them handled so that the matching bubbling class handlers are not invoked.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewStylusUp" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewTextInput">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewTextInput (System.Windows.Input.TextCompositionEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewTextInput(class System.Windows.Input.TextCompositionEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewTextInput(System.Windows.Input.TextCompositionEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewTextInput (e As TextCompositionEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewTextInput(System::Windows::Input::TextCompositionEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewTextInput : System.Windows.Input.TextCompositionEventArgs -&gt; unit&#xA;override this.OnPreviewTextInput : System.Windows.Input.TextCompositionEventArgs -&gt; unit" Usage="contentElement.OnPreviewTextInput e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.TextCompositionEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="f4180-1791">包含事件数据的 <see cref="T:System.Windows.Input.TextCompositionEventArgs" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-1791">The <see cref="T:System.Windows.Input.TextCompositionEventArgs" /> that contains the event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f4180-1792">当某个未处理的 <see cref="E:System.Windows.Input.TextCompositionManager.PreviewTextInput" /> 附加事件在其路由中到达派生自此类的某个元素时调用。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-1792">Invoked when an unhandled <see cref="E:System.Windows.Input.TextCompositionManager.PreviewTextInput" /> attached event reaches an element in its route that is derived from this class.</span>
          </span>
          <span data-ttu-id="f4180-1793">实现此方法可为此事件添加类处理。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-1793">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4180-1794">此方法具有默认实现。</span><span class="sxs-lookup"><span data-stu-id="f4180-1794">This method has no default implementation.</span></span> <span data-ttu-id="f4180-1795">因为中间类继承中的可能会实现此方法，我们建议在实现中调用基实现。</span><span class="sxs-lookup"><span data-stu-id="f4180-1795">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="f4180-1796">此方法的用途是类似于[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]事件模式 On \* 方法： 此方法提供了通过建立类处理程序而不是实例处理程序来处理从派生类的匹配事件的方法。</span><span class="sxs-lookup"><span data-stu-id="f4180-1796">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="f4180-1797">在这种情况下匹配事件是路由的事件。</span><span class="sxs-lookup"><span data-stu-id="f4180-1797">In this case the matching event is a routed event.</span></span> <span data-ttu-id="f4180-1798">On \* 方法的实现模式是不同的路由事件，因为可以由子元素，它不一定是将调用处理程序的元素引发路由的事件。</span><span class="sxs-lookup"><span data-stu-id="f4180-1798">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="f4180-1799">因此，您的实现需要检查的事件数据源属性。</span><span class="sxs-lookup"><span data-stu-id="f4180-1799">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="f4180-1800">它不应尝试再次引发该事件在大多数情况下。</span><span class="sxs-lookup"><span data-stu-id="f4180-1800">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="f4180-1801">通过重写此方法或通过注册类处理程序替换<xref:System.Windows.EventManager.RegisterClassHandler%2A>，派生类的<xref:System.Windows.ContentElement>为由事件路由收到事件时，可以调用私有类处理程序方法。</span><span class="sxs-lookup"><span data-stu-id="f4180-1801">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="f4180-1802">类处理是相应的一种方案是操作事件数据并将路由的事件标记为已处理。</span><span class="sxs-lookup"><span data-stu-id="f4180-1802">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span> <span data-ttu-id="f4180-1803">专用于预览事件的另一个方案是将已处理，以便匹配冒泡类处理程序不会调用其标记。</span><span class="sxs-lookup"><span data-stu-id="f4180-1803">Another scenario that is specifically for Preview events is to mark them handled so that the matching bubbling class handlers are not invoked.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.ContentElement.OnPreviewKeyDown(System.Windows.Input.KeyEventArgs)" />
        <altmember cref="E:System.Windows.ContentElement.PreviewTextInput" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewTouchDown">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewTouchDown (System.Windows.Input.TouchEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewTouchDown(class System.Windows.Input.TouchEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewTouchDown(System.Windows.Input.TouchEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewTouchDown (e As TouchEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewTouchDown(System::Windows::Input::TouchEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewTouchDown : System.Windows.Input.TouchEventArgs -&gt; unit&#xA;override this.OnPreviewTouchDown : System.Windows.Input.TouchEventArgs -&gt; unit" Usage="contentElement.OnPreviewTouchDown e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.TouchEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="f4180-1804">包含事件数据的 <see cref="T:System.Windows.Input.TouchEventArgs" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-1804">A <see cref="T:System.Windows.Input.TouchEventArgs" /> that contains the event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f4180-1805">为在触摸屏输入按下此元素时发生的 <see cref="E:System.Windows.ContentElement.PreviewTouchDown" /> 路由事件提供类处理。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-1805">Provides class handling for the <see cref="E:System.Windows.ContentElement.PreviewTouchDown" /> routed event that occurs when a touch presses this element.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4180-1806"><xref:System.Windows.ContentElement.OnPreviewTouchDown%2A>方法具有默认实现。</span><span class="sxs-lookup"><span data-stu-id="f4180-1806">The <xref:System.Windows.ContentElement.OnPreviewTouchDown%2A> method has no default implementation.</span></span> <span data-ttu-id="f4180-1807">重写<xref:System.Windows.ContentElement.OnPreviewTouchDown%2A>中派生的类来处理<xref:System.Windows.ContentElement.PreviewTouchDown>事件。</span><span class="sxs-lookup"><span data-stu-id="f4180-1807">Override <xref:System.Windows.ContentElement.OnPreviewTouchDown%2A> in a derived class to handle the <xref:System.Windows.ContentElement.PreviewTouchDown> event.</span></span> <span data-ttu-id="f4180-1808">请务必调用基类的<xref:System.Windows.ContentElement.OnPreviewTouchDown%2A>方法，从而基本类接收事件。</span><span class="sxs-lookup"><span data-stu-id="f4180-1808">Be sure to call the base class’s <xref:System.Windows.ContentElement.OnPreviewTouchDown%2A> method so that base classes receive the event.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnPreviewTouchMove">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewTouchMove (System.Windows.Input.TouchEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewTouchMove(class System.Windows.Input.TouchEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewTouchMove(System.Windows.Input.TouchEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewTouchMove (e As TouchEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewTouchMove(System::Windows::Input::TouchEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewTouchMove : System.Windows.Input.TouchEventArgs -&gt; unit&#xA;override this.OnPreviewTouchMove : System.Windows.Input.TouchEventArgs -&gt; unit" Usage="contentElement.OnPreviewTouchMove e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.TouchEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="f4180-1809">包含事件数据的 <see cref="T:System.Windows.Input.TouchEventArgs" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-1809">A <see cref="T:System.Windows.Input.TouchEventArgs" /> that contains the event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f4180-1810">为在此元素内部移动触摸屏输入时发生的 <see cref="E:System.Windows.ContentElement.PreviewTouchMove" /> 路由事件提供类处理。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-1810">Provides class handling for the <see cref="E:System.Windows.ContentElement.PreviewTouchMove" /> routed event that occurs when a touch moves while inside this element.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4180-1811"><xref:System.Windows.ContentElement.OnPreviewTouchMove%2A>方法具有默认实现。</span><span class="sxs-lookup"><span data-stu-id="f4180-1811">The <xref:System.Windows.ContentElement.OnPreviewTouchMove%2A> method has no default implementation.</span></span> <span data-ttu-id="f4180-1812">重写<xref:System.Windows.ContentElement.OnPreviewTouchMove%2A>中派生的类来处理<xref:System.Windows.ContentElement.PreviewTouchMove>事件。</span><span class="sxs-lookup"><span data-stu-id="f4180-1812">Override <xref:System.Windows.ContentElement.OnPreviewTouchMove%2A> in a derived class to handle the <xref:System.Windows.ContentElement.PreviewTouchMove> event.</span></span> <span data-ttu-id="f4180-1813">请务必调用基类的<xref:System.Windows.ContentElement.OnPreviewTouchMove%2A>方法，从而基本类接收事件。</span><span class="sxs-lookup"><span data-stu-id="f4180-1813">Be sure to call the base class’s <xref:System.Windows.ContentElement.OnPreviewTouchMove%2A> method so that base classes receive the event.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnPreviewTouchUp">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewTouchUp (System.Windows.Input.TouchEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewTouchUp(class System.Windows.Input.TouchEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewTouchUp(System.Windows.Input.TouchEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewTouchUp (e As TouchEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewTouchUp(System::Windows::Input::TouchEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewTouchUp : System.Windows.Input.TouchEventArgs -&gt; unit&#xA;override this.OnPreviewTouchUp : System.Windows.Input.TouchEventArgs -&gt; unit" Usage="contentElement.OnPreviewTouchUp e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.TouchEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="f4180-1814">包含事件数据的 <see cref="T:System.Windows.Input.TouchEventArgs" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-1814">A <see cref="T:System.Windows.Input.TouchEventArgs" /> that contains the event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f4180-1815">为在此元素内部释放触摸屏输入时发生的 <see cref="E:System.Windows.ContentElement.PreviewTouchUp" /> 路由事件提供类处理。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-1815">Provides class handling for the <see cref="E:System.Windows.ContentElement.PreviewTouchUp" /> routed event that occurs when a touch is released inside this element.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4180-1816"><xref:System.Windows.ContentElement.OnPreviewTouchUp%2A>方法具有默认实现。</span><span class="sxs-lookup"><span data-stu-id="f4180-1816">The <xref:System.Windows.ContentElement.OnPreviewTouchUp%2A> method has no default implementation.</span></span> <span data-ttu-id="f4180-1817">重写<xref:System.Windows.ContentElement.OnPreviewTouchUp%2A>中派生的类来处理<xref:System.Windows.ContentElement.PreviewTouchUp>事件。</span><span class="sxs-lookup"><span data-stu-id="f4180-1817">Override <xref:System.Windows.ContentElement.OnPreviewTouchUp%2A> in a derived class to handle the <xref:System.Windows.ContentElement.PreviewTouchUp> event.</span></span> <span data-ttu-id="f4180-1818">请务必调用基类的<xref:System.Windows.ContentElement.OnPreviewTouchUp%2A>方法，从而基本类接收事件。</span><span class="sxs-lookup"><span data-stu-id="f4180-1818">Be sure to call the base class’s <xref:System.Windows.ContentElement.OnPreviewTouchUp%2A> method so that base classes receive the event.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnQueryContinueDrag">
      <MemberSignature Language="C#" Value="protected internal virtual void OnQueryContinueDrag (System.Windows.QueryContinueDragEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnQueryContinueDrag(class System.Windows.QueryContinueDragEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnQueryContinueDrag(System.Windows.QueryContinueDragEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnQueryContinueDrag (e As QueryContinueDragEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnQueryContinueDrag(System::Windows::QueryContinueDragEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnQueryContinueDrag : System.Windows.QueryContinueDragEventArgs -&gt; unit&#xA;override this.OnQueryContinueDrag : System.Windows.QueryContinueDragEventArgs -&gt; unit" Usage="contentElement.OnQueryContinueDrag e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.QueryContinueDragEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="f4180-1819">包含事件数据的 <see cref="T:System.Windows.QueryContinueDragEventArgs" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-1819">The <see cref="T:System.Windows.QueryContinueDragEventArgs" /> that contains the event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f4180-1820">当某个未处理的 <see cref="E:System.Windows.DragDrop.QueryContinueDrag" /> 附加事件在其路由中到达派生自此类的某个元素时调用。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-1820">Invoked when an unhandled <see cref="E:System.Windows.DragDrop.QueryContinueDrag" /> attached event reaches an element in its route that is derived from this class.</span>
          </span>
          <span data-ttu-id="f4180-1821">实现此方法可为此事件添加类处理。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-1821">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4180-1822">此方法具有默认实现。</span><span class="sxs-lookup"><span data-stu-id="f4180-1822">This method has no default implementation.</span></span> <span data-ttu-id="f4180-1823">因为中间类继承中的可能会实现此方法，我们建议在实现中调用基实现。</span><span class="sxs-lookup"><span data-stu-id="f4180-1823">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="f4180-1824">此方法的用途是类似于[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]事件模式 On \* 方法： 此方法提供了通过建立类处理程序而不是实例处理程序来处理从派生类的匹配事件的方法。</span><span class="sxs-lookup"><span data-stu-id="f4180-1824">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="f4180-1825">在这种情况下匹配事件是路由的事件。</span><span class="sxs-lookup"><span data-stu-id="f4180-1825">In this case the matching event is a routed event.</span></span> <span data-ttu-id="f4180-1826">On \* 方法的实现模式是不同的路由事件，因为可以由子元素，它不一定是将调用处理程序的元素引发路由的事件。</span><span class="sxs-lookup"><span data-stu-id="f4180-1826">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="f4180-1827">因此，您的实现需要检查的事件数据源属性。</span><span class="sxs-lookup"><span data-stu-id="f4180-1827">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="f4180-1828">它不应尝试再次引发该事件在大多数情况下。</span><span class="sxs-lookup"><span data-stu-id="f4180-1828">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="f4180-1829">通过重写此方法或通过注册类处理程序替换<xref:System.Windows.EventManager.RegisterClassHandler%2A>，派生类的<xref:System.Windows.ContentElement>为由事件路由收到事件时，可以调用私有类处理程序方法。</span><span class="sxs-lookup"><span data-stu-id="f4180-1829">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="f4180-1830">类处理是相应的一种方案是操作事件数据并将路由的事件标记为已处理。</span><span class="sxs-lookup"><span data-stu-id="f4180-1830">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.QueryContinueDrag" />
      </Docs>
    </Member>
    <Member MemberName="OnQueryCursor">
      <MemberSignature Language="C#" Value="protected internal virtual void OnQueryCursor (System.Windows.Input.QueryCursorEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnQueryCursor(class System.Windows.Input.QueryCursorEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnQueryCursor(System.Windows.Input.QueryCursorEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnQueryCursor (e As QueryCursorEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnQueryCursor(System::Windows::Input::QueryCursorEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnQueryCursor : System.Windows.Input.QueryCursorEventArgs -&gt; unit&#xA;override this.OnQueryCursor : System.Windows.Input.QueryCursorEventArgs -&gt; unit" Usage="contentElement.OnQueryCursor e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.QueryCursorEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="f4180-1831">包含事件数据的 <see cref="T:System.Windows.Input.QueryCursorEventArgs" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-1831">The <see cref="T:System.Windows.Input.QueryCursorEventArgs" /> that contains the event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f4180-1832">当某个未处理的 <see cref="E:System.Windows.Input.Mouse.QueryCursor" /> 附加事件在其路由中到达派生自此类的某个元素时调用。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-1832">Invoked when an unhandled <see cref="E:System.Windows.Input.Mouse.QueryCursor" /> attached event reaches an element in its route that is derived from this class.</span>
          </span>
          <span data-ttu-id="f4180-1833">实现此方法可为此事件添加类处理。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-1833">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4180-1834">此方法具有默认实现。</span><span class="sxs-lookup"><span data-stu-id="f4180-1834">This method has no default implementation.</span></span> <span data-ttu-id="f4180-1835">因为中间类继承中的可能会实现此方法，我们建议在实现中调用基实现。</span><span class="sxs-lookup"><span data-stu-id="f4180-1835">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="f4180-1836">此方法的用途是类似于[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]事件模式 On \* 方法： 此方法提供了通过建立类处理程序而不是实例处理程序来处理从派生类的匹配事件的方法。</span><span class="sxs-lookup"><span data-stu-id="f4180-1836">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="f4180-1837">在这种情况下匹配事件是路由的事件。</span><span class="sxs-lookup"><span data-stu-id="f4180-1837">In this case the matching event is a routed event.</span></span> <span data-ttu-id="f4180-1838">On \* 方法的实现模式是不同的路由事件，因为可以由子元素，它不一定是将调用处理程序的元素引发路由的事件。</span><span class="sxs-lookup"><span data-stu-id="f4180-1838">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="f4180-1839">因此，您的实现需要检查的事件数据源属性。</span><span class="sxs-lookup"><span data-stu-id="f4180-1839">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="f4180-1840">它不应尝试再次引发该事件在大多数情况下。</span><span class="sxs-lookup"><span data-stu-id="f4180-1840">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="f4180-1841">通过重写此方法或通过注册类处理程序替换<xref:System.Windows.EventManager.RegisterClassHandler%2A>，派生类的<xref:System.Windows.ContentElement>为由事件路由收到事件时，可以调用私有类处理程序方法。</span><span class="sxs-lookup"><span data-stu-id="f4180-1841">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="f4180-1842">类处理是相应的一种方案是操作事件数据并将路由的事件标记为已处理。</span><span class="sxs-lookup"><span data-stu-id="f4180-1842">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.QueryCursor" />
      </Docs>
    </Member>
    <Member MemberName="OnStylusButtonDown">
      <MemberSignature Language="C#" Value="protected internal virtual void OnStylusButtonDown (System.Windows.Input.StylusButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnStylusButtonDown(class System.Windows.Input.StylusButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnStylusButtonDown(System.Windows.Input.StylusButtonEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnStylusButtonDown (e As StylusButtonEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnStylusButtonDown(System::Windows::Input::StylusButtonEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnStylusButtonDown : System.Windows.Input.StylusButtonEventArgs -&gt; unit&#xA;override this.OnStylusButtonDown : System.Windows.Input.StylusButtonEventArgs -&gt; unit" Usage="contentElement.OnStylusButtonDown e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="f4180-1843">包含事件数据的 <see cref="T:System.Windows.Input.StylusButtonEventArgs" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-1843">The <see cref="T:System.Windows.Input.StylusButtonEventArgs" /> that contains the event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f4180-1844">当某个未处理的 <see cref="E:System.Windows.Input.Stylus.StylusButtonDown" /> 附加事件在其路由中到达派生自此类的某个元素时调用。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-1844">Invoked when an unhandled <see cref="E:System.Windows.Input.Stylus.StylusButtonDown" /> attached event reaches an element in its route that is derived from this class.</span>
          </span>
          <span data-ttu-id="f4180-1845">实现此方法可为此事件添加类处理。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-1845">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4180-1846">此方法具有默认实现。</span><span class="sxs-lookup"><span data-stu-id="f4180-1846">This method has no default implementation.</span></span> <span data-ttu-id="f4180-1847">因为中间类继承中的可能会实现此方法，我们建议在实现中调用基实现。</span><span class="sxs-lookup"><span data-stu-id="f4180-1847">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="f4180-1848">此方法的用途是类似于[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]事件模式 On \* 方法： 此方法提供了通过建立类处理程序而不是实例处理程序来处理从派生类的匹配事件的方法。</span><span class="sxs-lookup"><span data-stu-id="f4180-1848">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="f4180-1849">在这种情况下匹配事件是路由的事件。</span><span class="sxs-lookup"><span data-stu-id="f4180-1849">In this case the matching event is a routed event.</span></span> <span data-ttu-id="f4180-1850">On \* 方法的实现模式是不同的路由事件，因为可以由子元素，它不一定是将调用处理程序的元素引发路由的事件。</span><span class="sxs-lookup"><span data-stu-id="f4180-1850">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="f4180-1851">因此，您的实现需要检查的事件数据源属性。</span><span class="sxs-lookup"><span data-stu-id="f4180-1851">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="f4180-1852">它不应尝试再次引发该事件在大多数情况下。</span><span class="sxs-lookup"><span data-stu-id="f4180-1852">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="f4180-1853">通过重写此方法或通过注册类处理程序替换<xref:System.Windows.EventManager.RegisterClassHandler%2A>，派生类的<xref:System.Windows.ContentElement>为由事件路由收到事件时，可以调用私有类处理程序方法。</span><span class="sxs-lookup"><span data-stu-id="f4180-1853">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="f4180-1854">类处理是相应的一种方案是操作事件数据并将路由的事件标记为已处理。</span><span class="sxs-lookup"><span data-stu-id="f4180-1854">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.StylusButtonDown" />
      </Docs>
    </Member>
    <Member MemberName="OnStylusButtonUp">
      <MemberSignature Language="C#" Value="protected internal virtual void OnStylusButtonUp (System.Windows.Input.StylusButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnStylusButtonUp(class System.Windows.Input.StylusButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnStylusButtonUp(System.Windows.Input.StylusButtonEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnStylusButtonUp (e As StylusButtonEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnStylusButtonUp(System::Windows::Input::StylusButtonEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnStylusButtonUp : System.Windows.Input.StylusButtonEventArgs -&gt; unit&#xA;override this.OnStylusButtonUp : System.Windows.Input.StylusButtonEventArgs -&gt; unit" Usage="contentElement.OnStylusButtonUp e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="f4180-1855">包含事件数据的 <see cref="T:System.Windows.Input.StylusButtonEventArgs" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-1855">The <see cref="T:System.Windows.Input.StylusButtonEventArgs" /> that contains the event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f4180-1856">当某个未处理的 <see cref="E:System.Windows.Input.Stylus.StylusButtonUp" /> 附加事件在其路由中到达派生自此类的某个元素时调用。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-1856">Invoked when an unhandled <see cref="E:System.Windows.Input.Stylus.StylusButtonUp" /> attached event reaches an element in its route that is derived from this class.</span>
          </span>
          <span data-ttu-id="f4180-1857">实现此方法可为此事件添加类处理。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-1857">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4180-1858">此方法具有默认实现。</span><span class="sxs-lookup"><span data-stu-id="f4180-1858">This method has no default implementation.</span></span> <span data-ttu-id="f4180-1859">因为中间类继承中的可能会实现此方法，我们建议在实现中调用基实现。</span><span class="sxs-lookup"><span data-stu-id="f4180-1859">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="f4180-1860">此方法的用途是类似于[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]事件模式 On \* 方法： 此方法提供了通过建立类处理程序而不是实例处理程序来处理从派生类的匹配事件的方法。</span><span class="sxs-lookup"><span data-stu-id="f4180-1860">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="f4180-1861">在这种情况下匹配事件是路由的事件。</span><span class="sxs-lookup"><span data-stu-id="f4180-1861">In this case the matching event is a routed event.</span></span> <span data-ttu-id="f4180-1862">On \* 方法的实现模式是不同的路由事件，因为可以由子元素，它不一定是将调用处理程序的元素引发路由的事件。</span><span class="sxs-lookup"><span data-stu-id="f4180-1862">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="f4180-1863">因此，您的实现需要检查的事件数据源属性。</span><span class="sxs-lookup"><span data-stu-id="f4180-1863">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="f4180-1864">它不应尝试再次引发该事件在大多数情况下。</span><span class="sxs-lookup"><span data-stu-id="f4180-1864">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="f4180-1865">通过重写此方法或通过注册类处理程序替换<xref:System.Windows.EventManager.RegisterClassHandler%2A>，派生类的<xref:System.Windows.ContentElement>为由事件路由收到事件时，可以调用私有类处理程序方法。</span><span class="sxs-lookup"><span data-stu-id="f4180-1865">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="f4180-1866">类处理是相应的一种方案是操作事件数据并将路由的事件标记为已处理。</span><span class="sxs-lookup"><span data-stu-id="f4180-1866">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.StylusButtonUp" />
      </Docs>
    </Member>
    <Member MemberName="OnStylusDown">
      <MemberSignature Language="C#" Value="protected internal virtual void OnStylusDown (System.Windows.Input.StylusDownEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnStylusDown(class System.Windows.Input.StylusDownEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnStylusDown(System.Windows.Input.StylusDownEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnStylusDown (e As StylusDownEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnStylusDown(System::Windows::Input::StylusDownEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnStylusDown : System.Windows.Input.StylusDownEventArgs -&gt; unit&#xA;override this.OnStylusDown : System.Windows.Input.StylusDownEventArgs -&gt; unit" Usage="contentElement.OnStylusDown e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusDownEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="f4180-1867">包含事件数据的 <see cref="T:System.Windows.Input.StylusDownEventArgs" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-1867">The <see cref="T:System.Windows.Input.StylusDownEventArgs" /> that contains the event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f4180-1868">当某个未处理的 <see cref="E:System.Windows.Input.Stylus.StylusDown" /> 附加事件在其路由中到达派生自此类的某个元素时调用。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-1868">Invoked when an unhandled <see cref="E:System.Windows.Input.Stylus.StylusDown" /> attached event reaches an element in its route that is derived from this class.</span>
          </span>
          <span data-ttu-id="f4180-1869">实现此方法可为此事件添加类处理。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-1869">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4180-1870">此方法具有默认实现。</span><span class="sxs-lookup"><span data-stu-id="f4180-1870">This method has no default implementation.</span></span> <span data-ttu-id="f4180-1871">因为中间类继承中的可能会实现此方法，我们建议在实现中调用基实现。</span><span class="sxs-lookup"><span data-stu-id="f4180-1871">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="f4180-1872">此方法的用途是类似于[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]事件模式 On \* 方法： 此方法提供了通过建立类处理程序而不是实例处理程序来处理从派生类的匹配事件的方法。</span><span class="sxs-lookup"><span data-stu-id="f4180-1872">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="f4180-1873">在这种情况下匹配事件是路由的事件。</span><span class="sxs-lookup"><span data-stu-id="f4180-1873">In this case the matching event is a routed event.</span></span> <span data-ttu-id="f4180-1874">On \* 方法的实现模式是不同的路由事件，因为可以由子元素，它不一定是将调用处理程序的元素引发路由的事件。</span><span class="sxs-lookup"><span data-stu-id="f4180-1874">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="f4180-1875">因此，您的实现需要检查的事件数据源属性。</span><span class="sxs-lookup"><span data-stu-id="f4180-1875">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="f4180-1876">它不应尝试再次引发该事件在大多数情况下。</span><span class="sxs-lookup"><span data-stu-id="f4180-1876">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="f4180-1877">通过重写此方法或通过注册类处理程序替换<xref:System.Windows.EventManager.RegisterClassHandler%2A>，派生类的<xref:System.Windows.ContentElement>为由事件路由收到事件时，可以调用私有类处理程序方法。</span><span class="sxs-lookup"><span data-stu-id="f4180-1877">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="f4180-1878">类处理是相应的一种方案是操作事件数据并将路由的事件标记为已处理。</span><span class="sxs-lookup"><span data-stu-id="f4180-1878">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.StylusDown" />
      </Docs>
    </Member>
    <Member MemberName="OnStylusEnter">
      <MemberSignature Language="C#" Value="protected internal virtual void OnStylusEnter (System.Windows.Input.StylusEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnStylusEnter(class System.Windows.Input.StylusEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnStylusEnter(System.Windows.Input.StylusEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnStylusEnter (e As StylusEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnStylusEnter(System::Windows::Input::StylusEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnStylusEnter : System.Windows.Input.StylusEventArgs -&gt; unit&#xA;override this.OnStylusEnter : System.Windows.Input.StylusEventArgs -&gt; unit" Usage="contentElement.OnStylusEnter e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="f4180-1879">包含事件数据的 <see cref="T:System.Windows.Input.StylusEventArgs" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-1879">The <see cref="T:System.Windows.Input.StylusEventArgs" /> that contains the event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f4180-1880">当此元素引发未处理的 <see cref="E:System.Windows.Input.Stylus.StylusEnter" /> 附加事件时调用。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-1880">Invoked when an unhandled <see cref="E:System.Windows.Input.Stylus.StylusEnter" /> attached event is raised by this element.</span>
          </span>
          <span data-ttu-id="f4180-1881">实现此方法可为此事件添加类处理。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-1881">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4180-1882">此方法具有默认实现。</span><span class="sxs-lookup"><span data-stu-id="f4180-1882">This method has no default implementation.</span></span> <span data-ttu-id="f4180-1883">因为中间类继承中的可能会实现此方法，我们建议在实现中调用基实现。</span><span class="sxs-lookup"><span data-stu-id="f4180-1883">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span> <span data-ttu-id="f4180-1884">您可以调用基之前或之后应用特殊处理，具体取决于您的要求。</span><span class="sxs-lookup"><span data-stu-id="f4180-1884">You may call base either before or after your special handling, depending on your requirements.</span></span>  
  
 <span data-ttu-id="f4180-1885">此方法的用途是类似于[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]事件模式 On \* 方法： 此方法提供了通过建立类处理程序而不是实例处理程序来处理从派生类的匹配事件的方法。</span><span class="sxs-lookup"><span data-stu-id="f4180-1885">The purpose of this method is similar to [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="f4180-1886">在这种情况下匹配事件是路由的事件。</span><span class="sxs-lookup"><span data-stu-id="f4180-1886">In this case the matching event is a routed event.</span></span> <span data-ttu-id="f4180-1887">将事件标记为已处理是仍有助于防止典型实例处理程序 (未指定的那些`handledEventsToo`) 调用。</span><span class="sxs-lookup"><span data-stu-id="f4180-1887">Marking the event as handled is still useful for preventing typical instance handlers (those that do not specify `handledEventsToo`) from being invoked.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.StylusEnter" />
      </Docs>
    </Member>
    <Member MemberName="OnStylusInAirMove">
      <MemberSignature Language="C#" Value="protected internal virtual void OnStylusInAirMove (System.Windows.Input.StylusEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnStylusInAirMove(class System.Windows.Input.StylusEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnStylusInAirMove(System.Windows.Input.StylusEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnStylusInAirMove (e As StylusEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnStylusInAirMove(System::Windows::Input::StylusEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnStylusInAirMove : System.Windows.Input.StylusEventArgs -&gt; unit&#xA;override this.OnStylusInAirMove : System.Windows.Input.StylusEventArgs -&gt; unit" Usage="contentElement.OnStylusInAirMove e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="f4180-1888">包含事件数据的 <see cref="T:System.Windows.Input.StylusEventArgs" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-1888">The <see cref="T:System.Windows.Input.StylusEventArgs" /> that contains the event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f4180-1889">当某个未处理的 <see cref="E:System.Windows.Input.Stylus.StylusInAirMove" /> 附加事件在其路由中到达派生自此类的某个元素时调用。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-1889">Invoked when an unhandled <see cref="E:System.Windows.Input.Stylus.StylusInAirMove" /> attached event reaches an element in its route that is derived from this class.</span>
          </span>
          <span data-ttu-id="f4180-1890">实现此方法可为此事件添加类处理。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-1890">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4180-1891">此方法具有默认实现。</span><span class="sxs-lookup"><span data-stu-id="f4180-1891">This method has no default implementation.</span></span> <span data-ttu-id="f4180-1892">因为中间类继承中的可能会实现此方法，我们建议在实现中调用基实现。</span><span class="sxs-lookup"><span data-stu-id="f4180-1892">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="f4180-1893">此方法的用途是类似于[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]事件模式 On \* 方法： 此方法提供了通过建立类处理程序而不是实例处理程序来处理从派生类的匹配事件的方法。</span><span class="sxs-lookup"><span data-stu-id="f4180-1893">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="f4180-1894">在这种情况下匹配事件是路由的事件。</span><span class="sxs-lookup"><span data-stu-id="f4180-1894">In this case the matching event is a routed event.</span></span> <span data-ttu-id="f4180-1895">On \* 方法的实现模式是不同的路由事件，因为可以由子元素，它不一定是将调用处理程序的元素引发路由的事件。</span><span class="sxs-lookup"><span data-stu-id="f4180-1895">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="f4180-1896">因此，您的实现需要检查的事件数据源属性。</span><span class="sxs-lookup"><span data-stu-id="f4180-1896">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="f4180-1897">它不应尝试再次引发该事件在大多数情况下。</span><span class="sxs-lookup"><span data-stu-id="f4180-1897">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="f4180-1898">通过重写此方法或通过注册类处理程序替换<xref:System.Windows.EventManager.RegisterClassHandler%2A>，派生类的<xref:System.Windows.ContentElement>为由事件路由收到事件时，可以调用私有类处理程序方法。</span><span class="sxs-lookup"><span data-stu-id="f4180-1898">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="f4180-1899">类处理是相应的一种方案是操作事件数据并将路由的事件标记为已处理。</span><span class="sxs-lookup"><span data-stu-id="f4180-1899">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.StylusInAirMove" />
      </Docs>
    </Member>
    <Member MemberName="OnStylusInRange">
      <MemberSignature Language="C#" Value="protected internal virtual void OnStylusInRange (System.Windows.Input.StylusEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnStylusInRange(class System.Windows.Input.StylusEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnStylusInRange(System.Windows.Input.StylusEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnStylusInRange (e As StylusEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnStylusInRange(System::Windows::Input::StylusEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnStylusInRange : System.Windows.Input.StylusEventArgs -&gt; unit&#xA;override this.OnStylusInRange : System.Windows.Input.StylusEventArgs -&gt; unit" Usage="contentElement.OnStylusInRange e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="f4180-1900">包含事件数据的 <see cref="T:System.Windows.Input.StylusEventArgs" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-1900">The <see cref="T:System.Windows.Input.StylusEventArgs" /> that contains the event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f4180-1901">当某个未处理的 <see cref="E:System.Windows.Input.Stylus.StylusInRange" /> 附加事件在其路由中到达派生自此类的某个元素时调用。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-1901">Invoked when an unhandled <see cref="E:System.Windows.Input.Stylus.StylusInRange" /> attached event reaches an element in its route that is derived from this class.</span>
          </span>
          <span data-ttu-id="f4180-1902">实现此方法可为此事件添加类处理。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-1902">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4180-1903">此方法具有默认实现。</span><span class="sxs-lookup"><span data-stu-id="f4180-1903">This method has no default implementation.</span></span> <span data-ttu-id="f4180-1904">因为中间类继承中的可能会实现此方法，我们建议在实现中调用基实现。</span><span class="sxs-lookup"><span data-stu-id="f4180-1904">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="f4180-1905">此方法的用途是类似于[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]事件模式 On \* 方法： 此方法提供了通过建立类处理程序而不是实例处理程序来处理从派生类的匹配事件的方法。</span><span class="sxs-lookup"><span data-stu-id="f4180-1905">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="f4180-1906">在这种情况下匹配事件是路由的事件。</span><span class="sxs-lookup"><span data-stu-id="f4180-1906">In this case the matching event is a routed event.</span></span> <span data-ttu-id="f4180-1907">On \* 方法的实现模式是不同的路由事件，因为可以由子元素，它不一定是将调用处理程序的元素引发路由的事件。</span><span class="sxs-lookup"><span data-stu-id="f4180-1907">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="f4180-1908">因此，您的实现需要检查的事件数据源属性。</span><span class="sxs-lookup"><span data-stu-id="f4180-1908">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="f4180-1909">它不应尝试再次引发该事件在大多数情况下。</span><span class="sxs-lookup"><span data-stu-id="f4180-1909">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="f4180-1910">通过重写此方法或通过注册类处理程序替换<xref:System.Windows.EventManager.RegisterClassHandler%2A>，派生类的<xref:System.Windows.ContentElement>为由事件路由收到事件时，可以调用私有类处理程序方法。</span><span class="sxs-lookup"><span data-stu-id="f4180-1910">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="f4180-1911">类处理是相应的一种方案是操作事件数据并将路由的事件标记为已处理。</span><span class="sxs-lookup"><span data-stu-id="f4180-1911">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.StylusInRange" />
      </Docs>
    </Member>
    <Member MemberName="OnStylusLeave">
      <MemberSignature Language="C#" Value="protected internal virtual void OnStylusLeave (System.Windows.Input.StylusEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnStylusLeave(class System.Windows.Input.StylusEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnStylusLeave(System.Windows.Input.StylusEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnStylusLeave (e As StylusEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnStylusLeave(System::Windows::Input::StylusEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnStylusLeave : System.Windows.Input.StylusEventArgs -&gt; unit&#xA;override this.OnStylusLeave : System.Windows.Input.StylusEventArgs -&gt; unit" Usage="contentElement.OnStylusLeave e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="f4180-1912">包含事件数据的 <see cref="T:System.Windows.Input.StylusEventArgs" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-1912">The <see cref="T:System.Windows.Input.StylusEventArgs" /> that contains the event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f4180-1913">当此元素引发未处理的 <see cref="E:System.Windows.Input.Stylus.StylusLeave" /> 附加事件时调用。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-1913">Invoked when an unhandled <see cref="E:System.Windows.Input.Stylus.StylusLeave" /> attached event is raised by this element.</span>
          </span>
          <span data-ttu-id="f4180-1914">实现此方法可为此事件添加类处理。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-1914">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4180-1915">此方法具有默认实现。</span><span class="sxs-lookup"><span data-stu-id="f4180-1915">This method has no default implementation.</span></span> <span data-ttu-id="f4180-1916">因为中间类继承中的可能会实现此方法，我们建议在实现中调用基实现。</span><span class="sxs-lookup"><span data-stu-id="f4180-1916">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span> <span data-ttu-id="f4180-1917">您可以调用基之前或之后应用特殊处理，具体取决于您的要求。</span><span class="sxs-lookup"><span data-stu-id="f4180-1917">You may call base either before or after your special handling, depending on your requirements.</span></span>  
  
 <span data-ttu-id="f4180-1918">此方法的用途是类似于[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]事件模式 On \* 方法： 此方法提供了通过建立类处理程序而不是实例处理程序来处理从派生类的匹配事件的方法。</span><span class="sxs-lookup"><span data-stu-id="f4180-1918">The purpose of this method is similar to [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="f4180-1919">在这种情况下匹配事件是路由的事件。</span><span class="sxs-lookup"><span data-stu-id="f4180-1919">In this case the matching event is a routed event.</span></span> <span data-ttu-id="f4180-1920">将事件标记为已处理是仍有助于防止典型实例处理程序 (未指定的那些`handledEventsToo`) 调用。</span><span class="sxs-lookup"><span data-stu-id="f4180-1920">Marking the event as handled is still useful for preventing typical instance handlers (those that do not specify `handledEventsToo`) from being invoked.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.StylusLeave" />
      </Docs>
    </Member>
    <Member MemberName="OnStylusMove">
      <MemberSignature Language="C#" Value="protected internal virtual void OnStylusMove (System.Windows.Input.StylusEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnStylusMove(class System.Windows.Input.StylusEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnStylusMove(System.Windows.Input.StylusEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnStylusMove (e As StylusEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnStylusMove(System::Windows::Input::StylusEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnStylusMove : System.Windows.Input.StylusEventArgs -&gt; unit&#xA;override this.OnStylusMove : System.Windows.Input.StylusEventArgs -&gt; unit" Usage="contentElement.OnStylusMove e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="f4180-1921">包含事件数据的 <see cref="T:System.Windows.Input.StylusEventArgs" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-1921">The <see cref="T:System.Windows.Input.StylusEventArgs" /> that contains the event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f4180-1922">当某个未处理的 <see cref="E:System.Windows.Input.Stylus.StylusMove" /> 附加事件在其路由中到达派生自此类的某个元素时调用。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-1922">Invoked when an unhandled <see cref="E:System.Windows.Input.Stylus.StylusMove" /> attached event reaches an element in its route that is derived from this class.</span>
          </span>
          <span data-ttu-id="f4180-1923">实现此方法可为此事件添加类处理。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-1923">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4180-1924">此方法具有默认实现。</span><span class="sxs-lookup"><span data-stu-id="f4180-1924">This method has no default implementation.</span></span> <span data-ttu-id="f4180-1925">因为中间类继承中的可能会实现此方法，我们建议在实现中调用基实现。</span><span class="sxs-lookup"><span data-stu-id="f4180-1925">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="f4180-1926">此方法的用途是类似于[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]事件模式 On \* 方法： 此方法提供了通过建立类处理程序而不是实例处理程序来处理从派生类的匹配事件的方法。</span><span class="sxs-lookup"><span data-stu-id="f4180-1926">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="f4180-1927">在这种情况下匹配事件是路由的事件。</span><span class="sxs-lookup"><span data-stu-id="f4180-1927">In this case the matching event is a routed event.</span></span> <span data-ttu-id="f4180-1928">On \* 方法的实现模式是不同的路由事件，因为可以由子元素，它不一定是将调用处理程序的元素引发路由的事件。</span><span class="sxs-lookup"><span data-stu-id="f4180-1928">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="f4180-1929">因此，您的实现需要检查的事件数据源属性。</span><span class="sxs-lookup"><span data-stu-id="f4180-1929">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="f4180-1930">它不应尝试再次引发该事件在大多数情况下。</span><span class="sxs-lookup"><span data-stu-id="f4180-1930">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="f4180-1931">通过重写此方法或通过注册类处理程序替换<xref:System.Windows.EventManager.RegisterClassHandler%2A>，派生类的<xref:System.Windows.ContentElement>为由事件路由收到事件时，可以调用私有类处理程序方法。</span><span class="sxs-lookup"><span data-stu-id="f4180-1931">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="f4180-1932">类处理是相应的一种方案是操作事件数据并将路由的事件标记为已处理。</span><span class="sxs-lookup"><span data-stu-id="f4180-1932">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.StylusMove" />
      </Docs>
    </Member>
    <Member MemberName="OnStylusOutOfRange">
      <MemberSignature Language="C#" Value="protected internal virtual void OnStylusOutOfRange (System.Windows.Input.StylusEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnStylusOutOfRange(class System.Windows.Input.StylusEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnStylusOutOfRange(System.Windows.Input.StylusEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnStylusOutOfRange (e As StylusEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnStylusOutOfRange(System::Windows::Input::StylusEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnStylusOutOfRange : System.Windows.Input.StylusEventArgs -&gt; unit&#xA;override this.OnStylusOutOfRange : System.Windows.Input.StylusEventArgs -&gt; unit" Usage="contentElement.OnStylusOutOfRange e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="f4180-1933">包含事件数据的 <see cref="T:System.Windows.Input.StylusEventArgs" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-1933">The <see cref="T:System.Windows.Input.StylusEventArgs" /> that contains the event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f4180-1934">当某个未处理的 <see cref="E:System.Windows.Input.Stylus.StylusOutOfRange" /> 附加事件在其路由中到达派生自此类的某个元素时调用。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-1934">Invoked when an unhandled <see cref="E:System.Windows.Input.Stylus.StylusOutOfRange" /> attached event reaches an element in its route that is derived from this class.</span>
          </span>
          <span data-ttu-id="f4180-1935">实现此方法可为此事件添加类处理。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-1935">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4180-1936">此方法具有默认实现。</span><span class="sxs-lookup"><span data-stu-id="f4180-1936">This method has no default implementation.</span></span> <span data-ttu-id="f4180-1937">因为中间类继承中的可能会实现此方法，我们建议在实现中调用基实现。</span><span class="sxs-lookup"><span data-stu-id="f4180-1937">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="f4180-1938">此方法的用途是类似于[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]事件模式 On \* 方法： 此方法提供了通过建立类处理程序而不是实例处理程序来处理从派生类的匹配事件的方法。</span><span class="sxs-lookup"><span data-stu-id="f4180-1938">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="f4180-1939">在这种情况下匹配事件是路由的事件。</span><span class="sxs-lookup"><span data-stu-id="f4180-1939">In this case the matching event is a routed event.</span></span> <span data-ttu-id="f4180-1940">On \* 方法的实现模式是不同的路由事件，因为可以由子元素，它不一定是将调用处理程序的元素引发路由的事件。</span><span class="sxs-lookup"><span data-stu-id="f4180-1940">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="f4180-1941">因此，您的实现需要检查的事件数据源属性。</span><span class="sxs-lookup"><span data-stu-id="f4180-1941">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="f4180-1942">它不应尝试再次引发该事件在大多数情况下。</span><span class="sxs-lookup"><span data-stu-id="f4180-1942">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="f4180-1943">通过重写此方法或通过注册类处理程序替换<xref:System.Windows.EventManager.RegisterClassHandler%2A>，派生类的<xref:System.Windows.ContentElement>为由事件路由收到事件时，可以调用私有类处理程序方法。</span><span class="sxs-lookup"><span data-stu-id="f4180-1943">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="f4180-1944">类处理是相应的一种方案是操作事件数据并将路由的事件标记为已处理。</span><span class="sxs-lookup"><span data-stu-id="f4180-1944">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.StylusOutOfRange" />
      </Docs>
    </Member>
    <Member MemberName="OnStylusSystemGesture">
      <MemberSignature Language="C#" Value="protected internal virtual void OnStylusSystemGesture (System.Windows.Input.StylusSystemGestureEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnStylusSystemGesture(class System.Windows.Input.StylusSystemGestureEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnStylusSystemGesture(System.Windows.Input.StylusSystemGestureEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnStylusSystemGesture (e As StylusSystemGestureEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnStylusSystemGesture(System::Windows::Input::StylusSystemGestureEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnStylusSystemGesture : System.Windows.Input.StylusSystemGestureEventArgs -&gt; unit&#xA;override this.OnStylusSystemGesture : System.Windows.Input.StylusSystemGestureEventArgs -&gt; unit" Usage="contentElement.OnStylusSystemGesture e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusSystemGestureEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="f4180-1945">包含事件数据的 <see cref="T:System.Windows.Input.StylusSystemGestureEventArgs" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-1945">The <see cref="T:System.Windows.Input.StylusSystemGestureEventArgs" /> that contains the event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f4180-1946">当某个未处理的 <see cref="E:System.Windows.Input.Stylus.StylusSystemGesture" /> 附加事件在其路由中到达派生自此类的某个元素时调用。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-1946">Invoked when an unhandled <see cref="E:System.Windows.Input.Stylus.StylusSystemGesture" /> attached event reaches an element in its route that is derived from this class.</span>
          </span>
          <span data-ttu-id="f4180-1947">实现此方法可为此事件添加类处理。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-1947">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4180-1948">此方法具有默认实现。</span><span class="sxs-lookup"><span data-stu-id="f4180-1948">This method has no default implementation.</span></span> <span data-ttu-id="f4180-1949">因为中间类继承中的可能会实现此方法，我们建议在实现中调用基实现。</span><span class="sxs-lookup"><span data-stu-id="f4180-1949">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="f4180-1950">此方法的用途是类似于[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]事件模式 On \* 方法： 此方法提供了通过建立类处理程序而不是实例处理程序来处理从派生类的匹配事件的方法。</span><span class="sxs-lookup"><span data-stu-id="f4180-1950">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="f4180-1951">在这种情况下匹配事件是路由的事件。</span><span class="sxs-lookup"><span data-stu-id="f4180-1951">In this case the matching event is a routed event.</span></span> <span data-ttu-id="f4180-1952">On \* 方法的实现模式是不同的路由事件，因为可以由子元素，它不一定是将调用处理程序的元素引发路由的事件。</span><span class="sxs-lookup"><span data-stu-id="f4180-1952">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="f4180-1953">因此，您的实现需要检查的事件数据源属性。</span><span class="sxs-lookup"><span data-stu-id="f4180-1953">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="f4180-1954">它不应尝试再次引发该事件在大多数情况下。</span><span class="sxs-lookup"><span data-stu-id="f4180-1954">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="f4180-1955">通过重写此方法或通过注册类处理程序替换<xref:System.Windows.EventManager.RegisterClassHandler%2A>，派生类的<xref:System.Windows.ContentElement>为由事件路由收到事件时，可以调用私有类处理程序方法。</span><span class="sxs-lookup"><span data-stu-id="f4180-1955">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="f4180-1956">类处理是相应的一种方案是操作事件数据并将路由的事件标记为已处理。</span><span class="sxs-lookup"><span data-stu-id="f4180-1956">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.StylusSystemGesture" />
      </Docs>
    </Member>
    <Member MemberName="OnStylusUp">
      <MemberSignature Language="C#" Value="protected internal virtual void OnStylusUp (System.Windows.Input.StylusEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnStylusUp(class System.Windows.Input.StylusEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnStylusUp(System.Windows.Input.StylusEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnStylusUp (e As StylusEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnStylusUp(System::Windows::Input::StylusEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnStylusUp : System.Windows.Input.StylusEventArgs -&gt; unit&#xA;override this.OnStylusUp : System.Windows.Input.StylusEventArgs -&gt; unit" Usage="contentElement.OnStylusUp e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="f4180-1957">包含事件数据的 <see cref="T:System.Windows.Input.StylusEventArgs" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-1957">The <see cref="T:System.Windows.Input.StylusEventArgs" /> that contains the event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f4180-1958">当某个未处理的 <see cref="E:System.Windows.Input.Stylus.StylusUp" /> 附加事件在其路由中到达派生自此类的某个元素时调用。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-1958">Invoked when an unhandled <see cref="E:System.Windows.Input.Stylus.StylusUp" /> attached event reaches an element in its route that is derived from this class.</span>
          </span>
          <span data-ttu-id="f4180-1959">实现此方法可为此事件添加类处理。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-1959">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4180-1960">此方法具有默认实现。</span><span class="sxs-lookup"><span data-stu-id="f4180-1960">This method has no default implementation.</span></span> <span data-ttu-id="f4180-1961">因为中间类继承中的可能会实现此方法，我们建议在实现中调用基实现。</span><span class="sxs-lookup"><span data-stu-id="f4180-1961">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="f4180-1962">此方法的用途是类似于[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]事件模式 On \* 方法： 此方法提供了通过建立类处理程序而不是实例处理程序来处理从派生类的匹配事件的方法。</span><span class="sxs-lookup"><span data-stu-id="f4180-1962">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="f4180-1963">在这种情况下匹配事件是路由的事件。</span><span class="sxs-lookup"><span data-stu-id="f4180-1963">In this case the matching event is a routed event.</span></span> <span data-ttu-id="f4180-1964">On \* 方法的实现模式是不同的路由事件，因为可以由子元素，它不一定是将调用处理程序的元素引发路由的事件。</span><span class="sxs-lookup"><span data-stu-id="f4180-1964">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="f4180-1965">因此，您的实现需要检查的事件数据源属性。</span><span class="sxs-lookup"><span data-stu-id="f4180-1965">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="f4180-1966">它不应尝试再次引发该事件在大多数情况下。</span><span class="sxs-lookup"><span data-stu-id="f4180-1966">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="f4180-1967">通过重写此方法或通过注册类处理程序替换<xref:System.Windows.EventManager.RegisterClassHandler%2A>，派生类的<xref:System.Windows.ContentElement>为由事件路由收到事件时，可以调用私有类处理程序方法。</span><span class="sxs-lookup"><span data-stu-id="f4180-1967">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="f4180-1968">类处理是相应的一种方案是操作事件数据并将路由的事件标记为已处理。</span><span class="sxs-lookup"><span data-stu-id="f4180-1968">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.StylusUp" />
      </Docs>
    </Member>
    <Member MemberName="OnTextInput">
      <MemberSignature Language="C#" Value="protected internal virtual void OnTextInput (System.Windows.Input.TextCompositionEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnTextInput(class System.Windows.Input.TextCompositionEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnTextInput(System.Windows.Input.TextCompositionEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnTextInput (e As TextCompositionEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnTextInput(System::Windows::Input::TextCompositionEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnTextInput : System.Windows.Input.TextCompositionEventArgs -&gt; unit&#xA;override this.OnTextInput : System.Windows.Input.TextCompositionEventArgs -&gt; unit" Usage="contentElement.OnTextInput e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.TextCompositionEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="f4180-1969">包含事件数据的 <see cref="T:System.Windows.Input.TextCompositionEventArgs" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-1969">The <see cref="T:System.Windows.Input.TextCompositionEventArgs" /> that contains the event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f4180-1970">当某个未处理的 <see cref="E:System.Windows.Input.TextCompositionManager.TextInput" /> 附加事件在其路由中到达派生自此类的某个元素时调用。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-1970">Invoked when an unhandled <see cref="E:System.Windows.Input.TextCompositionManager.TextInput" /> attached event reaches an element in its route that is derived from this class.</span>
          </span>
          <span data-ttu-id="f4180-1971">实现此方法可为此事件添加类处理。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-1971">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4180-1972">此方法具有默认实现。</span><span class="sxs-lookup"><span data-stu-id="f4180-1972">This method has no default implementation.</span></span> <span data-ttu-id="f4180-1973">因为中间类继承中的可能会实现此方法，我们建议在实现中调用基实现。</span><span class="sxs-lookup"><span data-stu-id="f4180-1973">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="f4180-1974">此方法的用途是类似于[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]事件模式 On \* 方法： 此方法提供了通过建立类处理程序而不是实例处理程序来处理从派生类的匹配事件的方法。</span><span class="sxs-lookup"><span data-stu-id="f4180-1974">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="f4180-1975">在这种情况下匹配事件是路由的事件。</span><span class="sxs-lookup"><span data-stu-id="f4180-1975">In this case the matching event is a routed event.</span></span> <span data-ttu-id="f4180-1976">On \* 方法的实现模式是不同的路由事件，因为可以由子元素，它不一定是将调用处理程序的元素引发路由的事件。</span><span class="sxs-lookup"><span data-stu-id="f4180-1976">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="f4180-1977">因此，您的实现需要检查的事件数据源属性。</span><span class="sxs-lookup"><span data-stu-id="f4180-1977">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="f4180-1978">它不应尝试再次引发该事件在大多数情况下。</span><span class="sxs-lookup"><span data-stu-id="f4180-1978">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="f4180-1979">通过重写此方法或通过注册类处理程序替换<xref:System.Windows.EventManager.RegisterClassHandler%2A>，派生类的<xref:System.Windows.ContentElement>为由事件路由收到事件时，可以调用私有类处理程序方法。</span><span class="sxs-lookup"><span data-stu-id="f4180-1979">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="f4180-1980">类处理是相应的一种方案是操作事件数据并将路由的事件标记为已处理。</span><span class="sxs-lookup"><span data-stu-id="f4180-1980">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.TextInput" />
      </Docs>
    </Member>
    <Member MemberName="OnTouchDown">
      <MemberSignature Language="C#" Value="protected internal virtual void OnTouchDown (System.Windows.Input.TouchEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnTouchDown(class System.Windows.Input.TouchEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnTouchDown(System.Windows.Input.TouchEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnTouchDown (e As TouchEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnTouchDown(System::Windows::Input::TouchEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnTouchDown : System.Windows.Input.TouchEventArgs -&gt; unit&#xA;override this.OnTouchDown : System.Windows.Input.TouchEventArgs -&gt; unit" Usage="contentElement.OnTouchDown e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.TouchEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="f4180-1981">包含事件数据的 <see cref="T:System.Windows.Input.TouchEventArgs" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-1981">A <see cref="T:System.Windows.Input.TouchEventArgs" /> that contains the event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f4180-1982">为在此元素内按下触摸屏输入时发生的 <see cref="E:System.Windows.ContentElement.TouchDown" /> 路由事件提供类处理。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-1982">Provides class handling for the <see cref="E:System.Windows.ContentElement.TouchDown" /> routed event that occurs when a touch presses inside this element.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4180-1983"><xref:System.Windows.ContentElement.OnTouchDown%2A>方法具有默认实现。</span><span class="sxs-lookup"><span data-stu-id="f4180-1983">The <xref:System.Windows.ContentElement.OnTouchDown%2A> method has no default implementation.</span></span> <span data-ttu-id="f4180-1984">重写<xref:System.Windows.ContentElement.OnTouchDown%2A>中派生的类来处理<xref:System.Windows.ContentElement.TouchDown>事件。</span><span class="sxs-lookup"><span data-stu-id="f4180-1984">Override <xref:System.Windows.ContentElement.OnTouchDown%2A> in a derived class to handle the <xref:System.Windows.ContentElement.TouchDown> event.</span></span> <span data-ttu-id="f4180-1985">请务必调用基类的<xref:System.Windows.ContentElement.OnTouchDown%2A>方法，从而基本类接收事件。</span><span class="sxs-lookup"><span data-stu-id="f4180-1985">Be sure to call the base class’s <xref:System.Windows.ContentElement.OnTouchDown%2A> method so that base classes receive the event.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnTouchEnter">
      <MemberSignature Language="C#" Value="protected internal virtual void OnTouchEnter (System.Windows.Input.TouchEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnTouchEnter(class System.Windows.Input.TouchEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnTouchEnter(System.Windows.Input.TouchEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnTouchEnter (e As TouchEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnTouchEnter(System::Windows::Input::TouchEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnTouchEnter : System.Windows.Input.TouchEventArgs -&gt; unit&#xA;override this.OnTouchEnter : System.Windows.Input.TouchEventArgs -&gt; unit" Usage="contentElement.OnTouchEnter e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.TouchEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="f4180-1986">包含事件数据的 <see cref="T:System.Windows.Input.TouchEventArgs" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-1986">A <see cref="T:System.Windows.Input.TouchEventArgs" /> that contains the event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f4180-1987">为在触摸屏输入从此元素边界外部移动到其内部时发生的 <see cref="E:System.Windows.ContentElement.TouchEnter" /> 路由事件提供类处理。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-1987">Provides class handling for the <see cref="E:System.Windows.ContentElement.TouchEnter" /> routed event that occurs when a touch moves from outside to inside the bounds of this element.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4180-1988"><xref:System.Windows.ContentElement.OnTouchEnter%2A>方法具有默认实现。</span><span class="sxs-lookup"><span data-stu-id="f4180-1988">The <xref:System.Windows.ContentElement.OnTouchEnter%2A> method has no default implementation.</span></span> <span data-ttu-id="f4180-1989">重写<xref:System.Windows.ContentElement.OnTouchEnter%2A>中派生的类来处理<xref:System.Windows.ContentElement.TouchEnter>事件。</span><span class="sxs-lookup"><span data-stu-id="f4180-1989">Override <xref:System.Windows.ContentElement.OnTouchEnter%2A> in a derived class to handle the <xref:System.Windows.ContentElement.TouchEnter> event.</span></span> <span data-ttu-id="f4180-1990">请务必调用基类的<xref:System.Windows.ContentElement.OnTouchEnter%2A>方法，从而基本类接收事件。</span><span class="sxs-lookup"><span data-stu-id="f4180-1990">Be sure to call the base class’s <xref:System.Windows.ContentElement.OnTouchEnter%2A> method so that base classes receive the event.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnTouchLeave">
      <MemberSignature Language="C#" Value="protected internal virtual void OnTouchLeave (System.Windows.Input.TouchEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnTouchLeave(class System.Windows.Input.TouchEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnTouchLeave(System.Windows.Input.TouchEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnTouchLeave (e As TouchEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnTouchLeave(System::Windows::Input::TouchEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnTouchLeave : System.Windows.Input.TouchEventArgs -&gt; unit&#xA;override this.OnTouchLeave : System.Windows.Input.TouchEventArgs -&gt; unit" Usage="contentElement.OnTouchLeave e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.TouchEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="f4180-1991">包含事件数据的 <see cref="T:System.Windows.Input.TouchEventArgs" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-1991">A <see cref="T:System.Windows.Input.TouchEventArgs" /> that contains the event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f4180-1992">为在触摸屏输入从此元素边界内部移动到其外部时发生的 <see cref="E:System.Windows.ContentElement.TouchLeave" /> 路由事件提供类处理。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-1992">Provides class handling for the <see cref="E:System.Windows.ContentElement.TouchLeave" /> routed event that occurs when a touch moves from inside to outside the bounds of this element.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4180-1993"><xref:System.Windows.ContentElement.OnTouchLeave%2A>方法具有默认实现。</span><span class="sxs-lookup"><span data-stu-id="f4180-1993">The <xref:System.Windows.ContentElement.OnTouchLeave%2A> method has no default implementation.</span></span> <span data-ttu-id="f4180-1994">重写<xref:System.Windows.ContentElement.OnTouchLeave%2A>中派生的类来处理<xref:System.Windows.ContentElement.TouchLeave>事件。</span><span class="sxs-lookup"><span data-stu-id="f4180-1994">Override <xref:System.Windows.ContentElement.OnTouchLeave%2A> in a derived class to handle the <xref:System.Windows.ContentElement.TouchLeave> event.</span></span> <span data-ttu-id="f4180-1995">请务必调用基类的<xref:System.Windows.ContentElement.OnTouchLeave%2A>方法，从而基本类接收事件。</span><span class="sxs-lookup"><span data-stu-id="f4180-1995">Be sure to call the base class’s <xref:System.Windows.ContentElement.OnTouchLeave%2A> method so that base classes receive the event.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnTouchMove">
      <MemberSignature Language="C#" Value="protected internal virtual void OnTouchMove (System.Windows.Input.TouchEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnTouchMove(class System.Windows.Input.TouchEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnTouchMove(System.Windows.Input.TouchEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnTouchMove (e As TouchEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnTouchMove(System::Windows::Input::TouchEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnTouchMove : System.Windows.Input.TouchEventArgs -&gt; unit&#xA;override this.OnTouchMove : System.Windows.Input.TouchEventArgs -&gt; unit" Usage="contentElement.OnTouchMove e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.TouchEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="f4180-1996">包含事件数据的 <see cref="T:System.Windows.Input.TouchEventArgs" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-1996">A <see cref="T:System.Windows.Input.TouchEventArgs" /> that contains the event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f4180-1997">为在此元素内部移动触摸屏输入时发生的 <see cref="E:System.Windows.ContentElement.TouchMove" /> 路由事件提供类处理。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-1997">Provides class handling for the <see cref="E:System.Windows.ContentElement.TouchMove" /> routed event that occurs when a touch moves while inside this element.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4180-1998"><xref:System.Windows.ContentElement.OnTouchMove%2A>方法具有默认实现。</span><span class="sxs-lookup"><span data-stu-id="f4180-1998">The <xref:System.Windows.ContentElement.OnTouchMove%2A> method has no default implementation.</span></span> <span data-ttu-id="f4180-1999">重写<xref:System.Windows.ContentElement.OnTouchMove%2A>中派生的类来处理<xref:System.Windows.ContentElement.TouchMove>事件。</span><span class="sxs-lookup"><span data-stu-id="f4180-1999">Override <xref:System.Windows.ContentElement.OnTouchMove%2A> in a derived class to handle the <xref:System.Windows.ContentElement.TouchMove> event.</span></span> <span data-ttu-id="f4180-2000">请务必调用基类的<xref:System.Windows.ContentElement.OnTouchMove%2A>方法，从而基本类接收事件。</span><span class="sxs-lookup"><span data-stu-id="f4180-2000">Be sure to call the base class’s <xref:System.Windows.ContentElement.OnTouchMove%2A> method so that base classes receive the event.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnTouchUp">
      <MemberSignature Language="C#" Value="protected internal virtual void OnTouchUp (System.Windows.Input.TouchEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnTouchUp(class System.Windows.Input.TouchEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnTouchUp(System.Windows.Input.TouchEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnTouchUp (e As TouchEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnTouchUp(System::Windows::Input::TouchEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnTouchUp : System.Windows.Input.TouchEventArgs -&gt; unit&#xA;override this.OnTouchUp : System.Windows.Input.TouchEventArgs -&gt; unit" Usage="contentElement.OnTouchUp e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.TouchEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="f4180-2001">包含事件数据的 <see cref="T:System.Windows.Input.TouchEventArgs" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-2001">A <see cref="T:System.Windows.Input.TouchEventArgs" /> that contains the event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f4180-2002">为在此元素内部释放触摸屏输入时发生的 <see cref="E:System.Windows.ContentElement.TouchUp" /> 路由事件提供类处理。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-2002">Provides class handling for the <see cref="E:System.Windows.ContentElement.TouchUp" /> routed event that occurs when a touch is released inside this element.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4180-2003"><xref:System.Windows.ContentElement.OnTouchUp%2A>方法具有默认实现。</span><span class="sxs-lookup"><span data-stu-id="f4180-2003">The <xref:System.Windows.ContentElement.OnTouchUp%2A> method has no default implementation.</span></span> <span data-ttu-id="f4180-2004">重写<xref:System.Windows.ContentElement.OnTouchUp%2A>中派生的类来处理<xref:System.Windows.ContentElement.TouchUp>事件。</span><span class="sxs-lookup"><span data-stu-id="f4180-2004">Override <xref:System.Windows.ContentElement.OnTouchUp%2A> in a derived class to handle the <xref:System.Windows.ContentElement.TouchUp> event.</span></span> <span data-ttu-id="f4180-2005">请务必调用基类的<xref:System.Windows.ContentElement.OnTouchUp%2A>方法，从而基本类接收事件。</span><span class="sxs-lookup"><span data-stu-id="f4180-2005">Be sure to call the base class’s <xref:System.Windows.ContentElement.OnTouchUp%2A> method so that base classes receive the event.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PredictFocus">
      <MemberSignature Language="C#" Value="public virtual System.Windows.DependencyObject PredictFocus (System.Windows.Input.FocusNavigationDirection direction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Windows.DependencyObject PredictFocus(valuetype System.Windows.Input.FocusNavigationDirection direction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.PredictFocus(System.Windows.Input.FocusNavigationDirection)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function PredictFocus (direction As FocusNavigationDirection) As DependencyObject" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Windows::DependencyObject ^ PredictFocus(System::Windows::Input::FocusNavigationDirection direction);" />
      <MemberSignature Language="F#" Value="abstract member PredictFocus : System.Windows.Input.FocusNavigationDirection -&gt; System.Windows.DependencyObject&#xA;override this.PredictFocus : System.Windows.Input.FocusNavigationDirection -&gt; System.Windows.DependencyObject" Usage="contentElement.PredictFocus direction" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="direction" Type="System.Windows.Input.FocusNavigationDirection" />
      </Parameters>
      <Docs>
        <param name="direction">
          <span data-ttu-id="f4180-2006">请求的焦点遍历的方向。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-2006">The direction of the requested focus traversal.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f4180-2007">当在派生类中重写时，返回将按指定焦点遍历方向接收焦点的元素，而不用实际将焦点移至该元素。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-2007">When overridden in a derived class, returns the element that would receive focus for a specified focus traversal direction, without actually moving focus to that element.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f4180-2008">如果实际调用了 <see cref="M:System.Windows.ContentElement.MoveFocus(System.Windows.Input.TraversalRequest)" />，则为接收焦点的元素。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-2008">The element that would have received focus if <see cref="M:System.Windows.ContentElement.MoveFocus(System.Windows.Input.TraversalRequest)" /> were actually invoked.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4180-2009">此方法在此类中的默认实现是不完整且始终返回`null`。</span><span class="sxs-lookup"><span data-stu-id="f4180-2009">The default implementation of this method in this class is incomplete and always returns `null`.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.ContentElement.MoveFocus(System.Windows.Input.TraversalRequest)" />
      </Docs>
    </Member>
    <Member MemberName="PreviewDragEnter">
      <MemberSignature Language="C#" Value="public event System.Windows.DragEventHandler PreviewDragEnter;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DragEventHandler PreviewDragEnter" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewDragEnter" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewDragEnter As DragEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DragEventHandler ^ PreviewDragEnter;" />
      <MemberSignature Language="F#" Value="member this.PreviewDragEnter : System.Windows.DragEventHandler " Usage="member this.PreviewDragEnter : System.Windows.DragEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DragEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f4180-2010">在输入系统报告出现以此元素为拖动目标的基础拖动事件时发生。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-2010">Occurs when the input system reports an underlying drag event with this element as the drag target.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4180-2011">此事件创建一个别名<xref:System.Windows.DragDrop.PreviewDragEnter?displayProperty=nameWithType>附加事件对于此类，以便<xref:System.Windows.ContentElement.PreviewDragEnter>属于类的成员列出时<xref:System.Windows.ContentElement>作为基元素继承。</span><span class="sxs-lookup"><span data-stu-id="f4180-2011">This event creates an alias for the <xref:System.Windows.DragDrop.PreviewDragEnter?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.PreviewDragEnter> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="f4180-2012">事件处理程序附加到<xref:System.Windows.ContentElement.PreviewDragEnter>事件附加到基础<xref:System.Windows.DragDrop.PreviewDragEnter?displayProperty=nameWithType>附加事件，并接收相同的事件数据实例。</span><span class="sxs-lookup"><span data-stu-id="f4180-2012">Event handlers that are attached to the <xref:System.Windows.ContentElement.PreviewDragEnter> event are attached to the underlying <xref:System.Windows.DragDrop.PreviewDragEnter?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
<a name="routedEventInfo_PreviewDragEnter"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="f4180-2013">路由事件信息</span><span class="sxs-lookup"><span data-stu-id="f4180-2013">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="f4180-2014">标识符字段</span><span class="sxs-lookup"><span data-stu-id="f4180-2014">Identifier field</span></span>|<xref:System.Windows.ContentElement.PreviewDragEnterEvent>|  
|<span data-ttu-id="f4180-2015">路由策略</span><span class="sxs-lookup"><span data-stu-id="f4180-2015">Routing strategy</span></span>|<span data-ttu-id="f4180-2016">隧道</span><span class="sxs-lookup"><span data-stu-id="f4180-2016">Tunneling</span></span>|  
|<span data-ttu-id="f4180-2017">委托</span><span class="sxs-lookup"><span data-stu-id="f4180-2017">Delegate</span></span>|<xref:System.Windows.DragEventHandler>|  
  
-   <span data-ttu-id="f4180-2018">相应的浮升事件是<xref:System.Windows.ContentElement.DragEnter>。</span><span class="sxs-lookup"><span data-stu-id="f4180-2018">The corresponding bubbling event is <xref:System.Windows.ContentElement.DragEnter>.</span></span>  
  
-   <span data-ttu-id="f4180-2019">重写<xref:System.Windows.ContentElement.OnPreviewDragEnter%2A>实现类处理此事件在派生类中。</span><span class="sxs-lookup"><span data-stu-id="f4180-2019">Override <xref:System.Windows.ContentElement.OnPreviewDragEnter%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewDragEnterEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewDragEnterEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewDragEnterEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewDragEnterEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewDragEnterEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewDragEnterEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewDragEnterEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.PreviewDragEnterEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f4180-2020">标识 <see cref="E:System.Windows.ContentElement.PreviewDragEnter" /> 路由事件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-2020">Identifies the <see cref="E:System.Windows.ContentElement.PreviewDragEnter" /> routed event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4180-2021">在注册路由事件时创建路由事件标识符。</span><span class="sxs-lookup"><span data-stu-id="f4180-2021">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="f4180-2022">这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。</span><span class="sxs-lookup"><span data-stu-id="f4180-2022">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="f4180-2023">可以使用这些标识符添加类处理程序。</span><span class="sxs-lookup"><span data-stu-id="f4180-2023">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="f4180-2024">有关注册路由事件的更多信息，请参见 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="f4180-2024">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="f4180-2025">有关使用路由事件标识符添加类处理程序的更多信息，请参见 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="f4180-2025">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewDragLeave">
      <MemberSignature Language="C#" Value="public event System.Windows.DragEventHandler PreviewDragLeave;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DragEventHandler PreviewDragLeave" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewDragLeave" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewDragLeave As DragEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DragEventHandler ^ PreviewDragLeave;" />
      <MemberSignature Language="F#" Value="member this.PreviewDragLeave : System.Windows.DragEventHandler " Usage="member this.PreviewDragLeave : System.Windows.DragEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DragEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f4180-2026">在输入系统报告出现以此元素为拖动起点的基础拖动事件时发生。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-2026">Occurs when the input system reports an underlying drag event with this element as the drag origin.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4180-2027">此事件创建一个别名<xref:System.Windows.DragDrop.PreviewDragLeave?displayProperty=nameWithType>附加事件对于此类，以便<xref:System.Windows.ContentElement.PreviewDragLeave>属于类的成员列出时<xref:System.Windows.ContentElement>作为基元素继承。</span><span class="sxs-lookup"><span data-stu-id="f4180-2027">This event creates an alias for the <xref:System.Windows.DragDrop.PreviewDragLeave?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.PreviewDragLeave> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="f4180-2028">事件处理程序附加到<xref:System.Windows.ContentElement.PreviewDragLeave>事件附加到基础<xref:System.Windows.DragDrop.PreviewDragLeave?displayProperty=nameWithType>附加事件，并接收相同的事件数据实例。</span><span class="sxs-lookup"><span data-stu-id="f4180-2028">Event handlers that are attached to the <xref:System.Windows.ContentElement.PreviewDragLeave> event are attached to the underlying <xref:System.Windows.DragDrop.PreviewDragLeave?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
<a name="routedEventInfo_PreviewDragLeave"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="f4180-2029">路由事件信息</span><span class="sxs-lookup"><span data-stu-id="f4180-2029">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="f4180-2030">标识符字段</span><span class="sxs-lookup"><span data-stu-id="f4180-2030">Identifier field</span></span>|<xref:System.Windows.ContentElement.PreviewDragLeaveEvent>|  
|<span data-ttu-id="f4180-2031">路由策略</span><span class="sxs-lookup"><span data-stu-id="f4180-2031">Routing strategy</span></span>|<span data-ttu-id="f4180-2032">隧道</span><span class="sxs-lookup"><span data-stu-id="f4180-2032">Tunneling</span></span>|  
|<span data-ttu-id="f4180-2033">委托</span><span class="sxs-lookup"><span data-stu-id="f4180-2033">Delegate</span></span>|<xref:System.Windows.DragEventHandler>|  
  
-   <span data-ttu-id="f4180-2034">相应的浮升事件是<xref:System.Windows.ContentElement.DragLeave>。</span><span class="sxs-lookup"><span data-stu-id="f4180-2034">The corresponding bubbling event is <xref:System.Windows.ContentElement.DragLeave>.</span></span>  
  
-   <span data-ttu-id="f4180-2035">重写<xref:System.Windows.ContentElement.OnPreviewDragLeave%2A>实现类处理此事件在派生类中。</span><span class="sxs-lookup"><span data-stu-id="f4180-2035">Override <xref:System.Windows.ContentElement.OnPreviewDragLeave%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewDragLeaveEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewDragLeaveEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewDragLeaveEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewDragLeaveEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewDragLeaveEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewDragLeaveEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewDragLeaveEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.PreviewDragLeaveEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f4180-2036">标识 <see cref="E:System.Windows.ContentElement.PreviewDragLeave" /> 路由事件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-2036">Identifies the <see cref="E:System.Windows.ContentElement.PreviewDragLeave" /> routed event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4180-2037">在注册路由事件时创建路由事件标识符。</span><span class="sxs-lookup"><span data-stu-id="f4180-2037">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="f4180-2038">这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。</span><span class="sxs-lookup"><span data-stu-id="f4180-2038">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="f4180-2039">可以使用这些标识符添加类处理程序。</span><span class="sxs-lookup"><span data-stu-id="f4180-2039">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="f4180-2040">有关注册路由事件的更多信息，请参见 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="f4180-2040">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="f4180-2041">有关使用路由事件标识符添加类处理程序的更多信息，请参见 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="f4180-2041">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewDragOver">
      <MemberSignature Language="C#" Value="public event System.Windows.DragEventHandler PreviewDragOver;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DragEventHandler PreviewDragOver" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewDragOver" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewDragOver As DragEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DragEventHandler ^ PreviewDragOver;" />
      <MemberSignature Language="F#" Value="member this.PreviewDragOver : System.Windows.DragEventHandler " Usage="member this.PreviewDragOver : System.Windows.DragEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DragEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f4180-2042">在输入系统报告出现以此元素为可能放置目标的基础拖动事件时发生。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-2042">Occurs when the input system reports an underlying drag event with this element as the potential drop target.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4180-2043">此事件创建一个别名<xref:System.Windows.DragDrop.PreviewDragOver?displayProperty=nameWithType>附加事件对于此类，以便<xref:System.Windows.ContentElement.PreviewDragOver>属于类的成员列出时<xref:System.Windows.ContentElement>作为基元素继承。</span><span class="sxs-lookup"><span data-stu-id="f4180-2043">This event creates an alias for the <xref:System.Windows.DragDrop.PreviewDragOver?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.PreviewDragOver> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="f4180-2044">事件处理程序附加到<xref:System.Windows.ContentElement.PreviewDragOver>事件附加到基础<xref:System.Windows.DragDrop.PreviewDragOver?displayProperty=nameWithType>附加事件，并接收相同的事件数据实例。</span><span class="sxs-lookup"><span data-stu-id="f4180-2044">Event handlers that are attached to the <xref:System.Windows.ContentElement.PreviewDragOver> event are attached to the underlying <xref:System.Windows.DragDrop.PreviewDragOver?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
<a name="routedEventInfo_PreviewDragOver"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="f4180-2045">路由事件信息</span><span class="sxs-lookup"><span data-stu-id="f4180-2045">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="f4180-2046">标识符字段</span><span class="sxs-lookup"><span data-stu-id="f4180-2046">Identifier field</span></span>|<xref:System.Windows.ContentElement.PreviewDragOverEvent>|  
|<span data-ttu-id="f4180-2047">路由策略</span><span class="sxs-lookup"><span data-stu-id="f4180-2047">Routing strategy</span></span>|<span data-ttu-id="f4180-2048">隧道</span><span class="sxs-lookup"><span data-stu-id="f4180-2048">Tunneling</span></span>|  
|<span data-ttu-id="f4180-2049">委托</span><span class="sxs-lookup"><span data-stu-id="f4180-2049">Delegate</span></span>|<xref:System.Windows.DragEventHandler>|  
  
-   <span data-ttu-id="f4180-2050">相应的浮升事件是<xref:System.Windows.ContentElement.DragOver>。</span><span class="sxs-lookup"><span data-stu-id="f4180-2050">The corresponding bubbling event is <xref:System.Windows.ContentElement.DragOver>.</span></span>  
  
-   <span data-ttu-id="f4180-2051">重写<xref:System.Windows.ContentElement.OnPreviewDragOver%2A>实现类处理此事件在派生类中。</span><span class="sxs-lookup"><span data-stu-id="f4180-2051">Override <xref:System.Windows.ContentElement.OnPreviewDragOver%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewDragOverEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewDragOverEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewDragOverEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewDragOverEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewDragOverEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewDragOverEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewDragOverEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.PreviewDragOverEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f4180-2052">标识 <see cref="E:System.Windows.ContentElement.PreviewDragOver" /> 路由事件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-2052">Identifies the <see cref="E:System.Windows.ContentElement.PreviewDragOver" /> routed event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4180-2053">在注册路由事件时创建路由事件标识符。</span><span class="sxs-lookup"><span data-stu-id="f4180-2053">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="f4180-2054">这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。</span><span class="sxs-lookup"><span data-stu-id="f4180-2054">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="f4180-2055">可以使用这些标识符添加类处理程序。</span><span class="sxs-lookup"><span data-stu-id="f4180-2055">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="f4180-2056">有关注册路由事件的更多信息，请参见 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="f4180-2056">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="f4180-2057">有关使用路由事件标识符添加类处理程序的更多信息，请参见 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="f4180-2057">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewDrop">
      <MemberSignature Language="C#" Value="public event System.Windows.DragEventHandler PreviewDrop;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DragEventHandler PreviewDrop" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewDrop" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewDrop As DragEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DragEventHandler ^ PreviewDrop;" />
      <MemberSignature Language="F#" Value="member this.PreviewDrop : System.Windows.DragEventHandler " Usage="member this.PreviewDrop : System.Windows.DragEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DragEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f4180-2058">在输入系统报告出现将此元素作为放置目标的基础放置事件时发生。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-2058">Occurs when the input system reports an underlying drop event with this element as the drop target.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4180-2059">此事件创建一个别名<xref:System.Windows.DragDrop.PreviewDrop?displayProperty=nameWithType>附加事件对于此类，以便<xref:System.Windows.ContentElement.PreviewDrop>属于类的成员列出时<xref:System.Windows.ContentElement>作为基元素继承。</span><span class="sxs-lookup"><span data-stu-id="f4180-2059">This event creates an alias for the <xref:System.Windows.DragDrop.PreviewDrop?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.PreviewDrop> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="f4180-2060">事件处理程序附加到<xref:System.Windows.ContentElement.PreviewDrop>事件附加到基础<xref:System.Windows.DragDrop.PreviewDrop?displayProperty=nameWithType>附加事件，并接收相同的事件数据实例。</span><span class="sxs-lookup"><span data-stu-id="f4180-2060">Event handlers that are attached to the <xref:System.Windows.ContentElement.PreviewDrop> event are attached to the underlying <xref:System.Windows.DragDrop.PreviewDrop?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
<a name="routedEventInfo_PreviewDrop"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="f4180-2061">路由事件信息</span><span class="sxs-lookup"><span data-stu-id="f4180-2061">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="f4180-2062">标识符字段</span><span class="sxs-lookup"><span data-stu-id="f4180-2062">Identifier field</span></span>|<xref:System.Windows.ContentElement.PreviewDropEvent>|  
|<span data-ttu-id="f4180-2063">路由策略</span><span class="sxs-lookup"><span data-stu-id="f4180-2063">Routing strategy</span></span>|<span data-ttu-id="f4180-2064">隧道</span><span class="sxs-lookup"><span data-stu-id="f4180-2064">Tunneling</span></span>|  
|<span data-ttu-id="f4180-2065">委托</span><span class="sxs-lookup"><span data-stu-id="f4180-2065">Delegate</span></span>|<xref:System.Windows.DragEventHandler>|  
  
-   <span data-ttu-id="f4180-2066">相应的浮升事件是<xref:System.Windows.ContentElement.Drop>。</span><span class="sxs-lookup"><span data-stu-id="f4180-2066">The corresponding bubbling event is <xref:System.Windows.ContentElement.Drop>.</span></span>  
  
-   <span data-ttu-id="f4180-2067">重写<xref:System.Windows.ContentElement.OnPreviewDrop%2A>实现类处理此事件在派生类中。</span><span class="sxs-lookup"><span data-stu-id="f4180-2067">Override <xref:System.Windows.ContentElement.OnPreviewDrop%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewDropEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewDropEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewDropEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewDropEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewDropEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewDropEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewDropEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.PreviewDropEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f4180-2068">标识 <see cref="E:System.Windows.ContentElement.PreviewDrop" /> 路由事件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-2068">Identifies the <see cref="E:System.Windows.ContentElement.PreviewDrop" /> routed event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4180-2069">在注册路由事件时创建路由事件标识符。</span><span class="sxs-lookup"><span data-stu-id="f4180-2069">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="f4180-2070">这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。</span><span class="sxs-lookup"><span data-stu-id="f4180-2070">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="f4180-2071">可以使用这些标识符添加类处理程序。</span><span class="sxs-lookup"><span data-stu-id="f4180-2071">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="f4180-2072">有关注册路由事件的更多信息，请参见 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="f4180-2072">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="f4180-2073">有关使用路由事件标识符添加类处理程序的更多信息，请参见 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="f4180-2073">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewGiveFeedback">
      <MemberSignature Language="C#" Value="public event System.Windows.GiveFeedbackEventHandler PreviewGiveFeedback;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.GiveFeedbackEventHandler PreviewGiveFeedback" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewGiveFeedback" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewGiveFeedback As GiveFeedbackEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::GiveFeedbackEventHandler ^ PreviewGiveFeedback;" />
      <MemberSignature Language="F#" Value="member this.PreviewGiveFeedback : System.Windows.GiveFeedbackEventHandler " Usage="member this.PreviewGiveFeedback : System.Windows.GiveFeedbackEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.GiveFeedbackEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f4180-2074">在开始拖放操作时发生。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-2074">Occurs when a drag-and-drop operation is started.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4180-2075"><xref:System.Windows.ContentElement.PreviewGiveFeedback>事件允许拖动事件，可以修改鼠标指针的外观，以便为用户可视反馈提供拖放操作期间的源。</span><span class="sxs-lookup"><span data-stu-id="f4180-2075">The <xref:System.Windows.ContentElement.PreviewGiveFeedback> event enables the source of a drag event to modify the appearance of the mouse pointer, in order to give the user visual feedback during a drag-and-drop operation.</span></span>  
  
 <span data-ttu-id="f4180-2076">此事件创建一个别名<xref:System.Windows.DragDrop.PreviewGiveFeedback?displayProperty=nameWithType>附加事件对于此类，以便<xref:System.Windows.ContentElement.PreviewGiveFeedback>属于类的成员列出时<xref:System.Windows.ContentElement>作为基元素继承。</span><span class="sxs-lookup"><span data-stu-id="f4180-2076">This event creates an alias for the <xref:System.Windows.DragDrop.PreviewGiveFeedback?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.PreviewGiveFeedback> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="f4180-2077">事件处理程序附加到<xref:System.Windows.ContentElement.PreviewGiveFeedback>事件附加到基础<xref:System.Windows.DragDrop.PreviewGiveFeedback?displayProperty=nameWithType>附加事件，并接收相同的事件数据实例。</span><span class="sxs-lookup"><span data-stu-id="f4180-2077">Event handlers that are attached to the <xref:System.Windows.ContentElement.PreviewGiveFeedback> event are attached to the underlying <xref:System.Windows.DragDrop.PreviewGiveFeedback?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
<a name="routedEventInfo_PreviewGiveFeedback"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="f4180-2078">路由事件信息</span><span class="sxs-lookup"><span data-stu-id="f4180-2078">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="f4180-2079">标识符字段</span><span class="sxs-lookup"><span data-stu-id="f4180-2079">Identifier field</span></span>|<xref:System.Windows.ContentElement.PreviewGiveFeedbackEvent>|  
|<span data-ttu-id="f4180-2080">路由策略</span><span class="sxs-lookup"><span data-stu-id="f4180-2080">Routing strategy</span></span>|<span data-ttu-id="f4180-2081">隧道</span><span class="sxs-lookup"><span data-stu-id="f4180-2081">Tunneling</span></span>|  
|<span data-ttu-id="f4180-2082">委托</span><span class="sxs-lookup"><span data-stu-id="f4180-2082">Delegate</span></span>|<xref:System.Windows.GiveFeedbackEventHandler>|  
  
-   <span data-ttu-id="f4180-2083">相应的浮升事件是<xref:System.Windows.ContentElement.GiveFeedback>。</span><span class="sxs-lookup"><span data-stu-id="f4180-2083">The corresponding bubbling event is <xref:System.Windows.ContentElement.GiveFeedback>.</span></span>  
  
-   <span data-ttu-id="f4180-2084">重写<xref:System.Windows.ContentElement.OnPreviewGiveFeedback%2A>实现类处理此事件在派生类中。</span><span class="sxs-lookup"><span data-stu-id="f4180-2084">Override <xref:System.Windows.ContentElement.OnPreviewGiveFeedback%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewGiveFeedbackEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewGiveFeedbackEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewGiveFeedbackEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewGiveFeedbackEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewGiveFeedbackEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewGiveFeedbackEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewGiveFeedbackEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.PreviewGiveFeedbackEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f4180-2085">标识 <see cref="E:System.Windows.ContentElement.PreviewGiveFeedback" /> 路由事件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-2085">Identifies the <see cref="E:System.Windows.ContentElement.PreviewGiveFeedback" /> routed event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4180-2086">在注册路由事件时创建路由事件标识符。</span><span class="sxs-lookup"><span data-stu-id="f4180-2086">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="f4180-2087">这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。</span><span class="sxs-lookup"><span data-stu-id="f4180-2087">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="f4180-2088">可以使用这些标识符添加类处理程序。</span><span class="sxs-lookup"><span data-stu-id="f4180-2088">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="f4180-2089">有关注册路由事件的更多信息，请参见 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="f4180-2089">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="f4180-2090">有关使用路由事件标识符添加类处理程序的更多信息，请参见 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="f4180-2090">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewGotKeyboardFocus">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.KeyboardFocusChangedEventHandler PreviewGotKeyboardFocus;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.KeyboardFocusChangedEventHandler PreviewGotKeyboardFocus" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewGotKeyboardFocus" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewGotKeyboardFocus As KeyboardFocusChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::KeyboardFocusChangedEventHandler ^ PreviewGotKeyboardFocus;" />
      <MemberSignature Language="F#" Value="member this.PreviewGotKeyboardFocus : System.Windows.Input.KeyboardFocusChangedEventHandler " Usage="member this.PreviewGotKeyboardFocus : System.Windows.Input.KeyboardFocusChangedEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewGotKeyboardFocus</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.KeyboardFocusChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f4180-2091">在此元素聚焦于键盘时发生。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-2091">Occurs when the keyboard is focused on this element.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4180-2092">由于此事件使用隧道路由，因此具有焦点的元素可能是而不是元素的子元素实际附加事件处理程序。</span><span class="sxs-lookup"><span data-stu-id="f4180-2092">Because this event uses tunneling routing, the element that has focus might be a child element instead of the element where the event handler is actually attached.</span></span> <span data-ttu-id="f4180-2093">检查<xref:System.Windows.RoutedEventArgs.Source%2A>事件数据以确定实际具有焦点的元素中。</span><span class="sxs-lookup"><span data-stu-id="f4180-2093">Check the <xref:System.Windows.RoutedEventArgs.Source%2A> in the event data to determine the actual element that has focus.</span></span>  
  
 <span data-ttu-id="f4180-2094">此事件创建一个别名<xref:System.Windows.Input.Keyboard.PreviewGotKeyboardFocus?displayProperty=nameWithType>附加事件对于此类，以便<xref:System.Windows.ContentElement.PreviewGotKeyboardFocus>属于类的成员列出时<xref:System.Windows.ContentElement>作为基元素继承。</span><span class="sxs-lookup"><span data-stu-id="f4180-2094">This event creates an alias for the <xref:System.Windows.Input.Keyboard.PreviewGotKeyboardFocus?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.PreviewGotKeyboardFocus> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="f4180-2095">事件处理程序附加到<xref:System.Windows.ContentElement.PreviewGotKeyboardFocus>事件附加到基础<xref:System.Windows.Input.Keyboard.PreviewGotKeyboardFocus?displayProperty=nameWithType>附加事件，并接收相同的事件数据实例。</span><span class="sxs-lookup"><span data-stu-id="f4180-2095">Event handlers that are attached to the <xref:System.Windows.ContentElement.PreviewGotKeyboardFocus> event are attached to the underlying <xref:System.Windows.Input.Keyboard.PreviewGotKeyboardFocus?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
<a name="routedEventInfo_PreviewGotKeyboardFocus"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="f4180-2096">路由事件信息</span><span class="sxs-lookup"><span data-stu-id="f4180-2096">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="f4180-2097">标识符字段</span><span class="sxs-lookup"><span data-stu-id="f4180-2097">Identifier field</span></span>|<xref:System.Windows.ContentElement.PreviewGotKeyboardFocusEvent>|  
|<span data-ttu-id="f4180-2098">路由策略</span><span class="sxs-lookup"><span data-stu-id="f4180-2098">Routing strategy</span></span>|<span data-ttu-id="f4180-2099">隧道</span><span class="sxs-lookup"><span data-stu-id="f4180-2099">Tunneling</span></span>|  
|<span data-ttu-id="f4180-2100">委托</span><span class="sxs-lookup"><span data-stu-id="f4180-2100">Delegate</span></span>|<xref:System.Windows.Input.KeyboardFocusChangedEventHandler>|  
  
-   <span data-ttu-id="f4180-2101">相应的浮升事件是<xref:System.Windows.ContentElement.GotKeyboardFocus>。</span><span class="sxs-lookup"><span data-stu-id="f4180-2101">The corresponding bubbling event is <xref:System.Windows.ContentElement.GotKeyboardFocus>.</span></span>  
  
-   <span data-ttu-id="f4180-2102">重写<xref:System.Windows.ContentElement.OnPreviewGotKeyboardFocus%2A>实现类处理此事件在派生类中。</span><span class="sxs-lookup"><span data-stu-id="f4180-2102">Override <xref:System.Windows.ContentElement.OnPreviewGotKeyboardFocus%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewLostKeyboardFocus" />
      </Docs>
    </Member>
    <Member MemberName="PreviewGotKeyboardFocusEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewGotKeyboardFocusEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewGotKeyboardFocusEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewGotKeyboardFocusEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewGotKeyboardFocusEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewGotKeyboardFocusEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewGotKeyboardFocusEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.PreviewGotKeyboardFocusEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f4180-2103">标识 <see cref="E:System.Windows.ContentElement.PreviewGotKeyboardFocus" /> 路由事件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-2103">Identifies the <see cref="E:System.Windows.ContentElement.PreviewGotKeyboardFocus" /> routed event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4180-2104">在注册路由事件时创建路由事件标识符。</span><span class="sxs-lookup"><span data-stu-id="f4180-2104">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="f4180-2105">这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。</span><span class="sxs-lookup"><span data-stu-id="f4180-2105">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="f4180-2106">可以使用这些标识符添加类处理程序。</span><span class="sxs-lookup"><span data-stu-id="f4180-2106">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="f4180-2107">有关注册路由事件的更多信息，请参见 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="f4180-2107">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="f4180-2108">有关使用路由事件标识符添加类处理程序的更多信息，请参见 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="f4180-2108">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewKeyDown">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.KeyEventHandler PreviewKeyDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.KeyEventHandler PreviewKeyDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewKeyDown" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewKeyDown As KeyEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::KeyEventHandler ^ PreviewKeyDown;" />
      <MemberSignature Language="F#" Value="member this.PreviewKeyDown : System.Windows.Input.KeyEventHandler " Usage="member this.PreviewKeyDown : System.Windows.Input.KeyEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewKeyDown</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.KeyEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f4180-2109">在此元素聚焦于键盘并且按下某个键时发生。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-2109">Occurs when a key is pressed while the keyboard is focused on this element.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4180-2110">密钥处理与其他平台功能，例如命令和文本组合进行交互。</span><span class="sxs-lookup"><span data-stu-id="f4180-2110">Key handling interacts with other platform features such as commanding and text composition.</span></span> <span data-ttu-id="f4180-2111"><xref:System.Windows.ContentElement.KeyDown>事件是一个较低级别的文本输入的事件，可能不会像预期某些控件上。</span><span class="sxs-lookup"><span data-stu-id="f4180-2111">The <xref:System.Windows.ContentElement.KeyDown> event is a lower-level text input event that might not behave as expected on certain controls.</span></span> <span data-ttu-id="f4180-2112">这是文本的因为某些控件具有控件组合或提供更高级版本的类处理输入处理和相关的事件。</span><span class="sxs-lookup"><span data-stu-id="f4180-2112">This is because some controls have control compositing or class handling that provides a higher-level version of text input handling and related events.</span></span>  
  
 <span data-ttu-id="f4180-2113">此事件创建一个别名<xref:System.Windows.Input.Keyboard.PreviewKeyDown?displayProperty=nameWithType>附加事件对于此类，以便<xref:System.Windows.ContentElement.PreviewKeyDown>属于类的成员列出时<xref:System.Windows.ContentElement>作为基元素继承。</span><span class="sxs-lookup"><span data-stu-id="f4180-2113">This event creates an alias for the <xref:System.Windows.Input.Keyboard.PreviewKeyDown?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.PreviewKeyDown> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="f4180-2114">事件处理程序附加到<xref:System.Windows.ContentElement.PreviewKeyDown>事件附加到基础<xref:System.Windows.Input.Keyboard.PreviewKeyDown?displayProperty=nameWithType>附加事件，并接收相同的事件数据实例。</span><span class="sxs-lookup"><span data-stu-id="f4180-2114">Event handlers that are attached to the <xref:System.Windows.ContentElement.PreviewKeyDown> event are attached to the underlying <xref:System.Windows.Input.Keyboard.PreviewKeyDown?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
<a name="routedEventInfo_PreviewKeyDown"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="f4180-2115">路由事件信息</span><span class="sxs-lookup"><span data-stu-id="f4180-2115">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="f4180-2116">标识符字段</span><span class="sxs-lookup"><span data-stu-id="f4180-2116">Identifier field</span></span>|<xref:System.Windows.ContentElement.PreviewKeyDownEvent>|  
|<span data-ttu-id="f4180-2117">路由策略</span><span class="sxs-lookup"><span data-stu-id="f4180-2117">Routing strategy</span></span>|<span data-ttu-id="f4180-2118">隧道</span><span class="sxs-lookup"><span data-stu-id="f4180-2118">Tunneling</span></span>|  
|<span data-ttu-id="f4180-2119">委托</span><span class="sxs-lookup"><span data-stu-id="f4180-2119">Delegate</span></span>|<xref:System.Windows.Input.KeyEventHandler>|  
  
-   <span data-ttu-id="f4180-2120">相应的浮升事件是<xref:System.Windows.ContentElement.KeyDown>。</span><span class="sxs-lookup"><span data-stu-id="f4180-2120">The corresponding bubbling event is <xref:System.Windows.ContentElement.KeyDown>.</span></span>  
  
-   <span data-ttu-id="f4180-2121">重写<xref:System.Windows.ContentElement.OnPreviewKeyDown%2A>实现类处理此事件在派生类中。</span><span class="sxs-lookup"><span data-stu-id="f4180-2121">Override <xref:System.Windows.ContentElement.OnPreviewKeyDown%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewKeyUp" />
      </Docs>
    </Member>
    <Member MemberName="PreviewKeyDownEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewKeyDownEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewKeyDownEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewKeyDownEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewKeyDownEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewKeyDownEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewKeyDownEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.PreviewKeyDownEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f4180-2122">标识 <see cref="E:System.Windows.ContentElement.PreviewKeyDown" /> 路由事件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-2122">Identifies the <see cref="E:System.Windows.ContentElement.PreviewKeyDown" /> routed event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4180-2123">在注册路由事件时创建路由事件标识符。</span><span class="sxs-lookup"><span data-stu-id="f4180-2123">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="f4180-2124">这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。</span><span class="sxs-lookup"><span data-stu-id="f4180-2124">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="f4180-2125">可以使用这些标识符添加类处理程序。</span><span class="sxs-lookup"><span data-stu-id="f4180-2125">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="f4180-2126">有关注册路由事件的更多信息，请参见 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="f4180-2126">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="f4180-2127">有关使用路由事件标识符添加类处理程序的更多信息，请参见 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="f4180-2127">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewKeyUp">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.KeyEventHandler PreviewKeyUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.KeyEventHandler PreviewKeyUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewKeyUp" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewKeyUp As KeyEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::KeyEventHandler ^ PreviewKeyUp;" />
      <MemberSignature Language="F#" Value="member this.PreviewKeyUp : System.Windows.Input.KeyEventHandler " Usage="member this.PreviewKeyUp : System.Windows.Input.KeyEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewKeyUp</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.KeyEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f4180-2128">在此元素聚焦于键盘并且松开某个键时发生。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-2128">Occurs when a key is released while the keyboard is focused on this element.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4180-2129">密钥处理与其他平台功能，例如命令和文本组合进行交互。</span><span class="sxs-lookup"><span data-stu-id="f4180-2129">Key handling interacts with other platform features such as commanding and text composition.</span></span> <span data-ttu-id="f4180-2130"><xref:System.Windows.ContentElement.KeyUp>事件是一个较低级别的文本输入的事件，可能不会像预期某些控件上。</span><span class="sxs-lookup"><span data-stu-id="f4180-2130">The <xref:System.Windows.ContentElement.KeyUp> event is a lower-level text input event that might not behave as expected on certain controls.</span></span> <span data-ttu-id="f4180-2131">这是文本的因为某些控件具有控件组合或提供更高级版本的类处理输入处理和相关的事件。</span><span class="sxs-lookup"><span data-stu-id="f4180-2131">This is because some controls have control compositing or class handling that provides a higher-level version of text input handling and related events.</span></span> <span data-ttu-id="f4180-2132">有关详细信息，请检查各个控件的文档。</span><span class="sxs-lookup"><span data-stu-id="f4180-2132">For details, check the documentation for individual controls.</span></span>  
  
 <span data-ttu-id="f4180-2133">此事件创建一个别名<xref:System.Windows.Input.Keyboard.PreviewKeyUp?displayProperty=nameWithType>附加事件对于此类，以便<xref:System.Windows.ContentElement.PreviewKeyUp>属于类的成员列出时<xref:System.Windows.ContentElement>作为基元素继承。</span><span class="sxs-lookup"><span data-stu-id="f4180-2133">This event creates an alias for the <xref:System.Windows.Input.Keyboard.PreviewKeyUp?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.PreviewKeyUp> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="f4180-2134">事件处理程序附加到<xref:System.Windows.ContentElement.PreviewKeyUp>事件附加到基础<xref:System.Windows.Input.Keyboard.PreviewKeyUp?displayProperty=nameWithType>附加事件，并接收相同的事件数据实例。</span><span class="sxs-lookup"><span data-stu-id="f4180-2134">Event handlers that are attached to the <xref:System.Windows.ContentElement.PreviewKeyUp> event are attached to the underlying <xref:System.Windows.Input.Keyboard.PreviewKeyUp?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
<a name="routedEventInfo_PreviewKeyUp"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="f4180-2135">路由事件信息</span><span class="sxs-lookup"><span data-stu-id="f4180-2135">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="f4180-2136">标识符字段</span><span class="sxs-lookup"><span data-stu-id="f4180-2136">Identifier field</span></span>|<xref:System.Windows.ContentElement.PreviewKeyUpEvent>|  
|<span data-ttu-id="f4180-2137">路由策略</span><span class="sxs-lookup"><span data-stu-id="f4180-2137">Routing strategy</span></span>|<span data-ttu-id="f4180-2138">隧道</span><span class="sxs-lookup"><span data-stu-id="f4180-2138">Tunneling</span></span>|  
|<span data-ttu-id="f4180-2139">委托</span><span class="sxs-lookup"><span data-stu-id="f4180-2139">Delegate</span></span>|<xref:System.Windows.Input.KeyEventHandler>|  
  
-   <span data-ttu-id="f4180-2140">相应的浮升事件是<xref:System.Windows.ContentElement.KeyUp>。</span><span class="sxs-lookup"><span data-stu-id="f4180-2140">The corresponding bubbling event is <xref:System.Windows.ContentElement.KeyUp>.</span></span>  
  
-   <span data-ttu-id="f4180-2141">重写<xref:System.Windows.ContentElement.OnPreviewKeyUp%2A>实现类处理此事件在派生类中。</span><span class="sxs-lookup"><span data-stu-id="f4180-2141">Override <xref:System.Windows.ContentElement.OnPreviewKeyUp%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewKeyUpEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewKeyUpEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewKeyUpEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewKeyUpEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewKeyUpEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewKeyUpEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewKeyUpEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.PreviewKeyUpEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f4180-2142">标识 <see cref="E:System.Windows.ContentElement.PreviewKeyUp" /> 路由事件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-2142">Identifies the <see cref="E:System.Windows.ContentElement.PreviewKeyUp" /> routed event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4180-2143">在注册路由事件时创建路由事件标识符。</span><span class="sxs-lookup"><span data-stu-id="f4180-2143">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="f4180-2144">这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。</span><span class="sxs-lookup"><span data-stu-id="f4180-2144">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="f4180-2145">可以使用这些标识符添加类处理程序。</span><span class="sxs-lookup"><span data-stu-id="f4180-2145">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="f4180-2146">有关注册路由事件的更多信息，请参见 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="f4180-2146">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="f4180-2147">有关使用路由事件标识符添加类处理程序的更多信息，请参见 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="f4180-2147">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewLostKeyboardFocus">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.KeyboardFocusChangedEventHandler PreviewLostKeyboardFocus;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.KeyboardFocusChangedEventHandler PreviewLostKeyboardFocus" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewLostKeyboardFocus" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewLostKeyboardFocus As KeyboardFocusChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::KeyboardFocusChangedEventHandler ^ PreviewLostKeyboardFocus;" />
      <MemberSignature Language="F#" Value="member this.PreviewLostKeyboardFocus : System.Windows.Input.KeyboardFocusChangedEventHandler " Usage="member this.PreviewLostKeyboardFocus : System.Windows.Input.KeyboardFocusChangedEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewLostKeyboardFocus</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.KeyboardFocusChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f4180-2148">在此元素不再聚焦于键盘时发生。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-2148">Occurs when the keyboard is no longer focused on this element.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4180-2149">由于此事件使用隧道路由，因此失去焦点的元素可能是而不是元素的子元素实际附加事件处理程序。</span><span class="sxs-lookup"><span data-stu-id="f4180-2149">Because this event uses tunneling routing, the element that lost focus might be a child element instead of the element where the event handler is actually attached.</span></span> <span data-ttu-id="f4180-2150">检查<xref:System.Windows.RoutedEventArgs.Source%2A>事件数据来确定实际失去焦点的元素中。</span><span class="sxs-lookup"><span data-stu-id="f4180-2150">Check the <xref:System.Windows.RoutedEventArgs.Source%2A> in the event data to determine the actual element that lost focus.</span></span>  
  
 <span data-ttu-id="f4180-2151">此事件创建一个别名<xref:System.Windows.Input.Keyboard.PreviewLostKeyboardFocus?displayProperty=nameWithType>附加事件对于此类，以便<xref:System.Windows.ContentElement.PreviewLostKeyboardFocus>属于类的成员列出时<xref:System.Windows.ContentElement>作为基元素继承。</span><span class="sxs-lookup"><span data-stu-id="f4180-2151">This event creates an alias for the <xref:System.Windows.Input.Keyboard.PreviewLostKeyboardFocus?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.PreviewLostKeyboardFocus> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="f4180-2152">事件处理程序附加到<xref:System.Windows.ContentElement.PreviewLostKeyboardFocus>事件附加到基础<xref:System.Windows.Input.Keyboard.PreviewLostKeyboardFocus?displayProperty=nameWithType>附加事件，并接收相同的事件数据实例。</span><span class="sxs-lookup"><span data-stu-id="f4180-2152">Event handlers that are attached to the <xref:System.Windows.ContentElement.PreviewLostKeyboardFocus> event are attached to the underlying <xref:System.Windows.Input.Keyboard.PreviewLostKeyboardFocus?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
<a name="routedEventInfo_PreviewLostKeyboardFocus"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="f4180-2153">路由事件信息</span><span class="sxs-lookup"><span data-stu-id="f4180-2153">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="f4180-2154">标识符字段</span><span class="sxs-lookup"><span data-stu-id="f4180-2154">Identifier field</span></span>|<xref:System.Windows.ContentElement.PreviewLostKeyboardFocusEvent>|  
|<span data-ttu-id="f4180-2155">路由策略</span><span class="sxs-lookup"><span data-stu-id="f4180-2155">Routing strategy</span></span>|<span data-ttu-id="f4180-2156">隧道</span><span class="sxs-lookup"><span data-stu-id="f4180-2156">Tunneling</span></span>|  
|<span data-ttu-id="f4180-2157">委托</span><span class="sxs-lookup"><span data-stu-id="f4180-2157">Delegate</span></span>|<xref:System.Windows.Input.KeyboardFocusChangedEventHandler>|  
  
-   <span data-ttu-id="f4180-2158">相应的浮升事件是<xref:System.Windows.ContentElement.LostKeyboardFocus>。</span><span class="sxs-lookup"><span data-stu-id="f4180-2158">The corresponding bubbling event is <xref:System.Windows.ContentElement.LostKeyboardFocus>.</span></span>  
  
-   <span data-ttu-id="f4180-2159">重写<xref:System.Windows.ContentElement.OnPreviewLostKeyboardFocus%2A>实现类处理此事件在派生类中。</span><span class="sxs-lookup"><span data-stu-id="f4180-2159">Override <xref:System.Windows.ContentElement.OnPreviewLostKeyboardFocus%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewGotKeyboardFocus" />
      </Docs>
    </Member>
    <Member MemberName="PreviewLostKeyboardFocusEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewLostKeyboardFocusEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewLostKeyboardFocusEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewLostKeyboardFocusEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewLostKeyboardFocusEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewLostKeyboardFocusEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewLostKeyboardFocusEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.PreviewLostKeyboardFocusEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f4180-2160">标识 <see cref="E:System.Windows.ContentElement.PreviewLostKeyboardFocus" /> 路由事件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-2160">Identifies the <see cref="E:System.Windows.ContentElement.PreviewLostKeyboardFocus" /> routed event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4180-2161">在注册路由事件时创建路由事件标识符。</span><span class="sxs-lookup"><span data-stu-id="f4180-2161">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="f4180-2162">这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。</span><span class="sxs-lookup"><span data-stu-id="f4180-2162">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="f4180-2163">可以使用这些标识符添加类处理程序。</span><span class="sxs-lookup"><span data-stu-id="f4180-2163">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="f4180-2164">有关注册路由事件的更多信息，请参见 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="f4180-2164">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="f4180-2165">有关使用路由事件标识符添加类处理程序的更多信息，请参见 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="f4180-2165">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseDown">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseButtonEventHandler PreviewMouseDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseButtonEventHandler PreviewMouseDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewMouseDown" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewMouseDown As MouseButtonEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Input::MouseButtonEventHandler ^ PreviewMouseDown;" />
      <MemberSignature Language="F#" Value="member this.PreviewMouseDown : System.Windows.Input.MouseButtonEventHandler " Usage="member this.PreviewMouseDown : System.Windows.Input.MouseButtonEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f4180-2166">在指针位于此元素上并且按下任意鼠标按钮时发生。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-2166">Occurs when any mouse button is pressed while the pointer is over this element.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4180-2167">此事件创建一个别名<xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType>附加事件对于此类，以便<xref:System.Windows.ContentElement.PreviewMouseDown>属于类的成员列出时<xref:System.Windows.ContentElement>作为基元素继承。</span><span class="sxs-lookup"><span data-stu-id="f4180-2167">This event creates an alias for the <xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.PreviewMouseDown> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="f4180-2168">事件处理程序附加到<xref:System.Windows.ContentElement.PreviewMouseDown>事件附加到基础<xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType>附加事件，并接收相同的事件数据实例。</span><span class="sxs-lookup"><span data-stu-id="f4180-2168">Event handlers that are attached to the <xref:System.Windows.ContentElement.PreviewMouseDown> event are attached to the underlying <xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
 <span data-ttu-id="f4180-2169"><xref:System.Windows.ContentElement.PreviewMouseDown>任意一个协同通常引发事件<xref:System.Windows.ContentElement.PreviewMouseLeftButtonDown>或<xref:System.Windows.ContentElement.PreviewMouseRightButtonDown>，对应于一个两个标准鼠标按钮按下。</span><span class="sxs-lookup"><span data-stu-id="f4180-2169">The <xref:System.Windows.ContentElement.PreviewMouseDown> event is often raised together with either <xref:System.Windows.ContentElement.PreviewMouseLeftButtonDown> or <xref:System.Windows.ContentElement.PreviewMouseRightButtonDown>, which correspond to a press of one of the two standard mouse buttons.</span></span> <span data-ttu-id="f4180-2170"><xref:System.Windows.ContentElement.PreviewMouseLeftButtonDown> 并<xref:System.Windows.ContentElement.PreviewMouseRightButtonDown>也是路由的事件，但它们是直接路由的事件，并引发相应的特定于按钮的事件时<xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType>事件到达事件路由中的此元素。</span><span class="sxs-lookup"><span data-stu-id="f4180-2170"><xref:System.Windows.ContentElement.PreviewMouseLeftButtonDown> and <xref:System.Windows.ContentElement.PreviewMouseRightButtonDown> are also routed events, but they are direct routed events, and the appropriate button-specific event is raised when the <xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType> event reaches this element along the event route.</span></span> <span data-ttu-id="f4180-2171">请参阅备注<xref:System.Windows.ContentElement.PreviewMouseLeftButtonDown>或<xref:System.Windows.ContentElement.PreviewMouseRightButtonDown>。</span><span class="sxs-lookup"><span data-stu-id="f4180-2171">See Remarks for <xref:System.Windows.ContentElement.PreviewMouseLeftButtonDown> or <xref:System.Windows.ContentElement.PreviewMouseRightButtonDown>.</span></span>  
  
<a name="routedEventInfo_PreviewMouseDown"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="f4180-2172">路由事件信息</span><span class="sxs-lookup"><span data-stu-id="f4180-2172">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="f4180-2173">标识符字段</span><span class="sxs-lookup"><span data-stu-id="f4180-2173">Identifier field</span></span>|<xref:System.Windows.ContentElement.PreviewMouseDownEvent>|  
|<span data-ttu-id="f4180-2174">路由策略</span><span class="sxs-lookup"><span data-stu-id="f4180-2174">Routing strategy</span></span>|<span data-ttu-id="f4180-2175">隧道</span><span class="sxs-lookup"><span data-stu-id="f4180-2175">Tunneling</span></span>|  
|<span data-ttu-id="f4180-2176">委托</span><span class="sxs-lookup"><span data-stu-id="f4180-2176">Delegate</span></span>|<xref:System.Windows.Input.MouseButtonEventHandler>|  
  
-   <span data-ttu-id="f4180-2177">相应的浮升事件是<xref:System.Windows.ContentElement.MouseDown>。</span><span class="sxs-lookup"><span data-stu-id="f4180-2177">The corresponding bubbling event is <xref:System.Windows.ContentElement.MouseDown>.</span></span>  
  
-   <span data-ttu-id="f4180-2178">重写<xref:System.Windows.ContentElement.OnPreviewMouseDown%2A>实现类处理此事件在派生类中。</span><span class="sxs-lookup"><span data-stu-id="f4180-2178">Override <xref:System.Windows.ContentElement.OnPreviewMouseDown%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseDownEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewMouseDownEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewMouseDownEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewMouseDownEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewMouseDownEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewMouseDownEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewMouseDownEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.PreviewMouseDownEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f4180-2179">标识 <see cref="E:System.Windows.ContentElement.PreviewMouseDown" /> 路由事件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-2179">Identifies the <see cref="E:System.Windows.ContentElement.PreviewMouseDown" /> routed event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4180-2180">在注册路由事件时创建路由事件标识符。</span><span class="sxs-lookup"><span data-stu-id="f4180-2180">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="f4180-2181">这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。</span><span class="sxs-lookup"><span data-stu-id="f4180-2181">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="f4180-2182">可以使用这些标识符添加类处理程序。</span><span class="sxs-lookup"><span data-stu-id="f4180-2182">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="f4180-2183">有关注册路由事件的更多信息，请参见 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="f4180-2183">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="f4180-2184">有关使用路由事件标识符添加类处理程序的更多信息，请参见 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="f4180-2184">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseLeftButtonDown">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseButtonEventHandler PreviewMouseLeftButtonDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseButtonEventHandler PreviewMouseLeftButtonDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewMouseLeftButtonDown" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewMouseLeftButtonDown As MouseButtonEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::MouseButtonEventHandler ^ PreviewMouseLeftButtonDown;" />
      <MemberSignature Language="F#" Value="member this.PreviewMouseLeftButtonDown : System.Windows.Input.MouseButtonEventHandler " Usage="member this.PreviewMouseLeftButtonDown : System.Windows.Input.MouseButtonEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewMouseLeftButtonDown</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f4180-2185">在鼠标指针位于此元素上并且按下鼠标左键时发生。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-2185">Occurs when the left mouse button is pressed while the mouse pointer is over this element.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4180-2186">尽管这[路由事件概述](~/docs/framework/wpf/advanced/routed-events-overview.md)似乎遵循元素树中，通过隧道路由它实际上是引发并由每个重新沿元素树的直接路由的事件<xref:System.Windows.ContentElement>。</span><span class="sxs-lookup"><span data-stu-id="f4180-2186">Although this [Routed Events Overview](~/docs/framework/wpf/advanced/routed-events-overview.md) seems to follow a tunneling route through an element tree, it actually is a direct routed event that is raised and reraised along the element tree by each <xref:System.Windows.ContentElement>.</span></span>  
  
 <span data-ttu-id="f4180-2187">此事件是一个报告基础的鼠标按钮具体情况的多个相关事件<xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType>事件，它是由在事件路由的每个元素处理附加的事件。</span><span class="sxs-lookup"><span data-stu-id="f4180-2187">This event is one of several related events that report the mouse-button specifics of an underlying <xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType> event, which is an attached event that is processed by each element along an event route.</span></span>  
  
 <span data-ttu-id="f4180-2188">此事件的基础参数公开<xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType>事件。</span><span class="sxs-lookup"><span data-stu-id="f4180-2188">The arguments of this event expose the arguments of the underlying <xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType> event.</span></span> <span data-ttu-id="f4180-2189">如果该事件被标记为已处理事件路由过程，则仍会引发鼠标按钮特定事件;但是，必须通过显式调用添加的鼠标按钮特定事件的处理程序<xref:System.Windows.ContentElement.AddHandler%2A>，使用选项来处理已标记为已处理的事件，以便将该事件的侦听器。</span><span class="sxs-lookup"><span data-stu-id="f4180-2189">If that event is marked as handled along the event route, the mouse-button specific events are still raised; however, handlers of the mouse-button specific events must be added by explicitly calling <xref:System.Windows.ContentElement.AddHandler%2A>, with the option to handle events that are already marked as handled, in order to be listeners to the event.</span></span>  
  
 <span data-ttu-id="f4180-2190">从概念上讲，将此事件 (和其他鼠标事件<xref:System.Windows.ContentElement>) 为鼠标"服务"(使用提供的服务定义<xref:System.Windows.Input.Mouse>类)。</span><span class="sxs-lookup"><span data-stu-id="f4180-2190">Conceptually, think of this event (and other mouse-button events on <xref:System.Windows.ContentElement>) to be a mouse "service" (with the service definition provided by the <xref:System.Windows.Input.Mouse> class).</span></span> <span data-ttu-id="f4180-2191">事件添加了方便的不需要检查原始的鼠标事件在事件数据中的鼠标按钮状态 （左-右、 向上向下）。</span><span class="sxs-lookup"><span data-stu-id="f4180-2191">The event adds the convenience of not needing to check the mouse button states (left-right, up-down) of the original mouse events in the event data.</span></span> <span data-ttu-id="f4180-2192">对于更高级的方案，例如非标准按钮的状态检查，您可能需要使用[!INCLUDE[TLA#tla_api#plural](~/includes/tlasharptla-apisharpplural-md.md)]上<xref:System.Windows.Input.Mouse>而不是这些类上<xref:System.Windows.ContentElement>。</span><span class="sxs-lookup"><span data-stu-id="f4180-2192">For more advanced scenarios, such as checking for states of non-standard buttons, you might need to use the [!INCLUDE[TLA#tla_api#plural](~/includes/tlasharptla-apisharpplural-md.md)] on the <xref:System.Windows.Input.Mouse> class rather than those on <xref:System.Windows.ContentElement>.</span></span>  
  
<a name="routedEventInfo_PreviewMouseLeftButtonDown"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="f4180-2193">路由事件信息</span><span class="sxs-lookup"><span data-stu-id="f4180-2193">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="f4180-2194">标识符字段</span><span class="sxs-lookup"><span data-stu-id="f4180-2194">Identifier field</span></span>|<xref:System.Windows.ContentElement.PreviewMouseLeftButtonDownEvent>|  
|<span data-ttu-id="f4180-2195">路由策略</span><span class="sxs-lookup"><span data-stu-id="f4180-2195">Routing strategy</span></span>|<span data-ttu-id="f4180-2196">直接</span><span class="sxs-lookup"><span data-stu-id="f4180-2196">Direct</span></span>|  
|<span data-ttu-id="f4180-2197">委托</span><span class="sxs-lookup"><span data-stu-id="f4180-2197">Delegate</span></span>|<xref:System.Windows.Input.MouseButtonEventHandler>|  
  
-   <span data-ttu-id="f4180-2198">重写<xref:System.Windows.ContentElement.OnPreviewMouseLeftButtonDown%2A>实现类处理此事件在派生类中。</span><span class="sxs-lookup"><span data-stu-id="f4180-2198">Override <xref:System.Windows.ContentElement.OnPreviewMouseLeftButtonDown%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.MouseLeftButtonDown" />
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseLeftButtonDownEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewMouseLeftButtonDownEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewMouseLeftButtonDownEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewMouseLeftButtonDownEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewMouseLeftButtonDownEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewMouseLeftButtonDownEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewMouseLeftButtonDownEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.PreviewMouseLeftButtonDownEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f4180-2199">标识 <see cref="E:System.Windows.ContentElement.PreviewMouseLeftButtonDown" /> 路由事件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-2199">Identifies the <see cref="E:System.Windows.ContentElement.PreviewMouseLeftButtonDown" /> routed event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4180-2200">在注册路由事件时创建路由事件标识符。</span><span class="sxs-lookup"><span data-stu-id="f4180-2200">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="f4180-2201">这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。</span><span class="sxs-lookup"><span data-stu-id="f4180-2201">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="f4180-2202">可以使用这些标识符添加类处理程序。</span><span class="sxs-lookup"><span data-stu-id="f4180-2202">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="f4180-2203">有关注册路由事件的更多信息，请参见 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="f4180-2203">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="f4180-2204">有关使用路由事件标识符添加类处理程序的更多信息，请参见 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="f4180-2204">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseLeftButtonUp">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseButtonEventHandler PreviewMouseLeftButtonUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseButtonEventHandler PreviewMouseLeftButtonUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewMouseLeftButtonUp" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewMouseLeftButtonUp As MouseButtonEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::MouseButtonEventHandler ^ PreviewMouseLeftButtonUp;" />
      <MemberSignature Language="F#" Value="member this.PreviewMouseLeftButtonUp : System.Windows.Input.MouseButtonEventHandler " Usage="member this.PreviewMouseLeftButtonUp : System.Windows.Input.MouseButtonEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewMouseLeftButtonUp</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f4180-2205">在鼠标指针位于此元素上并且松开鼠标左键时发生。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-2205">Occurs when the left mouse button is released while the mouse pointer is over this element.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4180-2206">尽管这[路由事件概述](~/docs/framework/wpf/advanced/routed-events-overview.md)似乎遵循元素树中，通过隧道路由它实际上是引发并由每个重新沿元素树的直接路由的事件<xref:System.Windows.ContentElement>。</span><span class="sxs-lookup"><span data-stu-id="f4180-2206">Although this [Routed Events Overview](~/docs/framework/wpf/advanced/routed-events-overview.md) seems to follow a tunneling route through an element tree, it actually is a direct routed event that is raised and reraised along the element tree by each <xref:System.Windows.ContentElement>.</span></span>  
  
 <span data-ttu-id="f4180-2207">此事件是一个报告基础的鼠标按钮具体情况的多个相关事件<xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType>事件，它是由在事件路由的每个元素处理附加的事件。</span><span class="sxs-lookup"><span data-stu-id="f4180-2207">This event is one of several related events that report the mouse-button specifics of an underlying <xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType> event, which is an attached event that is processed by each element along an event route.</span></span>  
  
 <span data-ttu-id="f4180-2208">此事件的基础参数公开<xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType>事件。</span><span class="sxs-lookup"><span data-stu-id="f4180-2208">The arguments of this event expose the arguments of the underlying <xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType> event.</span></span> <span data-ttu-id="f4180-2209">如果该事件被标记为已处理事件路由过程，则仍会引发鼠标按钮特定事件;但是，必须通过显式调用添加的鼠标按钮特定事件的处理程序<xref:System.Windows.ContentElement.AddHandler%2A>，使用选项来处理已标记为已处理的事件，以便将该事件的侦听器。</span><span class="sxs-lookup"><span data-stu-id="f4180-2209">If that event is marked as handled along the event route, the mouse-button specific events are still raised; however, handlers of the mouse-button specific events must be added by explicitly calling <xref:System.Windows.ContentElement.AddHandler%2A>, with the option to handle events that are already marked as handled, in order to be listeners to the event.</span></span>  
  
 <span data-ttu-id="f4180-2210">从概念上讲，将此事件 (和其他鼠标事件<xref:System.Windows.ContentElement>) 为鼠标"服务"(使用提供的服务定义<xref:System.Windows.Input.Mouse>类)。</span><span class="sxs-lookup"><span data-stu-id="f4180-2210">Conceptually, think of this event (and other mouse-button events on <xref:System.Windows.ContentElement>) to be a mouse "service" (with the service definition provided by the <xref:System.Windows.Input.Mouse> class).</span></span> <span data-ttu-id="f4180-2211">事件添加了方便的不需要检查原始的鼠标事件在事件数据中的鼠标按钮状态 （左-右、 向上向下）。</span><span class="sxs-lookup"><span data-stu-id="f4180-2211">The event adds the convenience of not needing to check the mouse button states (left-right, up-down) of the original mouse events in the event data.</span></span> <span data-ttu-id="f4180-2212">对于更高级的方案，例如非标准按钮的状态检查，您可能需要使用[!INCLUDE[TLA#tla_api#plural](~/includes/tlasharptla-apisharpplural-md.md)]上<xref:System.Windows.Input.Mouse>而不是这些类上<xref:System.Windows.ContentElement>。</span><span class="sxs-lookup"><span data-stu-id="f4180-2212">For more advanced scenarios, such as checking for states of non-standard buttons, you might need to use the [!INCLUDE[TLA#tla_api#plural](~/includes/tlasharptla-apisharpplural-md.md)] on the <xref:System.Windows.Input.Mouse> class rather than those on <xref:System.Windows.ContentElement>.</span></span>  
  
<a name="routedEventInfo_PreviewMouseLeftButtonUp"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="f4180-2213">路由事件信息</span><span class="sxs-lookup"><span data-stu-id="f4180-2213">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="f4180-2214">标识符字段</span><span class="sxs-lookup"><span data-stu-id="f4180-2214">Identifier field</span></span>|<xref:System.Windows.ContentElement.PreviewMouseLeftButtonUpEvent>|  
|<span data-ttu-id="f4180-2215">路由策略</span><span class="sxs-lookup"><span data-stu-id="f4180-2215">Routing strategy</span></span>|<span data-ttu-id="f4180-2216">直接</span><span class="sxs-lookup"><span data-stu-id="f4180-2216">Direct</span></span>|  
|<span data-ttu-id="f4180-2217">委托</span><span class="sxs-lookup"><span data-stu-id="f4180-2217">Delegate</span></span>|<xref:System.Windows.Input.MouseButtonEventHandler>|  
  
-   <span data-ttu-id="f4180-2218">重写<xref:System.Windows.ContentElement.OnPreviewMouseLeftButtonUp%2A>实现类处理此事件在派生类中。</span><span class="sxs-lookup"><span data-stu-id="f4180-2218">Override <xref:System.Windows.ContentElement.OnPreviewMouseLeftButtonUp%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseLeftButtonUpEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewMouseLeftButtonUpEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewMouseLeftButtonUpEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewMouseLeftButtonUpEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewMouseLeftButtonUpEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewMouseLeftButtonUpEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewMouseLeftButtonUpEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.PreviewMouseLeftButtonUpEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f4180-2219">标识 <see cref="E:System.Windows.ContentElement.PreviewMouseLeftButtonUp" /> 路由事件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-2219">Identifies the <see cref="E:System.Windows.ContentElement.PreviewMouseLeftButtonUp" /> routed event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4180-2220">在注册路由事件时创建路由事件标识符。</span><span class="sxs-lookup"><span data-stu-id="f4180-2220">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="f4180-2221">这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。</span><span class="sxs-lookup"><span data-stu-id="f4180-2221">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="f4180-2222">可以使用这些标识符添加类处理程序。</span><span class="sxs-lookup"><span data-stu-id="f4180-2222">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="f4180-2223">有关注册路由事件的更多信息，请参见 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="f4180-2223">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="f4180-2224">有关使用路由事件标识符添加类处理程序的更多信息，请参见 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="f4180-2224">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseMove">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseEventHandler PreviewMouseMove;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseEventHandler PreviewMouseMove" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewMouseMove" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewMouseMove As MouseEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::MouseEventHandler ^ PreviewMouseMove;" />
      <MemberSignature Language="F#" Value="member this.PreviewMouseMove : System.Windows.Input.MouseEventHandler " Usage="member this.PreviewMouseMove : System.Windows.Input.MouseEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewMouseMove</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f4180-2225">在鼠标指针位于此元素上并且移动鼠标指针时发生。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-2225">Occurs when the mouse pointer moves while the mouse pointer is over this element.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4180-2226">都会发生此事件时鼠标指针第一次进入元素边界，并还在鼠标指针移动时仍剩余元素的边界内。</span><span class="sxs-lookup"><span data-stu-id="f4180-2226">This event occurs both when the mouse pointer first enters into the element bounds, and also when the mouse pointer moves while still remaining within the element bounds.</span></span>  
  
 <span data-ttu-id="f4180-2227">此事件创建一个别名<xref:System.Windows.Input.Mouse.PreviewMouseMove?displayProperty=nameWithType>附加事件对于此类，以便<xref:System.Windows.ContentElement.PreviewMouseMove>属于类的成员列出时<xref:System.Windows.ContentElement>作为基元素继承。</span><span class="sxs-lookup"><span data-stu-id="f4180-2227">This event creates an alias for the <xref:System.Windows.Input.Mouse.PreviewMouseMove?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.PreviewMouseMove> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="f4180-2228">事件处理程序附加到<xref:System.Windows.ContentElement.PreviewMouseMove>事件附加到基础<xref:System.Windows.Input.Mouse.PreviewMouseMove?displayProperty=nameWithType>附加事件，并接收相同的事件数据实例。</span><span class="sxs-lookup"><span data-stu-id="f4180-2228">Event handlers that are attached to the <xref:System.Windows.ContentElement.PreviewMouseMove> event are attached to the underlying <xref:System.Windows.Input.Mouse.PreviewMouseMove?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
<a name="routedEventInfo_PreviewMouseMove"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="f4180-2229">路由事件信息</span><span class="sxs-lookup"><span data-stu-id="f4180-2229">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="f4180-2230">标识符字段</span><span class="sxs-lookup"><span data-stu-id="f4180-2230">Identifier field</span></span>|<xref:System.Windows.ContentElement.PreviewMouseMoveEvent>|  
|<span data-ttu-id="f4180-2231">路由策略</span><span class="sxs-lookup"><span data-stu-id="f4180-2231">Routing strategy</span></span>|<span data-ttu-id="f4180-2232">隧道</span><span class="sxs-lookup"><span data-stu-id="f4180-2232">Tunneling</span></span>|  
|<span data-ttu-id="f4180-2233">委托</span><span class="sxs-lookup"><span data-stu-id="f4180-2233">Delegate</span></span>|<xref:System.Windows.Input.MouseEventHandler>|  
  
-   <span data-ttu-id="f4180-2234">相应的浮升事件是<xref:System.Windows.ContentElement.MouseMove>。</span><span class="sxs-lookup"><span data-stu-id="f4180-2234">The corresponding bubbling event is <xref:System.Windows.ContentElement.MouseMove>.</span></span>  
  
-   <span data-ttu-id="f4180-2235">重写<xref:System.Windows.ContentElement.OnPreviewMouseMove%2A>实现类处理此事件在派生类中。</span><span class="sxs-lookup"><span data-stu-id="f4180-2235">Override <xref:System.Windows.ContentElement.OnPreviewMouseMove%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseMoveEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewMouseMoveEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewMouseMoveEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewMouseMoveEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewMouseMoveEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewMouseMoveEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewMouseMoveEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.PreviewMouseMoveEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f4180-2236">标识 <see cref="E:System.Windows.ContentElement.PreviewMouseMove" /> 路由事件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-2236">Identifies the <see cref="E:System.Windows.ContentElement.PreviewMouseMove" /> routed event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4180-2237">在注册路由事件时创建路由事件标识符。</span><span class="sxs-lookup"><span data-stu-id="f4180-2237">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="f4180-2238">这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。</span><span class="sxs-lookup"><span data-stu-id="f4180-2238">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="f4180-2239">可以使用这些标识符添加类处理程序。</span><span class="sxs-lookup"><span data-stu-id="f4180-2239">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="f4180-2240">有关注册路由事件的更多信息，请参见 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="f4180-2240">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="f4180-2241">有关使用路由事件标识符添加类处理程序的更多信息，请参见 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="f4180-2241">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseRightButtonDown">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseButtonEventHandler PreviewMouseRightButtonDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseButtonEventHandler PreviewMouseRightButtonDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewMouseRightButtonDown" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewMouseRightButtonDown As MouseButtonEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::MouseButtonEventHandler ^ PreviewMouseRightButtonDown;" />
      <MemberSignature Language="F#" Value="member this.PreviewMouseRightButtonDown : System.Windows.Input.MouseButtonEventHandler " Usage="member this.PreviewMouseRightButtonDown : System.Windows.Input.MouseButtonEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewMouseRightButtonDown</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f4180-2242">在鼠标指针位于此元素上并且按下鼠标右键时发生。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-2242">Occurs when the right mouse button is pressed while the mouse pointer is over this element.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4180-2243">尽管这[路由事件概述](~/docs/framework/wpf/advanced/routed-events-overview.md)似乎遵循元素树中，通过隧道路由它实际上是引发并由每个重新沿元素树的直接路由的事件<xref:System.Windows.ContentElement>。</span><span class="sxs-lookup"><span data-stu-id="f4180-2243">Although this [Routed Events Overview](~/docs/framework/wpf/advanced/routed-events-overview.md) seems to follow a tunneling route through an element tree, it actually is a direct routed event that is raised and reraised along the element tree by each <xref:System.Windows.ContentElement>.</span></span>  
  
 <span data-ttu-id="f4180-2244">此事件是一个报告基础的鼠标按钮具体情况的多个相关事件<xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType>事件，它是由在事件路由的每个元素处理附加的事件。</span><span class="sxs-lookup"><span data-stu-id="f4180-2244">This event is one of several related events that report the mouse-button specifics of an underlying <xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType> event, which is an attached event that is processed by each element along an event route.</span></span>  
  
 <span data-ttu-id="f4180-2245">此事件的基础参数公开<xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType>事件。</span><span class="sxs-lookup"><span data-stu-id="f4180-2245">The arguments of this event expose the arguments of the underlying <xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType> event.</span></span> <span data-ttu-id="f4180-2246">如果该事件被标记为已处理事件路由过程，则仍会引发鼠标按钮特定事件;但是，必须通过显式调用添加的鼠标按钮特定事件的处理程序<xref:System.Windows.ContentElement.AddHandler%2A>，使用选项来处理已标记为已处理的事件，以便将该事件的侦听器。</span><span class="sxs-lookup"><span data-stu-id="f4180-2246">If that event is marked as handled along the event route, the mouse-button specific events are still raised; however, handlers of the mouse-button specific events must be added by explicitly calling <xref:System.Windows.ContentElement.AddHandler%2A>, with the option to handle events that are already marked as handled, in order to be listeners to the event.</span></span>  
  
 <span data-ttu-id="f4180-2247">从概念上讲，将此事件 (和其他鼠标事件<xref:System.Windows.ContentElement>) 为鼠标"服务"(使用提供的服务定义<xref:System.Windows.Input.Mouse>类)。</span><span class="sxs-lookup"><span data-stu-id="f4180-2247">Conceptually, think of this event (and other mouse-button events on <xref:System.Windows.ContentElement>) to be a mouse "service" (with the service definition provided by the <xref:System.Windows.Input.Mouse> class).</span></span> <span data-ttu-id="f4180-2248">事件添加了方便的不需要检查原始的鼠标事件在事件数据中的鼠标按钮状态 （左-右、 向上向下）。</span><span class="sxs-lookup"><span data-stu-id="f4180-2248">The event adds the convenience of not needing to check the mouse button states (left-right, up-down) of the original mouse events in the event data.</span></span> <span data-ttu-id="f4180-2249">对于更高级的方案，例如非标准按钮的状态检查，您可能需要使用[!INCLUDE[TLA#tla_api#plural](~/includes/tlasharptla-apisharpplural-md.md)]上<xref:System.Windows.Input.Mouse>而不是这些类上<xref:System.Windows.ContentElement>。</span><span class="sxs-lookup"><span data-stu-id="f4180-2249">For more advanced scenarios, such as checking for states of non-standard buttons, you might need to use the [!INCLUDE[TLA#tla_api#plural](~/includes/tlasharptla-apisharpplural-md.md)] on the <xref:System.Windows.Input.Mouse> class rather than those on <xref:System.Windows.ContentElement>.</span></span>  
  
<a name="routedEventInfo_PreviewMouseRightButtonDown"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="f4180-2250">路由事件信息</span><span class="sxs-lookup"><span data-stu-id="f4180-2250">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="f4180-2251">标识符字段</span><span class="sxs-lookup"><span data-stu-id="f4180-2251">Identifier field</span></span>|<xref:System.Windows.ContentElement.PreviewMouseRightButtonDownEvent>|  
|<span data-ttu-id="f4180-2252">路由策略</span><span class="sxs-lookup"><span data-stu-id="f4180-2252">Routing strategy</span></span>|<span data-ttu-id="f4180-2253">直接</span><span class="sxs-lookup"><span data-stu-id="f4180-2253">Direct</span></span>|  
|<span data-ttu-id="f4180-2254">委托</span><span class="sxs-lookup"><span data-stu-id="f4180-2254">Delegate</span></span>|<xref:System.Windows.Input.MouseButtonEventHandler>|  
  
-   <span data-ttu-id="f4180-2255">重写<xref:System.Windows.ContentElement.OnPreviewMouseRightButtonDown%2A>实现类处理此事件在派生类中。</span><span class="sxs-lookup"><span data-stu-id="f4180-2255">Override <xref:System.Windows.ContentElement.OnPreviewMouseRightButtonDown%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.MouseRightButtonDown" />
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseRightButtonDownEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewMouseRightButtonDownEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewMouseRightButtonDownEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewMouseRightButtonDownEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewMouseRightButtonDownEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewMouseRightButtonDownEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewMouseRightButtonDownEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.PreviewMouseRightButtonDownEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f4180-2256">标识 <see cref="E:System.Windows.ContentElement.PreviewMouseRightButtonDown" /> 路由事件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-2256">Identifies the <see cref="E:System.Windows.ContentElement.PreviewMouseRightButtonDown" /> routed event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4180-2257">在注册路由事件时创建路由事件标识符。</span><span class="sxs-lookup"><span data-stu-id="f4180-2257">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="f4180-2258">这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。</span><span class="sxs-lookup"><span data-stu-id="f4180-2258">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="f4180-2259">可以使用这些标识符添加类处理程序。</span><span class="sxs-lookup"><span data-stu-id="f4180-2259">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="f4180-2260">有关注册路由事件的更多信息，请参见 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="f4180-2260">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="f4180-2261">有关使用路由事件标识符添加类处理程序的更多信息，请参见 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="f4180-2261">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseRightButtonUp">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseButtonEventHandler PreviewMouseRightButtonUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseButtonEventHandler PreviewMouseRightButtonUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewMouseRightButtonUp" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewMouseRightButtonUp As MouseButtonEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::MouseButtonEventHandler ^ PreviewMouseRightButtonUp;" />
      <MemberSignature Language="F#" Value="member this.PreviewMouseRightButtonUp : System.Windows.Input.MouseButtonEventHandler " Usage="member this.PreviewMouseRightButtonUp : System.Windows.Input.MouseButtonEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewMouseRightButtonUp</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f4180-2262">在鼠标指针位于此元素上并且松开鼠标右键时发生。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-2262">Occurs when the right mouse button is released while the mouse pointer is over this element.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4180-2263">尽管这[路由事件概述](~/docs/framework/wpf/advanced/routed-events-overview.md)似乎遵循元素树中，通过隧道路由它实际上是引发并由每个重新沿元素树的直接路由的事件<xref:System.Windows.ContentElement>。</span><span class="sxs-lookup"><span data-stu-id="f4180-2263">Although this [Routed Events Overview](~/docs/framework/wpf/advanced/routed-events-overview.md) seems to follow a tunneling route through an element tree, it actually is a direct routed event that is raised and reraised along the element tree by each <xref:System.Windows.ContentElement>.</span></span>  
  
 <span data-ttu-id="f4180-2264">此事件是一个报告基础的鼠标按钮具体情况的多个相关事件<xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType>事件，它是由在事件路由的每个元素处理附加的事件。</span><span class="sxs-lookup"><span data-stu-id="f4180-2264">This event is one of several related events that report the mouse-button specifics of an underlying <xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType> event, which is an attached event that is processed by each element along an event route.</span></span>  
  
 <span data-ttu-id="f4180-2265">此事件的基础参数公开<xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType>事件。</span><span class="sxs-lookup"><span data-stu-id="f4180-2265">The arguments of this event expose the arguments of the underlying <xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType> event.</span></span> <span data-ttu-id="f4180-2266">如果该事件被标记为已处理事件路由过程，则仍会引发鼠标按钮特定事件;但是，必须通过显式调用添加的鼠标按钮特定事件的处理程序<xref:System.Windows.ContentElement.AddHandler%2A>，使用选项来处理已标记为已处理的事件，以便将该事件的侦听器。</span><span class="sxs-lookup"><span data-stu-id="f4180-2266">If that event is marked as handled along the event route, the mouse-button specific events are still raised; however, handlers of the mouse-button specific events must be added by explicitly calling <xref:System.Windows.ContentElement.AddHandler%2A>, with the option to handle events that are already marked as handled, in order to be listeners to the event.</span></span>  
  
 <span data-ttu-id="f4180-2267">从概念上讲，将此事件 (和其他鼠标事件<xref:System.Windows.ContentElement>) 为鼠标"服务"(使用提供的服务定义<xref:System.Windows.Input.Mouse>类)。</span><span class="sxs-lookup"><span data-stu-id="f4180-2267">Conceptually, think of this event (and other mouse-button events on <xref:System.Windows.ContentElement>) to be a mouse "service" (with the service definition provided by the <xref:System.Windows.Input.Mouse> class).</span></span> <span data-ttu-id="f4180-2268">事件添加了方便的不需要检查原始的鼠标事件在事件数据中的鼠标按钮状态 （左-右、 向上向下）。</span><span class="sxs-lookup"><span data-stu-id="f4180-2268">The event adds the convenience of not needing to check the mouse button states (left-right, up-down) of the original mouse events in the event data.</span></span> <span data-ttu-id="f4180-2269">对于更高级的方案，例如非标准按钮的状态检查，您可能需要使用[!INCLUDE[TLA#tla_api#plural](~/includes/tlasharptla-apisharpplural-md.md)]上<xref:System.Windows.Input.Mouse>而不是这些类上<xref:System.Windows.ContentElement>。</span><span class="sxs-lookup"><span data-stu-id="f4180-2269">For more advanced scenarios, such as checking for states of non-standard buttons, you might need to use the [!INCLUDE[TLA#tla_api#plural](~/includes/tlasharptla-apisharpplural-md.md)] on the <xref:System.Windows.Input.Mouse> class rather than those on <xref:System.Windows.ContentElement>.</span></span>  
  
<a name="routedEventInfo_PreviewMouseRightButtonUp"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="f4180-2270">路由事件信息</span><span class="sxs-lookup"><span data-stu-id="f4180-2270">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="f4180-2271">标识符字段</span><span class="sxs-lookup"><span data-stu-id="f4180-2271">Identifier field</span></span>|<xref:System.Windows.ContentElement.PreviewMouseRightButtonUpEvent>|  
|<span data-ttu-id="f4180-2272">路由策略</span><span class="sxs-lookup"><span data-stu-id="f4180-2272">Routing strategy</span></span>|<span data-ttu-id="f4180-2273">直接</span><span class="sxs-lookup"><span data-stu-id="f4180-2273">Direct</span></span>|  
|<span data-ttu-id="f4180-2274">委托</span><span class="sxs-lookup"><span data-stu-id="f4180-2274">Delegate</span></span>|<xref:System.Windows.Input.MouseButtonEventHandler>|  
  
-   <span data-ttu-id="f4180-2275">重写<xref:System.Windows.ContentElement.OnPreviewMouseRightButtonUp%2A>实现类处理此事件在派生类中。</span><span class="sxs-lookup"><span data-stu-id="f4180-2275">Override <xref:System.Windows.ContentElement.OnPreviewMouseRightButtonUp%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.MouseRightButtonUp" />
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseRightButtonUpEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewMouseRightButtonUpEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewMouseRightButtonUpEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewMouseRightButtonUpEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewMouseRightButtonUpEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewMouseRightButtonUpEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewMouseRightButtonUpEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.PreviewMouseRightButtonUpEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f4180-2276">标识 <see cref="E:System.Windows.ContentElement.PreviewMouseRightButtonUp" /> 路由事件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-2276">Identifies the <see cref="E:System.Windows.ContentElement.PreviewMouseRightButtonUp" /> routed event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4180-2277">在注册路由事件时创建路由事件标识符。</span><span class="sxs-lookup"><span data-stu-id="f4180-2277">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="f4180-2278">这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。</span><span class="sxs-lookup"><span data-stu-id="f4180-2278">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="f4180-2279">可以使用这些标识符添加类处理程序。</span><span class="sxs-lookup"><span data-stu-id="f4180-2279">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="f4180-2280">有关注册路由事件的更多信息，请参见 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="f4180-2280">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="f4180-2281">有关使用路由事件标识符添加类处理程序的更多信息，请参见 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="f4180-2281">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseUp">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseButtonEventHandler PreviewMouseUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseButtonEventHandler PreviewMouseUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewMouseUp" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewMouseUp As MouseButtonEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Input::MouseButtonEventHandler ^ PreviewMouseUp;" />
      <MemberSignature Language="F#" Value="member this.PreviewMouseUp : System.Windows.Input.MouseButtonEventHandler " Usage="member this.PreviewMouseUp : System.Windows.Input.MouseButtonEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f4180-2282">在鼠标指针位于此元素上并且松开任意鼠标按钮时发生。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-2282">Occurs when any mouse button is released while the mouse pointer is over this element.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4180-2283">此事件创建一个别名<xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType>附加事件对于此类，以便<xref:System.Windows.ContentElement.PreviewMouseUp>属于类的成员列出时<xref:System.Windows.ContentElement>作为基元素继承。</span><span class="sxs-lookup"><span data-stu-id="f4180-2283">This event creates an alias for the <xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.PreviewMouseUp> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="f4180-2284">事件处理程序附加到<xref:System.Windows.ContentElement.PreviewMouseUp>事件附加到基础<xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType>附加事件，并接收相同的事件数据实例。</span><span class="sxs-lookup"><span data-stu-id="f4180-2284">Event handlers that are attached to the <xref:System.Windows.ContentElement.PreviewMouseUp> event are attached to the underlying <xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
 <span data-ttu-id="f4180-2285"><xref:System.Windows.ContentElement.PreviewMouseUp>任意一个协同通常引发事件<xref:System.Windows.ContentElement.PreviewMouseLeftButtonUp>或<xref:System.Windows.ContentElement.PreviewMouseRightButtonUp>，对应于一个两个标准鼠标按钮按下。</span><span class="sxs-lookup"><span data-stu-id="f4180-2285">The <xref:System.Windows.ContentElement.PreviewMouseUp> event is often raised together with either <xref:System.Windows.ContentElement.PreviewMouseLeftButtonUp> or <xref:System.Windows.ContentElement.PreviewMouseRightButtonUp>, which correspond to a press of one of the two standard mouse buttons.</span></span> <span data-ttu-id="f4180-2286"><xref:System.Windows.ContentElement.PreviewMouseLeftButtonUp> 并<xref:System.Windows.ContentElement.PreviewMouseRightButtonUp>也是路由的事件，但它们是直接路由的事件，并引发相应的特定于按钮的事件时<xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType>事件到达事件路由中的此元素。</span><span class="sxs-lookup"><span data-stu-id="f4180-2286"><xref:System.Windows.ContentElement.PreviewMouseLeftButtonUp> and <xref:System.Windows.ContentElement.PreviewMouseRightButtonUp> are also routed events, but they are direct routed events, and the appropriate button-specific event is raised when the <xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType> event reaches this element along the event route.</span></span> <span data-ttu-id="f4180-2287">请参阅备注<xref:System.Windows.ContentElement.PreviewMouseLeftButtonUp>或<xref:System.Windows.ContentElement.PreviewMouseRightButtonUp>。</span><span class="sxs-lookup"><span data-stu-id="f4180-2287">See Remarks for <xref:System.Windows.ContentElement.PreviewMouseLeftButtonUp> or <xref:System.Windows.ContentElement.PreviewMouseRightButtonUp>.</span></span>  
  
<a name="routedEventInfo_PreviewMouseUp"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="f4180-2288">路由事件信息</span><span class="sxs-lookup"><span data-stu-id="f4180-2288">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="f4180-2289">标识符字段</span><span class="sxs-lookup"><span data-stu-id="f4180-2289">Identifier field</span></span>|<xref:System.Windows.ContentElement.PreviewMouseUpEvent>|  
|<span data-ttu-id="f4180-2290">路由策略</span><span class="sxs-lookup"><span data-stu-id="f4180-2290">Routing strategy</span></span>|<span data-ttu-id="f4180-2291">隧道</span><span class="sxs-lookup"><span data-stu-id="f4180-2291">Tunneling</span></span>|  
|<span data-ttu-id="f4180-2292">委托</span><span class="sxs-lookup"><span data-stu-id="f4180-2292">Delegate</span></span>|<xref:System.Windows.Input.MouseButtonEventHandler>|  
  
-   <span data-ttu-id="f4180-2293">相应的浮升事件是<xref:System.Windows.ContentElement.MouseUp>。</span><span class="sxs-lookup"><span data-stu-id="f4180-2293">The corresponding bubbling event is <xref:System.Windows.ContentElement.MouseUp>.</span></span>  
  
-   <span data-ttu-id="f4180-2294">重写<xref:System.Windows.ContentElement.OnPreviewMouseUp%2A>实现类处理此事件在派生类中。</span><span class="sxs-lookup"><span data-stu-id="f4180-2294">Override <xref:System.Windows.ContentElement.OnPreviewMouseUp%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseUpEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewMouseUpEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewMouseUpEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewMouseUpEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewMouseUpEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewMouseUpEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewMouseUpEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.PreviewMouseUpEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f4180-2295">标识 <see cref="E:System.Windows.ContentElement.PreviewMouseUp" /> 路由事件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-2295">Identifies the <see cref="E:System.Windows.ContentElement.PreviewMouseUp" /> routed event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4180-2296">在注册路由事件时创建路由事件标识符。</span><span class="sxs-lookup"><span data-stu-id="f4180-2296">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="f4180-2297">这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。</span><span class="sxs-lookup"><span data-stu-id="f4180-2297">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="f4180-2298">可以使用这些标识符添加类处理程序。</span><span class="sxs-lookup"><span data-stu-id="f4180-2298">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="f4180-2299">有关注册路由事件的更多信息，请参见 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="f4180-2299">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="f4180-2300">有关使用路由事件标识符添加类处理程序的更多信息，请参见 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="f4180-2300">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseWheel">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseWheelEventHandler PreviewMouseWheel;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseWheelEventHandler PreviewMouseWheel" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewMouseWheel" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewMouseWheel As MouseWheelEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::MouseWheelEventHandler ^ PreviewMouseWheel;" />
      <MemberSignature Language="F#" Value="member this.PreviewMouseWheel : System.Windows.Input.MouseWheelEventHandler " Usage="member this.PreviewMouseWheel : System.Windows.Input.MouseWheelEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewMouseWheel</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseWheelEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f4180-2301">在鼠标指针位于此元素上并且用户滚动鼠标滚轮时发生。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-2301">Occurs when the user rotates the mouse wheel while the mouse pointer is over this element.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4180-2302">焦点或鼠标捕获优先于在鼠标指针位于其中;因此，如果您收到此事件的已设定焦点或捕获的元素，将鼠标指针实际上可能是另一个元素上。</span><span class="sxs-lookup"><span data-stu-id="f4180-2302">Focus or mouse capture take precedence over where the mouse pointer is; therefore, if you receive this event from a focused or captured element, the mouse pointer might actually be over another element.</span></span>  
  
 <span data-ttu-id="f4180-2303">此事件创建一个别名<xref:System.Windows.Input.Mouse.PreviewMouseWheel?displayProperty=nameWithType>附加事件对于此类，以便<xref:System.Windows.ContentElement.PreviewMouseMove>属于类的成员列出时<xref:System.Windows.ContentElement>作为基元素继承。</span><span class="sxs-lookup"><span data-stu-id="f4180-2303">This event creates an alias for the <xref:System.Windows.Input.Mouse.PreviewMouseWheel?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.PreviewMouseMove> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="f4180-2304">事件处理程序附加到<xref:System.Windows.ContentElement.PreviewMouseMove>事件附加到基础<xref:System.Windows.Input.Mouse.PreviewMouseWheel?displayProperty=nameWithType>附加事件，并接收相同的事件数据实例。</span><span class="sxs-lookup"><span data-stu-id="f4180-2304">Event handlers that are attached to the <xref:System.Windows.ContentElement.PreviewMouseMove> event are attached to the underlying <xref:System.Windows.Input.Mouse.PreviewMouseWheel?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
<a name="routedEventInfo_PreviewMouseWheel"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="f4180-2305">路由事件信息</span><span class="sxs-lookup"><span data-stu-id="f4180-2305">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="f4180-2306">标识符字段</span><span class="sxs-lookup"><span data-stu-id="f4180-2306">Identifier field</span></span>|<xref:System.Windows.ContentElement.PreviewMouseWheelEvent>|  
|<span data-ttu-id="f4180-2307">路由策略</span><span class="sxs-lookup"><span data-stu-id="f4180-2307">Routing strategy</span></span>|<span data-ttu-id="f4180-2308">隧道</span><span class="sxs-lookup"><span data-stu-id="f4180-2308">Tunneling</span></span>|  
|<span data-ttu-id="f4180-2309">委托</span><span class="sxs-lookup"><span data-stu-id="f4180-2309">Delegate</span></span>|<xref:System.Windows.Input.MouseWheelEventHandler>|  
  
-   <span data-ttu-id="f4180-2310">相应的浮升事件是<xref:System.Windows.ContentElement.MouseWheel>。</span><span class="sxs-lookup"><span data-stu-id="f4180-2310">The corresponding bubbling event is <xref:System.Windows.ContentElement.MouseWheel>.</span></span>  
  
-   <span data-ttu-id="f4180-2311">重写<xref:System.Windows.ContentElement.OnPreviewMouseWheel%2A>实现类处理此事件在派生类中。</span><span class="sxs-lookup"><span data-stu-id="f4180-2311">Override <xref:System.Windows.ContentElement.OnPreviewMouseWheel%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseWheelEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewMouseWheelEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewMouseWheelEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewMouseWheelEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewMouseWheelEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewMouseWheelEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewMouseWheelEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.PreviewMouseWheelEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f4180-2312">标识 <see cref="E:System.Windows.ContentElement.PreviewMouseWheel" /> 路由事件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-2312">Identifies the <see cref="E:System.Windows.ContentElement.PreviewMouseWheel" /> routed event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4180-2313">在注册路由事件时创建路由事件标识符。</span><span class="sxs-lookup"><span data-stu-id="f4180-2313">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="f4180-2314">这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。</span><span class="sxs-lookup"><span data-stu-id="f4180-2314">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="f4180-2315">可以使用这些标识符添加类处理程序。</span><span class="sxs-lookup"><span data-stu-id="f4180-2315">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="f4180-2316">有关注册路由事件的更多信息，请参见 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="f4180-2316">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="f4180-2317">有关使用路由事件标识符添加类处理程序的更多信息，请参见 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="f4180-2317">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewQueryContinueDrag">
      <MemberSignature Language="C#" Value="public event System.Windows.QueryContinueDragEventHandler PreviewQueryContinueDrag;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.QueryContinueDragEventHandler PreviewQueryContinueDrag" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewQueryContinueDrag" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewQueryContinueDrag As QueryContinueDragEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::QueryContinueDragEventHandler ^ PreviewQueryContinueDrag;" />
      <MemberSignature Language="F#" Value="member this.PreviewQueryContinueDrag : System.Windows.QueryContinueDragEventHandler " Usage="member this.PreviewQueryContinueDrag : System.Windows.QueryContinueDragEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.QueryContinueDragEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f4180-2318">在拖放操作期间键盘或鼠标按钮的状态改变时发生。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-2318">Occurs when there is a change in the keyboard or mouse button state during a drag-and-drop operation.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4180-2319"><xref:System.Windows.ContentElement.PreviewQueryContinueDrag>事件允许拖动源来声明是否应取消拖放操作。</span><span class="sxs-lookup"><span data-stu-id="f4180-2319">The <xref:System.Windows.ContentElement.PreviewQueryContinueDrag> event enables the drag source to declare whether the drag-and-drop operation should be canceled.</span></span>  
  
 <span data-ttu-id="f4180-2320">此事件创建一个别名<xref:System.Windows.DragDrop.PreviewQueryContinueDrag?displayProperty=nameWithType>附加事件对于此类，以便<xref:System.Windows.ContentElement.PreviewQueryContinueDrag>属于类的成员列出时<xref:System.Windows.ContentElement>作为基元素继承。</span><span class="sxs-lookup"><span data-stu-id="f4180-2320">This event creates an alias for the <xref:System.Windows.DragDrop.PreviewQueryContinueDrag?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.PreviewQueryContinueDrag> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="f4180-2321">事件处理程序附加到<xref:System.Windows.ContentElement.PreviewQueryContinueDrag>事件附加到基础<xref:System.Windows.DragDrop.PreviewQueryContinueDrag?displayProperty=nameWithType>附加事件，并接收相同的事件数据实例。</span><span class="sxs-lookup"><span data-stu-id="f4180-2321">Event handlers that are attached to the <xref:System.Windows.ContentElement.PreviewQueryContinueDrag> event are attached to the underlying <xref:System.Windows.DragDrop.PreviewQueryContinueDrag?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
<a name="routedEventInfo_PreviewQueryContinueDrag"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="f4180-2322">路由事件信息</span><span class="sxs-lookup"><span data-stu-id="f4180-2322">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="f4180-2323">标识符字段</span><span class="sxs-lookup"><span data-stu-id="f4180-2323">Identifier field</span></span>|<xref:System.Windows.ContentElement.PreviewQueryContinueDragEvent>|  
|<span data-ttu-id="f4180-2324">路由策略</span><span class="sxs-lookup"><span data-stu-id="f4180-2324">Routing strategy</span></span>|<span data-ttu-id="f4180-2325">隧道</span><span class="sxs-lookup"><span data-stu-id="f4180-2325">Tunneling</span></span>|  
|<span data-ttu-id="f4180-2326">委托</span><span class="sxs-lookup"><span data-stu-id="f4180-2326">Delegate</span></span>|<xref:System.Windows.QueryContinueDragEventHandler>|  
  
-   <span data-ttu-id="f4180-2327">相应的浮升事件是<xref:System.Windows.ContentElement.QueryContinueDrag>。</span><span class="sxs-lookup"><span data-stu-id="f4180-2327">The corresponding bubbling event is <xref:System.Windows.ContentElement.QueryContinueDrag>.</span></span>  
  
-   <span data-ttu-id="f4180-2328">重写<xref:System.Windows.ContentElement.OnPreviewQueryContinueDrag%2A>实现类处理此事件在派生类中。</span><span class="sxs-lookup"><span data-stu-id="f4180-2328">Override <xref:System.Windows.ContentElement.OnPreviewQueryContinueDrag%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewQueryContinueDragEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewQueryContinueDragEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewQueryContinueDragEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewQueryContinueDragEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewQueryContinueDragEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewQueryContinueDragEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewQueryContinueDragEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.PreviewQueryContinueDragEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f4180-2329">标识 <see cref="E:System.Windows.ContentElement.PreviewQueryContinueDrag" /> 路由事件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-2329">Identifies the <see cref="E:System.Windows.ContentElement.PreviewQueryContinueDrag" /> routed event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4180-2330">在注册路由事件时创建路由事件标识符。</span><span class="sxs-lookup"><span data-stu-id="f4180-2330">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="f4180-2331">这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。</span><span class="sxs-lookup"><span data-stu-id="f4180-2331">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="f4180-2332">可以使用这些标识符添加类处理程序。</span><span class="sxs-lookup"><span data-stu-id="f4180-2332">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="f4180-2333">有关注册路由事件的更多信息，请参见 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="f4180-2333">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="f4180-2334">有关使用路由事件标识符添加类处理程序的更多信息，请参见 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="f4180-2334">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusButtonDown">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusButtonEventHandler PreviewStylusButtonDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusButtonEventHandler PreviewStylusButtonDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewStylusButtonDown" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewStylusButtonDown As StylusButtonEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusButtonEventHandler ^ PreviewStylusButtonDown;" />
      <MemberSignature Language="F#" Value="member this.PreviewStylusButtonDown : System.Windows.Input.StylusButtonEventHandler " Usage="member this.PreviewStylusButtonDown : System.Windows.Input.StylusButtonEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewStylusButtonDown</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f4180-2335">在指针位于此元素上并且按下触笔按钮时发生。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-2335">Occurs when the stylus button is pressed while the pointer is over this element.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4180-2336">此事件创建一个别名<xref:System.Windows.Input.Stylus.PreviewStylusButtonDown?displayProperty=nameWithType>附加事件对于此类，以便<xref:System.Windows.ContentElement.PreviewStylusButtonDown>属于类的成员列出时<xref:System.Windows.ContentElement>作为基元素继承。</span><span class="sxs-lookup"><span data-stu-id="f4180-2336">This event creates an alias for the <xref:System.Windows.Input.Stylus.PreviewStylusButtonDown?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.PreviewStylusButtonDown> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="f4180-2337">事件处理程序附加到<xref:System.Windows.ContentElement.PreviewStylusButtonDown>事件附加到基础<xref:System.Windows.Input.Stylus.PreviewStylusButtonDown?displayProperty=nameWithType>附加事件，并接收相同的事件数据实例。</span><span class="sxs-lookup"><span data-stu-id="f4180-2337">Event handlers that are attached to the <xref:System.Windows.ContentElement.PreviewStylusButtonDown> event are attached to the underlying <xref:System.Windows.Input.Stylus.PreviewStylusButtonDown?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
 <span data-ttu-id="f4180-2338">触摸、 鼠标和触笔输入中的特定关系存在。</span><span class="sxs-lookup"><span data-stu-id="f4180-2338">Touch, mouse, and stylus input exist in a particular relationship.</span></span> <span data-ttu-id="f4180-2339">有关详细信息，请参阅[输入概述](~/docs/framework/wpf/advanced/input-overview.md)。</span><span class="sxs-lookup"><span data-stu-id="f4180-2339">For more information, see [Input Overview](~/docs/framework/wpf/advanced/input-overview.md).</span></span>  
  
<a name="routedEventInfo_PreviewStylusButtonDown"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="f4180-2340">路由事件信息</span><span class="sxs-lookup"><span data-stu-id="f4180-2340">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="f4180-2341">标识符字段</span><span class="sxs-lookup"><span data-stu-id="f4180-2341">Identifier field</span></span>|<xref:System.Windows.ContentElement.PreviewStylusButtonDownEvent>|  
|<span data-ttu-id="f4180-2342">路由策略</span><span class="sxs-lookup"><span data-stu-id="f4180-2342">Routing strategy</span></span>|<span data-ttu-id="f4180-2343">隧道</span><span class="sxs-lookup"><span data-stu-id="f4180-2343">Tunneling</span></span>|  
|<span data-ttu-id="f4180-2344">委托</span><span class="sxs-lookup"><span data-stu-id="f4180-2344">Delegate</span></span>|<xref:System.Windows.Input.StylusButtonEventHandler>|  
  
-   <span data-ttu-id="f4180-2345">相应的浮升事件是<xref:System.Windows.ContentElement.StylusButtonDown>。</span><span class="sxs-lookup"><span data-stu-id="f4180-2345">The corresponding bubbling event is <xref:System.Windows.ContentElement.StylusButtonDown>.</span></span>  
  
-   <span data-ttu-id="f4180-2346">重写<xref:System.Windows.ContentElement.OnPreviewStylusButtonDown%2A>实现类处理此事件在派生类中。</span><span class="sxs-lookup"><span data-stu-id="f4180-2346">Override <xref:System.Windows.ContentElement.OnPreviewStylusButtonDown%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.StylusButtonDown" />
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusButtonDownEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewStylusButtonDownEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewStylusButtonDownEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewStylusButtonDownEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewStylusButtonDownEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewStylusButtonDownEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewStylusButtonDownEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.PreviewStylusButtonDownEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f4180-2347">标识 <see cref="E:System.Windows.ContentElement.PreviewStylusButtonDown" /> 路由事件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-2347">Identifies the <see cref="E:System.Windows.ContentElement.PreviewStylusButtonDown" /> routed event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4180-2348">在注册路由事件时创建路由事件标识符。</span><span class="sxs-lookup"><span data-stu-id="f4180-2348">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="f4180-2349">这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。</span><span class="sxs-lookup"><span data-stu-id="f4180-2349">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="f4180-2350">可以使用这些标识符添加类处理程序。</span><span class="sxs-lookup"><span data-stu-id="f4180-2350">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="f4180-2351">有关注册路由事件的更多信息，请参见 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="f4180-2351">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="f4180-2352">有关使用路由事件标识符添加类处理程序的更多信息，请参见 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="f4180-2352">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusButtonUp">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusButtonEventHandler PreviewStylusButtonUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusButtonEventHandler PreviewStylusButtonUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewStylusButtonUp" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewStylusButtonUp As StylusButtonEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusButtonEventHandler ^ PreviewStylusButtonUp;" />
      <MemberSignature Language="F#" Value="member this.PreviewStylusButtonUp : System.Windows.Input.StylusButtonEventHandler " Usage="member this.PreviewStylusButtonUp : System.Windows.Input.StylusButtonEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewStylusButtonUp</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f4180-2353">在指针位于此元素上并且松开触笔按钮时发生。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-2353">Occurs when the stylus button is released while the pointer is over this element.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4180-2354">此事件创建一个别名<xref:System.Windows.Input.Stylus.PreviewStylusButtonUp?displayProperty=nameWithType>附加事件对于此类，以便<xref:System.Windows.ContentElement.PreviewStylusButtonUp>属于类的成员列出时<xref:System.Windows.ContentElement>作为基元素继承。</span><span class="sxs-lookup"><span data-stu-id="f4180-2354">This event creates an alias for the <xref:System.Windows.Input.Stylus.PreviewStylusButtonUp?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.PreviewStylusButtonUp> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="f4180-2355">事件处理程序附加到<xref:System.Windows.ContentElement.PreviewStylusButtonUp>事件附加到基础<xref:System.Windows.Input.Stylus.PreviewStylusButtonUp?displayProperty=nameWithType>附加事件，并接收相同的事件数据实例。</span><span class="sxs-lookup"><span data-stu-id="f4180-2355">Event handlers that are attached to the <xref:System.Windows.ContentElement.PreviewStylusButtonUp> event are attached to the underlying <xref:System.Windows.Input.Stylus.PreviewStylusButtonUp?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
 <span data-ttu-id="f4180-2356">触摸、 鼠标和触笔输入中的特定关系存在。</span><span class="sxs-lookup"><span data-stu-id="f4180-2356">Touch, mouse, and stylus input exist in a particular relationship.</span></span> <span data-ttu-id="f4180-2357">有关详细信息，请参阅[输入概述](~/docs/framework/wpf/advanced/input-overview.md)。</span><span class="sxs-lookup"><span data-stu-id="f4180-2357">For more information, see [Input Overview](~/docs/framework/wpf/advanced/input-overview.md).</span></span>  
  
<a name="routedEventInfo_PreviewStylusButtonUp"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="f4180-2358">路由事件信息</span><span class="sxs-lookup"><span data-stu-id="f4180-2358">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="f4180-2359">标识符字段</span><span class="sxs-lookup"><span data-stu-id="f4180-2359">Identifier field</span></span>|<xref:System.Windows.ContentElement.PreviewStylusButtonUpEvent>|  
|<span data-ttu-id="f4180-2360">路由策略</span><span class="sxs-lookup"><span data-stu-id="f4180-2360">Routing strategy</span></span>|<span data-ttu-id="f4180-2361">隧道</span><span class="sxs-lookup"><span data-stu-id="f4180-2361">Tunneling</span></span>|  
|<span data-ttu-id="f4180-2362">委托</span><span class="sxs-lookup"><span data-stu-id="f4180-2362">Delegate</span></span>|<xref:System.Windows.Input.StylusButtonEventHandler>|  
  
-   <span data-ttu-id="f4180-2363">相应的浮升事件是<xref:System.Windows.ContentElement.StylusButtonUp>。</span><span class="sxs-lookup"><span data-stu-id="f4180-2363">The corresponding bubbling event is <xref:System.Windows.ContentElement.StylusButtonUp>.</span></span>  
  
-   <span data-ttu-id="f4180-2364">重写<xref:System.Windows.ContentElement.OnPreviewStylusButtonUp%2A>实现类处理此事件在派生类中。</span><span class="sxs-lookup"><span data-stu-id="f4180-2364">Override <xref:System.Windows.ContentElement.OnPreviewStylusButtonUp%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusButtonUpEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewStylusButtonUpEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewStylusButtonUpEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewStylusButtonUpEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewStylusButtonUpEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewStylusButtonUpEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewStylusButtonUpEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.PreviewStylusButtonUpEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f4180-2365">标识 <see cref="E:System.Windows.ContentElement.PreviewStylusButtonUp" /> 路由事件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-2365">Identifies the <see cref="E:System.Windows.ContentElement.PreviewStylusButtonUp" /> routed event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4180-2366">在注册路由事件时创建路由事件标识符。</span><span class="sxs-lookup"><span data-stu-id="f4180-2366">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="f4180-2367">这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。</span><span class="sxs-lookup"><span data-stu-id="f4180-2367">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="f4180-2368">可以使用这些标识符添加类处理程序。</span><span class="sxs-lookup"><span data-stu-id="f4180-2368">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="f4180-2369">有关注册路由事件的更多信息，请参见 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="f4180-2369">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="f4180-2370">有关使用路由事件标识符添加类处理程序的更多信息，请参见 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="f4180-2370">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusDown">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusDownEventHandler PreviewStylusDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusDownEventHandler PreviewStylusDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewStylusDown" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewStylusDown As StylusDownEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusDownEventHandler ^ PreviewStylusDown;" />
      <MemberSignature Language="F#" Value="member this.PreviewStylusDown : System.Windows.Input.StylusDownEventHandler " Usage="member this.PreviewStylusDown : System.Windows.Input.StylusDownEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewStylusDown</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusDownEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f4180-2371">当触笔位于元素上且触及数字化器时发生。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-2371">Occurs when the stylus touches the digitizer while it is over this element.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4180-2372">此事件创建一个别名<xref:System.Windows.Input.Stylus.PreviewStylusDown?displayProperty=nameWithType>附加事件对于此类，以便<xref:System.Windows.ContentElement.PreviewStylusDown>属于类的成员列出时<xref:System.Windows.ContentElement>作为基元素继承。</span><span class="sxs-lookup"><span data-stu-id="f4180-2372">This event creates an alias for the <xref:System.Windows.Input.Stylus.PreviewStylusDown?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.PreviewStylusDown> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="f4180-2373">事件处理程序附加到<xref:System.Windows.ContentElement.PreviewStylusDown>事件附加到基础<xref:System.Windows.Input.Stylus.PreviewStylusDown?displayProperty=nameWithType>附加事件，并接收相同的事件数据实例。</span><span class="sxs-lookup"><span data-stu-id="f4180-2373">Event handlers that are attached to the <xref:System.Windows.ContentElement.PreviewStylusDown> event are attached to the underlying <xref:System.Windows.Input.Stylus.PreviewStylusDown?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
 <span data-ttu-id="f4180-2374">触摸、 鼠标和触笔输入中的特定关系存在。</span><span class="sxs-lookup"><span data-stu-id="f4180-2374">Touch, mouse, and stylus input exist in a particular relationship.</span></span> <span data-ttu-id="f4180-2375">有关详细信息，请参阅[输入概述](~/docs/framework/wpf/advanced/input-overview.md)。</span><span class="sxs-lookup"><span data-stu-id="f4180-2375">For more information, see [Input Overview](~/docs/framework/wpf/advanced/input-overview.md).</span></span>  
  
<a name="routedEventInfo_PreviewStylusDown"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="f4180-2376">路由事件信息</span><span class="sxs-lookup"><span data-stu-id="f4180-2376">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="f4180-2377">标识符字段</span><span class="sxs-lookup"><span data-stu-id="f4180-2377">Identifier field</span></span>|<xref:System.Windows.ContentElement.PreviewStylusDownEvent>|  
|<span data-ttu-id="f4180-2378">路由策略</span><span class="sxs-lookup"><span data-stu-id="f4180-2378">Routing strategy</span></span>|<span data-ttu-id="f4180-2379">隧道</span><span class="sxs-lookup"><span data-stu-id="f4180-2379">Tunneling</span></span>|  
|<span data-ttu-id="f4180-2380">委托</span><span class="sxs-lookup"><span data-stu-id="f4180-2380">Delegate</span></span>|<xref:System.Windows.Input.StylusDownEventHandler>|  
  
-   <span data-ttu-id="f4180-2381">相应的浮升事件是<xref:System.Windows.ContentElement.StylusDown>。</span><span class="sxs-lookup"><span data-stu-id="f4180-2381">The corresponding bubbling event is <xref:System.Windows.ContentElement.StylusDown>.</span></span>  
  
-   <span data-ttu-id="f4180-2382">重写<xref:System.Windows.ContentElement.OnPreviewStylusDown%2A>实现类处理此事件在派生类中。</span><span class="sxs-lookup"><span data-stu-id="f4180-2382">Override <xref:System.Windows.ContentElement.OnPreviewStylusDown%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusDownEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewStylusDownEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewStylusDownEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewStylusDownEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewStylusDownEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewStylusDownEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewStylusDownEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.PreviewStylusDownEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f4180-2383">标识 <see cref="E:System.Windows.ContentElement.PreviewStylusDown" /> 路由事件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-2383">Identifies the <see cref="E:System.Windows.ContentElement.PreviewStylusDown" /> routed event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4180-2384">在注册路由事件时创建路由事件标识符。</span><span class="sxs-lookup"><span data-stu-id="f4180-2384">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="f4180-2385">这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。</span><span class="sxs-lookup"><span data-stu-id="f4180-2385">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="f4180-2386">可以使用这些标识符添加类处理程序。</span><span class="sxs-lookup"><span data-stu-id="f4180-2386">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="f4180-2387">有关注册路由事件的更多信息，请参见 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="f4180-2387">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="f4180-2388">有关使用路由事件标识符添加类处理程序的更多信息，请参见 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="f4180-2388">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusInAirMove">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusEventHandler PreviewStylusInAirMove;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusEventHandler PreviewStylusInAirMove" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewStylusInAirMove" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewStylusInAirMove As StylusEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusEventHandler ^ PreviewStylusInAirMove;" />
      <MemberSignature Language="F#" Value="member this.PreviewStylusInAirMove : System.Windows.Input.StylusEventHandler " Usage="member this.PreviewStylusInAirMove : System.Windows.Input.StylusEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewStylusInAirMove</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f4180-2389">在触笔掠过元素但并未实际接触数字化器时发生。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-2389">Occurs when the stylus moves over an element without actually touching the digitizer.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4180-2390">此事件创建一个别名<xref:System.Windows.Input.Stylus.PreviewStylusInAirMove?displayProperty=nameWithType>附加事件对于此类，以便<xref:System.Windows.ContentElement.PreviewStylusInAirMove>属于类的成员列出时<xref:System.Windows.ContentElement>作为基元素继承。</span><span class="sxs-lookup"><span data-stu-id="f4180-2390">This event creates an alias for the <xref:System.Windows.Input.Stylus.PreviewStylusInAirMove?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.PreviewStylusInAirMove> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="f4180-2391">事件处理程序附加到<xref:System.Windows.ContentElement.PreviewStylusInAirMove>事件附加到基础<xref:System.Windows.Input.Stylus.PreviewStylusInAirMove?displayProperty=nameWithType>附加事件，并接收相同的事件数据实例。</span><span class="sxs-lookup"><span data-stu-id="f4180-2391">Event handlers that are attached to the <xref:System.Windows.ContentElement.PreviewStylusInAirMove> event are attached to the underlying <xref:System.Windows.Input.Stylus.PreviewStylusInAirMove?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
 <span data-ttu-id="f4180-2392">触摸、 鼠标和触笔输入中的特定关系存在。</span><span class="sxs-lookup"><span data-stu-id="f4180-2392">Touch, mouse, and stylus input exist in a particular relationship.</span></span> <span data-ttu-id="f4180-2393">有关详细信息，请参阅[输入概述](~/docs/framework/wpf/advanced/input-overview.md)。</span><span class="sxs-lookup"><span data-stu-id="f4180-2393">For more information, see [Input Overview](~/docs/framework/wpf/advanced/input-overview.md).</span></span>  
  
<a name="routedEventInfo_PreviewStylusInAirMove"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="f4180-2394">路由事件信息</span><span class="sxs-lookup"><span data-stu-id="f4180-2394">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="f4180-2395">标识符字段</span><span class="sxs-lookup"><span data-stu-id="f4180-2395">Identifier field</span></span>|<xref:System.Windows.ContentElement.PreviewStylusInAirMoveEvent>|  
|<span data-ttu-id="f4180-2396">路由策略</span><span class="sxs-lookup"><span data-stu-id="f4180-2396">Routing strategy</span></span>|<span data-ttu-id="f4180-2397">隧道</span><span class="sxs-lookup"><span data-stu-id="f4180-2397">Tunneling</span></span>|  
|<span data-ttu-id="f4180-2398">委托</span><span class="sxs-lookup"><span data-stu-id="f4180-2398">Delegate</span></span>|<xref:System.Windows.Input.StylusEventHandler>|  
  
-   <span data-ttu-id="f4180-2399">相应的浮升事件是<xref:System.Windows.ContentElement.StylusInAirMove>。</span><span class="sxs-lookup"><span data-stu-id="f4180-2399">The corresponding bubbling event is <xref:System.Windows.ContentElement.StylusInAirMove>.</span></span>  
  
-   <span data-ttu-id="f4180-2400">重写<xref:System.Windows.ContentElement.OnPreviewStylusInAirMove%2A>实现类处理此事件在派生类中。</span><span class="sxs-lookup"><span data-stu-id="f4180-2400">Override <xref:System.Windows.ContentElement.OnPreviewStylusInAirMove%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusInAirMoveEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewStylusInAirMoveEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewStylusInAirMoveEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewStylusInAirMoveEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewStylusInAirMoveEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewStylusInAirMoveEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewStylusInAirMoveEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.PreviewStylusInAirMoveEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f4180-2401">标识 <see cref="E:System.Windows.ContentElement.PreviewStylusInAirMove" /> 路由事件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-2401">Identifies the <see cref="E:System.Windows.ContentElement.PreviewStylusInAirMove" /> routed event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4180-2402">在注册路由事件时创建路由事件标识符。</span><span class="sxs-lookup"><span data-stu-id="f4180-2402">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="f4180-2403">这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。</span><span class="sxs-lookup"><span data-stu-id="f4180-2403">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="f4180-2404">可以使用这些标识符添加类处理程序。</span><span class="sxs-lookup"><span data-stu-id="f4180-2404">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="f4180-2405">有关注册路由事件的更多信息，请参见 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="f4180-2405">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="f4180-2406">有关使用路由事件标识符添加类处理程序的更多信息，请参见 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="f4180-2406">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusInRange">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusEventHandler PreviewStylusInRange;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusEventHandler PreviewStylusInRange" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewStylusInRange" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewStylusInRange As StylusEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusEventHandler ^ PreviewStylusInRange;" />
      <MemberSignature Language="F#" Value="member this.PreviewStylusInRange : System.Windows.Input.StylusEventHandler " Usage="member this.PreviewStylusInRange : System.Windows.Input.StylusEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewStylusInRange</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f4180-2407">在触笔位于此元素上并且触笔与数字化器之间的距离近到足以检测到触笔时发生。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-2407">Occurs when the stylus is close enough to the digitizer to be detected, while over this element.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4180-2408">此事件创建一个别名<xref:System.Windows.Input.Stylus.PreviewStylusInRange?displayProperty=nameWithType>附加事件对于此类，以便<xref:System.Windows.ContentElement.PreviewStylusInRange>属于类的成员列出时<xref:System.Windows.ContentElement>作为基元素继承。</span><span class="sxs-lookup"><span data-stu-id="f4180-2408">This event creates an alias for the <xref:System.Windows.Input.Stylus.PreviewStylusInRange?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.PreviewStylusInRange> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="f4180-2409">事件处理程序附加到<xref:System.Windows.ContentElement.PreviewStylusInRange>事件附加到基础<xref:System.Windows.Input.Stylus.PreviewStylusInRange?displayProperty=nameWithType>附加事件，并接收相同的事件数据实例。</span><span class="sxs-lookup"><span data-stu-id="f4180-2409">Event handlers that are attached to the <xref:System.Windows.ContentElement.PreviewStylusInRange> event are attached to the underlying <xref:System.Windows.Input.Stylus.PreviewStylusInRange?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
 <span data-ttu-id="f4180-2410">触摸、 鼠标和触笔输入中的特定关系存在。</span><span class="sxs-lookup"><span data-stu-id="f4180-2410">Touch, mouse, and stylus input exist in a particular relationship.</span></span> <span data-ttu-id="f4180-2411">有关详细信息，请参阅[输入概述](~/docs/framework/wpf/advanced/input-overview.md)。</span><span class="sxs-lookup"><span data-stu-id="f4180-2411">For more information, see [Input Overview](~/docs/framework/wpf/advanced/input-overview.md).</span></span>  
  
<a name="routedEventInfo_PreviewStylusInRange"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="f4180-2412">路由事件信息</span><span class="sxs-lookup"><span data-stu-id="f4180-2412">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="f4180-2413">标识符字段</span><span class="sxs-lookup"><span data-stu-id="f4180-2413">Identifier field</span></span>|<xref:System.Windows.ContentElement.PreviewStylusInRangeEvent>|  
|<span data-ttu-id="f4180-2414">路由策略</span><span class="sxs-lookup"><span data-stu-id="f4180-2414">Routing strategy</span></span>|<span data-ttu-id="f4180-2415">隧道</span><span class="sxs-lookup"><span data-stu-id="f4180-2415">Tunneling</span></span>|  
|<span data-ttu-id="f4180-2416">委托</span><span class="sxs-lookup"><span data-stu-id="f4180-2416">Delegate</span></span>|<xref:System.Windows.Input.StylusEventHandler>|  
  
-   <span data-ttu-id="f4180-2417">相应的浮升事件是<xref:System.Windows.ContentElement.StylusInRange>。</span><span class="sxs-lookup"><span data-stu-id="f4180-2417">The corresponding bubbling event is <xref:System.Windows.ContentElement.StylusInRange>.</span></span>  
  
-   <span data-ttu-id="f4180-2418">重写<xref:System.Windows.ContentElement.OnPreviewStylusInRange%2A>实现类处理此事件在派生类中。</span><span class="sxs-lookup"><span data-stu-id="f4180-2418">Override <xref:System.Windows.ContentElement.OnPreviewStylusInRange%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusInRangeEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewStylusInRangeEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewStylusInRangeEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewStylusInRangeEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewStylusInRangeEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewStylusInRangeEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewStylusInRangeEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.PreviewStylusInRangeEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f4180-2419">标识 <see cref="E:System.Windows.ContentElement.PreviewStylusInRange" /> 路由事件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-2419">Identifies the <see cref="E:System.Windows.ContentElement.PreviewStylusInRange" /> routed event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4180-2420">在注册路由事件时创建路由事件标识符。</span><span class="sxs-lookup"><span data-stu-id="f4180-2420">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="f4180-2421">这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。</span><span class="sxs-lookup"><span data-stu-id="f4180-2421">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="f4180-2422">可以使用这些标识符添加类处理程序。</span><span class="sxs-lookup"><span data-stu-id="f4180-2422">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="f4180-2423">有关注册路由事件的更多信息，请参见 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="f4180-2423">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="f4180-2424">有关使用路由事件标识符添加类处理程序的更多信息，请参见 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="f4180-2424">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusMove">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusEventHandler PreviewStylusMove;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusEventHandler PreviewStylusMove" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewStylusMove" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewStylusMove As StylusEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusEventHandler ^ PreviewStylusMove;" />
      <MemberSignature Language="F#" Value="member this.PreviewStylusMove : System.Windows.Input.StylusEventHandler " Usage="member this.PreviewStylusMove : System.Windows.Input.StylusEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewStylusMove</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f4180-2425">在触笔位于元素上并且移动触笔时发生。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-2425">Occurs when the stylus moves while over the element.</span>
          </span>
          <span data-ttu-id="f4180-2426">数字化器在检测触笔时，触笔必须处于移动状态才会引发此事件，否则将改为引发 <see cref="E:System.Windows.ContentElement.PreviewStylusInAirMove" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-2426">The stylus must move while being detected by the  digitizer  to raise this event, otherwise, <see cref="E:System.Windows.ContentElement.PreviewStylusInAirMove" /> is raised instead.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4180-2427">此事件创建一个别名<xref:System.Windows.Input.Stylus.PreviewStylusMove?displayProperty=nameWithType>附加事件对于此类，以便<xref:System.Windows.ContentElement.PreviewStylusMove>属于类的成员列出时<xref:System.Windows.ContentElement>作为基元素继承。</span><span class="sxs-lookup"><span data-stu-id="f4180-2427">This event creates an alias for the <xref:System.Windows.Input.Stylus.PreviewStylusMove?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.PreviewStylusMove> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="f4180-2428">事件处理程序附加到<xref:System.Windows.ContentElement.PreviewStylusMove>事件附加到基础<xref:System.Windows.Input.Stylus.PreviewStylusMove?displayProperty=nameWithType>附加事件，并接收相同的事件数据实例。</span><span class="sxs-lookup"><span data-stu-id="f4180-2428">Event handlers that are attached to the <xref:System.Windows.ContentElement.PreviewStylusMove> event are attached to the underlying <xref:System.Windows.Input.Stylus.PreviewStylusMove?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
 <span data-ttu-id="f4180-2429">触摸、 鼠标和触笔输入中的特定关系存在。</span><span class="sxs-lookup"><span data-stu-id="f4180-2429">Touch, mouse, and stylus input exist in a particular relationship.</span></span> <span data-ttu-id="f4180-2430">有关详细信息，请参阅[输入概述](~/docs/framework/wpf/advanced/input-overview.md)。</span><span class="sxs-lookup"><span data-stu-id="f4180-2430">For more information, see [Input Overview](~/docs/framework/wpf/advanced/input-overview.md).</span></span>  
  
<a name="routedEventInfo_PreviewStylusMove"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="f4180-2431">路由事件信息</span><span class="sxs-lookup"><span data-stu-id="f4180-2431">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="f4180-2432">标识符字段</span><span class="sxs-lookup"><span data-stu-id="f4180-2432">Identifier field</span></span>|<xref:System.Windows.ContentElement.PreviewStylusMoveEvent>|  
|<span data-ttu-id="f4180-2433">路由策略</span><span class="sxs-lookup"><span data-stu-id="f4180-2433">Routing strategy</span></span>|<span data-ttu-id="f4180-2434">隧道</span><span class="sxs-lookup"><span data-stu-id="f4180-2434">Tunneling</span></span>|  
|<span data-ttu-id="f4180-2435">委托</span><span class="sxs-lookup"><span data-stu-id="f4180-2435">Delegate</span></span>|<xref:System.Windows.Input.StylusEventHandler>|  
  
-   <span data-ttu-id="f4180-2436">相应的浮升事件是<xref:System.Windows.ContentElement.StylusMove>。</span><span class="sxs-lookup"><span data-stu-id="f4180-2436">The corresponding bubbling event is <xref:System.Windows.ContentElement.StylusMove>.</span></span>  
  
-   <span data-ttu-id="f4180-2437">重写<xref:System.Windows.ContentElement.OnPreviewStylusMove%2A>实现类处理此事件在派生类中。</span><span class="sxs-lookup"><span data-stu-id="f4180-2437">Override <xref:System.Windows.ContentElement.OnPreviewStylusMove%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusMoveEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewStylusMoveEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewStylusMoveEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewStylusMoveEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewStylusMoveEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewStylusMoveEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewStylusMoveEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.PreviewStylusMoveEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f4180-2438">标识 <see cref="E:System.Windows.ContentElement.PreviewStylusMove" /> 路由事件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-2438">Identifies the <see cref="E:System.Windows.ContentElement.PreviewStylusMove" /> routed event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4180-2439">在注册路由事件时创建路由事件标识符。</span><span class="sxs-lookup"><span data-stu-id="f4180-2439">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="f4180-2440">这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。</span><span class="sxs-lookup"><span data-stu-id="f4180-2440">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="f4180-2441">可以使用这些标识符添加类处理程序。</span><span class="sxs-lookup"><span data-stu-id="f4180-2441">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="f4180-2442">有关注册路由事件的更多信息，请参见 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="f4180-2442">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="f4180-2443">有关使用路由事件标识符添加类处理程序的更多信息，请参见 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="f4180-2443">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusOutOfRange">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusEventHandler PreviewStylusOutOfRange;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusEventHandler PreviewStylusOutOfRange" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewStylusOutOfRange" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewStylusOutOfRange As StylusEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusEventHandler ^ PreviewStylusOutOfRange;" />
      <MemberSignature Language="F#" Value="member this.PreviewStylusOutOfRange : System.Windows.Input.StylusEventHandler " Usage="member this.PreviewStylusOutOfRange : System.Windows.Input.StylusEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewStylusOutOfRange</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f4180-2444">在触笔与数字化仪之间的距离太远以致无法检测到触笔时发生。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-2444">Occurs when the stylus is too far from the digitizer to be detected.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4180-2445">此事件创建一个别名<xref:System.Windows.Input.Stylus.PreviewStylusOutOfRange?displayProperty=nameWithType>附加事件对于此类，以便<xref:System.Windows.ContentElement.PreviewStylusOutOfRange>属于类的成员列出时<xref:System.Windows.ContentElement>作为基元素继承。</span><span class="sxs-lookup"><span data-stu-id="f4180-2445">This event creates an alias for the <xref:System.Windows.Input.Stylus.PreviewStylusOutOfRange?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.PreviewStylusOutOfRange> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="f4180-2446">事件处理程序附加到<xref:System.Windows.ContentElement.PreviewStylusOutOfRange>事件附加到基础<xref:System.Windows.Input.Stylus.PreviewStylusOutOfRange?displayProperty=nameWithType>附加事件，并接收相同的事件数据实例。</span><span class="sxs-lookup"><span data-stu-id="f4180-2446">Event handlers that are attached to the <xref:System.Windows.ContentElement.PreviewStylusOutOfRange> event are attached to the underlying <xref:System.Windows.Input.Stylus.PreviewStylusOutOfRange?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
 <span data-ttu-id="f4180-2447">触摸、 鼠标和触笔输入中的特定关系存在。</span><span class="sxs-lookup"><span data-stu-id="f4180-2447">Touch, mouse, and stylus input exist in a particular relationship.</span></span> <span data-ttu-id="f4180-2448">有关详细信息，请参阅[输入概述](~/docs/framework/wpf/advanced/input-overview.md)。</span><span class="sxs-lookup"><span data-stu-id="f4180-2448">For more information, see [Input Overview](~/docs/framework/wpf/advanced/input-overview.md).</span></span>  
  
<a name="routedEventInfo_PreviewStylusOutOfRange"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="f4180-2449">路由事件信息</span><span class="sxs-lookup"><span data-stu-id="f4180-2449">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="f4180-2450">标识符字段</span><span class="sxs-lookup"><span data-stu-id="f4180-2450">Identifier field</span></span>|<xref:System.Windows.ContentElement.PreviewStylusOutOfRangeEvent>|  
|<span data-ttu-id="f4180-2451">路由策略</span><span class="sxs-lookup"><span data-stu-id="f4180-2451">Routing strategy</span></span>|<span data-ttu-id="f4180-2452">隧道</span><span class="sxs-lookup"><span data-stu-id="f4180-2452">Tunneling</span></span>|  
|<span data-ttu-id="f4180-2453">委托</span><span class="sxs-lookup"><span data-stu-id="f4180-2453">Delegate</span></span>|<xref:System.Windows.Input.StylusEventHandler>|  
  
-   <span data-ttu-id="f4180-2454">相应的浮升事件是<xref:System.Windows.ContentElement.StylusOutOfRange>。</span><span class="sxs-lookup"><span data-stu-id="f4180-2454">The corresponding bubbling event is <xref:System.Windows.ContentElement.StylusOutOfRange>.</span></span>  
  
-   <span data-ttu-id="f4180-2455">重写<xref:System.Windows.ContentElement.OnPreviewStylusOutOfRange%2A>实现类处理此事件在派生类中。</span><span class="sxs-lookup"><span data-stu-id="f4180-2455">Override <xref:System.Windows.ContentElement.OnPreviewStylusOutOfRange%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusOutOfRangeEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewStylusOutOfRangeEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewStylusOutOfRangeEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewStylusOutOfRangeEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewStylusOutOfRangeEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewStylusOutOfRangeEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewStylusOutOfRangeEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.PreviewStylusOutOfRangeEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f4180-2456">标识 <see cref="E:System.Windows.ContentElement.PreviewStylusOutOfRange" /> 路由事件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-2456">Identifies the <see cref="E:System.Windows.ContentElement.PreviewStylusOutOfRange" /> routed event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4180-2457">在注册路由事件时创建路由事件标识符。</span><span class="sxs-lookup"><span data-stu-id="f4180-2457">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="f4180-2458">这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。</span><span class="sxs-lookup"><span data-stu-id="f4180-2458">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="f4180-2459">可以使用这些标识符添加类处理程序。</span><span class="sxs-lookup"><span data-stu-id="f4180-2459">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="f4180-2460">有关注册路由事件的更多信息，请参见 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="f4180-2460">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="f4180-2461">有关使用路由事件标识符添加类处理程序的更多信息，请参见 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="f4180-2461">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusSystemGesture">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusSystemGestureEventHandler PreviewStylusSystemGesture;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusSystemGestureEventHandler PreviewStylusSystemGesture" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewStylusSystemGesture" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewStylusSystemGesture As StylusSystemGestureEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusSystemGestureEventHandler ^ PreviewStylusSystemGesture;" />
      <MemberSignature Language="F#" Value="member this.PreviewStylusSystemGesture : System.Windows.Input.StylusSystemGestureEventHandler " Usage="member this.PreviewStylusSystemGesture : System.Windows.Input.StylusSystemGestureEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewStylusSystemGesture</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusSystemGestureEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f4180-2462">在用户采用某一种触笔笔势时发生。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-2462">Occurs when a user performs one of several stylus gestures.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4180-2463">有关触笔笔势的信息，请参阅<xref:System.Windows.Input.SystemGesture>。</span><span class="sxs-lookup"><span data-stu-id="f4180-2463">For information about stylus gestures, see <xref:System.Windows.Input.SystemGesture>.</span></span>  
  
 <span data-ttu-id="f4180-2464">此事件创建一个别名<xref:System.Windows.Input.Stylus.PreviewStylusSystemGesture?displayProperty=nameWithType>附加事件对于此类，以便<xref:System.Windows.ContentElement.PreviewStylusSystemGesture>属于类的成员列出时<xref:System.Windows.ContentElement>作为基元素继承。</span><span class="sxs-lookup"><span data-stu-id="f4180-2464">This event creates an alias for the <xref:System.Windows.Input.Stylus.PreviewStylusSystemGesture?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.PreviewStylusSystemGesture> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="f4180-2465">事件处理程序附加到<xref:System.Windows.ContentElement.PreviewStylusSystemGesture>事件附加到基础<xref:System.Windows.Input.Stylus.PreviewStylusSystemGesture?displayProperty=nameWithType>附加事件，并接收相同的事件数据实例。</span><span class="sxs-lookup"><span data-stu-id="f4180-2465">Event handlers that are attached to the <xref:System.Windows.ContentElement.PreviewStylusSystemGesture> event are attached to the underlying <xref:System.Windows.Input.Stylus.PreviewStylusSystemGesture?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
 <span data-ttu-id="f4180-2466">触摸、 鼠标和触笔输入中的特定关系存在。</span><span class="sxs-lookup"><span data-stu-id="f4180-2466">Touch, mouse, and stylus input exist in a particular relationship.</span></span> <span data-ttu-id="f4180-2467">有关详细信息，请参阅[输入概述](~/docs/framework/wpf/advanced/input-overview.md)。</span><span class="sxs-lookup"><span data-stu-id="f4180-2467">For more information, see [Input Overview](~/docs/framework/wpf/advanced/input-overview.md).</span></span>  
  
<a name="routedEventInfo_PreviewStylusSystemGesture"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="f4180-2468">路由事件信息</span><span class="sxs-lookup"><span data-stu-id="f4180-2468">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="f4180-2469">标识符字段</span><span class="sxs-lookup"><span data-stu-id="f4180-2469">Identifier field</span></span>|<xref:System.Windows.ContentElement.PreviewStylusSystemGestureEvent>|  
|<span data-ttu-id="f4180-2470">路由策略</span><span class="sxs-lookup"><span data-stu-id="f4180-2470">Routing strategy</span></span>|<span data-ttu-id="f4180-2471">隧道</span><span class="sxs-lookup"><span data-stu-id="f4180-2471">Tunneling</span></span>|  
|<span data-ttu-id="f4180-2472">委托</span><span class="sxs-lookup"><span data-stu-id="f4180-2472">Delegate</span></span>|<xref:System.Windows.Input.StylusSystemGestureEventHandler>|  
  
-   <span data-ttu-id="f4180-2473">相应的浮升事件是<xref:System.Windows.ContentElement.StylusSystemGesture>。</span><span class="sxs-lookup"><span data-stu-id="f4180-2473">The corresponding bubbling event is <xref:System.Windows.ContentElement.StylusSystemGesture>.</span></span>  
  
-   <span data-ttu-id="f4180-2474">重写<xref:System.Windows.ContentElement.OnPreviewStylusSystemGesture%2A>实现类处理此事件在派生类中。</span><span class="sxs-lookup"><span data-stu-id="f4180-2474">Override <xref:System.Windows.ContentElement.OnPreviewStylusSystemGesture%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusSystemGestureEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewStylusSystemGestureEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewStylusSystemGestureEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewStylusSystemGestureEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewStylusSystemGestureEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewStylusSystemGestureEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewStylusSystemGestureEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.PreviewStylusSystemGestureEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f4180-2475">标识 <see cref="E:System.Windows.ContentElement.PreviewStylusSystemGesture" /> 路由事件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-2475">Identifies the <see cref="E:System.Windows.ContentElement.PreviewStylusSystemGesture" /> routed event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4180-2476">在注册路由事件时创建路由事件标识符。</span><span class="sxs-lookup"><span data-stu-id="f4180-2476">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="f4180-2477">这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。</span><span class="sxs-lookup"><span data-stu-id="f4180-2477">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="f4180-2478">可以使用这些标识符添加类处理程序。</span><span class="sxs-lookup"><span data-stu-id="f4180-2478">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="f4180-2479">有关注册路由事件的更多信息，请参见 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="f4180-2479">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="f4180-2480">有关使用路由事件标识符添加类处理程序的更多信息，请参见 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="f4180-2480">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusUp">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusEventHandler PreviewStylusUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusEventHandler PreviewStylusUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewStylusUp" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewStylusUp As StylusEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusEventHandler ^ PreviewStylusUp;" />
      <MemberSignature Language="F#" Value="member this.PreviewStylusUp : System.Windows.Input.StylusEventHandler " Usage="member this.PreviewStylusUp : System.Windows.Input.StylusEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewStylusUp</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f4180-2481">当触笔位于此元素上并且用户将触笔抬离数字化器时发生。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-2481">Occurs when the user raises the stylus off the digitizer while the stylus is over this element.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4180-2482">此事件创建一个别名<xref:System.Windows.Input.Stylus.PreviewStylusUp?displayProperty=nameWithType>附加事件对于此类，以便<xref:System.Windows.ContentElement.PreviewStylusDown>属于类的成员列出时<xref:System.Windows.ContentElement>作为基元素继承。</span><span class="sxs-lookup"><span data-stu-id="f4180-2482">This event creates an alias for the <xref:System.Windows.Input.Stylus.PreviewStylusUp?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.PreviewStylusDown> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="f4180-2483">事件处理程序附加到<xref:System.Windows.ContentElement.PreviewStylusDown>事件附加到基础<xref:System.Windows.Input.Stylus.PreviewStylusUp?displayProperty=nameWithType>附加事件，并接收相同的事件数据实例。</span><span class="sxs-lookup"><span data-stu-id="f4180-2483">Event handlers that are attached to the <xref:System.Windows.ContentElement.PreviewStylusDown> event are attached to the underlying <xref:System.Windows.Input.Stylus.PreviewStylusUp?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
 <span data-ttu-id="f4180-2484">触摸、 鼠标和触笔输入中的特定关系存在。</span><span class="sxs-lookup"><span data-stu-id="f4180-2484">Touch, mouse, and stylus input exist in a particular relationship.</span></span> <span data-ttu-id="f4180-2485">有关详细信息，请参阅[输入概述](~/docs/framework/wpf/advanced/input-overview.md)。</span><span class="sxs-lookup"><span data-stu-id="f4180-2485">For more information, see [Input Overview](~/docs/framework/wpf/advanced/input-overview.md).</span></span>  
  
<a name="routedEventInfo_PreviewStylusUp"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="f4180-2486">路由事件信息</span><span class="sxs-lookup"><span data-stu-id="f4180-2486">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="f4180-2487">标识符字段</span><span class="sxs-lookup"><span data-stu-id="f4180-2487">Identifier field</span></span>|<xref:System.Windows.ContentElement.PreviewStylusUpEvent>|  
|<span data-ttu-id="f4180-2488">路由策略</span><span class="sxs-lookup"><span data-stu-id="f4180-2488">Routing strategy</span></span>|<span data-ttu-id="f4180-2489">隧道</span><span class="sxs-lookup"><span data-stu-id="f4180-2489">Tunneling</span></span>|  
|<span data-ttu-id="f4180-2490">委托</span><span class="sxs-lookup"><span data-stu-id="f4180-2490">Delegate</span></span>|<xref:System.Windows.Input.StylusEventHandler>|  
  
-   <span data-ttu-id="f4180-2491">相应的浮升事件是<xref:System.Windows.ContentElement.StylusUp>。</span><span class="sxs-lookup"><span data-stu-id="f4180-2491">The corresponding bubbling event is <xref:System.Windows.ContentElement.StylusUp>.</span></span>  
  
-   <span data-ttu-id="f4180-2492">重写<xref:System.Windows.ContentElement.OnPreviewStylusUp%2A>实现类处理此事件在派生类中。</span><span class="sxs-lookup"><span data-stu-id="f4180-2492">Override <xref:System.Windows.ContentElement.OnPreviewStylusUp%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusUpEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewStylusUpEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewStylusUpEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewStylusUpEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewStylusUpEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewStylusUpEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewStylusUpEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.PreviewStylusUpEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f4180-2493">标识 <see cref="E:System.Windows.ContentElement.PreviewStylusUp" /> 路由事件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-2493">Identifies the <see cref="E:System.Windows.ContentElement.PreviewStylusUp" /> routed event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4180-2494">在注册路由事件时创建路由事件标识符。</span><span class="sxs-lookup"><span data-stu-id="f4180-2494">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="f4180-2495">这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。</span><span class="sxs-lookup"><span data-stu-id="f4180-2495">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="f4180-2496">可以使用这些标识符添加类处理程序。</span><span class="sxs-lookup"><span data-stu-id="f4180-2496">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="f4180-2497">有关注册路由事件的更多信息，请参见 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="f4180-2497">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="f4180-2498">有关使用路由事件标识符添加类处理程序的更多信息，请参见 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="f4180-2498">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewTextInput">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.TextCompositionEventHandler PreviewTextInput;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.TextCompositionEventHandler PreviewTextInput" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewTextInput" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewTextInput As TextCompositionEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::TextCompositionEventHandler ^ PreviewTextInput;" />
      <MemberSignature Language="F#" Value="member this.PreviewTextInput : System.Windows.Input.TextCompositionEventHandler " Usage="member this.PreviewTextInput : System.Windows.Input.TextCompositionEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewTextInput</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.TextCompositionEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f4180-2499">在此元素以设备无关模式获取文本时发生。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-2499">Occurs when this element gets text in a device-independent manner.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4180-2500"><xref:System.Windows.ContentElement.PreviewTextInput>事件允许组件或应用程序以与设备无关的方式侦听文本输入。</span><span class="sxs-lookup"><span data-stu-id="f4180-2500">The <xref:System.Windows.ContentElement.PreviewTextInput> event allows a component or application to listen for text input in a device-independent manner.</span></span> <span data-ttu-id="f4180-2501">键盘是主要的方式<xref:System.Windows.ContentElement.PreviewTextInput>; 但语音、 手写和其他输入的设备也可以生成<xref:System.Windows.ContentElement.PreviewTextInput>。</span><span class="sxs-lookup"><span data-stu-id="f4180-2501">The keyboard is the primary means of <xref:System.Windows.ContentElement.PreviewTextInput>; but speech, handwriting, and other input devices can also generate <xref:System.Windows.ContentElement.PreviewTextInput>.</span></span>  
  
 <span data-ttu-id="f4180-2502">由于键组合 — 默认键盘或输入的法编辑器-多个关键事件可能会引发一个文本输入的事件。</span><span class="sxs-lookup"><span data-stu-id="f4180-2502">Because of key combinations—either in default keyboards or through input method editors—multiple key events may raise just one text input event.</span></span>  
  
 <span data-ttu-id="f4180-2503">此事件创建一个别名<xref:System.Windows.Input.TextCompositionManager.PreviewTextInput?displayProperty=nameWithType>附加事件对于此类，以便<xref:System.Windows.ContentElement.PreviewTextInput>属于类的成员列出时<xref:System.Windows.ContentElement>作为基元素继承。</span><span class="sxs-lookup"><span data-stu-id="f4180-2503">This event creates an alias for the <xref:System.Windows.Input.TextCompositionManager.PreviewTextInput?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.PreviewTextInput> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="f4180-2504">事件处理程序附加到<xref:System.Windows.ContentElement.PreviewTextInput>事件附加到基础<xref:System.Windows.Input.TextCompositionManager.PreviewTextInput?displayProperty=nameWithType>附加事件，并接收相同的事件数据实例。</span><span class="sxs-lookup"><span data-stu-id="f4180-2504">Event handlers that are attached to the <xref:System.Windows.ContentElement.PreviewTextInput> event are attached to the underlying <xref:System.Windows.Input.TextCompositionManager.PreviewTextInput?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
<a name="routedEventInfo_PreviewTextInput"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="f4180-2505">路由事件信息</span><span class="sxs-lookup"><span data-stu-id="f4180-2505">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="f4180-2506">标识符字段</span><span class="sxs-lookup"><span data-stu-id="f4180-2506">Identifier field</span></span>|<xref:System.Windows.ContentElement.PreviewTextInputEvent>|  
|<span data-ttu-id="f4180-2507">路由策略</span><span class="sxs-lookup"><span data-stu-id="f4180-2507">Routing strategy</span></span>|<span data-ttu-id="f4180-2508">隧道</span><span class="sxs-lookup"><span data-stu-id="f4180-2508">Tunneling</span></span>|  
|<span data-ttu-id="f4180-2509">委托</span><span class="sxs-lookup"><span data-stu-id="f4180-2509">Delegate</span></span>|<xref:System.Windows.Input.TextCompositionEventHandler>|  
  
-   <span data-ttu-id="f4180-2510">相应的浮升事件是<xref:System.Windows.ContentElement.TextInput>。</span><span class="sxs-lookup"><span data-stu-id="f4180-2510">The corresponding bubbling event is <xref:System.Windows.ContentElement.TextInput>.</span></span>  
  
-   <span data-ttu-id="f4180-2511">重写<xref:System.Windows.ContentElement.OnPreviewTextInput%2A>实现类处理此事件在派生类中。</span><span class="sxs-lookup"><span data-stu-id="f4180-2511">Override <xref:System.Windows.ContentElement.OnPreviewTextInput%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewKeyDown" />
      </Docs>
    </Member>
    <Member MemberName="PreviewTextInputEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewTextInputEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewTextInputEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewTextInputEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewTextInputEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewTextInputEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewTextInputEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.PreviewTextInputEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f4180-2512">标识 <see cref="E:System.Windows.ContentElement.PreviewTextInput" /> 路由事件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-2512">Identifies the <see cref="E:System.Windows.ContentElement.PreviewTextInput" /> routed event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4180-2513">在注册路由事件时创建路由事件标识符。</span><span class="sxs-lookup"><span data-stu-id="f4180-2513">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="f4180-2514">这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。</span><span class="sxs-lookup"><span data-stu-id="f4180-2514">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="f4180-2515">可以使用这些标识符添加类处理程序。</span><span class="sxs-lookup"><span data-stu-id="f4180-2515">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="f4180-2516">有关注册路由事件的更多信息，请参见 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="f4180-2516">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="f4180-2517">有关使用路由事件标识符添加类处理程序的更多信息，请参见 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="f4180-2517">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewTouchDown">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; PreviewTouchDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Input.TouchEventArgs&gt; PreviewTouchDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewTouchDown" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewTouchDown As EventHandler(Of TouchEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Windows::Input::TouchEventArgs ^&gt; ^ PreviewTouchDown;" />
      <MemberSignature Language="F#" Value="member this.PreviewTouchDown : EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; " Usage="member this.PreviewTouchDown : System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f4180-2518">当悬停在此元素上方的手指触摸屏幕时发生。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-2518">Occurs when a finger touches the screen while the finger is over this element.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4180-2519">默认情况下<xref:System.Windows.ContentElement.PreviewTouchDown>和<xref:System.Windows.ContentElement.TouchDown>手指触摸屏幕，并将移动之前不会发生的事件。</span><span class="sxs-lookup"><span data-stu-id="f4180-2519">By default, the <xref:System.Windows.ContentElement.PreviewTouchDown> and <xref:System.Windows.ContentElement.TouchDown> events do not occur until a finger touches the screen and moves.</span></span> <span data-ttu-id="f4180-2520">手指在屏幕上按住它而无需移动它会导致按下并保存的行为<xref:System.Windows.Input.Stylus>。</span><span class="sxs-lookup"><span data-stu-id="f4180-2520">Pressing a finger on the screen and holding it without moving it causes the press and hold behavior of a <xref:System.Windows.Input.Stylus>.</span></span> <span data-ttu-id="f4180-2521">按下并保持行为等同于鼠标右键单击。</span><span class="sxs-lookup"><span data-stu-id="f4180-2521">The press and hold behavior is equivalent to a mouse right-click.</span></span>  
  
 <span data-ttu-id="f4180-2522">若要使<xref:System.Windows.ContentElement.PreviewTouchDown>并<xref:System.Windows.ContentElement.TouchDown>事件发生只要上方的手指触摸屏幕上，设置<xref:System.Windows.Input.Stylus.IsPressAndHoldEnabled%2A?displayProperty=nameWithType>附加到属性`false`此元素。</span><span class="sxs-lookup"><span data-stu-id="f4180-2522">To cause the <xref:System.Windows.ContentElement.PreviewTouchDown> and <xref:System.Windows.ContentElement.TouchDown> events to occur as soon as a finger touches the screen, set the <xref:System.Windows.Input.Stylus.IsPressAndHoldEnabled%2A?displayProperty=nameWithType> attached property to `false` for this element.</span></span>  
  
<a name="routedEventInfo_PreviewTouchDown"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="f4180-2523">路由事件信息</span><span class="sxs-lookup"><span data-stu-id="f4180-2523">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="f4180-2524">标识符字段</span><span class="sxs-lookup"><span data-stu-id="f4180-2524">Identifier field</span></span>|<xref:System.Windows.ContentElement.PreviewTouchDownEvent>|  
|<span data-ttu-id="f4180-2525">路由策略</span><span class="sxs-lookup"><span data-stu-id="f4180-2525">Routing strategy</span></span>|<span data-ttu-id="f4180-2526">隧道</span><span class="sxs-lookup"><span data-stu-id="f4180-2526">Tunneling</span></span>|  
|<span data-ttu-id="f4180-2527">委托</span><span class="sxs-lookup"><span data-stu-id="f4180-2527">Delegate</span></span>|<span data-ttu-id="f4180-2528"><xref:System.EventHandler%601>类型<xref:System.Windows.Input.TouchEventArgs>。</span><span class="sxs-lookup"><span data-stu-id="f4180-2528"><xref:System.EventHandler%601> of type <xref:System.Windows.Input.TouchEventArgs>.</span></span>|  
  
-   <span data-ttu-id="f4180-2529">相应的浮升事件是<xref:System.Windows.ContentElement.TouchDown>。</span><span class="sxs-lookup"><span data-stu-id="f4180-2529">The corresponding bubbling event is <xref:System.Windows.ContentElement.TouchDown>.</span></span>  
  
-   <span data-ttu-id="f4180-2530">重写<xref:System.Windows.ContentElement.OnPreviewTouchDown%2A>实现类处理此事件在派生类中。</span><span class="sxs-lookup"><span data-stu-id="f4180-2530">Override <xref:System.Windows.ContentElement.OnPreviewTouchDown%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Input.Stylus.IsPressAndHoldEnabled" />
        <altmember cref="M:System.Windows.Input.Stylus.GetIsPressAndHoldEnabled(System.Windows.DependencyObject)" />
        <altmember cref="M:System.Windows.Input.Stylus.SetIsPressAndHoldEnabled(System.Windows.DependencyObject,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="PreviewTouchDownEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewTouchDownEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewTouchDownEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewTouchDownEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewTouchDownEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewTouchDownEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewTouchDownEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.PreviewTouchDownEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f4180-2531">标识 <see cref="E:System.Windows.ContentElement.PreviewTouchDown" /> 路由事件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-2531">Identifies the <see cref="E:System.Windows.ContentElement.PreviewTouchDown" /> routed event.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewTouchMove">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; PreviewTouchMove;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Input.TouchEventArgs&gt; PreviewTouchMove" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewTouchMove" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewTouchMove As EventHandler(Of TouchEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Windows::Input::TouchEventArgs ^&gt; ^ PreviewTouchMove;" />
      <MemberSignature Language="F#" Value="member this.PreviewTouchMove : EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; " Usage="member this.PreviewTouchMove : System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f4180-2532">当悬停在此元素上方的手指在屏幕上移动时发生。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-2532">Occurs when a finger moves on the screen while the finger is over this element.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="routedEventInfo_PreviewTouchMove"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="f4180-2533">路由事件信息</span><span class="sxs-lookup"><span data-stu-id="f4180-2533">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="f4180-2534">标识符字段</span><span class="sxs-lookup"><span data-stu-id="f4180-2534">Identifier field</span></span>|<xref:System.Windows.ContentElement.PreviewTouchMoveEvent>|  
|<span data-ttu-id="f4180-2535">路由策略</span><span class="sxs-lookup"><span data-stu-id="f4180-2535">Routing strategy</span></span>|<span data-ttu-id="f4180-2536">隧道</span><span class="sxs-lookup"><span data-stu-id="f4180-2536">Tunneling</span></span>|  
|<span data-ttu-id="f4180-2537">委托</span><span class="sxs-lookup"><span data-stu-id="f4180-2537">Delegate</span></span>|<span data-ttu-id="f4180-2538"><xref:System.EventHandler%601>类型<xref:System.Windows.Input.TouchEventArgs>。</span><span class="sxs-lookup"><span data-stu-id="f4180-2538"><xref:System.EventHandler%601> of type <xref:System.Windows.Input.TouchEventArgs>.</span></span>|  
  
-   <span data-ttu-id="f4180-2539">相应的浮升事件是<xref:System.Windows.ContentElement.TouchMove>。</span><span class="sxs-lookup"><span data-stu-id="f4180-2539">The corresponding bubbling event is <xref:System.Windows.ContentElement.TouchMove>.</span></span>  
  
-   <span data-ttu-id="f4180-2540">重写<xref:System.Windows.ContentElement.OnPreviewTouchMove%2A>实现类处理此事件在派生类中。</span><span class="sxs-lookup"><span data-stu-id="f4180-2540">Override <xref:System.Windows.ContentElement.OnPreviewTouchMove%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewTouchMoveEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewTouchMoveEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewTouchMoveEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewTouchMoveEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewTouchMoveEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewTouchMoveEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewTouchMoveEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.PreviewTouchMoveEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f4180-2541">标识 <see cref="E:System.Windows.ContentElement.PreviewTouchMove" /> 路由事件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-2541">Identifies the <see cref="E:System.Windows.ContentElement.PreviewTouchMove" /> routed event.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewTouchUp">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; PreviewTouchUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Input.TouchEventArgs&gt; PreviewTouchUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewTouchUp" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewTouchUp As EventHandler(Of TouchEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Windows::Input::TouchEventArgs ^&gt; ^ PreviewTouchUp;" />
      <MemberSignature Language="F#" Value="member this.PreviewTouchUp : EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; " Usage="member this.PreviewTouchUp : System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f4180-2542">当悬停在此元素上方的手指从屏幕上移开时发生。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-2542">Occurs when a finger is raised off of the screen while the finger is over this element.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="routedEventInfo_PreviewTouchUp"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="f4180-2543">路由事件信息</span><span class="sxs-lookup"><span data-stu-id="f4180-2543">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="f4180-2544">标识符字段</span><span class="sxs-lookup"><span data-stu-id="f4180-2544">Identifier field</span></span>|<xref:System.Windows.ContentElement.PreviewTouchUpEvent>|  
|<span data-ttu-id="f4180-2545">路由策略</span><span class="sxs-lookup"><span data-stu-id="f4180-2545">Routing strategy</span></span>|<span data-ttu-id="f4180-2546">隧道</span><span class="sxs-lookup"><span data-stu-id="f4180-2546">Tunneling</span></span>|  
|<span data-ttu-id="f4180-2547">委托</span><span class="sxs-lookup"><span data-stu-id="f4180-2547">Delegate</span></span>|<span data-ttu-id="f4180-2548"><xref:System.EventHandler%601>类型<xref:System.Windows.Input.TouchEventArgs>。</span><span class="sxs-lookup"><span data-stu-id="f4180-2548"><xref:System.EventHandler%601> of type <xref:System.Windows.Input.TouchEventArgs>.</span></span>|  
  
-   <span data-ttu-id="f4180-2549">相应的浮升事件是<xref:System.Windows.ContentElement.TouchUp>。</span><span class="sxs-lookup"><span data-stu-id="f4180-2549">The corresponding bubbling event is <xref:System.Windows.ContentElement.TouchUp>.</span></span>  
  
-   <span data-ttu-id="f4180-2550">重写<xref:System.Windows.ContentElement.OnPreviewTouchUp%2A>实现类处理此事件在派生类中。</span><span class="sxs-lookup"><span data-stu-id="f4180-2550">Override <xref:System.Windows.ContentElement.OnPreviewTouchUp%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewTouchUpEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewTouchUpEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewTouchUpEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewTouchUpEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewTouchUpEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewTouchUpEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewTouchUpEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.PreviewTouchUpEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f4180-2551">标识 <see cref="E:System.Windows.ContentElement.PreviewTouchUp" /> 路由事件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-2551">Identifies the <see cref="E:System.Windows.ContentElement.PreviewTouchUp" /> routed event.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="QueryContinueDrag">
      <MemberSignature Language="C#" Value="public event System.Windows.QueryContinueDragEventHandler QueryContinueDrag;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.QueryContinueDragEventHandler QueryContinueDrag" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.QueryContinueDrag" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event QueryContinueDrag As QueryContinueDragEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::QueryContinueDragEventHandler ^ QueryContinueDrag;" />
      <MemberSignature Language="F#" Value="member this.QueryContinueDrag : System.Windows.QueryContinueDragEventHandler " Usage="member this.QueryContinueDrag : System.Windows.QueryContinueDragEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.QueryContinueDragEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f4180-2552">在拖放操作期间键盘或鼠标按钮的状态改变时发生。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-2552">Occurs when there is a change in the keyboard or mouse button state during a drag-and-drop operation.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4180-2553"><xref:System.Windows.ContentElement.QueryContinueDrag>事件允许拖动源确定是否应取消拖放操作。</span><span class="sxs-lookup"><span data-stu-id="f4180-2553">The <xref:System.Windows.ContentElement.QueryContinueDrag> event enables the drag source to determine whether the drag-and-drop operation should be canceled.</span></span>  
  
 <span data-ttu-id="f4180-2554">此事件创建一个别名<xref:System.Windows.DragDrop.QueryContinueDrag?displayProperty=nameWithType>附加事件对于此类，以便<xref:System.Windows.ContentElement.QueryContinueDrag>属于类的成员列出时<xref:System.Windows.ContentElement>作为基元素继承。</span><span class="sxs-lookup"><span data-stu-id="f4180-2554">This event creates an alias for the <xref:System.Windows.DragDrop.QueryContinueDrag?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.QueryContinueDrag> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="f4180-2555">事件处理程序附加到<xref:System.Windows.ContentElement.QueryContinueDrag>事件附加到基础<xref:System.Windows.DragDrop.QueryContinueDrag?displayProperty=nameWithType>附加事件，并接收相同的事件数据实例。</span><span class="sxs-lookup"><span data-stu-id="f4180-2555">Event handlers that are attached to the <xref:System.Windows.ContentElement.QueryContinueDrag> event are attached to the underlying <xref:System.Windows.DragDrop.QueryContinueDrag?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
<a name="routedEventInfo_QueryContinueDrag"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="f4180-2556">路由事件信息</span><span class="sxs-lookup"><span data-stu-id="f4180-2556">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="f4180-2557">标识符字段</span><span class="sxs-lookup"><span data-stu-id="f4180-2557">Identifier field</span></span>|<xref:System.Windows.ContentElement.QueryContinueDragEvent>|  
|<span data-ttu-id="f4180-2558">路由策略</span><span class="sxs-lookup"><span data-stu-id="f4180-2558">Routing strategy</span></span>|<span data-ttu-id="f4180-2559">浮升</span><span class="sxs-lookup"><span data-stu-id="f4180-2559">Bubbling</span></span>|  
|<span data-ttu-id="f4180-2560">委托</span><span class="sxs-lookup"><span data-stu-id="f4180-2560">Delegate</span></span>|<xref:System.Windows.QueryContinueDragEventHandler>|  
  
-   <span data-ttu-id="f4180-2561">相应的隧道事件是<xref:System.Windows.ContentElement.PreviewQueryContinueDrag>。</span><span class="sxs-lookup"><span data-stu-id="f4180-2561">The corresponding tunneling event is <xref:System.Windows.ContentElement.PreviewQueryContinueDrag>.</span></span>  
  
-   <span data-ttu-id="f4180-2562">重写<xref:System.Windows.ContentElement.OnQueryContinueDrag%2A>实现类处理此事件在派生类中。</span><span class="sxs-lookup"><span data-stu-id="f4180-2562">Override <xref:System.Windows.ContentElement.OnQueryContinueDrag%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="QueryContinueDragEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent QueryContinueDragEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent QueryContinueDragEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.QueryContinueDragEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly QueryContinueDragEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ QueryContinueDragEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable QueryContinueDragEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.QueryContinueDragEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f4180-2563">标识 <see cref="E:System.Windows.ContentElement.QueryContinueDrag" /> 路由事件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-2563">Identifies the <see cref="E:System.Windows.ContentElement.QueryContinueDrag" /> routed event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4180-2564">在注册路由事件时创建路由事件标识符。</span><span class="sxs-lookup"><span data-stu-id="f4180-2564">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="f4180-2565">这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。</span><span class="sxs-lookup"><span data-stu-id="f4180-2565">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="f4180-2566">可以使用这些标识符添加类处理程序。</span><span class="sxs-lookup"><span data-stu-id="f4180-2566">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="f4180-2567">有关注册路由事件的更多信息，请参见 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="f4180-2567">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="f4180-2568">有关使用路由事件标识符添加类处理程序的更多信息，请参见 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="f4180-2568">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="QueryCursor">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.QueryCursorEventHandler QueryCursor;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.QueryCursorEventHandler QueryCursor" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.QueryCursor" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event QueryCursor As QueryCursorEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Input::QueryCursorEventHandler ^ QueryCursor;" />
      <MemberSignature Language="F#" Value="member this.QueryCursor : System.Windows.Input.QueryCursorEventHandler " Usage="member this.QueryCursor : System.Windows.Input.QueryCursorEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.QueryCursorEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f4180-2569">当请求显示光标时发生。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-2569">Occurs when the cursor is requested to display.</span>
          </span>
          <span data-ttu-id="f4180-2570">每次鼠标指针移至新位置时都会在一个元素上引发此事件，这意味着光标对象可能需要根据其新位置进行更改。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-2570">This event is raised on an element each time that the mouse pointer moves to a new location, which means the cursor object might need to be changed based on its new position.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4180-2571">此事件创建一个别名<xref:System.Windows.Input.Mouse.QueryCursor?displayProperty=nameWithType>附加事件对于此类，以便<xref:System.Windows.ContentElement.QueryCursor>属于类的成员列出时<xref:System.Windows.ContentElement>作为基元素继承。</span><span class="sxs-lookup"><span data-stu-id="f4180-2571">This event creates an alias for the <xref:System.Windows.Input.Mouse.QueryCursor?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.QueryCursor> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="f4180-2572">事件处理程序附加到<xref:System.Windows.ContentElement.QueryCursor>事件附加到基础<xref:System.Windows.Input.Mouse.QueryCursor?displayProperty=nameWithType>附加事件，并接收相同的事件数据实例。</span><span class="sxs-lookup"><span data-stu-id="f4180-2572">Event handlers that are attached to the <xref:System.Windows.ContentElement.QueryCursor> event are attached to the underlying <xref:System.Windows.Input.Mouse.QueryCursor?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
 <span data-ttu-id="f4180-2573">此事件的名称引用游标不一定是文本光标 （有时称为插入点）。</span><span class="sxs-lookup"><span data-stu-id="f4180-2573">The cursor being referred to by this event name is not necessarily the text cursor (sometimes known as the insertion point).</span></span> <span data-ttu-id="f4180-2574">相反，此上下文中的光标是声明与多个可能的输入相关的设备或 Windows 编程中的概念相关的屏幕图形显示的对象。</span><span class="sxs-lookup"><span data-stu-id="f4180-2574">Instead, the cursor in this context is the object that declares the onscreen graphical display related to several possible input-related devices or concepts in Windows programming.</span></span> <span data-ttu-id="f4180-2575">该对象表示由<xref:System.Windows.Input.Cursor>在 WPF 中的类。</span><span class="sxs-lookup"><span data-stu-id="f4180-2575">That object is represented by the <xref:System.Windows.Input.Cursor> class in WPF.</span></span> <span data-ttu-id="f4180-2576">WPF 输入的系统，可更改此光标时它表示鼠标指针的屏幕上的位置。</span><span class="sxs-lookup"><span data-stu-id="f4180-2576">The WPF input system enables you to change this cursor when it represents the onscreen position of the mouse pointer.</span></span> <span data-ttu-id="f4180-2577">可以使用预定义的值从<xref:System.Windows.Input.Cursors>枚举，也可以声明自定义光标为图像文件。</span><span class="sxs-lookup"><span data-stu-id="f4180-2577">You can use predefined values from the <xref:System.Windows.Input.Cursors> enumeration, or you can declare a custom cursor as an image file.</span></span>  
  
 <span data-ttu-id="f4180-2578">侦听<xref:System.Windows.ContentElement.QueryCursor>事件不是游标管理的有效技术。</span><span class="sxs-lookup"><span data-stu-id="f4180-2578">Listening for the <xref:System.Windows.ContentElement.QueryCursor> event is not an efficient technique for cursor management.</span></span> <span data-ttu-id="f4180-2579">相反，每个元素应定义自己使用的游标行为<xref:System.Windows.FrameworkContentElement.Cursor%2A>和<xref:System.Windows.FrameworkContentElement.ForceCursor%2A>。</span><span class="sxs-lookup"><span data-stu-id="f4180-2579">Instead, each element should define its own cursor behavior with <xref:System.Windows.FrameworkContentElement.Cursor%2A> and <xref:System.Windows.FrameworkContentElement.ForceCursor%2A>.</span></span> <span data-ttu-id="f4180-2580">您应仅依赖于<xref:System.Windows.ContentElement.QueryCursor>如果不使用 WPF 框架级别的基本元素，或中的特殊情况下，在每个元素的基础上定义游标的行为不符合你的需求。</span><span class="sxs-lookup"><span data-stu-id="f4180-2580">You should only rely on <xref:System.Windows.ContentElement.QueryCursor> if you are not using the WPF framework-level base elements, or in extraordinary circumstances where defining cursor behavior on a per-element basis does not meet your needs.</span></span> <span data-ttu-id="f4180-2581">有关详细信息在响应中实现的游标行为<xref:System.Windows.ContentElement.QueryCursor>，请参阅<xref:System.Windows.Input.QueryCursorEventHandler>。</span><span class="sxs-lookup"><span data-stu-id="f4180-2581">For more information on implementing cursor behavior in response to <xref:System.Windows.ContentElement.QueryCursor>, see <xref:System.Windows.Input.QueryCursorEventHandler>.</span></span>  
  
<a name="routedEventInfo_QueryCursor"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="f4180-2582">路由事件信息</span><span class="sxs-lookup"><span data-stu-id="f4180-2582">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="f4180-2583">标识符字段</span><span class="sxs-lookup"><span data-stu-id="f4180-2583">Identifier field</span></span>|<xref:System.Windows.ContentElement.QueryCursorEvent>|  
|<span data-ttu-id="f4180-2584">路由策略</span><span class="sxs-lookup"><span data-stu-id="f4180-2584">Routing strategy</span></span>|<span data-ttu-id="f4180-2585">浮升</span><span class="sxs-lookup"><span data-stu-id="f4180-2585">Bubbling</span></span>|  
|<span data-ttu-id="f4180-2586">委托</span><span class="sxs-lookup"><span data-stu-id="f4180-2586">Delegate</span></span>|<xref:System.Windows.Input.QueryCursorEventHandler>|  
  
-   <span data-ttu-id="f4180-2587">没有定义相应的隧道事件。</span><span class="sxs-lookup"><span data-stu-id="f4180-2587">There is no defined corresponding tunneling event.</span></span>  
  
-   <span data-ttu-id="f4180-2588">重写<xref:System.Windows.ContentElement.OnQueryCursor%2A>实现类处理此事件在派生类中。</span><span class="sxs-lookup"><span data-stu-id="f4180-2588">Override <xref:System.Windows.ContentElement.OnQueryCursor%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.FrameworkElement.Cursor" />
      </Docs>
    </Member>
    <Member MemberName="QueryCursorEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent QueryCursorEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent QueryCursorEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.QueryCursorEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly QueryCursorEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ QueryCursorEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable QueryCursorEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.QueryCursorEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f4180-2589">标识 <see cref="E:System.Windows.ContentElement.QueryCursor" /> 路由事件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-2589">Identifies the <see cref="E:System.Windows.ContentElement.QueryCursor" /> routed event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4180-2590">在注册路由事件时创建路由事件标识符。</span><span class="sxs-lookup"><span data-stu-id="f4180-2590">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="f4180-2591">这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。</span><span class="sxs-lookup"><span data-stu-id="f4180-2591">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="f4180-2592">可以使用这些标识符添加类处理程序。</span><span class="sxs-lookup"><span data-stu-id="f4180-2592">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="f4180-2593">有关注册路由事件的更多信息，请参见 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="f4180-2593">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="f4180-2594">有关使用路由事件标识符添加类处理程序的更多信息，请参见 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="f4180-2594">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RaiseEvent">
      <MemberSignature Language="C#" Value="public void RaiseEvent (System.Windows.RoutedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RaiseEvent(class System.Windows.RoutedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.RaiseEvent(System.Windows.RoutedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RaiseEvent (e As RoutedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void RaiseEvent(System::Windows::RoutedEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member RaiseEvent : System.Windows.RoutedEventArgs -&gt; unit&#xA;override this.RaiseEvent : System.Windows.RoutedEventArgs -&gt; unit" Usage="contentElement.RaiseEvent e" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.IInputElement.RaiseEvent(System.Windows.RoutedEventArgs)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.RoutedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="f4180-2595">一个 <see cref="T:System.Windows.RoutedEventArgs" />，其中包含事件数据并标识要引发的事件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-2595">A <see cref="T:System.Windows.RoutedEventArgs" /> that contains the event data and also identifies the event to raise.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f4180-2596">引发特定路由事件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-2596">Raises a specific routed event.</span>
          </span>
          <span data-ttu-id="f4180-2597">在提供的 <see cref="T:System.Windows.RoutedEvent" /> 实例中标识要引发的 <see cref="T:System.Windows.RoutedEventArgs" />（作为该事件数据的 <see cref="P:System.Windows.RoutedEventArgs.RoutedEvent" /> 属性）。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-2597">The <see cref="T:System.Windows.RoutedEvent" /> to be raised is identified within the <see cref="T:System.Windows.RoutedEventArgs" /> instance that is provided (as the <see cref="P:System.Windows.RoutedEventArgs.RoutedEvent" /> property of that event data).</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4180-2598">`e`参数的类型为路由的事件的所有数据的公共基类型; 但是，应作为最具体的事件数据类型，是适用于要引发的事件，因为给定的事件数据<xref:System.Windows.RoutedEventArgs>派生的类包含适用于特定事件时将引发此事件的实际的特定数据属性。</span><span class="sxs-lookup"><span data-stu-id="f4180-2598">The `e` parameter is typed as the common base type for all routed event data; however, the event data should be given as the most specific event data type that is available for the event being raised, because <xref:System.Windows.RoutedEventArgs> derived classes contain the actual specific data properties that are intended for the specific event when it is raised.</span></span>  
  
 <span data-ttu-id="f4180-2599"><xref:System.Windows.RoutedEventArgs> 不只是事件; 的状态属性它还标识要引发的路由的事件。</span><span class="sxs-lookup"><span data-stu-id="f4180-2599"><xref:System.Windows.RoutedEventArgs> is not just the state properties for the event; it also identifies which routed event to raise.</span></span> <span data-ttu-id="f4180-2600">此事件引发模式和路由的事件数据均不同于[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]事件和数据类，通常只包含与事件相关的属性。</span><span class="sxs-lookup"><span data-stu-id="f4180-2600">This event-raising pattern and the routed event data both differ from [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] events and data classes, which typically just contain properties that are related to the event.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f4180-2601">下面的示例创建事件数据，将事件标识符追加到数据，然后使用事件数据实例来引发自定义的路由的事件。</span><span class="sxs-lookup"><span data-stu-id="f4180-2601">The following example creates event data, appends the event identifier to the data, and then uses the event data instance to raise a custom routed event.</span></span>  
  
 [!code-csharp[ContentElementsSmorgasbord#RaiseEvent](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml.cs#raiseevent)]
 [!code-vb[ContentElementsSmorgasbord#RaiseEvent](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContentElementsSmorgasbord/visualbasic/page1.xaml.vb#raiseevent)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReleaseAllTouchCaptures">
      <MemberSignature Language="C#" Value="public void ReleaseAllTouchCaptures ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ReleaseAllTouchCaptures() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.ReleaseAllTouchCaptures" />
      <MemberSignature Language="VB.NET" Value="Public Sub ReleaseAllTouchCaptures ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ReleaseAllTouchCaptures();" />
      <MemberSignature Language="F#" Value="member this.ReleaseAllTouchCaptures : unit -&gt; unit" Usage="contentElement.ReleaseAllTouchCaptures " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="f4180-2602">从此元素中释放所有捕获的触摸设备。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-2602">Releases all captured touch devices from this element.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReleaseMouseCapture">
      <MemberSignature Language="C#" Value="public void ReleaseMouseCapture ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ReleaseMouseCapture() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.ReleaseMouseCapture" />
      <MemberSignature Language="VB.NET" Value="Public Sub ReleaseMouseCapture ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ReleaseMouseCapture();" />
      <MemberSignature Language="F#" Value="abstract member ReleaseMouseCapture : unit -&gt; unit&#xA;override this.ReleaseMouseCapture : unit -&gt; unit" Usage="contentElement.ReleaseMouseCapture " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.IInputElement.ReleaseMouseCapture</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="f4180-2603">如果此元素具有鼠标捕获，则释放该捕获。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-2603">Releases the mouse capture, if this element held the capture.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4180-2604">如果此元素不保存捕获，调用此方法无效。</span><span class="sxs-lookup"><span data-stu-id="f4180-2604">If this element did not hold the capture, calling this method has no effect.</span></span> <span data-ttu-id="f4180-2605">请考虑检查的值<xref:System.Windows.ContentElement.IsMouseCaptured%2A>之前调用此方法。</span><span class="sxs-lookup"><span data-stu-id="f4180-2605">Consider checking the value of <xref:System.Windows.ContentElement.IsMouseCaptured%2A> before you call this method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f4180-2606">下面的处理程序捕获或释放鼠标按钮状态根据鼠标捕获。</span><span class="sxs-lookup"><span data-stu-id="f4180-2606">The following handler captures or releases mouse capture according to mouse button states.</span></span> <span data-ttu-id="f4180-2607">该示例演示如何为使用捕获的鼠标移动进行其他比移动鼠标指针用途[!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)]。</span><span class="sxs-lookup"><span data-stu-id="f4180-2607">The example shows how to use captured mouse movement for alternative purposes other than moving the mouse pointer in the [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)].</span></span>  
  
 [!code-csharp[ContentElementsSmorgasbord#UIElementMouseCapture](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/Trackball.cs#uielementmousecapture)]
 [!code-vb[ContentElementsSmorgasbord#UIElementMouseCapture](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContentElementsSmorgasbord/visualbasic/trackball.vb#uielementmousecapture)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.ContentElement.IsMouseCaptured" />
      </Docs>
    </Member>
    <Member MemberName="ReleaseStylusCapture">
      <MemberSignature Language="C#" Value="public void ReleaseStylusCapture ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ReleaseStylusCapture() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.ReleaseStylusCapture" />
      <MemberSignature Language="VB.NET" Value="Public Sub ReleaseStylusCapture ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ReleaseStylusCapture();" />
      <MemberSignature Language="F#" Value="abstract member ReleaseStylusCapture : unit -&gt; unit&#xA;override this.ReleaseStylusCapture : unit -&gt; unit" Usage="contentElement.ReleaseStylusCapture " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.IInputElement.ReleaseStylusCapture</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="f4180-2608">如果此元素具有触笔设备捕获，则释放该捕获。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-2608">Releases the stylus device capture, if this element held the capture.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4180-2609">如果此元素不保存捕获，调用此方法无效。</span><span class="sxs-lookup"><span data-stu-id="f4180-2609">If this element did not hold the capture, calling this method has no effect.</span></span> <span data-ttu-id="f4180-2610">请考虑检查的值<xref:System.Windows.ContentElement.IsStylusCaptured%2A>之前调用此方法。</span><span class="sxs-lookup"><span data-stu-id="f4180-2610">Consider checking the value of <xref:System.Windows.ContentElement.IsStylusCaptured%2A> before you call this method.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReleaseTouchCapture">
      <MemberSignature Language="C#" Value="public bool ReleaseTouchCapture (System.Windows.Input.TouchDevice touchDevice);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ReleaseTouchCapture(class System.Windows.Input.TouchDevice touchDevice) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.ReleaseTouchCapture(System.Windows.Input.TouchDevice)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ReleaseTouchCapture(System::Windows::Input::TouchDevice ^ touchDevice);" />
      <MemberSignature Language="F#" Value="member this.ReleaseTouchCapture : System.Windows.Input.TouchDevice -&gt; bool" Usage="contentElement.ReleaseTouchCapture touchDevice" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="touchDevice" Type="System.Windows.Input.TouchDevice" />
      </Parameters>
      <Docs>
        <param name="touchDevice">
          <span data-ttu-id="f4180-2611">要释放的设备。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-2611">The device to release.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f4180-2612">尝试从此元素释放指定触摸设备。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-2612">Attempts to release the specified touch device from this element.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f4180-2613">如果释放了触摸设备，则为 <see langword="true" />；否则为 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-2613">
              <see langword="true" /> if the touch device is released; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f4180-2614">
            <paramref name="touchDevice" /> 为 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-2614">
              <paramref name="touchDevice" /> is <see langword="null" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="RemoveHandler">
      <MemberSignature Language="C#" Value="public void RemoveHandler (System.Windows.RoutedEvent routedEvent, Delegate handler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RemoveHandler(class System.Windows.RoutedEvent routedEvent, class System.Delegate handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.RemoveHandler(System.Windows.RoutedEvent,System.Delegate)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void RemoveHandler(System::Windows::RoutedEvent ^ routedEvent, Delegate ^ handler);" />
      <MemberSignature Language="F#" Value="abstract member RemoveHandler : System.Windows.RoutedEvent * Delegate -&gt; unit&#xA;override this.RemoveHandler : System.Windows.RoutedEvent * Delegate -&gt; unit" Usage="contentElement.RemoveHandler (routedEvent, handler)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.IInputElement.RemoveHandler(System.Windows.RoutedEvent,System.Delegate)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routedEvent" Type="System.Windows.RoutedEvent" />
        <Parameter Name="handler" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="routedEvent">
          <span data-ttu-id="f4180-2615">附加处理程序的路由事件的标识符。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-2615">The identifier of the.routed event for which the handler is attached.</span>
          </span>
        </param>
        <param name="handler">
          <span data-ttu-id="f4180-2616">要从此元素的事件处理程序集合中删除的特定处理程序实现。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-2616">The specific handler implementation to remove from the event handler collection on this element.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f4180-2617">从此元素中删除指定的路由事件处理程序。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-2617">Removes the specified routed event handler from this element.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4180-2618">使用此的最常见情形[!INCLUDE[TLA#tla_api](~/includes/tlasharptla-api-md.md)]是实现时[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]自定义的路由事件，特别是，当您实现在处理程序的"删除"逻辑与相关联的"包装器"事件[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]级别。</span><span class="sxs-lookup"><span data-stu-id="f4180-2618">The most common scenario for using this [!INCLUDE[TLA#tla_api](~/includes/tlasharptla-api-md.md)] is when you implement the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] "wrapper" event that is associated with a custom routed event, specifically when you implement the "remove" logic for handlers at the [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] level.</span></span> <span data-ttu-id="f4180-2619">以下示例中此部分说明了这种情况下的备注。</span><span class="sxs-lookup"><span data-stu-id="f4180-2619">The example that follows this remarks section illustrates this scenario.</span></span>  
  
 <span data-ttu-id="f4180-2620">如果存在任何与条件相匹配的输入的参数的方法调用注册的处理程序调用此方法起不起作用。</span><span class="sxs-lookup"><span data-stu-id="f4180-2620">Calling this method has no effect if there were no handlers registered with criteria that match the input parameters for the method call.</span></span>  
  
 <span data-ttu-id="f4180-2621">如果多个处理程序附加事件移除处理程序存储区中匹配的条件，仅第一个处理程序。</span><span class="sxs-lookup"><span data-stu-id="f4180-2621">If more than one handler is attached that matched the criteria, only the first handler in the event handler store is removed.</span></span> <span data-ttu-id="f4180-2622">此行为是与一致[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]的行为`-=`运算符。</span><span class="sxs-lookup"><span data-stu-id="f4180-2622">This behavior is consistent with [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] behavior of the `-=` operator.</span></span>  
  
 <span data-ttu-id="f4180-2623">既不`routedEvent`也不`handler`可能`null`。</span><span class="sxs-lookup"><span data-stu-id="f4180-2623">Neither `routedEvent` nor `handler` may be `null`.</span></span> <span data-ttu-id="f4180-2624">在尝试提供上述任意值作为`null`将引发异常。</span><span class="sxs-lookup"><span data-stu-id="f4180-2624">Attempting to provide either value as `null` will raise an exception.</span></span>  
  
 <span data-ttu-id="f4180-2625">此方法将忽略`handledEventsToo`与第一个处理程序时提供的参数信息添加<xref:System.Windows.ContentElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29>签名，它使已处理事件的处理。</span><span class="sxs-lookup"><span data-stu-id="f4180-2625">This method ignores the `handledEventsToo` parameter information, which is provided if the handler was first added with the <xref:System.Windows.ContentElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> signature that enables handling of already-handled events.</span></span> <span data-ttu-id="f4180-2626">删除任一类型的处理程序。</span><span class="sxs-lookup"><span data-stu-id="f4180-2626">Either type of handler is removed.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.ContentElement.AddHandler(System.Windows.RoutedEvent,System.Delegate)" />
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeCommandBindings">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeCommandBindings ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeCommandBindings() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.ShouldSerializeCommandBindings" />
      <MemberSignature Language="VB.NET" Value="Public Function ShouldSerializeCommandBindings () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ShouldSerializeCommandBindings();" />
      <MemberSignature Language="F#" Value="member this.ShouldSerializeCommandBindings : unit -&gt; bool" Usage="contentElement.ShouldSerializeCommandBindings " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="f4180-2627">返回序列化进程是否应在此类的实例上序列化 <see cref="P:System.Windows.ContentElement.CommandBindings" /> 属性的内容。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-2627">Returns whether serialization processes should serialize the contents of the <see cref="P:System.Windows.ContentElement.CommandBindings" /> property on instances of this class.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f4180-2628">如果应当序列化 <see cref="P:System.Windows.ContentElement.CommandBindings" /> 属性值，则为 <see langword="true" />；否则为 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-2628">
              <see langword="true" /> if the <see cref="P:System.Windows.ContentElement.CommandBindings" /> property value should be serialized; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4180-2629">这将返回`true`如果<xref:System.Windows.ContentElement.CommandBindings%2A>本地设置。</span><span class="sxs-lookup"><span data-stu-id="f4180-2629">This will return `true` if <xref:System.Windows.ContentElement.CommandBindings%2A> is locally set.</span></span>  
  
 <span data-ttu-id="f4180-2630">这`ShouldSerialize`提供方法，因为<xref:System.Windows.UIElement.CommandBindings%2A>属性不具有简单的默认值。</span><span class="sxs-lookup"><span data-stu-id="f4180-2630">This `ShouldSerialize` method is provided because the <xref:System.Windows.UIElement.CommandBindings%2A> property does not have a simple default value.</span></span> <span data-ttu-id="f4180-2631">此方法指示属性是否已从其默认值。</span><span class="sxs-lookup"><span data-stu-id="f4180-2631">This method indicates whether the property has changed from its default value.</span></span> <span data-ttu-id="f4180-2632">如果你要开发一个设计器或开发您自己控件包含通常调用此方法<xref:System.Windows.UIElement>。</span><span class="sxs-lookup"><span data-stu-id="f4180-2632">You typically invoke this method if you are either developing a designer or developing your own control incorporating a <xref:System.Windows.UIElement>.</span></span>  
  
 <span data-ttu-id="f4180-2633">有关详细信息，请参阅[使用 ShouldSerialize 和重置方法定义默认值](~/docs/framework/winforms/controls/defining-default-values-with-the-shouldserialize-and-reset-methods.md)。</span><span class="sxs-lookup"><span data-stu-id="f4180-2633">For more information, see [Defining Default Values with the ShouldSerialize and Reset Methods](~/docs/framework/winforms/controls/defining-default-values-with-the-shouldserialize-and-reset-methods.md).</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeInputBindings">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeInputBindings ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeInputBindings() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.ShouldSerializeInputBindings" />
      <MemberSignature Language="VB.NET" Value="Public Function ShouldSerializeInputBindings () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ShouldSerializeInputBindings();" />
      <MemberSignature Language="F#" Value="member this.ShouldSerializeInputBindings : unit -&gt; bool" Usage="contentElement.ShouldSerializeInputBindings " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="f4180-2634">返回序列化进程是否应在此类的实例上序列化 <see cref="P:System.Windows.ContentElement.InputBindings" /> 属性的内容。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-2634">Returns whether serialization processes should serialize the contents of the <see cref="P:System.Windows.ContentElement.InputBindings" /> property on instances of this class.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f4180-2635">如果应当序列化 <see cref="P:System.Windows.ContentElement.InputBindings" /> 属性值，则为 <see langword="true" />；否则为 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-2635">
              <see langword="true" /> if the <see cref="P:System.Windows.ContentElement.InputBindings" /> property value should be serialized; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4180-2636">这将返回`true`如果<xref:System.Windows.ContentElement.InputBindings%2A>本地设置。</span><span class="sxs-lookup"><span data-stu-id="f4180-2636">This will return `true` if <xref:System.Windows.ContentElement.InputBindings%2A> is locally set.</span></span>  
  
 <span data-ttu-id="f4180-2637">这`ShouldSerialize`提供方法，因为<xref:System.Windows.UIElement.InputBindings%2A>属性不具有简单的默认值。</span><span class="sxs-lookup"><span data-stu-id="f4180-2637">This `ShouldSerialize` method is provided because the <xref:System.Windows.UIElement.InputBindings%2A> property does not have a simple default value.</span></span> <span data-ttu-id="f4180-2638">此方法指示属性是否已从其默认值。</span><span class="sxs-lookup"><span data-stu-id="f4180-2638">This method indicates whether the property has changed from its default value.</span></span> <span data-ttu-id="f4180-2639">如果你要开发一个设计器或开发您自己控件包含通常调用此方法<xref:System.Windows.UIElement>。</span><span class="sxs-lookup"><span data-stu-id="f4180-2639">You typically invoke this method if you are either developing a designer or developing your own control incorporating a <xref:System.Windows.UIElement>.</span></span>  
  
 <span data-ttu-id="f4180-2640">有关详细信息，请参阅[使用 ShouldSerialize 和重置方法定义默认值](~/docs/framework/winforms/controls/defining-default-values-with-the-shouldserialize-and-reset-methods.md)。</span><span class="sxs-lookup"><span data-stu-id="f4180-2640">For more information, see [Defining Default Values with the ShouldSerialize and Reset Methods](~/docs/framework/winforms/controls/defining-default-values-with-the-shouldserialize-and-reset-methods.md).</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusButtonDown">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusButtonEventHandler StylusButtonDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusButtonEventHandler StylusButtonDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.StylusButtonDown" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event StylusButtonDown As StylusButtonEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusButtonEventHandler ^ StylusButtonDown;" />
      <MemberSignature Language="F#" Value="member this.StylusButtonDown : System.Windows.Input.StylusButtonEventHandler " Usage="member this.StylusButtonDown : System.Windows.Input.StylusButtonEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.StylusButtonDown</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f4180-2641">在指针位于此元素上并且按下触笔按钮时发生。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-2641">Occurs when the stylus button is pressed while the pointer is over this element.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4180-2642">此事件创建一个别名<xref:System.Windows.Input.Stylus.StylusButtonDown?displayProperty=nameWithType>附加事件对于此类，以便<xref:System.Windows.ContentElement.StylusButtonDown>属于类的成员列出时<xref:System.Windows.ContentElement>作为基元素继承。</span><span class="sxs-lookup"><span data-stu-id="f4180-2642">This event creates an alias for the <xref:System.Windows.Input.Stylus.StylusButtonDown?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.StylusButtonDown> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="f4180-2643">事件处理程序附加到<xref:System.Windows.ContentElement.StylusButtonDown>事件附加到基础<xref:System.Windows.Input.Stylus.StylusButtonDown?displayProperty=nameWithType>附加事件，并接收相同的事件数据实例。</span><span class="sxs-lookup"><span data-stu-id="f4180-2643">Event handlers that are attached to the <xref:System.Windows.ContentElement.StylusButtonDown> event are attached to the underlying <xref:System.Windows.Input.Stylus.StylusButtonDown?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
 <span data-ttu-id="f4180-2644">触摸、 鼠标和触笔输入中的特定关系存在。</span><span class="sxs-lookup"><span data-stu-id="f4180-2644">Touch, mouse, and stylus input exist in a particular relationship.</span></span> <span data-ttu-id="f4180-2645">有关详细信息，请参阅[输入概述](~/docs/framework/wpf/advanced/input-overview.md)。</span><span class="sxs-lookup"><span data-stu-id="f4180-2645">For more information, see [Input Overview](~/docs/framework/wpf/advanced/input-overview.md).</span></span>  
  
<a name="routedEventInfo_StylusButtonDown"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="f4180-2646">路由事件信息</span><span class="sxs-lookup"><span data-stu-id="f4180-2646">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="f4180-2647">标识符字段</span><span class="sxs-lookup"><span data-stu-id="f4180-2647">Identifier field</span></span>|<xref:System.Windows.ContentElement.StylusButtonDownEvent>|  
|<span data-ttu-id="f4180-2648">路由策略</span><span class="sxs-lookup"><span data-stu-id="f4180-2648">Routing strategy</span></span>|<span data-ttu-id="f4180-2649">浮升</span><span class="sxs-lookup"><span data-stu-id="f4180-2649">Bubbling</span></span>|  
|<span data-ttu-id="f4180-2650">委托</span><span class="sxs-lookup"><span data-stu-id="f4180-2650">Delegate</span></span>|<xref:System.Windows.Input.StylusButtonEventHandler>|  
  
-   <span data-ttu-id="f4180-2651">相应的隧道事件是<xref:System.Windows.ContentElement.PreviewStylusButtonDown>。</span><span class="sxs-lookup"><span data-stu-id="f4180-2651">The corresponding tunneling event is <xref:System.Windows.ContentElement.PreviewStylusButtonDown>.</span></span>  
  
-   <span data-ttu-id="f4180-2652">重写<xref:System.Windows.ContentElement.OnStylusButtonDown%2A>实现类处理此事件在派生类中。</span><span class="sxs-lookup"><span data-stu-id="f4180-2652">Override <xref:System.Windows.ContentElement.OnStylusButtonDown%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewStylusButtonDown" />
      </Docs>
    </Member>
    <Member MemberName="StylusButtonDownEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent StylusButtonDownEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent StylusButtonDownEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.StylusButtonDownEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly StylusButtonDownEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ StylusButtonDownEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable StylusButtonDownEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.StylusButtonDownEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f4180-2653">标识 <see cref="E:System.Windows.ContentElement.StylusButtonDown" /> 路由事件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-2653">Identifies the <see cref="E:System.Windows.ContentElement.StylusButtonDown" /> routed event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4180-2654">在注册路由事件时创建路由事件标识符。</span><span class="sxs-lookup"><span data-stu-id="f4180-2654">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="f4180-2655">这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。</span><span class="sxs-lookup"><span data-stu-id="f4180-2655">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="f4180-2656">可以使用这些标识符添加类处理程序。</span><span class="sxs-lookup"><span data-stu-id="f4180-2656">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="f4180-2657">有关注册路由事件的更多信息，请参见 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="f4180-2657">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="f4180-2658">有关使用路由事件标识符添加类处理程序的更多信息，请参见 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="f4180-2658">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusButtonUp">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusButtonEventHandler StylusButtonUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusButtonEventHandler StylusButtonUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.StylusButtonUp" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event StylusButtonUp As StylusButtonEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusButtonEventHandler ^ StylusButtonUp;" />
      <MemberSignature Language="F#" Value="member this.StylusButtonUp : System.Windows.Input.StylusButtonEventHandler " Usage="member this.StylusButtonUp : System.Windows.Input.StylusButtonEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.StylusButtonUp</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f4180-2659">在指针位于此元素上并且松开触笔按钮时发生。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-2659">Occurs when the stylus button is released while the pointer is over this element.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4180-2660">此事件创建一个别名<xref:System.Windows.Input.Stylus.StylusButtonUp?displayProperty=nameWithType>附加事件对于此类，以便<xref:System.Windows.ContentElement.StylusButtonUp>属于类的成员列出时<xref:System.Windows.ContentElement>作为基元素继承。</span><span class="sxs-lookup"><span data-stu-id="f4180-2660">This event creates an alias for the <xref:System.Windows.Input.Stylus.StylusButtonUp?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.StylusButtonUp> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="f4180-2661">事件处理程序附加到<xref:System.Windows.ContentElement.StylusButtonUp>事件附加到基础<xref:System.Windows.Input.Stylus.StylusButtonUp?displayProperty=nameWithType>附加事件，并接收相同的事件数据实例。</span><span class="sxs-lookup"><span data-stu-id="f4180-2661">Event handlers that are attached to the <xref:System.Windows.ContentElement.StylusButtonUp> event are attached to the underlying <xref:System.Windows.Input.Stylus.StylusButtonUp?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
 <span data-ttu-id="f4180-2662">触摸、 鼠标和触笔输入中的特定关系存在。</span><span class="sxs-lookup"><span data-stu-id="f4180-2662">Touch, mouse, and stylus input exist in a particular relationship.</span></span> <span data-ttu-id="f4180-2663">有关详细信息，请参阅[输入概述](~/docs/framework/wpf/advanced/input-overview.md)。</span><span class="sxs-lookup"><span data-stu-id="f4180-2663">For more information, see [Input Overview](~/docs/framework/wpf/advanced/input-overview.md).</span></span>  
  
<a name="routedEventInfo_StylusButtonUp"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="f4180-2664">路由事件信息</span><span class="sxs-lookup"><span data-stu-id="f4180-2664">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="f4180-2665">标识符字段</span><span class="sxs-lookup"><span data-stu-id="f4180-2665">Identifier field</span></span>|<xref:System.Windows.ContentElement.StylusButtonUpEvent>|  
|<span data-ttu-id="f4180-2666">路由策略</span><span class="sxs-lookup"><span data-stu-id="f4180-2666">Routing strategy</span></span>|<span data-ttu-id="f4180-2667">浮升</span><span class="sxs-lookup"><span data-stu-id="f4180-2667">Bubbling</span></span>|  
|<span data-ttu-id="f4180-2668">委托</span><span class="sxs-lookup"><span data-stu-id="f4180-2668">Delegate</span></span>|<xref:System.Windows.Input.StylusButtonEventHandler>|  
  
-   <span data-ttu-id="f4180-2669">相应的隧道事件是<xref:System.Windows.ContentElement.PreviewStylusButtonUp>。</span><span class="sxs-lookup"><span data-stu-id="f4180-2669">The corresponding tunneling event is <xref:System.Windows.ContentElement.PreviewStylusButtonUp>.</span></span>  
  
-   <span data-ttu-id="f4180-2670">重写<xref:System.Windows.ContentElement.OnStylusButtonUp%2A>实现类处理此事件在派生类中。</span><span class="sxs-lookup"><span data-stu-id="f4180-2670">Override <xref:System.Windows.ContentElement.OnStylusButtonUp%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewStylusButtonUp" />
      </Docs>
    </Member>
    <Member MemberName="StylusButtonUpEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent StylusButtonUpEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent StylusButtonUpEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.StylusButtonUpEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly StylusButtonUpEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ StylusButtonUpEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable StylusButtonUpEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.StylusButtonUpEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f4180-2671">标识 <see cref="E:System.Windows.ContentElement.StylusButtonUp" /> 路由事件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-2671">Identifies the <see cref="E:System.Windows.ContentElement.StylusButtonUp" /> routed event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4180-2672">在注册路由事件时创建路由事件标识符。</span><span class="sxs-lookup"><span data-stu-id="f4180-2672">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="f4180-2673">这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。</span><span class="sxs-lookup"><span data-stu-id="f4180-2673">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="f4180-2674">可以使用这些标识符添加类处理程序。</span><span class="sxs-lookup"><span data-stu-id="f4180-2674">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="f4180-2675">有关注册路由事件的更多信息，请参见 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="f4180-2675">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="f4180-2676">有关使用路由事件标识符添加类处理程序的更多信息，请参见 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="f4180-2676">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusDown">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusDownEventHandler StylusDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusDownEventHandler StylusDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.StylusDown" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event StylusDown As StylusDownEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusDownEventHandler ^ StylusDown;" />
      <MemberSignature Language="F#" Value="member this.StylusDown : System.Windows.Input.StylusDownEventHandler " Usage="member this.StylusDown : System.Windows.Input.StylusDownEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.StylusDown</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusDownEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f4180-2677">在触笔位于此元素上且同时触及数字化器时发生。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-2677">Occurs when the stylus touches the digitizer while the stylus is over this element.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4180-2678">此事件创建一个别名<xref:System.Windows.Input.Stylus.StylusDown?displayProperty=nameWithType>附加事件对于此类，以便<xref:System.Windows.ContentElement.StylusDown>属于类的成员列出时<xref:System.Windows.ContentElement>作为基元素继承。</span><span class="sxs-lookup"><span data-stu-id="f4180-2678">This event creates an alias for the <xref:System.Windows.Input.Stylus.StylusDown?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.StylusDown> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="f4180-2679">事件处理程序附加到<xref:System.Windows.ContentElement.StylusDown>事件附加到基础<xref:System.Windows.Input.Stylus.StylusDown?displayProperty=nameWithType>附加事件，并接收相同的事件数据实例。</span><span class="sxs-lookup"><span data-stu-id="f4180-2679">Event handlers that are attached to the <xref:System.Windows.ContentElement.StylusDown> event are attached to the underlying <xref:System.Windows.Input.Stylus.StylusDown?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
 <span data-ttu-id="f4180-2680">触摸、 鼠标和触笔输入中的特定关系存在。</span><span class="sxs-lookup"><span data-stu-id="f4180-2680">Touch, mouse, and stylus input exist in a particular relationship.</span></span> <span data-ttu-id="f4180-2681">有关详细信息，请参阅[输入概述](~/docs/framework/wpf/advanced/input-overview.md)。</span><span class="sxs-lookup"><span data-stu-id="f4180-2681">For more information, see [Input Overview](~/docs/framework/wpf/advanced/input-overview.md).</span></span>  
  
<a name="routedEventInfo_StylusDown"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="f4180-2682">路由事件信息</span><span class="sxs-lookup"><span data-stu-id="f4180-2682">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="f4180-2683">标识符字段</span><span class="sxs-lookup"><span data-stu-id="f4180-2683">Identifier field</span></span>|<xref:System.Windows.ContentElement.StylusDownEvent>|  
|<span data-ttu-id="f4180-2684">路由策略</span><span class="sxs-lookup"><span data-stu-id="f4180-2684">Routing strategy</span></span>|<span data-ttu-id="f4180-2685">浮升</span><span class="sxs-lookup"><span data-stu-id="f4180-2685">Bubbling</span></span>|  
|<span data-ttu-id="f4180-2686">委托</span><span class="sxs-lookup"><span data-stu-id="f4180-2686">Delegate</span></span>|<xref:System.Windows.Input.StylusDownEventHandler>|  
  
-   <span data-ttu-id="f4180-2687">相应的隧道事件是<xref:System.Windows.ContentElement.PreviewStylusDown>。</span><span class="sxs-lookup"><span data-stu-id="f4180-2687">The corresponding tunneling event is <xref:System.Windows.ContentElement.PreviewStylusDown>.</span></span>  
  
-   <span data-ttu-id="f4180-2688">重写<xref:System.Windows.ContentElement.OnStylusDown%2A>实现类处理此事件在派生类中。</span><span class="sxs-lookup"><span data-stu-id="f4180-2688">Override <xref:System.Windows.ContentElement.OnStylusDown%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusDownEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent StylusDownEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent StylusDownEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.StylusDownEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly StylusDownEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ StylusDownEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable StylusDownEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.StylusDownEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f4180-2689">标识 <see cref="E:System.Windows.ContentElement.StylusDown" /> 路由事件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-2689">Identifies the <see cref="E:System.Windows.ContentElement.StylusDown" /> routed event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4180-2690">在注册路由事件时创建路由事件标识符。</span><span class="sxs-lookup"><span data-stu-id="f4180-2690">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="f4180-2691">这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。</span><span class="sxs-lookup"><span data-stu-id="f4180-2691">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="f4180-2692">可以使用这些标识符添加类处理程序。</span><span class="sxs-lookup"><span data-stu-id="f4180-2692">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="f4180-2693">有关注册路由事件的更多信息，请参见 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="f4180-2693">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="f4180-2694">有关使用路由事件标识符添加类处理程序的更多信息，请参见 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="f4180-2694">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusEnter">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusEventHandler StylusEnter;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusEventHandler StylusEnter" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.StylusEnter" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event StylusEnter As StylusEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusEventHandler ^ StylusEnter;" />
      <MemberSignature Language="F#" Value="member this.StylusEnter : System.Windows.Input.StylusEventHandler " Usage="member this.StylusEnter : System.Windows.Input.StylusEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.StylusEnter</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f4180-2695">在触笔进入此元素的边界时发生。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-2695">Occurs when the stylus enters the bounds of this element.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4180-2696"><xref:System.Windows.ContentElement.StylusEnter> 是[路由事件概述](~/docs/framework/wpf/advanced/routed-events-overview.md)，它使用直接事件处理路由策略。</span><span class="sxs-lookup"><span data-stu-id="f4180-2696"><xref:System.Windows.ContentElement.StylusEnter> is a [Routed Events Overview](~/docs/framework/wpf/advanced/routed-events-overview.md) that uses the direct event handling routing strategy.</span></span> <span data-ttu-id="f4180-2697">直接路由的事件不会引发在路由过程;相反，它们被处理的同一元素中引发位置。</span><span class="sxs-lookup"><span data-stu-id="f4180-2697">Direct routed events are not raised along a route; instead, they are handled in the same element where they are raised.</span></span> <span data-ttu-id="f4180-2698">但是，它们启用了路由的事件的行为，如在样式中的事件触发的其他方面。</span><span class="sxs-lookup"><span data-stu-id="f4180-2698">However, they do enable other aspects of routed event behavior, such as event triggers in styles.</span></span>  
  
 <span data-ttu-id="f4180-2699">尽管<xref:System.Windows.ContentElement.StylusEnter>跟踪当触笔进入的边界的元素，此事件能够更确切地报告<xref:System.Windows.ContentElement.IsStylusOver%2A>属性值已从`false`到`true`此元素上。</span><span class="sxs-lookup"><span data-stu-id="f4180-2699">Although <xref:System.Windows.ContentElement.StylusEnter> tracks when the stylus enters the bounds of an element, this event more literally reports that the <xref:System.Windows.ContentElement.IsStylusOver%2A> property value has changed from `false` to `true` on this element.</span></span>  
  
 <span data-ttu-id="f4180-2700">此事件创建一个别名<xref:System.Windows.Input.Stylus.StylusEnter?displayProperty=nameWithType>附加事件对于此类，以便<xref:System.Windows.ContentElement.StylusEnter>属于类的成员列出时<xref:System.Windows.ContentElement>作为基元素继承。</span><span class="sxs-lookup"><span data-stu-id="f4180-2700">This event creates an alias for the <xref:System.Windows.Input.Stylus.StylusEnter?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.StylusEnter> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="f4180-2701">事件处理程序附加到<xref:System.Windows.ContentElement.StylusEnter>事件附加到基础<xref:System.Windows.Input.Stylus.StylusEnter?displayProperty=nameWithType>附加事件，并接收相同的事件数据实例。</span><span class="sxs-lookup"><span data-stu-id="f4180-2701">Event handlers that are attached to the <xref:System.Windows.ContentElement.StylusEnter> event are attached to the underlying <xref:System.Windows.Input.Stylus.StylusEnter?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
 <span data-ttu-id="f4180-2702">触摸、 鼠标和触笔输入中的特定关系存在。</span><span class="sxs-lookup"><span data-stu-id="f4180-2702">Touch, mouse, and stylus input exist in a particular relationship.</span></span> <span data-ttu-id="f4180-2703">有关详细信息，请参阅[输入概述](~/docs/framework/wpf/advanced/input-overview.md)。</span><span class="sxs-lookup"><span data-stu-id="f4180-2703">For more information, see [Input Overview](~/docs/framework/wpf/advanced/input-overview.md).</span></span>  
  
<a name="routedEventInfo_StylusEnter"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="f4180-2704">路由事件信息</span><span class="sxs-lookup"><span data-stu-id="f4180-2704">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="f4180-2705">标识符字段</span><span class="sxs-lookup"><span data-stu-id="f4180-2705">Identifier field</span></span>|<xref:System.Windows.ContentElement.StylusEnterEvent>|  
|<span data-ttu-id="f4180-2706">路由策略</span><span class="sxs-lookup"><span data-stu-id="f4180-2706">Routing strategy</span></span>|<span data-ttu-id="f4180-2707">直接</span><span class="sxs-lookup"><span data-stu-id="f4180-2707">Direct</span></span>|  
|<span data-ttu-id="f4180-2708">委托</span><span class="sxs-lookup"><span data-stu-id="f4180-2708">Delegate</span></span>|<xref:System.Windows.Input.StylusEventHandler>|  
  
-   <span data-ttu-id="f4180-2709">重写<xref:System.Windows.ContentElement.OnStylusEnter%2A>实现类处理此事件在派生类中。</span><span class="sxs-lookup"><span data-stu-id="f4180-2709">Override <xref:System.Windows.ContentElement.OnStylusEnter%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusEnterEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent StylusEnterEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent StylusEnterEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.StylusEnterEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly StylusEnterEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ StylusEnterEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable StylusEnterEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.StylusEnterEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f4180-2710">标识 <see cref="E:System.Windows.ContentElement.StylusEnter" /> 路由事件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-2710">Identifies the <see cref="E:System.Windows.ContentElement.StylusEnter" /> routed event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4180-2711">在注册路由事件时创建路由事件标识符。</span><span class="sxs-lookup"><span data-stu-id="f4180-2711">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="f4180-2712">这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。</span><span class="sxs-lookup"><span data-stu-id="f4180-2712">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="f4180-2713">可以使用这些标识符添加类处理程序。</span><span class="sxs-lookup"><span data-stu-id="f4180-2713">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="f4180-2714">有关注册路由事件的更多信息，请参见 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="f4180-2714">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="f4180-2715">有关使用路由事件标识符添加类处理程序的更多信息，请参见 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="f4180-2715">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusInAirMove">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusEventHandler StylusInAirMove;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusEventHandler StylusInAirMove" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.StylusInAirMove" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event StylusInAirMove As StylusEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusEventHandler ^ StylusInAirMove;" />
      <MemberSignature Language="F#" Value="member this.StylusInAirMove : System.Windows.Input.StylusEventHandler " Usage="member this.StylusInAirMove : System.Windows.Input.StylusEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.StylusInAirMove</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f4180-2716">在触笔掠过元素但并未实际接触数字化器时发生。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-2716">Occurs when the stylus moves over an element without actually touching the digitizer.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4180-2717">此事件创建一个别名<xref:System.Windows.Input.Stylus.StylusInAirMove?displayProperty=nameWithType>附加事件对于此类，以便<xref:System.Windows.ContentElement.StylusInAirMove>属于类的成员列出时<xref:System.Windows.ContentElement>作为基元素继承。</span><span class="sxs-lookup"><span data-stu-id="f4180-2717">This event creates an alias for the <xref:System.Windows.Input.Stylus.StylusInAirMove?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.StylusInAirMove> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="f4180-2718">事件处理程序附加到<xref:System.Windows.ContentElement.StylusInAirMove>事件附加到基础<xref:System.Windows.Input.Stylus.StylusInAirMove?displayProperty=nameWithType>附加事件，并接收相同的事件数据实例。</span><span class="sxs-lookup"><span data-stu-id="f4180-2718">Event handlers that are attached to the <xref:System.Windows.ContentElement.StylusInAirMove> event are attached to the underlying <xref:System.Windows.Input.Stylus.StylusInAirMove?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
 <span data-ttu-id="f4180-2719">触摸、 鼠标和触笔输入中的特定关系存在。</span><span class="sxs-lookup"><span data-stu-id="f4180-2719">Touch, mouse, and stylus input exist in a particular relationship.</span></span> <span data-ttu-id="f4180-2720">有关详细信息，请参阅[输入概述](~/docs/framework/wpf/advanced/input-overview.md)。</span><span class="sxs-lookup"><span data-stu-id="f4180-2720">For more information, see [Input Overview](~/docs/framework/wpf/advanced/input-overview.md).</span></span>  
  
<a name="routedEventInfo_StylusInAirMove"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="f4180-2721">路由事件信息</span><span class="sxs-lookup"><span data-stu-id="f4180-2721">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="f4180-2722">标识符字段</span><span class="sxs-lookup"><span data-stu-id="f4180-2722">Identifier field</span></span>|<xref:System.Windows.ContentElement.StylusInAirMoveEvent>|  
|<span data-ttu-id="f4180-2723">路由策略</span><span class="sxs-lookup"><span data-stu-id="f4180-2723">Routing strategy</span></span>|<span data-ttu-id="f4180-2724">浮升</span><span class="sxs-lookup"><span data-stu-id="f4180-2724">Bubbling</span></span>|  
|<span data-ttu-id="f4180-2725">委托</span><span class="sxs-lookup"><span data-stu-id="f4180-2725">Delegate</span></span>|<xref:System.Windows.Input.StylusEventHandler>|  
  
-   <span data-ttu-id="f4180-2726">相应的隧道事件是<xref:System.Windows.ContentElement.PreviewStylusInAirMove>。</span><span class="sxs-lookup"><span data-stu-id="f4180-2726">The corresponding tunneling event is <xref:System.Windows.ContentElement.PreviewStylusInAirMove>.</span></span>  
  
-   <span data-ttu-id="f4180-2727">重写<xref:System.Windows.ContentElement.OnStylusInAirMove%2A>实现类处理此事件在派生类中。</span><span class="sxs-lookup"><span data-stu-id="f4180-2727">Override <xref:System.Windows.ContentElement.OnStylusInAirMove%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusInAirMoveEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent StylusInAirMoveEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent StylusInAirMoveEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.StylusInAirMoveEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly StylusInAirMoveEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ StylusInAirMoveEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable StylusInAirMoveEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.StylusInAirMoveEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f4180-2728">标识 <see cref="E:System.Windows.ContentElement.StylusInAirMove" /> 路由事件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-2728">Identifies the <see cref="E:System.Windows.ContentElement.StylusInAirMove" /> routed event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4180-2729">在注册路由事件时创建路由事件标识符。</span><span class="sxs-lookup"><span data-stu-id="f4180-2729">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="f4180-2730">这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。</span><span class="sxs-lookup"><span data-stu-id="f4180-2730">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="f4180-2731">可以使用这些标识符添加类处理程序。</span><span class="sxs-lookup"><span data-stu-id="f4180-2731">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="f4180-2732">有关注册路由事件的更多信息，请参见 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="f4180-2732">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="f4180-2733">有关使用路由事件标识符添加类处理程序的更多信息，请参见 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="f4180-2733">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusInRange">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusEventHandler StylusInRange;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusEventHandler StylusInRange" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.StylusInRange" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event StylusInRange As StylusEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusEventHandler ^ StylusInRange;" />
      <MemberSignature Language="F#" Value="member this.StylusInRange : System.Windows.Input.StylusEventHandler " Usage="member this.StylusInRange : System.Windows.Input.StylusEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.StylusInRange</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f4180-2734">在触笔位于此元素上并且触笔与数字化器之间的距离近到足以检测到触笔时发生。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-2734">Occurs when the stylus is close enough to the digitizer to be detected, while over this element.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4180-2735">此事件创建一个别名<xref:System.Windows.Input.Stylus.StylusInRange?displayProperty=nameWithType>附加事件对于此类，以便<xref:System.Windows.ContentElement.StylusInRange>属于类的成员列出时<xref:System.Windows.ContentElement>作为基元素继承。</span><span class="sxs-lookup"><span data-stu-id="f4180-2735">This event creates an alias for the <xref:System.Windows.Input.Stylus.StylusInRange?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.StylusInRange> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="f4180-2736">事件处理程序附加到<xref:System.Windows.ContentElement.StylusInRange>事件附加到基础<xref:System.Windows.Input.Stylus.StylusInRange?displayProperty=nameWithType>附加事件，并接收相同的事件数据实例。</span><span class="sxs-lookup"><span data-stu-id="f4180-2736">Event handlers that are attached to the <xref:System.Windows.ContentElement.StylusInRange> event are attached to the underlying <xref:System.Windows.Input.Stylus.StylusInRange?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
 <span data-ttu-id="f4180-2737">触摸、 鼠标和触笔输入中的特定关系存在。</span><span class="sxs-lookup"><span data-stu-id="f4180-2737">Touch, mouse, and stylus input exist in a particular relationship.</span></span> <span data-ttu-id="f4180-2738">有关详细信息，请参阅[输入概述](~/docs/framework/wpf/advanced/input-overview.md)。</span><span class="sxs-lookup"><span data-stu-id="f4180-2738">For more information, see [Input Overview](~/docs/framework/wpf/advanced/input-overview.md).</span></span>  
  
<a name="routedEventInfo_StylusInRange"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="f4180-2739">路由事件信息</span><span class="sxs-lookup"><span data-stu-id="f4180-2739">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="f4180-2740">标识符字段</span><span class="sxs-lookup"><span data-stu-id="f4180-2740">Identifier field</span></span>|<xref:System.Windows.ContentElement.StylusInRangeEvent>|  
|<span data-ttu-id="f4180-2741">路由策略</span><span class="sxs-lookup"><span data-stu-id="f4180-2741">Routing strategy</span></span>|<span data-ttu-id="f4180-2742">浮升</span><span class="sxs-lookup"><span data-stu-id="f4180-2742">Bubbling</span></span>|  
|<span data-ttu-id="f4180-2743">委托</span><span class="sxs-lookup"><span data-stu-id="f4180-2743">Delegate</span></span>|<xref:System.Windows.Input.StylusEventHandler>|  
  
-   <span data-ttu-id="f4180-2744">相应的隧道事件是<xref:System.Windows.ContentElement.PreviewStylusInRange>。</span><span class="sxs-lookup"><span data-stu-id="f4180-2744">The corresponding tunneling event is <xref:System.Windows.ContentElement.PreviewStylusInRange>.</span></span>  
  
-   <span data-ttu-id="f4180-2745">重写<xref:System.Windows.ContentElement.OnStylusInRange%2A>实现类处理此事件在派生类中。</span><span class="sxs-lookup"><span data-stu-id="f4180-2745">Override <xref:System.Windows.ContentElement.OnStylusInRange%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusInRangeEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent StylusInRangeEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent StylusInRangeEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.StylusInRangeEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly StylusInRangeEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ StylusInRangeEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable StylusInRangeEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.StylusInRangeEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f4180-2746">标识 <see cref="E:System.Windows.ContentElement.StylusInRange" /> 路由事件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-2746">Identifies the <see cref="E:System.Windows.ContentElement.StylusInRange" /> routed event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4180-2747">在注册路由事件时创建路由事件标识符。</span><span class="sxs-lookup"><span data-stu-id="f4180-2747">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="f4180-2748">这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。</span><span class="sxs-lookup"><span data-stu-id="f4180-2748">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="f4180-2749">可以使用这些标识符添加类处理程序。</span><span class="sxs-lookup"><span data-stu-id="f4180-2749">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="f4180-2750">有关注册路由事件的更多信息，请参见 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="f4180-2750">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="f4180-2751">有关使用路由事件标识符添加类处理程序的更多信息，请参见 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="f4180-2751">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusLeave">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusEventHandler StylusLeave;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusEventHandler StylusLeave" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.StylusLeave" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event StylusLeave As StylusEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusEventHandler ^ StylusLeave;" />
      <MemberSignature Language="F#" Value="member this.StylusLeave : System.Windows.Input.StylusEventHandler " Usage="member this.StylusLeave : System.Windows.Input.StylusEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.StylusLeave</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f4180-2752">在触笔离开元素的边界时发生。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-2752">Occurs when the stylus leaves the bounds of the element.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4180-2753"><xref:System.Windows.ContentElement.StylusLeave> 是[路由事件概述](~/docs/framework/wpf/advanced/routed-events-overview.md)，它使用直接事件处理路由策略。</span><span class="sxs-lookup"><span data-stu-id="f4180-2753"><xref:System.Windows.ContentElement.StylusLeave> is a [Routed Events Overview](~/docs/framework/wpf/advanced/routed-events-overview.md) that uses the direct event handling routing strategy.</span></span> <span data-ttu-id="f4180-2754">直接路由的事件不会引发在路由过程;相反，它们被处理的同一元素中引发位置。</span><span class="sxs-lookup"><span data-stu-id="f4180-2754">Direct routed events are not raised along a route; instead, they are handled in the same element where they are raised.</span></span> <span data-ttu-id="f4180-2755">但是，它们启用了路由的事件的行为，如在样式中的事件触发的其他方面。</span><span class="sxs-lookup"><span data-stu-id="f4180-2755">However, they do enable other aspects of routed event behavior, such as event triggers in styles.</span></span>  
  
 <span data-ttu-id="f4180-2756">尽管<xref:System.Windows.ContentElement.StylusLeave>跟踪当触笔离开元素，此事件的边界的详细信息按原义报告<xref:System.Windows.ContentElement.IsStylusOver%2A>属性值已从`true`到`false`此元素上。</span><span class="sxs-lookup"><span data-stu-id="f4180-2756">Although <xref:System.Windows.ContentElement.StylusLeave> tracks when the stylus leaves the bounds of an element, this event more literally reports that the <xref:System.Windows.ContentElement.IsStylusOver%2A> property value has changed from `true` to `false` on this element.</span></span>  
  
 <span data-ttu-id="f4180-2757">此事件创建一个别名<xref:System.Windows.Input.Stylus.StylusLeave?displayProperty=nameWithType>附加事件对于此类，以便<xref:System.Windows.ContentElement.StylusLeave>属于类的成员列出时<xref:System.Windows.ContentElement>作为基元素继承。</span><span class="sxs-lookup"><span data-stu-id="f4180-2757">This event creates an alias for the <xref:System.Windows.Input.Stylus.StylusLeave?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.StylusLeave> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="f4180-2758">事件处理程序附加到<xref:System.Windows.ContentElement.StylusLeave>事件附加到基础<xref:System.Windows.Input.Stylus.StylusLeave?displayProperty=nameWithType>附加事件，并接收相同的事件数据实例。</span><span class="sxs-lookup"><span data-stu-id="f4180-2758">Event handlers that are attached to the <xref:System.Windows.ContentElement.StylusLeave> event are attached to the underlying <xref:System.Windows.Input.Stylus.StylusLeave?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
 <span data-ttu-id="f4180-2759">触摸、 鼠标和触笔输入中的特定关系存在。</span><span class="sxs-lookup"><span data-stu-id="f4180-2759">Touch, mouse, and stylus input exist in a particular relationship.</span></span> <span data-ttu-id="f4180-2760">有关详细信息，请参阅[输入概述](~/docs/framework/wpf/advanced/input-overview.md)。</span><span class="sxs-lookup"><span data-stu-id="f4180-2760">For more information, see [Input Overview](~/docs/framework/wpf/advanced/input-overview.md).</span></span>  
  
<a name="routedEventInfo_StylusLeave"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="f4180-2761">路由事件信息</span><span class="sxs-lookup"><span data-stu-id="f4180-2761">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="f4180-2762">标识符字段</span><span class="sxs-lookup"><span data-stu-id="f4180-2762">Identifier field</span></span>|<xref:System.Windows.ContentElement.StylusLeaveEvent>|  
|<span data-ttu-id="f4180-2763">路由策略</span><span class="sxs-lookup"><span data-stu-id="f4180-2763">Routing strategy</span></span>|<span data-ttu-id="f4180-2764">直接</span><span class="sxs-lookup"><span data-stu-id="f4180-2764">Direct</span></span>|  
|<span data-ttu-id="f4180-2765">委托</span><span class="sxs-lookup"><span data-stu-id="f4180-2765">Delegate</span></span>|<xref:System.Windows.Input.StylusEventHandler>|  
  
-   <span data-ttu-id="f4180-2766">重写<xref:System.Windows.ContentElement.OnStylusLeave%2A>实现类处理此事件在派生类中。</span><span class="sxs-lookup"><span data-stu-id="f4180-2766">Override <xref:System.Windows.ContentElement.OnStylusLeave%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusLeaveEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent StylusLeaveEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent StylusLeaveEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.StylusLeaveEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly StylusLeaveEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ StylusLeaveEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable StylusLeaveEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.StylusLeaveEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f4180-2767">标识 <see cref="E:System.Windows.ContentElement.StylusLeave" /> 路由事件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-2767">Identifies the <see cref="E:System.Windows.ContentElement.StylusLeave" /> routed event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4180-2768">在注册路由事件时创建路由事件标识符。</span><span class="sxs-lookup"><span data-stu-id="f4180-2768">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="f4180-2769">这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。</span><span class="sxs-lookup"><span data-stu-id="f4180-2769">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="f4180-2770">可以使用这些标识符添加类处理程序。</span><span class="sxs-lookup"><span data-stu-id="f4180-2770">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="f4180-2771">有关注册路由事件的更多信息，请参见 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="f4180-2771">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="f4180-2772">有关使用路由事件标识符添加类处理程序的更多信息，请参见 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="f4180-2772">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusMove">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusEventHandler StylusMove;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusEventHandler StylusMove" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.StylusMove" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event StylusMove As StylusEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusEventHandler ^ StylusMove;" />
      <MemberSignature Language="F#" Value="member this.StylusMove : System.Windows.Input.StylusEventHandler " Usage="member this.StylusMove : System.Windows.Input.StylusEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.StylusMove</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f4180-2773">在触笔移到此元素上时发生。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-2773">Occurs when the stylus moves over this element.</span>
          </span>
          <span data-ttu-id="f4180-2774">触笔必须在位于数字化器上时移动，才会引发此事件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-2774">The stylus must move while on the digitizer to raise this event.</span>
          </span>
          <span data-ttu-id="f4180-2775">否则，将改为引发 <see cref="E:System.Windows.ContentElement.StylusInAirMove" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-2775">Otherwise, <see cref="E:System.Windows.ContentElement.StylusInAirMove" /> is raised instead.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4180-2776">此事件创建一个别名<xref:System.Windows.Input.Stylus.StylusMove?displayProperty=nameWithType>附加事件对于此类，以便<xref:System.Windows.ContentElement.StylusMove>属于类的成员列出时<xref:System.Windows.ContentElement>作为基元素继承。</span><span class="sxs-lookup"><span data-stu-id="f4180-2776">This event creates an alias for the <xref:System.Windows.Input.Stylus.StylusMove?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.StylusMove> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="f4180-2777">事件处理程序附加到<xref:System.Windows.ContentElement.StylusMove>事件附加到基础<xref:System.Windows.Input.Stylus.StylusMove?displayProperty=nameWithType>附加事件，并接收相同的事件数据实例。</span><span class="sxs-lookup"><span data-stu-id="f4180-2777">Event handlers that are attached to the <xref:System.Windows.ContentElement.StylusMove> event are attached to the underlying <xref:System.Windows.Input.Stylus.StylusMove?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
 <span data-ttu-id="f4180-2778">触摸、 鼠标和触笔输入中的特定关系存在。</span><span class="sxs-lookup"><span data-stu-id="f4180-2778">Touch, mouse, and stylus input exist in a particular relationship.</span></span> <span data-ttu-id="f4180-2779">有关详细信息，请参阅[输入概述](~/docs/framework/wpf/advanced/input-overview.md)。</span><span class="sxs-lookup"><span data-stu-id="f4180-2779">For more information, see [Input Overview](~/docs/framework/wpf/advanced/input-overview.md).</span></span>  
  
<a name="routedEventInfo_StylusMove"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="f4180-2780">路由事件信息</span><span class="sxs-lookup"><span data-stu-id="f4180-2780">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="f4180-2781">标识符字段</span><span class="sxs-lookup"><span data-stu-id="f4180-2781">Identifier field</span></span>|<xref:System.Windows.ContentElement.StylusMoveEvent>|  
|<span data-ttu-id="f4180-2782">路由策略</span><span class="sxs-lookup"><span data-stu-id="f4180-2782">Routing strategy</span></span>|<span data-ttu-id="f4180-2783">浮升</span><span class="sxs-lookup"><span data-stu-id="f4180-2783">Bubbling</span></span>|  
|<span data-ttu-id="f4180-2784">委托</span><span class="sxs-lookup"><span data-stu-id="f4180-2784">Delegate</span></span>|<xref:System.Windows.Input.StylusEventHandler>|  
  
-   <span data-ttu-id="f4180-2785">相应的隧道事件是<xref:System.Windows.ContentElement.PreviewStylusMove>。</span><span class="sxs-lookup"><span data-stu-id="f4180-2785">The corresponding tunneling event is <xref:System.Windows.ContentElement.PreviewStylusMove>.</span></span>  
  
-   <span data-ttu-id="f4180-2786">重写<xref:System.Windows.ContentElement.OnStylusMove%2A>实现类处理此事件在派生类中。</span><span class="sxs-lookup"><span data-stu-id="f4180-2786">Override <xref:System.Windows.ContentElement.OnStylusMove%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusMoveEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent StylusMoveEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent StylusMoveEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.StylusMoveEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly StylusMoveEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ StylusMoveEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable StylusMoveEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.StylusMoveEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f4180-2787">标识 <see cref="E:System.Windows.ContentElement.StylusMove" /> 路由事件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-2787">Identifies the <see cref="E:System.Windows.ContentElement.StylusMove" /> routed event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4180-2788">在注册路由事件时创建路由事件标识符。</span><span class="sxs-lookup"><span data-stu-id="f4180-2788">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="f4180-2789">这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。</span><span class="sxs-lookup"><span data-stu-id="f4180-2789">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="f4180-2790">可以使用这些标识符添加类处理程序。</span><span class="sxs-lookup"><span data-stu-id="f4180-2790">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="f4180-2791">有关注册路由事件的更多信息，请参见 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="f4180-2791">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="f4180-2792">有关使用路由事件标识符添加类处理程序的更多信息，请参见 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="f4180-2792">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusOutOfRange">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusEventHandler StylusOutOfRange;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusEventHandler StylusOutOfRange" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.StylusOutOfRange" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event StylusOutOfRange As StylusEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusEventHandler ^ StylusOutOfRange;" />
      <MemberSignature Language="F#" Value="member this.StylusOutOfRange : System.Windows.Input.StylusEventHandler " Usage="member this.StylusOutOfRange : System.Windows.Input.StylusEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.StylusOutOfRange</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f4180-2793">在触笔位于此元素上并且触笔与数字化器之间的距离太远以致无法检测到触笔时发生。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-2793">Occurs when the stylus is too far from the digitizer to be detected, while over this element.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4180-2794">此事件创建一个别名<xref:System.Windows.Input.Stylus.StylusOutOfRange?displayProperty=nameWithType>附加事件对于此类，以便<xref:System.Windows.ContentElement.StylusOutOfRange>属于类的成员列出时<xref:System.Windows.ContentElement>作为基元素继承。</span><span class="sxs-lookup"><span data-stu-id="f4180-2794">This event creates an alias for the <xref:System.Windows.Input.Stylus.StylusOutOfRange?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.StylusOutOfRange> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="f4180-2795">事件处理程序附加到<xref:System.Windows.ContentElement.StylusOutOfRange>事件附加到基础<xref:System.Windows.Input.Stylus.StylusOutOfRange?displayProperty=nameWithType>附加事件，并接收相同的事件数据实例。</span><span class="sxs-lookup"><span data-stu-id="f4180-2795">Event handlers that are attached to the <xref:System.Windows.ContentElement.StylusOutOfRange> event are attached to the underlying <xref:System.Windows.Input.Stylus.StylusOutOfRange?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
 <span data-ttu-id="f4180-2796">触摸、 鼠标和触笔输入中的特定关系存在。</span><span class="sxs-lookup"><span data-stu-id="f4180-2796">Touch, mouse, and stylus input exist in a particular relationship.</span></span> <span data-ttu-id="f4180-2797">有关详细信息，请参阅[输入概述](~/docs/framework/wpf/advanced/input-overview.md)。</span><span class="sxs-lookup"><span data-stu-id="f4180-2797">For more information, see [Input Overview](~/docs/framework/wpf/advanced/input-overview.md).</span></span>  
  
<a name="routedEventInfo_StylusOutOfRange"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="f4180-2798">路由事件信息</span><span class="sxs-lookup"><span data-stu-id="f4180-2798">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="f4180-2799">标识符字段</span><span class="sxs-lookup"><span data-stu-id="f4180-2799">Identifier field</span></span>|<xref:System.Windows.ContentElement.StylusOutOfRangeEvent>|  
|<span data-ttu-id="f4180-2800">路由策略</span><span class="sxs-lookup"><span data-stu-id="f4180-2800">Routing strategy</span></span>|<span data-ttu-id="f4180-2801">浮升</span><span class="sxs-lookup"><span data-stu-id="f4180-2801">Bubbling</span></span>|  
|<span data-ttu-id="f4180-2802">委托</span><span class="sxs-lookup"><span data-stu-id="f4180-2802">Delegate</span></span>|<xref:System.Windows.Input.StylusEventHandler>|  
  
-   <span data-ttu-id="f4180-2803">相应的隧道事件是<xref:System.Windows.ContentElement.PreviewStylusOutOfRange>。</span><span class="sxs-lookup"><span data-stu-id="f4180-2803">The corresponding tunneling event is <xref:System.Windows.ContentElement.PreviewStylusOutOfRange>.</span></span>  
  
-   <span data-ttu-id="f4180-2804">重写<xref:System.Windows.ContentElement.OnStylusOutOfRange%2A>实现类处理此事件在派生类中。</span><span class="sxs-lookup"><span data-stu-id="f4180-2804">Override <xref:System.Windows.ContentElement.OnStylusOutOfRange%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusOutOfRangeEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent StylusOutOfRangeEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent StylusOutOfRangeEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.StylusOutOfRangeEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly StylusOutOfRangeEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ StylusOutOfRangeEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable StylusOutOfRangeEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.StylusOutOfRangeEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f4180-2805">标识 <see cref="E:System.Windows.ContentElement.StylusOutOfRange" /> 路由事件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-2805">Identifies the <see cref="E:System.Windows.ContentElement.StylusOutOfRange" /> routed event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4180-2806">在注册路由事件时创建路由事件标识符。</span><span class="sxs-lookup"><span data-stu-id="f4180-2806">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="f4180-2807">这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。</span><span class="sxs-lookup"><span data-stu-id="f4180-2807">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="f4180-2808">可以使用这些标识符添加类处理程序。</span><span class="sxs-lookup"><span data-stu-id="f4180-2808">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="f4180-2809">有关注册路由事件的更多信息，请参见 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="f4180-2809">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="f4180-2810">有关使用路由事件标识符添加类处理程序的更多信息，请参见 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="f4180-2810">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusSystemGesture">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusSystemGestureEventHandler StylusSystemGesture;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusSystemGestureEventHandler StylusSystemGesture" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.StylusSystemGesture" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event StylusSystemGesture As StylusSystemGestureEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusSystemGestureEventHandler ^ StylusSystemGesture;" />
      <MemberSignature Language="F#" Value="member this.StylusSystemGesture : System.Windows.Input.StylusSystemGestureEventHandler " Usage="member this.StylusSystemGesture : System.Windows.Input.StylusSystemGestureEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.StylusSystemGesture</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusSystemGestureEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f4180-2811">在用户采用某一种触笔笔势时发生。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-2811">Occurs when a user performs one of several stylus gestures.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4180-2812">有关触笔笔势的详细信息，请参阅<xref:System.Windows.Input.SystemGesture>。</span><span class="sxs-lookup"><span data-stu-id="f4180-2812">For more information about stylus gestures, see <xref:System.Windows.Input.SystemGesture>.</span></span>  
  
 <span data-ttu-id="f4180-2813">此事件创建一个别名<xref:System.Windows.Input.Stylus.StylusSystemGesture?displayProperty=nameWithType>附加事件对于此类，以便<xref:System.Windows.ContentElement.StylusSystemGesture>属于类的成员列出时<xref:System.Windows.ContentElement>作为基元素继承。</span><span class="sxs-lookup"><span data-stu-id="f4180-2813">This event creates an alias for the <xref:System.Windows.Input.Stylus.StylusSystemGesture?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.StylusSystemGesture> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="f4180-2814">事件处理程序附加到<xref:System.Windows.ContentElement.StylusSystemGesture>事件附加到基础<xref:System.Windows.Input.Stylus.StylusSystemGesture?displayProperty=nameWithType>附加事件，并接收相同的事件数据实例。</span><span class="sxs-lookup"><span data-stu-id="f4180-2814">Event handlers that are attached to the <xref:System.Windows.ContentElement.StylusSystemGesture> event are attached to the underlying <xref:System.Windows.Input.Stylus.StylusSystemGesture?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
 <span data-ttu-id="f4180-2815">触摸、 鼠标和触笔输入中的特定关系存在。</span><span class="sxs-lookup"><span data-stu-id="f4180-2815">Touch, mouse, and stylus input exist in a particular relationship.</span></span> <span data-ttu-id="f4180-2816">有关详细信息，请参阅[输入概述](~/docs/framework/wpf/advanced/input-overview.md)。</span><span class="sxs-lookup"><span data-stu-id="f4180-2816">For more information, see [Input Overview](~/docs/framework/wpf/advanced/input-overview.md).</span></span>  
  
<a name="routedEventInfo_StylusSystemGesture"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="f4180-2817">路由事件信息</span><span class="sxs-lookup"><span data-stu-id="f4180-2817">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="f4180-2818">标识符字段</span><span class="sxs-lookup"><span data-stu-id="f4180-2818">Identifier field</span></span>|<xref:System.Windows.ContentElement.StylusSystemGestureEvent>|  
|<span data-ttu-id="f4180-2819">路由策略</span><span class="sxs-lookup"><span data-stu-id="f4180-2819">Routing strategy</span></span>|<span data-ttu-id="f4180-2820">浮升</span><span class="sxs-lookup"><span data-stu-id="f4180-2820">Bubbling</span></span>|  
|<span data-ttu-id="f4180-2821">委托</span><span class="sxs-lookup"><span data-stu-id="f4180-2821">Delegate</span></span>|<xref:System.Windows.Input.StylusSystemGestureEventHandler>|  
  
-   <span data-ttu-id="f4180-2822">相应的隧道事件是<xref:System.Windows.ContentElement.PreviewStylusSystemGesture>。</span><span class="sxs-lookup"><span data-stu-id="f4180-2822">The corresponding tunneling event is <xref:System.Windows.ContentElement.PreviewStylusSystemGesture>.</span></span>  
  
-   <span data-ttu-id="f4180-2823">重写<xref:System.Windows.ContentElement.OnStylusSystemGesture%2A>实现类处理此事件在派生类中。</span><span class="sxs-lookup"><span data-stu-id="f4180-2823">Override <xref:System.Windows.ContentElement.OnStylusSystemGesture%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusSystemGestureEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent StylusSystemGestureEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent StylusSystemGestureEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.StylusSystemGestureEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly StylusSystemGestureEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ StylusSystemGestureEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable StylusSystemGestureEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.StylusSystemGestureEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f4180-2824">标识 <see cref="E:System.Windows.ContentElement.StylusSystemGesture" /> 路由事件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-2824">Identifies the <see cref="E:System.Windows.ContentElement.StylusSystemGesture" /> routed event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4180-2825">在注册路由事件时创建路由事件标识符。</span><span class="sxs-lookup"><span data-stu-id="f4180-2825">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="f4180-2826">这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。</span><span class="sxs-lookup"><span data-stu-id="f4180-2826">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="f4180-2827">可以使用这些标识符添加类处理程序。</span><span class="sxs-lookup"><span data-stu-id="f4180-2827">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="f4180-2828">有关注册路由事件的更多信息，请参见 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="f4180-2828">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="f4180-2829">有关使用路由事件标识符添加类处理程序的更多信息，请参见 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="f4180-2829">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusUp">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusEventHandler StylusUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusEventHandler StylusUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.StylusUp" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event StylusUp As StylusEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusEventHandler ^ StylusUp;" />
      <MemberSignature Language="F#" Value="member this.StylusUp : System.Windows.Input.StylusEventHandler " Usage="member this.StylusUp : System.Windows.Input.StylusEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.StylusUp</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f4180-2830">当触笔位于此元素上并且用户将触笔抬离数字化器时发生。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-2830">Occurs when the user raises the stylus off the digitizer while it is over this element.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4180-2831">此事件创建一个别名<xref:System.Windows.Input.Stylus.StylusUp?displayProperty=nameWithType>附加事件对于此类，以便<xref:System.Windows.ContentElement.StylusUp>属于类的成员列出时<xref:System.Windows.ContentElement>作为基元素继承。</span><span class="sxs-lookup"><span data-stu-id="f4180-2831">This event creates an alias for the <xref:System.Windows.Input.Stylus.StylusUp?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.StylusUp> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="f4180-2832">事件处理程序附加到<xref:System.Windows.ContentElement.StylusUp>事件附加到基础<xref:System.Windows.Input.Stylus.StylusUp?displayProperty=nameWithType>附加事件，并接收相同的事件数据实例。</span><span class="sxs-lookup"><span data-stu-id="f4180-2832">Event handlers that are attached to the <xref:System.Windows.ContentElement.StylusUp> event are attached to the underlying <xref:System.Windows.Input.Stylus.StylusUp?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
 <span data-ttu-id="f4180-2833">触摸、 鼠标和触笔输入中的特定关系存在。</span><span class="sxs-lookup"><span data-stu-id="f4180-2833">Touch, mouse, and stylus input exist in a particular relationship.</span></span> <span data-ttu-id="f4180-2834">有关详细信息，请参阅[输入概述](~/docs/framework/wpf/advanced/input-overview.md)。</span><span class="sxs-lookup"><span data-stu-id="f4180-2834">For more information, see [Input Overview](~/docs/framework/wpf/advanced/input-overview.md).</span></span>  
  
<a name="routedEventInfo_StylusUp"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="f4180-2835">路由事件信息</span><span class="sxs-lookup"><span data-stu-id="f4180-2835">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="f4180-2836">标识符字段</span><span class="sxs-lookup"><span data-stu-id="f4180-2836">Identifier field</span></span>|<xref:System.Windows.ContentElement.StylusUpEvent>|  
|<span data-ttu-id="f4180-2837">路由策略</span><span class="sxs-lookup"><span data-stu-id="f4180-2837">Routing strategy</span></span>|<span data-ttu-id="f4180-2838">浮升</span><span class="sxs-lookup"><span data-stu-id="f4180-2838">Bubbling</span></span>|  
|<span data-ttu-id="f4180-2839">委托</span><span class="sxs-lookup"><span data-stu-id="f4180-2839">Delegate</span></span>|<xref:System.Windows.Input.StylusEventHandler>|  
  
-   <span data-ttu-id="f4180-2840">相应的隧道事件是<xref:System.Windows.ContentElement.PreviewStylusUp>。</span><span class="sxs-lookup"><span data-stu-id="f4180-2840">The corresponding tunneling event is <xref:System.Windows.ContentElement.PreviewStylusUp>.</span></span>  
  
-   <span data-ttu-id="f4180-2841">重写<xref:System.Windows.ContentElement.OnStylusUp%2A>实现类处理此事件在派生类中。</span><span class="sxs-lookup"><span data-stu-id="f4180-2841">Override <xref:System.Windows.ContentElement.OnStylusUp%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusUpEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent StylusUpEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent StylusUpEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.StylusUpEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly StylusUpEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ StylusUpEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable StylusUpEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.StylusUpEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f4180-2842">标识 <see cref="E:System.Windows.ContentElement.StylusUp" /> 路由事件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-2842">Identifies the <see cref="E:System.Windows.ContentElement.StylusUp" /> routed event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4180-2843">在注册路由事件时创建路由事件标识符。</span><span class="sxs-lookup"><span data-stu-id="f4180-2843">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="f4180-2844">这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。</span><span class="sxs-lookup"><span data-stu-id="f4180-2844">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="f4180-2845">可以使用这些标识符添加类处理程序。</span><span class="sxs-lookup"><span data-stu-id="f4180-2845">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="f4180-2846">有关注册路由事件的更多信息，请参见 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="f4180-2846">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="f4180-2847">有关使用路由事件标识符添加类处理程序的更多信息，请参见 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="f4180-2847">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TextInput">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.TextCompositionEventHandler TextInput;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.TextCompositionEventHandler TextInput" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.TextInput" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event TextInput As TextCompositionEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::TextCompositionEventHandler ^ TextInput;" />
      <MemberSignature Language="F#" Value="member this.TextInput : System.Windows.Input.TextCompositionEventHandler " Usage="member this.TextInput : System.Windows.Input.TextCompositionEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.TextInput</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.TextCompositionEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f4180-2848">在此元素以设备无关模式获取文本时发生。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-2848">Occurs when this element gets text in a device-independent manner.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  <span data-ttu-id="f4180-2849">此事件可能已被标记处理由复合控件的内部实现。</span><span class="sxs-lookup"><span data-stu-id="f4180-2849">This event might already be marked as handled by the internal implementations of composited controls.</span></span> <span data-ttu-id="f4180-2850">请参阅下面的备注。</span><span class="sxs-lookup"><span data-stu-id="f4180-2850">See Remark below.</span></span>  
  
 <span data-ttu-id="f4180-2851"><xref:System.Windows.ContentElement.TextInput>事件可能已被处理的复合控件的内部实现标记。</span><span class="sxs-lookup"><span data-stu-id="f4180-2851">The <xref:System.Windows.ContentElement.TextInput> event may already be marked as handled by the internal implementations of composited controls.</span></span> <span data-ttu-id="f4180-2852">例如，<xref:System.Windows.Controls.TextBox>是一个复合控件，其中<xref:System.Windows.ContentElement.TextInput>事件已标记为已处理; 其组成中。</span><span class="sxs-lookup"><span data-stu-id="f4180-2852">For example, a <xref:System.Windows.Controls.TextBox> is a composited control where the <xref:System.Windows.ContentElement.TextInput> event is already marked as handled; within its compositing.</span></span> <span data-ttu-id="f4180-2853">这么做是因为该控件需要解释某些类型的输入，如箭头键，为具有对该控件的特殊含义。</span><span class="sxs-lookup"><span data-stu-id="f4180-2853">Controls do this because the control needs to interpret some types of input, such as arrow keys, as having special meaning to that control.</span></span> <span data-ttu-id="f4180-2854">如果使用<xref:System.Windows.ContentElement.PreviewTextInput>作为附加文本输入的处理程序的位置的事件，可能会收到更好的结果。</span><span class="sxs-lookup"><span data-stu-id="f4180-2854">If you use <xref:System.Windows.ContentElement.PreviewTextInput> as the event where you attach handlers for text input, you may receive better results.</span></span> <span data-ttu-id="f4180-2855">该技术可以应对大多数情况下，其中控件组合已经此事件标记为已处理并且会阻止您的处理程序接收事件路由事件。</span><span class="sxs-lookup"><span data-stu-id="f4180-2855">This technique circumvents most cases where control composition has already marked this event as handled and prevents your handler from receiving the event along the event route.</span></span>  
  
 <span data-ttu-id="f4180-2856"><xref:System.Windows.ContentElement.TextInput>事件允许组件或应用程序以与设备无关的方式侦听文本输入。</span><span class="sxs-lookup"><span data-stu-id="f4180-2856">The <xref:System.Windows.ContentElement.TextInput> event allows a component or application to listen for text input in a device-independent manner.</span></span> <span data-ttu-id="f4180-2857">键盘是主要的方式<xref:System.Windows.ContentElement.TextInput>，但语音、 手写和其他输入的设备也可以引发<xref:System.Windows.ContentElement.TextInput>。</span><span class="sxs-lookup"><span data-stu-id="f4180-2857">The keyboard is the primary means of <xref:System.Windows.ContentElement.TextInput>, but speech, handwriting, and other input devices can also raise <xref:System.Windows.ContentElement.TextInput>.</span></span>  
  
 <span data-ttu-id="f4180-2858">由于键组合 — 默认键盘或输入的法编辑器-多个关键事件可能会引发一个文本输入的事件。</span><span class="sxs-lookup"><span data-stu-id="f4180-2858">Because of key combinations—either in default keyboards or through input method editors—multiple key events might raise just one text input event.</span></span>  
  
 <span data-ttu-id="f4180-2859">此事件创建一个别名<xref:System.Windows.Input.TextCompositionManager.TextInput?displayProperty=nameWithType>附加事件对于此类，以便<xref:System.Windows.ContentElement.TextInput>属于类的成员列出时<xref:System.Windows.ContentElement>作为基元素继承。</span><span class="sxs-lookup"><span data-stu-id="f4180-2859">This event creates an alias for the <xref:System.Windows.Input.TextCompositionManager.TextInput?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.TextInput> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="f4180-2860">事件处理程序附加到<xref:System.Windows.ContentElement.TextInput>事件附加到基础<xref:System.Windows.Input.TextCompositionManager.TextInput?displayProperty=nameWithType>附加事件，并接收相同的事件数据实例。</span><span class="sxs-lookup"><span data-stu-id="f4180-2860">Event handlers that are attached to the <xref:System.Windows.ContentElement.TextInput> event are attached to the underlying <xref:System.Windows.Input.TextCompositionManager.TextInput?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
<a name="routedEventInfo_TextInput"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="f4180-2861">路由事件信息</span><span class="sxs-lookup"><span data-stu-id="f4180-2861">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="f4180-2862">标识符字段</span><span class="sxs-lookup"><span data-stu-id="f4180-2862">Identifier field</span></span>|<xref:System.Windows.ContentElement.TextInputEvent>|  
|<span data-ttu-id="f4180-2863">路由策略</span><span class="sxs-lookup"><span data-stu-id="f4180-2863">Routing strategy</span></span>|<span data-ttu-id="f4180-2864">浮升</span><span class="sxs-lookup"><span data-stu-id="f4180-2864">Bubbling</span></span>|  
|<span data-ttu-id="f4180-2865">委托</span><span class="sxs-lookup"><span data-stu-id="f4180-2865">Delegate</span></span>|<xref:System.Windows.Input.TextCompositionEventHandler>|  
  
-   <span data-ttu-id="f4180-2866">相应的隧道事件是<xref:System.Windows.ContentElement.PreviewTextInput>。</span><span class="sxs-lookup"><span data-stu-id="f4180-2866">The corresponding tunneling event is <xref:System.Windows.ContentElement.PreviewTextInput>.</span></span>  
  
-   <span data-ttu-id="f4180-2867">重写<xref:System.Windows.ContentElement.OnTextInput%2A>实现类处理此事件在派生类中。</span><span class="sxs-lookup"><span data-stu-id="f4180-2867">Override <xref:System.Windows.ContentElement.OnTextInput%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TextInputEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent TextInputEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent TextInputEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.TextInputEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TextInputEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ TextInputEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable TextInputEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.TextInputEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f4180-2868">标识 <see cref="E:System.Windows.ContentElement.TextInput" /> 路由事件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-2868">Identifies the <see cref="E:System.Windows.ContentElement.TextInput" /> routed event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4180-2869">在注册路由事件时创建路由事件标识符。</span><span class="sxs-lookup"><span data-stu-id="f4180-2869">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="f4180-2870">这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。</span><span class="sxs-lookup"><span data-stu-id="f4180-2870">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="f4180-2871">可以使用这些标识符添加类处理程序。</span><span class="sxs-lookup"><span data-stu-id="f4180-2871">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="f4180-2872">有关注册路由事件的更多信息，请参见 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="f4180-2872">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="f4180-2873">有关使用路由事件标识符添加类处理程序的更多信息，请参见 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="f4180-2873">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TouchDown">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; TouchDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Input.TouchEventArgs&gt; TouchDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.TouchDown" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event TouchDown As EventHandler(Of TouchEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Windows::Input::TouchEventArgs ^&gt; ^ TouchDown;" />
      <MemberSignature Language="F#" Value="member this.TouchDown : EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; " Usage="member this.TouchDown : System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f4180-2874">当悬停在此元素上方的手指触摸屏幕时发生。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-2874">Occurs when a finger touches the screen while the finger is over this element.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4180-2875">默认情况下<xref:System.Windows.ContentElement.PreviewTouchDown>和<xref:System.Windows.ContentElement.TouchDown>手指触摸屏幕，并将移动之前不会发生的事件。</span><span class="sxs-lookup"><span data-stu-id="f4180-2875">By default, the <xref:System.Windows.ContentElement.PreviewTouchDown> and <xref:System.Windows.ContentElement.TouchDown> events do not occur until a finger touches the screen and moves.</span></span> <span data-ttu-id="f4180-2876">手指在屏幕上按住它而无需移动它会导致按下并保存的行为<xref:System.Windows.Input.Stylus>。</span><span class="sxs-lookup"><span data-stu-id="f4180-2876">Pressing a finger on the screen and holding it without moving it causes the press and hold behavior of a <xref:System.Windows.Input.Stylus>.</span></span> <span data-ttu-id="f4180-2877">按下并保持行为等同于鼠标右键单击。</span><span class="sxs-lookup"><span data-stu-id="f4180-2877">The press and hold behavior is equivalent to a mouse right-click.</span></span>  
  
 <span data-ttu-id="f4180-2878">若要使<xref:System.Windows.ContentElement.PreviewTouchDown>并<xref:System.Windows.ContentElement.TouchDown>事件发生只要上方的手指触摸屏幕上，设置<xref:System.Windows.Input.Stylus.IsPressAndHoldEnabled%2A?displayProperty=nameWithType>附加到属性`false`此元素。</span><span class="sxs-lookup"><span data-stu-id="f4180-2878">To cause the <xref:System.Windows.ContentElement.PreviewTouchDown> and <xref:System.Windows.ContentElement.TouchDown> events to occur as soon as a finger touches the screen, set the <xref:System.Windows.Input.Stylus.IsPressAndHoldEnabled%2A?displayProperty=nameWithType> attached property to `false` for this element.</span></span>  
  
<a name="routedEventInfo_TouchDown"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="f4180-2879">路由事件信息</span><span class="sxs-lookup"><span data-stu-id="f4180-2879">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="f4180-2880">标识符字段</span><span class="sxs-lookup"><span data-stu-id="f4180-2880">Identifier field</span></span>|<xref:System.Windows.ContentElement.TouchDownEvent>|  
|<span data-ttu-id="f4180-2881">路由策略</span><span class="sxs-lookup"><span data-stu-id="f4180-2881">Routing strategy</span></span>|<span data-ttu-id="f4180-2882">浮升</span><span class="sxs-lookup"><span data-stu-id="f4180-2882">Bubbling</span></span>|  
|<span data-ttu-id="f4180-2883">委托</span><span class="sxs-lookup"><span data-stu-id="f4180-2883">Delegate</span></span>|<span data-ttu-id="f4180-2884"><xref:System.EventHandler%601>类型<xref:System.Windows.Input.TouchEventArgs>。</span><span class="sxs-lookup"><span data-stu-id="f4180-2884"><xref:System.EventHandler%601> of type <xref:System.Windows.Input.TouchEventArgs>.</span></span>|  
  
-   <span data-ttu-id="f4180-2885">相应的隧道事件是<xref:System.Windows.ContentElement.PreviewTouchDown>。</span><span class="sxs-lookup"><span data-stu-id="f4180-2885">The corresponding tunneling event is <xref:System.Windows.ContentElement.PreviewTouchDown>.</span></span>  
  
-   <span data-ttu-id="f4180-2886">重写<xref:System.Windows.ContentElement.OnTouchDown%2A>实现类处理此事件在派生类中。</span><span class="sxs-lookup"><span data-stu-id="f4180-2886">Override <xref:System.Windows.ContentElement.OnTouchDown%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Input.Stylus.IsPressAndHoldEnabled" />
        <altmember cref="M:System.Windows.Input.Stylus.GetIsPressAndHoldEnabled(System.Windows.DependencyObject)" />
        <altmember cref="M:System.Windows.Input.Stylus.SetIsPressAndHoldEnabled(System.Windows.DependencyObject,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="TouchDownEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent TouchDownEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent TouchDownEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.TouchDownEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TouchDownEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ TouchDownEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable TouchDownEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.TouchDownEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f4180-2887">标识 <see cref="E:System.Windows.ContentElement.TouchDown" /> 路由事件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-2887">Identifies the <see cref="E:System.Windows.ContentElement.TouchDown" /> routed event.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TouchEnter">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; TouchEnter;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Input.TouchEventArgs&gt; TouchEnter" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.TouchEnter" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event TouchEnter As EventHandler(Of TouchEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Windows::Input::TouchEventArgs ^&gt; ^ TouchEnter;" />
      <MemberSignature Language="F#" Value="member this.TouchEnter : EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; " Usage="member this.TouchEnter : System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f4180-2888">在触摸屏输入从此元素边界外部移动到其内部时发生。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-2888">Occurs when a touch moves from outside to inside the bounds of this element.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4180-2889">始终引发此事件，指示此 UI 元素上捕获触摸设备。</span><span class="sxs-lookup"><span data-stu-id="f4180-2889">This event is always raised, whether or not the touch device is captured to this UI element.</span></span>  
  
<a name="routedEventInfo_TouchEnter"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="f4180-2890">路由事件信息</span><span class="sxs-lookup"><span data-stu-id="f4180-2890">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="f4180-2891">标识符字段</span><span class="sxs-lookup"><span data-stu-id="f4180-2891">Identifier field</span></span>|<xref:System.Windows.ContentElement.TouchEnterEvent>|  
|<span data-ttu-id="f4180-2892">路由策略</span><span class="sxs-lookup"><span data-stu-id="f4180-2892">Routing strategy</span></span>|<span data-ttu-id="f4180-2893">直接</span><span class="sxs-lookup"><span data-stu-id="f4180-2893">Direct</span></span>|  
|<span data-ttu-id="f4180-2894">委托</span><span class="sxs-lookup"><span data-stu-id="f4180-2894">Delegate</span></span>|<span data-ttu-id="f4180-2895"><xref:System.EventHandler%601>类型<xref:System.Windows.Input.TouchEventArgs>。</span><span class="sxs-lookup"><span data-stu-id="f4180-2895"><xref:System.EventHandler%601> of type <xref:System.Windows.Input.TouchEventArgs>.</span></span>|  
  
-   <span data-ttu-id="f4180-2896">重写<xref:System.Windows.ContentElement.OnTouchEnter%2A>实现类处理此事件在派生类中。</span><span class="sxs-lookup"><span data-stu-id="f4180-2896">Override <xref:System.Windows.ContentElement.OnTouchEnter%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TouchEnterEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent TouchEnterEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent TouchEnterEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.TouchEnterEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TouchEnterEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ TouchEnterEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable TouchEnterEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.TouchEnterEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f4180-2897">标识 <see cref="E:System.Windows.ContentElement.TouchEnter" /> 路由事件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-2897">Identifies the <see cref="E:System.Windows.ContentElement.TouchEnter" /> routed event.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TouchesCaptured">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.Windows.Input.TouchDevice&gt; TouchesCaptured { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEnumerable`1&lt;class System.Windows.Input.TouchDevice&gt; TouchesCaptured" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.TouchesCaptured" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TouchesCaptured As IEnumerable(Of TouchDevice)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::IEnumerable&lt;System::Windows::Input::TouchDevice ^&gt; ^ TouchesCaptured { System::Collections::Generic::IEnumerable&lt;System::Windows::Input::TouchDevice ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.TouchesCaptured : seq&lt;System.Windows.Input.TouchDevice&gt;" Usage="System.Windows.ContentElement.TouchesCaptured" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Windows.Input.TouchDevice&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f4180-2898">获取在此元素上捕获的所有触摸设备。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-2898">Gets all touch devices that are captured to this element.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="f4180-2899">在此元素上捕获的 <see cref="T:System.Windows.Input.TouchDevice" /> 对象的枚举。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-2899">An enumeration of <see cref="T:System.Windows.Input.TouchDevice" /> objects that are captured to this element.</span>
          </span>
        </value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TouchesCapturedWithin">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.Windows.Input.TouchDevice&gt; TouchesCapturedWithin { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEnumerable`1&lt;class System.Windows.Input.TouchDevice&gt; TouchesCapturedWithin" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.TouchesCapturedWithin" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TouchesCapturedWithin As IEnumerable(Of TouchDevice)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::IEnumerable&lt;System::Windows::Input::TouchDevice ^&gt; ^ TouchesCapturedWithin { System::Collections::Generic::IEnumerable&lt;System::Windows::Input::TouchDevice ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.TouchesCapturedWithin : seq&lt;System.Windows.Input.TouchDevice&gt;" Usage="System.Windows.ContentElement.TouchesCapturedWithin" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Windows.Input.TouchDevice&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f4180-2900">获取在此元素或其可视化树中的任何子元素上捕获的所有触摸设备。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-2900">Gets all touch devices that are captured to this element or any child elements in its visual tree.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="f4180-2901">在此元素或其可视化树中的任何子元素上捕获的 <see cref="T:System.Windows.Input.TouchDevice" /> 对象的枚举。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-2901">An enumeration of <see cref="T:System.Windows.Input.TouchDevice" /> objects that are captured to this element or any child elements in its visual tree.</span>
          </span>
        </value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TouchesDirectlyOver">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.Windows.Input.TouchDevice&gt; TouchesDirectlyOver { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEnumerable`1&lt;class System.Windows.Input.TouchDevice&gt; TouchesDirectlyOver" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.TouchesDirectlyOver" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TouchesDirectlyOver As IEnumerable(Of TouchDevice)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::IEnumerable&lt;System::Windows::Input::TouchDevice ^&gt; ^ TouchesDirectlyOver { System::Collections::Generic::IEnumerable&lt;System::Windows::Input::TouchDevice ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.TouchesDirectlyOver : seq&lt;System.Windows.Input.TouchDevice&gt;" Usage="System.Windows.ContentElement.TouchesDirectlyOver" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Windows.Input.TouchDevice&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f4180-2902">获取此元素上的所有触摸设备。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-2902">Gets all touch devices that are over this element.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="f4180-2903">位于此元素上的 <see cref="T:System.Windows.Input.TouchDevice" /> 对象的枚举。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-2903">An enumeration of <see cref="T:System.Windows.Input.TouchDevice" /> objects that are over this element.</span>
          </span>
        </value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TouchesOver">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.Windows.Input.TouchDevice&gt; TouchesOver { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEnumerable`1&lt;class System.Windows.Input.TouchDevice&gt; TouchesOver" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.TouchesOver" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TouchesOver As IEnumerable(Of TouchDevice)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::IEnumerable&lt;System::Windows::Input::TouchDevice ^&gt; ^ TouchesOver { System::Collections::Generic::IEnumerable&lt;System::Windows::Input::TouchDevice ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.TouchesOver : seq&lt;System.Windows.Input.TouchDevice&gt;" Usage="System.Windows.ContentElement.TouchesOver" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Windows.Input.TouchDevice&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f4180-2904">获取在此元素或其可视化树中的任何子元素上的所有触摸设备。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-2904">Gets all touch devices that are over this element or any child elements in its visual tree.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="f4180-2905">在此元素或其可视化树中的任何子元素上的 <see cref="T:System.Windows.Input.TouchDevice" /> 对象的枚举。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-2905">An enumeration of <see cref="T:System.Windows.Input.TouchDevice" /> objects that are over this element or any child elements in its visual tree.</span>
          </span>
        </value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TouchLeave">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; TouchLeave;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Input.TouchEventArgs&gt; TouchLeave" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.TouchLeave" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event TouchLeave As EventHandler(Of TouchEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Windows::Input::TouchEventArgs ^&gt; ^ TouchLeave;" />
      <MemberSignature Language="F#" Value="member this.TouchLeave : EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; " Usage="member this.TouchLeave : System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f4180-2906">在触摸屏输入从此元素边界内部移动到其外部时发生。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-2906">Occurs when a touch moves from inside to outside the bounds of this element.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="routedEventInfo_TouchLeave"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="f4180-2907">路由事件信息</span><span class="sxs-lookup"><span data-stu-id="f4180-2907">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="f4180-2908">标识符字段</span><span class="sxs-lookup"><span data-stu-id="f4180-2908">Identifier field</span></span>|<xref:System.Windows.ContentElement.TouchLeaveEvent>|  
|<span data-ttu-id="f4180-2909">路由策略</span><span class="sxs-lookup"><span data-stu-id="f4180-2909">Routing strategy</span></span>|<span data-ttu-id="f4180-2910">直接</span><span class="sxs-lookup"><span data-stu-id="f4180-2910">Direct</span></span>|  
|<span data-ttu-id="f4180-2911">委托</span><span class="sxs-lookup"><span data-stu-id="f4180-2911">Delegate</span></span>|<span data-ttu-id="f4180-2912"><xref:System.EventHandler%601>类型<xref:System.Windows.Input.TouchEventArgs>。</span><span class="sxs-lookup"><span data-stu-id="f4180-2912"><xref:System.EventHandler%601> of type <xref:System.Windows.Input.TouchEventArgs>.</span></span>|  
  
-   <span data-ttu-id="f4180-2913">重写<xref:System.Windows.ContentElement.OnTouchLeave%2A>实现类处理此事件在派生类中。</span><span class="sxs-lookup"><span data-stu-id="f4180-2913">Override <xref:System.Windows.ContentElement.OnTouchLeave%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TouchLeaveEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent TouchLeaveEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent TouchLeaveEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.TouchLeaveEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TouchLeaveEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ TouchLeaveEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable TouchLeaveEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.TouchLeaveEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f4180-2914">标识 <see cref="E:System.Windows.ContentElement.TouchLeave" /> 路由事件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-2914">Identifies the <see cref="E:System.Windows.ContentElement.TouchLeave" /> routed event.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TouchMove">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; TouchMove;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Input.TouchEventArgs&gt; TouchMove" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.TouchMove" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event TouchMove As EventHandler(Of TouchEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Windows::Input::TouchEventArgs ^&gt; ^ TouchMove;" />
      <MemberSignature Language="F#" Value="member this.TouchMove : EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; " Usage="member this.TouchMove : System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f4180-2915">当悬停在此元素上方的手指在屏幕上移动时发生。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-2915">Occurs when a finger moves on the screen while the finger is over this element.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="routedEventInfo_TouchMove"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="f4180-2916">路由事件信息</span><span class="sxs-lookup"><span data-stu-id="f4180-2916">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="f4180-2917">标识符字段</span><span class="sxs-lookup"><span data-stu-id="f4180-2917">Identifier field</span></span>|<xref:System.Windows.ContentElement.TouchMoveEvent>|  
|<span data-ttu-id="f4180-2918">路由策略</span><span class="sxs-lookup"><span data-stu-id="f4180-2918">Routing strategy</span></span>|<span data-ttu-id="f4180-2919">浮升</span><span class="sxs-lookup"><span data-stu-id="f4180-2919">Bubbling</span></span>|  
|<span data-ttu-id="f4180-2920">委托</span><span class="sxs-lookup"><span data-stu-id="f4180-2920">Delegate</span></span>|<span data-ttu-id="f4180-2921"><xref:System.EventHandler%601>类型<xref:System.Windows.Input.TouchEventArgs>。</span><span class="sxs-lookup"><span data-stu-id="f4180-2921"><xref:System.EventHandler%601> of type <xref:System.Windows.Input.TouchEventArgs>.</span></span>|  
  
-   <span data-ttu-id="f4180-2922">相应的隧道事件是<xref:System.Windows.ContentElement.PreviewTouchMove>。</span><span class="sxs-lookup"><span data-stu-id="f4180-2922">The corresponding tunneling event is <xref:System.Windows.ContentElement.PreviewTouchMove>.</span></span>  
  
-   <span data-ttu-id="f4180-2923">重写<xref:System.Windows.ContentElement.OnTouchMove%2A>实现类处理此事件在派生类中。</span><span class="sxs-lookup"><span data-stu-id="f4180-2923">Override <xref:System.Windows.ContentElement.OnTouchMove%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TouchMoveEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent TouchMoveEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent TouchMoveEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.TouchMoveEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TouchMoveEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ TouchMoveEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable TouchMoveEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.TouchMoveEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f4180-2924">标识 <see cref="E:System.Windows.ContentElement.TouchMove" /> 路由事件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-2924">Identifies the <see cref="E:System.Windows.ContentElement.TouchMove" /> routed event.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TouchUp">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; TouchUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Input.TouchEventArgs&gt; TouchUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.TouchUp" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event TouchUp As EventHandler(Of TouchEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Windows::Input::TouchEventArgs ^&gt; ^ TouchUp;" />
      <MemberSignature Language="F#" Value="member this.TouchUp : EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; " Usage="member this.TouchUp : System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f4180-2925">当悬停在此元素上方的手指从屏幕上移开时发生。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-2925">Occurs when a finger is raised off of the screen while the finger is over this element.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="routedEventInfo_TouchUp"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="f4180-2926">路由事件信息</span><span class="sxs-lookup"><span data-stu-id="f4180-2926">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="f4180-2927">标识符字段</span><span class="sxs-lookup"><span data-stu-id="f4180-2927">Identifier field</span></span>|<xref:System.Windows.ContentElement.TouchUpEvent>|  
|<span data-ttu-id="f4180-2928">路由策略</span><span class="sxs-lookup"><span data-stu-id="f4180-2928">Routing strategy</span></span>|<span data-ttu-id="f4180-2929">浮升</span><span class="sxs-lookup"><span data-stu-id="f4180-2929">Bubbling</span></span>|  
|<span data-ttu-id="f4180-2930">委托</span><span class="sxs-lookup"><span data-stu-id="f4180-2930">Delegate</span></span>|<span data-ttu-id="f4180-2931"><xref:System.EventHandler%601>类型<xref:System.Windows.Input.TouchEventArgs>。</span><span class="sxs-lookup"><span data-stu-id="f4180-2931"><xref:System.EventHandler%601> of type <xref:System.Windows.Input.TouchEventArgs>.</span></span>|  
  
-   <span data-ttu-id="f4180-2932">相应的隧道事件是<xref:System.Windows.ContentElement.PreviewTouchUp>。</span><span class="sxs-lookup"><span data-stu-id="f4180-2932">The corresponding tunneling event is <xref:System.Windows.ContentElement.PreviewTouchUp>.</span></span>  
  
-   <span data-ttu-id="f4180-2933">重写<xref:System.Windows.ContentElement.OnTouchUp%2A>实现类处理此事件在派生类中。</span><span class="sxs-lookup"><span data-stu-id="f4180-2933">Override <xref:System.Windows.ContentElement.OnTouchUp%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TouchUpEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent TouchUpEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent TouchUpEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.TouchUpEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TouchUpEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ TouchUpEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable TouchUpEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.TouchUpEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f4180-2934">标识 <see cref="E:System.Windows.ContentElement.TouchUp" /> 路由事件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4180-2934">Identifies the <see cref="E:System.Windows.ContentElement.TouchUp" /> routed event.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>