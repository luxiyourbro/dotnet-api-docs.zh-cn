<Type Name="DependencyProperty" FullName="System.Windows.DependencyProperty">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="48e189814c9d38e818a9d416a18db9a92e096f66" />
    <Meta Name="ms.sourcegitcommit" Value="0ec122ee5f3681159b8460ab15b409fd6e3d3ae0" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-CN" />
    <Meta Name="ms.lasthandoff" Value="10/04/2018" />
    <Meta Name="ms.locfileid" Value="48623028" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class DependencyProperty" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit DependencyProperty extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Windows.DependencyProperty" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class DependencyProperty" />
  <TypeSignature Language="C++ CLI" Value="public ref class DependencyProperty sealed" />
  <TypeSignature Language="F#" Value="type DependencyProperty = class" />
  <AssemblyInfo>
    <AssemblyName>WindowsBase</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.ComponentModel.TypeConverter("System.Windows.Markup.DependencyPropertyConverter, PresentationFramework, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, Custom=null")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.Windows.Markup.ValueSerializer(typeof(System.Windows.DependencyPropertyValueSerializer))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5">
      <AttributeName>System.ComponentModel.TypeConverter("System.Windows.Markup.DependencyPropertyConverter, PresentationFramework, Version=3.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, Custom=null")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>
      <span data-ttu-id="8e0b6-101">表示可通过诸如样式、数据绑定、动画和继承等方法设置的属性。</span>
      <span class="sxs-lookup">
        <span data-stu-id="8e0b6-101">Represents a property that can be set through methods such as, styling, data binding, animation, and inheritance.</span>
      </span>
    </summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8e0b6-102">一个<xref:System.Windows.DependencyProperty>支持中的以下功能[!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)]:</span><span class="sxs-lookup"><span data-stu-id="8e0b6-102">A <xref:System.Windows.DependencyProperty> supports the following capabilities in [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)]:</span></span>  
  
-   <span data-ttu-id="8e0b6-103">可以在样式中设置该属性。</span><span class="sxs-lookup"><span data-stu-id="8e0b6-103">The property can be set in a style.</span></span> <span data-ttu-id="8e0b6-104">有关详细信息，请参阅[样式设置和模板化](~/docs/framework/wpf/controls/styling-and-templating.md)。</span><span class="sxs-lookup"><span data-stu-id="8e0b6-104">For more information, see [Styling and Templating](~/docs/framework/wpf/controls/styling-and-templating.md).</span></span>  
  
-   <span data-ttu-id="8e0b6-105">可通过数据绑定设置属性。</span><span class="sxs-lookup"><span data-stu-id="8e0b6-105">The property can be set through data binding.</span></span> <span data-ttu-id="8e0b6-106">有关数据绑定依赖关系属性的详细信息，请参阅[如何： 绑定两个控件属性的](~/docs/framework/wpf/data/how-to-bind-the-properties-of-two-controls.md)。</span><span class="sxs-lookup"><span data-stu-id="8e0b6-106">For more information about data binding dependency properties, see [How to: Bind the Properties of Two Controls](~/docs/framework/wpf/data/how-to-bind-the-properties-of-two-controls.md).</span></span>  
  
-   <span data-ttu-id="8e0b6-107">可以使用动态资源引用设置属性。</span><span class="sxs-lookup"><span data-stu-id="8e0b6-107">The property can be set with a dynamic resource reference.</span></span> <span data-ttu-id="8e0b6-108">有关详细信息，请参阅 [XAML 资源](~/docs/framework/wpf/advanced/xaml-resources.md)。</span><span class="sxs-lookup"><span data-stu-id="8e0b6-108">For more information, see [XAML Resources](~/docs/framework/wpf/advanced/xaml-resources.md).</span></span>  
  
-   <span data-ttu-id="8e0b6-109">该属性可以从元素树中的父元素自动继承它的值。</span><span class="sxs-lookup"><span data-stu-id="8e0b6-109">The property can inherit its value automatically from a parent element in the element tree.</span></span> <span data-ttu-id="8e0b6-110">有关详细信息，请参阅[属性值继承](~/docs/framework/wpf/advanced/property-value-inheritance.md)。</span><span class="sxs-lookup"><span data-stu-id="8e0b6-110">For more information, see [Property Value Inheritance](~/docs/framework/wpf/advanced/property-value-inheritance.md).</span></span>  
  
-   <span data-ttu-id="8e0b6-111">可以对属性进行动画处理。</span><span class="sxs-lookup"><span data-stu-id="8e0b6-111">The property can be animated.</span></span> <span data-ttu-id="8e0b6-112">有关详细信息，请参阅 [动画概述](~/docs/framework/wpf/graphics-multimedia/animation-overview.md)。</span><span class="sxs-lookup"><span data-stu-id="8e0b6-112">For more information, see [Animation Overview](~/docs/framework/wpf/graphics-multimedia/animation-overview.md).</span></span>  
  
-   <span data-ttu-id="8e0b6-113">已更改的属性的以前的值和属性值可强制转换时，可以报告属性。</span><span class="sxs-lookup"><span data-stu-id="8e0b6-113">The property can report when the previous value of the property has been changed and the property value can be coerced.</span></span> <span data-ttu-id="8e0b6-114">有关详细信息，请参阅[依赖属性回调和验证](~/docs/framework/wpf/advanced/dependency-property-callbacks-and-validation.md)。</span><span class="sxs-lookup"><span data-stu-id="8e0b6-114">For more information, see [Dependency Property Callbacks and Validation](~/docs/framework/wpf/advanced/dependency-property-callbacks-and-validation.md).</span></span>  
  
-   <span data-ttu-id="8e0b6-115">该属性报告信息到[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]，例如更改属性值是否应需要布局系统重新编写的元素的视觉对象。</span><span class="sxs-lookup"><span data-stu-id="8e0b6-115">The property reports information to [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)], such as whether changing a property value should require the layout system to recompose the visuals for an element.</span></span>  
  
-   <span data-ttu-id="8e0b6-116">属性接收中的支持[!INCLUDE[wpfdesigner_current_long](~/includes/wpfdesigner-current-long-md.md)]。</span><span class="sxs-lookup"><span data-stu-id="8e0b6-116">The property receives support in the [!INCLUDE[wpfdesigner_current_long](~/includes/wpfdesigner-current-long-md.md)].</span></span>  <span data-ttu-id="8e0b6-117">例如，可以在中编辑属性**属性**窗口。</span><span class="sxs-lookup"><span data-stu-id="8e0b6-117">For example, the property can be edited in the **Properties** window.</span></span>  
  
 <span data-ttu-id="8e0b6-118">若要了解有关依赖项属性的详细信息，请参阅[依赖属性概述](~/docs/framework/wpf/advanced/dependency-properties-overview.md)。</span><span class="sxs-lookup"><span data-stu-id="8e0b6-118">To learn more about dependency properties, see [Dependency Properties Overview](~/docs/framework/wpf/advanced/dependency-properties-overview.md).</span></span> <span data-ttu-id="8e0b6-119">如果希望在自定义类型支持的功能与上述列表中的属性，应创建一个依赖项属性。</span><span class="sxs-lookup"><span data-stu-id="8e0b6-119">If you want properties on your custom types to support the capabilities in the preceding list, you should create a dependency property.</span></span>  <span data-ttu-id="8e0b6-120">若要了解如何创建自定义依赖属性，请参阅[自定义依赖项属性](~/docs/framework/wpf/advanced/custom-dependency-properties.md)。</span><span class="sxs-lookup"><span data-stu-id="8e0b6-120">To learn how to create custom dependency properties, see [Custom Dependency Properties](~/docs/framework/wpf/advanced/custom-dependency-properties.md).</span></span>  
  
 <span data-ttu-id="8e0b6-121">附加的属性是属性，用于定义附加的属性的类型的报告信息的任何对象。</span><span class="sxs-lookup"><span data-stu-id="8e0b6-121">An attached property is a property that enables any object to report information to the type that defines the attached property.</span></span> <span data-ttu-id="8e0b6-122">在中[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]，继承自任何类型<xref:System.Windows.DependencyObject>可以使用附加的属性而不考虑该类型是否继承定义的属性的类型。</span><span class="sxs-lookup"><span data-stu-id="8e0b6-122">In [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)], any type that inherits from <xref:System.Windows.DependencyObject> can use an attached property regardless of whether the type inherits from the type that defines the property.</span></span> <span data-ttu-id="8e0b6-123">附加的属性是一项功能的[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]语言。</span><span class="sxs-lookup"><span data-stu-id="8e0b6-123">An attached property is a feature of the [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] language.</span></span>  <span data-ttu-id="8e0b6-124">若要设置附加的属性在[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]，使用*ownerType*。*propertyName*语法。</span><span class="sxs-lookup"><span data-stu-id="8e0b6-124">To set an attached property in [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)], use the *ownerType*.*propertyName* syntax.</span></span> <span data-ttu-id="8e0b6-125">附加属性的一个示例是<xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType>属性。</span><span class="sxs-lookup"><span data-stu-id="8e0b6-125">An example of an attached property is the <xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="8e0b6-126">如果你想要创建一个属性，可应用于所有<xref:System.Windows.DependencyObject>类型，则应创建附加的属性。</span><span class="sxs-lookup"><span data-stu-id="8e0b6-126">If you want to create a property that can be used on all <xref:System.Windows.DependencyObject> types, then you should create an attached property.</span></span> <span data-ttu-id="8e0b6-127">若要详细了解附加属性，包括如何创建它们，请参阅[附加属性概述](~/docs/framework/wpf/advanced/attached-properties-overview.md)。</span><span class="sxs-lookup"><span data-stu-id="8e0b6-127">To learn more about attached properties, including how to create them, see [Attached Properties Overview](~/docs/framework/wpf/advanced/attached-properties-overview.md).</span></span>  
  
<a name="xamlAttributeUsage_DependencyProperty"></a>   
## <a name="xaml-attribute-usage"></a><span data-ttu-id="8e0b6-128">XAML 属性用法</span><span class="sxs-lookup"><span data-stu-id="8e0b6-128">XAML Attribute Usage</span></span>  
  
```  
<object property="dependencyPropertyName"/>  
- or -  
<object property="ownerType.dependencyPropertyName"/>  
- or -  
<object property="attachedPropertyOwnerType.attachedPropertyName"/>  
```  
  
<a name="xamlValues_DependencyProperty"></a>   
## <a name="xaml-values"></a><span data-ttu-id="8e0b6-129">XAML 值</span><span class="sxs-lookup"><span data-stu-id="8e0b6-129">XAML Values</span></span>  
 `dependencyPropertyName`  
 <span data-ttu-id="8e0b6-130">一个字符串，指定<xref:System.Windows.DependencyProperty.Name%2A?displayProperty=nameWithType>的所需的依赖项属性。</span><span class="sxs-lookup"><span data-stu-id="8e0b6-130">A string that specifies the <xref:System.Windows.DependencyProperty.Name%2A?displayProperty=nameWithType> of the desired dependency property.</span></span> <span data-ttu-id="8e0b6-131">如果属性不是默认 XML 命名空间中可以按 XML 命名空间前缀前面这 (有关详细信息，请参阅[XAML 命名空间和 WPF XAML Namespace 映射](~/docs/framework/wpf/advanced/xaml-namespaces-and-namespace-mapping-for-wpf-xaml.md)。)</span><span class="sxs-lookup"><span data-stu-id="8e0b6-131">This can be preceded by an XML namespace prefix if the property is not in the default XML namespace (for details, see [XAML Namespaces and Namespace Mapping for WPF XAML](~/docs/framework/wpf/advanced/xaml-namespaces-and-namespace-mapping-for-wpf-xaml.md).)</span></span>  
  
 <span data-ttu-id="8e0b6-132">`ownerType`.`dependencyPropertyName`</span><span class="sxs-lookup"><span data-stu-id="8e0b6-132">`ownerType`.`dependencyPropertyName`</span></span>  
 <span data-ttu-id="8e0b6-133">一个字符串，指定所有者类型的依赖项属性，点 （.），则<xref:System.Windows.DependencyProperty.Name%2A?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="8e0b6-133">A string that specifies an owner type of a dependency property, a dot (.), then the <xref:System.Windows.DependencyProperty.Name%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="8e0b6-134">`ownerType` 此外可以按 XML 命名空间前缀前面。</span><span class="sxs-lookup"><span data-stu-id="8e0b6-134">`ownerType` can also be preceded by an XML namespace prefix.</span></span> <span data-ttu-id="8e0b6-135">这种用法是特定于后期绑定样式和模板，必须为因为分析上下文中指定的依赖项属性的所有者`TargetType`还不知道。</span><span class="sxs-lookup"><span data-stu-id="8e0b6-135">This usage is particular to late-bound styles and templates, where the owner of the dependency property must be specified for parsing context because the `TargetType` is not yet known.</span></span> <span data-ttu-id="8e0b6-136">有关详细信息，请参阅[样式设置和模板化](~/docs/framework/wpf/controls/styling-and-templating.md)。</span><span class="sxs-lookup"><span data-stu-id="8e0b6-136">For more information, see [Styling and Templating](~/docs/framework/wpf/controls/styling-and-templating.md).</span></span>  
  
 <span data-ttu-id="8e0b6-137">`attachedPropertyOwnerType` *.*</span><span class="sxs-lookup"><span data-stu-id="8e0b6-137">`attachedPropertyOwnerType` *.*</span></span> `attachedPropertyName`  
 <span data-ttu-id="8e0b6-138">一个字符串，指定为附加的属性、 句点 （.），然后附加的属性名称的所有者。</span><span class="sxs-lookup"><span data-stu-id="8e0b6-138">A string that specifies  the owner of an attached property, a dot (.), then the attached property name.</span></span> <span data-ttu-id="8e0b6-139">`attachedPropertyOwnerType` 此外可以按 XML 命名空间前缀前面。</span><span class="sxs-lookup"><span data-stu-id="8e0b6-139">`attachedPropertyOwnerType` can also be preceded by an XML namespace prefix.</span></span>  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.DependencyObject" />
    <altmember cref="T:System.Windows.DependencyPropertyHelper" />
  </Docs>
  <Members>
    <MemberGroup MemberName="AddOwner">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="8e0b6-140">将另一种类型添加为已注册到一种类型的依赖属性的所有者。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e0b6-140">Adds another type as an owner of a dependency property that has already been registered to a type.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddOwner">
      <MemberSignature Language="C#" Value="public System.Windows.DependencyProperty AddOwner (Type ownerType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.DependencyProperty AddOwner(class System.Type ownerType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.AddOwner(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Function AddOwner (ownerType As Type) As DependencyProperty" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::DependencyProperty ^ AddOwner(Type ^ ownerType);" />
      <MemberSignature Language="F#" Value="member this.AddOwner : Type -&gt; System.Windows.DependencyProperty" Usage="dependencyProperty.AddOwner ownerType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ownerType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="ownerType">
          <span data-ttu-id="8e0b6-141">要作为此依赖属性所有者添加的类型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e0b6-141">The type to add as an owner of this dependency property.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="8e0b6-142">将另一种类型添加为已注册的依赖属性的所有者。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e0b6-142">Adds another type as an owner of a dependency property that has already been registered.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="8e0b6-143">一个引用，它指向可标识依赖属性的原始 <see cref="T:System.Windows.DependencyProperty" /> 标识符。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e0b6-143">A reference to the original <see cref="T:System.Windows.DependencyProperty" /> identifier that identifies the dependency property.</span>
          </span>
          <span data-ttu-id="8e0b6-144">应通过将类添加为 <see langword="public static readonly" /> 字段来公开此标识符。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e0b6-144">This identifier should be exposed by the adding class as a <see langword="public static readonly" /> field.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8e0b6-145">此方法使属性系统最初未注册该特定的依赖项属性的类型上识别依赖项属性。</span><span class="sxs-lookup"><span data-stu-id="8e0b6-145">This method enables the property system to recognize a dependency property on a type that did not register that particular dependency property initially.</span></span>  
  
 <span data-ttu-id="8e0b6-146">通常情况下，<xref:System.Windows.DependencyProperty.AddOwner%2A>用于将依赖项属性添加到不公开通过托管的类继承该依赖项属性的类 (类继承将导致要由派生类继承的包装器属性，因此将提供常规成员表访问权限的依赖关系属性已）。</span><span class="sxs-lookup"><span data-stu-id="8e0b6-146">Typically, <xref:System.Windows.DependencyProperty.AddOwner%2A> is used to add dependency properties to classes that do not already expose that dependency property through managed class inheritance (class inheritance would cause the wrapper properties to be inherited by the derived class, and thus would provide general members-table access to the dependency property already).</span></span> <span data-ttu-id="8e0b6-147"><xref:System.Windows.DependencyProperty.AddOwner%2A> 使属性系统最初未注册该依赖项属性的类型上识别依赖项属性。</span><span class="sxs-lookup"><span data-stu-id="8e0b6-147"><xref:System.Windows.DependencyProperty.AddOwner%2A> enables the property system to recognize a dependency property on a type that did not register that dependency property initially.</span></span>  
  
 <span data-ttu-id="8e0b6-148">此签名不允许指定元数据。</span><span class="sxs-lookup"><span data-stu-id="8e0b6-148">This signature does not allow for specifying metadata.</span></span>  <span data-ttu-id="8e0b6-149">当使用此方法时，元数据自动生成的新<xref:System.Windows.DependencyProperty>和其所有者类型。</span><span class="sxs-lookup"><span data-stu-id="8e0b6-149">When you use this method, the metadata is automatically generated for the new <xref:System.Windows.DependencyProperty> and its owner type.</span></span> <span data-ttu-id="8e0b6-150">自动生成元数据是从所有已定义此属性的基类型的合并元数据的结果。</span><span class="sxs-lookup"><span data-stu-id="8e0b6-150">The auto-generated metadata is the result of the merged metadata from all of the base types that have this property defined.</span></span> <span data-ttu-id="8e0b6-151">如果无合并元数据不可用，则使用该属性的默认元数据。</span><span class="sxs-lookup"><span data-stu-id="8e0b6-151">If no merged metadata is available, then the default metadata for the property is used.</span></span> <span data-ttu-id="8e0b6-152">如果使用注册该属性<xref:System.Windows.DependencyProperty.RegisterAttached%2A>方法，则默认元数据是时创建的元数据相同<xref:System.Windows.DependencyProperty.RegisterAttached%2A>调用。</span><span class="sxs-lookup"><span data-stu-id="8e0b6-152">If the property is registered by using the <xref:System.Windows.DependencyProperty.RegisterAttached%2A> method, then the default metadata is the same as the metadata that is created when <xref:System.Windows.DependencyProperty.RegisterAttached%2A> was called.</span></span> <span data-ttu-id="8e0b6-153">否则为<xref:System.Windows.PropertyMetadata>对象创建与<xref:System.Windows.PropertyMetadata.DefaultValue%2A>属性设置为属性类型的默认值和所有其他属性<xref:System.Windows.PropertyMetadata>设置为`null`。</span><span class="sxs-lookup"><span data-stu-id="8e0b6-153">Otherwise, the <xref:System.Windows.PropertyMetadata> object is created with the <xref:System.Windows.PropertyMetadata.DefaultValue%2A> property set to the property type's default and all other properties of the <xref:System.Windows.PropertyMetadata> is set to `null`.</span></span> <span data-ttu-id="8e0b6-154">使用<xref:System.Windows.DependencyProperty.AddOwner%28System.Type%2CSystem.Windows.PropertyMetadata%29>签名，如果你想要为添加到所提供的类型的依赖项属性的版本提供元数据。</span><span class="sxs-lookup"><span data-stu-id="8e0b6-154">Use the <xref:System.Windows.DependencyProperty.AddOwner%28System.Type%2CSystem.Windows.PropertyMetadata%29> signature if you want to provide metadata for the version of the dependency property as added to the provided type.</span></span>  
  
 <span data-ttu-id="8e0b6-155">此方法的返回值通常用于声明和公开的依赖属性通过将存储依赖项属性标识符。</span><span class="sxs-lookup"><span data-stu-id="8e0b6-155">The return value of this method is typically used to declare and expose the dependency property by storing a dependency property identifier.</span></span> <span data-ttu-id="8e0b6-156">此标识符提供依赖项属性的访问权限，如果你想要调用属性系统[!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)]针对依赖项属性，尤其是当它存在添加的所有者类上。</span><span class="sxs-lookup"><span data-stu-id="8e0b6-156">The identifier provides access to the dependency property if you want to call property system [!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)] against the dependency property, particularly as it exists on the adding owner class.</span></span> <span data-ttu-id="8e0b6-157">原始所有者和所有者添加的相同属性名称应该用于指示类似的功能。</span><span class="sxs-lookup"><span data-stu-id="8e0b6-157">The same property name for both original owner and added owner should be used to indicate the similar functionality.</span></span> <span data-ttu-id="8e0b6-158">应使用<xref:System.Windows.DependencyProperty>的返回值<xref:System.Windows.DependencyProperty.AddOwner%2A>方法来定义依赖属性标识符，并还声明[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]属性的包装器，将添加到使用的类型的依赖项属性<xref:System.Windows.DependencyProperty.AddOwner%2A>。</span><span class="sxs-lookup"><span data-stu-id="8e0b6-158">You should use the <xref:System.Windows.DependencyProperty> return value of the <xref:System.Windows.DependencyProperty.AddOwner%2A> method to define the dependency property identifier, and also to declare [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] property wrappers, for dependency properties that are added to types using <xref:System.Windows.DependencyProperty.AddOwner%2A>.</span></span>  
  
 <span data-ttu-id="8e0b6-159"><xref:System.Windows.DependencyProperty.AddOwner%2A>创建中声明的依赖项属性时，上面建议的方法使用[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]。</span><span class="sxs-lookup"><span data-stu-id="8e0b6-159">The <xref:System.Windows.DependencyProperty.AddOwner%2A> methodology recommended above is used when creating the dependency properties that are declared within [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)].</span></span> <span data-ttu-id="8e0b6-160">例如，同时<xref:System.Windows.Controls.Border>并<xref:System.Windows.Controls.Control>定义`BorderBrush`依赖项属性，具有类似的功能。</span><span class="sxs-lookup"><span data-stu-id="8e0b6-160">For instance, both <xref:System.Windows.Controls.Border> and <xref:System.Windows.Controls.Control> define a `BorderBrush` dependency property, which have similar functionality.</span></span> <span data-ttu-id="8e0b6-161"><xref:System.Windows.Controls.Control> 定义其`BorderBrush`属性设置为通过调用属性系统<xref:System.Windows.DependencyProperty.AddOwner%2A>基于原始所有者<xref:System.Windows.Controls.Border>且其已注册<xref:System.Windows.Controls.Border.BorderBrushProperty>依赖项属性标识符。</span><span class="sxs-lookup"><span data-stu-id="8e0b6-161"><xref:System.Windows.Controls.Control> defines its `BorderBrush` property to the property system by calling <xref:System.Windows.DependencyProperty.AddOwner%2A> based on the original owner <xref:System.Windows.Controls.Border> and its registered <xref:System.Windows.Controls.Border.BorderBrushProperty> dependency property identifer.</span></span> <span data-ttu-id="8e0b6-162"><xref:System.Windows.DependencyProperty.AddOwner%2A>返回值然后用于建立一个新的静态<xref:System.Windows.DependencyProperty>字段 (<xref:System.Windows.Controls.Control.BorderBrushProperty>) 上添加所有者，该属性和一个`BorderBrush`还声明属性包装器。</span><span class="sxs-lookup"><span data-stu-id="8e0b6-162">The <xref:System.Windows.DependencyProperty.AddOwner%2A> return value is then used to establish a new static <xref:System.Windows.DependencyProperty> field (<xref:System.Windows.Controls.Control.BorderBrushProperty>) for that property on the added owner, and a `BorderBrush` property wrapper is also declared.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddOwner">
      <MemberSignature Language="C#" Value="public System.Windows.DependencyProperty AddOwner (Type ownerType, System.Windows.PropertyMetadata typeMetadata);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.DependencyProperty AddOwner(class System.Type ownerType, class System.Windows.PropertyMetadata typeMetadata) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.AddOwner(System.Type,System.Windows.PropertyMetadata)" />
      <MemberSignature Language="VB.NET" Value="Public Function AddOwner (ownerType As Type, typeMetadata As PropertyMetadata) As DependencyProperty" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::DependencyProperty ^ AddOwner(Type ^ ownerType, System::Windows::PropertyMetadata ^ typeMetadata);" />
      <MemberSignature Language="F#" Value="member this.AddOwner : Type * System.Windows.PropertyMetadata -&gt; System.Windows.DependencyProperty" Usage="dependencyProperty.AddOwner (ownerType, typeMetadata)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ownerType" Type="System.Type" />
        <Parameter Name="typeMetadata" Type="System.Windows.PropertyMetadata" />
      </Parameters>
      <Docs>
        <param name="ownerType">
          <span data-ttu-id="8e0b6-163">要作为此依赖属性所有者添加的类型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e0b6-163">The type to add as owner of this dependency property.</span>
          </span>
        </param>
        <param name="typeMetadata">
          <span data-ttu-id="8e0b6-164">在依赖属性存在于所提供的类型上时对其进行限定的元数据。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e0b6-164">The metadata that qualifies the dependency property as it exists on the provided type.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="8e0b6-165">将其他类型添加为已注册的依赖对象所有者，从而为依赖属性提供依赖属性元数据使其存在于提供的所有者类型上。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e0b6-165">Adds another type as an owner of a dependency property that has already been registered, providing dependency property metadata for the dependency property as it will exist on the provided owner type.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="8e0b6-166">一个引用，它指向可标识依赖属性的原始 <see cref="T:System.Windows.DependencyProperty" /> 标识符。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e0b6-166">A reference to the original <see cref="T:System.Windows.DependencyProperty" /> identifier that identifies the dependency property.</span>
          </span>
          <span data-ttu-id="8e0b6-167">应通过将类添加为 <see langword="public static readonly" /> 字段来公开此标识符。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e0b6-167">This identifier should be exposed by the adding class as a <see langword="public static readonly" /> field.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8e0b6-168">此方法使属性系统最初未注册该特定的依赖项属性的类型上识别依赖项属性。</span><span class="sxs-lookup"><span data-stu-id="8e0b6-168">This method enables the property system to recognize a dependency property on a type that did not register that particular dependency property initially.</span></span>  
  
 <span data-ttu-id="8e0b6-169">此方法的返回值用来声明和公开的依赖项属性，尤其是当它位于添加的所有者类。</span><span class="sxs-lookup"><span data-stu-id="8e0b6-169">The return value of this method is used to declare and expose the dependency property, particularly as it exists on the adding owner class.</span></span> <span data-ttu-id="8e0b6-170">通常情况下，应使用原始所有者和所有者添加的相同属性名称以指示类似的功能。</span><span class="sxs-lookup"><span data-stu-id="8e0b6-170">Generally, the same property name for both original owner and added owner should be used to indicate the similar functionality.</span></span> <span data-ttu-id="8e0b6-171">它是公开的标识符，以及新的好办法[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]属性的包装器，将添加到使用的类型的依赖项属性<xref:System.Windows.DependencyProperty.AddOwner%2A>。</span><span class="sxs-lookup"><span data-stu-id="8e0b6-171">It is good practice to expose the identifiers, as well as new [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] property wrappers, for dependency properties that are added to types using <xref:System.Windows.DependencyProperty.AddOwner%2A>.</span></span>  
  
 <span data-ttu-id="8e0b6-172"><xref:System.Windows.DependencyProperty.AddOwner%2A>上面建议的方法使用创建时[!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)]中声明[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]。</span><span class="sxs-lookup"><span data-stu-id="8e0b6-172">The <xref:System.Windows.DependencyProperty.AddOwner%2A> methodology recommended above is used when creating [!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)] declared within [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)].</span></span> <span data-ttu-id="8e0b6-173">例如，同时<xref:System.Windows.Controls.Border>并<xref:System.Windows.Controls.Control>定义`BorderBrush`依赖项属性，具有类似的功能。</span><span class="sxs-lookup"><span data-stu-id="8e0b6-173">For instance, both <xref:System.Windows.Controls.Border> and <xref:System.Windows.Controls.Control> define a `BorderBrush` dependency property, which have similar functionality.</span></span> <span data-ttu-id="8e0b6-174"><xref:System.Windows.Controls.Control> 定义其`BorderBrush`属性设置为通过调用属性系统<xref:System.Windows.DependencyProperty.AddOwner%2A>上原始所有者<xref:System.Windows.Controls.Border>且其已注册<xref:System.Windows.Controls.Border.BorderBrushProperty>依赖项属性标识符。</span><span class="sxs-lookup"><span data-stu-id="8e0b6-174"><xref:System.Windows.Controls.Control> defines its `BorderBrush` property to the property system by calling <xref:System.Windows.DependencyProperty.AddOwner%2A> on original owner <xref:System.Windows.Controls.Border> and its registered <xref:System.Windows.Controls.Border.BorderBrushProperty> dependency property identifer.</span></span> <span data-ttu-id="8e0b6-175"><xref:System.Windows.DependencyProperty.AddOwner%2A>返回值然后用于建立一个静态<xref:System.Windows.DependencyProperty>字段 (<xref:System.Windows.Controls.Control.BorderBrushProperty>) 上添加所有者，该属性和一个`BorderBrush`还声明属性包装器。</span><span class="sxs-lookup"><span data-stu-id="8e0b6-175">The <xref:System.Windows.DependencyProperty.AddOwner%2A> return value is then used to establish a static <xref:System.Windows.DependencyProperty> field (<xref:System.Windows.Controls.Control.BorderBrushProperty>) for that property on the added owner, and a `BorderBrush` property wrapper is also declared.</span></span>  
  
 <span data-ttu-id="8e0b6-176">添加的所有者的依赖项属性标识符应使用的操作如<xref:System.Windows.DependencyObject.GetValue%2A>。</span><span class="sxs-lookup"><span data-stu-id="8e0b6-176">The added owner's dependency property identifier should be used for operations such as <xref:System.Windows.DependencyObject.GetValue%2A>.</span></span> <span data-ttu-id="8e0b6-177">但是，涉及类型或如仍将具有不同的元数据所有者添加的类的实例的特定于类型的操作返回预期的结果，即使原始 （未添加的所有者） 中指定依赖项属性标识符调用方法如<xref:System.Windows.DependencyObject.GetValue%2A>或<xref:System.Windows.DependencyProperty.GetMetadata%2A>。</span><span class="sxs-lookup"><span data-stu-id="8e0b6-177">However, type-specific operations involving either types or instances of the class that was added as owner with different metadata will still return the expected results even if the original (not the added owner's) dependency property identifier is specified in calls to methods such as <xref:System.Windows.DependencyObject.GetValue%2A> or <xref:System.Windows.DependencyProperty.GetMetadata%2A>.</span></span> <span data-ttu-id="8e0b6-178">添加的所有者的元数据会保留通过<xref:System.Windows.DependencyProperty.AddOwner%2A>调用本身并不一定以独占方式引用添加的所有者类标识符字段。</span><span class="sxs-lookup"><span data-stu-id="8e0b6-178">The metadata for the added owner is perpetuated by the <xref:System.Windows.DependencyProperty.AddOwner%2A> call itself, not necessarily referenced exclusively by the adding owner class identifier field.</span></span> <span data-ttu-id="8e0b6-179">不过，它是公开的标识符，以及新的好办法[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]属性的包装器，将添加到使用的类型的依赖关系属性<xref:System.Windows.DependencyProperty.AddOwner%2A>，因为如果不这样做产生之间的差异[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]和[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]您的属性的表示形式。</span><span class="sxs-lookup"><span data-stu-id="8e0b6-179">Nevertheless, it is good practice to expose the  identifier, as well as new [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] property wrappers, for dependency properties that are added to types using <xref:System.Windows.DependencyProperty.AddOwner%2A>, because failing to do so creates disparity between the [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] and [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] representations of your properties.</span></span>  
  
 <span data-ttu-id="8e0b6-180">提供的元数据合并的依赖项属性的属性元数据存在于基所有者上。</span><span class="sxs-lookup"><span data-stu-id="8e0b6-180">The supplied metadata is merged with the property metadata for the dependency property as it exists on the base owner.</span></span> <span data-ttu-id="8e0b6-181">将保留原始的基本元数据中指定的任何特征。</span><span class="sxs-lookup"><span data-stu-id="8e0b6-181">Any characteristics that were specified in the original base metadata will persist.</span></span> <span data-ttu-id="8e0b6-182">仅已专门在新的元数据中更改这些特性将重写的基本元数据的特征。</span><span class="sxs-lookup"><span data-stu-id="8e0b6-182">Only those characteristics that were specifically changed in the new metadata will override the characteristics of the base metadata.</span></span> <span data-ttu-id="8e0b6-183">一些特征，如<xref:System.Windows.PropertyMetadata.DefaultValue%2A>，如果在新的元数据中指定了替换。</span><span class="sxs-lookup"><span data-stu-id="8e0b6-183">Some characteristics, such as <xref:System.Windows.PropertyMetadata.DefaultValue%2A>, are replaced if they are specified in the new metadata.</span></span> <span data-ttu-id="8e0b6-184">其他人，例如<xref:System.Windows.PropertyChangedCallback>，组合。</span><span class="sxs-lookup"><span data-stu-id="8e0b6-184">Others, such as <xref:System.Windows.PropertyChangedCallback>, are combined.</span></span> <span data-ttu-id="8e0b6-185">从根本上讲，合并行为取决于用于重写时，因此此处所述的行为是使用的现有属性的元数据类的属性元数据类型[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]依赖项属性。</span><span class="sxs-lookup"><span data-stu-id="8e0b6-185">Ultimately, the merge behavior depends on the property metadata type being used for the override, so the behavior described here is for the existing property metadata classes used by [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] dependency properties.</span></span> <span data-ttu-id="8e0b6-186">有关详细信息，请参阅[依赖属性元数据](~/docs/framework/wpf/advanced/dependency-property-metadata.md)并[框架属性元数据](~/docs/framework/wpf/advanced/framework-property-metadata.md)。</span><span class="sxs-lookup"><span data-stu-id="8e0b6-186">For details, see [Dependency Property Metadata](~/docs/framework/wpf/advanced/dependency-property-metadata.md) and [Framework Property Metadata](~/docs/framework/wpf/advanced/framework-property-metadata.md).</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultMetadata">
      <MemberSignature Language="C#" Value="public System.Windows.PropertyMetadata DefaultMetadata { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.PropertyMetadata DefaultMetadata" />
      <MemberSignature Language="DocId" Value="P:System.Windows.DependencyProperty.DefaultMetadata" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DefaultMetadata As PropertyMetadata" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::PropertyMetadata ^ DefaultMetadata { System::Windows::PropertyMetadata ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DefaultMetadata : System.Windows.PropertyMetadata" Usage="System.Windows.DependencyProperty.DefaultMetadata" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.PropertyMetadata</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="8e0b6-187">获取依赖项对象的默认元数据。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e0b6-187">Gets the default metadata of the dependency property.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="8e0b6-188">依赖项对象的默认元数据。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e0b6-188">The default metadata of the dependency property.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8e0b6-189">默认元数据是可供该特定对象或派生类型的对象，通过显式提供了没有备用的元数据的属性元数据<xref:System.Windows.DependencyProperty.Register%2A>或<xref:System.Windows.DependencyProperty.OverrideMetadata%2A>调用。</span><span class="sxs-lookup"><span data-stu-id="8e0b6-189">The default metadata is the property metadata that is available to that particular object or an object of a derived type where no alternative metadata was supplied by an explicit <xref:System.Windows.DependencyProperty.Register%2A> or <xref:System.Windows.DependencyProperty.OverrideMetadata%2A> call.</span></span>  
  
 <span data-ttu-id="8e0b6-190">如果原始所有者元数据应用到第一个<xref:System.Windows.DependencyProperty.Register%2A>建立依赖关系属性，则为返回的元数据的调用<xref:System.Windows.DependencyProperty.DefaultMetadata%2A>。</span><span class="sxs-lookup"><span data-stu-id="8e0b6-190">If the original owner applied metadata to the first <xref:System.Windows.DependencyProperty.Register%2A> call that established the dependency property, then that metadata is returned as <xref:System.Windows.DependencyProperty.DefaultMetadata%2A>.</span></span>  
  
 <span data-ttu-id="8e0b6-191">如果没有元数据中原始应用<xref:System.Windows.DependencyProperty.Register%2A>调用，则默认元数据生成内<xref:System.Windows.DependencyProperty.Register%2A>调用并将此值将作为<xref:System.Windows.DependencyProperty.DefaultMetadata%2A>。</span><span class="sxs-lookup"><span data-stu-id="8e0b6-191">If no metadata was applied in the original <xref:System.Windows.DependencyProperty.Register%2A> call, then default metadata is generated from within the <xref:System.Windows.DependencyProperty.Register%2A> call and this value is returned as the <xref:System.Windows.DependencyProperty.DefaultMetadata%2A>.</span></span>  
  
 <span data-ttu-id="8e0b6-192">具有与关联的默认元数据的主要目的<xref:System.Windows.DependencyProperty>是提供任何上此属性的默认值<xref:System.Windows.DependencyObject>或派生的类型。</span><span class="sxs-lookup"><span data-stu-id="8e0b6-192">The main purpose of having default metadata associated with a <xref:System.Windows.DependencyProperty> is to supply a default value for this property on any <xref:System.Windows.DependencyObject> or a derived type.</span></span>  
  
 <span data-ttu-id="8e0b6-193">对于非附加属性，此属性返回的元数据类型不能强制转换为派生类型的<xref:System.Windows.PropertyMetadata>类型，即使该属性最初注册的派生的元数据类型。</span><span class="sxs-lookup"><span data-stu-id="8e0b6-193">For nonattached properties, the metadata type returned by this property cannot be cast to derived types of <xref:System.Windows.PropertyMetadata> type, even if the property was originally registered with a derived metadata type.</span></span> <span data-ttu-id="8e0b6-194">如果您希望最初已注册的元数据，包括其原始的可能是派生的元数据类型，调用<xref:System.Windows.DependencyProperty.GetMetadata%28System.Type%29>相反，传递原始注册类型用作参数。</span><span class="sxs-lookup"><span data-stu-id="8e0b6-194">If you want the originally registered metadata including its original possibly derived metadata type, call <xref:System.Windows.DependencyProperty.GetMetadata%28System.Type%29> instead, passing the original registering type as a parameter.</span></span>  
  
 <span data-ttu-id="8e0b6-195">对于附加属性，返回此属性的元数据的类型将与原始中给定的类型匹配<xref:System.Windows.DependencyProperty.RegisterAttached%2A>注册方法。</span><span class="sxs-lookup"><span data-stu-id="8e0b6-195">For attached properties, the type of the metadata returned by this property will match the type given in the original <xref:System.Windows.DependencyProperty.RegisterAttached%2A> registration method.</span></span>  
  
   
  
## Examples  
 [!code-csharp[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpgetmetadatasingle)]
 [!code-vb[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpgetmetadatasingle)]  
[!code-csharp[PropertySystemEsoterics#DPDefaultValue](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpdefaultvalue)]
[!code-vb[PropertySystemEsoterics#DPDefaultValue](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpdefaultvalue)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="dependencyProperty.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="8e0b6-196">返回此 <see cref="T:System.Windows.DependencyProperty" /> 的哈希代码。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e0b6-196">Returns a hash code for this <see cref="T:System.Windows.DependencyProperty" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="8e0b6-197">此 <see cref="T:System.Windows.DependencyProperty" /> 的哈希代码。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e0b6-197">The hash code for this <see cref="T:System.Windows.DependencyProperty" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8e0b6-198">属性系统使用其自己的唯一标识符<xref:System.Windows.DependencyProperty.GlobalIndex%2A>，并返回该属性的值<xref:System.Windows.DependencyProperty.GetHashCode%2A>。</span><span class="sxs-lookup"><span data-stu-id="8e0b6-198">The property system uses its own unique identifier <xref:System.Windows.DependencyProperty.GlobalIndex%2A>, and the value of that property is returned by <xref:System.Windows.DependencyProperty.GetHashCode%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetMetadata">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="8e0b6-199">返回与此依赖属性关联的的元数据（只要它对于特定的类型存在）。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e0b6-199">Returns the metadata associated with this dependency property as it exists for a particular type.</span>
          </span>
          <span data-ttu-id="8e0b6-200">它可以是在其中首次注册依赖属性的类型、随后将其添加到的类型，或在其中通过继承获取依赖属性而已专门重写元数据的类型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e0b6-200">This can be the type where the dependency property was first registered, one to which it was added subsequently, or a type where the dependency property was obtained through inheritance but the metadata was specifically overridden.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetMetadata">
      <MemberSignature Language="C#" Value="public System.Windows.PropertyMetadata GetMetadata (Type forType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.PropertyMetadata GetMetadata(class System.Type forType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.GetMetadata(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMetadata (forType As Type) As PropertyMetadata" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::PropertyMetadata ^ GetMetadata(Type ^ forType);" />
      <MemberSignature Language="F#" Value="member this.GetMetadata : Type -&gt; System.Windows.PropertyMetadata" Usage="dependencyProperty.GetMetadata forType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.PropertyMetadata</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="forType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="forType">
          <span data-ttu-id="8e0b6-201">要从中检索依赖属性元数据的特定类型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e0b6-201">The specific type from which to retrieve the dependency property metadata.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="8e0b6-202">返回此依赖属性的元数据，因为它存在于指定的现有类型上。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e0b6-202">Returns the metadata for this dependency property as it exists on a specified existing type.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="8e0b6-203">属性元数据对象。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e0b6-203">A property metadata object.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8e0b6-204">指定的类型或对象引用，以用作类是必需的元数据可能会不同于最初注册原因可能是因为<xref:System.Windows.DependencyProperty.AddOwner%2A>或<xref:System.Windows.DependencyProperty.OverrideMetadata%2A>更改依赖项属性的元数据，因为它存在于上一种类型的调用。</span><span class="sxs-lookup"><span data-stu-id="8e0b6-204">Specifying either the type or an object reference to use as type is necessary because the metadata can vary from the original registration due either to <xref:System.Windows.DependencyProperty.AddOwner%2A> or <xref:System.Windows.DependencyProperty.OverrideMetadata%2A> calls that alter the metadata of the dependency property as it exists on a type.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="8e0b6-205">下面的示例获取基于其类型的依赖项属性的元数据。</span><span class="sxs-lookup"><span data-stu-id="8e0b6-205">The following example gets metadata for a dependency property based on its type.</span></span> <span data-ttu-id="8e0b6-206">通过使用获取类型`typeof`运算符。</span><span class="sxs-lookup"><span data-stu-id="8e0b6-206">The type is obtained by using a `typeof` operator.</span></span>  
  
 [!code-csharp[PropertySystemEsoterics#GetMetadataType](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/default.xaml.cs#getmetadatatype)]
 [!code-vb[PropertySystemEsoterics#GetMetadataType](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/default.xaml.vb#getmetadatatype)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMetadata">
      <MemberSignature Language="C#" Value="public System.Windows.PropertyMetadata GetMetadata (System.Windows.DependencyObject dependencyObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.PropertyMetadata GetMetadata(class System.Windows.DependencyObject dependencyObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.GetMetadata(System.Windows.DependencyObject)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::PropertyMetadata ^ GetMetadata(System::Windows::DependencyObject ^ dependencyObject);" />
      <MemberSignature Language="F#" Value="member this.GetMetadata : System.Windows.DependencyObject -&gt; System.Windows.PropertyMetadata" Usage="dependencyProperty.GetMetadata dependencyObject" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.PropertyMetadata</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dependencyObject" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="dependencyObject">
          <span data-ttu-id="8e0b6-207">一个依赖对象，检查了其类型，以便确定元数据应来自依赖属性的哪个类型特定版本。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e0b6-207">A dependency object that is checked for type, to determine which type-specific version of the dependency property the metadata should come from.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="8e0b6-208">返回此依赖属性的元数据，因为它存在于指定的对象实例上。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e0b6-208">Returns the metadata for this dependency property as it exists on the specified object instance.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="8e0b6-209">属性元数据对象。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e0b6-209">A property metadata object.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8e0b6-210">指定的类型或对象引用必需的任何给定的依赖属性元数据可能会不同于最初注册原因可能是因为<xref:System.Windows.DependencyProperty.AddOwner%2A>或<xref:System.Windows.DependencyProperty.OverrideMetadata%2A>可以优化属性元数据，因为它存在于上调用类型。</span><span class="sxs-lookup"><span data-stu-id="8e0b6-210">Specifying either the type or an object reference is necessary because the metadata of any given dependency property can vary from the original registration due either to <xref:System.Windows.DependencyProperty.AddOwner%2A> or <xref:System.Windows.DependencyProperty.OverrideMetadata%2A> calls that can refine the property metadata as it exists on a type.</span></span>  
  
 <span data-ttu-id="8e0b6-211">当请求基于实例的属性元数据时，实际上只传递该实例，以便可以在内部计算它的类型。</span><span class="sxs-lookup"><span data-stu-id="8e0b6-211">When you request property metadata based on an instance, you are really just passing the instance so that its type can be evaluated internally.</span></span> <span data-ttu-id="8e0b6-212">依赖属性元数据没有改变每个实例;它始终是一致的任意给定的类型的属性组合。</span><span class="sxs-lookup"><span data-stu-id="8e0b6-212">Dependency property metadata does not vary per instance; it is always consistent for any given type-property combination.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="8e0b6-213">下面的示例获取基于特定的依赖项属性的元数据<xref:System.Windows.DependencyObject>实例。</span><span class="sxs-lookup"><span data-stu-id="8e0b6-213">The following example gets metadata for a dependency property based on a specific <xref:System.Windows.DependencyObject> instance.</span></span>  
  
 [!code-csharp[PropertySystemEsoterics#GetMetadataDOInstance](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/default.xaml.cs#getmetadatadoinstance)]
 [!code-vb[PropertySystemEsoterics#GetMetadataDOInstance](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/default.xaml.vb#getmetadatadoinstance)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMetadata">
      <MemberSignature Language="C#" Value="public System.Windows.PropertyMetadata GetMetadata (System.Windows.DependencyObjectType dependencyObjectType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.PropertyMetadata GetMetadata(class System.Windows.DependencyObjectType dependencyObjectType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.GetMetadata(System.Windows.DependencyObjectType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::PropertyMetadata ^ GetMetadata(System::Windows::DependencyObjectType ^ dependencyObjectType);" />
      <MemberSignature Language="F#" Value="member this.GetMetadata : System.Windows.DependencyObjectType -&gt; System.Windows.PropertyMetadata" Usage="dependencyProperty.GetMetadata dependencyObjectType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.PropertyMetadata</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dependencyObjectType" Type="System.Windows.DependencyObjectType" />
      </Parameters>
      <Docs>
        <param name="dependencyObjectType">
          <span data-ttu-id="8e0b6-214">一个特定对象，该对象记录需要其中的依赖属性元数据的依赖项对象类型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e0b6-214">A specific object that records the dependency object type from which the dependency property metadata is desired.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="8e0b6-215">为此依赖属性（当它位于指定的对象实例上时）返回元数据。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e0b6-215">Returns the metadata for this dependency property as it exists on a specified type.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="8e0b6-216">属性元数据对象。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e0b6-216">A property metadata object.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8e0b6-217">指定的类型或对象引用必需的任何给定的依赖属性元数据可能会不同于最初注册原因可能是因为<xref:System.Windows.DependencyProperty.AddOwner%2A>或<xref:System.Windows.DependencyProperty.OverrideMetadata%2A>可以优化属性元数据，因为它存在于上调用类型。</span><span class="sxs-lookup"><span data-stu-id="8e0b6-217">Specifying either the type or an object reference is necessary because the metadata of any given dependency property can vary from the original registration due either to <xref:System.Windows.DependencyProperty.AddOwner%2A> or <xref:System.Windows.DependencyProperty.OverrideMetadata%2A> calls that can refine the property metadata as it exists on a type.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="8e0b6-218">下面的示例获取基于依赖项属性的元数据其<xref:System.Windows.DependencyObjectType>。</span><span class="sxs-lookup"><span data-stu-id="8e0b6-218">The following example gets metadata for a dependency property based on its <xref:System.Windows.DependencyObjectType>.</span></span>  
  
 [!code-csharp[PropertySystemEsoterics#GetMetadataDOType](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/default.xaml.cs#getmetadatadotype)]
 [!code-vb[PropertySystemEsoterics#GetMetadataDOType](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/default.xaml.vb#getmetadatadotype)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GlobalIndex">
      <MemberSignature Language="C#" Value="public int GlobalIndex { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 GlobalIndex" />
      <MemberSignature Language="DocId" Value="P:System.Windows.DependencyProperty.GlobalIndex" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property GlobalIndex As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int GlobalIndex { int get(); };" />
      <MemberSignature Language="F#" Value="member this.GlobalIndex : int" Usage="System.Windows.DependencyProperty.GlobalIndex" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="8e0b6-219">获取唯一标识依赖项对象的内部生成值。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e0b6-219">Gets an internally generated value that uniquely identifies the dependency property.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="8e0b6-220">唯一数字标识符。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e0b6-220">A unique numeric identifier.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8e0b6-221">此值是一个整数，未一个全局唯一标识符 (GUID)。</span><span class="sxs-lookup"><span data-stu-id="8e0b6-221">This value is an integer, not a globally unique identifier (GUID).</span></span> <span data-ttu-id="8e0b6-222">通常情况下，使用此索引值不是必需的并且没有任何索引访问表的所有依赖项属性。</span><span class="sxs-lookup"><span data-stu-id="8e0b6-222">Generally, using this index value is not required, and there is no index access to tables of all dependency properties.</span></span> <span data-ttu-id="8e0b6-223">而是应由其标识符字段引用依赖项属性。</span><span class="sxs-lookup"><span data-stu-id="8e0b6-223">Dependency properties should instead be referenced by their identifier fields.</span></span>  
  
 <span data-ttu-id="8e0b6-224"><xref:System.Windows.DependencyProperty.GlobalIndex%2A> 在内部使用，更快地访问使用的数据结构<xref:System.Windows.DependencyProperty.GlobalIndex%2A>为从零开始的数组索引。</span><span class="sxs-lookup"><span data-stu-id="8e0b6-224"><xref:System.Windows.DependencyProperty.GlobalIndex%2A> is used internally for faster access to data structures that use the <xref:System.Windows.DependencyProperty.GlobalIndex%2A> as a zero-based array index.</span></span> <span data-ttu-id="8e0b6-225">类似的使用情况可能会有应用程序设计器或工具。</span><span class="sxs-lookup"><span data-stu-id="8e0b6-225">A similar usage might have applications for designers or tools.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsValidType">
      <MemberSignature Language="C#" Value="public bool IsValidType (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsValidType(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.IsValidType(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsValidType (value As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsValidType(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="member this.IsValidType : obj -&gt; bool" Usage="dependencyProperty.IsValidType value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="8e0b6-226">要检查的值。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e0b6-226">The value to check.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="8e0b6-227">确定指定的值对于该依赖项对象的类型是否可接受（与原依赖项对象注册中提供的属性类型相对照）。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e0b6-227">Determines whether a specified value is acceptable for this dependency property's type, as checked against the property type provided in the original dependency property registration.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="8e0b6-228">如果指定的值是已注册的属性类型或可接受的派生类型，则为 <see langword="true" />；否则为 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e0b6-228">
              <see langword="true" /> if the specified value is the registered property type or an acceptable derived type; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8e0b6-229">值为`null`是有效类型为引用类型依赖属性，或<xref:System.Nullable%601>依赖项属性，并将返回`true`这种情况下。</span><span class="sxs-lookup"><span data-stu-id="8e0b6-229">A value of `null` is a valid type for reference type dependency properties, or for a <xref:System.Nullable%601> dependency property, and would return `true` for these cases.</span></span> <span data-ttu-id="8e0b6-230">在其中依赖项属性是既不是引用的情况下也不是<xref:System.Nullable%601>类型，<xref:System.Windows.DependencyProperty.IsValidType%2A>将返回`false`的 null 值，而不是引发异常。</span><span class="sxs-lookup"><span data-stu-id="8e0b6-230">In cases where the dependency property is neither a reference nor a <xref:System.Nullable%601> type, <xref:System.Windows.DependencyProperty.IsValidType%2A> will return `false` for a null value rather than raise an exception.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="8e0b6-231">下面的示例使用<xref:System.Windows.DependencyProperty.IsValidType%2A>作为一种检查之前调用<xref:System.Windows.DependencyObject.SetValue%2A>的依赖属性。</span><span class="sxs-lookup"><span data-stu-id="8e0b6-231">The following example uses <xref:System.Windows.DependencyProperty.IsValidType%2A> as a check before calling <xref:System.Windows.DependencyObject.SetValue%2A> on the dependency property.</span></span>  
  
 [!code-csharp[PropertySystemEsoterics#TrySetValue](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#trysetvalue)]
 [!code-vb[PropertySystemEsoterics#TrySetValue](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#trysetvalue)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsValidValue">
      <MemberSignature Language="C#" Value="public bool IsValidValue (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsValidValue(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.IsValidValue(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsValidValue (value As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsValidValue(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="member this.IsValidValue : obj -&gt; bool" Usage="dependencyProperty.IsValidValue value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="8e0b6-232">要检查的值。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e0b6-232">The value to check.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="8e0b6-233">确定所提供的值通过基本类型检查后是否被属性类型接受，以及它是否有可能在该类型的值的允许范围以内。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e0b6-233">Determines whether the provided value is accepted for the type of property through basic type checking, and also potentially if it is within the allowed range of values for that type.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="8e0b6-234">如果值是可接受的，并且具有正确的类型或派生类型，则为 <see langword="true" />；否则为 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e0b6-234">
              <see langword="true" /> if the value is acceptable and is of the correct type or a derived type; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8e0b6-235">对于依赖项属性，可以通过指定该类型的值的允许的范围<xref:System.Windows.ValidateValueCallback>依赖关系属性注册中提供的。</span><span class="sxs-lookup"><span data-stu-id="8e0b6-235">For a dependency property, an allowed range of values for that type can be specified through a <xref:System.Windows.ValidateValueCallback> that is provided in the dependency property registration.</span></span>  
  
 <span data-ttu-id="8e0b6-236">此方法调用<xref:System.Windows.DependencyProperty.IsValidType%2A>在内部。</span><span class="sxs-lookup"><span data-stu-id="8e0b6-236">This method calls <xref:System.Windows.DependencyProperty.IsValidType%2A> internally.</span></span> <span data-ttu-id="8e0b6-237">如果有问题的依赖关系属性不具有<xref:System.Windows.ValidateValueCallback>，则调用此方法是有效地等效于调用<xref:System.Windows.DependencyProperty.IsValidType%2A>。</span><span class="sxs-lookup"><span data-stu-id="8e0b6-237">If the dependency property in question has no <xref:System.Windows.ValidateValueCallback>,then calling this method is effectively equivalent to calling <xref:System.Windows.DependencyProperty.IsValidType%2A>.</span></span> <span data-ttu-id="8e0b6-238">如果具有依赖关系属性<xref:System.Windows.ValidateValueCallback>，并且如果<xref:System.Windows.DependencyProperty.IsValidType%2A>将返回`true`，则在回调中实现时将返回的值。</span><span class="sxs-lookup"><span data-stu-id="8e0b6-238">If the dependency property does have a <xref:System.Windows.ValidateValueCallback>, and if <xref:System.Windows.DependencyProperty.IsValidType%2A> would have returned `true`, then the value returned will be as implemented in the callback.</span></span>  
  
 <span data-ttu-id="8e0b6-239">Null 值是有效的值为引用类型依赖属性，或<xref:System.Nullable%601>依赖项属性，并将返回`true`这种情况下。</span><span class="sxs-lookup"><span data-stu-id="8e0b6-239">A null value is a valid value for reference type dependency properties, or for a <xref:System.Nullable%601> dependency property, and would return `true` for these cases.</span></span> <span data-ttu-id="8e0b6-240">在其中依赖项属性是既不是引用的情况下也不是<xref:System.Nullable%601>类型，<xref:System.Windows.DependencyProperty.IsValidType%2A>将返回`false`的 null 值，而不是引发异常。</span><span class="sxs-lookup"><span data-stu-id="8e0b6-240">In cases where the dependency property is neither a reference nor a <xref:System.Nullable%601> type, <xref:System.Windows.DependencyProperty.IsValidType%2A> will return `false` for a null value rather than raise an exception.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="8e0b6-241">下面的示例使用<xref:System.Windows.DependencyProperty.IsValidValue%2A>作为一种检查之前调用<xref:System.Windows.DependencyObject.SetValue%2A>的依赖属性。</span><span class="sxs-lookup"><span data-stu-id="8e0b6-241">The following example uses <xref:System.Windows.DependencyProperty.IsValidValue%2A> as a check before calling <xref:System.Windows.DependencyObject.SetValue%2A> on the dependency property.</span></span>  
  
 [!code-csharp[PropertySystemEsoterics#TrySetValueWithValidate](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#trysetvaluewithvalidate)]
 [!code-vb[PropertySystemEsoterics#TrySetValueWithValidate](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#trysetvaluewithvalidate)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Windows.DependencyProperty.Name" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Name { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Name : string" Usage="System.Windows.DependencyProperty.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="8e0b6-242">获取依赖属性的名称。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e0b6-242">Gets the name of the dependency property.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="8e0b6-243">属性的名称。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e0b6-243">The name of the property.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8e0b6-244">此属性获取形式提供的名称`name`依赖关系属性注册过程的参数。</span><span class="sxs-lookup"><span data-stu-id="8e0b6-244">This property gets the name provided as the `name` parameter during dependency property registration.</span></span> <span data-ttu-id="8e0b6-245">此名称是不可变的并且不能为`null`或空字符串。</span><span class="sxs-lookup"><span data-stu-id="8e0b6-245">This name is immutable, and cannot be `null` or an empty string.</span></span> <span data-ttu-id="8e0b6-246">重复名称注册相同的所有者类型上不允许使用，并尝试注册重复的情况下将引发异常。</span><span class="sxs-lookup"><span data-stu-id="8e0b6-246">Duplicate name registrations on the same owner type are not permitted, and will throw an exception when you attempt to register the duplicate.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="8e0b6-247"><xref:System.Windows.DependencyProperty.Name%2A>的依赖项属性必须遵循的去掉后缀"Property"其依赖项属性标识符的名称匹配的约定。</span><span class="sxs-lookup"><span data-stu-id="8e0b6-247">The <xref:System.Windows.DependencyProperty.Name%2A> of a dependency property must follow the convention of matching the name of its dependency property identifier minus the suffix "Property".</span></span> <span data-ttu-id="8e0b6-248">有关详细信息，请参阅[自定义依赖属性](~/docs/framework/wpf/advanced/custom-dependency-properties.md)。</span><span class="sxs-lookup"><span data-stu-id="8e0b6-248">For details, see [Custom Dependency Properties](~/docs/framework/wpf/advanced/custom-dependency-properties.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="8e0b6-249">下面的示例查询依赖项属性标识符的各种特征包括<xref:System.Windows.DependencyProperty.Name%2A>。</span><span class="sxs-lookup"><span data-stu-id="8e0b6-249">The following example queries various characteristics of a dependency property identifier, including the <xref:System.Windows.DependencyProperty.Name%2A>.</span></span>  
  
 [!code-csharp[PropertySystemEsoterics#DPProps](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpprops)]
 [!code-vb[PropertySystemEsoterics#DPProps](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpprops)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="OverrideMetadata">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="8e0b6-250">当此依赖属性位于指定类型的实例上时为其提供替换元数据（而不是在最初注册依赖属性时提供的元数据）。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e0b6-250">Supplies alternate metadata for this dependency property when it is present on instances of a specified type, versus the metadata that was provided in the initial dependency property registration.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OverrideMetadata">
      <MemberSignature Language="C#" Value="public void OverrideMetadata (Type forType, System.Windows.PropertyMetadata typeMetadata);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void OverrideMetadata(class System.Type forType, class System.Windows.PropertyMetadata typeMetadata) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata)" />
      <MemberSignature Language="VB.NET" Value="Public Sub OverrideMetadata (forType As Type, typeMetadata As PropertyMetadata)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void OverrideMetadata(Type ^ forType, System::Windows::PropertyMetadata ^ typeMetadata);" />
      <MemberSignature Language="F#" Value="member this.OverrideMetadata : Type * System.Windows.PropertyMetadata -&gt; unit" Usage="dependencyProperty.OverrideMetadata (forType, typeMetadata)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="forType" Type="System.Type" />
        <Parameter Name="typeMetadata" Type="System.Windows.PropertyMetadata" />
      </Parameters>
      <Docs>
        <param name="forType">
          <span data-ttu-id="8e0b6-251">一种类型，在该类型上继承该依赖属性并将应用所提供的替换元数据。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e0b6-251">The type where this dependency property is inherited and where the provided alternate metadata will be applied.</span>
          </span>
        </param>
        <param name="typeMetadata">
          <span data-ttu-id="8e0b6-252">一种元数据，它将应用于重写类型上的依赖属性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e0b6-252">The metadata to apply to the dependency property on the overriding type.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="8e0b6-253">当此依赖属性位于指定类型的实例上时为其指定替换元数据，以在该依赖属性继承自基类型时重写该属性已存在的元数据。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e0b6-253">Specifies alternate metadata for this dependency property when it is present on instances of a specified type, overriding the metadata that existed for the dependency property as it was inherited from base types.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8e0b6-254">应重写依赖属性元数据，然后再属性系统将使用依赖项属性。</span><span class="sxs-lookup"><span data-stu-id="8e0b6-254">Dependency property metadata should be overridden before the property system uses the dependency property.</span></span> <span data-ttu-id="8e0b6-255">这相当于使用注册依赖属性的类来创建特定实例的时间。</span><span class="sxs-lookup"><span data-stu-id="8e0b6-255">This equates to the time that specific instances are created using the class that registers the dependency property.</span></span> <span data-ttu-id="8e0b6-256">调用<xref:System.Windows.DependencyProperty.OverrideMetadata%2A>仅在为自己提供的类型的静态构造函数中执行`forType`参数，此方法，或通过相似的实例化。</span><span class="sxs-lookup"><span data-stu-id="8e0b6-256">Calls to <xref:System.Windows.DependencyProperty.OverrideMetadata%2A> should only be performed within the static constructors of the type that provides itself as the `forType` parameter of this method, or through similar instantiation.</span></span> <span data-ttu-id="8e0b6-257">尝试更改元数据的所有者类型的实例存在之后不会引发异常，但将导致属性系统中的不一致的行为。</span><span class="sxs-lookup"><span data-stu-id="8e0b6-257">Attempting to change metadata after instances of the owner type exist will not raise exceptions, but will result in inconsistent behaviors in the property system.</span></span>  
  
 <span data-ttu-id="8e0b6-258">对于特定的派生的类重写元数据建立使用此方法后，重写此相同的派生类上的元数据的后续尝试将引发异常。</span><span class="sxs-lookup"><span data-stu-id="8e0b6-258">After metadata for a particular derived class override is established with this method, subsequent attempts to override metadata on this same derived class will raise an exception.</span></span>  
  
 <span data-ttu-id="8e0b6-259">提供的元数据合并的依赖项属性的属性元数据存在于基所有者上。</span><span class="sxs-lookup"><span data-stu-id="8e0b6-259">The supplied metadata is merged with the property metadata for the dependency property as it exists on the base owner.</span></span> <span data-ttu-id="8e0b6-260">原始的基本元数据中指定的任何特征将保持不变;仅已专门在新的元数据中更改这些特性将重写的基本元数据的特征。</span><span class="sxs-lookup"><span data-stu-id="8e0b6-260">Any characteristics that were specified in the original base metadata will persist; only those characteristics that were specifically changed in the new metadata will override the characteristics of the base metadata.</span></span> <span data-ttu-id="8e0b6-261">如一些特征<xref:System.Windows.PropertyMetadata.DefaultValue%2A>如果在新的元数据中指定替换。</span><span class="sxs-lookup"><span data-stu-id="8e0b6-261">Some characteristics such as <xref:System.Windows.PropertyMetadata.DefaultValue%2A> are replaced if specified in the new metadata.</span></span> <span data-ttu-id="8e0b6-262">其他人，例如<xref:System.Windows.PropertyChangedCallback>，组合。</span><span class="sxs-lookup"><span data-stu-id="8e0b6-262">Others, such as <xref:System.Windows.PropertyChangedCallback>, are combined.</span></span> <span data-ttu-id="8e0b6-263">从根本上讲，合并行为取决于用于重写时，因此此处所述的行为是使用的现有属性的元数据类的属性元数据类型[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]依赖项属性。</span><span class="sxs-lookup"><span data-stu-id="8e0b6-263">Ultimately, the merge behavior depends on the property metadata type being used for the override, so the behavior described here is for the existing property metadata classes used by [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] dependency properties.</span></span> <span data-ttu-id="8e0b6-264">有关详细信息，请参阅[依赖属性元数据](~/docs/framework/wpf/advanced/dependency-property-metadata.md)并[框架属性元数据](~/docs/framework/wpf/advanced/framework-property-metadata.md)。</span><span class="sxs-lookup"><span data-stu-id="8e0b6-264">For details, see [Dependency Property Metadata](~/docs/framework/wpf/advanced/dependency-property-metadata.md) and [Framework Property Metadata](~/docs/framework/wpf/advanced/framework-property-metadata.md).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="8e0b6-265">尝试重写只读依赖属性的元数据（不能使用此签名完成该操作）。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e0b6-265">An attempt was made to override metadata on a read-only dependency property (that operation cannot be done using this signature).</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="8e0b6-266">已为依赖属性建立元数据，因为它存在于所提供的类型上。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e0b6-266">Metadata was already established for the dependency property as it exists on the provided type.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="OverrideMetadata">
      <MemberSignature Language="C#" Value="public void OverrideMetadata (Type forType, System.Windows.PropertyMetadata typeMetadata, System.Windows.DependencyPropertyKey key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void OverrideMetadata(class System.Type forType, class System.Windows.PropertyMetadata typeMetadata, class System.Windows.DependencyPropertyKey key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata,System.Windows.DependencyPropertyKey)" />
      <MemberSignature Language="VB.NET" Value="Public Sub OverrideMetadata (forType As Type, typeMetadata As PropertyMetadata, key As DependencyPropertyKey)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void OverrideMetadata(Type ^ forType, System::Windows::PropertyMetadata ^ typeMetadata, System::Windows::DependencyPropertyKey ^ key);" />
      <MemberSignature Language="F#" Value="member this.OverrideMetadata : Type * System.Windows.PropertyMetadata * System.Windows.DependencyPropertyKey -&gt; unit" Usage="dependencyProperty.OverrideMetadata (forType, typeMetadata, key)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="forType" Type="System.Type" />
        <Parameter Name="typeMetadata" Type="System.Windows.PropertyMetadata" />
        <Parameter Name="key" Type="System.Windows.DependencyPropertyKey" />
      </Parameters>
      <Docs>
        <param name="forType">
          <span data-ttu-id="8e0b6-267">一种类型，在该类型上继承该依赖属性并将应用所提供的替换元数据。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e0b6-267">The type where this dependency property is inherited and where the provided alternate metadata will be applied.</span>
          </span>
        </param>
        <param name="typeMetadata">
          <span data-ttu-id="8e0b6-268">一种元数据，它将应用于重写类型上的依赖属性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e0b6-268">The metadata to apply to the dependency property on the overriding type.</span>
          </span>
        </param>
        <param name="key">
          <span data-ttu-id="8e0b6-269">只读依赖属性的访问键。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e0b6-269">The access key for a read-only dependency property.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="8e0b6-270">当只读依赖属性位于指定类型的实例上时为其提供替换元数据，以便重写在最初注册依赖属性时提供的元数据。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e0b6-270">Supplies alternate metadata for a read-only dependency property when it is present on instances of a specified type, overriding the metadata that was provided in the initial dependency property registration.</span>
          </span>
          <span data-ttu-id="8e0b6-271">您必须为只读依赖项对象传递 <see cref="T:System.Windows.DependencyPropertyKey" />，以避免引发异常。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e0b6-271">You must pass the <see cref="T:System.Windows.DependencyPropertyKey" /> for the read-only dependency property to avoid raising an exception.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8e0b6-272">此签名提供了基础实现只读依赖属性标识符 (<xref:System.Windows.DependencyPropertyKey>) 方法。</span><span class="sxs-lookup"><span data-stu-id="8e0b6-272">This signature provides underlying implementation for a read-only dependency property identifier (<xref:System.Windows.DependencyPropertyKey>) method.</span></span> <span data-ttu-id="8e0b6-273">如果重写读写依赖属性元数据，使用<xref:System.Windows.DependencyProperty.OverrideMetadata%28System.Type%2CSystem.Windows.PropertyMetadata%29>。</span><span class="sxs-lookup"><span data-stu-id="8e0b6-273">If overriding metadata for a read-write dependency property, use <xref:System.Windows.DependencyProperty.OverrideMetadata%28System.Type%2CSystem.Windows.PropertyMetadata%29>.</span></span>  
  
 <span data-ttu-id="8e0b6-274">应重写依赖属性元数据，然后再属性系统将使用依赖项属性。</span><span class="sxs-lookup"><span data-stu-id="8e0b6-274">Dependency property metadata should be overridden before the property system uses the dependency property.</span></span> <span data-ttu-id="8e0b6-275">这相当于注册依赖属性的类创建特定对象的时间。</span><span class="sxs-lookup"><span data-stu-id="8e0b6-275">This equates to the time that specific objects are created for the class that registers the dependency property.</span></span> <span data-ttu-id="8e0b6-276">调用<xref:System.Windows.DependencyProperty.OverrideMetadata%2A>仅在为自己提供的类型的静态构造函数中执行`forType`参数，此方法，或通过相似的实例化。</span><span class="sxs-lookup"><span data-stu-id="8e0b6-276">Calls to <xref:System.Windows.DependencyProperty.OverrideMetadata%2A> should only be performed within the static constructors of the type that provides itself as the `forType` parameter of this method, or through similar instantiation.</span></span> <span data-ttu-id="8e0b6-277">尝试更改元数据的所有者类型的实例存在之后不会引发异常，但将导致属性系统中的不一致的行为。</span><span class="sxs-lookup"><span data-stu-id="8e0b6-277">Attempting to change metadata after instances of the owner type exist will not raise exceptions, but will result in inconsistent behaviors in the property system.</span></span>  
  
 <span data-ttu-id="8e0b6-278">对于特定的派生的类重写元数据建立使用此方法后，重写此相同的派生类上的元数据的后续尝试将引发异常。</span><span class="sxs-lookup"><span data-stu-id="8e0b6-278">After metadata for a particular derived class override is established with this method, subsequent attempts to override metadata on this same derived class will raise an exception.</span></span>  
  
 <span data-ttu-id="8e0b6-279">提供的元数据合并的依赖项属性的属性元数据存在于基所有者上。</span><span class="sxs-lookup"><span data-stu-id="8e0b6-279">The supplied metadata is merged with the property metadata for the dependency property as it exists on the base owner.</span></span> <span data-ttu-id="8e0b6-280">原始的基本元数据中指定的任何特征将保持不变;仅已专门在新的元数据中更改这些特性将重写的基本元数据的特征。</span><span class="sxs-lookup"><span data-stu-id="8e0b6-280">Any characteristics that were specified in the original base metadata will persist; only those characteristics that were specifically changed in the new metadata will override the characteristics of the base metadata.</span></span> <span data-ttu-id="8e0b6-281">如一些特征<xref:System.Windows.PropertyMetadata.DefaultValue%2A>如果在新的元数据中指定替换。</span><span class="sxs-lookup"><span data-stu-id="8e0b6-281">Some characteristics such as <xref:System.Windows.PropertyMetadata.DefaultValue%2A> are replaced if specified in the new metadata.</span></span> <span data-ttu-id="8e0b6-282">其他人，例如<xref:System.Windows.PropertyChangedCallback>，组合。</span><span class="sxs-lookup"><span data-stu-id="8e0b6-282">Others, such as <xref:System.Windows.PropertyChangedCallback>, are combined.</span></span> <span data-ttu-id="8e0b6-283">合并行为取决于所使用的重写的属性元数据类型。</span><span class="sxs-lookup"><span data-stu-id="8e0b6-283">The merge behavior depends on the property metadata type being used for the override.</span></span> <span data-ttu-id="8e0b6-284">有关详细信息，请参阅[依赖属性元数据](~/docs/framework/wpf/advanced/dependency-property-metadata.md)并[框架属性元数据](~/docs/framework/wpf/advanced/framework-property-metadata.md)。</span><span class="sxs-lookup"><span data-stu-id="8e0b6-284">For details, see [Dependency Property Metadata](~/docs/framework/wpf/advanced/dependency-property-metadata.md) and [Framework Property Metadata](~/docs/framework/wpf/advanced/framework-property-metadata.md).</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OwnerType">
      <MemberSignature Language="C#" Value="public Type OwnerType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type OwnerType" />
      <MemberSignature Language="DocId" Value="P:System.Windows.DependencyProperty.OwnerType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property OwnerType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Type ^ OwnerType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.OwnerType : Type" Usage="System.Windows.DependencyProperty.OwnerType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="8e0b6-285">获取使用属性系统注册依赖属性或者将自己作为属性所有者添加的对象的类型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e0b6-285">Gets the type of the object that registered the dependency property with the property system, or added itself as owner of the property.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="8e0b6-286">注册属性或者将自己作为属性所有者添加的对象的类型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e0b6-286">The type of the object that registered the property or added itself as owner of the property.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8e0b6-287">在注册过程中未提供此值。</span><span class="sxs-lookup"><span data-stu-id="8e0b6-287">This value was provided during property registration.</span></span> <span data-ttu-id="8e0b6-288">所有者将任一原始注册类型的情况下<xref:System.Windows.DependencyProperty>从生成标识符<xref:System.Windows.DependencyProperty.Register%2A>调用或将自己作为所有者的情况下添加的类型<xref:System.Windows.DependencyProperty>标识符从生成<xref:System.Windows.DependencyProperty.AddOwner%2A>调用。</span><span class="sxs-lookup"><span data-stu-id="8e0b6-288">The owner will be either the original registering type in the case of a <xref:System.Windows.DependencyProperty> identifier generated from a <xref:System.Windows.DependencyProperty.Register%2A> call, or the type that added itself as owner in the case of a <xref:System.Windows.DependencyProperty> identifier generated from an <xref:System.Windows.DependencyProperty.AddOwner%2A> call.</span></span>  
  
 <span data-ttu-id="8e0b6-289"><xref:System.Windows.DependencyProperty.OwnerType%2A>针对任何给定<xref:System.Windows.DependencyProperty>是不可变的并且不能`null`中的有效<xref:System.Windows.DependencyProperty>。</span><span class="sxs-lookup"><span data-stu-id="8e0b6-289">The <xref:System.Windows.DependencyProperty.OwnerType%2A> on any given <xref:System.Windows.DependencyProperty> is immutable, and cannot be `null` in a valid <xref:System.Windows.DependencyProperty>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="8e0b6-290">下面的示例获取基于依赖项属性标识符的所有者类型`dp`，然后获取元数据所有者类型上的该相同的标识符。</span><span class="sxs-lookup"><span data-stu-id="8e0b6-290">The following example gets the owner type based on a dependency property identifier `dp`, and then gets metadata on the owner type for that same identifier.</span></span> <span data-ttu-id="8e0b6-291">此操作是实际等效于获取<xref:System.Windows.DependencyProperty.DefaultMetadata%2A>上`dp`。</span><span class="sxs-lookup"><span data-stu-id="8e0b6-291">This operation is actually equivalent to getting <xref:System.Windows.DependencyProperty.DefaultMetadata%2A> on `dp`.</span></span>  
  
 [!code-csharp[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpgetmetadatasingle)]
 [!code-vb[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpgetmetadatasingle)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PropertyType">
      <MemberSignature Language="C#" Value="public Type PropertyType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type PropertyType" />
      <MemberSignature Language="DocId" Value="P:System.Windows.DependencyProperty.PropertyType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PropertyType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Type ^ PropertyType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.PropertyType : Type" Usage="System.Windows.DependencyProperty.PropertyType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="8e0b6-292">获取依赖项对象用于其值的类型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e0b6-292">Gets the type that the dependency property uses for its value.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="8e0b6-293">属性值的 <see cref="T:System.Type" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e0b6-293">The <see cref="T:System.Type" /> of the property value.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8e0b6-294">此属性报告的属性的值所声明的原始的注册属性中，通过类型`propertyType`参数。</span><span class="sxs-lookup"><span data-stu-id="8e0b6-294">This property reports the type of the property's value as declared by the original property registration, through the `propertyType` parameter.</span></span> <span data-ttu-id="8e0b6-295">类似于<xref:System.Windows.DependencyProperty.Name%2A>，注册后依赖项属性的属性类型是不可变。</span><span class="sxs-lookup"><span data-stu-id="8e0b6-295">Similar to the <xref:System.Windows.DependencyProperty.Name%2A>, the property type of a dependency property is immutable after registration.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="8e0b6-296">下面的示例查询依赖项属性标识符的各种特征包括<xref:System.Windows.DependencyProperty.PropertyType%2A>。</span><span class="sxs-lookup"><span data-stu-id="8e0b6-296">The following example queries various characteristics of a dependency property identifier, including the <xref:System.Windows.DependencyProperty.PropertyType%2A>.</span></span> <span data-ttu-id="8e0b6-297">类型名称字符串<xref:System.Windows.DependencyProperty.PropertyType%2A>获取从返回<xref:System.Type>。</span><span class="sxs-lookup"><span data-stu-id="8e0b6-297">The type name string of the <xref:System.Windows.DependencyProperty.PropertyType%2A> is obtained from the returned <xref:System.Type>.</span></span>  
  
 [!code-csharp[PropertySystemEsoterics#DPProps](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpprops)]
 [!code-vb[PropertySystemEsoterics#DPProps](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpprops)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadOnly">
      <MemberSignature Language="C#" Value="public bool ReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Windows.DependencyProperty.ReadOnly" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ReadOnly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ReadOnly { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.ReadOnly : bool" Usage="System.Windows.DependencyProperty.ReadOnly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="8e0b6-298">获取一个值，该值指示由此 <see cref="T:System.Windows.DependencyProperty" /> 实例标识的依赖项对象是否为只读依赖项对象。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e0b6-298">Gets a value that indicates whether the dependency property identified by this <see cref="T:System.Windows.DependencyProperty" /> instance is a read-only dependency property.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="8e0b6-299">如果该依赖项对象为只读属性，则为 <see langword="true" />；否则为 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e0b6-299">
              <see langword="true" /> if the dependency property is read-only; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8e0b6-300">属性系统中注册只读依赖属性，应调用<xref:System.Windows.DependencyProperty.RegisterReadOnly%2A>方法而不是<xref:System.Windows.DependencyProperty.Register%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="8e0b6-300">Read-only dependency properties are registered within the property system by calling the <xref:System.Windows.DependencyProperty.RegisterReadOnly%2A> method as opposed to the <xref:System.Windows.DependencyProperty.Register%2A> method.</span></span> <span data-ttu-id="8e0b6-301">此外可以将附加的属性注册为只读的;请参阅<xref:System.Windows.DependencyProperty.RegisterAttachedReadOnly%2A>。</span><span class="sxs-lookup"><span data-stu-id="8e0b6-301">Attached properties can also be registered as read-only; see <xref:System.Windows.DependencyProperty.RegisterAttachedReadOnly%2A>.</span></span>  
  
 <span data-ttu-id="8e0b6-302">只读依赖属性都需要<xref:System.Windows.DependencyPropertyKey>标识符而非<xref:System.Windows.DependencyProperty>标识符执行元数据操作，如重写元数据或将值设置。</span><span class="sxs-lookup"><span data-stu-id="8e0b6-302">Read-only dependency properties require a <xref:System.Windows.DependencyPropertyKey> identifier rather than a <xref:System.Windows.DependencyProperty> identifier to perform metadata operations such as overriding the metadata or setting the value.</span></span> <span data-ttu-id="8e0b6-303">如果获取一系列<xref:System.Windows.DependencyProperty>通过调用标识符<xref:System.Windows.DependencyObject.GetLocalValueEnumerator%2A>或另一个[!INCLUDE[TLA2#tla_api](~/includes/tla2sharptla-api-md.md)]公开标识符，检查<xref:System.Windows.DependencyProperty.ReadOnly%2A>前尝试调用值<xref:System.Windows.DependencyObject.SetValue%2A>或<xref:System.Windows.DependencyProperty.OverrideMetadata%2A>使用的依赖项属性标识符作为输入参数，以验证标识符表示的依赖关系属性不是只读的。</span><span class="sxs-lookup"><span data-stu-id="8e0b6-303">If you obtained a collection of <xref:System.Windows.DependencyProperty> identifiers through a call to <xref:System.Windows.DependencyObject.GetLocalValueEnumerator%2A> or another [!INCLUDE[TLA2#tla_api](~/includes/tla2sharptla-api-md.md)] that exposes identifiers, check the <xref:System.Windows.DependencyProperty.ReadOnly%2A> value before attempting to call <xref:System.Windows.DependencyObject.SetValue%2A> or <xref:System.Windows.DependencyProperty.OverrideMetadata%2A> using that dependency property identifier as an input parameter, to verify that the dependency property that the identifier represents is not read-only.</span></span> <span data-ttu-id="8e0b6-304">如果的值<xref:System.Windows.DependencyProperty.ReadOnly%2A>是`true`依赖项的属性是无法通过编程方式获取对引用<xref:System.Windows.DependencyPropertyKey>从元数据或从该依赖项属性标识符<xref:System.Windows.DependencyProperty>标识符; 标识符若要调用必须可用作静态字段<xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29>对只读依赖属性。</span><span class="sxs-lookup"><span data-stu-id="8e0b6-304">If the value of <xref:System.Windows.DependencyProperty.ReadOnly%2A> is `true` on a dependency property, there is no programmatic way to obtain a reference to the <xref:System.Windows.DependencyPropertyKey> identifier of that dependency property, from the metadata or from the <xref:System.Windows.DependencyProperty> identifier; the identifier must be available as a static field in order to call <xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29> against a read-only dependency property.</span></span>  
  
 <span data-ttu-id="8e0b6-305">当您创建自定义依赖属性，并将其注册为只读的时则应定义仅一个 get 访问器为[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]包装器属性。</span><span class="sxs-lookup"><span data-stu-id="8e0b6-305">When you create a custom dependency property, and register it as read-only, you should define only a get accessor for the [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] wrapper property.</span></span> <span data-ttu-id="8e0b6-306">否则，您的类将具有与对支持依赖项属性的访问权限属性包装器的令人困惑对象模型。</span><span class="sxs-lookup"><span data-stu-id="8e0b6-306">Otherwise, your class will have a confusing object model for the property wrapper as compared to the access to the backing dependency property.</span></span> <span data-ttu-id="8e0b6-307">有关详细信息，请参阅[自定义依赖属性](~/docs/framework/wpf/advanced/custom-dependency-properties.md)或[只读依赖属性](~/docs/framework/wpf/advanced/read-only-dependency-properties.md)。</span><span class="sxs-lookup"><span data-stu-id="8e0b6-307">For details, see [Custom Dependency Properties](~/docs/framework/wpf/advanced/custom-dependency-properties.md) or [Read-Only Dependency Properties](~/docs/framework/wpf/advanced/read-only-dependency-properties.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="8e0b6-308">以下示例从各种依赖项属性字段中获取的默认元数据和依赖项属性标识符属性，并使用信息来填充表，以实现"元数据浏览器"。</span><span class="sxs-lookup"><span data-stu-id="8e0b6-308">The following example obtains the default metadata and the dependency property identifier properties from various dependency property fields, and uses the information to populate a table to implement a "metadata browser".</span></span>  
  
 [!code-csharp[PropertySystemEsoterics#DPProps](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpprops)]
 [!code-vb[PropertySystemEsoterics#DPProps](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpprops)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Register">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="8e0b6-309">注册依赖属性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e0b6-309">Registers a dependency property.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Register">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyProperty Register (string name, Type propertyType, Type ownerType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyProperty Register(string name, class System.Type propertyType, class System.Type ownerType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Register (name As String, propertyType As Type, ownerType As Type) As DependencyProperty" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyProperty ^ Register(System::String ^ name, Type ^ propertyType, Type ^ ownerType);" />
      <MemberSignature Language="F#" Value="static member Register : string * Type * Type -&gt; System.Windows.DependencyProperty" Usage="System.Windows.DependencyProperty.Register (name, propertyType, ownerType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="ownerType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="8e0b6-310">要注册的依赖属性的名称。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e0b6-310">The name of the dependency property to register.</span>
          </span>
          <span data-ttu-id="8e0b6-311">名称必须在所有者类型的注册命名空间中是唯一的。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e0b6-311">The name must be unique within the registration namespace of the owner type.</span>
          </span>
        </param>
        <param name="propertyType">
          <span data-ttu-id="8e0b6-312">属性的类型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e0b6-312">The type of the property.</span>
          </span>
        </param>
        <param name="ownerType">
          <span data-ttu-id="8e0b6-313">正在注册依赖属性的所有者类型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e0b6-313">The owner type that is registering the dependency property.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="8e0b6-314">使用指定的属性名称、属性类型和所有者类型注册依赖属性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e0b6-314">Registers a dependency property with the specified property name, property type, and owner type.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="8e0b6-315">一个依赖项对象标识符，应使用它在您的类中设置 <see langword="public static readonly" /> 字段的值。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e0b6-315">A dependency property identifier that should be used to set the value of a <see langword="public static readonly" /> field in your class.</span>
          </span>
          <span data-ttu-id="8e0b6-316">稍后将此标识符用来引用依赖属性，从而实现以编程方式设置其值或获取元数据等操作。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e0b6-316">That identifier is then used to reference the dependency property later, for operations such as setting its value programmatically or obtaining metadata.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8e0b6-317">依赖关系属性注册的详细信息，请参阅<xref:System.Windows.DependencyProperty>。</span><span class="sxs-lookup"><span data-stu-id="8e0b6-317">For more information on dependency property registration, see <xref:System.Windows.DependencyProperty>.</span></span>  
  
   
  
## Examples  
 [!code-csharp[WPFAquariumSln#Register3Param](~/samples/snippets/csharp/VS_Snippets_Wpf/WPFAquariumSln/CSharp/WPFAquariumObjects/Class1.cs#register3param)]
 [!code-vb[WPFAquariumSln#Register3Param](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WPFAquariumSln/visualbasic/wpfaquariumobjects/class1.vb#register3param)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type)" />
        <altmember cref="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      </Docs>
    </Member>
    <Member MemberName="Register">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyProperty Register (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata typeMetadata);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyProperty Register(string name, class System.Type propertyType, class System.Type ownerType, class System.Windows.PropertyMetadata typeMetadata) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Register (name As String, propertyType As Type, ownerType As Type, typeMetadata As PropertyMetadata) As DependencyProperty" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyProperty ^ Register(System::String ^ name, Type ^ propertyType, Type ^ ownerType, System::Windows::PropertyMetadata ^ typeMetadata);" />
      <MemberSignature Language="F#" Value="static member Register : string * Type * Type * System.Windows.PropertyMetadata -&gt; System.Windows.DependencyProperty" Usage="System.Windows.DependencyProperty.Register (name, propertyType, ownerType, typeMetadata)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="ownerType" Type="System.Type" />
        <Parameter Name="typeMetadata" Type="System.Windows.PropertyMetadata" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="8e0b6-318">要注册的依赖属性的名称。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e0b6-318">The name of the dependency property to register.</span>
          </span>
        </param>
        <param name="propertyType">
          <span data-ttu-id="8e0b6-319">属性的类型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e0b6-319">The type of the property.</span>
          </span>
        </param>
        <param name="ownerType">
          <span data-ttu-id="8e0b6-320">正在注册依赖属性的所有者类型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e0b6-320">The owner type that is registering the dependency property.</span>
          </span>
        </param>
        <param name="typeMetadata">
          <span data-ttu-id="8e0b6-321">依赖属性的属性元数据。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e0b6-321">Property metadata for the dependency property.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="8e0b6-322">使用指定的属性名称、属性类型、所有者类型和属性元数据注册依赖属性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e0b6-322">Registers a dependency property with the specified property name, property type, owner type, and property metadata.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="8e0b6-323">一个依赖项对象标识符，应使用它在您的类中设置 <see langword="public static readonly" /> 字段的值。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e0b6-323">A dependency property identifier that should be used to set the value of a <see langword="public static readonly" /> field in your class.</span>
          </span>
          <span data-ttu-id="8e0b6-324">稍后将此标识符用来引用依赖属性，从而实现以编程方式设置其值或获取元数据等操作。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e0b6-324">That identifier is then used to reference the dependency property later, for operations such as setting its value programmatically or obtaining metadata.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8e0b6-325">依赖关系属性注册的详细信息，请参阅<xref:System.Windows.DependencyProperty>。</span><span class="sxs-lookup"><span data-stu-id="8e0b6-325">For more information on dependency property registration, see <xref:System.Windows.DependencyProperty>.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type)" />
        <altmember cref="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      </Docs>
    </Member>
    <Member MemberName="Register">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyProperty Register (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata typeMetadata, System.Windows.ValidateValueCallback validateValueCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyProperty Register(string name, class System.Type propertyType, class System.Type ownerType, class System.Windows.PropertyMetadata typeMetadata, class System.Windows.ValidateValueCallback validateValueCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyProperty ^ Register(System::String ^ name, Type ^ propertyType, Type ^ ownerType, System::Windows::PropertyMetadata ^ typeMetadata, System::Windows::ValidateValueCallback ^ validateValueCallback);" />
      <MemberSignature Language="F#" Value="static member Register : string * Type * Type * System.Windows.PropertyMetadata * System.Windows.ValidateValueCallback -&gt; System.Windows.DependencyProperty" Usage="System.Windows.DependencyProperty.Register (name, propertyType, ownerType, typeMetadata, validateValueCallback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="ownerType" Type="System.Type" />
        <Parameter Name="typeMetadata" Type="System.Windows.PropertyMetadata" />
        <Parameter Name="validateValueCallback" Type="System.Windows.ValidateValueCallback" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="8e0b6-326">要注册的依赖属性的名称。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e0b6-326">The name of the dependency property to register.</span>
          </span>
        </param>
        <param name="propertyType">
          <span data-ttu-id="8e0b6-327">属性的类型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e0b6-327">The type of the property.</span>
          </span>
        </param>
        <param name="ownerType">
          <span data-ttu-id="8e0b6-328">正在注册依赖属性的所有者类型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e0b6-328">The owner type that is registering the dependency property.</span>
          </span>
        </param>
        <param name="typeMetadata">
          <span data-ttu-id="8e0b6-329">依赖属性的属性元数据。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e0b6-329">Property metadata for the dependency property.</span>
          </span>
        </param>
        <param name="validateValueCallback">
          <span data-ttu-id="8e0b6-330">对回调的引用，除了典型的类型验证之外，该引用还应执行依赖属性值的任何自定义验证。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e0b6-330">A reference to a callback that should perform any custom validation of the dependency property value beyond typical type validation.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="8e0b6-331">使用指定的属性名称、属性类型、所有者类型、属性元数据和属性的值验证回叫来注册依赖属性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e0b6-331">Registers a dependency property with the specified property name, property type, owner type, property metadata, and a value validation callback for the property.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="8e0b6-332">一个依赖项对象标识符，应使用它在您的类中设置 <see langword="public static readonly" /> 字段的值。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e0b6-332">A dependency property identifier that should be used to set the value of a <see langword="public static readonly" /> field in your class.</span>
          </span>
          <span data-ttu-id="8e0b6-333">稍后将此标识符用来引用依赖属性，从而实现以编程方式设置其值或获取元数据等操作。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e0b6-333">That identifier is then used to reference the dependency property later, for operations such as setting its value programmatically or obtaining metadata.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8e0b6-334">依赖关系属性注册的详细信息，请参阅<xref:System.Windows.DependencyProperty>。</span><span class="sxs-lookup"><span data-stu-id="8e0b6-334">For more information on dependency property registration, see <xref:System.Windows.DependencyProperty>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="8e0b6-335">下面的示例注册依赖属性，包括验证回叫 (回调定义不显示; 回调定义的详细信息，请参阅<xref:System.Windows.ValidateValueCallback>)。</span><span class="sxs-lookup"><span data-stu-id="8e0b6-335">The following example registers a dependency property, including a validation callback (the callback definition is not shown; for details on the callback definition, see <xref:System.Windows.ValidateValueCallback>).</span></span>  
  
 [!code-csharp[DPCallbackOverride#CurrentDefinitionWithWrapper](~/samples/snippets/csharp/VS_Snippets_Wpf/DPCallbackOverride/CSharp/SDKSampleLibrary/class1.cs#currentdefinitionwithwrapper)]
 [!code-vb[DPCallbackOverride#CurrentDefinitionWithWrapper](~/samples/snippets/visualbasic/VS_Snippets_Wpf/DPCallbackOverride/visualbasic/sdksamplelibrary/class1.vb#currentdefinitionwithwrapper)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type)" />
        <altmember cref="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="RegisterAttached">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="8e0b6-336">在属性系统上注册附加属性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e0b6-336">Registers an attached property with the property system.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RegisterAttached">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyProperty RegisterAttached (string name, Type propertyType, Type ownerType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyProperty RegisterAttached(string name, class System.Type propertyType, class System.Type ownerType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RegisterAttached (name As String, propertyType As Type, ownerType As Type) As DependencyProperty" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyProperty ^ RegisterAttached(System::String ^ name, Type ^ propertyType, Type ^ ownerType);" />
      <MemberSignature Language="F#" Value="static member RegisterAttached : string * Type * Type -&gt; System.Windows.DependencyProperty" Usage="System.Windows.DependencyProperty.RegisterAttached (name, propertyType, ownerType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="ownerType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="8e0b6-337">要注册的依赖属性的名称。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e0b6-337">The name of the dependency property to register.</span>
          </span>
        </param>
        <param name="propertyType">
          <span data-ttu-id="8e0b6-338">属性的类型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e0b6-338">The type of the property.</span>
          </span>
        </param>
        <param name="ownerType">
          <span data-ttu-id="8e0b6-339">正在注册依赖属性的所有者类型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e0b6-339">The owner type that is registering the dependency property.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="8e0b6-340">使用指定的属性名称、属性类型和所有者类型注册附加属性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e0b6-340">Registers an attached property with the specified property name, property type, and owner type.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="8e0b6-341">一个依赖项对象标识符，应使用它在您的类中设置 <see langword="public static readonly" /> 字段的值。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e0b6-341">A dependency property identifier that should be used to set the value of a <see langword="public static readonly" /> field in your class.</span>
          </span>
          <span data-ttu-id="8e0b6-342">稍后将此标识符用来引用依赖属性，从而实现以编程方式设置其值或获取元数据等操作。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e0b6-342">That identifier is then used to reference the dependency property later, for operations such as setting its value programmatically or obtaining metadata.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8e0b6-343">附加的属性是通过定义的属性概念[!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)]。</span><span class="sxs-lookup"><span data-stu-id="8e0b6-343">An attached property is a property concept defined by [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)].</span></span> [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] <span data-ttu-id="8e0b6-344">将附加属性实现为依赖属性。</span><span class="sxs-lookup"><span data-stu-id="8e0b6-344"> implements attached properties as dependency properties.</span></span> <span data-ttu-id="8e0b6-345">因为[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]附加的属性是依赖属性，它们可以包含应用，可用于操作，如报表布局特征的常规属性系统的元数据。</span><span class="sxs-lookup"><span data-stu-id="8e0b6-345">Because the [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] attached properties are dependency properties, they can have metadata applied that can be used by the general property system for operations such as reporting layout characteristics.</span></span> <span data-ttu-id="8e0b6-346">有关详细信息，请参阅[附加属性概述](~/docs/framework/wpf/advanced/attached-properties-overview.md)。</span><span class="sxs-lookup"><span data-stu-id="8e0b6-346">For more information, see [Attached Properties Overview](~/docs/framework/wpf/advanced/attached-properties-overview.md).</span></span>  
  
 <span data-ttu-id="8e0b6-347">依赖关系属性注册的详细信息，请参阅<xref:System.Windows.DependencyProperty>。</span><span class="sxs-lookup"><span data-stu-id="8e0b6-347">For more information on dependency property registration, see <xref:System.Windows.DependencyProperty>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="8e0b6-348">下面的示例注册附加的属性上使用此抽象类<xref:System.Windows.DependencyProperty.RegisterAttached%2A>签名。</span><span class="sxs-lookup"><span data-stu-id="8e0b6-348">The following example registers an attached property on an abstract class using this <xref:System.Windows.DependencyProperty.RegisterAttached%2A> signature.</span></span>  
  
 [!code-csharp[WPFAquariumSln#RegisterAttachedBubbler2](~/samples/snippets/csharp/VS_Snippets_Wpf/WPFAquariumSln/CSharp/WPFAquariumObjects/Class1.cs#registerattachedbubbler2)]
 [!code-vb[WPFAquariumSln#RegisterAttachedBubbler2](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WPFAquariumSln/visualbasic/wpfaquariumobjects/class1.vb#registerattachedbubbler2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
        <altmember cref="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      </Docs>
    </Member>
    <Member MemberName="RegisterAttached">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyProperty RegisterAttached (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata defaultMetadata);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyProperty RegisterAttached(string name, class System.Type propertyType, class System.Type ownerType, class System.Windows.PropertyMetadata defaultMetadata) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RegisterAttached (name As String, propertyType As Type, ownerType As Type, defaultMetadata As PropertyMetadata) As DependencyProperty" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyProperty ^ RegisterAttached(System::String ^ name, Type ^ propertyType, Type ^ ownerType, System::Windows::PropertyMetadata ^ defaultMetadata);" />
      <MemberSignature Language="F#" Value="static member RegisterAttached : string * Type * Type * System.Windows.PropertyMetadata -&gt; System.Windows.DependencyProperty" Usage="System.Windows.DependencyProperty.RegisterAttached (name, propertyType, ownerType, defaultMetadata)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="ownerType" Type="System.Type" />
        <Parameter Name="defaultMetadata" Type="System.Windows.PropertyMetadata" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="8e0b6-349">要注册的依赖属性的名称。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e0b6-349">The name of the dependency property to register.</span>
          </span>
        </param>
        <param name="propertyType">
          <span data-ttu-id="8e0b6-350">属性的类型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e0b6-350">The type of the property.</span>
          </span>
        </param>
        <param name="ownerType">
          <span data-ttu-id="8e0b6-351">正在注册依赖属性的所有者类型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e0b6-351">The owner type that is registering the dependency property.</span>
          </span>
        </param>
        <param name="defaultMetadata">
          <span data-ttu-id="8e0b6-352">依赖属性的属性元数据。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e0b6-352">Property metadata for the dependency property.</span>
          </span>
          <span data-ttu-id="8e0b6-353">这可以包括默认值和其他特征。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e0b6-353">This can include the default value as well as other characteristics.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="8e0b6-354">使用指定的属性名、属性类型、所有者类型和属性元数据注册附加的属性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e0b6-354">Registers an attached property with the specified property name, property type, owner type, and property metadata.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="8e0b6-355">一个依赖项对象标识符，应使用它在您的类中设置 <see langword="public static readonly" /> 字段的值。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e0b6-355">A dependency property identifier that should be used to set the value of a <see langword="public static readonly" /> field in your class.</span>
          </span>
          <span data-ttu-id="8e0b6-356">稍后将此标识符用来引用依赖属性，从而实现以编程方式设置其值或获取元数据等操作。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e0b6-356">That identifier is then used to reference the dependency property later, for operations such as setting its value programmatically or obtaining metadata.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8e0b6-357">附加的属性是通过定义的属性概念[!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)]。</span><span class="sxs-lookup"><span data-stu-id="8e0b6-357">An attached property is a property concept defined by [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)].</span></span> [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] <span data-ttu-id="8e0b6-358">将附加属性实现为依赖属性。</span><span class="sxs-lookup"><span data-stu-id="8e0b6-358"> implements attached properties as dependency properties.</span></span> <span data-ttu-id="8e0b6-359">因为[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]附加的属性是依赖属性，它们可以包含应用，可用于操作，如报表布局特征的常规属性系统的元数据。</span><span class="sxs-lookup"><span data-stu-id="8e0b6-359">Because the [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] attached properties are dependency properties, they can have metadata applied that can be used by the general property system for operations such as reporting layout characteristics.</span></span> <span data-ttu-id="8e0b6-360">有关详细信息，请参阅[附加属性概述](~/docs/framework/wpf/advanced/attached-properties-overview.md)。</span><span class="sxs-lookup"><span data-stu-id="8e0b6-360">For more information, see [Attached Properties Overview](~/docs/framework/wpf/advanced/attached-properties-overview.md).</span></span>  
  
 <span data-ttu-id="8e0b6-361">依赖关系属性注册的详细信息，请参阅<xref:System.Windows.DependencyProperty>。</span><span class="sxs-lookup"><span data-stu-id="8e0b6-361">For more information on dependency property registration, see <xref:System.Windows.DependencyProperty>.</span></span>  
  
## <a name="use-registerattached-for-value-inheriting-dependency-properties"></a><span data-ttu-id="8e0b6-362">使用 RegisterAttached 值继承依赖属性</span><span class="sxs-lookup"><span data-stu-id="8e0b6-362">Use RegisterAttached for Value-inheriting Dependency Properties</span></span>  
 <span data-ttu-id="8e0b6-363">用于注册依赖属性使用一个特殊的情况<xref:System.Windows.DependencyProperty.RegisterAttached%2A>而不是<xref:System.Windows.DependencyProperty.Register%2A>是支持的属性值继承。</span><span class="sxs-lookup"><span data-stu-id="8e0b6-363">One particular scenario for registering a dependency property with <xref:System.Windows.DependencyProperty.RegisterAttached%2A> instead of <xref:System.Windows.DependencyProperty.Register%2A> is to support property value inheritance.</span></span> <span data-ttu-id="8e0b6-364">应注册与值继承依赖属性<xref:System.Windows.DependencyProperty.RegisterAttached%2A>即使该类定义公开该依赖属性的属性包装器访问器，即使您不打算公开 Get \* 和集 \* 静态方法，以提供 true 附加属性支持访问器。</span><span class="sxs-lookup"><span data-stu-id="8e0b6-364">You should register value-inheriting dependency properties with <xref:System.Windows.DependencyProperty.RegisterAttached%2A> even if the class defines property wrapper accessors that expose the dependency property, and even if you do not intend to expose Get\* and Set\* static methods to provide true attached property support accessors.</span></span>   <span data-ttu-id="8e0b6-365">虽然属性值继承看起来适用于非附加依赖项属性，但通过在运行时树中特定元素边界的非附加属性的继承行为未定义。</span><span class="sxs-lookup"><span data-stu-id="8e0b6-365">Although property value inheritance might appear to work for nonattached dependency properties, the inheritance behavior for a nonattached property through certain element boundaries in the runtime tree is undefined.</span></span> <span data-ttu-id="8e0b6-366">将属性注册为附加有效地对属性系统中，附加的属性的全局属性，并确保属性值继承，可以在元素树中的所有边界。</span><span class="sxs-lookup"><span data-stu-id="8e0b6-366">Registering the property as attached effectively makes the attached property a global property to the property system, and assures that property value inheritance works across all boundaries in an element tree.</span></span> <span data-ttu-id="8e0b6-367">始终使用<xref:System.Windows.DependencyProperty.RegisterAttached%2A>来注册您在其中指定的属性<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>元数据中。</span><span class="sxs-lookup"><span data-stu-id="8e0b6-367">Always use <xref:System.Windows.DependencyProperty.RegisterAttached%2A> to register properties where you specify <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> in the metadata.</span></span> <span data-ttu-id="8e0b6-368">有关详细信息，请参阅[属性值继承](~/docs/framework/wpf/advanced/property-value-inheritance.md)。</span><span class="sxs-lookup"><span data-stu-id="8e0b6-368">For more information, see [Property Value Inheritance](~/docs/framework/wpf/advanced/property-value-inheritance.md).</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
        <altmember cref="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      </Docs>
    </Member>
    <Member MemberName="RegisterAttached">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyProperty RegisterAttached (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata defaultMetadata, System.Windows.ValidateValueCallback validateValueCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyProperty RegisterAttached(string name, class System.Type propertyType, class System.Type ownerType, class System.Windows.PropertyMetadata defaultMetadata, class System.Windows.ValidateValueCallback validateValueCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyProperty ^ RegisterAttached(System::String ^ name, Type ^ propertyType, Type ^ ownerType, System::Windows::PropertyMetadata ^ defaultMetadata, System::Windows::ValidateValueCallback ^ validateValueCallback);" />
      <MemberSignature Language="F#" Value="static member RegisterAttached : string * Type * Type * System.Windows.PropertyMetadata * System.Windows.ValidateValueCallback -&gt; System.Windows.DependencyProperty" Usage="System.Windows.DependencyProperty.RegisterAttached (name, propertyType, ownerType, defaultMetadata, validateValueCallback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="ownerType" Type="System.Type" />
        <Parameter Name="defaultMetadata" Type="System.Windows.PropertyMetadata" />
        <Parameter Name="validateValueCallback" Type="System.Windows.ValidateValueCallback" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="8e0b6-369">要注册的依赖属性的名称。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e0b6-369">The name of the dependency property to register.</span>
          </span>
        </param>
        <param name="propertyType">
          <span data-ttu-id="8e0b6-370">属性的类型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e0b6-370">The type of the property.</span>
          </span>
        </param>
        <param name="ownerType">
          <span data-ttu-id="8e0b6-371">正在注册依赖属性的所有者类型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e0b6-371">The owner type that is registering the dependency property.</span>
          </span>
        </param>
        <param name="defaultMetadata">
          <span data-ttu-id="8e0b6-372">依赖属性的属性元数据。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e0b6-372">Property metadata for the dependency property.</span>
          </span>
          <span data-ttu-id="8e0b6-373">这可以包括默认值和其他特征。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e0b6-373">This can include the default value as well as other characteristics.</span>
          </span>
        </param>
        <param name="validateValueCallback">
          <span data-ttu-id="8e0b6-374">对回调的引用，除了典型的类型验证之外，该引用还应执行依赖属性值的任何自定义验证。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e0b6-374">A reference to a callback that should perform any custom validation of the dependency property value beyond typical type validation.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="8e0b6-375">使用指定的属性类型、所有者类型、属性元数据和属性的值验证回调来注册附加属性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e0b6-375">Registers an attached property with the specified property type, owner type, property metadata, and value validation callback for the property.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="8e0b6-376">一个依赖项对象标识符，应使用它在您的类中设置 <see langword="public static readonly" /> 字段的值。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e0b6-376">A dependency property identifier that should be used to set the value of a <see langword="public static readonly" /> field in your class.</span>
          </span>
          <span data-ttu-id="8e0b6-377">稍后将此标识符用来引用依赖属性，从而实现以编程方式设置其值或获取元数据等操作。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e0b6-377">That identifier is then used to reference the dependency property later, for operations such as setting its value programmatically or obtaining metadata.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8e0b6-378">附加的属性是通过定义的属性概念[!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)]。</span><span class="sxs-lookup"><span data-stu-id="8e0b6-378">An attached property is a property concept defined by [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)].</span></span> [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] <span data-ttu-id="8e0b6-379">将附加属性实现为依赖属性。</span><span class="sxs-lookup"><span data-stu-id="8e0b6-379"> implements attached properties as dependency properties.</span></span> <span data-ttu-id="8e0b6-380">因为[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]附加的属性是依赖属性，它们可以包含应用，可用于操作，如报表布局特征的常规属性系统的元数据。</span><span class="sxs-lookup"><span data-stu-id="8e0b6-380">Because the [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] attached properties are dependency properties, they can have metadata applied that can be used by the general property system for operations such as reporting layout characteristics.</span></span> <span data-ttu-id="8e0b6-381">有关详细信息，请参阅[附加属性概述](~/docs/framework/wpf/advanced/attached-properties-overview.md)。</span><span class="sxs-lookup"><span data-stu-id="8e0b6-381">For more information, see [Attached Properties Overview](~/docs/framework/wpf/advanced/attached-properties-overview.md).</span></span>  
  
 <span data-ttu-id="8e0b6-382">依赖关系属性注册的详细信息，请参阅<xref:System.Windows.DependencyProperty>。</span><span class="sxs-lookup"><span data-stu-id="8e0b6-382">For more information on dependency property registration, see <xref:System.Windows.DependencyProperty>.</span></span>  
  
## <a name="use-registerattached-for-value-inheriting-dependency-properties"></a><span data-ttu-id="8e0b6-383">使用 RegisterAttached 值继承依赖属性</span><span class="sxs-lookup"><span data-stu-id="8e0b6-383">Use RegisterAttached for Value-inheriting Dependency Properties</span></span>  
 <span data-ttu-id="8e0b6-384">用于注册依赖属性使用一个特殊的情况<xref:System.Windows.DependencyProperty.RegisterAttached%2A>而不是<xref:System.Windows.DependencyProperty.Register%2A>是支持的属性值继承。</span><span class="sxs-lookup"><span data-stu-id="8e0b6-384">One particular scenario for registering a dependency property with <xref:System.Windows.DependencyProperty.RegisterAttached%2A> instead of <xref:System.Windows.DependencyProperty.Register%2A> is to support property value inheritance.</span></span> <span data-ttu-id="8e0b6-385">应注册与值继承依赖属性<xref:System.Windows.DependencyProperty.RegisterAttached%2A>即使该类定义公开该依赖属性的属性包装器访问器，即使您不打算公开 Get \* 和集 \* 静态方法，以提供 true 附加属性支持访问器。</span><span class="sxs-lookup"><span data-stu-id="8e0b6-385">You should register value-inheriting dependency properties with <xref:System.Windows.DependencyProperty.RegisterAttached%2A> even if the class defines property wrapper accessors that expose the dependency property, and even if you do not intend to expose Get\* and Set\* static methods to provide true attached property support accessors.</span></span>   <span data-ttu-id="8e0b6-386">虽然属性值继承看起来适用于非附加依赖项属性，但通过在运行时树中特定元素边界的非附加属性的继承行为未定义。</span><span class="sxs-lookup"><span data-stu-id="8e0b6-386">Although property value inheritance might appear to work for nonattached dependency properties, the inheritance behavior for a nonattached property through certain element boundaries in the runtime tree is undefined.</span></span> <span data-ttu-id="8e0b6-387">将属性注册为附加有效地对属性系统中，附加的属性的全局属性，并确保属性值继承，可以在元素树中的所有边界。</span><span class="sxs-lookup"><span data-stu-id="8e0b6-387">Registering the property as attached effectively makes the attached property a global property to the property system, and assures that property value inheritance works across all boundaries in an element tree.</span></span> <span data-ttu-id="8e0b6-388">始终使用<xref:System.Windows.DependencyProperty.RegisterAttached%2A>来注册您在其中指定的属性<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>元数据中。</span><span class="sxs-lookup"><span data-stu-id="8e0b6-388">Always use <xref:System.Windows.DependencyProperty.RegisterAttached%2A> to register properties where you specify <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> in the metadata.</span></span> <span data-ttu-id="8e0b6-389">有关详细信息，请参阅[属性值继承](~/docs/framework/wpf/advanced/property-value-inheritance.md)。</span><span class="sxs-lookup"><span data-stu-id="8e0b6-389">For more information, see [Property Value Inheritance](~/docs/framework/wpf/advanced/property-value-inheritance.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="8e0b6-390">下面的示例注册附加的属性上使用此抽象类<xref:System.Windows.DependencyProperty.RegisterAttached%2A>签名。</span><span class="sxs-lookup"><span data-stu-id="8e0b6-390">The following example registers an attached property on an abstract class using this <xref:System.Windows.DependencyProperty.RegisterAttached%2A> signature.</span></span> <span data-ttu-id="8e0b6-391">此附加的属性为枚举类型属性，并注册添加一个验证回调，以验证提供的值为枚举的值。</span><span class="sxs-lookup"><span data-stu-id="8e0b6-391">This attached property is an enumeration type property, and the registration adds a validation callback to verify that the provided value is a value of the enumeration.</span></span>  
  
 [!code-csharp[WPFAquariumSln#RegisterAttachedBubbler2](~/samples/snippets/csharp/VS_Snippets_Wpf/WPFAquariumSln/CSharp/WPFAquariumObjects/Class1.cs#registerattachedbubbler2)]
 [!code-vb[WPFAquariumSln#RegisterAttachedBubbler2](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WPFAquariumSln/visualbasic/wpfaquariumobjects/class1.vb#registerattachedbubbler2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
        <altmember cref="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="RegisterAttachedReadOnly">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="8e0b6-392">注册只读附加属性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e0b6-392">Registers a read-only attached property.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RegisterAttachedReadOnly">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyPropertyKey RegisterAttachedReadOnly (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata defaultMetadata);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyPropertyKey RegisterAttachedReadOnly(string name, class System.Type propertyType, class System.Type ownerType, class System.Windows.PropertyMetadata defaultMetadata) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RegisterAttachedReadOnly (name As String, propertyType As Type, ownerType As Type, defaultMetadata As PropertyMetadata) As DependencyPropertyKey" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyPropertyKey ^ RegisterAttachedReadOnly(System::String ^ name, Type ^ propertyType, Type ^ ownerType, System::Windows::PropertyMetadata ^ defaultMetadata);" />
      <MemberSignature Language="F#" Value="static member RegisterAttachedReadOnly : string * Type * Type * System.Windows.PropertyMetadata -&gt; System.Windows.DependencyPropertyKey" Usage="System.Windows.DependencyProperty.RegisterAttachedReadOnly (name, propertyType, ownerType, defaultMetadata)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="ownerType" Type="System.Type" />
        <Parameter Name="defaultMetadata" Type="System.Windows.PropertyMetadata" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="8e0b6-393">要注册的依赖属性的名称。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e0b6-393">The name of the dependency property to register.</span>
          </span>
        </param>
        <param name="propertyType">
          <span data-ttu-id="8e0b6-394">属性的类型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e0b6-394">The type of the property.</span>
          </span>
        </param>
        <param name="ownerType">
          <span data-ttu-id="8e0b6-395">正在注册依赖属性的所有者类型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e0b6-395">The owner type that is registering the dependency property.</span>
          </span>
        </param>
        <param name="defaultMetadata">
          <span data-ttu-id="8e0b6-396">依赖属性的属性元数据。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e0b6-396">Property metadata for the dependency property.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="8e0b6-397">使用指定的属性名称、所有者类型和属性元数据注册只读附加属性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e0b6-397">Registers a read-only attached property, with the specified property type, owner type, and property metadata.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="8e0b6-398">一个依赖属性键，此键应用于设置你的类中静态只读字段的值，该值稍后被用于引用该依赖属性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e0b6-398">A dependency property key that should be used to set the value of a static read-only field in your class, which is then used to reference the dependency property later.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8e0b6-399">此方法返回的类型<xref:System.Windows.DependencyPropertyKey>，而<xref:System.Windows.DependencyProperty.RegisterAttached%2A>返回的类型<xref:System.Windows.DependencyProperty>。</span><span class="sxs-lookup"><span data-stu-id="8e0b6-399">This method returns the type <xref:System.Windows.DependencyPropertyKey>, whereas <xref:System.Windows.DependencyProperty.RegisterAttached%2A> returns the type <xref:System.Windows.DependencyProperty>.</span></span> <span data-ttu-id="8e0b6-400">通常情况下，表示只读属性的密钥不会将公共的因为密钥可以用于通过调用设置依赖项属性值<xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29>。</span><span class="sxs-lookup"><span data-stu-id="8e0b6-400">Typically, the keys that represent read-only properties are not made public, because the keys can be used to set the dependency property value by calling <xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29>.</span></span> <span data-ttu-id="8e0b6-401">类设计会影响你的要求，但通常建议限制的访问权限和任何可见性<xref:System.Windows.DependencyPropertyKey>到只是那些需要将该依赖项属性设置为类或应用程序逻辑的一部分的代码部分。</span><span class="sxs-lookup"><span data-stu-id="8e0b6-401">Your class design will affect your requirements, but it is generally recommended to limit the access and visibility of any <xref:System.Windows.DependencyPropertyKey> to only those parts of your code that are necessary to set that dependency property as part of class or application logic.</span></span> <span data-ttu-id="8e0b6-402">此外，建议您通过公开的值来公开该只读依赖属性的依赖项属性标识符<xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A?displayProperty=nameWithType>作为`public static readonly`字段在类上。</span><span class="sxs-lookup"><span data-stu-id="8e0b6-402">It is also recommended that you expose a dependency property identifier for the read-only dependency property, by exposing the value of <xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A?displayProperty=nameWithType> as a `public static readonly` field on your class.</span></span>  
  
 <span data-ttu-id="8e0b6-403">只读附加的属性是少见的方案，因为附加属性的主要方案是在中的使用它[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]。</span><span class="sxs-lookup"><span data-stu-id="8e0b6-403">Read-only attached properties are a rare scenario, because the primary scenario for an attached property is its use in [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].</span></span> <span data-ttu-id="8e0b6-404">没有公共 setter 的情况下附加的属性不能设置[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]语法。</span><span class="sxs-lookup"><span data-stu-id="8e0b6-404">Without a public setter, an attached property cannot be set in [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] syntax.</span></span>  
  
 <span data-ttu-id="8e0b6-405">依赖关系属性注册的详细信息，请参阅<xref:System.Windows.DependencyProperty>。</span><span class="sxs-lookup"><span data-stu-id="8e0b6-405">For more information on dependency property registration, see <xref:System.Windows.DependencyProperty>.</span></span>  
  
## <a name="use-registerattached-for-value-inheriting-dependency-properties"></a><span data-ttu-id="8e0b6-406">使用 RegisterAttached 值继承依赖属性</span><span class="sxs-lookup"><span data-stu-id="8e0b6-406">Use RegisterAttached for Value-inheriting Dependency Properties</span></span>  
 <span data-ttu-id="8e0b6-407">注册为依赖属性的一个特定的方案附加是支持的属性值继承。</span><span class="sxs-lookup"><span data-stu-id="8e0b6-407">One particular scenario for registering a dependency property as attached is to support property value inheritance.</span></span> <span data-ttu-id="8e0b6-408">应注册与值继承依赖属性<xref:System.Windows.DependencyProperty.RegisterAttached%2A>即使该类定义公开该依赖属性的属性包装器访问器，即使您不打算公开 Get \* 和集 \* 静态方法，以提供 true 附加属性支持访问器。</span><span class="sxs-lookup"><span data-stu-id="8e0b6-408">You should register value-inheriting dependency properties with <xref:System.Windows.DependencyProperty.RegisterAttached%2A> even if the class defines property wrapper accessors that expose the dependency property, and even if you do not intend to expose Get\* and Set\* static methods to provide true attached property support accessors.</span></span>   <span data-ttu-id="8e0b6-409">虽然属性值继承看起来适用于非附加依赖项属性，但通过在运行时树中特定元素边界的非附加属性的继承行为未定义。</span><span class="sxs-lookup"><span data-stu-id="8e0b6-409">Although property value inheritance might appear to work for nonattached dependency properties, the inheritance behavior for a nonattached property through certain element boundaries in the runtime tree is undefined.</span></span> <span data-ttu-id="8e0b6-410">将属性注册为附加有效地对属性系统中，附加的属性的全局属性，并确保属性值继承，可以在元素树中的所有边界。</span><span class="sxs-lookup"><span data-stu-id="8e0b6-410">Registering the property as attached effectively makes the attached property a global property to the property system, and assures that property value inheritance works across all boundaries in an element tree.</span></span> <span data-ttu-id="8e0b6-411">始终使用<xref:System.Windows.DependencyProperty.RegisterAttached%2A>来注册您在其中指定的属性<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>元数据中。</span><span class="sxs-lookup"><span data-stu-id="8e0b6-411">Always use <xref:System.Windows.DependencyProperty.RegisterAttached%2A> to register properties where you specify <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> in the metadata.</span></span> <span data-ttu-id="8e0b6-412">有关详细信息，请参阅[属性值继承](~/docs/framework/wpf/advanced/property-value-inheritance.md)。</span><span class="sxs-lookup"><span data-stu-id="8e0b6-412">For more information, see [Property Value Inheritance](~/docs/framework/wpf/advanced/property-value-inheritance.md).</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RegisterAttachedReadOnly">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyPropertyKey RegisterAttachedReadOnly (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata defaultMetadata, System.Windows.ValidateValueCallback validateValueCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyPropertyKey RegisterAttachedReadOnly(string name, class System.Type propertyType, class System.Type ownerType, class System.Windows.PropertyMetadata defaultMetadata, class System.Windows.ValidateValueCallback validateValueCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyPropertyKey ^ RegisterAttachedReadOnly(System::String ^ name, Type ^ propertyType, Type ^ ownerType, System::Windows::PropertyMetadata ^ defaultMetadata, System::Windows::ValidateValueCallback ^ validateValueCallback);" />
      <MemberSignature Language="F#" Value="static member RegisterAttachedReadOnly : string * Type * Type * System.Windows.PropertyMetadata * System.Windows.ValidateValueCallback -&gt; System.Windows.DependencyPropertyKey" Usage="System.Windows.DependencyProperty.RegisterAttachedReadOnly (name, propertyType, ownerType, defaultMetadata, validateValueCallback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="ownerType" Type="System.Type" />
        <Parameter Name="defaultMetadata" Type="System.Windows.PropertyMetadata" />
        <Parameter Name="validateValueCallback" Type="System.Windows.ValidateValueCallback" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="8e0b6-413">要注册的依赖属性的名称。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e0b6-413">The name of the dependency property to register.</span>
          </span>
        </param>
        <param name="propertyType">
          <span data-ttu-id="8e0b6-414">属性的类型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e0b6-414">The type of the property.</span>
          </span>
        </param>
        <param name="ownerType">
          <span data-ttu-id="8e0b6-415">正在注册依赖属性的所有者类型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e0b6-415">The owner type that is registering the dependency property.</span>
          </span>
        </param>
        <param name="defaultMetadata">
          <span data-ttu-id="8e0b6-416">依赖属性的属性元数据。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e0b6-416">Property metadata for the dependency property.</span>
          </span>
        </param>
        <param name="validateValueCallback">
          <span data-ttu-id="8e0b6-417">对用户创建的回调的引用，除了典型的类型验证之外，该引用还应执行依赖属性值的任何自定义验证。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e0b6-417">A reference to a user-created callback that should perform any custom validation of the dependency property value beyond typical type validation.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="8e0b6-418">使用指定的属性类型、所有者类型、属性元数据和验证回调来注册只读附加属性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e0b6-418">Registers a read-only attached property, with the specified property type, owner type, property metadata, and a validation callback.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="8e0b6-419">一个依赖属性键，应使用它在类中设置静态只读字段的值，然后使用该字段的值引用依赖属性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e0b6-419">A dependency property key that should be used to set the value of a static read-only field in your class, which is then used to reference the dependency property.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8e0b6-420">此方法返回的类型<xref:System.Windows.DependencyPropertyKey>，而<xref:System.Windows.DependencyProperty.RegisterAttached%2A>返回的类型<xref:System.Windows.DependencyProperty>。</span><span class="sxs-lookup"><span data-stu-id="8e0b6-420">This method returns the type <xref:System.Windows.DependencyPropertyKey>, whereas <xref:System.Windows.DependencyProperty.RegisterAttached%2A> returns the type <xref:System.Windows.DependencyProperty>.</span></span> <span data-ttu-id="8e0b6-421">通常情况下，表示类型的密钥<xref:System.Windows.DependencyProperty>。</span><span class="sxs-lookup"><span data-stu-id="8e0b6-421">Typically, the keys that represent the type <xref:System.Windows.DependencyProperty>.</span></span> <span data-ttu-id="8e0b6-422">通常情况下，表示只读属性的密钥不会将公共的因为密钥可以用于通过调用设置依赖项属性值<xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29>。</span><span class="sxs-lookup"><span data-stu-id="8e0b6-422">Typically, the keys that represent read-only properties are not made public, because the keys can be used to set the dependency property value by calling <xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29>.</span></span> <span data-ttu-id="8e0b6-423">类设计会影响你的要求，但通常建议限制的访问权限和任何可见性<xref:System.Windows.DependencyPropertyKey>到只是那些需要将该依赖项属性设置为类或应用程序逻辑的一部分的代码部分。</span><span class="sxs-lookup"><span data-stu-id="8e0b6-423">Your class design will affect your requirements, but it is generally recommended to limit the access and visibility of any <xref:System.Windows.DependencyPropertyKey> to only those parts of your code that are necessary to set that dependency property as part of class or application logic.</span></span> <span data-ttu-id="8e0b6-424">此外，建议您通过公开的值来公开该只读依赖属性的依赖项属性标识符<xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A?displayProperty=nameWithType>作为`public static readonly`字段在类上。</span><span class="sxs-lookup"><span data-stu-id="8e0b6-424">It is also recommended that you expose a dependency property identifier for the read-only dependency property, by exposing the value of <xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A?displayProperty=nameWithType> as a `public static readonly` field on your class.</span></span>  
  
 <span data-ttu-id="8e0b6-425">只读附加的属性是少见的方案，因为附加属性的主要方案是在中的使用它[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]。</span><span class="sxs-lookup"><span data-stu-id="8e0b6-425">Read-only attached properties are a rare scenario, because the primary scenario for an attached property is its use in [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].</span></span> <span data-ttu-id="8e0b6-426">没有公共 setter 的情况下附加的属性不能设置[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]语法。</span><span class="sxs-lookup"><span data-stu-id="8e0b6-426">Without a public setter, an attached property cannot be set in [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] syntax.</span></span>  
  
 <span data-ttu-id="8e0b6-427">依赖关系属性注册的详细信息，请参阅<xref:System.Windows.DependencyProperty>。</span><span class="sxs-lookup"><span data-stu-id="8e0b6-427">For more information on dependency property registration, see <xref:System.Windows.DependencyProperty>.</span></span>  
  
## <a name="use-registerattached-for-value-inheriting-dependency-properties"></a><span data-ttu-id="8e0b6-428">使用 RegisterAttached 值继承依赖属性</span><span class="sxs-lookup"><span data-stu-id="8e0b6-428">Use RegisterAttached for Value-inheriting Dependency Properties</span></span>  
 <span data-ttu-id="8e0b6-429">有关注册依赖项属性为附加而不是一个特殊的情况<xref:System.Windows.DependencyProperty.Register%2A>是支持的属性值继承。</span><span class="sxs-lookup"><span data-stu-id="8e0b6-429">One particular scenario for registering a dependency property as attached instead of <xref:System.Windows.DependencyProperty.Register%2A> is to support property value inheritance.</span></span> <span data-ttu-id="8e0b6-430">应注册与值继承依赖属性<xref:System.Windows.DependencyProperty.RegisterAttached%2A>即使该类定义公开该依赖属性的属性包装器访问器，即使您不打算公开 Get \* 和集 \* 静态方法，以提供 true 附加属性支持访问器。</span><span class="sxs-lookup"><span data-stu-id="8e0b6-430">You should register value-inheriting dependency properties with <xref:System.Windows.DependencyProperty.RegisterAttached%2A> even if the class defines property wrapper accessors that expose the dependency property, and even if you do not intend to expose Get\* and Set\* static methods to provide true attached property support accessors.</span></span>   <span data-ttu-id="8e0b6-431">虽然属性值继承看起来适用于非附加依赖项属性，但通过在运行时树中特定元素边界的非附加属性的继承行为未定义。</span><span class="sxs-lookup"><span data-stu-id="8e0b6-431">Although property value inheritance might appear to work for nonattached dependency properties, the inheritance behavior for a nonattached property through certain element boundaries in the runtime tree is undefined.</span></span> <span data-ttu-id="8e0b6-432">将属性注册为附加有效地对属性系统中，附加的属性的全局属性，并确保属性值继承，可以在元素树中的所有边界。</span><span class="sxs-lookup"><span data-stu-id="8e0b6-432">Registering the property as attached effectively makes the attached property a global property to the property system, and assures that property value inheritance works across all boundaries in an element tree.</span></span> <span data-ttu-id="8e0b6-433">始终使用<xref:System.Windows.DependencyProperty.RegisterAttached%2A>来注册您在其中指定的属性<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>元数据中。</span><span class="sxs-lookup"><span data-stu-id="8e0b6-433">Always use <xref:System.Windows.DependencyProperty.RegisterAttached%2A> to register properties where you specify <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> in the metadata.</span></span> <span data-ttu-id="8e0b6-434">有关详细信息，请参阅[属性值继承](~/docs/framework/wpf/advanced/property-value-inheritance.md)。</span><span class="sxs-lookup"><span data-stu-id="8e0b6-434">For more information, see [Property Value Inheritance](~/docs/framework/wpf/advanced/property-value-inheritance.md).</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="RegisterReadOnly">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="8e0b6-435">将依赖属性注册为只读依赖属性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e0b6-435">Registers a dependency property as a read-only dependency property.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RegisterReadOnly">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyPropertyKey RegisterReadOnly (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata typeMetadata);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyPropertyKey RegisterReadOnly(string name, class System.Type propertyType, class System.Type ownerType, class System.Windows.PropertyMetadata typeMetadata) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RegisterReadOnly (name As String, propertyType As Type, ownerType As Type, typeMetadata As PropertyMetadata) As DependencyPropertyKey" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyPropertyKey ^ RegisterReadOnly(System::String ^ name, Type ^ propertyType, Type ^ ownerType, System::Windows::PropertyMetadata ^ typeMetadata);" />
      <MemberSignature Language="F#" Value="static member RegisterReadOnly : string * Type * Type * System.Windows.PropertyMetadata -&gt; System.Windows.DependencyPropertyKey" Usage="System.Windows.DependencyProperty.RegisterReadOnly (name, propertyType, ownerType, typeMetadata)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="ownerType" Type="System.Type" />
        <Parameter Name="typeMetadata" Type="System.Windows.PropertyMetadata" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="8e0b6-436">要注册的依赖属性的名称。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e0b6-436">The name of the dependency property to register.</span>
          </span>
        </param>
        <param name="propertyType">
          <span data-ttu-id="8e0b6-437">属性的类型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e0b6-437">The type of the property.</span>
          </span>
        </param>
        <param name="ownerType">
          <span data-ttu-id="8e0b6-438">正在注册依赖属性的所有者类型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e0b6-438">The owner type that is registering the dependency property.</span>
          </span>
        </param>
        <param name="typeMetadata">
          <span data-ttu-id="8e0b6-439">依赖属性的属性元数据。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e0b6-439">Property metadata for the dependency property.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="8e0b6-440">使用指定的属性名称、所有者类型和属性元数据注册只读依赖属性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e0b6-440">Registers a read-only dependency property, with the specified property type, owner type, and property metadata.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="8e0b6-441">一个依赖属性键，应使用它在类中设置静态只读字段的值，然后使用该字段的值引用依赖属性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e0b6-441">A dependency property key that should be used to set the value of a static read-only field in your class, which is then used to reference the dependency property.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8e0b6-442">此方法返回的类型<xref:System.Windows.DependencyPropertyKey>，而<xref:System.Windows.DependencyProperty.RegisterAttached%2A>返回的类型<xref:System.Windows.DependencyProperty>。</span><span class="sxs-lookup"><span data-stu-id="8e0b6-442">This method returns the type <xref:System.Windows.DependencyPropertyKey>, whereas <xref:System.Windows.DependencyProperty.RegisterAttached%2A> returns the type <xref:System.Windows.DependencyProperty>.</span></span> <span data-ttu-id="8e0b6-443">通常情况下，表示只读属性的密钥不会将公共的因为密钥可以用于通过调用设置依赖项属性值<xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29>。</span><span class="sxs-lookup"><span data-stu-id="8e0b6-443">Typically, the keys that represent read-only properties are not made public, because the keys can be used to set the dependency property value by calling <xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29>.</span></span> <span data-ttu-id="8e0b6-444">类设计会影响你的要求，但通常建议限制的访问权限和任何可见性<xref:System.Windows.DependencyPropertyKey>到只是那些需要将该依赖项属性设置为类或应用程序逻辑的一部分的代码部分。</span><span class="sxs-lookup"><span data-stu-id="8e0b6-444">Your class design will affect your requirements, but it is generally recommended to limit the access and visibility of any <xref:System.Windows.DependencyPropertyKey> to only those parts of your code that are necessary to set that dependency property as part of class or application logic.</span></span> <span data-ttu-id="8e0b6-445">此外，建议您通过公开的值来公开该只读依赖属性的依赖项属性标识符<xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A?displayProperty=nameWithType>作为`public static readonly`字段在类上。</span><span class="sxs-lookup"><span data-stu-id="8e0b6-445">It is also recommended that you expose a dependency property identifier for the read-only dependency property, by exposing the value of <xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A?displayProperty=nameWithType> as a `public static readonly` field on your class.</span></span>  
  
 <span data-ttu-id="8e0b6-446">只读依赖属性是相当典型的方案中的现有[!INCLUDE[TLA2#tla_api](~/includes/tla2sharptla-api-md.md)]和自定义方案，因为其他[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]功能可能需要依赖项属性，即使该属性不应可以通过设置调用方。</span><span class="sxs-lookup"><span data-stu-id="8e0b6-446">Read-only dependency properties are a fairly typical scenario both in the existing [!INCLUDE[TLA2#tla_api](~/includes/tla2sharptla-api-md.md)] and for customization scenarios, because other [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] features might require a dependency property even if that property is not intended to be settable by callers.</span></span> <span data-ttu-id="8e0b6-447">可用于只读依赖属性的值作为基础采用依赖项属性，如将其他属性系统操作<xref:System.Windows.Trigger>样式中的依赖属性。</span><span class="sxs-lookup"><span data-stu-id="8e0b6-447">You can use the value of a read-only dependency property as the basis for other property system operations that take a dependency property, such as basing a <xref:System.Windows.Trigger> on the dependency property in a style.</span></span>  
  
 <span data-ttu-id="8e0b6-448">依赖关系属性注册的详细信息，请参阅<xref:System.Windows.DependencyProperty>。</span><span class="sxs-lookup"><span data-stu-id="8e0b6-448">For more information on dependency property registration, see <xref:System.Windows.DependencyProperty>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="8e0b6-449">下面的示例注册`AquariumSize`依赖项属性为只读的。</span><span class="sxs-lookup"><span data-stu-id="8e0b6-449">The following example registers an `AquariumSize` dependency property as read-only.</span></span> <span data-ttu-id="8e0b6-450">该示例定义了`AquariumSizeKey`作为内部键 （在程序集中，以便其他类可以重写元数据） 和依赖项属性标识符基于该密钥作为公开`AquariumSizeProperty`。</span><span class="sxs-lookup"><span data-stu-id="8e0b6-450">The example defines `AquariumSizeKey` as an internal key (so that other classes in the assembly could override metadata) and exposes the dependency property identifier based on that key as `AquariumSizeProperty`.</span></span> <span data-ttu-id="8e0b6-451">此外，对于创建的包装`AquariumSize`，只有 get 访问器。</span><span class="sxs-lookup"><span data-stu-id="8e0b6-451">Also, a wrapper is created for `AquariumSize`, with only a get accessor.</span></span>  
  
 [!code-csharp[WPFAquariumSln#RODP](~/samples/snippets/csharp/VS_Snippets_Wpf/WPFAquariumSln/CSharp/WPFAquariumObjects/Class1.cs#rodp)]
 [!code-vb[WPFAquariumSln#RODP](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WPFAquariumSln/visualbasic/wpfaquariumobjects/class1.vb#rodp)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RegisterReadOnly">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyPropertyKey RegisterReadOnly (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata typeMetadata, System.Windows.ValidateValueCallback validateValueCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyPropertyKey RegisterReadOnly(string name, class System.Type propertyType, class System.Type ownerType, class System.Windows.PropertyMetadata typeMetadata, class System.Windows.ValidateValueCallback validateValueCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyPropertyKey ^ RegisterReadOnly(System::String ^ name, Type ^ propertyType, Type ^ ownerType, System::Windows::PropertyMetadata ^ typeMetadata, System::Windows::ValidateValueCallback ^ validateValueCallback);" />
      <MemberSignature Language="F#" Value="static member RegisterReadOnly : string * Type * Type * System.Windows.PropertyMetadata * System.Windows.ValidateValueCallback -&gt; System.Windows.DependencyPropertyKey" Usage="System.Windows.DependencyProperty.RegisterReadOnly (name, propertyType, ownerType, typeMetadata, validateValueCallback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="ownerType" Type="System.Type" />
        <Parameter Name="typeMetadata" Type="System.Windows.PropertyMetadata" />
        <Parameter Name="validateValueCallback" Type="System.Windows.ValidateValueCallback" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="8e0b6-452">要注册的依赖属性的名称。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e0b6-452">The name of the dependency property to register.</span>
          </span>
        </param>
        <param name="propertyType">
          <span data-ttu-id="8e0b6-453">属性的类型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e0b6-453">The type of the property.</span>
          </span>
        </param>
        <param name="ownerType">
          <span data-ttu-id="8e0b6-454">正在注册依赖属性的所有者类型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e0b6-454">The owner type that is registering the dependency property.</span>
          </span>
        </param>
        <param name="typeMetadata">
          <span data-ttu-id="8e0b6-455">依赖属性的属性元数据。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e0b6-455">Property metadata for the dependency property.</span>
          </span>
        </param>
        <param name="validateValueCallback">
          <span data-ttu-id="8e0b6-456">对用户创建的回调的引用，除了典型的类型验证之外，该引用还应执行依赖属性值的任何自定义验证。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e0b6-456">A reference to a user-created callback that should perform any custom validation of the dependency property value beyond typical type validation.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="8e0b6-457">使用指定的属性类型、所有者类型、属性元数据和验证回叫来注册只读依赖属性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e0b6-457">Registers a read-only dependency property, with the specified property type, owner type, property metadata, and a validation callback.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="8e0b6-458">一个依赖属性键，此键应用于设置你的类中静态只读字段的值，该值稍后被用于引用该依赖属性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e0b6-458">A dependency property key that should be used to set the value of a static read-only field in your class, which is then used to reference the dependency property later.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8e0b6-459">此方法返回的类型<xref:System.Windows.DependencyPropertyKey>，而<xref:System.Windows.DependencyProperty.RegisterAttached%2A>返回的类型<xref:System.Windows.DependencyProperty>。</span><span class="sxs-lookup"><span data-stu-id="8e0b6-459">This method returns the type <xref:System.Windows.DependencyPropertyKey>, whereas <xref:System.Windows.DependencyProperty.RegisterAttached%2A> returns the type <xref:System.Windows.DependencyProperty>.</span></span> <span data-ttu-id="8e0b6-460">通常情况下，表示只读属性的密钥不会将公共的因为密钥可以用于通过调用设置依赖项属性值<xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29>。</span><span class="sxs-lookup"><span data-stu-id="8e0b6-460">Typically, the keys that represent read-only properties are not made public, because the keys can be used to set the dependency property value by calling <xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29>.</span></span> <span data-ttu-id="8e0b6-461">类设计会影响你的要求，但通常建议限制的访问权限和任何可见性<xref:System.Windows.DependencyPropertyKey>到只是那些需要将该依赖项属性设置为类或应用程序逻辑的一部分的代码部分。</span><span class="sxs-lookup"><span data-stu-id="8e0b6-461">Your class design will affect your requirements, but it is generally recommended to limit the access and visibility of any <xref:System.Windows.DependencyPropertyKey> to only those parts of your code that are necessary to set that dependency property as part of class or application logic.</span></span> <span data-ttu-id="8e0b6-462">此外，建议您通过公开的值来公开该只读依赖属性的依赖项属性标识符<xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A?displayProperty=nameWithType>作为`public static readonly`字段在类上。</span><span class="sxs-lookup"><span data-stu-id="8e0b6-462">It is also recommended that you expose a dependency property identifier for the read-only dependency property, by exposing the value of <xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A?displayProperty=nameWithType> as a `public static readonly` field on your class.</span></span>  
  
 <span data-ttu-id="8e0b6-463">只读依赖属性是相当典型的方案。</span><span class="sxs-lookup"><span data-stu-id="8e0b6-463">Read-only dependency properties are a fairly typical scenario.</span></span> <span data-ttu-id="8e0b6-464">可用于只读依赖属性的值作为基础采用依赖项属性，如将其他属性系统操作<xref:System.Windows.Trigger>样式中的依赖属性。</span><span class="sxs-lookup"><span data-stu-id="8e0b6-464">You can use the value of a read-only dependency property as the basis for other property system operations that take a dependency property, such as basing a <xref:System.Windows.Trigger> on the dependency property in a style.</span></span>  
  
 <span data-ttu-id="8e0b6-465">依赖关系属性注册的详细信息，请参阅<xref:System.Windows.DependencyProperty>。</span><span class="sxs-lookup"><span data-stu-id="8e0b6-465">For more information on dependency property registration, see <xref:System.Windows.DependencyProperty>.</span></span>  
  
 <span data-ttu-id="8e0b6-466">只读依赖属性上的验证可能不太重要。</span><span class="sxs-lookup"><span data-stu-id="8e0b6-466">Validation on a read-only dependency property might be less important.</span></span> <span data-ttu-id="8e0b6-467">为密钥指定的非公共访问级别可以减少对任意无效输入的可能性。</span><span class="sxs-lookup"><span data-stu-id="8e0b6-467">The nonpublic access level you specify for the key reduces the likelihood for arbitrary invalid input.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="dependencyProperty.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="8e0b6-468">返回依赖属性的字符串表示形式。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e0b6-468">Returns the string representation of the dependency property.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="8e0b6-469">依赖属性的字符串表示形式。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e0b6-469">The string representation of the dependency property.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8e0b6-470">此实现返回<xref:System.Windows.DependencyProperty.Name%2A>属性值。</span><span class="sxs-lookup"><span data-stu-id="8e0b6-470">This implementation returns the <xref:System.Windows.DependencyProperty.Name%2A> property value.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.DependencyProperty.Name" />
      </Docs>
    </Member>
    <Member MemberName="UnsetValue">
      <MemberSignature Language="C#" Value="public static readonly object UnsetValue;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly object UnsetValue" />
      <MemberSignature Language="DocId" Value="F:System.Windows.DependencyProperty.UnsetValue" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly UnsetValue As Object " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Object ^ UnsetValue;" />
      <MemberSignature Language="F#" Value=" staticval mutable UnsetValue : obj" Usage="System.Windows.DependencyProperty.UnsetValue" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="8e0b6-471">指定由 [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] 属性系统使用的静态值而非 <see langword="null" />，以指示属性存在，但其值未经属性系统设置。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e0b6-471">Specifies a static value that is used by the [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] property system rather than <see langword="null" /> to indicate that the property exists, but does not have its value set by the property system.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8e0b6-472"><xref:System.Windows.DependencyProperty.UnsetValue> 是一个 sentinel 值用于方案，其中[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]属性系统是无法确定请求<xref:System.Windows.DependencyProperty>值。</span><span class="sxs-lookup"><span data-stu-id="8e0b6-472"><xref:System.Windows.DependencyProperty.UnsetValue> is a sentinel value that is used for scenarios where the [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] property system is unable to determine a requested <xref:System.Windows.DependencyProperty> value.</span></span> <span data-ttu-id="8e0b6-473"><xref:System.Windows.DependencyProperty.UnsetValue> 使用而非`null`，因为`null`可以是有效的属性值，也是有效 （和常用） <xref:System.Windows.PropertyMetadata.DefaultValue%2A>。</span><span class="sxs-lookup"><span data-stu-id="8e0b6-473"><xref:System.Windows.DependencyProperty.UnsetValue> is used rather than `null`, because `null` could be a valid property value, as well as a valid (and frequently used) <xref:System.Windows.PropertyMetadata.DefaultValue%2A>.</span></span>  
  
 <span data-ttu-id="8e0b6-474"><xref:System.Windows.DependencyProperty.UnsetValue> 永远不会返回带<xref:System.Windows.DependencyObject.GetValue%2A?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="8e0b6-474"><xref:System.Windows.DependencyProperty.UnsetValue> is never returned out of <xref:System.Windows.DependencyObject.GetValue%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="8e0b6-475">当您调用<xref:System.Windows.DependencyObject.GetValue%2A?displayProperty=nameWithType>上的依赖项属性<xref:System.Windows.DependencyObject>实例，一个以下应用：</span><span class="sxs-lookup"><span data-stu-id="8e0b6-475">When you call <xref:System.Windows.DependencyObject.GetValue%2A?displayProperty=nameWithType> on a dependency property on a <xref:System.Windows.DependencyObject> instance, one of the following applies:</span></span>  
  
-   <span data-ttu-id="8e0b6-476">依赖属性具有默认值在元数据，并返回该值。</span><span class="sxs-lookup"><span data-stu-id="8e0b6-476">A dependency property has a default value established in metadata and that value is returned.</span></span> <span data-ttu-id="8e0b6-477">此值可能来自<xref:System.Windows.DependencyProperty.DefaultMetadata%2A>。</span><span class="sxs-lookup"><span data-stu-id="8e0b6-477">This value might come from <xref:System.Windows.DependencyProperty.DefaultMetadata%2A>.</span></span>  
  
-   <span data-ttu-id="8e0b6-478">一些其他值由属性系统中，并且默认值不再适用。</span><span class="sxs-lookup"><span data-stu-id="8e0b6-478">Some other value was established by the property system, and the default value is no longer relevant.</span></span> <span data-ttu-id="8e0b6-479">有关详细信息，请参阅[依赖属性值优先级](~/docs/framework/wpf/advanced/dependency-property-value-precedence.md)。</span><span class="sxs-lookup"><span data-stu-id="8e0b6-479">For details, see [Dependency Property Value Precedence](~/docs/framework/wpf/advanced/dependency-property-value-precedence.md).</span></span>  
  
 <span data-ttu-id="8e0b6-480">设置<xref:System.Windows.PropertyMetadata.DefaultValue%2A>的<xref:System.Windows.DependencyProperty.UnsetValue>明确不允许。</span><span class="sxs-lookup"><span data-stu-id="8e0b6-480">Setting a <xref:System.Windows.PropertyMetadata.DefaultValue%2A> of <xref:System.Windows.DependencyProperty.UnsetValue> is specifically disallowed.</span></span>  
  
 <span data-ttu-id="8e0b6-481"><xref:System.Windows.DependencyObject.ReadLocalValue%2A?displayProperty=nameWithType> 返回<xref:System.Windows.DependencyProperty.UnsetValue>时请求的属性具有未在本地设置。</span><span class="sxs-lookup"><span data-stu-id="8e0b6-481"><xref:System.Windows.DependencyObject.ReadLocalValue%2A?displayProperty=nameWithType> returns <xref:System.Windows.DependencyProperty.UnsetValue> when the requested property has not been locally set.</span></span>  
  
 <span data-ttu-id="8e0b6-482"><xref:System.Windows.DependencyProperty.UnsetValue> 具有特殊含义时使用的返回值作为<xref:System.Windows.CoerceValueCallback>。</span><span class="sxs-lookup"><span data-stu-id="8e0b6-482"><xref:System.Windows.DependencyProperty.UnsetValue> has a special meaning when used as the return value of a <xref:System.Windows.CoerceValueCallback>.</span></span> <span data-ttu-id="8e0b6-483">有关详细信息，请参阅[依赖属性回调和验证](~/docs/framework/wpf/advanced/dependency-property-callbacks-and-validation.md)。</span><span class="sxs-lookup"><span data-stu-id="8e0b6-483">For details, see [Dependency Property Callbacks and Validation](~/docs/framework/wpf/advanced/dependency-property-callbacks-and-validation.md).</span></span>  
  
 <span data-ttu-id="8e0b6-484">如果要绑定到数据库，请注意<xref:System.Windows.DependencyProperty.UnsetValue>并不等同于<xref:System.DBNull.Value>，以及的方式类似的方式<xref:System.DBNull.Value>并不等同于 true 的为 null。</span><span class="sxs-lookup"><span data-stu-id="8e0b6-484">If you are binding to a database, note that <xref:System.Windows.DependencyProperty.UnsetValue> is not equivalent to <xref:System.DBNull.Value>, in a similar way to how <xref:System.DBNull.Value> is not equivalent to a true null.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ValidateValueCallback">
      <MemberSignature Language="C#" Value="public System.Windows.ValidateValueCallback ValidateValueCallback { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.ValidateValueCallback ValidateValueCallback" />
      <MemberSignature Language="DocId" Value="P:System.Windows.DependencyProperty.ValidateValueCallback" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ValidateValueCallback As ValidateValueCallback" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::ValidateValueCallback ^ ValidateValueCallback { System::Windows::ValidateValueCallback ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ValidateValueCallback : System.Windows.ValidateValueCallback" Usage="System.Windows.DependencyProperty.ValidateValueCallback" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.ValidateValueCallback</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="8e0b6-485">获取依赖项对象的值验证回调。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e0b6-485">Gets the value validation callback for the dependency property.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="8e0b6-486">最初依赖项对象注册时为 <paramref name="validateValueCallback" /> 参数提供的该依赖项对象的值验证回调。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e0b6-486">The value validation callback for this dependency property, as provided for the <paramref name="validateValueCallback" /> parameter in the original dependency property registration.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8e0b6-487">此属性将包含`null`没有已注册的验证回调具有任何依赖项属性。</span><span class="sxs-lookup"><span data-stu-id="8e0b6-487">This property will contain `null` for any dependency property with no registered validation callback.</span></span>  
  
 <span data-ttu-id="8e0b6-488">验证回叫的行为必须在静态意义上的值： 通过应用验证<xref:System.Windows.ValidateValueCallback>不能确定提供的值是否对任何特定实例有效。</span><span class="sxs-lookup"><span data-stu-id="8e0b6-488">Validate value callbacks must act in a static sense: validation applied through the <xref:System.Windows.ValidateValueCallback> cannot determine whether the provided value is valid for any particular instance.</span></span> <span data-ttu-id="8e0b6-489">回调仅可以确定是否具有依赖项属性的所有对象应该或不应接受为有效提供的值。</span><span class="sxs-lookup"><span data-stu-id="8e0b6-489">The callback can only determine whether all objects that possess the dependency property should or should not accept the provided value as valid.</span></span> <span data-ttu-id="8e0b6-490">如果你需要执行依赖于知道上一个特定实例，使用的其他依赖项属性的值的验证<xref:System.Windows.CoerceValueCallback>相反。</span><span class="sxs-lookup"><span data-stu-id="8e0b6-490">If you need to perform validation that relies on knowing the values of other dependency properties on a particular instance, use a <xref:System.Windows.CoerceValueCallback> instead.</span></span> <span data-ttu-id="8e0b6-491"><xref:System.Windows.CoerceValueCallback>作为依赖属性元数据，而不是直接在依赖项属性标识符的一部分进行注册。</span><span class="sxs-lookup"><span data-stu-id="8e0b6-491">The <xref:System.Windows.CoerceValueCallback> is registered as part of dependency property metadata, rather than directly within the dependency property identifier.</span></span> <span data-ttu-id="8e0b6-492">有关详细信息，请参阅[依赖属性回调和验证](~/docs/framework/wpf/advanced/dependency-property-callbacks-and-validation.md)。</span><span class="sxs-lookup"><span data-stu-id="8e0b6-492">For details, see [Dependency Property Callbacks and Validation](~/docs/framework/wpf/advanced/dependency-property-callbacks-and-validation.md).</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.ValidateValueCallback" />
      </Docs>
    </Member>
  </Members>
</Type>