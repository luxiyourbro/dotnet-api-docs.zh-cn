<Type Name="FrameworkContentElement" FullName="System.Windows.FrameworkContentElement">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="fa112b67988d89807201b31758464c713a866c6b" />
    <Meta Name="ms.sourcegitcommit" Value="0ec122ee5f3681159b8460ab15b409fd6e3d3ae0" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-CN" />
    <Meta Name="ms.lasthandoff" Value="10/04/2018" />
    <Meta Name="ms.locfileid" Value="48607803" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class FrameworkContentElement : System.Windows.ContentElement, System.ComponentModel.ISupportInitialize, System.Windows.IFrameworkInputElement, System.Windows.Markup.IQueryAmbient" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi FrameworkContentElement extends System.Windows.ContentElement implements class System.ComponentModel.ISupportInitialize, class System.Windows.IFrameworkInputElement, class System.Windows.IInputElement, class System.Windows.Markup.IQueryAmbient" />
  <TypeSignature Language="DocId" Value="T:System.Windows.FrameworkContentElement" />
  <TypeSignature Language="VB.NET" Value="Public Class FrameworkContentElement&#xA;Inherits ContentElement&#xA;Implements IFrameworkInputElement, IQueryAmbient, ISupportInitialize" />
  <TypeSignature Language="C++ CLI" Value="public ref class FrameworkContentElement : System::Windows::ContentElement, System::ComponentModel::ISupportInitialize, System::Windows::IFrameworkInputElement, System::Windows::Markup::IQueryAmbient" />
  <TypeSignature Language="F#" Value="type FrameworkContentElement = class&#xA;    inherit ContentElement&#xA;    interface IFrameworkInputElement&#xA;    interface IInputElement&#xA;    interface ISupportInitialize&#xA;    interface IQueryAmbient" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.ContentElement</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ComponentModel.ISupportInitialize</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Windows.IFrameworkInputElement</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Windows.Markup.IQueryAmbient</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.Windows.Markup.RuntimeNameProperty("Name")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.Windows.Markup.UsableDuringInitialization(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.Windows.Markup.XmlLangProperty("Language")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.Windows.StyleTypedProperty(Property="FocusVisualStyle", StyleTargetType=typeof(System.Windows.Controls.Control))</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>
      <span data-ttu-id="891c2-101">
        <see cref="T:System.Windows.FrameworkContentElement" /> 是 <see cref="T:System.Windows.ContentElement" /> 基类的 WPF 框架级别的实现和扩展。</span>
      <span class="sxs-lookup">
        <span data-stu-id="891c2-101">
          <see cref="T:System.Windows.FrameworkContentElement" /> is the WPF framework-level implementation and expansion of the <see cref="T:System.Windows.ContentElement" /> base class.</span>
      </span>
      <span data-ttu-id="891c2-102">
        <see cref="T:System.Windows.FrameworkContentElement" /> 增加了针对下列各项的支持：附加输入 API（包括工具提示和上下文菜单）、演示图板、用于数据绑定的数据上下文、格式支持和逻辑树帮助程序 API。</span>
      <span class="sxs-lookup">
        <span data-stu-id="891c2-102">
          <see cref="T:System.Windows.FrameworkContentElement" /> adds support for additional input APIs (including tooltips and context menus), storyboards, data context for data binding, styles support, and logical tree helper APIs.</span>
      </span>
    </summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="891c2-103"><xref:System.Windows.FrameworkContentElement> 未定义其自己的呈现行为;实例化实际<xref:System.Windows.FrameworkContentElement>在代码或标记中的类实例是可能的但显示在中为 nothing[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]应用程序[!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)]。</span><span class="sxs-lookup"><span data-stu-id="891c2-103"><xref:System.Windows.FrameworkContentElement> does not yet define its own rendering behavior; instantiating an actual <xref:System.Windows.FrameworkContentElement> class instance in code or markup is possible but displays nothing in a [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] application [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)].</span></span> <span data-ttu-id="891c2-104">必须通过执行的类提供呈现逻辑<xref:System.Windows.FrameworkContentElement>子元素作为其内容模型的一部分或位于<xref:System.Windows.FrameworkContentElement>派生的类。</span><span class="sxs-lookup"><span data-stu-id="891c2-104">Rendering logic must be provided by classes that take <xref:System.Windows.FrameworkContentElement> child elements as part of their content model, or in <xref:System.Windows.FrameworkContentElement> derived classes.</span></span>  
  
 <span data-ttu-id="891c2-105"><xref:System.Windows.FrameworkContentElement> 有意与许多相同[!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)]作为<xref:System.Windows.FrameworkElement>。</span><span class="sxs-lookup"><span data-stu-id="891c2-105"><xref:System.Windows.FrameworkContentElement> deliberately parallels many of the same [!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)] as <xref:System.Windows.FrameworkElement>.</span></span> <span data-ttu-id="891c2-106">请注意，某些[!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)]上找到<xref:System.Windows.FrameworkElement>不会<xref:System.Windows.FrameworkContentElement>等效。</span><span class="sxs-lookup"><span data-stu-id="891c2-106">Note that certain [!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)] found on <xref:System.Windows.FrameworkElement> will not have a <xref:System.Windows.FrameworkContentElement> equivalent.</span></span> <span data-ttu-id="891c2-107">多个<xref:System.Windows.FrameworkElement>[!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)]是获取功能，如几何表示形式或布局，其中不相关的<xref:System.Windows.FrameworkContentElement>。</span><span class="sxs-lookup"><span data-stu-id="891c2-107">Several of the <xref:System.Windows.FrameworkElement> [!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)] are for functionality such as geometry representation or layout, which are not relevant for a <xref:System.Windows.FrameworkContentElement>.</span></span>  
  
 <span data-ttu-id="891c2-108">大多数现有<xref:System.Windows.FrameworkContentElement>将在派生的类中找到<xref:System.Windows.Documents>命名空间。</span><span class="sxs-lookup"><span data-stu-id="891c2-108">The majority of existing <xref:System.Windows.FrameworkContentElement> derived classes will be found in the <xref:System.Windows.Documents> namespace.</span></span> <span data-ttu-id="891c2-109">许多这些派生类实现用于流文档模型元素。</span><span class="sxs-lookup"><span data-stu-id="891c2-109">Many of these derived classes implement elements for the flow document model.</span></span> <span data-ttu-id="891c2-110">某些派生的类，如<xref:System.Windows.Documents.Hyperlink>具有一些类似控件的功能，但派生自<xref:System.Windows.FrameworkContentElement>以便类似控件的元素仍可以参与流文档模型。</span><span class="sxs-lookup"><span data-stu-id="891c2-110">Certain derived classes such as <xref:System.Windows.Documents.Hyperlink> have some control-like functionality, but are derived from <xref:System.Windows.FrameworkContentElement> such that the control-like elements can still participate in the flow document model.</span></span>  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.FrameworkElement" />
    <altmember cref="T:System.Windows.ContentElement" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkContentElement ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkContentElement();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="891c2-111">初始化 <see cref="T:System.Windows.FrameworkContentElement" /> 类的新实例。</span>
          <span class="sxs-lookup">
            <span data-stu-id="891c2-111">Initializes a new instance of the <see cref="T:System.Windows.FrameworkContentElement" /> class.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddLogicalChild">
      <MemberSignature Language="C#" Value="protected internal void AddLogicalChild (object child);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance void AddLogicalChild(object child) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.AddLogicalChild(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Sub AddLogicalChild (child As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; void AddLogicalChild(System::Object ^ child);" />
      <MemberSignature Language="F#" Value="member this.AddLogicalChild : obj -&gt; unit" Usage="frameworkContentElement.AddLogicalChild child" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="child" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="child">
          <span data-ttu-id="891c2-112">要添加的子元素。</span>
          <span class="sxs-lookup">
            <span data-stu-id="891c2-112">The child element to be added.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="891c2-113">将提供的元素添加为此元素的子级。</span>
          <span class="sxs-lookup">
            <span data-stu-id="891c2-113">Adds the provided element as a child of this element.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="891c2-114">如果在另一个进程循环访问逻辑树时调用此方法可以引发异常。</span><span class="sxs-lookup"><span data-stu-id="891c2-114">This method can throw an exception if called at a time when the logical tree is being iterated by another process.</span></span>  
  
 <span data-ttu-id="891c2-115">大多数<xref:System.Windows.FrameworkContentElement>派生的类公开的负责包含专用的集合 (例如，<xref:System.Windows.Documents.Span.Inlines%2A>上<xref:System.Windows.Documents.Span>类;<xref:System.Windows.Documents.Section.Blocks%2A>上<xref:System.Windows.Documents.Section>类)。</span><span class="sxs-lookup"><span data-stu-id="891c2-115">Most <xref:System.Windows.FrameworkContentElement> derived classes expose dedicated collections that are responsible for containment (for example, <xref:System.Windows.Documents.Span.Inlines%2A> on the <xref:System.Windows.Documents.Span> class; <xref:System.Windows.Documents.Section.Blocks%2A> on the <xref:System.Windows.Documents.Section> class).</span></span> <span data-ttu-id="891c2-116">通常可以避免无需直接操作逻辑树，改为从这些类派生。</span><span class="sxs-lookup"><span data-stu-id="891c2-116">You can typically avoid any need to manipulate the logical tree directly if you derive from these classes instead.</span></span> <span data-ttu-id="891c2-117">使用为内容元素的逻辑树是一个高级的方案，可能需要专用的分析器或专用<xref:System.Windows.FrameworkElement>，它作为父呈现元素 （内容主机）。</span><span class="sxs-lookup"><span data-stu-id="891c2-117">Working with the logical tree for content elements is an advanced scenario that may require a specialized parser or a specialized <xref:System.Windows.FrameworkElement> that acts as the parent rendering element (content host).</span></span>  
  
 <span data-ttu-id="891c2-118">有关如何使用详细信息<xref:System.Windows.FrameworkContentElement.LogicalChildren%2A>并<xref:System.Windows.FrameworkContentElement.AddLogicalChild%2A>，请参阅[WPF 中的树](~/docs/framework/wpf/advanced/trees-in-wpf.md)。</span><span class="sxs-lookup"><span data-stu-id="891c2-118">For more information about how to use <xref:System.Windows.FrameworkContentElement.LogicalChildren%2A> and <xref:System.Windows.FrameworkContentElement.AddLogicalChild%2A>, see [Trees in WPF](~/docs/framework/wpf/advanced/trees-in-wpf.md).</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkElement.AddLogicalChild(System.Object)" />
        <altmember cref="P:System.Windows.FrameworkContentElement.LogicalChildren" />
        <altmember cref="T:System.Windows.LogicalTreeHelper" />
      </Docs>
    </Member>
    <Member MemberName="BeginInit">
      <MemberSignature Language="C#" Value="public virtual void BeginInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void BeginInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.BeginInit" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub BeginInit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void BeginInit();" />
      <MemberSignature Language="F#" Value="abstract member BeginInit : unit -&gt; unit&#xA;override this.BeginInit : unit -&gt; unit" Usage="frameworkContentElement.BeginInit " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="891c2-119">在初始化元素之前调用。</span>
          <span class="sxs-lookup">
            <span data-stu-id="891c2-119">Called before an element is initialized.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides">
          <para>
            <span data-ttu-id="891c2-120">重写此方法以提供您的元素在元素加载过程中在初始化之前应发生的特殊处理。</span>
            <span class="sxs-lookup">
              <span data-stu-id="891c2-120">Override this method to provide special handling that should occur before your element is initialized during the element loading process.</span>
            </span>
            <span data-ttu-id="891c2-121">您的实现应调用基实现，因为基本 （默认值） 实现设置要跟踪的初始化一些内部标志。</span>
            <span class="sxs-lookup">
              <span data-stu-id="891c2-121">Your implementation should call the base implementation, because the base (default) implementation sets some internal flags to keep track of initialization.</span>
            </span>
            <span data-ttu-id="891c2-122">基实现将引发异常，如果<see cref="M:System.Windows.FrameworkContentElement.BeginInit" />称为不止一次在同一个元素之前到达<see cref="M:System.Windows.FrameworkContentElement.EndInit" />。</span>
            <span class="sxs-lookup">
              <span data-stu-id="891c2-122">The base implementation will throw an exception if <see cref="M:System.Windows.FrameworkContentElement.BeginInit" /> is called more than one time on the same element prior to reaching <see cref="M:System.Windows.FrameworkContentElement.EndInit" />.</span>
            </span>
          </para>
        </block>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginStoryboard">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="891c2-123">开始所提供的演示图板中包含的操作序列。</span>
          <span class="sxs-lookup">
            <span data-stu-id="891c2-123">Begins the sequence of actions that are contained in the provided storyboard.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginStoryboard">
      <MemberSignature Language="C#" Value="public void BeginStoryboard (System.Windows.Media.Animation.Storyboard storyboard);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BeginStoryboard(class System.Windows.Media.Animation.Storyboard storyboard) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BeginStoryboard(System::Windows::Media::Animation::Storyboard ^ storyboard);" />
      <MemberSignature Language="F#" Value="member this.BeginStoryboard : System.Windows.Media.Animation.Storyboard -&gt; unit" Usage="frameworkContentElement.BeginStoryboard storyboard" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="storyboard" Type="System.Windows.Media.Animation.Storyboard" />
      </Parameters>
      <Docs>
        <param name="storyboard">
          <span data-ttu-id="891c2-124">要开始的演示图板。</span>
          <span class="sxs-lookup">
            <span data-stu-id="891c2-124">The storyboard to begin.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="891c2-125">开始所提供的演示图板中包含的操作序列。</span>
          <span class="sxs-lookup">
            <span data-stu-id="891c2-125">Begins the sequence of actions that are contained in the provided storyboard.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="891c2-126">不使用的签名`isControllable`，参数，或指定该参数时`false`，一旦它达到"填充"期删除与该动画关联的时间线时钟。</span><span class="sxs-lookup"><span data-stu-id="891c2-126">For the signatures that do not use the `isControllable`, parameter, or when that parameter is specified `false`, the timeline clocks associated with the animation are removed as soon as it reaches the "Fill" period.</span></span> <span data-ttu-id="891c2-127">因此不能运行一次后重新启动动画。</span><span class="sxs-lookup"><span data-stu-id="891c2-127">Therefore the animation cannot be restarted after being run once.</span></span> <span data-ttu-id="891c2-128">请注意，控制动画还要求情节提要是已命名或在代码中实例的可访问性。</span><span class="sxs-lookup"><span data-stu-id="891c2-128">Note that controlling an animation also requires that the storyboard be named or accessible as an instance in code.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginStoryboard">
      <MemberSignature Language="C#" Value="public void BeginStoryboard (System.Windows.Media.Animation.Storyboard storyboard, System.Windows.Media.Animation.HandoffBehavior handoffBehavior);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BeginStoryboard(class System.Windows.Media.Animation.Storyboard storyboard, valuetype System.Windows.Media.Animation.HandoffBehavior handoffBehavior) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BeginStoryboard(System::Windows::Media::Animation::Storyboard ^ storyboard, System::Windows::Media::Animation::HandoffBehavior handoffBehavior);" />
      <MemberSignature Language="F#" Value="member this.BeginStoryboard : System.Windows.Media.Animation.Storyboard * System.Windows.Media.Animation.HandoffBehavior -&gt; unit" Usage="frameworkContentElement.BeginStoryboard (storyboard, handoffBehavior)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="storyboard" Type="System.Windows.Media.Animation.Storyboard" />
        <Parameter Name="handoffBehavior" Type="System.Windows.Media.Animation.HandoffBehavior" />
      </Parameters>
      <Docs>
        <param name="storyboard">
          <span data-ttu-id="891c2-129">要开始的演示图板。</span>
          <span class="sxs-lookup">
            <span data-stu-id="891c2-129">The storyboard to begin.</span>
          </span>
        </param>
        <param name="handoffBehavior">
          <span data-ttu-id="891c2-130">一个枚举值，该值描述演示图板中描述的属性在经过动画处理后要使用的行为。</span>
          <span class="sxs-lookup">
            <span data-stu-id="891c2-130">A value of the enumeration that describes behavior to use if a property described in the storyboard is already animated.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="891c2-131">开始所提供的演示图板中包含的操作序列，其中指定了在该属性经过动画处理后要发生的行为的选项。</span>
          <span class="sxs-lookup">
            <span data-stu-id="891c2-131">Begins the sequence of actions that are contained in the provided storyboard, with options specified for what should occur if the property is already animated.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="891c2-132">不使用的签名`isControllable`，参数，或指定该参数时`false`，一旦它达到"填充"期删除与该动画关联的时间线时钟。</span><span class="sxs-lookup"><span data-stu-id="891c2-132">For the signatures that do not use the `isControllable`, parameter, or when that parameter is specified `false`, the timeline clocks associated with the animation are removed as soon as it reaches the "Fill" period.</span></span> <span data-ttu-id="891c2-133">因此不能运行一次后重新启动动画。</span><span class="sxs-lookup"><span data-stu-id="891c2-133">Therefore the animation cannot be restarted after being run once.</span></span> <span data-ttu-id="891c2-134">请注意，控制动画还要求情节提要是已命名或在代码中实例的可访问性。</span><span class="sxs-lookup"><span data-stu-id="891c2-134">Note that controlling an animation also requires that the storyboard be named or accessible as an instance in code.</span></span>  
  
## <a name="using-the-compose-handoffbehavior"></a><span data-ttu-id="891c2-135">使用组合 HandoffBehavior</span><span class="sxs-lookup"><span data-stu-id="891c2-135">Using the Compose HandoffBehavior</span></span>  
 <span data-ttu-id="891c2-136">当应用<xref:System.Windows.Media.Animation.Storyboard>， <xref:System.Windows.Media.Animation.AnimationTimeline>，或<xref:System.Windows.Media.Animation.AnimationClock>到通过使用属性<xref:System.Windows.Media.Animation.HandoffBehavior.Compose> <xref:System.Windows.Media.Animation.HandoffBehavior>，则所有<xref:System.Windows.Media.Animation.Clock>之前与该属性相关联的对象继续消耗系统资源时，计时系统将执行不自动删除时钟。</span><span class="sxs-lookup"><span data-stu-id="891c2-136">When you apply a <xref:System.Windows.Media.Animation.Storyboard>, <xref:System.Windows.Media.Animation.AnimationTimeline>, or <xref:System.Windows.Media.Animation.AnimationClock> to a property by using the <xref:System.Windows.Media.Animation.HandoffBehavior.Compose> <xref:System.Windows.Media.Animation.HandoffBehavior>, any <xref:System.Windows.Media.Animation.Clock> objects previously associated with that property continue to consume system resources; the timing system does not remove the clocks automatically.</span></span>  
  
 <span data-ttu-id="891c2-137">若要避免出现性能问题，通过使用应用大量时钟时<xref:System.Windows.Media.Animation.HandoffBehavior.Compose>，它们完成后，您应该从属性的基值删除组合时钟。</span><span class="sxs-lookup"><span data-stu-id="891c2-137">To avoid performance issues when you apply a large number of clocks by using <xref:System.Windows.Media.Animation.HandoffBehavior.Compose>, you should remove composing clocks from the animated property after they complete.</span></span> <span data-ttu-id="891c2-138">有几种方法来移除时钟：</span><span class="sxs-lookup"><span data-stu-id="891c2-138">There are several ways to remove a clock:</span></span>  
  
-   <span data-ttu-id="891c2-139">若要从属性中删除所有时钟，请使用<xref:System.Windows.Media.Animation.Animatable.ApplyAnimationClock%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationClock%29>或<xref:System.Windows.Media.Animation.Animatable.BeginAnimation%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationTimeline%29>经过动画处理的对象的方法。</span><span class="sxs-lookup"><span data-stu-id="891c2-139">To remove all clocks from a property, use the <xref:System.Windows.Media.Animation.Animatable.ApplyAnimationClock%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationClock%29> or <xref:System.Windows.Media.Animation.Animatable.BeginAnimation%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationTimeline%29> method of the animated object.</span></span> <span data-ttu-id="891c2-140">指定要进行动画处理的第一个参数的属性和`null`为第二个。</span><span class="sxs-lookup"><span data-stu-id="891c2-140">Specify the property being animated as the first parameter, and `null` as the second.</span></span> <span data-ttu-id="891c2-141">这将从属性中删除所有的动画时钟。</span><span class="sxs-lookup"><span data-stu-id="891c2-141">This removes all animation clocks from the property.</span></span>  
  
-   <span data-ttu-id="891c2-142">若要删除特定<xref:System.Windows.Media.Animation.AnimationClock>从列表中的时钟，使用<xref:System.Windows.Media.Animation.Clock.Controller%2A>属性<xref:System.Windows.Media.Animation.AnimationClock>检索<xref:System.Windows.Media.Animation.ClockController>，然后调用<xref:System.Windows.Media.Animation.ClockController.Remove%2A>方法<xref:System.Windows.Media.Animation.ClockController>。</span><span class="sxs-lookup"><span data-stu-id="891c2-142">To remove a specific <xref:System.Windows.Media.Animation.AnimationClock> from a list of clocks, use the <xref:System.Windows.Media.Animation.Clock.Controller%2A> property of the <xref:System.Windows.Media.Animation.AnimationClock> to retrieve a <xref:System.Windows.Media.Animation.ClockController>, then call the <xref:System.Windows.Media.Animation.ClockController.Remove%2A> method of the <xref:System.Windows.Media.Animation.ClockController>.</span></span> <span data-ttu-id="891c2-143">这通常是<xref:System.Windows.Media.Animation.Clock.Completed>时钟的事件处理程序。</span><span class="sxs-lookup"><span data-stu-id="891c2-143">This is typically done in the <xref:System.Windows.Media.Animation.Clock.Completed> event handler for a clock.</span></span> <span data-ttu-id="891c2-144">请注意，只有根时钟可以受<xref:System.Windows.Media.Animation.ClockController>;<xref:System.Windows.Media.Animation.Clock.Controller%2A>属性的子时钟返回`null`。</span><span class="sxs-lookup"><span data-stu-id="891c2-144">Note that only root clocks can be controlled by a <xref:System.Windows.Media.Animation.ClockController>; the <xref:System.Windows.Media.Animation.Clock.Controller%2A> property of a child clock returns `null`.</span></span> <span data-ttu-id="891c2-145">另请注意，<xref:System.Windows.Media.Animation.Clock.Completed>如果时钟的有效持续时间将永远不会引发事件。</span><span class="sxs-lookup"><span data-stu-id="891c2-145">Note also that the <xref:System.Windows.Media.Animation.Clock.Completed> event is not raised if the effective duration of the clock is forever.</span></span>  <span data-ttu-id="891c2-146">在这种情况下，用户必须确定何时调用<xref:System.Windows.Media.Animation.ClockController.Remove%2A>。</span><span class="sxs-lookup"><span data-stu-id="891c2-146">In that case, the user must determine when to call <xref:System.Windows.Media.Animation.ClockController.Remove%2A>.</span></span>  
  
 <span data-ttu-id="891c2-147">此动画问题主要出现在生存期较长的对象上。</span><span class="sxs-lookup"><span data-stu-id="891c2-147">This is primarily an issue for animations on objects that have a long lifetime.</span></span>  <span data-ttu-id="891c2-148">垃圾回收对象时，它的时钟也会断开连接和垃圾回收。</span><span class="sxs-lookup"><span data-stu-id="891c2-148">When an object is garbage collected, its clocks are also disconnected and garbage collected.</span></span>  
  
 <span data-ttu-id="891c2-149">有关时钟对象的详细信息，请参阅[动画和计时系统概述](~/docs/framework/wpf/graphics-multimedia/animation-and-timing-system-overview.md)。</span><span class="sxs-lookup"><span data-stu-id="891c2-149">For more information about clock objects, see [Animation and Timing System Overview](~/docs/framework/wpf/graphics-multimedia/animation-and-timing-system-overview.md).</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginStoryboard">
      <MemberSignature Language="C#" Value="public void BeginStoryboard (System.Windows.Media.Animation.Storyboard storyboard, System.Windows.Media.Animation.HandoffBehavior handoffBehavior, bool isControllable);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BeginStoryboard(class System.Windows.Media.Animation.Storyboard storyboard, valuetype System.Windows.Media.Animation.HandoffBehavior handoffBehavior, bool isControllable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BeginStoryboard(System::Windows::Media::Animation::Storyboard ^ storyboard, System::Windows::Media::Animation::HandoffBehavior handoffBehavior, bool isControllable);" />
      <MemberSignature Language="F#" Value="member this.BeginStoryboard : System.Windows.Media.Animation.Storyboard * System.Windows.Media.Animation.HandoffBehavior * bool -&gt; unit" Usage="frameworkContentElement.BeginStoryboard (storyboard, handoffBehavior, isControllable)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="storyboard" Type="System.Windows.Media.Animation.Storyboard" />
        <Parameter Name="handoffBehavior" Type="System.Windows.Media.Animation.HandoffBehavior" />
        <Parameter Name="isControllable" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="storyboard">
          <span data-ttu-id="891c2-150">要开始的演示图板。</span>
          <span class="sxs-lookup">
            <span data-stu-id="891c2-150">The storyboard to begin.</span>
          </span>
        </param>
        <param name="handoffBehavior">
          <span data-ttu-id="891c2-151">一个枚举值，该值描述演示图板中描述的属性在经过动画处理后要使用的行为。</span>
          <span class="sxs-lookup">
            <span data-stu-id="891c2-151">A value of the enumeration that describes behavior to use if a  property described in the storyboard is already animated.</span>
          </span>
        </param>
        <param name="isControllable">
          <span data-ttu-id="891c2-152">声明在动画开始后是否仍可以对它进行控制（可以暂停）。</span>
          <span class="sxs-lookup">
            <span data-stu-id="891c2-152">Declares whether the animation is controllable (can be paused) after it is started.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="891c2-153">开始所提供的演示图板中包含的操作序列，其中指定了在动画开始之后动画控件的状态。</span>
          <span class="sxs-lookup">
            <span data-stu-id="891c2-153">Begins the sequence of actions that are contained in the provided storyboard, with specified state for control of the animation after it is started.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="891c2-154">不使用的签名`isControllable`，参数，或指定该参数时`false`，一旦它达到"填充"期删除与该动画关联的时间线时钟。</span><span class="sxs-lookup"><span data-stu-id="891c2-154">For the signatures that do not use the `isControllable`, parameter, or when that parameter is specified `false`, the timeline clocks associated with the animation are removed as soon as it reaches the "Fill" period.</span></span> <span data-ttu-id="891c2-155">因此不能运行一次后重新启动动画。</span><span class="sxs-lookup"><span data-stu-id="891c2-155">Therefore the animation cannot be restarted after being run once.</span></span> <span data-ttu-id="891c2-156">请注意，控制动画还要求情节提要是已命名或在代码中实例的可访问性。</span><span class="sxs-lookup"><span data-stu-id="891c2-156">Note that controlling an animation also requires that the storyboard be named or accessible as an instance in code.</span></span>  
  
## <a name="using-the-compose-handoffbehavior"></a><span data-ttu-id="891c2-157">使用组合 HandoffBehavior</span><span class="sxs-lookup"><span data-stu-id="891c2-157">Using the Compose HandoffBehavior</span></span>  
 <span data-ttu-id="891c2-158">当应用<xref:System.Windows.Media.Animation.Storyboard>， <xref:System.Windows.Media.Animation.AnimationTimeline>，或<xref:System.Windows.Media.Animation.AnimationClock>到通过使用属性<xref:System.Windows.Media.Animation.HandoffBehavior.Compose> <xref:System.Windows.Media.Animation.HandoffBehavior>，则所有<xref:System.Windows.Media.Animation.Clock>之前与该属性相关联的对象继续消耗系统资源时，计时系统将执行不自动删除这些时钟。</span><span class="sxs-lookup"><span data-stu-id="891c2-158">When you apply a <xref:System.Windows.Media.Animation.Storyboard>, <xref:System.Windows.Media.Animation.AnimationTimeline>, or <xref:System.Windows.Media.Animation.AnimationClock> to a property by using the <xref:System.Windows.Media.Animation.HandoffBehavior.Compose> <xref:System.Windows.Media.Animation.HandoffBehavior>, any <xref:System.Windows.Media.Animation.Clock> objects previously associated with that property continue to consume system resources; the timing system does not remove these clocks automatically.</span></span>  
  
 <span data-ttu-id="891c2-159">若要避免出现性能问题，通过使用应用大量时钟时<xref:System.Windows.Media.Animation.HandoffBehavior.Compose>，它们完成后，您应该从属性的基值删除组合时钟。</span><span class="sxs-lookup"><span data-stu-id="891c2-159">To avoid performance issues when you apply a large number of clocks by using <xref:System.Windows.Media.Animation.HandoffBehavior.Compose>, you should remove composing clocks from the animated property after they complete.</span></span> <span data-ttu-id="891c2-160">有几种方法来移除时钟：</span><span class="sxs-lookup"><span data-stu-id="891c2-160">There are several ways to remove a clock:</span></span>  
  
-   <span data-ttu-id="891c2-161">若要从属性中删除所有时钟，请使用<xref:System.Windows.Media.Animation.Animatable.ApplyAnimationClock%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationClock%29>或<xref:System.Windows.Media.Animation.Animatable.BeginAnimation%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationTimeline%29>经过动画处理的对象的方法。</span><span class="sxs-lookup"><span data-stu-id="891c2-161">To remove all clocks from a property, use the <xref:System.Windows.Media.Animation.Animatable.ApplyAnimationClock%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationClock%29> or <xref:System.Windows.Media.Animation.Animatable.BeginAnimation%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationTimeline%29> method of the animated object.</span></span> <span data-ttu-id="891c2-162">指定要进行动画处理的第一个参数的属性和`null`为第二个。</span><span class="sxs-lookup"><span data-stu-id="891c2-162">Specify the property being animated as the first parameter, and `null` as the second.</span></span> <span data-ttu-id="891c2-163">这将从属性中删除所有的动画时钟。</span><span class="sxs-lookup"><span data-stu-id="891c2-163">This removes all animation clocks from the property.</span></span>  
  
-   <span data-ttu-id="891c2-164">若要删除特定<xref:System.Windows.Media.Animation.AnimationClock>从列表中的时钟，使用<xref:System.Windows.Media.Animation.Clock.Controller%2A>属性<xref:System.Windows.Media.Animation.AnimationClock>检索<xref:System.Windows.Media.Animation.ClockController>，然后调用<xref:System.Windows.Media.Animation.ClockController.Remove%2A>方法<xref:System.Windows.Media.Animation.ClockController>。</span><span class="sxs-lookup"><span data-stu-id="891c2-164">To remove a specific <xref:System.Windows.Media.Animation.AnimationClock> from a list of clocks, use the <xref:System.Windows.Media.Animation.Clock.Controller%2A> property of the <xref:System.Windows.Media.Animation.AnimationClock> to retrieve a <xref:System.Windows.Media.Animation.ClockController>, then call the <xref:System.Windows.Media.Animation.ClockController.Remove%2A> method of the <xref:System.Windows.Media.Animation.ClockController>.</span></span> <span data-ttu-id="891c2-165">这通常是<xref:System.Windows.Media.Animation.Clock.Completed>时钟的事件处理程序。</span><span class="sxs-lookup"><span data-stu-id="891c2-165">This is typically done in the <xref:System.Windows.Media.Animation.Clock.Completed> event handler for a clock.</span></span> <span data-ttu-id="891c2-166">请注意，只有根时钟可以受<xref:System.Windows.Media.Animation.ClockController>;<xref:System.Windows.Media.Animation.Clock.Controller%2A>属性的子时钟返回`null`。</span><span class="sxs-lookup"><span data-stu-id="891c2-166">Note that only root clocks can be controlled by a <xref:System.Windows.Media.Animation.ClockController>; the <xref:System.Windows.Media.Animation.Clock.Controller%2A> property of a child clock returns `null`.</span></span> <span data-ttu-id="891c2-167">另请注意，<xref:System.Windows.Media.Animation.Clock.Completed>如果时钟的有效持续时间将永远不会引发事件。</span><span class="sxs-lookup"><span data-stu-id="891c2-167">Note also that the <xref:System.Windows.Media.Animation.Clock.Completed> event is not raised if the effective duration of the clock is forever.</span></span>  <span data-ttu-id="891c2-168">在这种情况下，用户必须确定何时调用<xref:System.Windows.Media.Animation.ClockController.Remove%2A>。</span><span class="sxs-lookup"><span data-stu-id="891c2-168">In that case, the user must determine when to call <xref:System.Windows.Media.Animation.ClockController.Remove%2A>.</span></span>  
  
 <span data-ttu-id="891c2-169">此动画问题主要出现在生存期较长的对象上。</span><span class="sxs-lookup"><span data-stu-id="891c2-169">This is primarily an issue for animations on objects that have a long lifetime.</span></span>  <span data-ttu-id="891c2-170">垃圾回收对象时，它的时钟也会断开连接和垃圾回收。</span><span class="sxs-lookup"><span data-stu-id="891c2-170">When an object is garbage collected, its clocks are also disconnected and garbage collected.</span></span>  
  
 <span data-ttu-id="891c2-171">有关时钟对象的详细信息，请参阅[动画和计时系统概述](~/docs/framework/wpf/graphics-multimedia/animation-and-timing-system-overview.md)。</span><span class="sxs-lookup"><span data-stu-id="891c2-171">For more information about clock objects, see [Animation and Timing System Overview](~/docs/framework/wpf/graphics-multimedia/animation-and-timing-system-overview.md).</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BindingGroup">
      <MemberSignature Language="C#" Value="public System.Windows.Data.BindingGroup BindingGroup { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Data.BindingGroup BindingGroup" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.BindingGroup" />
      <MemberSignature Language="VB.NET" Value="Public Property BindingGroup As BindingGroup" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Data::BindingGroup ^ BindingGroup { System::Windows::Data::BindingGroup ^ get(); void set(System::Windows::Data::BindingGroup ^ value); };" />
      <MemberSignature Language="F#" Value="member this.BindingGroup : System.Windows.Data.BindingGroup with get, set" Usage="System.Windows.FrameworkContentElement.BindingGroup" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.NeverLocalize)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Data.BindingGroup</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="891c2-172">获取或设置用于该元素的 <see cref="T:System.Windows.Data.BindingGroup" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="891c2-172">Gets or sets the <see cref="T:System.Windows.Data.BindingGroup" /> that is used for the element.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="891c2-173">用于该元素的 <see cref="T:System.Windows.Data.BindingGroup" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="891c2-173">The <see cref="T:System.Windows.Data.BindingGroup" /> that is used for the element.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="891c2-174">一个<xref:System.Windows.Data.BindingGroup>可用于验证对象的多个属性的值。</span><span class="sxs-lookup"><span data-stu-id="891c2-174">A <xref:System.Windows.Data.BindingGroup> can be used to validate the values of multiple properties of an object.</span></span> <span data-ttu-id="891c2-175">例如，假设应用程序提示用户输入地址，然后填充类型的对象`Address`，其中包含属性`Street`， `City`， `ZipCode`，和`Country`，使用值的用户提供。</span><span class="sxs-lookup"><span data-stu-id="891c2-175">For example, suppose that an application prompts the user to enter an address and then populates an object of type `Address`, which has the properties `Street`, `City`, `ZipCode`, and `Country`, with the values that the user provided.</span></span> <span data-ttu-id="891c2-176">应用程序必须包含四个面板<xref:System.Windows.Controls.TextBox>控件，其中每个绑定到对象的属性之一。</span><span class="sxs-lookup"><span data-stu-id="891c2-176">The application has a panel that contains four <xref:System.Windows.Controls.TextBox> controls, each of which is bound to one of the object’s properties.</span></span> <span data-ttu-id="891c2-177">可以使用<xref:System.Windows.Controls.ValidationRule>中<xref:System.Windows.Data.BindingGroup>验证`Address`对象。</span><span class="sxs-lookup"><span data-stu-id="891c2-177">You can use a <xref:System.Windows.Controls.ValidationRule> in a <xref:System.Windows.Data.BindingGroup> to validate the `Address` object.</span></span> <span data-ttu-id="891c2-178">例如，<xref:System.Windows.Controls.ValidationRule>可以确保 zip 代码是有效的国家/地区的地址。</span><span class="sxs-lookup"><span data-stu-id="891c2-178">For example, the <xref:System.Windows.Controls.ValidationRule> can ensure that the zip code is valid for the country of the address.</span></span>  
  
 <span data-ttu-id="891c2-179">子元素继承<xref:System.Windows.Data.BindingGroup>从其父元素，就像使用任何其他可继承属性。</span><span class="sxs-lookup"><span data-stu-id="891c2-179">Child elements inherit the <xref:System.Windows.Data.BindingGroup> from their parent elements, just as with any other inheritable property.</span></span>  
  
<a name="dependencyPropertyInfo_BindingGroup"></a>   
## <a name="dependency-property-information"></a><span data-ttu-id="891c2-180">依赖项属性信息</span><span class="sxs-lookup"><span data-stu-id="891c2-180">Dependency Property Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="891c2-181">标识符字段</span><span class="sxs-lookup"><span data-stu-id="891c2-181">Identifier field</span></span>|<xref:System.Windows.FrameworkContentElement.BindingGroupProperty>|  
|<span data-ttu-id="891c2-182">元数据属性设置为 **，则返回 true**</span><span class="sxs-lookup"><span data-stu-id="891c2-182">Metadata properties set to **true**</span></span>|<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BindingGroupProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty BindingGroupProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty BindingGroupProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.BindingGroupProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly BindingGroupProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ BindingGroupProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable BindingGroupProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkContentElement.BindingGroupProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="891c2-183">标识 <see cref="P:System.Windows.FrameworkContentElement.BindingGroup" /> 依赖属性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="891c2-183">Identifies the <see cref="P:System.Windows.FrameworkContentElement.BindingGroup" /> dependency property.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BringIntoView">
      <MemberSignature Language="C#" Value="public void BringIntoView ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BringIntoView() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.BringIntoView" />
      <MemberSignature Language="VB.NET" Value="Public Sub BringIntoView ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BringIntoView();" />
      <MemberSignature Language="F#" Value="member this.BringIntoView : unit -&gt; unit" Usage="frameworkContentElement.BringIntoView " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="891c2-184">尝试将此元素放入其所在的任何可滚动区域内的视图中。</span>
          <span class="sxs-lookup">
            <span data-stu-id="891c2-184">Attempts to bring this element into view, within any scrollable regions it is contained within.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="891c2-185">通过调用此方法，你有效地将调用<xref:System.Windows.Controls.ScrollContentPresenter.MakeVisible%2A>任何父可滚动区域中包含的元素 (很可能是父<xref:System.Windows.FrameworkElement>，而不<xref:System.Windows.FrameworkContentElement>)。</span><span class="sxs-lookup"><span data-stu-id="891c2-185">By calling this method, you effectively will call <xref:System.Windows.Controls.ScrollContentPresenter.MakeVisible%2A> on any parent scrollable area that contains the element (the parent may very well be a <xref:System.Windows.FrameworkElement>, not a <xref:System.Windows.FrameworkContentElement>).</span></span> <span data-ttu-id="891c2-186">如果此元素不包含在可滚动区域中，仍引发该事件，但不会产生任何影响。</span><span class="sxs-lookup"><span data-stu-id="891c2-186">If this element is not contained in a scrollable area, the event is still raised, but there will be no effect.</span></span>  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/dotnet/netframework-3.5/ms752352(v=vs.90)">
          <span data-ttu-id="891c2-187">如何： 创建 ScrollViewer</span>
          <span class="sxs-lookup">
            <span data-stu-id="891c2-187">How to: Create a ScrollViewer</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="ContextMenu">
      <MemberSignature Language="C#" Value="public System.Windows.Controls.ContextMenu ContextMenu { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Controls.ContextMenu ContextMenu" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.ContextMenu" />
      <MemberSignature Language="VB.NET" Value="Public Property ContextMenu As ContextMenu" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Controls::ContextMenu ^ ContextMenu { System::Windows::Controls::ContextMenu ^ get(); void set(System::Windows::Controls::ContextMenu ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ContextMenu : System.Windows.Controls.ContextMenu with get, set" Usage="System.Windows.FrameworkContentElement.ContextMenu" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.ContextMenu</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="891c2-188">获取或设置每当通过[!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)] 从此元素中请求上下文菜单时应该显示的上下文菜单元素。</span>
          <span class="sxs-lookup">
            <span data-stu-id="891c2-188">Gets or sets the context menu element that should appear whenever the context menu is requested via [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)] from within this element.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="891c2-189">此元素使用的上下文菜单。</span>
          <span class="sxs-lookup">
            <span data-stu-id="891c2-189">The context menu that this element uses.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="dependencyPropertyInfo_ContextMenu"></a>   
## <a name="dependency-property-information"></a><span data-ttu-id="891c2-190">依赖项属性信息</span><span class="sxs-lookup"><span data-stu-id="891c2-190">Dependency Property Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="891c2-191">标识符字段</span><span class="sxs-lookup"><span data-stu-id="891c2-191">Identifier field</span></span>|<xref:System.Windows.FrameworkContentElement.ContextMenuProperty>|  
|<span data-ttu-id="891c2-192">元数据属性设置为 `true`</span><span class="sxs-lookup"><span data-stu-id="891c2-192">Metadata properties set to `true`</span></span>|<span data-ttu-id="891c2-193">无</span><span class="sxs-lookup"><span data-stu-id="891c2-193">None</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="891c2-194">以下示例中位置<xref:System.Windows.Controls.ContextMenu>上<xref:System.Windows.Documents.Paragraph>。</span><span class="sxs-lookup"><span data-stu-id="891c2-194">The following example places a <xref:System.Windows.Controls.ContextMenu> on a <xref:System.Windows.Documents.Paragraph>.</span></span>  
  
 [!code-xaml[ContentElementsSmorgasbord#ContextMenu](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml#contextmenu)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.ContextMenu" />
        <altmember cref="T:System.Windows.Controls.ContextMenuService" />
      </Docs>
    </Member>
    <Member MemberName="ContextMenuClosing">
      <MemberSignature Language="C#" Value="public event System.Windows.Controls.ContextMenuEventHandler ContextMenuClosing;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Controls.ContextMenuEventHandler ContextMenuClosing" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkContentElement.ContextMenuClosing" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ContextMenuClosing As ContextMenuEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Controls::ContextMenuEventHandler ^ ContextMenuClosing;" />
      <MemberSignature Language="F#" Value="member this.ContextMenuClosing : System.Windows.Controls.ContextMenuEventHandler " Usage="member this.ContextMenuClosing : System.Windows.Controls.ContextMenuEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.ContextMenuEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="891c2-195">在元素上的任何上下文菜单关闭之前发生。</span>
          <span class="sxs-lookup">
            <span data-stu-id="891c2-195">Occurs just before any context menu on the element is closed.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="891c2-196">若要取消关闭上下文菜单，该事件的处理程序应将其标记为已处理。</span><span class="sxs-lookup"><span data-stu-id="891c2-196">To suppress closing context menus, handlers of the event should mark it as handled.</span></span>  
  
 <span data-ttu-id="891c2-197">若要将此事件用作<xref:System.Windows.EventTrigger>在样式中，必须引用基础服务的事件标识符：</span><span class="sxs-lookup"><span data-stu-id="891c2-197">To use this event as an <xref:System.Windows.EventTrigger> in a style, you must reference the underlying service event identifier:</span></span>  
  
 [!code-xaml[CorePseudocode#FEContextMenuClosing](~/samples/snippets/csharp/VS_Snippets_Wpf/CorePseudocode/CSharp/pseudocode.xaml#fecontextmenuclosing)]  
  
 <span data-ttu-id="891c2-198">(这种用法是必需的因为上的事件实现<xref:System.Windows.FrameworkContentElement>，公开基础的服务事件未正确映射<xref:System.Windows.FrameworkContentElement.ContextMenuClosing>在触发器中使用的标识符)。</span><span class="sxs-lookup"><span data-stu-id="891c2-198">(This usage is required because the event implementation on <xref:System.Windows.FrameworkContentElement> that exposes the underlying service event does not correctly map the <xref:System.Windows.FrameworkContentElement.ContextMenuClosing> identifier for use in triggers).</span></span>  
  
<a name="routedEventInfo_ContextMenuClosing"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="891c2-199">路由事件信息</span><span class="sxs-lookup"><span data-stu-id="891c2-199">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="891c2-200">标识符字段</span><span class="sxs-lookup"><span data-stu-id="891c2-200">Identifier field</span></span>|<xref:System.Windows.FrameworkContentElement.ContextMenuClosingEvent>|  
|<span data-ttu-id="891c2-201">路由策略</span><span class="sxs-lookup"><span data-stu-id="891c2-201">Routing strategy</span></span>|<span data-ttu-id="891c2-202">浮升</span><span class="sxs-lookup"><span data-stu-id="891c2-202">Bubbling</span></span>|  
|<span data-ttu-id="891c2-203">Delegate</span><span class="sxs-lookup"><span data-stu-id="891c2-203">Delegate</span></span>|<xref:System.Windows.Controls.ContextMenuEventHandler>|  
  
   
  
## Examples  
 <span data-ttu-id="891c2-204">下面的示例实现的处理程序上的命名区域更改光标`DisplayArea`（未显示）。</span><span class="sxs-lookup"><span data-stu-id="891c2-204">The following example implements a handler that changes the cursor over a named region `DisplayArea` (not shown).</span></span> <span data-ttu-id="891c2-205">注释暗示<xref:System.Windows.UIElement>使用情况，实际上，此示例将是相同，但如果`DisplayArea`了<xref:System.Windows.FrameworkContentElement>。</span><span class="sxs-lookup"><span data-stu-id="891c2-205">The comment hints at a <xref:System.Windows.UIElement> usage, but in fact this sample would be identical if `DisplayArea` were a <xref:System.Windows.FrameworkContentElement>.</span></span>  
  
 [!code-csharp[cursors#ChangeCursorsSample](~/samples/snippets/csharp/VS_Snippets_Wpf/cursors/CSharp/Window1.xaml.cs#changecursorssample)]
 [!code-vb[cursors#ChangeCursorsSample](~/samples/snippets/visualbasic/VS_Snippets_Wpf/cursors/VisualBasic/Window1.xaml.vb#changecursorssample)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.ContextMenuService" />
      </Docs>
    </Member>
    <Member MemberName="ContextMenuClosingEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent ContextMenuClosingEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent ContextMenuClosingEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.ContextMenuClosingEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ContextMenuClosingEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ ContextMenuClosingEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable ContextMenuClosingEvent : System.Windows.RoutedEvent" Usage="System.Windows.FrameworkContentElement.ContextMenuClosingEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="891c2-206">标识 <see cref="E:System.Windows.FrameworkContentElement.ContextMenuClosing" /> [路由事件概述](~/docs/framework/wpf/advanced/routed-events-overview.md)。</span>
          <span class="sxs-lookup">
            <span data-stu-id="891c2-206">Identifies the <see cref="E:System.Windows.FrameworkContentElement.ContextMenuClosing" /> [Routed Events Overview](~/docs/framework/wpf/advanced/routed-events-overview.md).</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="891c2-207">在注册路由的事件时创建事件标识符对象 (请参阅<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>)，用于添加类处理程序 (请参阅<xref:System.Windows.EventManager.RegisterClassHandler%2A>)。</span><span class="sxs-lookup"><span data-stu-id="891c2-207">Event identifier objects are created when routed events are registered (see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>) and can then be used to add class handlers (see <xref:System.Windows.EventManager.RegisterClassHandler%2A>).</span></span> <span data-ttu-id="891c2-208">标识符对象包含标识名称、 所有者类型、 处理程序类型、 路由策略和用于添加事件所有者的实用工具方法。</span><span class="sxs-lookup"><span data-stu-id="891c2-208">Identifier objects contain an identifying name, owner type, handler type, routing strategy, and a utility method for adding owners for the event.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContextMenuOpening">
      <MemberSignature Language="C#" Value="public event System.Windows.Controls.ContextMenuEventHandler ContextMenuOpening;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Controls.ContextMenuEventHandler ContextMenuOpening" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkContentElement.ContextMenuOpening" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ContextMenuOpening As ContextMenuEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Controls::ContextMenuEventHandler ^ ContextMenuOpening;" />
      <MemberSignature Language="F#" Value="member this.ContextMenuOpening : System.Windows.Controls.ContextMenuEventHandler " Usage="member this.ContextMenuOpening : System.Windows.Controls.ContextMenuEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.ContextMenuEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="891c2-209">在元素上的任何上下文菜单打开时发生。</span>
          <span class="sxs-lookup">
            <span data-stu-id="891c2-209">Occurs when any context menu on the element is opened.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="891c2-210">若要手动打开上下文菜单，事件的处理程序应将相关的事件标记为已处理。</span><span class="sxs-lookup"><span data-stu-id="891c2-210">To manually open context menus, handlers of the events should mark the relevant event as handled.</span></span> <span data-ttu-id="891c2-211">否则为现有值<xref:System.Windows.FrameworkContentElement.ContextMenu%2A>属性将用于自动打开上下文菜单。</span><span class="sxs-lookup"><span data-stu-id="891c2-211">Otherwise, the existing value of the <xref:System.Windows.FrameworkContentElement.ContextMenu%2A> property will be used to automatically open a context menu.</span></span> <span data-ttu-id="891c2-212">将标记处理的事件将有效地取消默认操作，并且可重置的值的机会<xref:System.Windows.FrameworkContentElement.ContextMenu%2A>属性，然后打开新<xref:System.Windows.Controls.ContextMenu>。</span><span class="sxs-lookup"><span data-stu-id="891c2-212">Marking the event handled will effectively cancel the default action, and could be an opportunity to reset the value of the <xref:System.Windows.FrameworkContentElement.ContextMenu%2A> property and then open the new <xref:System.Windows.Controls.ContextMenu>.</span></span> <span data-ttu-id="891c2-213">但是，是应注意的计时问题。</span><span class="sxs-lookup"><span data-stu-id="891c2-213">However, there is a timing issue you should be aware of.</span></span> <span data-ttu-id="891c2-214">若要完全替换通过上下文菜单<xref:System.Windows.FrameworkContentElement.ContextMenuOpening>处理程序中，初始上下文菜单不能为 null / 空。</span><span class="sxs-lookup"><span data-stu-id="891c2-214">In order to completely replace the context menu through a <xref:System.Windows.FrameworkContentElement.ContextMenuOpening> handler, the initial context menu must not be null / empty.</span></span> <span data-ttu-id="891c2-215">或者，您可能需要处理的事件，然后手动打开新的上下文菜单。</span><span class="sxs-lookup"><span data-stu-id="891c2-215">Alternatively, you might need to handle the event and then manually open a new context menu.</span></span> <span data-ttu-id="891c2-216">有关详细信息，请参阅[如何： 处理 ContextMenuOpening 事件](~/docs/framework/wpf/advanced/how-to-handle-the-contextmenuopening-event.md)。</span><span class="sxs-lookup"><span data-stu-id="891c2-216">For details, see [How to: Handle the ContextMenuOpening Event](~/docs/framework/wpf/advanced/how-to-handle-the-contextmenuopening-event.md).</span></span>  
  
 <span data-ttu-id="891c2-217">若要将此事件用作<xref:System.Windows.EventTrigger>在样式中，必须引用基础服务的事件标识符：</span><span class="sxs-lookup"><span data-stu-id="891c2-217">To use this event as an <xref:System.Windows.EventTrigger> in a style, you must reference the underlying service event identifier:</span></span>  
  
 [!code-xaml[CorePseudocode#FEContextMenuOpening](~/samples/snippets/csharp/VS_Snippets_Wpf/CorePseudocode/CSharp/pseudocode.xaml#fecontextmenuopening)]  
  
 <span data-ttu-id="891c2-218">(这种用法是必需的因为上的事件实现<xref:System.Windows.FrameworkContentElement>，公开基础的服务事件未正确映射<xref:System.Windows.FrameworkContentElement.ContextMenuOpening>在触发器中使用的标识符)。</span><span class="sxs-lookup"><span data-stu-id="891c2-218">(This usage is required because the event implementation on <xref:System.Windows.FrameworkContentElement> that exposes the underlying service event does not correctly map the <xref:System.Windows.FrameworkContentElement.ContextMenuOpening> identifier for use in triggers).</span></span>  
  
<a name="routedEventInfo_ContextMenuOpening"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="891c2-219">路由事件信息</span><span class="sxs-lookup"><span data-stu-id="891c2-219">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="891c2-220">标识符字段</span><span class="sxs-lookup"><span data-stu-id="891c2-220">Identifier field</span></span>|<xref:System.Windows.FrameworkContentElement.ContextMenuOpeningEvent>|  
|<span data-ttu-id="891c2-221">路由策略</span><span class="sxs-lookup"><span data-stu-id="891c2-221">Routing strategy</span></span>|<span data-ttu-id="891c2-222">浮升</span><span class="sxs-lookup"><span data-stu-id="891c2-222">Bubbling</span></span>|  
|<span data-ttu-id="891c2-223">Delegate</span><span class="sxs-lookup"><span data-stu-id="891c2-223">Delegate</span></span>|<xref:System.Windows.Controls.ContextMenuEventHandler>|  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.ContextMenuService" />
        <altmember cref="T:System.Windows.Controls.ContextMenu" />
      </Docs>
    </Member>
    <Member MemberName="ContextMenuOpeningEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent ContextMenuOpeningEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent ContextMenuOpeningEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.ContextMenuOpeningEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ContextMenuOpeningEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ ContextMenuOpeningEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable ContextMenuOpeningEvent : System.Windows.RoutedEvent" Usage="System.Windows.FrameworkContentElement.ContextMenuOpeningEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="891c2-224">标识 <see cref="E:System.Windows.FrameworkContentElement.ContextMenuOpening" /> [路由事件概述](~/docs/framework/wpf/advanced/routed-events-overview.md)。</span>
          <span class="sxs-lookup">
            <span data-stu-id="891c2-224">Identifies the <see cref="E:System.Windows.FrameworkContentElement.ContextMenuOpening" /> [Routed Events Overview](~/docs/framework/wpf/advanced/routed-events-overview.md).</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="891c2-225">在注册路由的事件时创建事件标识符对象 (请参阅<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>)，用于添加类处理程序 (请参阅<xref:System.Windows.EventManager.RegisterClassHandler%2A>)。</span><span class="sxs-lookup"><span data-stu-id="891c2-225">Event identifier objects are created when routed events are registered (see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>) and can then be used to add class handlers (see <xref:System.Windows.EventManager.RegisterClassHandler%2A>).</span></span> <span data-ttu-id="891c2-226">标识符对象包含标识名称、 所有者类型、 处理程序类型、 路由策略和用于添加事件所有者的实用工具方法。</span><span class="sxs-lookup"><span data-stu-id="891c2-226">Identifier objects contain an identifying name, owner type, handler type, routing strategy, and a utility method for adding owners for the event.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContextMenuProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ContextMenuProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ContextMenuProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.ContextMenuProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ContextMenuProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ContextMenuProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable ContextMenuProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkContentElement.ContextMenuProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="891c2-227">标识 <see cref="P:System.Windows.FrameworkContentElement.ContextMenu" /> 依赖属性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="891c2-227">Identifies the <see cref="P:System.Windows.FrameworkContentElement.ContextMenu" /> dependency property.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Cursor">
      <MemberSignature Language="C#" Value="public System.Windows.Input.Cursor Cursor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Input.Cursor Cursor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.Cursor" />
      <MemberSignature Language="VB.NET" Value="Public Property Cursor As Cursor" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Input::Cursor ^ Cursor { System::Windows::Input::Cursor ^ get(); void set(System::Windows::Input::Cursor ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Cursor : System.Windows.Input.Cursor with get, set" Usage="System.Windows.FrameworkContentElement.Cursor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.Cursor</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="891c2-228">获取或设置在鼠标指针位于此元素上时显示的光标。</span>
          <span class="sxs-lookup">
            <span data-stu-id="891c2-228">Gets or sets the cursor that displays when the mouse pointer is over this element.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="891c2-229">要显示的光标。</span>
          <span class="sxs-lookup">
            <span data-stu-id="891c2-229">The cursor to display.</span>
          </span>
          <span data-ttu-id="891c2-230">按此依赖属性，默认值定义为 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="891c2-230">The default value is defined as <see langword="null" /> per this dependency property.</span>
          </span>
          <span data-ttu-id="891c2-231">但是，运行时的实际默认值将受到多种因素的影响。</span>
          <span class="sxs-lookup">
            <span data-stu-id="891c2-231">However, the practical default at run time will come from a variety of factors.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="891c2-232">设置此属性时[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]，则[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]处理器将依赖类型转换为<xref:System.Windows.Input.Cursor>类来计算该字符串。</span><span class="sxs-lookup"><span data-stu-id="891c2-232">When setting this property in [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)], the [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] processor relies on type conversion for the <xref:System.Windows.Input.Cursor> class to evaluate the string.</span></span> <span data-ttu-id="891c2-233">所提供的字符串的计算结果应为<xref:System.Windows.Input.CursorType>值。</span><span class="sxs-lookup"><span data-stu-id="891c2-233">The provided string should evaluate to a <xref:System.Windows.Input.CursorType> value.</span></span> <span data-ttu-id="891c2-234">有关详细信息，请参阅<xref:System.Windows.Input.Cursor>。</span><span class="sxs-lookup"><span data-stu-id="891c2-234">See <xref:System.Windows.Input.Cursor> for details.</span></span>  
  
 <span data-ttu-id="891c2-235">此属性所建立的光标将还是将不会显示在鼠标指针位于此元素上时也是依赖于的值<xref:System.Windows.FrameworkContentElement.ForceCursor%2A>属性。</span><span class="sxs-lookup"><span data-stu-id="891c2-235">Whether the cursor as established by this property will or will not display when the mouse pointer is over this element is also dependent on the value of the <xref:System.Windows.FrameworkContentElement.ForceCursor%2A> property.</span></span> <span data-ttu-id="891c2-236">此外，与事件相关的注意事项，如活动拖动、 鼠标捕获、 文本编辑模式中控件和等等，还将影响游标，并且其优先级高于此属性中指定的值。</span><span class="sxs-lookup"><span data-stu-id="891c2-236">Also, event-related considerations such as an active drag, mouse capture, text editing modes within controls, and so on, will also affect the cursor with higher priority than the value you specify in this property.</span></span>  
  
 <span data-ttu-id="891c2-237">若要还原的此属性设置为最终的默认行为，请将其设置为`null`试。</span><span class="sxs-lookup"><span data-stu-id="891c2-237">To revert the behavior of setting this property to the eventual default, set it to `null` again.</span></span>  
  
 <span data-ttu-id="891c2-238">`null`默认值实际上意味着确定实际游标值的此处延迟，并且应从其他位置获取。</span><span class="sxs-lookup"><span data-stu-id="891c2-238">The `null` default really means that determination of the practical cursor value is deferred here and should be obtained from elsewhere.</span></span> <span data-ttu-id="891c2-239">如果不存在以编程方式值来自任何源默认游标通过[!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)]应用程序将是一个箭头。</span><span class="sxs-lookup"><span data-stu-id="891c2-239">If presented with no programmatic values from any source, the default cursor over a [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] application will be an arrow.</span></span>  
  
 <span data-ttu-id="891c2-240">每个移动的鼠标悬停[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]应用程序将引发<xref:System.Windows.ContentElement.QueryCursor>事件。</span><span class="sxs-lookup"><span data-stu-id="891c2-240">Each movement of the mouse over a [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] application raises a <xref:System.Windows.ContentElement.QueryCursor> event.</span></span> <span data-ttu-id="891c2-241">该事件冒泡，并且路由中的任何元素都有机会处理事件并设置游标通过此事件的参数的值。</span><span class="sxs-lookup"><span data-stu-id="891c2-241">The event bubbles, and any element along the route has the opportunity to handle the event and to set the value of the cursor via the arguments of this event.</span></span> <span data-ttu-id="891c2-242">如果发生这种情况，则表明事件进行处理，并且 in 实参具有一个更改的值将优先于的值<xref:System.Windows.FrameworkContentElement.Cursor%2A>属性在任何级别，除非<xref:System.Windows.FrameworkContentElement.ForceCursor%2A>设置。</span><span class="sxs-lookup"><span data-stu-id="891c2-242">If that happens, the fact that the event is handled and has a changed value in the arguments takes precedence over the value of the <xref:System.Windows.FrameworkContentElement.Cursor%2A> property at any level, unless <xref:System.Windows.FrameworkContentElement.ForceCursor%2A> is set.</span></span>  
  
 <span data-ttu-id="891c2-243">如果不创建自定义光标，通常您将此属性设置的静态属性值<xref:System.Windows.Input.Cursors>类。</span><span class="sxs-lookup"><span data-stu-id="891c2-243">If not creating a custom cursor, typically you set this property to a static property value of the <xref:System.Windows.Input.Cursors> class.</span></span>  
  
 <span data-ttu-id="891c2-244">设置<xref:System.Windows.Input.Cursor>在部分信任环境中未启用为自定义值。</span><span class="sxs-lookup"><span data-stu-id="891c2-244">Setting the <xref:System.Windows.Input.Cursor> to a custom value is not enabled in partial trust.</span></span> <span data-ttu-id="891c2-245">自定义光标的详细信息，请参阅[输入概述](~/docs/framework/wpf/advanced/input-overview.md)。</span><span class="sxs-lookup"><span data-stu-id="891c2-245">For more information on custom cursors, see [Input Overview](~/docs/framework/wpf/advanced/input-overview.md).</span></span>  
  
<a name="dependencyPropertyInfo_Cursor"></a>   
## <a name="dependency-property-information"></a><span data-ttu-id="891c2-246">依赖项属性信息</span><span class="sxs-lookup"><span data-stu-id="891c2-246">Dependency Property Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="891c2-247">标识符字段</span><span class="sxs-lookup"><span data-stu-id="891c2-247">Identifier field</span></span>|<xref:System.Windows.FrameworkContentElement.CursorProperty>|  
|<span data-ttu-id="891c2-248">元数据属性设置为 `true`</span><span class="sxs-lookup"><span data-stu-id="891c2-248">Metadata properties set to `true`</span></span>|<span data-ttu-id="891c2-249">无</span><span class="sxs-lookup"><span data-stu-id="891c2-249">None</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="891c2-250">下面的示例将光标设置为自定义值。</span><span class="sxs-lookup"><span data-stu-id="891c2-250">The following example sets the cursor to a custom value.</span></span>  
  
 [!code-csharp[cursors#ChangeCursorsSample](~/samples/snippets/csharp/VS_Snippets_Wpf/cursors/CSharp/Window1.xaml.cs#changecursorssample)]
 [!code-vb[cursors#ChangeCursorsSample](~/samples/snippets/visualbasic/VS_Snippets_Wpf/cursors/VisualBasic/Window1.xaml.vb#changecursorssample)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.QueryCursor" />
        <altmember cref="P:System.Windows.FrameworkContentElement.ForceCursor" />
        <altmember cref="P:System.Windows.Input.Mouse.OverrideCursor" />
      </Docs>
    </Member>
    <Member MemberName="CursorProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty CursorProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty CursorProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.CursorProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly CursorProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ CursorProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable CursorProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkContentElement.CursorProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="891c2-251">标识 <see cref="P:System.Windows.FrameworkContentElement.Cursor" /> 依赖属性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="891c2-251">Identifies the <see cref="P:System.Windows.FrameworkContentElement.Cursor" /> dependency property.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DataContext">
      <MemberSignature Language="C#" Value="public object DataContext { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object DataContext" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.DataContext" />
      <MemberSignature Language="VB.NET" Value="Public Property DataContext As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ DataContext { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.DataContext : obj with get, set" Usage="System.Windows.FrameworkContentElement.DataContext" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.NeverLocalize)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="891c2-252">获取或设置元素在参与数据绑定时的数据上下文。</span>
          <span class="sxs-lookup">
            <span data-stu-id="891c2-252">Gets or sets the data context for an element when it participates in data binding.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="891c2-253">要用作数据上下文的对象。</span>
          <span class="sxs-lookup">
            <span data-stu-id="891c2-253">The object to use as data context.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="891c2-254">*数据上下文*是允许将信息从其父元素继承有关用于绑定，以及其他特征等路径的绑定的绑定源元素的概念。</span><span class="sxs-lookup"><span data-stu-id="891c2-254">*Data context* is a concept that allows elements to inherit information from their parent elements about the binding source that is used for binding, as well as other characteristics of the binding such as the path.</span></span>  
  
 <span data-ttu-id="891c2-255">可以直接设置数据上下文[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]对象，并且将绑定到该对象的属性计算。</span><span class="sxs-lookup"><span data-stu-id="891c2-255">Data context can be set directly to a [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] object, with the bindings evaluating to properties of that object.</span></span> <span data-ttu-id="891c2-256">或者，可以将数据上下文设置为<xref:System.Windows.Data.DataSourceProvider>对象。</span><span class="sxs-lookup"><span data-stu-id="891c2-256">Alternatively, you can set the data context to a <xref:System.Windows.Data.DataSourceProvider> object.</span></span>  
  
 <span data-ttu-id="891c2-257">此依赖属性继承属性值。</span><span class="sxs-lookup"><span data-stu-id="891c2-257">This dependency property inherits property values.</span></span> <span data-ttu-id="891c2-258">如果没有与任何其他值的子元素<xref:System.Windows.FrameworkContentElement.DataContext%2A>建立通过本地值或样式，属性系统将设置此值为<xref:System.Windows.FrameworkContentElement.DataContext%2A>分配有此值最接近的父元素的值。</span><span class="sxs-lookup"><span data-stu-id="891c2-258">If there are child elements with no other value for <xref:System.Windows.FrameworkContentElement.DataContext%2A> established through local values or styles, the property system will set the value to be the <xref:System.Windows.FrameworkContentElement.DataContext%2A> value of the nearest parent element with this value assigned.</span></span>  
  
 <span data-ttu-id="891c2-259">或者，可以使用以下属性之一<xref:System.Windows.Data.Binding>类来显式指定绑定源： <xref:System.Windows.Data.Binding.ElementName%2A>， <xref:System.Windows.Data.Binding.Source%2A>，或<xref:System.Windows.Data.Binding.RelativeSource%2A>。</span><span class="sxs-lookup"><span data-stu-id="891c2-259">Alternatively, you can use one of the following properties of the <xref:System.Windows.Data.Binding> class to specify the binding source explicitly: <xref:System.Windows.Data.Binding.ElementName%2A>, <xref:System.Windows.Data.Binding.Source%2A>, or <xref:System.Windows.Data.Binding.RelativeSource%2A>.</span></span> <span data-ttu-id="891c2-260">有关详细信息，请参阅[如何： 指定绑定源](~/docs/framework/wpf/data/how-to-specify-the-binding-source.md)。</span><span class="sxs-lookup"><span data-stu-id="891c2-260">For more information, see [How to: Specify the Binding Source](~/docs/framework/wpf/data/how-to-specify-the-binding-source.md).</span></span>  
  
 <span data-ttu-id="891c2-261">在中[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]，<xref:System.Windows.FrameworkContentElement.DataContext%2A>通常设置为<xref:System.Windows.Data.Binding>声明。</span><span class="sxs-lookup"><span data-stu-id="891c2-261">In [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)], <xref:System.Windows.FrameworkContentElement.DataContext%2A> is most commonly set to as a <xref:System.Windows.Data.Binding> declaration.</span></span> <span data-ttu-id="891c2-262">您可以使用属性元素语法或特性语法。</span><span class="sxs-lookup"><span data-stu-id="891c2-262">You can use either property element syntax or attribute syntax.</span></span> <span data-ttu-id="891c2-263">特性语法在此页上的示例所示。</span><span class="sxs-lookup"><span data-stu-id="891c2-263">Attribute syntax is shown in the example on this page.</span></span> <span data-ttu-id="891c2-264">您还可以设置<xref:System.Windows.FrameworkContentElement.DataContext%2A>在代码中。</span><span class="sxs-lookup"><span data-stu-id="891c2-264">You can also set <xref:System.Windows.FrameworkContentElement.DataContext%2A> in code.</span></span>  
  
<a name="xamlPropertyElementUsage_DataContext"></a>   
## <a name="xaml-property-element-usage"></a><span data-ttu-id="891c2-265">XAML 属性元素用法</span><span class="sxs-lookup"><span data-stu-id="891c2-265">XAML Property Element Usage</span></span>  
  
```  
<object>  
  <object.DataContext>  
    <dataContextObject />  
  </object.DataContext>  
</object>  
```  
  
<a name="xamlAttributeUsage_DataContext"></a>   
## <a name="xaml-attribute-usage"></a><span data-ttu-id="891c2-266">XAML 属性用法</span><span class="sxs-lookup"><span data-stu-id="891c2-266">XAML Attribute Usage</span></span>  
  
```  
<object DataContext="bindingUsage"/>  
- or -  
<object DataContext="{resourceExtension contextResourceKey}"/>  
```  
  
<a name="xamlValues_DataContext"></a>   
## <a name="xaml-values"></a><span data-ttu-id="891c2-267">XAML 值</span><span class="sxs-lookup"><span data-stu-id="891c2-267">XAML Values</span></span>  
 <span data-ttu-id="891c2-268">*dataContextObject*</span><span class="sxs-lookup"><span data-stu-id="891c2-268">*dataContextObject*</span></span>  
 <span data-ttu-id="891c2-269">作为父元素中的任何绑定的数据上下文直接嵌入的对象。</span><span class="sxs-lookup"><span data-stu-id="891c2-269">A directly embedded object that serves as data context for any bindings within the parent element.</span></span> <span data-ttu-id="891c2-270">通常情况下，此对象是<xref:System.Windows.Data.Binding>或另一个<xref:System.Windows.Data.BindingBase>子类。</span><span class="sxs-lookup"><span data-stu-id="891c2-270">Typically, this object is a <xref:System.Windows.Data.Binding> or another <xref:System.Windows.Data.BindingBase> subclass.</span></span> <span data-ttu-id="891c2-271">或者，原始数据的任何[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]对象类型的目标的绑定可能会放在此处，定义更高版本的实际绑定。</span><span class="sxs-lookup"><span data-stu-id="891c2-271">Alternatively, raw data of any [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] object type intended for binding may be placed here, with the actual bindings defined later.</span></span>  
  
 <span data-ttu-id="891c2-272">*bindingUsage*</span><span class="sxs-lookup"><span data-stu-id="891c2-272">*bindingUsage*</span></span>  
 <span data-ttu-id="891c2-273">计算结果为相应的数据上下文绑定使用情况。</span><span class="sxs-lookup"><span data-stu-id="891c2-273">A binding usage that evaluates to an appropriate data context.</span></span> <span data-ttu-id="891c2-274">有关详细信息，请参阅 [Binding 标记扩展](~/docs/framework/wpf/advanced/binding-markup-extension.md)。</span><span class="sxs-lookup"><span data-stu-id="891c2-274">For details, see [Binding Markup Extension](~/docs/framework/wpf/advanced/binding-markup-extension.md).</span></span>  
  
 <span data-ttu-id="891c2-275">*resourceExtension*</span><span class="sxs-lookup"><span data-stu-id="891c2-275">*resourceExtension*</span></span>  
 <span data-ttu-id="891c2-276">以下项之一： `StaticResource`，或`DynamicResource`。</span><span class="sxs-lookup"><span data-stu-id="891c2-276">One of the following: `StaticResource`, or `DynamicResource`.</span></span> <span data-ttu-id="891c2-277">引用定义为资源中的对象的原始数据时，使用这种用法。</span><span class="sxs-lookup"><span data-stu-id="891c2-277">This usage is used when referring to raw data defined as an object in resources.</span></span> <span data-ttu-id="891c2-278">请参阅[XAML 资源](~/docs/framework/wpf/advanced/xaml-resources.md)。</span><span class="sxs-lookup"><span data-stu-id="891c2-278">See [XAML Resources](~/docs/framework/wpf/advanced/xaml-resources.md).</span></span>  
  
 <span data-ttu-id="891c2-279">*contextResourceKey*</span><span class="sxs-lookup"><span data-stu-id="891c2-279">*contextResourceKey*</span></span>  
 <span data-ttu-id="891c2-280">正在请求中的对象的密钥标识符<xref:System.Windows.ResourceDictionary>。</span><span class="sxs-lookup"><span data-stu-id="891c2-280">The key identifier for the object being requested from within a <xref:System.Windows.ResourceDictionary>.</span></span>  
  
<a name="dependencyPropertyInfo_DataContext"></a>   
## <a name="dependency-property-information"></a><span data-ttu-id="891c2-281">依赖项属性信息</span><span class="sxs-lookup"><span data-stu-id="891c2-281">Dependency Property Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="891c2-282">标识符字段</span><span class="sxs-lookup"><span data-stu-id="891c2-282">Identifier field</span></span>|<xref:System.Windows.FrameworkContentElement.DataContextProperty>|  
|<span data-ttu-id="891c2-283">元数据属性设置为 `true`</span><span class="sxs-lookup"><span data-stu-id="891c2-283">Metadata properties set to `true`</span></span>|<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
   
  
## Examples  
 <span data-ttu-id="891c2-284">下面的示例上设置的绑定<xref:System.Windows.Documents.Paragraph>元素中，通过创建新的自定义数据对象，该对象作为建立<xref:System.Windows.FrameworkContentElement.DataContext%2A>，并将绑定路径设置为在其中一个属性。</span><span class="sxs-lookup"><span data-stu-id="891c2-284">The following example sets a binding on a <xref:System.Windows.Documents.Paragraph> element, by creating a new custom data object, establishing that object as <xref:System.Windows.FrameworkContentElement.DataContext%2A>, and setting the binding path to a property within it.</span></span>  
  
 [!code-csharp[ContentElementsSmorgasbord#DataContext](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml.cs#datacontext)]
 [!code-vb[ContentElementsSmorgasbord#DataContext](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContentElementsSmorgasbord/visualbasic/page1.xaml.vb#datacontext)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DataContextChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.DependencyPropertyChangedEventHandler DataContextChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DependencyPropertyChangedEventHandler DataContextChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkContentElement.DataContextChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DataContextChanged As DependencyPropertyChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DependencyPropertyChangedEventHandler ^ DataContextChanged;" />
      <MemberSignature Language="F#" Value="member this.DataContextChanged : System.Windows.DependencyPropertyChangedEventHandler " Usage="member this.DataContextChanged : System.Windows.DependencyPropertyChangedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="891c2-285">当此元素的数据上下文更改时发生。</span>
          <span class="sxs-lookup">
            <span data-stu-id="891c2-285">Occurs when this element's data context changes.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="891c2-286">数据上下文和数据绑定的说明，请参阅[数据绑定概述](~/docs/framework/wpf/data/data-binding-overview.md)。</span><span class="sxs-lookup"><span data-stu-id="891c2-286">For an explanation of data contexts and data binding, see [Data Binding Overview](~/docs/framework/wpf/data/data-binding-overview.md).</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="891c2-287">当元素的<xref:System.Windows.FrameworkContentElement.DataContext%2A>可能受影响的更改，此元素上的所有数据绑定属性。</span><span class="sxs-lookup"><span data-stu-id="891c2-287">When an element's <xref:System.Windows.FrameworkContentElement.DataContext%2A> changes, all data-bound properties on this element are potentially affected.</span></span> <span data-ttu-id="891c2-288">这适用于任何元素属于当前元素的子代元素继承数据上下文，以及当前元素本身。</span><span class="sxs-lookup"><span data-stu-id="891c2-288">This applies to any elements that are descendant elements of the current element, which inherit the data context, and also the current element itself.</span></span> <span data-ttu-id="891c2-289">所有此类绑定重新解释的新<xref:System.Windows.FrameworkContentElement.DataContext%2A>以反映在绑定中的新值。</span><span class="sxs-lookup"><span data-stu-id="891c2-289">All such bindings re-interpret the new <xref:System.Windows.FrameworkContentElement.DataContext%2A> to reflect the new value in bindings.</span></span> <span data-ttu-id="891c2-290">相对于引发这些更改的顺序不能保证<xref:System.Windows.FrameworkContentElement.DataContextChanged>事件。</span><span class="sxs-lookup"><span data-stu-id="891c2-290">There is no guarantee made about the order of these changes relative to the raising of the <xref:System.Windows.FrameworkContentElement.DataContextChanged> event.</span></span>  <span data-ttu-id="891c2-291">事件后或在任意组合，可以在事件之前发生的更改。</span><span class="sxs-lookup"><span data-stu-id="891c2-291">The changes can occur before the event, after the event, or in any mixture.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DataContextProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty DataContextProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty DataContextProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.DataContextProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly DataContextProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ DataContextProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable DataContextProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkContentElement.DataContextProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="891c2-292">标识 <see cref="P:System.Windows.FrameworkContentElement.DataContext" /> 依赖属性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="891c2-292">Identifies the <see cref="P:System.Windows.FrameworkContentElement.DataContext" /> dependency property.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultStyleKey">
      <MemberSignature Language="C#" Value="protected internal object DefaultStyleKey { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object DefaultStyleKey" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.DefaultStyleKey" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Property DefaultStyleKey As Object" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; property System::Object ^ DefaultStyleKey { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.DefaultStyleKey : obj with get, set" Usage="System.Windows.FrameworkContentElement.DefaultStyleKey" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="891c2-293">获取或设置用于在主题中查找此控件的样式模板的键。</span>
          <span class="sxs-lookup">
            <span data-stu-id="891c2-293">Gets or sets the key to use to find the style template for this control in themes.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="891c2-294">样式键。</span>
          <span class="sxs-lookup">
            <span data-stu-id="891c2-294">The style key.</span>
          </span>
          <span data-ttu-id="891c2-295">为了在主题样式查找中正确工作，此值应为样式化元素的 <see cref="T:System.Type" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="891c2-295">To work correctly as part of theme style lookup, this value is expected to be the <see cref="T:System.Type" /> of the element being styled.</span>
          </span>
          <span data-ttu-id="891c2-296">
            <see langword="null" /> 是在某些情况下接受的值。</span>
          <span class="sxs-lookup">
            <span data-stu-id="891c2-296">
              <see langword="null" /> is an accepted value for a certain case.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="891c2-297">通常通过其直接资源库的任何未设置此属性。</span><span class="sxs-lookup"><span data-stu-id="891c2-297">This property is typically not set through any of its direct setters.</span></span> <span data-ttu-id="891c2-298">相反，每次创建新的子类覆盖此依赖项属性的特定于类型的元数据。</span><span class="sxs-lookup"><span data-stu-id="891c2-298">Instead, you override the type-specific metadata of this dependency property every time you create a new subclass.</span></span> <span data-ttu-id="891c2-299">当在子类中，调用<xref:System.Windows.DependencyProperty.OverrideMetadata%2A>方法针对<xref:System.Windows.FrameworkContentElement.DefaultStyleKeyProperty>在控件子类的静态构造函数内的标识符。</span><span class="sxs-lookup"><span data-stu-id="891c2-299">When you subclass, call the <xref:System.Windows.DependencyProperty.OverrideMetadata%2A> method against the <xref:System.Windows.FrameworkContentElement.DefaultStyleKeyProperty> identifier, within the static constructor of the control subclass.</span></span>  
  
 <span data-ttu-id="891c2-300">例如，内联类，如<xref:System.Windows.Documents.Bold>实际上有很少之外重写实现<xref:System.Windows.FrameworkContentElement.DefaultStyleKey%2A>其静态构造函数，并公开多个实例构造函数中的元数据。</span><span class="sxs-lookup"><span data-stu-id="891c2-300">For instance, an inline class such as <xref:System.Windows.Documents.Bold> actually has very little implementation beyond overriding the <xref:System.Windows.FrameworkContentElement.DefaultStyleKey%2A> metadata in its static constructor, and exposing several instance constructors.</span></span> <span data-ttu-id="891c2-301">这一事实元素括<xref:System.Windows.Documents.Bold>标记提升<xref:System.Windows.Documents.TextElement.FontWeight%2A>的属性<xref:System.Windows.FontWeights.Bold%2A>内的默认值设置引用主题样式实现<xref:System.Windows.FrameworkContentElement.DefaultStyleKey%2A>到`typeof(Bold)`。</span><span class="sxs-lookup"><span data-stu-id="891c2-301">The fact that elements surrounded by the <xref:System.Windows.Documents.Bold> tag gain a <xref:System.Windows.Documents.TextElement.FontWeight%2A> property of <xref:System.Windows.FontWeights.Bold%2A> is implemented within the theme style that was referenced by setting the default value of <xref:System.Windows.FrameworkContentElement.DefaultStyleKey%2A> to `typeof(Bold)`.</span></span>  
  
 <span data-ttu-id="891c2-302">如果你希望元素或故意不使用主题样式的控件，设置<xref:System.Windows.FrameworkContentElement.OverridesDefaultStyle%2A>属性设置为`true`。</span><span class="sxs-lookup"><span data-stu-id="891c2-302">If you want your element or control to deliberately not use theme styles, set the <xref:System.Windows.FrameworkContentElement.OverridesDefaultStyle%2A> property to `true`.</span></span>  
  
<a name="dependencyPropertyInfo_DefaultStyleKey"></a>   
## <a name="dependency-property-information"></a><span data-ttu-id="891c2-303">依赖项属性信息</span><span class="sxs-lookup"><span data-stu-id="891c2-303">Dependency Property Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="891c2-304">标识符字段</span><span class="sxs-lookup"><span data-stu-id="891c2-304">Identifier field</span></span>|<xref:System.Windows.FrameworkContentElement.DefaultStyleKeyProperty>|  
|<span data-ttu-id="891c2-305">元数据属性设置为 `true`</span><span class="sxs-lookup"><span data-stu-id="891c2-305">Metadata properties set to `true`</span></span>|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultStyleKeyProperty">
      <MemberSignature Language="C#" Value="protected internal static readonly System.Windows.DependencyProperty DefaultStyleKeyProperty;" />
      <MemberSignature Language="ILAsm" Value=".field familyorassembly static initonly class System.Windows.DependencyProperty DefaultStyleKeyProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.DefaultStyleKeyProperty" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Shared ReadOnly DefaultStyleKeyProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="protected public: static initonly System::Windows::DependencyProperty ^ DefaultStyleKeyProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable DefaultStyleKeyProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkContentElement.DefaultStyleKeyProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="891c2-306">标识 <see cref="P:System.Windows.FrameworkContentElement.DefaultStyleKey" /> 依赖属性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="891c2-306">Identifies the <see cref="P:System.Windows.FrameworkContentElement.DefaultStyleKey" /> dependency property.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EndInit">
      <MemberSignature Language="C#" Value="public virtual void EndInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EndInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.EndInit" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub EndInit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void EndInit();" />
      <MemberSignature Language="F#" Value="abstract member EndInit : unit -&gt; unit&#xA;override this.EndInit : unit -&gt; unit" Usage="frameworkContentElement.EndInit " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="891c2-307">在初始化元素后立即调用。</span>
          <span class="sxs-lookup">
            <span data-stu-id="891c2-307">Called immediately after an element is initialized.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="891c2-308">实现此方法以提供您的元素在元素加载过程中初始化时应发生的特殊处理。</span><span class="sxs-lookup"><span data-stu-id="891c2-308">Implement this method to provide special handling that should occur when your element is initialized during the element loading process.</span></span>  
  
 <span data-ttu-id="891c2-309">您的实现应调用基实现，因为基本 （默认值） 实现设置要跟踪的初始化一些内部标志。</span><span class="sxs-lookup"><span data-stu-id="891c2-309">Your implementation should call the base implementation, because the base (default) implementation sets some internal flags to keep track of initialization.</span></span>  
  
 <span data-ttu-id="891c2-310">如果<xref:System.Windows.FrameworkContentElement.BeginInit%2A>之前调用，基实现将引发<xref:System.Windows.FrameworkContentElement.Initialized>事件。</span><span class="sxs-lookup"><span data-stu-id="891c2-310">If <xref:System.Windows.FrameworkContentElement.BeginInit%2A> was previously called, the base implementation will raise the <xref:System.Windows.FrameworkContentElement.Initialized> event.</span></span> <span data-ttu-id="891c2-311">否则为如果<xref:System.Windows.FrameworkContentElement.BeginInit%2A>未调用或不能确定是否<xref:System.Windows.FrameworkContentElement.BeginInit%2A>已调用，则不会引发该事件。</span><span class="sxs-lookup"><span data-stu-id="891c2-311">Otherwise, if <xref:System.Windows.FrameworkContentElement.BeginInit%2A> was not called or it could not be determined whether <xref:System.Windows.FrameworkContentElement.BeginInit%2A> was called, the event is not raised.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FindName">
      <MemberSignature Language="C#" Value="public object FindName (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object FindName(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.FindName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function FindName (name As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ FindName(System::String ^ name);" />
      <MemberSignature Language="F#" Value="member this.FindName : string -&gt; obj" Usage="frameworkContentElement.FindName name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="891c2-312">要搜索的元素的名称。</span>
          <span class="sxs-lookup">
            <span data-stu-id="891c2-312">Name of the element to search for.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="891c2-313">查找具有提供的标识符名的元素。</span>
          <span class="sxs-lookup">
            <span data-stu-id="891c2-313">Finds an element that has the provided identifier name.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="891c2-314">请求的元素。</span>
          <span class="sxs-lookup">
            <span data-stu-id="891c2-314">The requested element.</span>
          </span>
          <span data-ttu-id="891c2-315">如果未找到匹配的元素，则可以为 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="891c2-315">May be <see langword="null" /> if no matching element was found.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="891c2-316">如果此元素具有子元素，这些子元素将是所有以递归方式搜索请求的命名元素。</span><span class="sxs-lookup"><span data-stu-id="891c2-316">If this element has child elements, these child elements are all searched recursively for the requested named element.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="891c2-317">下面的示例内部引用通过名称找到的元素上设置属性<xref:System.Windows.Documents.FlowDocument>页面上。</span><span class="sxs-lookup"><span data-stu-id="891c2-317">The following example sets a property on an element found by name within a referenced <xref:System.Windows.Documents.FlowDocument> on a page.</span></span>  
  
 [!code-csharp[ContentElementsSmorgasbord#FindName](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml.cs#findname)]
 [!code-vb[ContentElementsSmorgasbord#FindName](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContentElementsSmorgasbord/visualbasic/page1.xaml.vb#findname)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FindResource">
      <MemberSignature Language="C#" Value="public object FindResource (object resourceKey);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object FindResource(object resourceKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.FindResource(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function FindResource (resourceKey As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ FindResource(System::Object ^ resourceKey);" />
      <MemberSignature Language="F#" Value="member this.FindResource : obj -&gt; obj" Usage="frameworkContentElement.FindResource resourceKey" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="resourceKey" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="resourceKey">
          <span data-ttu-id="891c2-318">要查找的资源的键标识符。</span>
          <span class="sxs-lookup">
            <span data-stu-id="891c2-318">Key identifier of the resource to be found.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="891c2-319">搜索具有指定键的资源，如果未找到请求的资源，则引发异常。</span>
          <span class="sxs-lookup">
            <span data-stu-id="891c2-319">Searches for a resource with the specified key, and will throw an exception if the requested resource is not found.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="891c2-320">找到的资源；如果未找到任何匹配的资源，则为 <see langword="null" />（但如果为 <see langword="null" />，将同时引发异常）。</span>
          <span class="sxs-lookup">
            <span data-stu-id="891c2-320">The found resource, or <see langword="null" /> if no matching resource was found (but will also throw an exception if <see langword="null" />).</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  <span data-ttu-id="891c2-321">如果找不到键调用此方法，将引发异常。</span><span class="sxs-lookup"><span data-stu-id="891c2-321">If you call this method for a key that cannot be found, an exception is thrown.</span></span> <span data-ttu-id="891c2-322">如果您不想要处理这种情况下的异常，应改为调用<xref:System.Windows.FrameworkContentElement.TryFindResource%2A>。</span><span class="sxs-lookup"><span data-stu-id="891c2-322">If you do not want to handle exceptions for this case, you should instead call <xref:System.Windows.FrameworkContentElement.TryFindResource%2A>.</span></span> <span data-ttu-id="891c2-323"><xref:System.Windows.FrameworkContentElement.TryFindResource%2A> 返回`null`不到资源时找到，并且不会引发异常。</span><span class="sxs-lookup"><span data-stu-id="891c2-323"><xref:System.Windows.FrameworkContentElement.TryFindResource%2A> returns `null` when no resource is found, and does not throw an exception.</span></span>  
  
 <span data-ttu-id="891c2-324">如果在调用元素上找不到资源，使用逻辑树搜索父树，树的方法相同的某个资源已请求搜索由在运行时参数。</span><span class="sxs-lookup"><span data-stu-id="891c2-324">If the resource is not found on the calling element, the parent tree is searched using the logical tree, in the same way that the tree would be searched if a resource were requested by key at run-time.</span></span>  
  
 <span data-ttu-id="891c2-325">通常，会立即强制转换为已尝试设置为返回的资源值的属性的类型的返回值。</span><span class="sxs-lookup"><span data-stu-id="891c2-325">Typically you would immediately cast the return value to the type of the property that you were attempting to set with the returned resource value.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="891c2-326">下面的示例查找资源，在标记中定义并将其应用于路由事件的响应中的元素的某一属性。</span><span class="sxs-lookup"><span data-stu-id="891c2-326">The following example finds a resource as defined in markup and applies it to a certain property of an element in response to a routed event.</span></span>  
  
 [!code-csharp[ContentElementsSmorgasbord#FindResource](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml.cs#findresource)]
 [!code-vb[ContentElementsSmorgasbord#FindResource](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContentElementsSmorgasbord/visualbasic/page1.xaml.vb#findresource)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Windows.ResourceReferenceKeyNotFoundException">
          <span data-ttu-id="891c2-327">未找到请求的资源键。</span>
          <span class="sxs-lookup">
            <span data-stu-id="891c2-327">The requested resource key was not found.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="891c2-328">
            <paramref name="resourceKey" /> 为 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="891c2-328">
              <paramref name="resourceKey" /> is <see langword="null" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="FocusVisualStyle">
      <MemberSignature Language="C#" Value="public System.Windows.Style FocusVisualStyle { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Style FocusVisualStyle" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.FocusVisualStyle" />
      <MemberSignature Language="VB.NET" Value="Public Property FocusVisualStyle As Style" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Style ^ FocusVisualStyle { System::Windows::Style ^ get(); void set(System::Windows::Style ^ value); };" />
      <MemberSignature Language="F#" Value="member this.FocusVisualStyle : System.Windows.Style with get, set" Usage="System.Windows.FrameworkContentElement.FocusVisualStyle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Style</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="891c2-329">获取或设置一个对象，该对象允许自定义此元素在捕获到键盘焦点时要应用于此元素的外观、效果或其他样式特征。</span>
          <span class="sxs-lookup">
            <span data-stu-id="891c2-329">Gets or sets an object that enables customization of appearance, effects, or other style characteristics that will apply to this element when it captures keyboard focus.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="891c2-330">要应用于焦点的所需样式。</span>
          <span class="sxs-lookup">
            <span data-stu-id="891c2-330">The desired style to apply on focus.</span>
          </span>
          <span data-ttu-id="891c2-331">该依赖项属性中声明的默认值是一个空的静态 <see cref="T:System.Windows.Style" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="891c2-331">The default value as declared in the dependency property is an empty static <see cref="T:System.Windows.Style" />.</span>
          </span>
          <span data-ttu-id="891c2-332">但是，运行时的有效值通常是（但并非总是）控件的主题支持所提供的样式。</span>
          <span class="sxs-lookup">
            <span data-stu-id="891c2-332">However, the effective value at run time is often (but not always) a style as supplied by theme support for controls.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="891c2-333">设置此属性时[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]、 样式几乎始终定义为资源，而不是作为一个元素，内联和资源，通常是作为引用<xref:System.Windows.StaticResourceExtension>。</span><span class="sxs-lookup"><span data-stu-id="891c2-333">When setting this property in [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)], styles are almost always defined as a resource, rather than inline as an element, and that resource is usually referenced as a <xref:System.Windows.StaticResourceExtension>.</span></span>  
  
 <span data-ttu-id="891c2-334">请注意，此属性会影响视觉外观，但不会报告此元数据中。</span><span class="sxs-lookup"><span data-stu-id="891c2-334">Note that this property affects visual appearance but does not report so in metadata.</span></span> <span data-ttu-id="891c2-335">这是因为可视外观更改是事件驱动和在任何时候，可能不适用，因此通常不应报告元数据中的任何视觉对象或布局信息。</span><span class="sxs-lookup"><span data-stu-id="891c2-335">This is because the visual appearance change is event-driven and may not apply at all times, and thus should not generally report any visual or layout information in metadata.</span></span>  
  
 <span data-ttu-id="891c2-336">从概念上讲，焦点应用于控件的可视行为应一致元素元素。</span><span class="sxs-lookup"><span data-stu-id="891c2-336">Conceptually, the visual behavior of focus applied to a control should be coherent from element to element.</span></span> <span data-ttu-id="891c2-337">强制实施一致性的最合理方法是仅当您在创作整个主题更改焦点视觉样式。</span><span class="sxs-lookup"><span data-stu-id="891c2-337">The most sensible way to enforce coherence is to only change the focus visual style if you are composing an entire theme.</span></span> <span data-ttu-id="891c2-338">在单个样式上而不是作为主题的一部分设置此属性不可此属性的预期的用法，因为它可能会导致混乱的用户体验与键盘焦点有关。</span><span class="sxs-lookup"><span data-stu-id="891c2-338">Setting this property on individual styles and not as part of a theme is not the intended usage of this property, because it may lead to a confusing user experience regarding keyboard focus.</span></span> <span data-ttu-id="891c2-339">如果你想是故意不一致的整个主题的特定于元素的行为，更好的方法是使用触发器在样式中的个别输入的状态属性，如<xref:System.Windows.UIElement.IsFocused%2A>或<xref:System.Windows.UIElement.IsKeyboardFocusWithin%2A>，并为此，在没有一种方法以可视方式会影响任何现有的焦点视觉样式。</span><span class="sxs-lookup"><span data-stu-id="891c2-339">If you are intending element-specific behavior that is deliberately not coherent across a theme, a much better approach is to use triggers in styles for individual input state properties, such as <xref:System.Windows.UIElement.IsFocused%2A> or <xref:System.Windows.UIElement.IsKeyboardFocusWithin%2A>, and to do so in a way that does not visually interfere with any existing focus visual style.</span></span> <span data-ttu-id="891c2-340">有关详细信息的设计意图<xref:System.Windows.FrameworkContentElement.FocusVisualStyle%2A>及替代焦点属性，请参阅[控件，以及 FocusVisualStyle 中的焦点设置样式](~/docs/framework/wpf/advanced/styling-for-focus-in-controls-and-focusvisualstyle.md)。</span><span class="sxs-lookup"><span data-stu-id="891c2-340">For more information on the design intention of <xref:System.Windows.FrameworkContentElement.FocusVisualStyle%2A> and alternative focus properties, see [Styling for Focus in Controls, and FocusVisualStyle](~/docs/framework/wpf/advanced/styling-for-focus-in-controls-and-focusvisualstyle.md).</span></span>  
  
<a name="xamlAttributeUsage_FocusVisualStyle"></a>   
## <a name="xaml-attribute-usage"></a><span data-ttu-id="891c2-341">XAML 属性用法</span><span class="sxs-lookup"><span data-stu-id="891c2-341">XAML Attribute Usage</span></span>  
  
```  
<object FocusVisualStyle="{resourceExtension styleResourceKey}"/>  
```  
  
<a name="xamlPropertyElementUsage_FocusVisualStyle"></a>   
## <a name="xaml-property-element-usage"></a><span data-ttu-id="891c2-342">XAML 属性元素用法</span><span class="sxs-lookup"><span data-stu-id="891c2-342">XAML Property Element Usage</span></span>  
  
<a name="xamlValues_FocusVisualStyle"></a>   
## <a name="xaml-values"></a><span data-ttu-id="891c2-343">XAML 值</span><span class="sxs-lookup"><span data-stu-id="891c2-343">XAML Values</span></span>  
 <span data-ttu-id="891c2-344">*resourceExtension*</span><span class="sxs-lookup"><span data-stu-id="891c2-344">*resourceExtension*</span></span>  
 <span data-ttu-id="891c2-345">以下项之一:、 或。</span><span class="sxs-lookup"><span data-stu-id="891c2-345">One of the following: , or .</span></span> <span data-ttu-id="891c2-346">请参阅[XAML 资源](~/docs/framework/wpf/advanced/xaml-resources.md)。</span><span class="sxs-lookup"><span data-stu-id="891c2-346">See [XAML Resources](~/docs/framework/wpf/advanced/xaml-resources.md).</span></span>  
  
 <span data-ttu-id="891c2-347">*styleResourceKey*</span><span class="sxs-lookup"><span data-stu-id="891c2-347">*styleResourceKey*</span></span>  
 <span data-ttu-id="891c2-348">标识所请求的样式的键。</span><span class="sxs-lookup"><span data-stu-id="891c2-348">The key that identifies the style being requested.</span></span> <span data-ttu-id="891c2-349">键引用中的现有资源<xref:System.Windows.ResourceDictionary>。</span><span class="sxs-lookup"><span data-stu-id="891c2-349">The key refers to an existing resource in a <xref:System.Windows.ResourceDictionary>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="891c2-350">属性元素语法就从技术上讲，但不是建议这样做。</span><span class="sxs-lookup"><span data-stu-id="891c2-350">Property element syntax is technically possible, but not recommended.</span></span> <span data-ttu-id="891c2-351">请参阅[内联样式和模板](~/docs/framework/wpf/advanced/inline-styles-and-templates.md)。</span><span class="sxs-lookup"><span data-stu-id="891c2-351">See [Inline Styles and Templates](~/docs/framework/wpf/advanced/inline-styles-and-templates.md).</span></span>  <span data-ttu-id="891c2-352">绑定引用使用或<xref:System.Windows.Data.Binding>也是可行的但不常见。</span><span class="sxs-lookup"><span data-stu-id="891c2-352">A binding reference using  or <xref:System.Windows.Data.Binding> is also possible, but uncommon.</span></span>  
  
<a name="dependencyPropertyInfo_FocusVisualStyle"></a>   
## <a name="dependency-property-information"></a><span data-ttu-id="891c2-353">依赖项属性信息</span><span class="sxs-lookup"><span data-stu-id="891c2-353">Dependency Property Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="891c2-354">标识符字段</span><span class="sxs-lookup"><span data-stu-id="891c2-354">Identifier field</span></span>|<xref:System.Windows.FrameworkContentElement.FocusVisualStyleProperty>|  
|<span data-ttu-id="891c2-355">元数据属性设置为 `true`</span><span class="sxs-lookup"><span data-stu-id="891c2-355">Metadata properties set to `true`</span></span>|<span data-ttu-id="891c2-356">无</span><span class="sxs-lookup"><span data-stu-id="891c2-356">None</span></span>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FocusVisualStyleProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty FocusVisualStyleProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty FocusVisualStyleProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.FocusVisualStyleProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly FocusVisualStyleProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ FocusVisualStyleProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable FocusVisualStyleProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkContentElement.FocusVisualStyleProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="891c2-357">标识 <see cref="P:System.Windows.FrameworkContentElement.FocusVisualStyle" /> 依赖属性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="891c2-357">Identifies the <see cref="P:System.Windows.FrameworkContentElement.FocusVisualStyle" /> dependency property.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ForceCursor">
      <MemberSignature Language="C#" Value="public bool ForceCursor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ForceCursor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.ForceCursor" />
      <MemberSignature Language="VB.NET" Value="Public Property ForceCursor As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ForceCursor { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.ForceCursor : bool with get, set" Usage="System.Windows.FrameworkContentElement.ForceCursor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="891c2-358">获取或设置一个值，该值指示此 <see cref="T:System.Windows.FrameworkContentElement" /> 是否应该强制[!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)] 按照此实例的 <see cref="P:System.Windows.FrameworkContentElement.Cursor" /> 属性所声明的方式呈现光标。</span>
          <span class="sxs-lookup">
            <span data-stu-id="891c2-358">Gets or sets a value indicating whether this <see cref="T:System.Windows.FrameworkContentElement" /> should force the [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)] to render the cursor as declared by this instance's <see cref="P:System.Windows.FrameworkContentElement.Cursor" /> property.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="891c2-359">在光标位于此元素上时，强制光标呈现以将此实例的设置用于光标（包括在所有子元素上），则为 <see langword="true" />；否则为 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="891c2-359">
              <see langword="true" /> to force cursor presentation while over this element to use this instance's setting for the cursor (including on all child elements); otherwise <see langword="false" />.</span>
          </span>
          <span data-ttu-id="891c2-360">默认值为 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="891c2-360">The default value is <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="891c2-361">此属性设置为`true`将覆盖由子元素的光标首选项。</span><span class="sxs-lookup"><span data-stu-id="891c2-361">Setting this property to `true` will override the cursor preferences established by child elements.</span></span> <span data-ttu-id="891c2-362">这样做因此一般情况下应用程序[!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)]可能容易引起混淆的用户，尤其是如果子元素尝试指定游标。</span><span class="sxs-lookup"><span data-stu-id="891c2-362">Doing so in general application [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)] might be confusing for the user, particularly if child elements are attempting to specify cursors.</span></span> <span data-ttu-id="891c2-363">设置<xref:System.Windows.FrameworkElement.ForceCursor%2A>控件子类化或组合的情况下方案中更合适。</span><span class="sxs-lookup"><span data-stu-id="891c2-363">Setting <xref:System.Windows.FrameworkElement.ForceCursor%2A> is more appropriate in control subclassing or compositing scenarios.</span></span>  
  
<a name="dependencyPropertyInfo_ForceCursor"></a>   
## <a name="dependency-property-information"></a><span data-ttu-id="891c2-364">依赖项属性信息</span><span class="sxs-lookup"><span data-stu-id="891c2-364">Dependency Property Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="891c2-365">标识符字段</span><span class="sxs-lookup"><span data-stu-id="891c2-365">Identifier field</span></span>|<xref:System.Windows.FrameworkContentElement.ForceCursorProperty>|  
|<span data-ttu-id="891c2-366">元数据属性设置为 `true`</span><span class="sxs-lookup"><span data-stu-id="891c2-366">Metadata properties set to `true`</span></span>|<span data-ttu-id="891c2-367">无</span><span class="sxs-lookup"><span data-stu-id="891c2-367">None</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="891c2-368">下面的示例强制上元素的光标。</span><span class="sxs-lookup"><span data-stu-id="891c2-368">The following example forces the cursor while over the element.</span></span>  
  
 [!code-xaml[ForceCursor#ForceCursor](~/samples/snippets/csharp/VS_Snippets_Wpf/ForceCursor/CS/default.xaml#forcecursor)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ForceCursorProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ForceCursorProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ForceCursorProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.ForceCursorProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ForceCursorProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ForceCursorProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable ForceCursorProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkContentElement.ForceCursorProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="891c2-369">标识 <see cref="P:System.Windows.FrameworkContentElement.ForceCursor" /> 依赖属性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="891c2-369">Identifies the <see cref="P:System.Windows.FrameworkContentElement.ForceCursor" /> dependency property.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetBindingExpression">
      <MemberSignature Language="C#" Value="public System.Windows.Data.BindingExpression GetBindingExpression (System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Data.BindingExpression GetBindingExpression(class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.GetBindingExpression(System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetBindingExpression (dp As DependencyProperty) As BindingExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Data::BindingExpression ^ GetBindingExpression(System::Windows::DependencyProperty ^ dp);" />
      <MemberSignature Language="F#" Value="member this.GetBindingExpression : System.Windows.DependencyProperty -&gt; System.Windows.Data.BindingExpression" Usage="frameworkContentElement.GetBindingExpression dp" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Data.BindingExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="dp">
          <span data-ttu-id="891c2-370">从中获取绑定的目标 <see cref="T:System.Windows.DependencyProperty" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="891c2-370">The target <see cref="T:System.Windows.DependencyProperty" /> from which to get the binding.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="891c2-371">获取指定属性的绑定的 <see cref="T:System.Windows.Data.BindingExpression" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="891c2-371">Gets the <see cref="T:System.Windows.Data.BindingExpression" /> for the specified property's binding.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="891c2-372">如果目标为数据绑定，则返回 <see cref="T:System.Windows.Data.BindingExpression" />；否则返回 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="891c2-372">Returns a <see cref="T:System.Windows.Data.BindingExpression" /> if the target is data bound; otherwise, <see langword="null" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="891c2-373">下面的示例通过查询属性来检索一个绑定。</span><span class="sxs-lookup"><span data-stu-id="891c2-373">The following example retrieves a binding by querying a property.</span></span>  
  
 [!code-csharp[ContentElementsSmorgasbord#GetBindingExpression](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml.cs#getbindingexpression)]
 [!code-vb[ContentElementsSmorgasbord#GetBindingExpression](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContentElementsSmorgasbord/visualbasic/page1.xaml.vb#getbindingexpression)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetUIParentCore">
      <MemberSignature Language="C#" Value="protected internal override System.Windows.DependencyObject GetUIParentCore ();" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance class System.Windows.DependencyObject GetUIParentCore() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.GetUIParentCore" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides Function GetUIParentCore () As DependencyObject" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override System::Windows::DependencyObject ^ GetUIParentCore();" />
      <MemberSignature Language="F#" Value="override this.GetUIParentCore : unit -&gt; System.Windows.DependencyObject" Usage="frameworkContentElement.GetUIParentCore " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="891c2-374">如果没有此元素的可视化父级，则返回此元素的备用逻辑父级。</span>
          <span class="sxs-lookup">
            <span data-stu-id="891c2-374">Returns an alternative logical parent for this element if there is no visual parent.</span>
          </span>
          <span data-ttu-id="891c2-375">在这种情况下，<see cref="T:System.Windows.FrameworkContentElement" /> 父级始终与 <see cref="P:System.Windows.FrameworkContentElement.Parent" /> 属性具有相同值。</span>
          <span class="sxs-lookup">
            <span data-stu-id="891c2-375">In this case, a <see cref="T:System.Windows.FrameworkContentElement" /> parent is always the same value as the <see cref="P:System.Windows.FrameworkContentElement.Parent" /> property.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="891c2-376">当此方法的 WPF 框架级别实现具有非视觉父级连接时，即返回 <see langword="null" /> 之外的内容。</span>
          <span class="sxs-lookup">
            <span data-stu-id="891c2-376">Returns something other than <see langword="null" /> whenever a WPF framework-level implementation of this method has a non-visual parent connection.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="891c2-377">默认实现返回预期的单个可视化父级。</span><span class="sxs-lookup"><span data-stu-id="891c2-377">The default implementation returns the expected single visual parent.</span></span> <span data-ttu-id="891c2-378">自定义实现可能会返回备用的父关系。</span><span class="sxs-lookup"><span data-stu-id="891c2-378">Custom implementations might return alternate parent relationships.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Initialized">
      <MemberSignature Language="C#" Value="public event EventHandler Initialized;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Initialized" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkContentElement.Initialized" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Initialized As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Initialized;" />
      <MemberSignature Language="F#" Value="member this.Initialized : EventHandler " Usage="member this.Initialized : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="891c2-379">初始化此 <see cref="T:System.Windows.FrameworkContentElement" /> 时发生。</span>
          <span class="sxs-lookup">
            <span data-stu-id="891c2-379">Occurs when this <see cref="T:System.Windows.FrameworkContentElement" /> is initialized.</span>
          </span>
          <span data-ttu-id="891c2-380">这与 <see cref="P:System.Windows.FrameworkContentElement.IsInitialized" /> 属性值从 <see langword="false" />（或未定义）更改为 <see langword="true" /> 的情况相符。</span>
          <span class="sxs-lookup">
            <span data-stu-id="891c2-380">This coincides with cases where the value of the <see cref="P:System.Windows.FrameworkContentElement.IsInitialized" /> property changes from <see langword="false" /> (or undefined) to <see langword="true" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="891c2-381">将此事件时引发<xref:System.Windows.FrameworkContentElement.EndInit%2A>或<xref:System.Windows.FrameworkContentElement.OnInitialized%2A>调用方法。</span><span class="sxs-lookup"><span data-stu-id="891c2-381">This event will be raised whenever the <xref:System.Windows.FrameworkContentElement.EndInit%2A> or <xref:System.Windows.FrameworkContentElement.OnInitialized%2A> methods are called.</span></span> <span data-ttu-id="891c2-382">对这些方法的调用可能已进行了通过故意代码，或由[!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)]加载过程。</span><span class="sxs-lookup"><span data-stu-id="891c2-382">Calls to these methods could have been made by deliberate code, or by the [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)] loading process.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InputScope">
      <MemberSignature Language="C#" Value="public System.Windows.Input.InputScope InputScope { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Input.InputScope InputScope" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.InputScope" />
      <MemberSignature Language="VB.NET" Value="Public Property InputScope As InputScope" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Input::InputScope ^ InputScope { System::Windows::Input::InputScope ^ get(); void set(System::Windows::Input::InputScope ^ value); };" />
      <MemberSignature Language="F#" Value="member this.InputScope : System.Windows.Input.InputScope with get, set" Usage="System.Windows.FrameworkContentElement.InputScope" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.InputScope</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="891c2-383">获取或设置此 <see cref="T:System.Windows.FrameworkContentElement" /> 使用的输入的上下文。</span>
          <span class="sxs-lookup">
            <span data-stu-id="891c2-383">Gets or sets the context for input used by this <see cref="T:System.Windows.FrameworkContentElement" />.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="891c2-384">解释输入范围，在该输入范围内修改从其他输入法输入的方式。</span>
          <span class="sxs-lookup">
            <span data-stu-id="891c2-384">The input scope, which modifies how input from alternative input methods is interpreted.</span>
          </span>
          <span data-ttu-id="891c2-385">默认值为 <see langword="null" />（这导致对命令的默认处理）。</span>
          <span class="sxs-lookup">
            <span data-stu-id="891c2-385">The default value is <see langword="null" /> (which results in a default handling of commands).</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="891c2-386">此依赖属性继承属性值。</span><span class="sxs-lookup"><span data-stu-id="891c2-386">This dependency property inherits property values.</span></span> <span data-ttu-id="891c2-387">如果没有与任何其他值的子元素<xref:System.Windows.FrameworkElement.InputScope%2A>建立通过本地值或样式，属性系统将设置此值为<xref:System.Windows.FrameworkElement.InputScope%2A>分配有此值最接近的父元素的值。</span><span class="sxs-lookup"><span data-stu-id="891c2-387">If there are child elements with no other value for <xref:System.Windows.FrameworkElement.InputScope%2A> established through local values or styles, the property system will set the value to be the <xref:System.Windows.FrameworkElement.InputScope%2A> value of the nearest parent element with this value assigned.</span></span>  
  
 <span data-ttu-id="891c2-388">尽管[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]语法使用情况列出和语法上允许，则将此属性设置[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]并不常见。</span><span class="sxs-lookup"><span data-stu-id="891c2-388">Although a [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] syntax usage is listed and is syntactically allowed, setting this property in [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] is not common.</span></span>  
  
<a name="dependencyPropertyInfo_InputScope"></a>   
## <a name="dependency-property-information"></a><span data-ttu-id="891c2-389">依赖项属性信息</span><span class="sxs-lookup"><span data-stu-id="891c2-389">Dependency Property Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="891c2-390">标识符字段</span><span class="sxs-lookup"><span data-stu-id="891c2-390">Identifier field</span></span>|<xref:System.Windows.FrameworkContentElement.InputScopeProperty>|  
|<span data-ttu-id="891c2-391">元数据属性设置为 `true`</span><span class="sxs-lookup"><span data-stu-id="891c2-391">Metadata properties set to `true`</span></span>|<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InputScopeProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty InputScopeProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty InputScopeProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.InputScopeProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly InputScopeProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ InputScopeProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable InputScopeProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkContentElement.InputScopeProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="891c2-392">标识 <see cref="P:System.Windows.FrameworkContentElement.InputScope" /> 依赖属性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="891c2-392">Identifies the <see cref="P:System.Windows.FrameworkContentElement.InputScope" /> dependency property.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsInitialized">
      <MemberSignature Language="C#" Value="public bool IsInitialized { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsInitialized" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.IsInitialized" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsInitialized As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsInitialized { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsInitialized : bool" Usage="System.Windows.FrameworkContentElement.IsInitialized" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="891c2-393">获取一个值，该值指示是否已通过将此元素作为[!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)] 加载或显式调用它的 <see cref="M:System.Windows.FrameworkContentElement.EndInit" /> 方法初始化此元素。</span>
          <span class="sxs-lookup">
            <span data-stu-id="891c2-393">Gets a value indicating whether this element has been initialized, either by being loaded as [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)], or by explicitly having its <see cref="M:System.Windows.FrameworkContentElement.EndInit" /> method called.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="891c2-394">如果已通过上述加载或方法调用初始化了此元素，则为 <see langword="true" />；否则为 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="891c2-394">
              <see langword="true" /> if the element is initialized per the aforementioned loading or method calls; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="891c2-395">此属性也可能`true`如果此元素被移动元素树中以便它有了新的父元素，并因此重新。</span><span class="sxs-lookup"><span data-stu-id="891c2-395">This property may also be `true` if this element has been moved within the element tree such that it has a new parent element, and therefore becomes reloaded again.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkContentElement.BeginInit" />
      </Docs>
    </Member>
    <Member MemberName="IsLoaded">
      <MemberSignature Language="C#" Value="public bool IsLoaded { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsLoaded" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.IsLoaded" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsLoaded As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsLoaded { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsLoaded : bool" Usage="System.Windows.FrameworkContentElement.IsLoaded" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="891c2-396">获取一个值，该值指示是否已加载此元素以供显示。</span>
          <span class="sxs-lookup">
            <span data-stu-id="891c2-396">Gets a value indicating whether this element has been loaded for presentation.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="891c2-397">如果当前元素附加到元素树且已呈现，则为 <see langword="true" />；如果元素从未附加到加载的元素树中，则为 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="891c2-397">
              <see langword="true" /> if the current element is attached to an element tree and has been rendered; <see langword="false" /> if the element has never been attached to a loaded element tree.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="891c2-398">从新构造的实例，此属性以`false`，并保持`true`一旦设置为`true`，即使随后由代码中删除。</span><span class="sxs-lookup"><span data-stu-id="891c2-398">From a newly constructed instance, this property starts off `false`, and remains `true` once it is set to `true`, even if subsequently removed by  code.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="891c2-399">下面的代码示例使用<xref:System.Windows.FrameworkContentElement.IsLoaded%2A>作为条件检查，以确保函数`displayData`（未显示） 将具有有效的元素上加载页后，可以按需处理程序的一部分，针对工作。</span><span class="sxs-lookup"><span data-stu-id="891c2-399">The following example code uses <xref:System.Windows.FrameworkContentElement.IsLoaded%2A> as a conditional check to assure that a function `displayData` (not shown) will have valid elements loaded on the page to work against, as part of an on-demand handler.</span></span> <span data-ttu-id="891c2-400">作为事件处理程序运行时相同的逻辑<xref:System.Windows.FrameworkContentElement.Loaded>。</span><span class="sxs-lookup"><span data-stu-id="891c2-400">That same logic is run as an event handler for <xref:System.Windows.FrameworkContentElement.Loaded>.</span></span>  
  
 [!code-csharp[ContentElementsSmorgasbord#IsLoaded](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml.cs#isloaded)]
 [!code-vb[ContentElementsSmorgasbord#IsLoaded](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContentElementsSmorgasbord/visualbasic/page1.xaml.vb#isloaded)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.FrameworkContentElement.Loaded" />
      </Docs>
    </Member>
    <Member MemberName="Language">
      <MemberSignature Language="C#" Value="public System.Windows.Markup.XmlLanguage Language { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Markup.XmlLanguage Language" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.Language" />
      <MemberSignature Language="VB.NET" Value="Public Property Language As XmlLanguage" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Markup::XmlLanguage ^ Language { System::Windows::Markup::XmlLanguage ^ get(); void set(System::Windows::Markup::XmlLanguage ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Language : System.Windows.Markup.XmlLanguage with get, set" Usage="System.Windows.FrameworkContentElement.Language" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Markup.XmlLanguage</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="891c2-401">获取或设置应用于单个元素的本地化/全球化语言信息。</span>
          <span class="sxs-lookup">
            <span data-stu-id="891c2-401">Gets or sets localization/globalization language information that applies to an individual element.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="891c2-402">此元素的区域性信息。</span>
          <span class="sxs-lookup">
            <span data-stu-id="891c2-402">The culture information for this element.</span>
          </span>
          <span data-ttu-id="891c2-403">默认值是一个 <see cref="T:System.Windows.Markup.XmlLanguage" /> 实例，它的 <see cref="P:System.Windows.Markup.XmlLanguage.IetfLanguageTag" /> 值设置为字符串“en-US”。</span>
          <span class="sxs-lookup">
            <span data-stu-id="891c2-403">The default value is an <see cref="T:System.Windows.Markup.XmlLanguage" /> instance with its <see cref="P:System.Windows.Markup.XmlLanguage.IetfLanguageTag" /> value set to the string "en-US".</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="891c2-404">字符串格式遵循 RFC 3066 标准。</span><span class="sxs-lookup"><span data-stu-id="891c2-404">The string formats follow the RFC 3066 standard.</span></span> <span data-ttu-id="891c2-405">例如，美国英语是"EN-US"。</span><span class="sxs-lookup"><span data-stu-id="891c2-405">For example, U.S. English is "en-US".</span></span> <span data-ttu-id="891c2-406">请参阅<xref:System.Windows.Markup.XmlLanguage>的值和格式的详细信息。</span><span class="sxs-lookup"><span data-stu-id="891c2-406">See <xref:System.Windows.Markup.XmlLanguage> for more information on the values and format.</span></span>  
  
 <span data-ttu-id="891c2-407">此依赖属性继承属性值。</span><span class="sxs-lookup"><span data-stu-id="891c2-407">This dependency property inherits property values.</span></span> <span data-ttu-id="891c2-408">如果没有与任何其他值的子元素<xref:System.Windows.FrameworkElement.Language%2A>建立通过本地值或样式，属性系统将设置此值为<xref:System.Windows.FrameworkElement.Language%2A>分配有此值最接近的父元素的值。</span><span class="sxs-lookup"><span data-stu-id="891c2-408">If there are child elements with no other value for <xref:System.Windows.FrameworkElement.Language%2A> established through local values or styles, the property system will set the value to be the <xref:System.Windows.FrameworkElement.Language%2A> value of the nearest parent element with this value assigned.</span></span>  
  
<a name="dependencyPropertyInfo_CultureInfo"></a>   
## <a name="dependency-property-information"></a><span data-ttu-id="891c2-409">依赖项属性信息</span><span class="sxs-lookup"><span data-stu-id="891c2-409">Dependency Property Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="891c2-410">标识符字段</span><span class="sxs-lookup"><span data-stu-id="891c2-410">Identifier field</span></span>|<xref:System.Windows.FrameworkContentElement.LanguageProperty>|  
|<span data-ttu-id="891c2-411">元数据属性设置为 `true`</span><span class="sxs-lookup"><span data-stu-id="891c2-411">Metadata properties set to `true`</span></span>|<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LanguageProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty LanguageProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty LanguageProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.LanguageProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly LanguageProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ LanguageProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable LanguageProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkContentElement.LanguageProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="891c2-412">标识 <see cref="P:System.Windows.FrameworkContentElement.Language" /> 依赖属性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="891c2-412">Identifies the <see cref="P:System.Windows.FrameworkContentElement.Language" /> dependency property.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Loaded">
      <MemberSignature Language="C#" Value="public event System.Windows.RoutedEventHandler Loaded;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.RoutedEventHandler Loaded" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkContentElement.Loaded" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Loaded As RoutedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::RoutedEventHandler ^ Loaded;" />
      <MemberSignature Language="F#" Value="member this.Loaded : System.Windows.RoutedEventHandler " Usage="member this.Loaded : System.Windows.RoutedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="891c2-413">在元素已布局、已呈现且可用于交互时发生。</span>
          <span class="sxs-lookup">
            <span data-stu-id="891c2-413">Occurs when the element is laid out, rendered, and ready for interaction.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="891c2-414">直接路由的事件不遵循路由，而仅处理引发它们在同一元素中。</span><span class="sxs-lookup"><span data-stu-id="891c2-414">Direct routed events do not follow a route, they are only handled within the same element on which they are raised.</span></span> <span data-ttu-id="891c2-415">直接路由的事件支持其他路由的事件行为： 它们支持的可访问的处理程序集合，并可用作<xref:System.Windows.EventTrigger>样式中。</span><span class="sxs-lookup"><span data-stu-id="891c2-415">Direct routed events do support other routed event behavior: they support an accessible handlers collection, and can be used as an <xref:System.Windows.EventTrigger> in a style.</span></span>  
  
<a name="routedEventInfo_Loaded"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="891c2-416">路由事件信息</span><span class="sxs-lookup"><span data-stu-id="891c2-416">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="891c2-417">标识符字段</span><span class="sxs-lookup"><span data-stu-id="891c2-417">Identifier field</span></span>|<xref:System.Windows.FrameworkContentElement.LoadedEvent>|  
|<span data-ttu-id="891c2-418">路由策略</span><span class="sxs-lookup"><span data-stu-id="891c2-418">Routing strategy</span></span>|<span data-ttu-id="891c2-419">直接</span><span class="sxs-lookup"><span data-stu-id="891c2-419">Direct</span></span>|  
|<span data-ttu-id="891c2-420">Delegate</span><span class="sxs-lookup"><span data-stu-id="891c2-420">Delegate</span></span>|<xref:System.Windows.RoutedEventHandler>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LoadedEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent LoadedEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent LoadedEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.LoadedEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly LoadedEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ LoadedEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable LoadedEvent : System.Windows.RoutedEvent" Usage="System.Windows.FrameworkContentElement.LoadedEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="891c2-421">标识 <see cref="E:System.Windows.FrameworkContentElement.Loaded" /> [路由事件概述](~/docs/framework/wpf/advanced/routed-events-overview.md)。</span>
          <span class="sxs-lookup">
            <span data-stu-id="891c2-421">Identifies the <see cref="E:System.Windows.FrameworkContentElement.Loaded" /> [Routed Events Overview](~/docs/framework/wpf/advanced/routed-events-overview.md).</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="891c2-422">在注册路由的事件时创建事件标识符对象 (请参阅<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>)，用于添加类处理程序 (请参阅<xref:System.Windows.EventManager.RegisterClassHandler%2A>)。</span><span class="sxs-lookup"><span data-stu-id="891c2-422">Event identifier objects are created when routed events are registered (see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>) and can then be used to add class handlers (see <xref:System.Windows.EventManager.RegisterClassHandler%2A>).</span></span> <span data-ttu-id="891c2-423">标识符对象包含标识名称、 所有者类型、 处理程序类型、 路由策略和用于添加事件所有者的实用工具方法。</span><span class="sxs-lookup"><span data-stu-id="891c2-423">Identifier objects contain an identifying name, owner type, handler type, routing strategy, and a utility method for adding owners for the event.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LogicalChildren">
      <MemberSignature Language="C#" Value="protected internal virtual System.Collections.IEnumerator LogicalChildren { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.IEnumerator LogicalChildren" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.LogicalChildren" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable ReadOnly Property LogicalChildren As IEnumerator" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual property System::Collections::IEnumerator ^ LogicalChildren { System::Collections::IEnumerator ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.LogicalChildren : System.Collections.IEnumerator" Usage="System.Windows.FrameworkContentElement.LogicalChildren" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="891c2-424">获取此元素的逻辑子元素的一个枚举数。</span>
          <span class="sxs-lookup">
            <span data-stu-id="891c2-424">Gets an enumerator for the logical child elements of this element.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="891c2-425">此元素的逻辑子元素的一个枚举数。</span>
          <span class="sxs-lookup">
            <span data-stu-id="891c2-425">An enumerator for logical child elements of this element.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="891c2-426">有关如何使用的详细信息<xref:System.Windows.FrameworkContentElement.LogicalChildren%2A>并<xref:System.Windows.FrameworkContentElement.AddLogicalChild%2A>，请参阅[WPF 中的树](~/docs/framework/wpf/advanced/trees-in-wpf.md)。</span><span class="sxs-lookup"><span data-stu-id="891c2-426">For more information on how to use <xref:System.Windows.FrameworkContentElement.LogicalChildren%2A> and <xref:System.Windows.FrameworkContentElement.AddLogicalChild%2A>, see [Trees in WPF](~/docs/framework/wpf/advanced/trees-in-wpf.md).</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MoveFocus">
      <MemberSignature Language="C#" Value="public override sealed bool MoveFocus (System.Windows.Input.TraversalRequest request);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool MoveFocus(class System.Windows.Input.TraversalRequest request) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.MoveFocus(System.Windows.Input.TraversalRequest)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides NotOverridable Function MoveFocus (request As TraversalRequest) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool MoveFocus(System::Windows::Input::TraversalRequest ^ request);" />
      <MemberSignature Language="F#" Value="override this.MoveFocus : System.Windows.Input.TraversalRequest -&gt; bool" Usage="frameworkContentElement.MoveFocus request" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="request" Type="System.Windows.Input.TraversalRequest" />
      </Parameters>
      <Docs>
        <param name="request">
          <span data-ttu-id="891c2-427">焦点要移动的方向，作为一个枚举值。</span>
          <span class="sxs-lookup">
            <span data-stu-id="891c2-427">The direction that focus is to be moved, as a value of the enumeration.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="891c2-428">将键盘焦点从此元素移到另一个元素。</span>
          <span class="sxs-lookup">
            <span data-stu-id="891c2-428">Moves the keyboard focus from this element to another element.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="891c2-429">如果焦点成功移动，则返回 <see langword="true" />；如果指定方向上的目标元素不存在，则返回 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="891c2-429">Returns <see langword="true" /> if focus is moved successfully; <see langword="false" /> if the target element in direction as specified does not exist.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.ContentElement.MoveFocus(System.Windows.Input.TraversalRequest)" />
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public string Name { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.Name" />
      <MemberSignature Language="VB.NET" Value="Public Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Name { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Name : string with get, set" Usage="System.Windows.FrameworkContentElement.Name" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.IFrameworkInputElement.Name</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.MergableProperty(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.NeverLocalize)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="891c2-430">获取或设置元素的标识名称。</span>
          <span class="sxs-lookup">
            <span data-stu-id="891c2-430">Gets or sets the identifying name of the element.</span>
          </span>
          <span data-ttu-id="891c2-431">该名称提供实例引用，以便编程代码隐藏（如事件处理程序代码）可以引用曾在 [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] 的分析过程中构造的元素。</span>
          <span class="sxs-lookup">
            <span data-stu-id="891c2-431">The name provides an instance reference so that programmatic code-behind, such as event handler code, can refer to an element once it is constructed during parsing of [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="891c2-432">元素的名称。</span>
          <span class="sxs-lookup">
            <span data-stu-id="891c2-432">The name of the element.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="891c2-433">此属性的最常见用法是指定时[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]标记中的元素名称。</span><span class="sxs-lookup"><span data-stu-id="891c2-433">The most common usage of this property is when specifying a [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] element name in markup.</span></span>  
  
 <span data-ttu-id="891c2-434">此属性实质上是提供一个 WPF 框架级便捷属性来设置[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] [X:name 指令](~/docs/framework/xaml-services/x-name-directive.md)。</span><span class="sxs-lookup"><span data-stu-id="891c2-434">This property essentially provides a WPF framework-level convenience property to set the [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] [x:Name Directive](~/docs/framework/xaml-services/x-name-directive.md).</span></span>  
  
 <span data-ttu-id="891c2-435">获取<xref:System.Windows.FrameworkContentElement.Name%2A>从代码并不常用，因为如果已在代码中具有适当的引用，只需调用方法和属性在元素上的引用且通常并不需要<xref:System.Windows.FrameworkContentElement.Name%2A>。</span><span class="sxs-lookup"><span data-stu-id="891c2-435">Getting a <xref:System.Windows.FrameworkContentElement.Name%2A> from code is not common, because if you have the appropriate reference in code already, you can just call methods and properties on the element reference and do not generally need the <xref:System.Windows.FrameworkContentElement.Name%2A>.</span></span> <span data-ttu-id="891c2-436">例外情况是字符串具有某些重载的含义，例如用于中显示该名称是否[!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)]。</span><span class="sxs-lookup"><span data-stu-id="891c2-436">An exception is if the string has some overloaded meaning, for instance if it is useful to display that name in [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)].</span></span> <span data-ttu-id="891c2-437">设置<xref:System.Windows.FrameworkContentElement.Name%2A>从代码如果原始<xref:System.Windows.FrameworkContentElement.Name%2A>已从标记中的设置也不建议，并更改该属性不会更改的对象引用。</span><span class="sxs-lookup"><span data-stu-id="891c2-437">Setting a <xref:System.Windows.FrameworkContentElement.Name%2A> from code if the original <xref:System.Windows.FrameworkContentElement.Name%2A> was set from markup is also not recommended, and changing the property will not change the object reference.</span></span> <span data-ttu-id="891c2-438">仅当过程中显式创建基础名称范围时，会创建此类对象引用[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]加载。</span><span class="sxs-lookup"><span data-stu-id="891c2-438">Such object references are created only when the underlying namescopes are explicitly created during [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] loading.</span></span>  
  
 <span data-ttu-id="891c2-439">具体而言，必须调用<xref:System.Windows.FrameworkContentElement.RegisterName%2A>以进行有效的更改上<xref:System.Windows.FrameworkContentElement.Name%2A>已加载元素的属性。</span><span class="sxs-lookup"><span data-stu-id="891c2-439">You must specifically call <xref:System.Windows.FrameworkContentElement.RegisterName%2A> to make an effective change on the <xref:System.Windows.FrameworkContentElement.Name%2A> property of an already loaded element.</span></span>  
  
 <span data-ttu-id="891c2-440">一个值得一提设置情况<xref:System.Windows.FrameworkContentElement.Name%2A>从代码很重要是用于对运行演示图板将命名元素。</span><span class="sxs-lookup"><span data-stu-id="891c2-440">One notable case where setting <xref:System.Windows.FrameworkContentElement.Name%2A> from  code is important is for naming elements that storyboards will run against.</span></span> <span data-ttu-id="891c2-441">可以注册名称之前，可能还需要实例化并分配<xref:System.Windows.NameScope>实例。</span><span class="sxs-lookup"><span data-stu-id="891c2-441">Before you can register a name, might also need to instantiate and assign a <xref:System.Windows.NameScope> instance.</span></span> <span data-ttu-id="891c2-442">请参阅示例部分中，或[情节提要概述](~/docs/framework/wpf/graphics-multimedia/storyboards-overview.md)。</span><span class="sxs-lookup"><span data-stu-id="891c2-442">See the Example section, or [Storyboards Overview](~/docs/framework/wpf/graphics-multimedia/storyboards-overview.md).</span></span>  
  
 <span data-ttu-id="891c2-443">设置<xref:System.Windows.FrameworkContentElement.Name%2A>从代码具有有限的应用程序，但按名称查找元素，则更容易，尤其是当采用一种导航模型的页面重新加载到应用程序和运行时代码不一定是的代码隐藏相应的页。</span><span class="sxs-lookup"><span data-stu-id="891c2-443">Setting <xref:System.Windows.FrameworkContentElement.Name%2A> from code has limited applications, but looking up an element by name is more common, particularly if you are employing a navigation model where pages reload into the application and the run-time code is not necessarily the code-behind of that respective page.</span></span> <span data-ttu-id="891c2-444">实用程序方法<xref:System.Windows.FrameworkContentElement.FindName%2A>，这是可从任何<xref:System.Windows.FrameworkContentElement>，可以找到的任何元素<xref:System.Windows.FrameworkContentElement.Name%2A>中该元素的逻辑树以递归方式。</span><span class="sxs-lookup"><span data-stu-id="891c2-444">The utility method <xref:System.Windows.FrameworkContentElement.FindName%2A>, which is available from any <xref:System.Windows.FrameworkContentElement>, can find any element by <xref:System.Windows.FrameworkContentElement.Name%2A> in that element's logical tree recursively.</span></span> <span data-ttu-id="891c2-445">也可以使用<xref:System.Windows.LogicalTreeHelper.FindLogicalNode%2A>的静态方法<xref:System.Windows.LogicalTreeHelper>，其还会<xref:System.Windows.FrameworkContentElement.Name%2A>字符串作为参数。</span><span class="sxs-lookup"><span data-stu-id="891c2-445">Or you can use the <xref:System.Windows.LogicalTreeHelper.FindLogicalNode%2A> static method of <xref:System.Windows.LogicalTreeHelper>, which also takes the <xref:System.Windows.FrameworkContentElement.Name%2A> string as an argument.</span></span>  
  
 <span data-ttu-id="891c2-446">常用根元素 (<xref:System.Windows.Window>，<xref:System.Windows.Controls.Page>例如) 实现该接口<xref:System.Windows.Markup.INameScope>。</span><span class="sxs-lookup"><span data-stu-id="891c2-446">Commonly used root elements (<xref:System.Windows.Window>, <xref:System.Windows.Controls.Page> for example) implement the interface <xref:System.Windows.Markup.INameScope>.</span></span> <span data-ttu-id="891c2-447">此接口的实现需要强制实施的名称会明确其作用域内。</span><span class="sxs-lookup"><span data-stu-id="891c2-447">Implementations of this interface are expected to enforce that names be unambiguous within their scope.</span></span>  
  
<a name="dependencyPropertyInfo_Name"></a>   
## <a name="dependency-property-information"></a><span data-ttu-id="891c2-448">依赖项属性信息</span><span class="sxs-lookup"><span data-stu-id="891c2-448">Dependency Property Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="891c2-449">标识符字段</span><span class="sxs-lookup"><span data-stu-id="891c2-449">Identifier field</span></span>|<xref:System.Windows.FrameworkContentElement.NameProperty>|  
|<span data-ttu-id="891c2-450">元数据属性设置为 `true`</span><span class="sxs-lookup"><span data-stu-id="891c2-450">Metadata properties set to `true`</span></span>|<xref:System.Windows.UIPropertyMetadata.IsAnimationProhibited%2A>|  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.NameScope" />
      </Docs>
    </Member>
    <Member MemberName="NameProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty NameProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty NameProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.NameProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly NameProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ NameProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable NameProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkContentElement.NameProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="891c2-451">标识 <see cref="P:System.Windows.FrameworkContentElement.Name" /> 依赖属性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="891c2-451">Identifies the <see cref="P:System.Windows.FrameworkContentElement.Name" /> dependency property.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnContextMenuClosing">
      <MemberSignature Language="C#" Value="protected virtual void OnContextMenuClosing (System.Windows.Controls.ContextMenuEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnContextMenuClosing(class System.Windows.Controls.ContextMenuEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.OnContextMenuClosing(System.Windows.Controls.ContextMenuEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnContextMenuClosing (e As ContextMenuEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnContextMenuClosing(System::Windows::Controls::ContextMenuEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnContextMenuClosing : System.Windows.Controls.ContextMenuEventArgs -&gt; unit&#xA;override this.OnContextMenuClosing : System.Windows.Controls.ContextMenuEventArgs -&gt; unit" Usage="frameworkContentElement.OnContextMenuClosing e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Controls.ContextMenuEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="891c2-452">提供与事件有关的数据。</span>
          <span class="sxs-lookup">
            <span data-stu-id="891c2-452">Provides data about the event.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="891c2-453">每当 <see cref="E:System.Windows.FrameworkContentElement.ContextMenuClosing" /> 路由事件在其路由中到达此类时调用。</span>
          <span class="sxs-lookup">
            <span data-stu-id="891c2-453">Invoked whenever the <see cref="E:System.Windows.FrameworkContentElement.ContextMenuClosing" /> routed event reaches this class in its route.</span>
          </span>
          <span data-ttu-id="891c2-454">实现此方法可为此事件添加类处理。</span>
          <span class="sxs-lookup">
            <span data-stu-id="891c2-454">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="891c2-455">此方法具有默认实现。</span><span class="sxs-lookup"><span data-stu-id="891c2-455">This method has no default implementation.</span></span> <span data-ttu-id="891c2-456">继承中的中间类已经实现了此方法的情况下，仍应调用基实现。</span><span class="sxs-lookup"><span data-stu-id="891c2-456">You should still call the base implementation in case an intermediate class in the inheritance has implemented this method.</span></span>  
  
 <span data-ttu-id="891c2-457">此方法的目的是某种程度上类似于[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]事件模式 On \* 方法： 它提供了方法来处理从派生类的类处理程序而不是实例处理程序匹配的事件。</span><span class="sxs-lookup"><span data-stu-id="891c2-457">The purpose of this method is somewhat similar to [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: it provides the means to handle the matching event from derived classes with a class handler instead of an instance handler.</span></span> <span data-ttu-id="891c2-458">在这种情况下匹配事件是路由的事件。</span><span class="sxs-lookup"><span data-stu-id="891c2-458">In this case the matching event is a routed event.</span></span> <span data-ttu-id="891c2-459">On \* 方法的实现模式是不同的路由事件，因为路由的事件可能由子元素，不一定是将调用处理程序的元素引发。</span><span class="sxs-lookup"><span data-stu-id="891c2-459">The implementation pattern of the On\* methods is different for routed events because the routed event may have been raised by a child element, not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="891c2-460">因此，您的实现必须考虑该事件参数的源属性 （并且不应尝试重新引发该事件在大多数情况下）。</span><span class="sxs-lookup"><span data-stu-id="891c2-460">Therefore, your implementation will have to take the event arguments' source properties into account (and should not try to re-raise the event in most cases).</span></span> <span data-ttu-id="891c2-461">子类<xref:System.Windows.FrameworkContentElement>无法选择路由收到事件时调用私有类处理程序方法。</span><span class="sxs-lookup"><span data-stu-id="891c2-461">Subclasses of <xref:System.Windows.FrameworkContentElement> could choose to call private class handler methods when the event is received along the route.</span></span> <span data-ttu-id="891c2-462">一个可能的方案是采用的事件自变量并谨慎地将事件标记为已处理来缩短路由。</span><span class="sxs-lookup"><span data-stu-id="891c2-462">One potential scenario is to take the arguments of the event and deliberately mark the event as handled to shorten the route.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnContextMenuOpening">
      <MemberSignature Language="C#" Value="protected virtual void OnContextMenuOpening (System.Windows.Controls.ContextMenuEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnContextMenuOpening(class System.Windows.Controls.ContextMenuEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.OnContextMenuOpening(System.Windows.Controls.ContextMenuEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnContextMenuOpening (e As ContextMenuEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnContextMenuOpening(System::Windows::Controls::ContextMenuEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnContextMenuOpening : System.Windows.Controls.ContextMenuEventArgs -&gt; unit&#xA;override this.OnContextMenuOpening : System.Windows.Controls.ContextMenuEventArgs -&gt; unit" Usage="frameworkContentElement.OnContextMenuOpening e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Controls.ContextMenuEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="891c2-463">事件的事件数据。</span>
          <span class="sxs-lookup">
            <span data-stu-id="891c2-463">Event data for the event.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="891c2-464">每当 <see cref="E:System.Windows.FrameworkContentElement.ContextMenuOpening" /> 路由事件在其路由中到达此类时调用。</span>
          <span class="sxs-lookup">
            <span data-stu-id="891c2-464">Invoked whenever the <see cref="E:System.Windows.FrameworkContentElement.ContextMenuOpening" /> routed event reaches this class in its route.</span>
          </span>
          <span data-ttu-id="891c2-465">实现此方法可为此事件添加类处理。</span>
          <span class="sxs-lookup">
            <span data-stu-id="891c2-465">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="891c2-466">此方法具有默认实现。</span><span class="sxs-lookup"><span data-stu-id="891c2-466">This method has no default implementation.</span></span> <span data-ttu-id="891c2-467">继承中的中间类已经实现了此方法的情况下，仍应调用 base （）。</span><span class="sxs-lookup"><span data-stu-id="891c2-467">You should still call base() in case an intermediate class in the inheritance has implemented this method.</span></span>  
  
 <span data-ttu-id="891c2-468">此方法的目的是某种程度上类似于[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]事件模式 On \* 方法： 它提供了方法来处理从派生类的类处理程序而不是实例处理程序匹配的事件。</span><span class="sxs-lookup"><span data-stu-id="891c2-468">The purpose of this method is somewhat similar to [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: it provides the means to handle the matching event from derived classes with a class handler instead of an instance handler.</span></span> <span data-ttu-id="891c2-469">在这种情况下匹配事件是路由的事件。</span><span class="sxs-lookup"><span data-stu-id="891c2-469">In this case the matching event is a routed event.</span></span> <span data-ttu-id="891c2-470">On \* 方法的实现模式是不同的路由事件，因为路由的事件可能由子元素，不一定是将调用处理程序，因此您的实现将需要采取的事件参数的源的元素引发将属性转换为帐户 （和不应尝试重新引发该事件在大多数情况下）。</span><span class="sxs-lookup"><span data-stu-id="891c2-470">The implementation pattern of the On\* methods is different for routed events because the routed event may have been raised by a child element, not necessarily the element that will invoke handlers, so your implementation will have to take the event arguments' source properties into account (and should not try to re-raise the event in most cases).</span></span> <span data-ttu-id="891c2-471">子类<xref:System.Windows.FrameworkContentElement>无法选择路由收到事件时调用私有类处理程序方法。</span><span class="sxs-lookup"><span data-stu-id="891c2-471">Subclasses of <xref:System.Windows.FrameworkContentElement> could choose to call private class handler methods when the event is received along the route.</span></span> <span data-ttu-id="891c2-472">一个可能的方案是采用的事件自变量并谨慎地将事件标记为已处理来缩短路由。</span><span class="sxs-lookup"><span data-stu-id="891c2-472">One potential scenario is to take the arguments of the event and deliberately mark the event as handled to shorten the route.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnGotFocus">
      <MemberSignature Language="C#" Value="protected override void OnGotFocus (System.Windows.RoutedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnGotFocus(class System.Windows.RoutedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.OnGotFocus(System.Windows.RoutedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnGotFocus (e As RoutedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnGotFocus(System::Windows::RoutedEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnGotFocus : System.Windows.RoutedEventArgs -&gt; unit" Usage="frameworkContentElement.OnGotFocus e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.RoutedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="891c2-473">事件的事件数据。</span>
          <span class="sxs-lookup">
            <span data-stu-id="891c2-473">Event data for the event.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="891c2-474">
            <see cref="E:System.Windows.ContentElement.GotFocus" /> 事件的类处理程序。</span>
          <span class="sxs-lookup">
            <span data-stu-id="891c2-474">Class handler for the <see cref="E:System.Windows.ContentElement.GotFocus" /> event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="891c2-475">如果该事件来源于此元素，此类处理程序在此元素上设置相应的焦点行为。</span><span class="sxs-lookup"><span data-stu-id="891c2-475">This class handler sets appropriate focus behavior on this element if the event originated from this element.</span></span> <span data-ttu-id="891c2-476">如果事件的源树中的另一个元素，该处理程序没有任何影响。</span><span class="sxs-lookup"><span data-stu-id="891c2-476">If the event's source was another element in the tree, the handler does nothing.</span></span>  
  
 <span data-ttu-id="891c2-477">若要更改这些默认焦点行为在元素上重写此方法。</span><span class="sxs-lookup"><span data-stu-id="891c2-477">Override this method in order to change these default focusing behavior on your element.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnInitialized">
      <MemberSignature Language="C#" Value="protected virtual void OnInitialized (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnInitialized(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.OnInitialized(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnInitialized (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnInitialized(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnInitialized : EventArgs -&gt; unit&#xA;override this.OnInitialized : EventArgs -&gt; unit" Usage="frameworkContentElement.OnInitialized e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="891c2-478">事件的事件数据。</span>
          <span class="sxs-lookup">
            <span data-stu-id="891c2-478">Event data for the event.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="891c2-479">引发 <see cref="E:System.Windows.FrameworkContentElement.Initialized" /> 事件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="891c2-479">Raises the <see cref="E:System.Windows.FrameworkContentElement.Initialized" /> event.</span>
          </span>
          <span data-ttu-id="891c2-480">只要将 <see cref="P:System.Windows.FrameworkContentElement.IsInitialized" /> 设置为 <see langword="true" />，就可以调用此方法。</span>
          <span class="sxs-lookup">
            <span data-stu-id="891c2-480">This method is invoked whenever <see cref="P:System.Windows.FrameworkContentElement.IsInitialized" /> is set to <see langword="true" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="891c2-481">本主题中前面所述，此虚拟方法的默认实现将引发事件。</span><span class="sxs-lookup"><span data-stu-id="891c2-481">The default implementation of this virtual method raises the event as described earlier in this topic.</span></span> <span data-ttu-id="891c2-482">重写应调用 base （） 以保留此行为。</span><span class="sxs-lookup"><span data-stu-id="891c2-482">Overrides should call base() to preserve this behavior.</span></span>  
  
 <span data-ttu-id="891c2-483">请注意，<xref:System.Windows.FrameworkContentElement.IsInitialized%2A>属性是只读的。</span><span class="sxs-lookup"><span data-stu-id="891c2-483">Note that the <xref:System.Windows.FrameworkContentElement.IsInitialized%2A> property is read-only.</span></span> <span data-ttu-id="891c2-484">因此，不能设置它以这种方式强制执行初始化行为。</span><span class="sxs-lookup"><span data-stu-id="891c2-484">Therefore, you cannot set it to force initialization behavior that way.</span></span> <span data-ttu-id="891c2-485">初始化设置旨在只能由[!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)]框架。</span><span class="sxs-lookup"><span data-stu-id="891c2-485">Initialization setting is intended to be done only by the [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] framework.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnPropertyChanged">
      <MemberSignature Language="C#" Value="protected override void OnPropertyChanged (System.Windows.DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnPropertyChanged(valuetype System.Windows.DependencyPropertyChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnPropertyChanged (e As DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnPropertyChanged(System::Windows::DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="F#" Value="abstract member OnPropertyChanged : System.Windows.DependencyPropertyChangedEventArgs -&gt; unit&#xA;override this.OnPropertyChanged : System.Windows.DependencyPropertyChangedEventArgs -&gt; unit" Usage="frameworkContentElement.OnPropertyChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DependencyPropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="891c2-486">描述已更改的属性的事件数据，包括旧值和新值。</span>
          <span class="sxs-lookup">
            <span data-stu-id="891c2-486">The event data that describes the property that changed, including the old and new values.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="891c2-487">每当更新此 <see cref="T:System.Windows.FrameworkContentElement" /> 上任何依赖项属性的有效值时调用。</span>
          <span class="sxs-lookup">
            <span data-stu-id="891c2-487">Invoked whenever the effective value of any dependency property on this <see cref="T:System.Windows.FrameworkContentElement" /> has been updated.</span>
          </span>
          <span data-ttu-id="891c2-488">将在实参形参中报告已更改的特定依赖属性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="891c2-488">The specific dependency property that changed is reported in the arguments parameter.</span>
          </span>
          <span data-ttu-id="891c2-489">重写 <see cref="M:System.Windows.DependencyObject.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="891c2-489">Overrides <see cref="M:System.Windows.DependencyObject.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="891c2-490">此方法不应以通常将检测到属性更改或失效。</span><span class="sxs-lookup"><span data-stu-id="891c2-490">This method is not intended to generally detect property changes or invalidations.</span></span> <span data-ttu-id="891c2-491">它改为适用于修改常规失效模式如果特定的信息了解了宽分类的属性。</span><span class="sxs-lookup"><span data-stu-id="891c2-491">It is instead intended for modifications of the general invalidation pattern if certain information is known about wide classifications of properties.</span></span>  
  
 <span data-ttu-id="891c2-492">调用此方法可能很多时候一个对象的生命周期内。</span><span class="sxs-lookup"><span data-stu-id="891c2-492">This method is potentially invoked many times during the life of an object.</span></span> <span data-ttu-id="891c2-493">因此，可以实现更好的性能，如果重写特定属性的元数据，然后将附加<xref:System.Windows.CoerceValueCallback>或<xref:System.Windows.PropertyChangedCallback>各个属性的函数。</span><span class="sxs-lookup"><span data-stu-id="891c2-493">Therefore, you can achieve better performance if you override the metadata of specific properties and then attach <xref:System.Windows.CoerceValueCallback> or <xref:System.Windows.PropertyChangedCallback> functions for individual properties.</span></span> <span data-ttu-id="891c2-494">但是，应使用此方法，如果<xref:System.Windows.FrameworkContentElement>包括大量的值相关的依赖项属性，或如果它包含逻辑，例如呈现行为，必须重新运行多个相关的属性失效的情况。</span><span class="sxs-lookup"><span data-stu-id="891c2-494">However, you would use this method if a <xref:System.Windows.FrameworkContentElement> includes a significant number of value-interrelated dependency properties, or if it includes logic such as rendering behavior that must be rerun for several related cases of property invalidations.</span></span>  
  
 <span data-ttu-id="891c2-495">请注意，没有具有相同名称`OnPropertyChanged`具有不同签名的方法 (参数类型是<xref:System.ComponentModel.PropertyChangedEventArgs>)，可能出现在多个类。</span><span class="sxs-lookup"><span data-stu-id="891c2-495">Note that there is an identically named `OnPropertyChanged` method with a different signature (the parameter type is <xref:System.ComponentModel.PropertyChangedEventArgs>) that can appear on a number of classes.</span></span> <span data-ttu-id="891c2-496">是否`OnPropertyChanged`用于数据对象通知，并且是为协定的一部分<xref:System.ComponentModel.INotifyPropertyChanged>。</span><span class="sxs-lookup"><span data-stu-id="891c2-496">That `OnPropertyChanged` is used for data object notifications, and is part of the contract for <xref:System.ComponentModel.INotifyPropertyChanged>.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <span data-ttu-id="891c2-497">始终调用基实现中，您的实现中的第一个操作。</span>
            <span class="sxs-lookup">
              <span data-stu-id="891c2-497">Always call the base implementation, as the first operation in your implementation.</span>
            </span>
            <span data-ttu-id="891c2-498">如果不这样做将大大禁用整个[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]属性系统，这会导致不正确的值报告。</span>
            <span class="sxs-lookup">
              <span data-stu-id="891c2-498">Failure to do this will significantly disable the entire [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] property system, which causes incorrect values to be reported.</span>
            </span>
          </para>
        </block>
        <altmember cref="M:System.Windows.FrameworkElement.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
        <altmember cref="M:System.Windows.DependencyObject.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnStyleChanged">
      <MemberSignature Language="C#" Value="protected internal virtual void OnStyleChanged (System.Windows.Style oldStyle, System.Windows.Style newStyle);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnStyleChanged(class System.Windows.Style oldStyle, class System.Windows.Style newStyle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.OnStyleChanged(System.Windows.Style,System.Windows.Style)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnStyleChanged (oldStyle As Style, newStyle As Style)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnStyleChanged(System::Windows::Style ^ oldStyle, System::Windows::Style ^ newStyle);" />
      <MemberSignature Language="F#" Value="abstract member OnStyleChanged : System.Windows.Style * System.Windows.Style -&gt; unit&#xA;override this.OnStyleChanged : System.Windows.Style * System.Windows.Style -&gt; unit" Usage="frameworkContentElement.OnStyleChanged (oldStyle, newStyle)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldStyle" Type="System.Windows.Style" />
        <Parameter Name="newStyle" Type="System.Windows.Style" />
      </Parameters>
      <Docs>
        <param name="oldStyle">
          <span data-ttu-id="891c2-499">旧样式。</span>
          <span class="sxs-lookup">
            <span data-stu-id="891c2-499">The old style.</span>
          </span>
        </param>
        <param name="newStyle">
          <span data-ttu-id="891c2-500">新样式。</span>
          <span class="sxs-lookup">
            <span data-stu-id="891c2-500">The new style.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="891c2-501">在此元素上使用的样式更改时调用。</span>
          <span class="sxs-lookup">
            <span data-stu-id="891c2-501">Invoked when the style that is in use on this element changes.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="891c2-502">此方法具有一个默认实现，设置一个内部标志指明样式更改条件。</span><span class="sxs-lookup"><span data-stu-id="891c2-502">This method has a default implementation that sets an internal flag noting the style changed condition.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <span data-ttu-id="891c2-503">始终调用基实现，否则不能应用样式。</span>
            <span class="sxs-lookup">
              <span data-stu-id="891c2-503">Always call the base implementation, otherwise styles cannot be applied.</span>
            </span>
            <span data-ttu-id="891c2-504">如果派生的类具有专用的样式选择器，或缓存样式值，可能会包括重写此方法的方案。</span>
            <span class="sxs-lookup">
              <span data-stu-id="891c2-504">Scenarios for overriding this method might include if your derived class has a specialized style selector, or caches style values.</span>
            </span>
            <span data-ttu-id="891c2-505">主题更改可能会调用此方法。</span>
            <span class="sxs-lookup">
              <span data-stu-id="891c2-505">Theme changes will potentially invoke this method.</span>
            </span>
          </para>
        </block>
        <altmember cref="P:System.Windows.FrameworkContentElement.Style" />
      </Docs>
    </Member>
    <Member MemberName="OnToolTipClosing">
      <MemberSignature Language="C#" Value="protected virtual void OnToolTipClosing (System.Windows.Controls.ToolTipEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnToolTipClosing(class System.Windows.Controls.ToolTipEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.OnToolTipClosing(System.Windows.Controls.ToolTipEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnToolTipClosing (e As ToolTipEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnToolTipClosing(System::Windows::Controls::ToolTipEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnToolTipClosing : System.Windows.Controls.ToolTipEventArgs -&gt; unit&#xA;override this.OnToolTipClosing : System.Windows.Controls.ToolTipEventArgs -&gt; unit" Usage="frameworkContentElement.OnToolTipClosing e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Controls.ToolTipEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="891c2-506">提供与事件有关的数据。</span>
          <span class="sxs-lookup">
            <span data-stu-id="891c2-506">Provides data about the event.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="891c2-507">每当 <see cref="E:System.Windows.FrameworkContentElement.ToolTipClosing" /> 路由事件在其路由中到达此类时调用。</span>
          <span class="sxs-lookup">
            <span data-stu-id="891c2-507">Invoked whenever the <see cref="E:System.Windows.FrameworkContentElement.ToolTipClosing" /> routed event reaches this class in its route.</span>
          </span>
          <span data-ttu-id="891c2-508">实现此方法可为此事件添加类处理。</span>
          <span class="sxs-lookup">
            <span data-stu-id="891c2-508">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="891c2-509">此方法具有默认实现。</span><span class="sxs-lookup"><span data-stu-id="891c2-509">This method has no default implementation.</span></span> <span data-ttu-id="891c2-510">继承中的中间类已经实现了此方法的情况下，仍应调用 base （）。</span><span class="sxs-lookup"><span data-stu-id="891c2-510">You should still call base() in case an intermediate class in the inheritance has implemented this method.</span></span>  
  
 <span data-ttu-id="891c2-511">此方法的目的是某种程度上类似于[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]事件模式 On \* 方法： 它提供了方法来处理从派生类的类处理程序而不是实例处理程序匹配的事件。</span><span class="sxs-lookup"><span data-stu-id="891c2-511">The purpose of this method is somewhat similar to [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: it provides the means to handle the matching event from derived classes with a class handler instead of an instance handler.</span></span> <span data-ttu-id="891c2-512">在这种情况下匹配事件是路由的事件。</span><span class="sxs-lookup"><span data-stu-id="891c2-512">In this case the matching event is a routed event.</span></span> <span data-ttu-id="891c2-513">On \* 方法的实现模式是不同的路由事件，因为路由的事件可能由子元素，不一定是将调用处理程序，因此您的实现将需要采取的事件参数的源的元素引发将属性转换为帐户 （和不应尝试重新引发该事件在大多数情况下）。</span><span class="sxs-lookup"><span data-stu-id="891c2-513">The implementation pattern of the On\* methods is different for routed events because the routed event may have been raised by a child element, not necessarily the element that will invoke handlers, so your implementation will have to take the event arguments' source properties into account (and should not try to re-raise the event in most cases).</span></span> <span data-ttu-id="891c2-514">子类<xref:System.Windows.FrameworkContentElement>无法选择路由收到事件时调用私有类处理程序方法。</span><span class="sxs-lookup"><span data-stu-id="891c2-514">Subclasses of <xref:System.Windows.FrameworkContentElement> could choose to call private class handler methods when the event is received along the route.</span></span> <span data-ttu-id="891c2-515">一个可能的方案是采用的事件自变量并谨慎地将事件标记为已处理来缩短路由。</span><span class="sxs-lookup"><span data-stu-id="891c2-515">One potential scenario is to take the arguments of the event and deliberately mark the event as handled to shorten the route.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnToolTipOpening">
      <MemberSignature Language="C#" Value="protected virtual void OnToolTipOpening (System.Windows.Controls.ToolTipEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnToolTipOpening(class System.Windows.Controls.ToolTipEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.OnToolTipOpening(System.Windows.Controls.ToolTipEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnToolTipOpening (e As ToolTipEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnToolTipOpening(System::Windows::Controls::ToolTipEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnToolTipOpening : System.Windows.Controls.ToolTipEventArgs -&gt; unit&#xA;override this.OnToolTipOpening : System.Windows.Controls.ToolTipEventArgs -&gt; unit" Usage="frameworkContentElement.OnToolTipOpening e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Controls.ToolTipEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="891c2-516">提供与事件有关的数据。</span>
          <span class="sxs-lookup">
            <span data-stu-id="891c2-516">Provides data about the event.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="891c2-517">每当 <see cref="E:System.Windows.FrameworkContentElement.ToolTipOpening" /> 路由事件在其路由中到达此类时调用。</span>
          <span class="sxs-lookup">
            <span data-stu-id="891c2-517">Invoked whenever the <see cref="E:System.Windows.FrameworkContentElement.ToolTipOpening" /> routed event reaches this class in its route.</span>
          </span>
          <span data-ttu-id="891c2-518">实现此方法可为此事件添加类处理。</span>
          <span class="sxs-lookup">
            <span data-stu-id="891c2-518">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="891c2-519">此方法具有默认实现。</span><span class="sxs-lookup"><span data-stu-id="891c2-519">This method has no default implementation.</span></span> <span data-ttu-id="891c2-520">继承中的中间类已经实现了此方法的情况下，仍应调用 base （）。</span><span class="sxs-lookup"><span data-stu-id="891c2-520">You should still call base() in case an intermediate class in the inheritance has implemented this method.</span></span>  
  
 <span data-ttu-id="891c2-521">此方法的目的是某种程度上类似于[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]事件模式 On \* 方法： 它提供了方法来处理从派生类的类处理程序而不是实例处理程序匹配的事件。</span><span class="sxs-lookup"><span data-stu-id="891c2-521">The purpose of this method is somewhat similar to [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: it provides the means to handle the matching event from derived classes with a class handler instead of an instance handler.</span></span> <span data-ttu-id="891c2-522">在这种情况下匹配事件是路由的事件。</span><span class="sxs-lookup"><span data-stu-id="891c2-522">In this case the matching event is a routed event.</span></span> <span data-ttu-id="891c2-523">On \* 方法的实现模式是不同的路由事件，因为路由的事件可能由子元素，不一定是将调用处理程序，因此您的实现将需要使事件参数的源的元素引发将属性转换为帐户 （和不应尝试重新引发该事件在大多数情况下）。</span><span class="sxs-lookup"><span data-stu-id="891c2-523">The implementation pattern of the On\* methods is different for routed events because the routed event may have been raised by a child element, not necessarily the element that will invoke handlers, so your implementation will need to take the event arguments' source properties into account (and should not try to re-raise the event in most cases).</span></span> <span data-ttu-id="891c2-524">子类<xref:System.Windows.FrameworkContentElement>无法选择路由收到事件时调用私有类处理程序方法。</span><span class="sxs-lookup"><span data-stu-id="891c2-524">Subclasses of <xref:System.Windows.FrameworkContentElement> could choose to call private class handler methods when the event is received along the route.</span></span> <span data-ttu-id="891c2-525">一个可能的方案是采用的事件自变量并谨慎地将事件标记为已处理来缩短路由。</span><span class="sxs-lookup"><span data-stu-id="891c2-525">One potential scenario is to take the arguments of the event and deliberately mark the event as handled to shorten the route.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OverridesDefaultStyle">
      <MemberSignature Language="C#" Value="public bool OverridesDefaultStyle { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool OverridesDefaultStyle" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.OverridesDefaultStyle" />
      <MemberSignature Language="VB.NET" Value="Public Property OverridesDefaultStyle As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool OverridesDefaultStyle { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.OverridesDefaultStyle : bool with get, set" Usage="System.Windows.FrameworkContentElement.OverridesDefaultStyle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="891c2-526">获取或设置一个值，该值指示此元素是否合并了主题样式的样式属性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="891c2-526">Gets or sets a value indicating whether this element incorporates style properties from theme styles.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="891c2-527">如果此元素不使用主题样式属性，则为 <see langword="true" />；所有源于样式的属性均来自本地应用程序样式，不会应用主题样式属性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="891c2-527">
              <see langword="true" /> if this element does not use theme style properties; all style-originating properties come from local application styles, and theme style properties do not apply.</span>
          </span>
          <span data-ttu-id="891c2-528">如果首先应用了应用程序样式，然后将主题样式应用于未在应用程序样式中专门设置的属性，则为 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="891c2-528">
              <see langword="false" /> if application styles apply first, and then theme styles apply for properties that were not specifically set in application styles.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="891c2-529">此属性的最常见用法是间接提供主题样式的样式资源库中使用。</span><span class="sxs-lookup"><span data-stu-id="891c2-529">The most common usage of this property is an indirect usage within the setter of a style that is supplying a themed style.</span></span>  
  
<a name="dependencyPropertyInfo_OverridesDefaultStyle"></a>   
## <a name="dependency-property-information"></a><span data-ttu-id="891c2-530">依赖项属性信息</span><span class="sxs-lookup"><span data-stu-id="891c2-530">Dependency Property Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="891c2-531">标识符字段</span><span class="sxs-lookup"><span data-stu-id="891c2-531">Identifier field</span></span>|<xref:System.Windows.FrameworkContentElement.OverridesDefaultStyleProperty>|  
|<span data-ttu-id="891c2-532">元数据属性设置为 `true`</span><span class="sxs-lookup"><span data-stu-id="891c2-532">Metadata properties set to `true`</span></span>|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.FrameworkContentElement.DefaultStyleKey" />
      </Docs>
    </Member>
    <Member MemberName="OverridesDefaultStyleProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty OverridesDefaultStyleProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty OverridesDefaultStyleProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.OverridesDefaultStyleProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly OverridesDefaultStyleProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ OverridesDefaultStyleProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable OverridesDefaultStyleProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkContentElement.OverridesDefaultStyleProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="891c2-533">标识 <see cref="P:System.Windows.FrameworkContentElement.OverridesDefaultStyle" /> 依赖属性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="891c2-533">Identifies the <see cref="P:System.Windows.FrameworkContentElement.OverridesDefaultStyle" /> dependency property.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Parent">
      <MemberSignature Language="C#" Value="public System.Windows.DependencyObject Parent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.DependencyObject Parent" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.Parent" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Parent As DependencyObject" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::DependencyObject ^ Parent { System::Windows::DependencyObject ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Parent : System.Windows.DependencyObject" Usage="System.Windows.FrameworkContentElement.Parent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="891c2-534">获取此元素的逻辑树中的父级。</span>
          <span class="sxs-lookup">
            <span data-stu-id="891c2-534">Gets the parent in the logical tree for this element.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="891c2-535">此元素的逻辑父级。</span>
          <span class="sxs-lookup">
            <span data-stu-id="891c2-535">The logical parent for this element.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="891c2-536">请注意，具体取决于应用程序的功能，可能发生更改的元素的逻辑父级保留此属性的值将不反映所做的更改。</span><span class="sxs-lookup"><span data-stu-id="891c2-536">Note that the logical parent of an element can potentially change depending on your application functionality, and keeping the value of this property will not reflect that change.</span></span> <span data-ttu-id="891c2-537">需要它之前，通常应获取的值。</span><span class="sxs-lookup"><span data-stu-id="891c2-537">You typically should get the value immediately before you need it.</span></span>  
  
 <span data-ttu-id="891c2-538">请参阅[WPF 中的树](~/docs/framework/wpf/advanced/trees-in-wpf.md)有关遍历逻辑树和方案其中采用针对元素发现这种方法相应的详细信息。</span><span class="sxs-lookup"><span data-stu-id="891c2-538">See [Trees in WPF](~/docs/framework/wpf/advanced/trees-in-wpf.md) for more information about traversing logical trees, and the scenarios where taking this approach towards element discovery is appropriate.</span></span>  
  
 <span data-ttu-id="891c2-539">属性系统将后可能重新计算所有属性值的元素父级，因为某些属性继承值到逻辑树。</span><span class="sxs-lookup"><span data-stu-id="891c2-539">The property system will potentially recalculate all property values of an element when it is reparented, because some properties inherit values through the logical tree.</span></span> <span data-ttu-id="891c2-540"><xref:System.Windows.FrameworkContentElement.DataContext%2A>适用于绑定可以还元素的父级更改。</span><span class="sxs-lookup"><span data-stu-id="891c2-540">The <xref:System.Windows.FrameworkContentElement.DataContext%2A> that applies for bindings can also change when elements are reparented.</span></span>  
  
 <span data-ttu-id="891c2-541">更改元素的父级通常只能通过集合的操作，通过使用专用添加或删除方法，或通过设置内容属性的元素。</span><span class="sxs-lookup"><span data-stu-id="891c2-541">Changing an element's parent is typically only done through manipulation of collections, by using dedicated add or remove methods, or through setting content properties of elements.</span></span>  
  
 <span data-ttu-id="891c2-542">使用的最典型情形<xref:System.Windows.FrameworkContentElement.Parent%2A>属性将获取的引用，然后获取各种<xref:System.Windows.FrameworkContentElement>从父对象的属性值。</span><span class="sxs-lookup"><span data-stu-id="891c2-542">The most typical scenario for using the <xref:System.Windows.FrameworkContentElement.Parent%2A> property is to obtain a reference and then get various <xref:System.Windows.FrameworkContentElement> property values from the parent.</span></span> <span data-ttu-id="891c2-543">对于模板，<xref:System.Windows.FrameworkContentElement.Parent%2A>模板的最终将`null`。</span><span class="sxs-lookup"><span data-stu-id="891c2-543">For templates, the <xref:System.Windows.FrameworkContentElement.Parent%2A> of the template eventually will be `null`.</span></span> <span data-ttu-id="891c2-544">若要忽略这一点并扩展到实际应用了模板的逻辑树，请使用<xref:System.Windows.FrameworkContentElement.TemplatedParent%2A>。</span><span class="sxs-lookup"><span data-stu-id="891c2-544">To get past this point and extend into the logical tree where the template is actually applied, use <xref:System.Windows.FrameworkContentElement.TemplatedParent%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="891c2-545">以下示例检查以查看是否<xref:System.Windows.FrameworkContentElement.Parent%2A>的<xref:System.Windows.Documents.TextPointer>的特定类型。</span><span class="sxs-lookup"><span data-stu-id="891c2-545">The following example checks to see whether the <xref:System.Windows.FrameworkContentElement.Parent%2A> of a <xref:System.Windows.Documents.TextPointer> is of a particular type.</span></span>  
  
 [!code-csharp[TextPointer_snippets#FCEParent](~/samples/snippets/csharp/VS_Snippets_Wpf/TextPointer_Snippets/CSharp/Window1.xaml.cs#fceparent)]
 [!code-vb[TextPointer_snippets#FCEParent](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextPointer_Snippets/visualbasic/window1.xaml.vb#fceparent)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.FrameworkContentElement.TemplatedParent" />
      </Docs>
    </Member>
    <Member MemberName="PredictFocus">
      <MemberSignature Language="C#" Value="public override sealed System.Windows.DependencyObject PredictFocus (System.Windows.Input.FocusNavigationDirection direction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Windows.DependencyObject PredictFocus(valuetype System.Windows.Input.FocusNavigationDirection direction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.PredictFocus(System.Windows.Input.FocusNavigationDirection)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides NotOverridable Function PredictFocus (direction As FocusNavigationDirection) As DependencyObject" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Windows::DependencyObject ^ PredictFocus(System::Windows::Input::FocusNavigationDirection direction);" />
      <MemberSignature Language="F#" Value="override this.PredictFocus : System.Windows.Input.FocusNavigationDirection -&gt; System.Windows.DependencyObject" Usage="frameworkContentElement.PredictFocus direction" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="direction" Type="System.Windows.Input.FocusNavigationDirection" />
      </Parameters>
      <Docs>
        <param name="direction">
          <span data-ttu-id="891c2-546">应确定其预期焦点更改的方向。</span>
          <span class="sxs-lookup">
            <span data-stu-id="891c2-546">The direction for which a prospective focus change should be determined.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="891c2-547">根据提供的焦点移动方向，确定在此元素之后接收焦点的下一个元素，但不实际移动焦点。</span>
          <span class="sxs-lookup">
            <span data-stu-id="891c2-547">Determines the next element that would receive focus relative to this element for a provided focus movement direction, but does not actually move the focus.</span>
          </span>
          <span data-ttu-id="891c2-548">此方法是密封的，不能对其进行重写。</span>
          <span class="sxs-lookup">
            <span data-stu-id="891c2-548">This method is sealed and cannot be overridden.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="891c2-549">如果实际遍历了焦点，则为焦点将要移到的下一个元素。</span>
          <span class="sxs-lookup">
            <span data-stu-id="891c2-549">The next element that focus would move to if focus were actually traversed.</span>
          </span>
          <span data-ttu-id="891c2-550">如果焦点不能按提供的方向相对于此元素移动，则可能返回 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="891c2-550">May return <see langword="null" /> if focus cannot be moved relative to this element for the provided direction.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="891c2-551"><xref:System.Windows.FrameworkContentElement.MoveFocus%2A> 是实际移动焦点的相关的方法。</span><span class="sxs-lookup"><span data-stu-id="891c2-551"><xref:System.Windows.FrameworkContentElement.MoveFocus%2A> is the related method that actually does move focus.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <span data-ttu-id="891c2-552">在 <see cref="T:System.Windows.Input.TraversalRequest" /> 中指定了以下方向之一：<see cref="F:System.Windows.Input.FocusNavigationDirection.Next" />、<see cref="F:System.Windows.Input.FocusNavigationDirection.Previous" />、<see cref="F:System.Windows.Input.FocusNavigationDirection.First" />、<see cref="F:System.Windows.Input.FocusNavigationDirection.Last" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="891c2-552">Specified one of the following directions in the <see cref="T:System.Windows.Input.TraversalRequest" />: <see cref="F:System.Windows.Input.FocusNavigationDirection.Next" />, <see cref="F:System.Windows.Input.FocusNavigationDirection.Previous" />, <see cref="F:System.Windows.Input.FocusNavigationDirection.First" />, <see cref="F:System.Windows.Input.FocusNavigationDirection.Last" />.</span>
          </span>
          <span data-ttu-id="891c2-553">对于 <see cref="M:System.Windows.FrameworkContentElement.PredictFocus(System.Windows.Input.FocusNavigationDirection)" /> 来说，这些方向是非法的（但对于 <see cref="M:System.Windows.FrameworkContentElement.MoveFocus(System.Windows.Input.TraversalRequest)" /> 来说是合法的）。</span>
          <span class="sxs-lookup">
            <span data-stu-id="891c2-553">These directions are not legal for <see cref="M:System.Windows.FrameworkContentElement.PredictFocus(System.Windows.Input.FocusNavigationDirection)" /> (but they are legal for <see cref="M:System.Windows.FrameworkContentElement.MoveFocus(System.Windows.Input.TraversalRequest)" />).</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="RegisterName">
      <MemberSignature Language="C#" Value="public void RegisterName (string name, object scopedElement);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterName(string name, object scopedElement) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.RegisterName(System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RegisterName (name As String, scopedElement As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterName(System::String ^ name, System::Object ^ scopedElement);" />
      <MemberSignature Language="F#" Value="member this.RegisterName : string * obj -&gt; unit" Usage="frameworkContentElement.RegisterName (name, scopedElement)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="scopedElement" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="891c2-554">要在指定的名称-对象映射中使用的名称。</span>
          <span class="sxs-lookup">
            <span data-stu-id="891c2-554">Name to use for the specified name-object mapping.</span>
          </span>
        </param>
        <param name="scopedElement">
          <span data-ttu-id="891c2-555">映射的对象。</span>
          <span class="sxs-lookup">
            <span data-stu-id="891c2-555">Object for the mapping.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="891c2-556">提供一个可简化对 <see cref="T:System.Windows.NameScope" /> 注册方法访问的访问器。</span>
          <span class="sxs-lookup">
            <span data-stu-id="891c2-556">Provides an accessor that simplifies access to the <see cref="T:System.Windows.NameScope" /> registration method.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="891c2-557">此方法是调用的便捷方法<xref:System.Windows.NameScope.RegisterName%2A>。</span><span class="sxs-lookup"><span data-stu-id="891c2-557">This method is a convenience method for calling <xref:System.Windows.NameScope.RegisterName%2A>.</span></span> <span data-ttu-id="891c2-558">该实现将检查后续父元素，直到它找到的适用<xref:System.Windows.NameScope>实现，它可以通过查找的元素，实现<xref:System.Windows.Markup.INameScope>。</span><span class="sxs-lookup"><span data-stu-id="891c2-558">The implementation will check successive parent elements until it finds the applicable <xref:System.Windows.NameScope> implementation, which is found by finding an element that implements <xref:System.Windows.Markup.INameScope>.</span></span> <span data-ttu-id="891c2-559">有关名称范围的详细信息，请参阅[WPF XAML 名称范围](~/docs/framework/wpf/advanced/wpf-xaml-namescopes.md)。</span><span class="sxs-lookup"><span data-stu-id="891c2-559">For more information about namescopes, see [WPF XAML Namescopes](~/docs/framework/wpf/advanced/wpf-xaml-namescopes.md).</span></span>  
  
 <span data-ttu-id="891c2-560">调用<xref:System.Windows.FrameworkContentElement.RegisterName%2A>为正确挂钩的应用程序时在代码中创建动画演示图板是必需的。</span><span class="sxs-lookup"><span data-stu-id="891c2-560">Calling <xref:System.Windows.FrameworkContentElement.RegisterName%2A> is necessary in order to correctly hook up animation storyboards for applications when created in code.</span></span> <span data-ttu-id="891c2-561">这是因为其中一个主要的演示图板属性<xref:System.Windows.Media.Animation.Storyboard.TargetName%2A>，使用运行时名称查找而不是要采用对目标元素的引用。</span><span class="sxs-lookup"><span data-stu-id="891c2-561">This is because one of the key storyboard properties, <xref:System.Windows.Media.Animation.Storyboard.TargetName%2A>, uses a run-time name lookup instead of being able to take a reference to a target element.</span></span> <span data-ttu-id="891c2-562">即使该元素是通过从代码引用可访问，这是如此。</span><span class="sxs-lookup"><span data-stu-id="891c2-562">This is true even if that element is accessible by reference from the code.</span></span> <span data-ttu-id="891c2-563">为什么需要注册名称的情节提要目标的详细信息，请参阅[情节提要概述](~/docs/framework/wpf/graphics-multimedia/storyboards-overview.md)。</span><span class="sxs-lookup"><span data-stu-id="891c2-563">For more information on why you need to register names for storyboard targets, see [Storyboards Overview](~/docs/framework/wpf/graphics-multimedia/storyboards-overview.md).</span></span> <span data-ttu-id="891c2-564">为内容元素的动画是比动画在控件上，不太常见[情节提要概述](~/docs/framework/wpf/graphics-multimedia/storyboards-overview.md)重点介绍控制方案。</span><span class="sxs-lookup"><span data-stu-id="891c2-564">Animations for content elements are less common than animations on controls, the [Storyboards Overview](~/docs/framework/wpf/graphics-multimedia/storyboards-overview.md) concentrates on control scenarios.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkContentElement.UnregisterName(System.String)" />
        <altmember cref="T:System.Windows.NameScope" />
      </Docs>
    </Member>
    <Member MemberName="RemoveLogicalChild">
      <MemberSignature Language="C#" Value="protected internal void RemoveLogicalChild (object child);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance void RemoveLogicalChild(object child) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.RemoveLogicalChild(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Sub RemoveLogicalChild (child As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; void RemoveLogicalChild(System::Object ^ child);" />
      <MemberSignature Language="F#" Value="member this.RemoveLogicalChild : obj -&gt; unit" Usage="frameworkContentElement.RemoveLogicalChild child" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="child" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="child">
          <span data-ttu-id="891c2-565">要移除的元素。</span>
          <span class="sxs-lookup">
            <span data-stu-id="891c2-565">The element to remove.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="891c2-566">从该元素的逻辑树中移除指定的元素。</span>
          <span class="sxs-lookup">
            <span data-stu-id="891c2-566">Removes the specified element from the logical tree for this element.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="891c2-567">这[!INCLUDE[TLA#tla_api](~/includes/tlasharptla-api-md.md)]主要适用于派生的情况下，类时添加为子集合的支持。</span><span class="sxs-lookup"><span data-stu-id="891c2-567">This [!INCLUDE[TLA#tla_api](~/includes/tlasharptla-api-md.md)] is mainly relevant for class deriving scenarios, when adding support for child collections.</span></span>  
  
 <span data-ttu-id="891c2-568">大多数<xref:System.Windows.FrameworkContentElement>派生的类公开的负责包含专用的集合 (例如，<xref:System.Windows.Documents.Span.Inlines%2A>上<xref:System.Windows.Documents.Span>类;<xref:System.Windows.Documents.Section.Blocks%2A>上<xref:System.Windows.Documents.Section>类)。</span><span class="sxs-lookup"><span data-stu-id="891c2-568">Most <xref:System.Windows.FrameworkContentElement> derived classes expose dedicated collections that are responsible for containment (for example, <xref:System.Windows.Documents.Span.Inlines%2A> on the <xref:System.Windows.Documents.Span> class; <xref:System.Windows.Documents.Section.Blocks%2A> on the <xref:System.Windows.Documents.Section> class).</span></span> <span data-ttu-id="891c2-569">派生自这些类通常可以避免无需直接操作逻辑树。</span><span class="sxs-lookup"><span data-stu-id="891c2-569">Deriving from such classes typically can avoid any need to manipulate the logical tree directly.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.LogicalTreeHelper" />
      </Docs>
    </Member>
    <Member MemberName="Resources">
      <MemberSignature Language="C#" Value="public System.Windows.ResourceDictionary Resources { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.ResourceDictionary Resources" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.Resources" />
      <MemberSignature Language="VB.NET" Value="Public Property Resources As ResourceDictionary" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::ResourceDictionary ^ Resources { System::Windows::ResourceDictionary ^ get(); void set(System::Windows::ResourceDictionary ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Resources : System.Windows.ResourceDictionary with get, set" Usage="System.Windows.FrameworkContentElement.Resources" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Windows.Markup.Ambient</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.ResourceDictionary</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="891c2-570">获取或设置当前本地定义的资源字典。</span>
          <span class="sxs-lookup">
            <span data-stu-id="891c2-570">Gets or sets the current locally-defined resource dictionary.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="891c2-571">当前本地定义的资源。</span>
          <span class="sxs-lookup">
            <span data-stu-id="891c2-571">The current locally-defined resources.</span>
          </span>
          <span data-ttu-id="891c2-572">这是一本资源字典，可通过键来访问字典中的资源。</span>
          <span class="sxs-lookup">
            <span data-stu-id="891c2-572">This is a dictionary of resources, where resources within the dictionary are accessed by key.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="891c2-573">可以完全或部分中定义的资源字典[!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)]通常创建为属性元素中，并且通常是针对任何单独的页面或应用程序的根元素上。</span><span class="sxs-lookup"><span data-stu-id="891c2-573">Resource dictionaries that can be defined completely or partially in [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)] are typically created as a property element, and are typically on the root element for any individual page or for the application.</span></span> <span data-ttu-id="891c2-574">在此级别将资源字典可以更轻松地找到从页面中的各个子元素 （或从任何页上，在应用程序的情况下）。</span><span class="sxs-lookup"><span data-stu-id="891c2-574">Placing the resource dictionary at this level makes it easier to find from individual child elements in the page (or from any page, in the application case).</span></span> <span data-ttu-id="891c2-575">在大多数应用程序方案中，我们建议样式定义为使用的资源字典中的对象元素或定义为外部资源中，以便整个样式资源可以是自包含 （此方法有助于单独设计器从开发人员的责任由分隔的物理文件，需要编辑职责）。</span><span class="sxs-lookup"><span data-stu-id="891c2-575">In most application scenarios, we recommend that styles be defined as object elements within a resource dictionary, or be defined as external resources so that the entire style resource can be self-contained (this approach helps separate designer responsibilities from developer responsibilities by separating the physical files that need to be edited).</span></span>  
  
 <span data-ttu-id="891c2-576">请注意，此属性返回该元素内直接声明仅的资源字典。</span><span class="sxs-lookup"><span data-stu-id="891c2-576">Note that this property returns only the resource dictionary declared directly within that element.</span></span> <span data-ttu-id="891c2-577">这是不同于实际资源查找过程，其中的子元素可以访问任何向上递归搜索每个父元素中定义的资源。</span><span class="sxs-lookup"><span data-stu-id="891c2-577">This is different than the actual resource lookup process, where a child element can access any of the resources defined in each parent element, searching recursively upwards.</span></span>  
  
 <span data-ttu-id="891c2-578">资源还可以通过从集合中的代码引用，但请注意在创建资源[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]绝对不可访问，直到<xref:System.Windows.FrameworkContentElement.Loaded>引起声明该字典的元素。</span><span class="sxs-lookup"><span data-stu-id="891c2-578">Resources can also be referenced by code from within the collection, but be aware that resources created in [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] will definitely not be accessible until after <xref:System.Windows.FrameworkContentElement.Loaded> is raised by the element that declares the dictionary.</span></span> <span data-ttu-id="891c2-579">实际上，资源以异步方式进行分析，甚至不能<xref:System.Windows.FrameworkContentElement.Loaded>事件是可以引用保障[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]定义资源。</span><span class="sxs-lookup"><span data-stu-id="891c2-579">In fact, resources are parsed asynchronously, and not even the <xref:System.Windows.FrameworkContentElement.Loaded> event is an assurance that you can reference a [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] defined resource.</span></span> <span data-ttu-id="891c2-580">出于此原因，通常只应访问[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]定义的资源作为的一部分运行时代码，或通过其他[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]技术，如样式或特性值的资源扩展引用。</span><span class="sxs-lookup"><span data-stu-id="891c2-580">For this reason you should generally only access [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] defined resources as part of run-time code, or through other [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] techniques such as styles or resource extension references for attribute values.</span></span> <span data-ttu-id="891c2-581">当通过代码访问资源时，它在实质上是等效于从进行的引用[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]。</span><span class="sxs-lookup"><span data-stu-id="891c2-581">When you access resources through code, it is essentially equivalent to a  reference made from [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].</span></span>  
  
 <span data-ttu-id="891c2-582">基础<xref:System.Windows.ResourceDictionary>支持添加、 删除，或通过使用代码查询从集合中的资源所需的方法。</span><span class="sxs-lookup"><span data-stu-id="891c2-582">The underlying <xref:System.Windows.ResourceDictionary> supports the methods required to add, remove, or query resources from within the collection by using code.</span></span> <span data-ttu-id="891c2-583"><xref:System.Windows.FrameworkContentElement.Resources%2A>属性是可以设置以支持此方案的完全替换的元素是一个新的或不同的资源集合<xref:System.Windows.ResourceDictionary>。</span><span class="sxs-lookup"><span data-stu-id="891c2-583">The <xref:System.Windows.FrameworkContentElement.Resources%2A> property is settable to support the scenario of completely replacing the resources collection of an element to be a new or different <xref:System.Windows.ResourceDictionary>.</span></span>  
  
 <span data-ttu-id="891c2-584">请注意，[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]所示的语法不包含的元素<xref:System.Windows.ResourceDictionary>。</span><span class="sxs-lookup"><span data-stu-id="891c2-584">Notice that the [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] syntax shown does not include an element for the <xref:System.Windows.ResourceDictionary>.</span></span> <span data-ttu-id="891c2-585">这是隐式集合语法; 的示例表示集合元素的标记，则可以省略。</span><span class="sxs-lookup"><span data-stu-id="891c2-585">This is an example of implicit collection syntax; a tag representing the collection element can be omitted.</span></span> <span data-ttu-id="891c2-586">改为指定作为项目添加到集合的元素。</span><span class="sxs-lookup"><span data-stu-id="891c2-586">The elements that are added as items to the collection are specified instead.</span></span> <span data-ttu-id="891c2-587">有关隐式集合的详细信息和[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]，请参阅[XAML 语法详述](~/docs/framework/wpf/advanced/xaml-syntax-in-detail.md)。</span><span class="sxs-lookup"><span data-stu-id="891c2-587">For more information about implicit collections and [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)], see [XAML Syntax In Detail](~/docs/framework/wpf/advanced/xaml-syntax-in-detail.md).</span></span> <span data-ttu-id="891c2-588">一种情况下，<xref:System.Windows.ResourceDictionary>元素是引入合并的字典，这种情况下是否存在通常没有子元素，如仍指定显式<xref:System.Windows.ResourceDictionary>。</span><span class="sxs-lookup"><span data-stu-id="891c2-588">One case where a <xref:System.Windows.ResourceDictionary> is still specified explicitly as an element is if you are introducing a merged dictionary, in which case there are typically no child elements for that <xref:System.Windows.ResourceDictionary>.</span></span> <span data-ttu-id="891c2-589">有关详细信息，请参阅[合并资源字典](~/docs/framework/wpf/advanced/merged-resource-dictionaries.md)。</span><span class="sxs-lookup"><span data-stu-id="891c2-589">For details, see [Merged Resource Dictionaries](~/docs/framework/wpf/advanced/merged-resource-dictionaries.md).</span></span>  
  
<a name="xamlPropertyElementUsage_Resources"></a>   
## <a name="xaml-property-element-usage"></a><span data-ttu-id="891c2-590">XAML 属性元素用法</span><span class="sxs-lookup"><span data-stu-id="891c2-590">XAML Property Element Usage</span></span>  
  
```  
<object>  
  <object.Resources>  
    oneOrMoreResourceElements  
  </object.Resources>  
</object>  
```  
  
<a name="xamlValues_Resources"></a>   
## <a name="xaml-values"></a><span data-ttu-id="891c2-591">XAML 值</span><span class="sxs-lookup"><span data-stu-id="891c2-591">XAML Values</span></span>  
 <span data-ttu-id="891c2-592">*oneOrMoreResourceElements*</span><span class="sxs-lookup"><span data-stu-id="891c2-592">*oneOrMoreResourceElements*</span></span>  
 <span data-ttu-id="891c2-593">一个或多个对象元素，其中每个定义的资源。</span><span class="sxs-lookup"><span data-stu-id="891c2-593">One or more object elements, each of which defines a resource.</span></span> <span data-ttu-id="891c2-594">在每个每个资源属性元素<xref:System.Windows.ResourceDictionary>必须具有唯一值[X:key 指令](~/docs/framework/xaml-services/x-key-directive.md)，从检索值时，它可作为唯一键<xref:System.Windows.ResourceDictionary>。</span><span class="sxs-lookup"><span data-stu-id="891c2-594">Each resource property element within each <xref:System.Windows.ResourceDictionary> must have a unique value for the [x:Key Directive](~/docs/framework/xaml-services/x-key-directive.md), which serves as the unique key when values are retrieved from the <xref:System.Windows.ResourceDictionary>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="891c2-595">下面的示例建立<xref:System.Windows.FrameworkContentElement.Resources%2A>上的收集<xref:System.Windows.Documents.FlowDocument>根元素。</span><span class="sxs-lookup"><span data-stu-id="891c2-595">The following example establishes a <xref:System.Windows.FrameworkContentElement.Resources%2A> collection on a <xref:System.Windows.Documents.FlowDocument> root element.</span></span> <span data-ttu-id="891c2-596"><xref:System.Windows.Documents.FlowDocument> 是一个典型的选择，因为它是一个将少数<xref:System.Windows.FrameworkContentElement>作为根元素和资源有意义的类通常存储在页面根或更高级别的如在应用程序。</span><span class="sxs-lookup"><span data-stu-id="891c2-596"><xref:System.Windows.Documents.FlowDocument> is a typical choice because it is one of the few <xref:System.Windows.FrameworkContentElement> classes that make sense as a root element, and resources are generally stored at the page root or at even higher levels such as in the application.</span></span>  
  
 [!code-xaml[ContentElementsSmorgasbord#FCEResources](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page2.xaml#fceresources)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Application.Resources" />
      </Docs>
    </Member>
    <MemberGroup MemberName="SetBinding">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="891c2-597">为指定的依赖属性向此元素附加一个绑定。</span>
          <span class="sxs-lookup">
            <span data-stu-id="891c2-597">Attaches a binding to this element for the specified dependency property.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetBinding">
      <MemberSignature Language="C#" Value="public System.Windows.Data.BindingExpression SetBinding (System.Windows.DependencyProperty dp, string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Data.BindingExpression SetBinding(class System.Windows.DependencyProperty dp, string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.SetBinding(System.Windows.DependencyProperty,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function SetBinding (dp As DependencyProperty, path As String) As BindingExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Data::BindingExpression ^ SetBinding(System::Windows::DependencyProperty ^ dp, System::String ^ path);" />
      <MemberSignature Language="F#" Value="member this.SetBinding : System.Windows.DependencyProperty * string -&gt; System.Windows.Data.BindingExpression" Usage="frameworkContentElement.SetBinding (dp, path)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Data.BindingExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="dp">
          <span data-ttu-id="891c2-598">标识绑定属性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="891c2-598">Identifies the bound property.</span>
          </span>
        </param>
        <param name="path">
          <span data-ttu-id="891c2-599">源属性名称或用于绑定的属性的路径。</span>
          <span class="sxs-lookup">
            <span data-stu-id="891c2-599">The source property name or the path to the property used for the binding.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="891c2-600">将提供的源属性名作为数据源的路径限定，从而将绑定附加到此元素上。</span>
          <span class="sxs-lookup">
            <span data-stu-id="891c2-600">Attaches a binding to this element, based on the provided source property name as a path qualification to the data source.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="891c2-601">记录绑定的情况。</span>
          <span class="sxs-lookup">
            <span data-stu-id="891c2-601">Records the conditions of the binding.</span>
          </span>
          <span data-ttu-id="891c2-602">此返回值可用于错误检查。</span>
          <span class="sxs-lookup">
            <span data-stu-id="891c2-602">This return value can be useful for error checking.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="891c2-603">此方法是调用的便捷方法<xref:System.Windows.Data.BindingOperations.SetBinding%2A?displayProperty=nameWithType>，其中将当前实例作为传递<xref:System.Windows.DependencyObject>，并创建一个新<xref:System.Windows.Data.Binding>基于所提供`path`参数。</span><span class="sxs-lookup"><span data-stu-id="891c2-603">This method is a convenience method for calling <xref:System.Windows.Data.BindingOperations.SetBinding%2A?displayProperty=nameWithType>, which passes the current instance as the <xref:System.Windows.DependencyObject>, and creates a new <xref:System.Windows.Data.Binding> based on the provided `path` parameter.</span></span> <span data-ttu-id="891c2-604">此签名是更方便，如果您要建立一个简单的默认绑定。</span><span class="sxs-lookup"><span data-stu-id="891c2-604">This signature is more convenient if you are establishing a simple default binding.</span></span> <span data-ttu-id="891c2-605">如果你需要指定任何绑定属性为非默认条件，或者想要使用<xref:System.Windows.Data.MultiBinding>或<xref:System.Windows.Data.PriorityBinding>，则应使用<xref:System.Windows.FrameworkContentElement.SetBinding%28System.Windows.DependencyProperty%2CSystem.Windows.Data.BindingBase%29>签名。</span><span class="sxs-lookup"><span data-stu-id="891c2-605">If you need to specify any binding properties to non-default conditions, or want to use a <xref:System.Windows.Data.MultiBinding> or <xref:System.Windows.Data.PriorityBinding>,you should use the <xref:System.Windows.FrameworkContentElement.SetBinding%28System.Windows.DependencyProperty%2CSystem.Windows.Data.BindingBase%29> signature.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="891c2-606">下面的示例上设置的绑定<xref:System.Windows.Documents.Paragraph>元素中，通过创建新的自定义数据对象，该对象作为建立<xref:System.Windows.FrameworkContentElement.DataContext%2A>，并将绑定路径设置为在其中一个属性。</span><span class="sxs-lookup"><span data-stu-id="891c2-606">The following example sets a binding on a <xref:System.Windows.Documents.Paragraph> element, by creating a new custom data object, establishing that object as <xref:System.Windows.FrameworkContentElement.DataContext%2A>, and setting the binding path to a property within it.</span></span>  
  
 [!code-csharp[ContentElementsSmorgasbord#DataContext](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml.cs#datacontext)]
 [!code-vb[ContentElementsSmorgasbord#DataContext](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContentElementsSmorgasbord/visualbasic/page1.xaml.vb#datacontext)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetBinding">
      <MemberSignature Language="C#" Value="public System.Windows.Data.BindingExpressionBase SetBinding (System.Windows.DependencyProperty dp, System.Windows.Data.BindingBase binding);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Data.BindingExpressionBase SetBinding(class System.Windows.DependencyProperty dp, class System.Windows.Data.BindingBase binding) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.SetBinding(System.Windows.DependencyProperty,System.Windows.Data.BindingBase)" />
      <MemberSignature Language="VB.NET" Value="Public Function SetBinding (dp As DependencyProperty, binding As BindingBase) As BindingExpressionBase" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Data::BindingExpressionBase ^ SetBinding(System::Windows::DependencyProperty ^ dp, System::Windows::Data::BindingBase ^ binding);" />
      <MemberSignature Language="F#" Value="member this.SetBinding : System.Windows.DependencyProperty * System.Windows.Data.BindingBase -&gt; System.Windows.Data.BindingExpressionBase" Usage="frameworkContentElement.SetBinding (dp, binding)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Data.BindingExpressionBase</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="binding" Type="System.Windows.Data.BindingBase" />
      </Parameters>
      <Docs>
        <param name="dp">
          <span data-ttu-id="891c2-607">标识绑定属性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="891c2-607">Identifies the bound property.</span>
          </span>
        </param>
        <param name="binding">
          <span data-ttu-id="891c2-608">表示数据绑定。</span>
          <span class="sxs-lookup">
            <span data-stu-id="891c2-608">Represents a data binding.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="891c2-609">根据提供的绑定对象，将绑定附加到此元素上。</span>
          <span class="sxs-lookup">
            <span data-stu-id="891c2-609">Attaches a binding to this element, based on the provided binding object.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="891c2-610">记录绑定的情况。</span>
          <span class="sxs-lookup">
            <span data-stu-id="891c2-610">Records the conditions of the binding.</span>
          </span>
          <span data-ttu-id="891c2-611">此返回值可用于错误检查。</span>
          <span class="sxs-lookup">
            <span data-stu-id="891c2-611">This return value can be useful for error checking.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="891c2-612">此方法是调用的便捷方法<xref:System.Windows.Data.BindingOperations.SetBinding%2A?displayProperty=nameWithType>，其中将当前实例作为传递<xref:System.Windows.DependencyObject>。</span><span class="sxs-lookup"><span data-stu-id="891c2-612">This method is a convenience method for calling <xref:System.Windows.Data.BindingOperations.SetBinding%2A?displayProperty=nameWithType>, which passes the current instance as the <xref:System.Windows.DependencyObject>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="891c2-613">下面的示例上设置的绑定<xref:System.Windows.Documents.Paragraph>元素中的，通过创建一个新<xref:System.Windows.Data.Binding>并将源设置为新生成`DateTime`对象。</span><span class="sxs-lookup"><span data-stu-id="891c2-613">The following example sets a binding on a <xref:System.Windows.Documents.Paragraph> element, by creating a new <xref:System.Windows.Data.Binding> and setting the source to a newly built `DateTime` object.</span></span>  
  
 [!code-csharp[ContentElementsSmorgasbord#SetBinding](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml.cs#setbinding)]
 [!code-vb[ContentElementsSmorgasbord#SetBinding](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContentElementsSmorgasbord/visualbasic/page1.xaml.vb#setbinding)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetResourceReference">
      <MemberSignature Language="C#" Value="public void SetResourceReference (System.Windows.DependencyProperty dp, object name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetResourceReference(class System.Windows.DependencyProperty dp, object name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.SetResourceReference(System.Windows.DependencyProperty,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetResourceReference (dp As DependencyProperty, name As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetResourceReference(System::Windows::DependencyProperty ^ dp, System::Object ^ name);" />
      <MemberSignature Language="F#" Value="member this.SetResourceReference : System.Windows.DependencyProperty * obj -&gt; unit" Usage="frameworkContentElement.SetResourceReference (dp, name)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="name" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="dp">
          <span data-ttu-id="891c2-614">资源绑定到的属性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="891c2-614">The property to which the resource is bound.</span>
          </span>
        </param>
        <param name="name">
          <span data-ttu-id="891c2-615">资源的名称。</span>
          <span class="sxs-lookup">
            <span data-stu-id="891c2-615">The name of the resource.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="891c2-616">搜索具有指定名称的资源，并且为指定的属性设置一个指向该资源的资源引用。</span>
          <span class="sxs-lookup">
            <span data-stu-id="891c2-616">Searches for a resource with the specified name and sets up a resource reference to it for the specified property.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="891c2-617">资源引用是类似于使用[DynamicResource 标记扩展](~/docs/framework/wpf/advanced/dynamicresource-markup-extension.md)标记中。</span><span class="sxs-lookup"><span data-stu-id="891c2-617">A resource reference is similar to the use of a [DynamicResource Markup Extension](~/docs/framework/wpf/advanced/dynamicresource-markup-extension.md) in markup.</span></span> <span data-ttu-id="891c2-618">资源引用创建一个内部表达式，用于提供在运行时的延迟基础上的指定属性的值。</span><span class="sxs-lookup"><span data-stu-id="891c2-618">The resource reference creates an internal expression that supplies the value of the specified property on a run-time deferred basis.</span></span> <span data-ttu-id="891c2-619">将重新计算表达式时资源字典指示更改的值通过内部事件，或者每当重新设定当前元素 （父级更改会更改字典查找路径）。</span><span class="sxs-lookup"><span data-stu-id="891c2-619">The expression will be re-evaluated whenever the resource dictionary indicates a changed value through internal events, or whenever the current element is reparented (a parent change would change the dictionary lookup path).</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkContentElement.FindResource(System.Object)" />
        <altmember cref="P:System.Windows.Application.Resources" />
        <altmember cref="P:System.Windows.FrameworkElement.Resources" />
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeResources">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeResources ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeResources() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.ShouldSerializeResources" />
      <MemberSignature Language="VB.NET" Value="Public Function ShouldSerializeResources () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ShouldSerializeResources();" />
      <MemberSignature Language="F#" Value="member this.ShouldSerializeResources : unit -&gt; bool" Usage="frameworkContentElement.ShouldSerializeResources " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="891c2-620">返回序列化进程是否应在此类的实例上序列化 <see cref="P:System.Windows.FrameworkContentElement.Resources" /> 属性的内容。</span>
          <span class="sxs-lookup">
            <span data-stu-id="891c2-620">Returns whether serialization processes should serialize the contents of the <see cref="P:System.Windows.FrameworkContentElement.Resources" /> property on instances of this class.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="891c2-621">如果应当将 <see cref="P:System.Windows.FrameworkContentElement.Resources" /> 属性值序列化，则为 <see langword="true" />；否则为 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="891c2-621">
              <see langword="true" /> if the <see cref="P:System.Windows.FrameworkContentElement.Resources" /> property value should be serialized; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="891c2-622">这将返回`true`只要本地没有至少一个键控的资源<xref:System.Windows.FrameworkContentElement.Resources%2A>。</span><span class="sxs-lookup"><span data-stu-id="891c2-622">This will return `true` so long as there is at least one keyed resource in the local <xref:System.Windows.FrameworkContentElement.Resources%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeStyle">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeStyle ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeStyle() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.ShouldSerializeStyle" />
      <MemberSignature Language="VB.NET" Value="Public Function ShouldSerializeStyle () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ShouldSerializeStyle();" />
      <MemberSignature Language="F#" Value="member this.ShouldSerializeStyle : unit -&gt; bool" Usage="frameworkContentElement.ShouldSerializeStyle " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="891c2-623">返回序列化进程是否应在此类的实例上序列化 <see cref="P:System.Windows.FrameworkContentElement.Style" /> 属性的内容。</span>
          <span class="sxs-lookup">
            <span data-stu-id="891c2-623">Returns whether serialization processes should serialize the contents of the <see cref="P:System.Windows.FrameworkContentElement.Style" /> property on instances of this class.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="891c2-624">如果应当将 <see cref="P:System.Windows.FrameworkContentElement.Style" /> 属性值序列化，则为 <see langword="true" />；否则为 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="891c2-624">
              <see langword="true" /> if the <see cref="P:System.Windows.FrameworkContentElement.Style" /> property value should be serialized; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="891c2-625">这将返回`true`如果<xref:System.Windows.Style>本地设置。</span><span class="sxs-lookup"><span data-stu-id="891c2-625">This will return `true` if the <xref:System.Windows.Style> is locally set.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SourceUpdated">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt; SourceUpdated;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Data.DataTransferEventArgs&gt; SourceUpdated" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkContentElement.SourceUpdated" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event SourceUpdated As EventHandler(Of DataTransferEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Windows::Data::DataTransferEventArgs ^&gt; ^ SourceUpdated;" />
      <MemberSignature Language="F#" Value="member this.SourceUpdated : EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt; " Usage="member this.SourceUpdated : System.EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="891c2-626">当参与此元素上的绑定的任意关联数据源更改时发生。</span>
          <span class="sxs-lookup">
            <span data-stu-id="891c2-626">Occurs when any associated data source participating in a binding on this element changes.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="891c2-627">此事件图面<xref:System.Windows.Data.Binding.SourceUpdated>引发的任何事件<xref:System.Windows.Data.Binding>与此元素关联。</span><span class="sxs-lookup"><span data-stu-id="891c2-627">This event surfaces the <xref:System.Windows.Data.Binding.SourceUpdated> event that is raised by any <xref:System.Windows.Data.Binding> associated with this element.</span></span>  
  
<a name="xamlAttributeUsage_SourceUpdated"></a>   
## <a name="xaml-attribute-usage"></a><span data-ttu-id="891c2-628">XAML 属性用法</span><span class="sxs-lookup"><span data-stu-id="891c2-628">XAML Attribute Usage</span></span>  
  
```  
<object SourceUpdated="EventHandler"/>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Style">
      <MemberSignature Language="C#" Value="public System.Windows.Style Style { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Style Style" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.Style" />
      <MemberSignature Language="VB.NET" Value="Public Property Style As Style" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Style ^ Style { System::Windows::Style ^ get(); void set(System::Windows::Style ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Style : System.Windows.Style with get, set" Usage="System.Windows.FrameworkContentElement.Style" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Style</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="891c2-629">获取或设置此元素要使用的样式。</span>
          <span class="sxs-lookup">
            <span data-stu-id="891c2-629">Gets or sets the style to be used by this element.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="891c2-630">若存在，则为此元素适用的非默认样式。</span>
          <span class="sxs-lookup">
            <span data-stu-id="891c2-630">The applied, nondefault style for the element, if present.</span>
          </span>
          <span data-ttu-id="891c2-631">否则为 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="891c2-631">Otherwise, <see langword="null" />.</span>
          </span>
          <span data-ttu-id="891c2-632">默认情况下构造的 <see cref="T:System.Windows.FrameworkContentElement" /> 的默认值为 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="891c2-632">The default for a default-constructed <see cref="T:System.Windows.FrameworkContentElement" /> is <see langword="null" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="891c2-633">从主题设置，或从通常由资源在页面或应用程序级别 （隐式样式） 应用于该类型的对象的样式的默认样式通常提供当前样式。</span><span class="sxs-lookup"><span data-stu-id="891c2-633">The current style is often provided by a default style from theming, or from styles generally applied to objects of that type by resources at page or application level (an implicit style).</span></span> <span data-ttu-id="891c2-634">此属性不会设置或返回默认 （主题） 样式，但它确实会隐式样式或显式样式。</span><span class="sxs-lookup"><span data-stu-id="891c2-634">This property does not set or return default (theme) styles, but it does return the implicit style or an explicit style.</span></span> <span data-ttu-id="891c2-635">如果存在隐式或显式样式，并不重要是否访问作为资源或本地定义的样式。</span><span class="sxs-lookup"><span data-stu-id="891c2-635">In the case of implicit or explicit styles, it does not matter whether the style is accessed as a resource or defined locally.</span></span>  
  
 <span data-ttu-id="891c2-636">设置样式存在一些限制。</span><span class="sxs-lookup"><span data-stu-id="891c2-636">Setting the styles has some restrictions.</span></span> <span data-ttu-id="891c2-637">你可以重置整个<xref:System.Windows.FrameworkContentElement.Style%2A>属性设置为一个新<xref:System.Windows.Style>在任何时候，这将强制布局重新组合。</span><span class="sxs-lookup"><span data-stu-id="891c2-637">You can reset the entire <xref:System.Windows.FrameworkContentElement.Style%2A> property to a new <xref:System.Windows.Style> at any time, which will force a layout recomposition.</span></span> <span data-ttu-id="891c2-638">但是，一旦加载的元素，该样式放置在使用<xref:System.Windows.Style>应被视为密封。</span><span class="sxs-lookup"><span data-stu-id="891c2-638">However, as soon as that style is placed in use by a loaded element, the <xref:System.Windows.Style> should be considered sealed.</span></span> <span data-ttu-id="891c2-639">尝试对正在使用样式的任何单个属性进行更改 (如的在集合中的任何内容<xref:System.Windows.Style.Setters%2A>) 会导致引发异常。</span><span class="sxs-lookup"><span data-stu-id="891c2-639">Attempting to make a change to any individual property of an in-use style (such as anything within the collection of <xref:System.Windows.Style.Setters%2A>) causes an exception to be thrown.</span></span> <span data-ttu-id="891c2-640">在标记中定义的样式被视为一旦加载从资源字典 （适用于资源），或包含在页面加载 （适用于内联样式），可使用。</span><span class="sxs-lookup"><span data-stu-id="891c2-640">A style that is defined in markup is considered to be in use as soon as it is loaded from a resource dictionary (for resources), or the page it is contained within is loaded (for inline styles).</span></span>  
  
 <span data-ttu-id="891c2-641"><xref:System.Windows.FrameworkContentElement.Style%2A> 是具有特殊的优先顺序的依赖项属性。</span><span class="sxs-lookup"><span data-stu-id="891c2-641"><xref:System.Windows.FrameworkContentElement.Style%2A> is a dependency property with special precedence.</span></span> <span data-ttu-id="891c2-642">本地设置样式通常在进行操作的最高优先级属性系统中。</span><span class="sxs-lookup"><span data-stu-id="891c2-642">The locally set style generally operates at the highest precedence in the property system.</span></span> <span data-ttu-id="891c2-643">如果<xref:System.Windows.FrameworkContentElement.Style%2A>期间加载属性系统检查隐式样式定义指定该类型的资源作为在此情况下，为 null。</span><span class="sxs-lookup"><span data-stu-id="891c2-643">If the <xref:System.Windows.FrameworkContentElement.Style%2A> is null at this point, during loading the property system checks for implicit styles as defined resources that specify that type.</span></span> <span data-ttu-id="891c2-644">如果样式是完成此步骤后仍然为 null 则样式来自默认 （主题） 样式，但默认样式中不会返回<xref:System.Windows.FrameworkContentElement.Style%2A>属性值。</span><span class="sxs-lookup"><span data-stu-id="891c2-644">If the style is still null after this step, then the style comes from the default (theme) style, but the default style is not returned in the <xref:System.Windows.FrameworkContentElement.Style%2A> property value.</span></span> <span data-ttu-id="891c2-645">请参阅[依赖属性值优先级](~/docs/framework/wpf/advanced/dependency-property-value-precedence.md)。</span><span class="sxs-lookup"><span data-stu-id="891c2-645">See [Dependency Property Value Precedence](~/docs/framework/wpf/advanced/dependency-property-value-precedence.md).</span></span>  
  
<a name="xamlAttributeUsage_Style"></a>   
## <a name="xaml-attribute-usage"></a><span data-ttu-id="891c2-646">XAML 属性用法</span><span class="sxs-lookup"><span data-stu-id="891c2-646">XAML Attribute Usage</span></span>  
  
```  
<object Style="{resourceExtension StyleResourceKey}"/>  
```  
  
<a name="xamlValues_Style"></a>   
## <a name="xaml-values"></a><span data-ttu-id="891c2-647">XAML 值</span><span class="sxs-lookup"><span data-stu-id="891c2-647">XAML Values</span></span>  
 <span data-ttu-id="891c2-648">*resourceExtension*</span><span class="sxs-lookup"><span data-stu-id="891c2-648">*resourceExtension*</span></span>  
 <span data-ttu-id="891c2-649">以下项之一:、 或。</span><span class="sxs-lookup"><span data-stu-id="891c2-649">One of the following: , or .</span></span> <span data-ttu-id="891c2-650">请参阅[XAML 资源](~/docs/framework/wpf/advanced/xaml-resources.md)。</span><span class="sxs-lookup"><span data-stu-id="891c2-650">See [XAML Resources](~/docs/framework/wpf/advanced/xaml-resources.md).</span></span>  
  
 <span data-ttu-id="891c2-651">*styleResourceKey*</span><span class="sxs-lookup"><span data-stu-id="891c2-651">*styleResourceKey*</span></span>  
 <span data-ttu-id="891c2-652">标识所请求的样式的键。</span><span class="sxs-lookup"><span data-stu-id="891c2-652">The key that identifies the style being requested.</span></span> <span data-ttu-id="891c2-653">键引用中的现有资源<xref:System.Windows.ResourceDictionary>。</span><span class="sxs-lookup"><span data-stu-id="891c2-653">The key refers to an existing resource in a <xref:System.Windows.ResourceDictionary>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="891c2-654">属性元素语法就从技术上讲，但不是建议这样做。</span><span class="sxs-lookup"><span data-stu-id="891c2-654">Property element syntax is technically possible, but not recommended.</span></span> <span data-ttu-id="891c2-655">请参阅[内联样式和模板](~/docs/framework/wpf/advanced/inline-styles-and-templates.md)。</span><span class="sxs-lookup"><span data-stu-id="891c2-655">See [Inline Styles and Templates](~/docs/framework/wpf/advanced/inline-styles-and-templates.md).</span></span>  <span data-ttu-id="891c2-656">绑定引用使用或<xref:System.Windows.Data.Binding>也是可行的但不常见。</span><span class="sxs-lookup"><span data-stu-id="891c2-656">A binding reference using  or <xref:System.Windows.Data.Binding> is also possible, but uncommon.</span></span>  
  
<a name="dependencyPropertyInfo_Style"></a>   
## <a name="dependency-property-information"></a><span data-ttu-id="891c2-657">依赖项属性信息</span><span class="sxs-lookup"><span data-stu-id="891c2-657">Dependency Property Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="891c2-658">标识符字段</span><span class="sxs-lookup"><span data-stu-id="891c2-658">Identifier field</span></span>|<xref:System.Windows.FrameworkContentElement.StyleProperty>|  
|<span data-ttu-id="891c2-659">元数据属性设置为 `true`</span><span class="sxs-lookup"><span data-stu-id="891c2-659">Metadata properties set to `true`</span></span>|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
   
  
## Examples  
 <span data-ttu-id="891c2-660">下面的示例建立<xref:System.Windows.FrameworkContentElement.Resources%2A>上的收集<xref:System.Windows.Documents.FlowDocument>根元素，然后将其引用为特定样式的资源作为<xref:System.Windows.Documents.Paragraph>。</span><span class="sxs-lookup"><span data-stu-id="891c2-660">The following example establishes a <xref:System.Windows.FrameworkContentElement.Resources%2A> collection on a <xref:System.Windows.Documents.FlowDocument> root element and then references it as a resource as a specific style for a <xref:System.Windows.Documents.Paragraph>.</span></span>  
  
 [!code-xaml[ContentElementsSmorgasbord#FCEResources](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page2.xaml#fceresources)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StyleProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty StyleProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty StyleProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.StyleProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly StyleProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ StyleProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable StyleProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkContentElement.StyleProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="891c2-661">标识 <see cref="P:System.Windows.FrameworkContentElement.Style" /> 依赖属性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="891c2-661">Identifies the <see cref="P:System.Windows.FrameworkContentElement.Style" /> dependency property.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable">
      <MemberSignature Language="C#" Value="bool IQueryAmbient.IsAmbientPropertyAvailable (string propertyName);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(string propertyName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.System#Windows#Markup#IQueryAmbient#IsAmbientPropertyAvailable(System.String)" />
      <MemberSignature Language="VB.NET" Value="Function IsAmbientPropertyAvailable (propertyName As String) As Boolean Implements IQueryAmbient.IsAmbientPropertyAvailable" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(System::String ^ propertyName) = System::Windows::Markup::IQueryAmbient::IsAmbientPropertyAvailable;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="propertyName">
          <span data-ttu-id="891c2-662">请求的环境属性的名称。</span>
          <span class="sxs-lookup">
            <span data-stu-id="891c2-662">The name of the requested ambient property.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="891c2-663">有关此成员的说明，请参见 <see cref="M:System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(System.String)" /> 方法。</span>
          <span class="sxs-lookup">
            <span data-stu-id="891c2-663">For a description of this member, see the <see cref="M:System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(System.String)" /> method.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="891c2-664">如果 <paramref name="propertyName" /> 可用，则为 <see langword="true" />；否则为 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="891c2-664">
              <see langword="true" /> if <paramref name="propertyName" /> is available; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="891c2-665">此成员是显式的接口成员实现。</span><span class="sxs-lookup"><span data-stu-id="891c2-665">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="891c2-666">它只能在 <xref:System.Windows.FrameworkContentElement> 实例强制转换为 <xref:System.Windows.Markup.IQueryAmbient> 接口时使用。</span><span class="sxs-lookup"><span data-stu-id="891c2-666">It can be used only when the <xref:System.Windows.FrameworkContentElement> instance is cast to an <xref:System.Windows.Markup.IQueryAmbient> interface.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Tag">
      <MemberSignature Language="C#" Value="public object Tag { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Tag" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.Tag" />
      <MemberSignature Language="VB.NET" Value="Public Property Tag As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ Tag { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Tag : obj with get, set" Usage="System.Windows.FrameworkContentElement.Tag" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="891c2-667">获取或设置任意对象值，该值可用于存储关于此元素的自定义信息。</span>
          <span class="sxs-lookup">
            <span data-stu-id="891c2-667">Gets or sets an arbitrary object value that can be used to store custom information about this element.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="891c2-668">预期值。</span>
          <span class="sxs-lookup">
            <span data-stu-id="891c2-668">The intended value.</span>
          </span>
          <span data-ttu-id="891c2-669">此属性无默认值。</span>
          <span class="sxs-lookup">
            <span data-stu-id="891c2-669">This property has no default value.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="891c2-670">此属性是类似于其他 Microsoft 编程模型，如 Visual Basic 应用程序或 Windows 窗体中的标记属性。</span><span class="sxs-lookup"><span data-stu-id="891c2-670">This property is analogous to Tag properties in other Microsoft programming models, such as Visual Basic for Applications or Windows Forms.</span></span> <span data-ttu-id="891c2-671">它旨在提供一个预先存在的空间来存储有关任何元素的一些基本的自定义信息，而不强制应用程序开发人员创建子类。</span><span class="sxs-lookup"><span data-stu-id="891c2-671">It is intended to provide a pre-existing place to store some basic custom information about any element without forcing application developers to subclass.</span></span>  
  
<a name="xamlValues_Tag"></a>   
## <a name="xaml-values"></a><span data-ttu-id="891c2-672">XAML 值</span><span class="sxs-lookup"><span data-stu-id="891c2-672">XAML Values</span></span>  
 <span data-ttu-id="891c2-673">由于此属性需要一个对象，需要设置以便使用属性元素用法<xref:System.Windows.FrameworkContentElement.Tag%2A>在 XAML 中为具有已知和内置类型转换器，如字符串的对象以外的任何属性。</span><span class="sxs-lookup"><span data-stu-id="891c2-673">Because this property takes an object, you need to use the property element usage in order to set the <xref:System.Windows.FrameworkContentElement.Tag%2A> property in XAML to anything other than an object with a known and built-in type converter, such as a string.</span></span> <span data-ttu-id="891c2-674">这种方式中使用的对象通常不是标准的 WPF 命名空间内，因此可能需要以引入作为 XAML 元素的命名空间映射到外部命名空间。</span><span class="sxs-lookup"><span data-stu-id="891c2-674">Objects used in this way are typically not within the standard WPF namespaces and therefore may require namespace mapping to the external namespace in order to be introduced as XAML elements.</span></span>  
  
<a name="dependencyPropertyInfo_Tag"></a>   
## <a name="dependency-property-information"></a><span data-ttu-id="891c2-675">依赖项属性信息</span><span class="sxs-lookup"><span data-stu-id="891c2-675">Dependency Property Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="891c2-676">标识符字段</span><span class="sxs-lookup"><span data-stu-id="891c2-676">Identifier field</span></span>|<xref:System.Windows.FrameworkContentElement.TagProperty>|  
|<span data-ttu-id="891c2-677">元数据属性设置为 `true`</span><span class="sxs-lookup"><span data-stu-id="891c2-677">Metadata properties set to `true`</span></span>|<span data-ttu-id="891c2-678">无</span><span class="sxs-lookup"><span data-stu-id="891c2-678">None</span></span>|  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.FrameworkContentElement.Name" />
      </Docs>
    </Member>
    <Member MemberName="TagProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty TagProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty TagProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.TagProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TagProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ TagProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable TagProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkContentElement.TagProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="891c2-679">标识 <see cref="P:System.Windows.FrameworkContentElement.Tag" /> 依赖属性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="891c2-679">Identifies the <see cref="P:System.Windows.FrameworkContentElement.Tag" /> dependency property.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TargetUpdated">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt; TargetUpdated;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Data.DataTransferEventArgs&gt; TargetUpdated" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkContentElement.TargetUpdated" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event TargetUpdated As EventHandler(Of DataTransferEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Windows::Data::DataTransferEventArgs ^&gt; ^ TargetUpdated;" />
      <MemberSignature Language="F#" Value="member this.TargetUpdated : EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt; " Usage="member this.TargetUpdated : System.EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="891c2-680">当参与此元素上的绑定的任意关联目标属性更改时发生。</span>
          <span class="sxs-lookup">
            <span data-stu-id="891c2-680">Occurs when any associated target property participating in a binding on this element changes.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="891c2-681">此事件图面<xref:System.Windows.Data.Binding.TargetUpdated>引发的任何事件<xref:System.Windows.Data.Binding>与此元素关联。</span><span class="sxs-lookup"><span data-stu-id="891c2-681">This event surfaces the <xref:System.Windows.Data.Binding.TargetUpdated> event that is raised by any <xref:System.Windows.Data.Binding> associated with this element.</span></span> <span data-ttu-id="891c2-682">这通常意味着所讨论的绑定是双向绑定，且绑定的依赖属性确定每个任何验证或缓存的属性支持的方案的以前属性值无效。</span><span class="sxs-lookup"><span data-stu-id="891c2-682">This usually means that the binding in question is a two-way binding, and that the bound  dependency property affirms an invalidation of the previous property value per any validation or caching scheme that the property supports.</span></span>  
  
 <span data-ttu-id="891c2-683">此事件的事件参数会通知你绑定属性已更改。</span><span class="sxs-lookup"><span data-stu-id="891c2-683">The event arguments of this event will inform you which bound property was changed.</span></span>  
  
<a name="xamlAttributeUsage_TargetUpdated"></a>   
## <a name="xaml-attribute-usage"></a><span data-ttu-id="891c2-684">XAML 属性用法</span><span class="sxs-lookup"><span data-stu-id="891c2-684">XAML Attribute Usage</span></span>  
  
```  
<object TargetUpdated="EventHandler"/>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TemplatedParent">
      <MemberSignature Language="C#" Value="public System.Windows.DependencyObject TemplatedParent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.DependencyObject TemplatedParent" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.TemplatedParent" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TemplatedParent As DependencyObject" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::DependencyObject ^ TemplatedParent { System::Windows::DependencyObject ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.TemplatedParent : System.Windows.DependencyObject" Usage="System.Windows.FrameworkContentElement.TemplatedParent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="891c2-685">获取一个对此元素的模板父级的引用。</span>
          <span class="sxs-lookup">
            <span data-stu-id="891c2-685">Gets a reference to the template parent of this element.</span>
          </span>
          <span data-ttu-id="891c2-686">如果此元素不是通过模板创建而成，则此属性并不相关。</span>
          <span class="sxs-lookup">
            <span data-stu-id="891c2-686">This property is not relevant if the element was not created through a template.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="891c2-687">元素的<see cref="T:System.Windows.FrameworkTemplate" /><see cref="P:System.Windows.FrameworkTemplate.VisualTree" />导致要创建此元素。</span>
          <span class="sxs-lookup">
            <span data-stu-id="891c2-687">The element whose <see cref="T:System.Windows.FrameworkTemplate" /><see cref="P:System.Windows.FrameworkTemplate.VisualTree" /> caused this element to be created.</span>
          </span>
          <span data-ttu-id="891c2-688">此值通常为<see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="891c2-688">This value is frequently <see langword="null" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="891c2-689">模板实际上是共享的对象，其中只有一次创建模板的内容。</span><span class="sxs-lookup"><span data-stu-id="891c2-689">Templates are actually shared objects, where the contents of the template are created only once.</span></span> <span data-ttu-id="891c2-690">因此，如果您获得来自模板的元素的对象引用，可能会发现明显的逻辑树不会访问到页面根。</span><span class="sxs-lookup"><span data-stu-id="891c2-690">Therefore, if you obtain an object reference to an element that came from a template, you may find that the apparent logical tree does not reach to the page root.</span></span> <span data-ttu-id="891c2-691">若要连接到该页面的逻辑树这样的模板引用，应会看到<xref:System.Windows.FrameworkContentElement.TemplatedParent%2A>值并继续根据需要该元素树中导航。</span><span class="sxs-lookup"><span data-stu-id="891c2-691">In order to connect such a template reference to the page's logical tree, you should get the <xref:System.Windows.FrameworkContentElement.TemplatedParent%2A> value and continue to navigate that element tree as desired.</span></span>  
  
 <span data-ttu-id="891c2-692"><xref:System.Windows.FrameworkContentElement.TemplatedParent%2A> 通常会`null`对常见对象，因为如果您通过典型方式在应用程序中获取从页面外的对象引用，该元素可能不从创建模板。</span><span class="sxs-lookup"><span data-stu-id="891c2-692"><xref:System.Windows.FrameworkContentElement.TemplatedParent%2A> will frequently be `null` for common objects, because if you have obtained an object reference from out of a page in your application through typical means, that element probably was not created from a template.</span></span> <span data-ttu-id="891c2-693">事例<xref:System.Windows.FrameworkContentElement.TemplatedParent%2A>可能不是`null`将包括处理某些低级别的输入事件，或使用枚举器返回了来自模板的元素的命中测试的事件等操作。</span><span class="sxs-lookup"><span data-stu-id="891c2-693">Cases where <xref:System.Windows.FrameworkContentElement.TemplatedParent%2A> might not be `null` would include operations such as hit-testing, event handling for certain low-level input events, or working with enumerators, which may have returned elements that came from templates.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToolTip">
      <MemberSignature Language="C#" Value="public object ToolTip { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object ToolTip" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.ToolTip" />
      <MemberSignature Language="VB.NET" Value="Public Property ToolTip As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ ToolTip { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ToolTip : obj with get, set" Usage="System.Windows.FrameworkContentElement.ToolTip" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Bindable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Category("Appearance")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="891c2-694">获取或设置在[!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)] 中为此元素显示的工具提示对象。</span>
          <span class="sxs-lookup">
            <span data-stu-id="891c2-694">Gets or sets the tool-tip object that is displayed for this element in the [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)].</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="891c2-695">工具提示对象。</span>
          <span class="sxs-lookup">
            <span data-stu-id="891c2-695">The tooltip object.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="891c2-696">如果此属性的值属于类型<xref:System.Windows.Controls.ToolTip>，则它就是将在中使用工具提示[!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)]。</span><span class="sxs-lookup"><span data-stu-id="891c2-696">If the value of this property is of type <xref:System.Windows.Controls.ToolTip>, then that is the tool-tip that will be used in the [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)].</span></span>  <span data-ttu-id="891c2-697">如果值为任何其他类型，则该值将用作*内容*为<xref:System.Windows.Controls.ToolTip>提供系统 （构造）。</span><span class="sxs-lookup"><span data-stu-id="891c2-697">If the value is of any other type, then that value will be used as the *content* for a <xref:System.Windows.Controls.ToolTip> provided (constructed) by the system.</span></span> <span data-ttu-id="891c2-698">有关更多信息，请参见<xref:System.Windows.Controls.ToolTipService>。</span><span class="sxs-lookup"><span data-stu-id="891c2-698">For more information see <xref:System.Windows.Controls.ToolTipService>.</span></span> <span data-ttu-id="891c2-699">服务类提供了可用于进一步自定义工具提示的附加的属性。</span><span class="sxs-lookup"><span data-stu-id="891c2-699">The service class provides attached properties that can be used to further customize a tool-tip.</span></span>  
  
<a name="xamlAttributeUsage_ToolTip"></a>   
## <a name="xaml-attribute-usage"></a><span data-ttu-id="891c2-700">XAML 属性用法</span><span class="sxs-lookup"><span data-stu-id="891c2-700">XAML Attribute Usage</span></span>  
  
```  
<object ToolTip="toolTipContent"/>  
```  
  
<a name="xamlPropertyElementUsage_ToolTip"></a>   
## <a name="xaml-property-element-usage"></a><span data-ttu-id="891c2-701">XAML 属性元素用法</span><span class="sxs-lookup"><span data-stu-id="891c2-701">XAML Property Element Usage</span></span>  
  
```  
<object>  
  <object.ToolTip>  
    <ToolTip .../>  
  </object.ToolTip>  
</object>  
- or -  
<object>  
  <object.ToolTip>  
    toolTipObjectContent  
  </object.ToolTip>  
</object>  
```  
  
<a name="xamlValues_ToolTip"></a>   
## <a name="xaml-values"></a><span data-ttu-id="891c2-702">XAML 值</span><span class="sxs-lookup"><span data-stu-id="891c2-702">XAML Values</span></span>  
 <span data-ttu-id="891c2-703">*toolTipContent*</span><span class="sxs-lookup"><span data-stu-id="891c2-703">*toolTipContent*</span></span>  
 <span data-ttu-id="891c2-704">将成为显示的文本的字符串<xref:System.Windows.FrameworkContentElement.ToolTip%2A>。</span><span class="sxs-lookup"><span data-stu-id="891c2-704">A string that becomes the display text for the <xref:System.Windows.FrameworkContentElement.ToolTip%2A>.</span></span>  
  
 <span data-ttu-id="891c2-705">*toolTipObjectContent*</span><span class="sxs-lookup"><span data-stu-id="891c2-705">*toolTipObjectContent*</span></span>  
 <span data-ttu-id="891c2-706">对象元素窗体，应使用的内容作为中提供某些对象<xref:System.Windows.FrameworkContentElement>。</span><span class="sxs-lookup"><span data-stu-id="891c2-706">Some object, provided in object element form, that should be used as the content for the <xref:System.Windows.FrameworkContentElement> .</span></span> <span data-ttu-id="891c2-707">通常，这是<xref:System.Windows.FrameworkElement>或创建布局的组合的情况下的某些其他元素<xref:System.Windows.FrameworkContentElement.ToolTip%2A>，最终包含在该组合中的文本内容。</span><span class="sxs-lookup"><span data-stu-id="891c2-707">Typically this would be a <xref:System.Windows.FrameworkElement> or some other element that creates layout compositing for the <xref:System.Windows.FrameworkContentElement.ToolTip%2A>, eventually containing text content within the compositing.</span></span> <span data-ttu-id="891c2-708">在此使用情况<xref:System.Windows.Controls.ToolTip>元素创建隐式地从已分析[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]，并*经过*内容设置为其<xref:System.Windows.Controls.ContentControl.Content%2A?displayProperty=nameWithType>属性。</span><span class="sxs-lookup"><span data-stu-id="891c2-708">In this usage, the <xref:System.Windows.Controls.ToolTip> element is created implicitly from the parsed [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)], and the *toolTipObjectContent* content is set as its <xref:System.Windows.Controls.ContentControl.Content%2A?displayProperty=nameWithType> property.</span></span>  
  
 <span data-ttu-id="891c2-709"><`ToolTip` .../></span><span class="sxs-lookup"><span data-stu-id="891c2-709"><`ToolTip` .../></span></span>  
 <span data-ttu-id="891c2-710">请参阅<xref:System.Windows.Controls.ToolTip>。</span><span class="sxs-lookup"><span data-stu-id="891c2-710">See <xref:System.Windows.Controls.ToolTip>.</span></span>  
  
<a name="dependencyPropertyInfo_ToolTip"></a>   
## <a name="dependency-property-information"></a><span data-ttu-id="891c2-711">依赖项属性信息</span><span class="sxs-lookup"><span data-stu-id="891c2-711">Dependency Property Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="891c2-712">标识符字段</span><span class="sxs-lookup"><span data-stu-id="891c2-712">Identifier field</span></span>|<xref:System.Windows.FrameworkContentElement.ToolTipProperty>|  
|<span data-ttu-id="891c2-713">元数据属性设置为 `true`</span><span class="sxs-lookup"><span data-stu-id="891c2-713">Metadata properties set to `true`</span></span>|<span data-ttu-id="891c2-714">无</span><span class="sxs-lookup"><span data-stu-id="891c2-714">None</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="891c2-715">下面的示例设置的值<xref:System.Windows.FrameworkElement.ToolTip%2A>直接为字符串的属性。</span><span class="sxs-lookup"><span data-stu-id="891c2-715">The following example sets the value of the <xref:System.Windows.FrameworkElement.ToolTip%2A> property directly to a string.</span></span>  
  
 [!code-csharp[TableSnippets2#_Table_RowGroups_ManipRows](~/samples/snippets/csharp/VS_Snippets_Wpf/TableSnippets2/CSharp/Window1.xaml.cs#_table_rowgroups_maniprows)]
 [!code-vb[TableSnippets2#_Table_RowGroups_ManipRows](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TableSnippets2/visualbasic/window1.xaml.vb#_table_rowgroups_maniprows)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToolTipClosing">
      <MemberSignature Language="C#" Value="public event System.Windows.Controls.ToolTipEventHandler ToolTipClosing;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Controls.ToolTipEventHandler ToolTipClosing" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkContentElement.ToolTipClosing" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ToolTipClosing As ToolTipEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Controls::ToolTipEventHandler ^ ToolTipClosing;" />
      <MemberSignature Language="F#" Value="member this.ToolTipClosing : System.Windows.Controls.ToolTipEventHandler " Usage="member this.ToolTipClosing : System.Windows.Controls.ToolTipEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.ToolTipEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="891c2-716">在元素上的任何工具提示关闭之前发生。</span>
          <span class="sxs-lookup">
            <span data-stu-id="891c2-716">Occurs just before any tooltip on the element is closed.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="891c2-717">若要取消关闭工具提示，该事件的处理程序应将其标记为已处理。</span><span class="sxs-lookup"><span data-stu-id="891c2-717">To suppress closing the tooltip, handlers of the event should mark it as handled.</span></span>  
  
 <span data-ttu-id="891c2-718">此事件不能为<xref:System.Windows.EventTrigger>样式中。</span><span class="sxs-lookup"><span data-stu-id="891c2-718">This event cannot be an <xref:System.Windows.EventTrigger> in a style.</span></span> <span data-ttu-id="891c2-719">这是因为此事件的标识符字段重新使用从一种服务，不会公开事件的添加/删除方法的实现。</span><span class="sxs-lookup"><span data-stu-id="891c2-719">This is because the identifier field of this event re-uses an implementation from a service that does not expose add/remove methods on the event.</span></span>  
  
<a name="routedEventInfo_ToolTipClosing"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="891c2-720">路由事件信息</span><span class="sxs-lookup"><span data-stu-id="891c2-720">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="891c2-721">标识符字段</span><span class="sxs-lookup"><span data-stu-id="891c2-721">Identifier field</span></span>|<xref:System.Windows.FrameworkContentElement.ToolTipClosingEvent>|  
|<span data-ttu-id="891c2-722">路由策略</span><span class="sxs-lookup"><span data-stu-id="891c2-722">Routing strategy</span></span>|<span data-ttu-id="891c2-723">直接</span><span class="sxs-lookup"><span data-stu-id="891c2-723">Direct</span></span>|  
|<span data-ttu-id="891c2-724">Delegate</span><span class="sxs-lookup"><span data-stu-id="891c2-724">Delegate</span></span>|<xref:System.Windows.Controls.ToolTipEventHandler>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToolTipClosingEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent ToolTipClosingEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent ToolTipClosingEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.ToolTipClosingEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ToolTipClosingEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ ToolTipClosingEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable ToolTipClosingEvent : System.Windows.RoutedEvent" Usage="System.Windows.FrameworkContentElement.ToolTipClosingEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="891c2-725">标识 <see cref="E:System.Windows.FrameworkContentElement.ToolTipClosing" /> [路由事件概述](~/docs/framework/wpf/advanced/routed-events-overview.md)。</span>
          <span class="sxs-lookup">
            <span data-stu-id="891c2-725">Identifies the <see cref="E:System.Windows.FrameworkContentElement.ToolTipClosing" /> [Routed Events Overview](~/docs/framework/wpf/advanced/routed-events-overview.md).</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="891c2-726">在注册路由的事件时创建事件标识符对象 (请参阅<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>)，用于添加类处理程序 (请参阅<xref:System.Windows.EventManager.RegisterClassHandler%2A>)。</span><span class="sxs-lookup"><span data-stu-id="891c2-726">Event identifier objects are created when routed events are registered (see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>) and can then be used to add class handlers (see <xref:System.Windows.EventManager.RegisterClassHandler%2A>).</span></span> <span data-ttu-id="891c2-727">标识符对象包含标识名称、 所有者类型、 处理程序类型、 路由策略和用于添加事件所有者的实用工具方法。</span><span class="sxs-lookup"><span data-stu-id="891c2-727">Identifier objects contain an identifying name, owner type, handler type, routing strategy, and a utility method for adding owners for the event.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToolTipOpening">
      <MemberSignature Language="C#" Value="public event System.Windows.Controls.ToolTipEventHandler ToolTipOpening;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Controls.ToolTipEventHandler ToolTipOpening" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkContentElement.ToolTipOpening" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ToolTipOpening As ToolTipEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Controls::ToolTipEventHandler ^ ToolTipOpening;" />
      <MemberSignature Language="F#" Value="member this.ToolTipOpening : System.Windows.Controls.ToolTipEventHandler " Usage="member this.ToolTipOpening : System.Windows.Controls.ToolTipEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.ToolTipEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="891c2-728">在元素上的任何工具提示打开时发生。</span>
          <span class="sxs-lookup">
            <span data-stu-id="891c2-728">Occurs when any tooltip on the element is opened.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="891c2-729">若要手动打开工具提示，事件的处理程序应将相关的事件标记为已处理。</span><span class="sxs-lookup"><span data-stu-id="891c2-729">To manually open tooltips, handlers of the events should mark the relevant event as handled.</span></span> <span data-ttu-id="891c2-730">否则为值<xref:System.Windows.FrameworkContentElement.ToolTip%2A>属性将用于自动打开上下文菜单。</span><span class="sxs-lookup"><span data-stu-id="891c2-730">Otherwise, the value of the <xref:System.Windows.FrameworkContentElement.ToolTip%2A> property will be used to automatically open a context menu.</span></span> <span data-ttu-id="891c2-731">将标记处理的事件将有效地取消默认操作，并且可重置的值的机会<xref:System.Windows.FrameworkContentElement.ToolTip%2A>属性，然后打开新<xref:System.Windows.Controls.ContextMenu>。</span><span class="sxs-lookup"><span data-stu-id="891c2-731">Marking the event handled will effectively cancel the default action, and could be an opportunity to reset the value of the <xref:System.Windows.FrameworkContentElement.ToolTip%2A> property and then open the new <xref:System.Windows.Controls.ContextMenu>.</span></span> <span data-ttu-id="891c2-732">请注意，是否将不会引发此事件<xref:System.Windows.FrameworkContentElement.ToolTip%2A>为空引用或其他取消设置。</span><span class="sxs-lookup"><span data-stu-id="891c2-732">Note that this event will not be raised if <xref:System.Windows.FrameworkContentElement.ToolTip%2A> is a null reference or otherwise unset.</span></span>  
  
 <span data-ttu-id="891c2-733">此事件不能为<xref:System.Windows.EventTrigger>样式中。</span><span class="sxs-lookup"><span data-stu-id="891c2-733">This event cannot be an <xref:System.Windows.EventTrigger> in a style.</span></span> <span data-ttu-id="891c2-734">这是因为此事件的标识符字段重新使用从一种服务，不会公开事件的添加/删除方法的实现。</span><span class="sxs-lookup"><span data-stu-id="891c2-734">This is because the identifier field of this event re-uses an implementation from a service that does not expose add/remove methods on the event.</span></span>  
  
<a name="routedEventInfo_ToolTipOpening"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="891c2-735">路由事件信息</span><span class="sxs-lookup"><span data-stu-id="891c2-735">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="891c2-736">标识符字段</span><span class="sxs-lookup"><span data-stu-id="891c2-736">Identifier field</span></span>|<xref:System.Windows.FrameworkContentElement.ToolTipOpeningEvent>|  
|<span data-ttu-id="891c2-737">路由策略</span><span class="sxs-lookup"><span data-stu-id="891c2-737">Routing strategy</span></span>|<span data-ttu-id="891c2-738">直接</span><span class="sxs-lookup"><span data-stu-id="891c2-738">Direct</span></span>|  
|<span data-ttu-id="891c2-739">Delegate</span><span class="sxs-lookup"><span data-stu-id="891c2-739">Delegate</span></span>|<xref:System.Windows.Controls.ToolTipEventHandler>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToolTipOpeningEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent ToolTipOpeningEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent ToolTipOpeningEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.ToolTipOpeningEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ToolTipOpeningEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ ToolTipOpeningEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable ToolTipOpeningEvent : System.Windows.RoutedEvent" Usage="System.Windows.FrameworkContentElement.ToolTipOpeningEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="891c2-740">标识 <see cref="E:System.Windows.FrameworkContentElement.ToolTipOpening" /> [路由事件概述](~/docs/framework/wpf/advanced/routed-events-overview.md)。</span>
          <span class="sxs-lookup">
            <span data-stu-id="891c2-740">Identifies the <see cref="E:System.Windows.FrameworkContentElement.ToolTipOpening" /> [Routed Events Overview](~/docs/framework/wpf/advanced/routed-events-overview.md).</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="891c2-741">在注册路由的事件时创建事件标识符对象 (请参阅<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>)，用于添加类处理程序 (请参阅<xref:System.Windows.EventManager.RegisterClassHandler%2A>)。</span><span class="sxs-lookup"><span data-stu-id="891c2-741">Event identifier objects are created when routed events are registered (see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>) and can then be used to add class handlers (see <xref:System.Windows.EventManager.RegisterClassHandler%2A>).</span></span> <span data-ttu-id="891c2-742">标识符对象包含标识名称、 所有者类型、 处理程序类型、 路由策略和用于添加事件所有者的实用工具方法。</span><span class="sxs-lookup"><span data-stu-id="891c2-742">Identifier objects contain an identifying name, owner type, handler type, routing strategy, and a utility method for adding owners for the event.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToolTipProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ToolTipProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ToolTipProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.ToolTipProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ToolTipProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ToolTipProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable ToolTipProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkContentElement.ToolTipProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="891c2-743">标识 <see cref="P:System.Windows.FrameworkContentElement.ToolTip" /> 依赖属性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="891c2-743">Identifies the <see cref="P:System.Windows.FrameworkContentElement.ToolTip" /> dependency property.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryFindResource">
      <MemberSignature Language="C#" Value="public object TryFindResource (object resourceKey);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object TryFindResource(object resourceKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.TryFindResource(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryFindResource (resourceKey As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ TryFindResource(System::Object ^ resourceKey);" />
      <MemberSignature Language="F#" Value="member this.TryFindResource : obj -&gt; obj" Usage="frameworkContentElement.TryFindResource resourceKey" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="resourceKey" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="resourceKey">
          <span data-ttu-id="891c2-744">要查找的资源的键标识符。</span>
          <span class="sxs-lookup">
            <span data-stu-id="891c2-744">Key identifier of the resource to be found.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="891c2-745">搜索具有指定键的资源，如果找到，则返回该资源。</span>
          <span class="sxs-lookup">
            <span data-stu-id="891c2-745">Searches for a resource with the specified key, and returns that resource if found.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="891c2-746">找到的资源。</span>
          <span class="sxs-lookup">
            <span data-stu-id="891c2-746">The found resource.</span>
          </span>
          <span data-ttu-id="891c2-747">如果未找到资源，则返回 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="891c2-747">If no resource was found, <see langword="null" /> is returned.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="891c2-748">如果调用元素上找不到资源，使用在树的方法相同的逻辑树中，搜索父树由在运行时参数请求动态资源引用时搜索。</span><span class="sxs-lookup"><span data-stu-id="891c2-748">If the resource is not found on the calling element, the parent tree is searched using the logical tree, in the same way that the tree would be searched if a dynamic resource reference were requested by key at run-time.</span></span>  
  
 <span data-ttu-id="891c2-749">通常，会立即强制转换为已尝试设置为返回的资源值的属性的类型的返回值。</span><span class="sxs-lookup"><span data-stu-id="891c2-749">Typically you would immediately cast the return value to the type of the property that you were attempting to set with the returned resource value.</span></span>  
  
 <span data-ttu-id="891c2-750"><xref:System.Windows.FrameworkContentElement.FindResource%2A>方法具有类似行为，不同之处在于它将在不使用提供的键查找资源的情况下发生异常。</span><span class="sxs-lookup"><span data-stu-id="891c2-750">The <xref:System.Windows.FrameworkContentElement.FindResource%2A> method has similar behavior, except that it will throw an exception in the case of not finding a resource with the provided key.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="891c2-751">下面的示例查找资源，在标记中定义并将其应用于路由事件的响应中的元素的某一属性。</span><span class="sxs-lookup"><span data-stu-id="891c2-751">The following example finds a resource as defined in markup and applies it to a certain property of an element in response to a routed event.</span></span>  
  
 [!code-csharp[ContentElementsSmorgasbord#TryFindResource](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml.cs#tryfindresource)]
 [!code-vb[ContentElementsSmorgasbord#TryFindResource](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContentElementsSmorgasbord/visualbasic/page1.xaml.vb#tryfindresource)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkContentElement.FindResource(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Unloaded">
      <MemberSignature Language="C#" Value="public event System.Windows.RoutedEventHandler Unloaded;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.RoutedEventHandler Unloaded" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkContentElement.Unloaded" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Unloaded As RoutedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::RoutedEventHandler ^ Unloaded;" />
      <MemberSignature Language="F#" Value="member this.Unloaded : System.Windows.RoutedEventHandler " Usage="member this.Unloaded : System.Windows.RoutedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="891c2-752">当从已加载元素的元素树中移除元素时发生。</span>
          <span class="sxs-lookup">
            <span data-stu-id="891c2-752">Occurs when the element is removed from an element tree of loaded elements.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="891c2-753">直接路由的事件不遵循路由，而仅处理引发它们在同一元素中。</span><span class="sxs-lookup"><span data-stu-id="891c2-753">Direct routed events do not follow a route, they are only handled within the same element on which they are raised.</span></span> <span data-ttu-id="891c2-754">直接路由的事件支持其他路由的事件行为： 它们支持的可访问的处理程序集合，并可用作<xref:System.Windows.EventTrigger>样式中。</span><span class="sxs-lookup"><span data-stu-id="891c2-754">Direct routed events do support other routed event behavior: they support an accessible handlers collection, and can be used as an <xref:System.Windows.EventTrigger> in a style.</span></span>  
  
<a name="routedEventInfo_Unloaded"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="891c2-755">路由事件信息</span><span class="sxs-lookup"><span data-stu-id="891c2-755">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="891c2-756">标识符字段</span><span class="sxs-lookup"><span data-stu-id="891c2-756">Identifier field</span></span>|<xref:System.Windows.FrameworkContentElement.UnloadedEvent>|  
|<span data-ttu-id="891c2-757">路由策略</span><span class="sxs-lookup"><span data-stu-id="891c2-757">Routing strategy</span></span>|<span data-ttu-id="891c2-758">直接</span><span class="sxs-lookup"><span data-stu-id="891c2-758">Direct</span></span>|  
|<span data-ttu-id="891c2-759">Delegate</span><span class="sxs-lookup"><span data-stu-id="891c2-759">Delegate</span></span>|<xref:System.Windows.RoutedEventHandler>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UnloadedEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent UnloadedEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent UnloadedEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.UnloadedEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly UnloadedEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ UnloadedEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable UnloadedEvent : System.Windows.RoutedEvent" Usage="System.Windows.FrameworkContentElement.UnloadedEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="891c2-760">标识 <see cref="E:System.Windows.FrameworkContentElement.Unloaded" /> [路由事件概述](~/docs/framework/wpf/advanced/routed-events-overview.md)。</span>
          <span class="sxs-lookup">
            <span data-stu-id="891c2-760">Identifies the <see cref="E:System.Windows.FrameworkContentElement.Unloaded" /> [Routed Events Overview](~/docs/framework/wpf/advanced/routed-events-overview.md).</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="891c2-761">在注册路由的事件时创建事件标识符对象 (请参阅<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>)，用于添加类处理程序 (请参阅<xref:System.Windows.EventManager.RegisterClassHandler%2A>)。</span><span class="sxs-lookup"><span data-stu-id="891c2-761">Event identifier objects are created when routed events are registered (see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>) and can then be used to add class handlers (see <xref:System.Windows.EventManager.RegisterClassHandler%2A>).</span></span> <span data-ttu-id="891c2-762">标识符对象包含标识名称、 所有者类型、 处理程序类型、 路由策略和用于添加事件所有者的实用工具方法。</span><span class="sxs-lookup"><span data-stu-id="891c2-762">Identifier objects contain an identifying name, owner type, handler type, routing strategy, and a utility method for adding owners for the event.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UnregisterName">
      <MemberSignature Language="C#" Value="public void UnregisterName (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void UnregisterName(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.UnregisterName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub UnregisterName (name As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void UnregisterName(System::String ^ name);" />
      <MemberSignature Language="F#" Value="member this.UnregisterName : string -&gt; unit" Usage="frameworkContentElement.UnregisterName name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="891c2-763">要从当前范围中移除的名称-对象对的名称。</span>
          <span class="sxs-lookup">
            <span data-stu-id="891c2-763">Name of the name-object pair to remove from the current scope.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="891c2-764">简化对 <see cref="T:System.Windows.NameScope" /> 注销方法的访问。</span>
          <span class="sxs-lookup">
            <span data-stu-id="891c2-764">Simplifies access to the <see cref="T:System.Windows.NameScope" /> de-registration method.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="891c2-765">如果你想要重新注册该名称与另一个元素只需取消注册名称到系统。</span><span class="sxs-lookup"><span data-stu-id="891c2-765">You only need to un-register names if you intend to re-register another element with that same name.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkContentElement.RegisterName(System.String,System.Object)" />
        <altmember cref="T:System.Windows.NameScope" />
      </Docs>
    </Member>
    <Member MemberName="UpdateDefaultStyle">
      <MemberSignature Language="C#" Value="public void UpdateDefaultStyle ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void UpdateDefaultStyle() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.UpdateDefaultStyle" />
      <MemberSignature Language="VB.NET" Value="Public Sub UpdateDefaultStyle ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void UpdateDefaultStyle();" />
      <MemberSignature Language="F#" Value="member this.UpdateDefaultStyle : unit -&gt; unit" Usage="frameworkContentElement.UpdateDefaultStyle " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="891c2-766">将默认样式重新应用至当前 <see cref="T:System.Windows.FrameworkContentElement" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="891c2-766">Reapplies the default style to the current <see cref="T:System.Windows.FrameworkContentElement" />.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>