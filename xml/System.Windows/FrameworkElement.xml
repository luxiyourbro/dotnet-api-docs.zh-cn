<Type Name="FrameworkElement" FullName="System.Windows.FrameworkElement">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="89ebadb6a5c9e3735cc4c4daa24f3184f2a39368" />
    <Meta Name="ms.sourcegitcommit" Value="0ec122ee5f3681159b8460ab15b409fd6e3d3ae0" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-CN" />
    <Meta Name="ms.lasthandoff" Value="10/04/2018" />
    <Meta Name="ms.locfileid" Value="48671555" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class FrameworkElement : System.Windows.UIElement, System.ComponentModel.ISupportInitialize, System.Windows.IFrameworkInputElement, System.Windows.Markup.IQueryAmbient" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi FrameworkElement extends System.Windows.UIElement implements class System.ComponentModel.ISupportInitialize, class System.Windows.IFrameworkInputElement, class System.Windows.IInputElement, class System.Windows.Markup.IQueryAmbient" />
  <TypeSignature Language="DocId" Value="T:System.Windows.FrameworkElement" />
  <TypeSignature Language="VB.NET" Value="Public Class FrameworkElement&#xA;Inherits UIElement&#xA;Implements IFrameworkInputElement, IQueryAmbient, ISupportInitialize" />
  <TypeSignature Language="C++ CLI" Value="public ref class FrameworkElement : System::Windows::UIElement, System::ComponentModel::ISupportInitialize, System::Windows::IFrameworkInputElement, System::Windows::Markup::IQueryAmbient" />
  <TypeSignature Language="F#" Value="type FrameworkElement = class&#xA;    inherit UIElement&#xA;    interface IFrameworkInputElement&#xA;    interface IInputElement&#xA;    interface ISupportInitialize&#xA;    interface IQueryAmbient" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.UIElement</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ComponentModel.ISupportInitialize</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Windows.IFrameworkInputElement</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Windows.Markup.IQueryAmbient</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.Windows.Markup.RuntimeNameProperty("Name")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.Windows.Markup.UsableDuringInitialization(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.Windows.Markup.XmlLangProperty("Language")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.Windows.StyleTypedProperty(Property="FocusVisualStyle", StyleTargetType=typeof(System.Windows.Controls.Control))</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>提供 Windows Presentation Foundation (WPF) 元素的属性、事件和方法的 WPF 框架级别集。 此类表示所提供的 WPF 框架级别实现基于 <see cref="T:System.Windows.UIElement" /> 定义的 WPF 核心级别 API。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.FrameworkElement> 是 WPF 框架级元素类的 WPF 核心级别集之间的连接点<xref:System.Windows.UIElement>表示服务。 有关这些概念的详细信息，请参阅[WPF 体系结构](~/docs/framework/wpf/advanced/wpf-architecture.md)。  
  
 <xref:System.Windows.FrameworkElement> 扩展了<xref:System.Windows.UIElement>和添加了以下功能：  
  
-   **布局系统定义**:<xref:System.Windows.FrameworkElement>为某些已作为中的虚拟成员定义的方法提供特定的 WPF 框架级别实现<xref:System.Windows.UIElement>。 最值得注意的是，<xref:System.Windows.FrameworkElement>密封某些 WPF 核心级别布局重写，并改为提供 WPF 框架级别等效项的派生类应替代。 例如，<xref:System.Windows.FrameworkElement>封条<xref:System.Windows.UIElement.ArrangeCore%2A>但提供了<xref:System.Windows.FrameworkElement.ArrangeOverride%2A>。 这些更改反映这一事实，在 WPF 框架级别没有完整布局系统准备就绪，可以呈现任何<xref:System.Windows.FrameworkElement>派生的类。 在 WPF 核心级别，某些成员，将构建常规[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]基于的布局解决方案均已到位，但未定义的布局系统实际的引擎。 请参阅[布局](~/docs/framework/wpf/advanced/layout.md)以了解详细信息。  
  
-   **逻辑树：** 常规[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]编程模型通常表示在正在元素树的方面。 支持表达为逻辑树中，元素树，同时还支持在标记中定义该树是实现在<xref:System.Windows.FrameworkElement>级别。 请注意但是该<xref:System.Windows.FrameworkElement>特意不定义内容模型，并使这一责任派生类。 有关详细信息，请参见 [WPF 中的树](~/docs/framework/wpf/advanced/trees-in-wpf.md)。  
  
-   **对象生存期事件：** 通常很有用，要知道当初始化元素 （称为构造函数） 或元素时首次加载到逻辑树。 <xref:System.Windows.FrameworkElement> 定义与对象生存期相关的代码隐藏涉及的操作元素，如添加更多的子元素提供有用的挂钩的多个事件。 有关详细信息，请参阅[对象生存期事件](~/docs/framework/wpf/advanced/object-lifetime-events.md)。  
  
-   **支持数据绑定和动态资源引用：** 由实现数据绑定和资源的属性级支持<xref:System.Windows.DependencyProperty>类，并体现在属性系统，但解析为的成员值的能力存储为<xref:System.Windows.Expression>（提供支持数据绑定和动态资源的编程构造） 实现通过<xref:System.Windows.FrameworkElement>。 有关详细信息，请参阅[数据绑定概述](~/docs/framework/wpf/data/data-binding-overview.md)并[XAML 资源](~/docs/framework/wpf/advanced/xaml-resources.md)。  
  
-   **样式：** <xref:System.Windows.FrameworkElement>定义<xref:System.Windows.FrameworkElement.Style%2A>属性。 但是，<xref:System.Windows.FrameworkElement>尚未定义支持模板，或支持修饰器。 这些功能通过控件类如引入<xref:System.Windows.Controls.Control>和<xref:System.Windows.Controls.ContentControl>。  
  
-   **动画的更多支持：** 一些动画支持已定义为在 WPF 核心级别，但<xref:System.Windows.FrameworkElement>通过实现来扩展此<xref:System.Windows.FrameworkElement.BeginStoryboard%2A>和相关的成员。  
  
 可以看出类层次结构，许多[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]类派生自<xref:System.Windows.FrameworkElement>、 直接或通过中间基类，这些类如下所述<xref:System.Windows.Controls.Panel>或<xref:System.Windows.Controls.Control>。  
  
 如果你想要使用<xref:System.Windows.FrameworkElement>作为基类，你可能想要首先检查现有的派生的类。 <xref:System.Windows.FrameworkElement> 提供对多种基本方案的支持，但是同样缺少数为"element"意义上的构建基块，用来创建所需的功能[!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)]在[!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)]。 例如，<xref:System.Windows.FrameworkElement>不定义任何真正的内容模型;<xref:System.Windows.FrameworkElement>如基的类不定义一个属性，可以创建[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]子元素。 具体而言，你可能想要看看<xref:System.Windows.Controls.Control>和<xref:System.Windows.Controls.ContentControl>。  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.DependencyObject" />
    <altmember cref="T:System.Windows.FrameworkContentElement" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkElement ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkElement();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>初始化 <see cref="T:System.Windows.FrameworkElement" /> 类的新实例。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ActualHeight">
      <MemberSignature Language="C#" Value="public double ActualHeight { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 ActualHeight" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.ActualHeight" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ActualHeight As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double ActualHeight { double get(); };" />
      <MemberSignature Language="F#" Value="member this.ActualHeight : double" Usage="System.Windows.FrameworkElement.ActualHeight" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取此元素的呈现高度。</summary>
        <value>元素的高度，这是一个采用[!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]的值。 默认值为 0（零）。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此属性是基于其他高度输入和布局系统的计算的值。 值由布局系统本身基于实际呈现的传递，设置，因此可能稍微小于属性的设置值如<xref:System.Windows.FrameworkElement.Height%2A>是作为输入更改的基础。  
  
 因为<xref:System.Windows.FrameworkElement.ActualHeight%2A>是计算后的值，应注意可能有多次或递增的报告更改为它作为各种操作结果由布局系统。 布局系统可能会计算子元素所需的测量空间、父元素的约束等。  
  
 尽管您不能设置此属性从[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]，您可以基于<xref:System.Windows.Trigger>样式中其值。  
  
<a name="dependencyPropertyInfo_ActualHeight"></a>   
## <a name="dependency-property-information"></a>依赖项属性信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.FrameworkElement.ActualHeightProperty>|  
|元数据属性设置为 `true`|无|  
  
   
  
## Examples  
 以下示例显示各种高度属性。  
  
 [!code-csharp[HeightMinHeightMaxHeight#3](~/samples/snippets/csharp/VS_Snippets_Wpf/HeightMinHeightMaxHeight/CSharp/Window1.xaml.cs#3)]
 [!code-vb[HeightMinHeightMaxHeight#3](~/samples/snippets/visualbasic/VS_Snippets_Wpf/HeightMinHeightMaxHeight/VisualBasic/Window1.xaml.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ActualHeightProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ActualHeightProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ActualHeightProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.ActualHeightProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ActualHeightProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ActualHeightProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable ActualHeightProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.ActualHeightProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="P:System.Windows.FrameworkElement.ActualHeight" /> 依赖项属性。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ActualWidth">
      <MemberSignature Language="C#" Value="public double ActualWidth { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 ActualWidth" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.ActualWidth" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ActualWidth As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double ActualWidth { double get(); };" />
      <MemberSignature Language="F#" Value="member this.ActualWidth : double" Usage="System.Windows.FrameworkElement.ActualWidth" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取此元素的呈现宽度。</summary>
        <value>元素的宽度，这是一个采用[!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]的值。 默认值为 0（零）。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此属性是基于其他宽度输入和布局系统的计算的值。 值由布局系统本身基于实际呈现的传递，设置，因此可能稍微小于属性的设置值如<xref:System.Windows.FrameworkElement.Width%2A>是作为输入更改的基础。  
  
 因为<xref:System.Windows.FrameworkElement.ActualWidth%2A>是计算后的值，应注意可能有多次或递增的报告更改为它作为各种操作结果由布局系统。 布局系统可能会计算子元素所需的测量空间、父元素的约束等。  
  
 尽管您不能设置此属性从[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]，您可以基于<xref:System.Windows.Trigger>样式中其值。  
  
<a name="dependencyPropertyInfo_ActualWidth"></a>   
## <a name="dependency-property-information"></a>依赖项属性信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.FrameworkElement.ActualWidthProperty>|  
|元数据属性设置为 `true`|无|  
  
   
  
## Examples  
 以下示例显示各种宽度属性。  
  
 [!code-csharp[WidthMinWidthMaxWidth#3](~/samples/snippets/csharp/VS_Snippets_Wpf/WidthMinWidthMaxWidth/CSharp/Window1.xaml.cs#3)]
 [!code-vb[WidthMinWidthMaxWidth#3](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WidthMinWidthMaxWidth/VisualBasic/Window1.xaml.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ActualWidthProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ActualWidthProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ActualWidthProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.ActualWidthProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ActualWidthProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ActualWidthProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable ActualWidthProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.ActualWidthProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="P:System.Windows.FrameworkElement.ActualWidth" /> 依赖项属性。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddLogicalChild">
      <MemberSignature Language="C#" Value="protected internal void AddLogicalChild (object child);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance void AddLogicalChild(object child) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.AddLogicalChild(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Sub AddLogicalChild (child As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; void AddLogicalChild(System::Object ^ child);" />
      <MemberSignature Language="F#" Value="member this.AddLogicalChild : obj -&gt; unit" Usage="frameworkElement.AddLogicalChild child" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="child" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="child">要添加的子元素。</param>
        <summary>将提供的对象添加到此元素的逻辑树。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用此方法的实现的对象表示的元素的逻辑子元素上的集合。 子元素集合的集合维护操作可能会在属性 getter 或 setter，类处理的 Changed 事件，构造函数，或在自己的集合类型。  
  
 为控件创作者，操作逻辑树在此级别不是建议的做法，除非所有可用的基控件类的内容模型都适用于你控制的方案。 子类化的级别，请考虑<xref:System.Windows.Controls.ContentControl>， <xref:System.Windows.Controls.ItemsControl>，和<xref:System.Windows.Controls.HeaderedItemsControl>。 这些类提供与特定强制通过专用的逻辑树子元素的内容模型[!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)]，以及对其他功能中通常所需的支持[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]如通过模板设置样式的控件。 有关如何使用的详细信息<xref:System.Windows.FrameworkElement.LogicalChildren%2A>并<xref:System.Windows.FrameworkElement.AddLogicalChild%2A>，请参阅[WPF 中的树](~/docs/framework/wpf/advanced/trees-in-wpf.md)。  
  
 <xref:System.Windows.FrameworkElement.AddLogicalChild%2A> 如果在另一个进程循环访问逻辑树时调用，可能会引发异常。  
  
   
  
## Examples  
 下面的示例实现`Child`的自定义属性<xref:System.Windows.FrameworkElement>执行其自己的可视化层实现的。 属性 setter 被设计，以便如果的值发生更改，从逻辑树中，以及特定于类的可视集合中删除旧值。 缓存的属性值，并随后将新值添加到逻辑树和自定义可视化的集合。  
  
 [!code-csharp[CompositionTargetRenderingAnimations#AddRemoveLogicalChild](~/samples/snippets/csharp/VS_Snippets_Wpf/CompositionTargetRenderingAnimations/CSharp/ParticleEffectExamples/OverlayRenderDecorator.cs#addremovelogicalchild)]
 [!code-vb[CompositionTargetRenderingAnimations#AddRemoveLogicalChild](~/samples/snippets/visualbasic/VS_Snippets_Wpf/CompositionTargetRenderingAnimations/visualbasic/particleeffectexamples/overlayrenderdecorator.vb#addremovelogicalchild)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkElement.RemoveLogicalChild(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="ApplyTemplate">
      <MemberSignature Language="C#" Value="public bool ApplyTemplate ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ApplyTemplate() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.ApplyTemplate" />
      <MemberSignature Language="VB.NET" Value="Public Function ApplyTemplate () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ApplyTemplate();" />
      <MemberSignature Language="F#" Value="member this.ApplyTemplate : unit -&gt; bool" Usage="frameworkElement.ApplyTemplate " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>在必要时生成当前模板的可视化树，然后返回一个值，该值指示可视化树是否由此调用重新生成。</summary>
        <returns>如果在树中添加了视觉对象，则返回 <see langword="true" />；否则返回 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 应用程序可以调用此方法，以保证元素的可视化树的已完成。 如果代码将检查在树中的子元素，则可能需要采用此保证步骤。 为调用的应用程序中的典型元素逻辑<xref:System.Windows.FrameworkElement.ApplyTemplate%2A>不必要的因为模板将应用于合适的点处的元素在其生存期自动。  
  
 <xref:System.Windows.FrameworkElement.ApplyTemplate%2A> 在每个度量值上调用传递由 WPF 框架级别的布局系统。  
  
 <xref:System.Windows.FrameworkElement> 派生的类可以使用<xref:System.Windows.FrameworkElement.OnApplyTemplate%2A>类处理程序的情况下在其中显式调用此方法或由布局系统接收通知。 <xref:System.Windows.FrameworkElement.OnApplyTemplate%2A> 模板是完全生成，并附加到逻辑树之后调用。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.ControlTemplate" />
      </Docs>
    </Member>
    <Member MemberName="ArrangeCore">
      <MemberSignature Language="C#" Value="protected override sealed void ArrangeCore (System.Windows.Rect finalRect);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void ArrangeCore(valuetype System.Windows.Rect finalRect) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.ArrangeCore(System.Windows.Rect)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides NotOverridable Sub ArrangeCore (finalRect As Rect)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void ArrangeCore(System::Windows::Rect finalRect);" />
      <MemberSignature Language="F#" Value="override this.ArrangeCore : System.Windows.Rect -&gt; unit" Usage="frameworkElement.ArrangeCore finalRect" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="finalRect" Type="System.Windows.Rect" />
      </Parameters>
      <Docs>
        <param name="finalRect">父级中应使用此元素排列自身及其子元素的最终区域。</param>
        <summary>实现 <see cref="M:System.Windows.UIElement.ArrangeCore(System.Windows.Rect)" />（在 <see cref="T:System.Windows.UIElement" /> 中定义为虚拟对象）并密封实现。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法被密封。 若要重写中专门用于元素布局的排列处理你自定义元素的逻辑应用<xref:System.Windows.FrameworkElement>派生的类必须重写<xref:System.Windows.FrameworkElement.ArrangeOverride%2A>。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.UIElement.Arrange(System.Windows.Rect)" />
      </Docs>
    </Member>
    <Member MemberName="ArrangeOverride">
      <MemberSignature Language="C#" Value="protected virtual System.Windows.Size ArrangeOverride (System.Windows.Size finalSize);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance valuetype System.Windows.Size ArrangeOverride(valuetype System.Windows.Size finalSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.ArrangeOverride(System.Windows.Size)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function ArrangeOverride (finalSize As Size) As Size" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Windows::Size ArrangeOverride(System::Windows::Size finalSize);" />
      <MemberSignature Language="F#" Value="abstract member ArrangeOverride : System.Windows.Size -&gt; System.Windows.Size&#xA;override this.ArrangeOverride : System.Windows.Size -&gt; System.Windows.Size" Usage="frameworkElement.ArrangeOverride finalSize" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Size</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="finalSize" Type="System.Windows.Size" />
      </Parameters>
      <Docs>
        <param name="finalSize">父级中应使用此元素排列自身及其子元素的最终区域。</param>
        <summary>在派生类中重写时，为 <see cref="T:System.Windows.FrameworkElement" /> 派生类定位子元素并确定大小。</summary>
        <returns>使用的实际大小。</returns>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides">
          <para>想要自定义布局处理的排列处理控件作者应重写此方法。 实现模式应调用<see cref="M:System.Windows.UIElement.Arrange(System.Windows.Rect)" />每个可见子元素和传递的最终所需大小为每个子元素上<paramref name="finalRect" />参数。 父元素应调用<see cref="M:System.Windows.UIElement.Arrange(System.Windows.Rect)" />在每个的子活动，否则子元素将不会呈现。  
  
多个派生的类提供了此方法的实现。 其中主要的包括： <see cref="M:System.Windows.Window.ArrangeOverride(System.Windows.Size)" />，<see cref="M:System.Windows.Controls.Page.ArrangeOverride(System.Windows.Size)" />和<see cref="M:System.Windows.Controls.Control.ArrangeOverride(System.Windows.Size)" />。</para>
        </block>
        <altmember cref="M:System.Windows.UIElement.Arrange(System.Windows.Rect)" />
      </Docs>
    </Member>
    <Member MemberName="BeginInit">
      <MemberSignature Language="C#" Value="public virtual void BeginInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void BeginInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.BeginInit" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub BeginInit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void BeginInit();" />
      <MemberSignature Language="F#" Value="abstract member BeginInit : unit -&gt; unit&#xA;override this.BeginInit : unit -&gt; unit" Usage="frameworkElement.BeginInit " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>启动此元素的初始化过程。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果在尚未公开，或将元素连接到任何元素树的方式调整它们，可以对单独的元素调用此方法。 例如，你可能已创建一个新<xref:System.Windows.FrameworkElement>，但具有尚未将其附加到任何逻辑树。 或者，其中您的元素是在其中一个子元素的逻辑树可能未连接到窗口或应用程序页。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>实现此方法以提供您的元素在元素加载过程中在初始化之前应发生这种情况的特殊处理。  
  
您的实现应调用基实现，因为基本 （默认值） 实现设置要跟踪的初始化一些内部标志。 一个可能的实现是使用此方法作为挂钩到自己的构造函数未已启用的私有类初始化例程。  
  
基实现将引发异常，如果<see cref="M:System.Windows.FrameworkElement.BeginInit" />称为不止一次在同一个元素之前<see cref="M:System.Windows.FrameworkElement.EndInit" />被调用。</para>
        </block>
        <altmember cref="M:System.Windows.FrameworkElement.EndInit" />
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginStoryboard">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>开始所提供的演示图板中包含的操作序列。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginStoryboard">
      <MemberSignature Language="C#" Value="public void BeginStoryboard (System.Windows.Media.Animation.Storyboard storyboard);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BeginStoryboard(class System.Windows.Media.Animation.Storyboard storyboard) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BeginStoryboard(System::Windows::Media::Animation::Storyboard ^ storyboard);" />
      <MemberSignature Language="F#" Value="member this.BeginStoryboard : System.Windows.Media.Animation.Storyboard -&gt; unit" Usage="frameworkElement.BeginStoryboard storyboard" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="storyboard" Type="System.Windows.Media.Animation.Storyboard" />
      </Parameters>
      <Docs>
        <param name="storyboard">要开始的演示图板。</param>
        <summary>开始所提供的演示图板中包含的操作序列。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 动画的最典型方案不使用此方法。 通常情况下，创建<xref:System.Windows.Media.Animation.Storyboard>或<xref:System.Windows.Media.Animation.BeginStoryboard>元素标记，然后将它们作为<xref:System.Windows.EventTrigger>上一个元素的内容。 由事件触发，动画将运行。 控制的各个方面的大多数<xref:System.Windows.Media.Animation.Storyboard>可以通过在标记中公开的属性进行寻址。  
  
 不使用的签名`isControllable`，参数，或指定该参数时`false`，与动画相关联的时间线时钟动画到达"填充"时间段时，就立即删除。 因此不能一次运行后重新启动动画。 控制动画还要求具有情节提要[X:name 指令](~/docs/framework/xaml-services/x-name-directive.md)或可通过在代码中的引用。  
  
   
  
## Examples  
 下面的示例检索<xref:System.Windows.Media.Animation.Storyboard>从资源，然后运行的<xref:System.Windows.Media.Animation.Storyboard>时对内部事件进行类处理。  
  
 [!code-csharp[CubeAnimation#FEBeginStoryboard](~/samples/snippets/csharp/VS_Snippets_Wpf/CubeAnimation/CSharp/Page1.xaml.cs#febeginstoryboard)]
 [!code-vb[CubeAnimation#FEBeginStoryboard](~/samples/snippets/visualbasic/VS_Snippets_Wpf/CubeAnimation/visualbasic/page1.xaml.vb#febeginstoryboard)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginStoryboard">
      <MemberSignature Language="C#" Value="public void BeginStoryboard (System.Windows.Media.Animation.Storyboard storyboard, System.Windows.Media.Animation.HandoffBehavior handoffBehavior);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BeginStoryboard(class System.Windows.Media.Animation.Storyboard storyboard, valuetype System.Windows.Media.Animation.HandoffBehavior handoffBehavior) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BeginStoryboard(System::Windows::Media::Animation::Storyboard ^ storyboard, System::Windows::Media::Animation::HandoffBehavior handoffBehavior);" />
      <MemberSignature Language="F#" Value="member this.BeginStoryboard : System.Windows.Media.Animation.Storyboard * System.Windows.Media.Animation.HandoffBehavior -&gt; unit" Usage="frameworkElement.BeginStoryboard (storyboard, handoffBehavior)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="storyboard" Type="System.Windows.Media.Animation.Storyboard" />
        <Parameter Name="handoffBehavior" Type="System.Windows.Media.Animation.HandoffBehavior" />
      </Parameters>
      <Docs>
        <param name="storyboard">要开始的演示图板。</param>
        <param name="handoffBehavior">一个枚举值，该值描述演示图板中描述的属性在经过动画处理后要使用的行为。</param>
        <summary>开始所提供的演示图板中包含的操作序列，并指定选项来指明当已对属性进行动画处理时应发生的行为。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 动画的最典型方案不使用此方法。 通常情况下，创建<xref:System.Windows.Media.Animation.Storyboard>或<xref:System.Windows.Media.Animation.BeginStoryboard>元素标记，然后将它们作为<xref:System.Windows.EventTrigger>上一个元素的内容。 由事件触发，动画将运行。 控制的各个方面的大多数<xref:System.Windows.Media.Animation.Storyboard>可以通过在标记中公开的属性进行寻址。  
  
 不使用的签名`isControllable`，参数，或指定该参数时`false`，与动画相关联的时间线时钟动画到达"填充"时间段时，就立即删除。 因此不能一次运行后重新启动动画。 控制动画还要求具有情节提要[X:name 指令](~/docs/framework/xaml-services/x-name-directive.md)或可通过在代码中的引用。  
  
 切换行为可以指定的属性为<xref:System.Windows.Media.Animation.BeginStoryboard>。  
  
## <a name="using-the-compose-handoffbehavior"></a>使用组合 HandoffBehavior  
 当应用<xref:System.Windows.Media.Animation.Storyboard>， <xref:System.Windows.Media.Animation.AnimationTimeline>，或<xref:System.Windows.Media.Animation.AnimationClock>到通过使用属性<xref:System.Windows.Media.Animation.HandoffBehavior.Compose> <xref:System.Windows.Media.Animation.HandoffBehavior>，则所有<xref:System.Windows.Media.Animation.Clock>之前与该属性相关联的对象继续消耗系统资源时，计时系统将执行不自动删除时钟。  
  
 若要避免出现性能问题，通过使用应用大量时钟时<xref:System.Windows.Media.Animation.HandoffBehavior.Compose>，它们完成后，您应该从属性的基值删除组合时钟。 有几种方法来移除时钟：  
  
-   若要从属性中删除所有时钟，请使用<xref:System.Windows.Media.Animation.Animatable.ApplyAnimationClock%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationClock%29>或<xref:System.Windows.Media.Animation.Animatable.BeginAnimation%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationTimeline%29>经过动画处理的对象的方法。 指定要进行动画处理的第一个参数的属性和`null`为第二个。 这将从属性中删除所有的动画时钟。  
  
-   若要删除特定<xref:System.Windows.Media.Animation.AnimationClock>从列表中的时钟，使用<xref:System.Windows.Media.Animation.Clock.Controller%2A>属性<xref:System.Windows.Media.Animation.AnimationClock>检索<xref:System.Windows.Media.Animation.ClockController>，然后调用<xref:System.Windows.Media.Animation.ClockController.Remove%2A>方法<xref:System.Windows.Media.Animation.ClockController>。 这通常是<xref:System.Windows.Media.Animation.Clock.Completed>时钟的事件处理程序。 请注意，只有根时钟可以受<xref:System.Windows.Media.Animation.ClockController>;<xref:System.Windows.Media.Animation.Clock.Controller%2A>属性的子时钟返回`null`。 另请注意，<xref:System.Windows.Media.Animation.Clock.Completed>如果时钟的有效持续时间将永远不会引发事件。  在这种情况下，用户必须确定何时调用<xref:System.Windows.Media.Animation.ClockController.Remove%2A>。  
  
 此动画问题主要出现在生存期较长的对象上。  垃圾回收对象时，它的时钟也会断开连接和垃圾回收。  
  
 有关时钟对象的详细信息，请参阅[动画和计时系统概述](~/docs/framework/wpf/graphics-multimedia/animation-and-timing-system-overview.md)。  
  
   
  
## Examples  
 下面的示例检索<xref:System.Windows.Media.Animation.Storyboard>从资源，然后运行的<xref:System.Windows.Media.Animation.Storyboard>时对内部事件进行类处理。  
  
 [!code-csharp[CubeAnimation#FEBeginStoryboard](~/samples/snippets/csharp/VS_Snippets_Wpf/CubeAnimation/CSharp/Page1.xaml.cs#febeginstoryboard)]
 [!code-vb[CubeAnimation#FEBeginStoryboard](~/samples/snippets/visualbasic/VS_Snippets_Wpf/CubeAnimation/visualbasic/page1.xaml.vb#febeginstoryboard)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginStoryboard">
      <MemberSignature Language="C#" Value="public void BeginStoryboard (System.Windows.Media.Animation.Storyboard storyboard, System.Windows.Media.Animation.HandoffBehavior handoffBehavior, bool isControllable);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BeginStoryboard(class System.Windows.Media.Animation.Storyboard storyboard, valuetype System.Windows.Media.Animation.HandoffBehavior handoffBehavior, bool isControllable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BeginStoryboard(System::Windows::Media::Animation::Storyboard ^ storyboard, System::Windows::Media::Animation::HandoffBehavior handoffBehavior, bool isControllable);" />
      <MemberSignature Language="F#" Value="member this.BeginStoryboard : System.Windows.Media.Animation.Storyboard * System.Windows.Media.Animation.HandoffBehavior * bool -&gt; unit" Usage="frameworkElement.BeginStoryboard (storyboard, handoffBehavior, isControllable)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="storyboard" Type="System.Windows.Media.Animation.Storyboard" />
        <Parameter Name="handoffBehavior" Type="System.Windows.Media.Animation.HandoffBehavior" />
        <Parameter Name="isControllable" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="storyboard">要开始的演示图板。</param>
        <param name="handoffBehavior">一个枚举值，该值描述演示图板中描述的属性在经过动画处理后要使用的行为。</param>
        <param name="isControllable">声明在动画开始后是否仍可以对它进行控制（可以暂停）。</param>
        <summary>开始所提供的演示图板中包含的操作序列，并使动画控件在动画开始后具有指定的状态。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 动画的最典型方案不使用此方法。 通常情况下，创建<xref:System.Windows.Media.Animation.Storyboard>或<xref:System.Windows.Media.Animation.BeginStoryboard>元素标记，然后将它们作为<xref:System.Windows.EventTrigger>上一个元素的内容。 由事件触发，动画将运行。 控制的各个方面的大多数<xref:System.Windows.Media.Animation.Storyboard>可以通过在标记中公开的属性进行寻址。  
  
 不使用的签名`isControllable`，参数，或指定该参数时`false`，与动画相关联的时间线时钟动画到达"填充"时间段时，就立即删除。 因此不能一次运行后重新启动动画。 控制动画还要求具有情节提要[X:name 指令](~/docs/framework/xaml-services/x-name-directive.md)或可通过在代码中的引用。  
  
 切换行为可以指定的属性为<xref:System.Windows.Media.Animation.BeginStoryboard>。  
  
## <a name="using-the-compose-handoffbehavior"></a>使用组合 HandoffBehavior  
 当应用<xref:System.Windows.Media.Animation.Storyboard>， <xref:System.Windows.Media.Animation.AnimationTimeline>，或<xref:System.Windows.Media.Animation.AnimationClock>到通过使用属性<xref:System.Windows.Media.Animation.HandoffBehavior.Compose> <xref:System.Windows.Media.Animation.HandoffBehavior>，则所有<xref:System.Windows.Media.Animation.Clock>之前与该属性相关联的对象继续消耗系统资源时，计时系统将执行不自动删除时钟。  
  
 若要避免出现性能问题，通过使用应用大量时钟时<xref:System.Windows.Media.Animation.HandoffBehavior.Compose>，它们完成后，您应该从属性的基值删除组合时钟。 有几种方法来移除时钟：  
  
-   若要从属性中删除所有时钟，请使用<xref:System.Windows.Media.Animation.Animatable.ApplyAnimationClock%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationClock%29>或<xref:System.Windows.Media.Animation.Animatable.BeginAnimation%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationTimeline%29>经过动画处理的对象的方法。 指定要进行动画处理的第一个参数的属性和`null`为第二个。 这将从属性中删除所有的动画时钟。  
  
-   若要删除特定<xref:System.Windows.Media.Animation.AnimationClock>从列表中的时钟，使用<xref:System.Windows.Media.Animation.Clock.Controller%2A>属性<xref:System.Windows.Media.Animation.AnimationClock>检索<xref:System.Windows.Media.Animation.ClockController>，然后调用<xref:System.Windows.Media.Animation.ClockController.Remove%2A>方法<xref:System.Windows.Media.Animation.ClockController>。 这通常是<xref:System.Windows.Media.Animation.Clock.Completed>时钟的事件处理程序。 请注意，只有根时钟可以受<xref:System.Windows.Media.Animation.ClockController>;<xref:System.Windows.Media.Animation.Clock.Controller%2A>属性的子时钟返回`null`。 另请注意，<xref:System.Windows.Media.Animation.Clock.Completed>如果时钟的有效持续时间将永远不会引发事件。  在这种情况下，用户必须确定何时调用<xref:System.Windows.Media.Animation.ClockController.Remove%2A>。  
  
 此动画问题主要出现在生存期较长的对象上。  垃圾回收对象时，它的时钟也会断开连接和垃圾回收。  
  
 有关时钟对象的详细信息，请参阅[动画和计时系统概述](~/docs/framework/wpf/graphics-multimedia/animation-and-timing-system-overview.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BindingGroup">
      <MemberSignature Language="C#" Value="public System.Windows.Data.BindingGroup BindingGroup { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Data.BindingGroup BindingGroup" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.BindingGroup" />
      <MemberSignature Language="VB.NET" Value="Public Property BindingGroup As BindingGroup" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Data::BindingGroup ^ BindingGroup { System::Windows::Data::BindingGroup ^ get(); void set(System::Windows::Data::BindingGroup ^ value); };" />
      <MemberSignature Language="F#" Value="member this.BindingGroup : System.Windows.Data.BindingGroup with get, set" Usage="System.Windows.FrameworkElement.BindingGroup" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.NeverLocalize)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Data.BindingGroup</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置用于该元素的 <see cref="T:System.Windows.Data.BindingGroup" />。</summary>
        <value>用于该元素的 <see cref="T:System.Windows.Data.BindingGroup" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 一个<xref:System.Windows.Data.BindingGroup>可用于验证对象的多个属性的值。 例如，假设应用程序提示用户输入地址，然后填充类型的对象`Address`，其中包含属性`Street`， `City`， `ZipCode`，和`Country`，使用值的用户提供。 应用程序必须包含四个面板<xref:System.Windows.Controls.TextBox>控件，其中每个绑定到对象的属性之一。 可以使用<xref:System.Windows.Controls.ValidationRule>中<xref:System.Windows.Data.BindingGroup>验证`Address`对象。 例如，<xref:System.Windows.Controls.ValidationRule>可以确保 zip 代码是有效的国家/地区的地址。  
  
 子元素继承<xref:System.Windows.Data.BindingGroup>从其父元素，就像使用任何其他可继承属性。  
  
<a name="dependencyPropertyInfo_BindingGroup"></a>   
## <a name="dependency-property-information"></a>依赖项属性信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.FrameworkElement.BindingGroupProperty>|  
|元数据属性设置为 **，则返回 true**|<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
   
  
## Examples  
 下面的示例是检查用户是否已设置为相等的值的两个对象的属性的应用程序的一部分。 第一个示例创建两个<xref:System.Windows.Controls.TextBox>控件，其中每个绑定到不同的数据源。 <xref:System.Windows.Controls.StackPanel>已<xref:System.Windows.Data.BindingGroup>，其中包含<xref:System.Windows.Controls.ValidationRule>，用于检查两个字符串是否相等。  
  
 [!code-xaml[BindingGroupSnippets#BindingGroupComplete](~/samples/snippets/csharp/VS_Snippets_Wpf/BindingGroupSnippets/CSharp/Window3.xaml#bindinggroupcomplete)]  
  
 下面的示例演示<xref:System.Windows.Controls.ValidationRule>的上一个示例使用。  在中<xref:System.Windows.Controls.ValidationRule.Validate%2A>方法重写此示例获取的每个源对象<xref:System.Windows.Data.BindingGroup>，并检查是否相等的对象的属性。  
  
 [!code-csharp[BindingGroupSnippets#BindingGroupNameValidationRule](~/samples/snippets/csharp/VS_Snippets_Wpf/BindingGroupSnippets/CSharp/Window3.xaml.cs#bindinggroupnamevalidationrule)]
 [!code-vb[BindingGroupSnippets#BindingGroupNameValidationRule](~/samples/snippets/visualbasic/VS_Snippets_Wpf/BindingGroupSnippets/visualbasic/window3.xaml.vb#bindinggroupnamevalidationrule)]  
  
 若要调用<xref:System.Windows.Controls.ValidationRule>，调用<xref:System.Windows.Data.BindingGroup.UpdateSources%2A>方法。  下面的示例调用<xref:System.Windows.Data.BindingGroup.UpdateSources%2A>按钮的 click 事件发生时。  
  
 [!code-csharp[BindingGroupSnippets#UpdateSourcesClick](~/samples/snippets/csharp/VS_Snippets_Wpf/BindingGroupSnippets/CSharp/Window3.xaml.cs#updatesourcesclick)]
 [!code-vb[BindingGroupSnippets#UpdateSourcesClick](~/samples/snippets/visualbasic/VS_Snippets_Wpf/BindingGroupSnippets/visualbasic/window3.xaml.vb#updatesourcesclick)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BindingGroupProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty BindingGroupProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty BindingGroupProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.BindingGroupProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly BindingGroupProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ BindingGroupProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable BindingGroupProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.BindingGroupProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="P:System.Windows.FrameworkElement.BindingGroup" /> 依赖项属性。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="BringIntoView">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>尝试将此元素放入其所在的任何可滚动区域内的视图中。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BringIntoView">
      <MemberSignature Language="C#" Value="public void BringIntoView ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BringIntoView() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.BringIntoView" />
      <MemberSignature Language="VB.NET" Value="Public Sub BringIntoView ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BringIntoView();" />
      <MemberSignature Language="F#" Value="member this.BringIntoView : unit -&gt; unit" Usage="frameworkElement.BringIntoView " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>尝试将此元素放入其所在的任何可滚动区域内的视图中。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 通过调用此方法，你将提升<xref:System.Windows.FrameworkElement.RequestBringIntoView>源自当前元素的事件。 以便可以通过对其进行处理，将引发此事件<xref:System.Windows.Controls.ScrollViewer>，或派生或类似的类。 预期的行为是由标记为已处理事件数据中的父元素处理事件和事件源放入视图中嵌入的逻辑通过<xref:System.Windows.Controls.ScrollViewer>控件。 既不<xref:System.Windows.FrameworkElement.RequestBringIntoView>事件和<xref:System.Windows.FrameworkElement.BringIntoView%2A>方法不会传输有关成功或失败，以外，通常会将事件标记为已处理上成功的任何信息。 故障可包括元素设置中，如下所述的原因<xref:System.Windows.UIElement.Visibility%2A>以外的值<xref:System.Windows.Visibility.Visible>。  
  
 如果使用未指定的签名`targetRectangle`，然后整个元素大小 (其<xref:System.Windows.UIElement.RenderSize%2A>) 将变为可见。  
  
 通过调用此方法，你可能会调用<xref:System.Windows.Controls.ScrollContentPresenter.MakeVisible%2A>任何父可滚动区域中包含的元素。 如果此元素未包含在可滚动区域中，<xref:System.Windows.FrameworkElement.RequestBringIntoView>仍引发事件，但因为没有事件侦听器会将不起作用。  
  
   
  
## Examples  
 下面的示例实现每当响应应用程序导航事件的处理程序[!INCLUDE[TLA#tla_uri](~/includes/tlasharptla-uri-md.md)]要导航到包含碎片。 在名为片段[!INCLUDE[TLA2#tla_uri](~/includes/tla2sharptla-uri-md.md)]的哈希符号 （#），并且实现的行为将导致要滚动到视图的框架内的元素。 <xref:System.Windows.FrameworkElement.BringIntoView%2A> 和<xref:System.Windows.FrameworkElement.RequestBringIntoView>请求示例中的滚动行为。  
  
 [!code-csharp[FragmentNavigationSample#FEBringIntoView](~/samples/snippets/csharp/VS_Snippets_Wpf/FragmentNavigationSample/CSharp/MainWindow.xaml.cs#febringintoview)]
 [!code-vb[FragmentNavigationSample#FEBringIntoView](~/samples/snippets/visualbasic/VS_Snippets_Wpf/FragmentNavigationSample/VisualBasic/MainWindow.xaml.vb#febringintoview)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.ScrollViewer" />
      </Docs>
    </Member>
    <Member MemberName="BringIntoView">
      <MemberSignature Language="C#" Value="public void BringIntoView (System.Windows.Rect targetRectangle);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BringIntoView(valuetype System.Windows.Rect targetRectangle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.BringIntoView(System.Windows.Rect)" />
      <MemberSignature Language="VB.NET" Value="Public Sub BringIntoView (targetRectangle As Rect)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BringIntoView(System::Windows::Rect targetRectangle);" />
      <MemberSignature Language="F#" Value="member this.BringIntoView : System.Windows.Rect -&gt; unit" Usage="frameworkElement.BringIntoView targetRectangle" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="targetRectangle" Type="System.Windows.Rect" />
      </Parameters>
      <Docs>
        <param name="targetRectangle">也应放入视图中的元素的指定大小。</param>
        <summary>尝试将此元素的提供区域大小放入其所在的任何可滚动区域内的视图中。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 通过调用此方法，你将提升<xref:System.Windows.FrameworkElement.RequestBringIntoView>源自当前元素的事件。 以便可以通过对其进行处理，将引发此事件<xref:System.Windows.Controls.ScrollViewer>，或派生或类似的类。 预期的行为是由标记为已处理事件数据中的父元素处理事件和事件源放入视图中嵌入的逻辑通过<xref:System.Windows.Controls.ScrollViewer>控件。 既不<xref:System.Windows.FrameworkElement.RequestBringIntoView>事件和<xref:System.Windows.FrameworkElement.BringIntoView%2A>方法不会传输有关成功或失败，以外，通常会将事件标记为已处理上成功的任何信息。 故障可包括元素设置中，如下所述的原因<xref:System.Windows.UIElement.Visibility%2A>以外的值<xref:System.Windows.Visibility.Visible>。  
  
 如果使用未指定的签名`targetRectangle`，然后整个元素大小 (其<xref:System.Windows.UIElement.RenderSize%2A>) 将变为可见。  
  
 通过调用此方法，你可能会调用<xref:System.Windows.Controls.ScrollContentPresenter.MakeVisible%2A>任何父可滚动区域中包含的元素。 如果此元素未包含在可滚动区域中，<xref:System.Windows.FrameworkElement.RequestBringIntoView>仍引发事件，但因为没有事件侦听器会将不起作用。  
  
   
  
## Examples  
 下面的示例在受约束的滚动区域中有一幅大图。 在页上的按钮具有滚动到大型图形的特定区域的视图的处理程序。  
  
 [!code-xaml[BaseElementsSmorgasbord#BringIntoViewRectMarkup](~/samples/snippets/csharp/VS_Snippets_Wpf/BaseElementsSmorgasbord/CSharp/Page1.xaml#bringintoviewrectmarkup)]  
  
 [!code-csharp[BaseElementsSmorgasbord#BringIntoViewRectCode](~/samples/snippets/csharp/VS_Snippets_Wpf/BaseElementsSmorgasbord/CSharp/Page1.xaml.cs#bringintoviewrectcode)]
 [!code-vb[BaseElementsSmorgasbord#BringIntoViewRectCode](~/samples/snippets/visualbasic/VS_Snippets_Wpf/BaseElementsSmorgasbord/visualbasic/page1.xaml.vb#bringintoviewrectcode)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.FlowDocumentScrollViewer" />
      </Docs>
    </Member>
    <Member MemberName="ContextMenu">
      <MemberSignature Language="C#" Value="public System.Windows.Controls.ContextMenu ContextMenu { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Controls.ContextMenu ContextMenu" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.ContextMenu" />
      <MemberSignature Language="VB.NET" Value="Public Property ContextMenu As ContextMenu" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Controls::ContextMenu ^ ContextMenu { System::Windows::Controls::ContextMenu ^ get(); void set(System::Windows::Controls::ContextMenu ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ContextMenu : System.Windows.Controls.ContextMenu with get, set" Usage="System.Windows.FrameworkElement.ContextMenu" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.ContextMenu</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置每当通过[!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)] 从此元素内部请求上下文菜单时应该显示的上下文菜单元素。</summary>
        <value>分配给此元素的上下文菜单。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Controls.ContextMenu> 本身是<xref:System.Windows.FrameworkElement>派生的类，并从技术上讲可能<xref:System.Windows.Controls.ContextMenu>本身可以具有<xref:System.Windows.FrameworkElement.ContextMenu%2A>属性。 但是，这将创建令人困惑的上下文菜单体验的用户并不推荐这样做。  
  
<a name="dependencyPropertyInfo_ContextMenu"></a>   
## <a name="dependency-property-information"></a>依赖项属性信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.FrameworkElement.ContextMenuProperty>|  
|元数据属性设置为 `true`|无|  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.ContextMenu" />
      </Docs>
    </Member>
    <Member MemberName="ContextMenuClosing">
      <MemberSignature Language="C#" Value="public event System.Windows.Controls.ContextMenuEventHandler ContextMenuClosing;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Controls.ContextMenuEventHandler ContextMenuClosing" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkElement.ContextMenuClosing" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ContextMenuClosing As ContextMenuEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Controls::ContextMenuEventHandler ^ ContextMenuClosing;" />
      <MemberSignature Language="F#" Value="member this.ContextMenuClosing : System.Windows.Controls.ContextMenuEventHandler " Usage="member this.ContextMenuClosing : System.Windows.Controls.ContextMenuEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.ContextMenuEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在元素上的任何上下文菜单关闭之前发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要取消关闭上下文菜单，该事件的处理程序应将其标记为已处理。  
  
 若要将此事件用作<xref:System.Windows.EventTrigger>在样式中，必须引用事件的基础服务的定义：  
  
 [!code-xaml[CorePseudocode#FEContextMenuClosing](~/samples/snippets/csharp/VS_Snippets_Wpf/CorePseudocode/CSharp/pseudocode.xaml#fecontextmenuclosing)]  
  
 (这种用法是必需的因为上的事件实现<xref:System.Windows.FrameworkElement>，公开基础的服务事件不会映射<xref:System.Windows.FrameworkElement.ContextMenuClosing>标识符，以便可以将其用作触发器)。  
  
 <xref:System.Windows.Controls.ContextMenu> 本身是<xref:System.Windows.FrameworkElement>派生的类，但<xref:System.Windows.FrameworkElement.ContextMenuClosing>不会引发事件的上下文菜单直接。 相反，从"拥有"作为属性的上下文菜单和仅在用户尝试关闭 UI 中的上下文菜单时引发的元素引发该事件。 但是有可能<xref:System.Windows.Controls.ContextMenu>本身可以具有<xref:System.Windows.FrameworkElement.ContextMenu%2A>属性 （嵌入的上下文菜单）。 在这种情况下<xref:System.Windows.Controls.ContextMenu>实际上确实拥有嵌套<xref:System.Windows.Controls.ContextMenu>和可能引发具有嵌入的上下文菜单上的事件源的事件。  
  
 <xref:System.Windows.Controls.ContextMenu>类本身也有类似的事件 (<xref:System.Windows.Controls.ContextMenu.Closed>)，但<xref:System.Windows.Controls.ContextMenu.Closed>不，事件会向你提供取消用户操作的机会。  
  
<a name="routedEventInfo_ContextMenuClosing"></a>   
## <a name="routed-event-information"></a>路由事件信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.FrameworkElement.ContextMenuClosingEvent>|  
|路由策略|浮升|  
|委托|<xref:System.Windows.Controls.ContextMenuEventHandler>|  
  
-   重写<xref:System.Windows.FrameworkElement.OnContextMenuClosing%2A>实现类处理此事件在派生类中。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.ContextMenu" />
      </Docs>
    </Member>
    <Member MemberName="ContextMenuClosingEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent ContextMenuClosingEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent ContextMenuClosingEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.ContextMenuClosingEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ContextMenuClosingEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ ContextMenuClosingEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable ContextMenuClosingEvent : System.Windows.RoutedEvent" Usage="System.Windows.FrameworkElement.ContextMenuClosingEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="E:System.Windows.FrameworkElement.ContextMenuClosing" /> 路由事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在注册路由事件时创建路由事件标识符。 这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。 可以使用这些标识符添加类处理程序。  
  
 有关注册路由事件的更多信息，请参见 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。 有关使用路由事件标识符添加类处理程序的更多信息，请参见 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContextMenuOpening">
      <MemberSignature Language="C#" Value="public event System.Windows.Controls.ContextMenuEventHandler ContextMenuOpening;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Controls.ContextMenuEventHandler ContextMenuOpening" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkElement.ContextMenuOpening" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ContextMenuOpening As ContextMenuEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Controls::ContextMenuEventHandler ^ ContextMenuOpening;" />
      <MemberSignature Language="F#" Value="member this.ContextMenuOpening : System.Windows.Controls.ContextMenuEventHandler " Usage="member this.ContextMenuOpening : System.Windows.Controls.ContextMenuEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.ContextMenuEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在元素上的任何上下文菜单打开时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要手动打开上下文菜单，事件的处理程序应将相关的事件标记为已处理。 否则为现有值<xref:System.Windows.FrameworkElement.ContextMenu%2A>属性将用于自动打开上下文菜单。 将标记处理的事件将有效地取消默认操作，并且可重置的值的机会<xref:System.Windows.FrameworkElement.ContextMenu%2A>属性，然后打开新<xref:System.Windows.Controls.ContextMenu>。 但是，是应注意的计时问题。 若要完全替换通过上下文菜单<xref:System.Windows.FrameworkElement.ContextMenuOpening>处理程序中，初始上下文菜单不能为 null / 空。 或者，您可能需要处理的事件，然后手动打开新的上下文菜单。 有关详细信息，请参阅[如何： 处理 ContextMenuOpening 事件](~/docs/framework/wpf/advanced/how-to-handle-the-contextmenuopening-event.md)。  
  
 若要将此事件用作<xref:System.Windows.EventTrigger>在样式中，必须引用基础附加的事件：  
  
 [!code-xaml[CorePseudocode#FEContextMenuOpening](~/samples/snippets/csharp/VS_Snippets_Wpf/CorePseudocode/CSharp/pseudocode.xaml#fecontextmenuopening)]  
  
 (这种用法是必需的因为上的事件实现<xref:System.Windows.FrameworkElement>，公开基础的服务事件不会映射<xref:System.Windows.FrameworkElement.ContextMenuOpening>标识符，以便可以在触发器中使用)。  
  
 <xref:System.Windows.Controls.ContextMenu> 本身是<xref:System.Windows.FrameworkElement>派生的类，但不是会从上下文菜单正在打开作为源引发此事件。 从"拥有"作为属性的上下文菜单和仅在用户尝试在 UI 中打开上下文菜单时引发的元素引发该事件。 很可能<xref:System.Windows.Controls.ContextMenu>本身可以具有<xref:System.Windows.FrameworkElement.ContextMenu%2A>属性，但您应避免这种情况 (有关详细信息，请参阅<xref:System.Windows.FrameworkElement.ContextMenu%2A?displayProperty=nameWithType>)。  
  
 <xref:System.Windows.Controls.ContextMenu>类本身也有类似的事件 (<xref:System.Windows.Controls.ContextMenu.Opened>)，但<xref:System.Windows.Controls.ContextMenu.Opened>不提供取消用户操作的机会。  
  
<a name="routedEventInfo_ContextMenuOpening"></a>   
## <a name="routed-event-information"></a>路由事件信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.FrameworkElement.ContextMenuOpeningEvent>|  
|路由策略|浮升|  
|委托|<xref:System.Windows.Controls.ContextMenuEventHandler>|  
  
-   重写<xref:System.Windows.FrameworkElement.OnContextMenuOpening%2A>实现类处理此事件在派生类中。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.ContextMenu" />
      </Docs>
    </Member>
    <Member MemberName="ContextMenuOpeningEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent ContextMenuOpeningEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent ContextMenuOpeningEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.ContextMenuOpeningEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ContextMenuOpeningEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ ContextMenuOpeningEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable ContextMenuOpeningEvent : System.Windows.RoutedEvent" Usage="System.Windows.FrameworkElement.ContextMenuOpeningEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="E:System.Windows.FrameworkElement.ContextMenuOpening" /> 路由事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在注册路由事件时创建路由事件标识符。 这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。 可以使用这些标识符添加类处理程序。  
  
 有关注册路由事件的更多信息，请参见 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。 有关使用路由事件标识符添加类处理程序的更多信息，请参见 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContextMenuProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ContextMenuProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ContextMenuProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.ContextMenuProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ContextMenuProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ContextMenuProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable ContextMenuProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.ContextMenuProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="P:System.Windows.FrameworkElement.ContextMenu" /> 依赖项属性。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Cursor">
      <MemberSignature Language="C#" Value="public System.Windows.Input.Cursor Cursor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Input.Cursor Cursor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.Cursor" />
      <MemberSignature Language="VB.NET" Value="Public Property Cursor As Cursor" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Input::Cursor ^ Cursor { System::Windows::Input::Cursor ^ get(); void set(System::Windows::Input::Cursor ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Cursor : System.Windows.Input.Cursor with get, set" Usage="System.Windows.FrameworkElement.Cursor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.Cursor</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置在鼠标指针位于此元素上时显示的光标。</summary>
        <value>要显示的光标。 按此依赖属性，默认值定义为 <see langword="null" />。 但是，运行时的实际默认值将受到多种因素的影响。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在将此属性设置[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]，则[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]处理器将依赖类型转换为<xref:System.Windows.Input.Cursor>类来计算该字符串。 所提供的字符串的计算结果应为<xref:System.Windows.Input.CursorType>值。 有关详细信息，请参阅<xref:System.Windows.Input.Cursor>。  
  
 此属性所建立的光标将还是将不会显示在鼠标指针位于此元素上时也是依赖于的值<xref:System.Windows.FrameworkElement.ForceCursor%2A>属性。 此外，与事件相关的注意事项，如活动拖动、 鼠标捕获、 文本编辑模式中控件和等等，还将影响游标，并且其优先级高于此属性中指定的值。  
  
 若要还原的此属性设置为最终的默认行为，请将其设置为`null`试。  
  
 `null`默认值实际上意味着确定实际游标值的此处延迟，并且应从其他位置获取。 如果没有来自任何源编程值提供，默认游标是直观地超过[!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)]应用程序将是一个箭头。 但是，暂时性光标发生变化，未设置为<xref:System.Windows.FrameworkElement.Cursor%2A>时通过传递元素的值。 <xref:System.Windows.FrameworkElement.Cursor%2A>属性将只报告非 null 值在其中实际设置，例如通过代码或样式的情况下。 每个移动的鼠标悬停[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]应用程序将引发<xref:System.Windows.UIElement.QueryCursor>事件。 该事件冒泡，并且路由中的任何元素都有机会处理事件并设置游标通过此事件的参数的值。 这是显而易见的光标在大多数情况下将生成的机制。 如果<xref:System.Windows.UIElement.QueryCursor>处理程序返回游标结果，则这一事实事件进行处理，并且 in 实参具有一个更改的值将优先于的值<xref:System.Windows.FrameworkElement.Cursor%2A>属性在任何级别，除非<xref:System.Windows.FrameworkElement.ForceCursor%2A>设置。  
  
 如果不创建自定义光标，已将此属性通常设置为静态属性值的<xref:System.Windows.Input.Cursors>类。 设置<xref:System.Windows.FrameworkElement.Cursor%2A>在代码中需要以下项之一：  
  
-   调用<xref:System.Windows.Input.Cursor>构造函数获取<xref:System.Windows.Input.Cursor>实例。 这两个签名<xref:System.Windows.Input.Cursor>构造函数使用的流或文件，您创建的预期<xref:System.Windows.Input.Cursor>对象的自定义光标。  
  
-   使用<xref:System.Windows.Input.CursorConverter>类并将其<xref:System.Windows.Input.CursorConverter.ConvertFrom%2A>方法，以指定通过游标<xref:System.Windows.Input.CursorType>，或可以计算为字符串<xref:System.Windows.Input.CursorType>，并强制转换为恢复<xref:System.Windows.Input.Cursor>。  
  
 设置<xref:System.Windows.Input.Cursor>在部分信任环境中未启用为自定义值。 自定义光标的详细信息，请参阅[输入概述](~/docs/framework/wpf/advanced/input-overview.md)。  
  
<a name="dependencyPropertyInfo_Cursor"></a>   
## <a name="dependency-property-information"></a>依赖项属性信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.FrameworkElement.CursorProperty>|  
|元数据属性设置为 `true`|无|  
  
   
  
## Examples  
 下面的示例演示如何以故意光标图形。  
  
 [!code-csharp[cursors#ChangeCursorsSample](~/samples/snippets/csharp/VS_Snippets_Wpf/cursors/CSharp/Window1.xaml.cs#changecursorssample)]
 [!code-vb[cursors#ChangeCursorsSample](~/samples/snippets/visualbasic/VS_Snippets_Wpf/cursors/VisualBasic/Window1.xaml.vb#changecursorssample)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.QueryCursor" />
        <altmember cref="P:System.Windows.FrameworkElement.ForceCursor" />
        <altmember cref="P:System.Windows.Input.Mouse.OverrideCursor" />
      </Docs>
    </Member>
    <Member MemberName="CursorProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty CursorProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty CursorProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.CursorProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly CursorProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ CursorProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable CursorProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.CursorProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="P:System.Windows.FrameworkElement.Cursor" /> 依赖项属性。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DataContext">
      <MemberSignature Language="C#" Value="public object DataContext { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object DataContext" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.DataContext" />
      <MemberSignature Language="VB.NET" Value="Public Property DataContext As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ DataContext { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.DataContext : obj with get, set" Usage="System.Windows.FrameworkElement.DataContext" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.NeverLocalize)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置元素参与数据绑定时的数据上下文。</summary>
        <value>要用作数据上下文的对象。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 *数据上下文*是允许元素信息从其父元素继承有关用于绑定，以及绑定，如的路径的其他特征的数据源的概念。  
  
 在评估结果为该对象的属性的绑定，可以直接向.NET 对象，设置数据上下文。 或者，可以将数据上下文设置为<xref:System.Windows.Data.DataSourceProvider>对象。  
  
 此依赖属性继承属性值。 如果没有为其他值的子元素<xref:System.Windows.FrameworkElement.DataContext%2A>建立本地值或样式，通过属性系统会将设置此值为<xref:System.Windows.FrameworkElement.DataContext%2A>分配有此值最接近的父元素的值。  
  
 或者，可以使用以下属性之一<xref:System.Windows.Data.Binding>类来显式指定绑定源：
  
    - <xref:System.Windows.Data.Binding.ElementName%2A>。
    - <xref:System.Windows.Data.Binding.Source%2A>。
    - <xref:System.Windows.Data.Binding.RelativeSource%2A>。 
  
  有关详细信息，请参阅[如何： 指定绑定源](~/docs/framework/wpf/data/how-to-specify-the-binding-source.md)。  
  
 在 XAML 中，<xref:System.Windows.FrameworkElement.DataContext%2A>最通常设置为<xref:System.Windows.Data.Binding>声明。 您可以使用属性元素语法或特性语法。 特性语法在此页上的示例所示。 此外可以使用代码来设置<xref:System.Windows.FrameworkElement.DataContext%2A>。  
  
 <xref:System.Windows.FrameworkElement.DataContext%2A> 是一个可绑定的属性，以利于以下方案可能会在这里将一个上下文绑定到另一个。 但是，如果将绑定到<xref:System.Windows.FrameworkElement.DataContext%2A>，请注意，不创建循环绑定引用 (不是将绑定<xref:System.Windows.FrameworkElement.DataContext%2A>自身，这是可以执行的属性值继承特性导致<xref:System.Windows.FrameworkElement.DataContext%2A>属性)。  
  
<a name="xamlPropertyElementUsage_DataContext"></a>   
## <a name="xaml-property-element-usage"></a>XAML 属性元素用法  
  
```  
<object>  
  <object.DataContext>  
    <dataContextObject />  
  </object.DataContext>  
</object>  
```  
  
<a name="xamlAttributeUsage_DataContext"></a>   
## <a name="xaml-attribute-usage"></a>XAML 属性用法  
  
```  
<object DataContext="bindingUsage"/>  
- or -  
<object DataContext="{resourceExtension contextResourceKey}"/>  
```  
  
<a name="xamlValues_DataContext"></a>   
## <a name="xaml-values"></a>XAML 值  
 *dataContextObject*  
 作为父元素中的任何绑定的数据上下文直接嵌入的对象。 通常情况下，此对象是<xref:System.Windows.Data.Binding>或另一个<xref:System.Windows.Data.BindingBase>派生的类。 或者，适用于绑定任何对象类型的原始数据可能会放在此处，定义更高版本的实际绑定。  
  
 *bindingUsage*  
 计算结果为相应的数据上下文绑定使用情况。 有关详细信息，请参阅 [Binding 标记扩展](~/docs/framework/wpf/advanced/binding-markup-extension.md)。  
  
 *resourceExtension*  
 以下项之一： [ `StaticResource` ](~/docs/framework/wpf/advanced/staticresource-markup-extension.md)或[ `DynamicResource` ](~/docs/framework/wpf/advanced/dynamicresource-markup-extension.md)。 引用定义为资源中的对象的原始数据时，使用这种用法。 请参阅[XAML 资源](~/docs/framework/wpf/advanced/xaml-resources.md)。  
  
 *contextResourceKey*  
 正在请求中的对象的密钥标识符<xref:System.Windows.ResourceDictionary>。  
  
<a name="dependencyPropertyInfo_DataContext"></a>   
## <a name="dependency-property-information"></a>依赖项属性信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.FrameworkElement.DataContextProperty>|  
|元数据属性设置为 `true`|<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
   
  
## Examples  
 以下示例说明了数据上下文的绑定上的处理方式，并提供了定义的绑定属性的特定值的信息。  
  
 [!code-xaml[MasterDetail#DataContextProperty](~/samples/snippets/csharp/VS_Snippets_Wpf/MasterDetail/CSharp/Page1.xaml#datacontextproperty)]  
[!code-xaml[MasterDetail#DataContextProperty2](~/samples/snippets/csharp/VS_Snippets_Wpf/MasterDetail/CSharp/Page1.xaml#datacontextproperty2)]  
[!code-xaml[MasterDetail#DataContextProperty3](~/samples/snippets/csharp/VS_Snippets_Wpf/MasterDetail/CSharp/Page1.xaml#datacontextproperty3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DataContextChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.DependencyPropertyChangedEventHandler DataContextChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DependencyPropertyChangedEventHandler DataContextChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkElement.DataContextChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DataContextChanged As DependencyPropertyChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DependencyPropertyChangedEventHandler ^ DataContextChanged;" />
      <MemberSignature Language="F#" Value="member this.DataContextChanged : System.Windows.DependencyPropertyChangedEventHandler " Usage="member this.DataContextChanged : System.Windows.DependencyPropertyChangedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在此元素的数据上下文更改时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 数据上下文和数据绑定的说明，请参阅[数据绑定概述](~/docs/framework/wpf/data/data-binding-overview.md)。  
  
> [!IMPORTANT]
>  当<xref:System.Windows.FrameworkElement.DataContext%2A>有关元素的更改，此元素上的所有数据绑定属性可能会受到都影响。 这适用于任何元素的子元素的逻辑树中的当前元素继承数据上下文，以及当前元素本身。 此类的所有现有绑定必须重新解释的新<xref:System.Windows.FrameworkElement.DataContext%2A>并将重新计算绑定结果。 数据绑定引擎是不确定的顺序的这些重新计算，相对于引发<xref:System.Windows.FrameworkElement.DataContextChanged>事件。 略微降低可以在事件之前发生，这是后事件，或在任意组合。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.FrameworkElement.DataContext" />
      </Docs>
    </Member>
    <Member MemberName="DataContextProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty DataContextProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty DataContextProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.DataContextProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly DataContextProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ DataContextProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable DataContextProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.DataContextProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="P:System.Windows.FrameworkElement.DataContext" /> 依赖项属性。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultStyleKey">
      <MemberSignature Language="C#" Value="protected internal object DefaultStyleKey { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object DefaultStyleKey" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.DefaultStyleKey" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Property DefaultStyleKey As Object" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; property System::Object ^ DefaultStyleKey { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.DefaultStyleKey : obj with get, set" Usage="System.Windows.FrameworkElement.DefaultStyleKey" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置在使用或定义主题样式时要用于引用此控件样式的键。</summary>
        <value>样式键。 要作为主题样式查找的一部分正常工作，此值应是带样式的控件的 <see cref="T:System.Type" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 通常通过其直接属性访问器的任何未设置此属性。 相反，替代此依赖项属性的特定于类型的元数据，每次创建一个新<xref:System.Windows.FrameworkElement>派生的类。 当派生控件时，调用<xref:System.Windows.DependencyProperty.OverrideMetadata%2A>方法针对<xref:System.Windows.FrameworkElement.DefaultStyleKeyProperty>在控件的静态构造函数内的标识符，派生类 （或等效的类初始化）。  
  
 控件通常将覆盖默认值的此属性才能为其自己的类型，但在某些情况下也可以使用存在主题字典中的样式的基类型。 如果基控件的控件模板完全定义该派生的可视表示形式和派生的类型公开的任何其他成员不需要的其他元素为控件模板的一部分，这是控件的仅实用。  
  
 如果你希望元素或故意不使用主题样式的控件，设置<xref:System.Windows.FrameworkElement.OverridesDefaultStyle%2A>属性设置为`true`。  
  
<a name="dependencyPropertyInfo_DefaultStyleKey"></a>   
## <a name="dependency-property-information"></a>依赖项属性信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.FrameworkElement.DefaultStyleKeyProperty>|  
|元数据属性设置为 `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
   
  
## Examples  
 下面的示例说明了在备注中讨论的依赖项属性元数据重写用法。 此代码定义了一个自定义控件类`NumericUpDown`旨在用于从专用的控件库程序集。 所示的静态构造函数引用了一些专用的初始化函数，则注册类处理程序 (另一个常见的控件子类化方案，请参见[路由事件标记为已处理，和类处理](~/docs/framework/wpf/advanced/marking-routed-events-as-handled-and-class-handling.md)) 和最后重写<xref:System.Windows.FrameworkElement.DefaultStyleKey%2A>依赖属性元数据上的`NumericUpDown`类。 <xref:System.Windows.FrameworkElement.DefaultStyleKey%2A> 始终返回其自己的类型作为预期的键，这是主题样式系统用来查找一些任意否则非样式控件的样式的约定。 完整的示例还定义了由该密钥; 引用的实际控件的主题样式请参阅[带有主题和 UI 自动化支持示例的 NumericUpDown 自定义控件](http://go.microsoft.com/fwlink/?LinkID=160025)。  
  
 [!code-csharp[CustomControlNumericUpDown#StaticCtorOfCustomClassCommonTasks](~/samples/snippets/csharp/VS_Snippets_Wpf/CustomControlNumericUpDown/CSharp/CustomControlLibrary/NumericUpDown.cs#staticctorofcustomclasscommontasks)]
 [!code-vb[CustomControlNumericUpDown#StaticCtorOfCustomClassCommonTasks](~/samples/snippets/visualbasic/VS_Snippets_Wpf/CustomControlNumericUpDown/visualbasic/customcontrollibrary/numericupdown.vb#staticctorofcustomclasscommontasks)]  
[!code-csharp[CustomControlNumericUpDown#Close](~/samples/snippets/csharp/VS_Snippets_Wpf/CustomControlNumericUpDown/CSharp/CustomControlLibrary/NumericUpDown.cs#close)]
[!code-vb[CustomControlNumericUpDown#Close](~/samples/snippets/visualbasic/VS_Snippets_Wpf/CustomControlNumericUpDown/visualbasic/customcontrollibrary/numericupdown.vb#close)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.FrameworkElement.OverridesDefaultStyle" />
        <related type="ExternalDocumentation" href="http://go.microsoft.com/fwlink/?LinkID=160025">带有主题和 UI 自动化支持示例的 NumericUpDown 自定义控件</related>
      </Docs>
    </Member>
    <Member MemberName="DefaultStyleKeyProperty">
      <MemberSignature Language="C#" Value="protected internal static readonly System.Windows.DependencyProperty DefaultStyleKeyProperty;" />
      <MemberSignature Language="ILAsm" Value=".field familyorassembly static initonly class System.Windows.DependencyProperty DefaultStyleKeyProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.DefaultStyleKeyProperty" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Shared ReadOnly DefaultStyleKeyProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="protected public: static initonly System::Windows::DependencyProperty ^ DefaultStyleKeyProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable DefaultStyleKeyProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.DefaultStyleKeyProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="P:System.Windows.FrameworkElement.DefaultStyleKey" /> 依赖项属性。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EndInit">
      <MemberSignature Language="C#" Value="public virtual void EndInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EndInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.EndInit" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub EndInit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void EndInit();" />
      <MemberSignature Language="F#" Value="abstract member EndInit : unit -&gt; unit&#xA;override this.EndInit : unit -&gt; unit" Usage="frameworkElement.EndInit " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>指示元素的初始化过程已完成。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果<xref:System.Windows.FrameworkElement.BeginInit%2A>之前调用，基实现将引发<xref:System.Windows.FrameworkElement.Initialized>事件。 否则为如果<xref:System.Windows.FrameworkElement.BeginInit%2A>未调用或找不到确定是否<xref:System.Windows.FrameworkElement.BeginInit%2A>调用，则<xref:System.Windows.FrameworkElement.Initialized>则不会引发并改为引发异常。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">调用 <see cref="M:System.Windows.FrameworkElement.EndInit" /> 之前尚未在元素上调用 <see cref="M:System.Windows.FrameworkElement.BeginInit" />。</exception>
        <block subset="none" type="overrides">
          <para>实现此方法以提供您的元素在元素加载过程中初始化时应发生这种情况的特殊处理。  
  
您的实现应调用基实现，因为基本 （默认值） 实现设置要跟踪的初始化一些内部标志。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="FindName">
      <MemberSignature Language="C#" Value="public object FindName (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object FindName(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.FindName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function FindName (name As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ FindName(System::String ^ name);" />
      <MemberSignature Language="F#" Value="member this.FindName : string -&gt; obj" Usage="frameworkElement.FindName name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">所请求元素的名称。</param>
        <summary>查找具有提供的标识符名的元素。</summary>
        <returns>请求的元素。 如果未找到匹配的元素，该值将为 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果元素具有子元素，这些子元素将是所有以递归方式搜索请求的命名元素。  
  
 <xref:System.Windows.FrameworkElement.FindName%2A> 在当前元素的名称范围内运行。 有关详细信息，请参阅[WPF XAML 名称范围](~/docs/framework/wpf/advanced/wpf-xaml-namescopes.md)。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkElement.FindResource(System.Object)" />
        <altmember cref="P:System.Windows.FrameworkElement.Name" />
        <related type="Article" href="http://msdn.microsoft.com/library/b7e61222-e8cf-48d2-acd0-6df3b7685d48">X:name 特性</related>
      </Docs>
    </Member>
    <Member MemberName="FindResource">
      <MemberSignature Language="C#" Value="public object FindResource (object resourceKey);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object FindResource(object resourceKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.FindResource(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function FindResource (resourceKey As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ FindResource(System::Object ^ resourceKey);" />
      <MemberSignature Language="F#" Value="member this.FindResource : obj -&gt; obj" Usage="frameworkElement.FindResource resourceKey" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="resourceKey" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="resourceKey">所请求资源的键标识符。</param>
        <summary>搜索具有指定密钥的资源，如果未找到请求的资源，则会引发异常。</summary>
        <returns>所请求的资源。 如果未找到具有所提供键的资源，将引发异常。 在发生异常的情况下，可能还会返回一个 <see cref="F:System.Windows.DependencyProperty.UnsetValue" /> 值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  如果找不到键调用此方法，将引发异常。 如果没有要处理的异常，导致调用<xref:System.Windows.FrameworkElement.FindResource%2A>，调用<xref:System.Windows.FrameworkElement.TryFindResource%2A>相反。 <xref:System.Windows.FrameworkElement.TryFindResource%2A> 返回`null`请求的资源时无法找到，且不会引发异常。  
  
 如果在调用元素上找不到资源，逻辑树中的父元素是搜索下一步，然后应用程序，则主题和最后的系统资源。 这种查找方法等同于在标记中的动态资源引用请求资源时如何搜索树。 有关资源查找的详细信息，请参阅[XAML 资源](~/docs/framework/wpf/advanced/xaml-resources.md)。  
  
 通常情况下，您立即强制转换<xref:System.Windows.FrameworkElement.FindResource%2A>值到属性的类型，使你返回设置，并返回的资源值。  
  
 资源键不一定是字符串。 例如，样式的控件在主题级别特意根据<xref:System.Type>的控制和应用程序或页样式的控件通常使用此相同的键约定。 有关详细信息，请参阅[样式和模板化](~/docs/framework/wpf/controls/styling-and-templating.md)或[XAML 资源](~/docs/framework/wpf/advanced/xaml-resources.md)。  
  
   
  
## Examples  
 下面的示例获取的已命名的资源，并将其转换为相应的类型以填充属性。  
  
 [!code-csharp[PropertiesOvwSupport#ResourceProceduralGet](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertiesOvwSupport/CSharp/page3.xaml.cs#resourceproceduralget)]
 [!code-vb[PropertiesOvwSupport#ResourceProceduralGet](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertiesOvwSupport/visualbasic/page3.xaml.vb#resourceproceduralget)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Windows.ResourceReferenceKeyNotFoundException">找不到 <paramref name="resourceKey" />，且事件管理器对于 <see cref="E:System.Windows.Threading.Dispatcher.UnhandledException" /> 事件不存在。  
  
或 
 找不到 <paramref name="resourceKey" />，且 <see cref="P:System.Windows.Threading.DispatcherUnhandledExceptionEventArgs.Handled" /> 属性在 <see cref="E:System.Windows.Threading.Dispatcher.UnhandledException" /> 事件中为 <see langword="false" />。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="resourceKey" /> 为 <see langword="null" />。</exception>
        <altmember cref="M:System.Windows.FrameworkElement.TryFindResource(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="FlowDirection">
      <MemberSignature Language="C#" Value="public System.Windows.FlowDirection FlowDirection { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.FlowDirection FlowDirection" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.FlowDirection" />
      <MemberSignature Language="VB.NET" Value="Public Property FlowDirection As FlowDirection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::FlowDirection FlowDirection { System::Windows::FlowDirection get(); void set(System::Windows::FlowDirection value); };" />
      <MemberSignature Language="F#" Value="member this.FlowDirection : System.Windows.FlowDirection with get, set" Usage="System.Windows.FrameworkElement.FlowDirection" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.None)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.FlowDirection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置文本和其他[!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)] 元素在控制它们布局的任何父元素中的流动方向。</summary>
        <value>文本和其他 [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)] 元素在它们的父元素中的流动方向，是一个枚举值。 默认值为 <see cref="F:System.Windows.FlowDirection.LeftToRight" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 依赖项属性的使用情况设置<xref:System.Windows.FrameworkElement.FlowDirection%2A>此元素上。 由于设置的属性值继承<xref:System.Windows.FrameworkElement.FlowDirection%2A>元素上可以有可能在设置<xref:System.Windows.FrameworkElement.FlowDirection%2A>未设置的所有子元素上<xref:System.Windows.FrameworkElement.FlowDirection%2A>本地或通过其他方式如样式。  
  
 是未设置此属性会自动作为一部分的任何应用程序的区域性信息，因为元素可能包含不一定是不遵守权限隐含的区域性信息的常规流方向的内容。 全球化注意事项的详细信息，请参阅[WPF 的全球化](~/docs/framework/wpf/advanced/globalization-for-wpf.md)。  
  
 此属性具有已定义[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]属性访问器，使其作为依赖项属性。 但是，它还注册为附加，因此它也可以作为附加属性。 注册附加主要是为了支持属性值继承，但该属性还可以用作真正的附加属性。 附加的属性用法才是如果你想要将数据流方向设置上的对象具有相关<xref:System.Windows.FrameworkElement>执行时，布局的父元素不是本身<xref:System.Windows.FrameworkElement>，并且已没有更直接地定义`FlowDirection`属性。 (如的一些流文档类<xref:System.Windows.Documents.Block>并<xref:System.Windows.Documents.Inline>定义其自己`FlowDirection`，此属性也可以设置流方向。 属性值随后由读取最终内容主机而无需附加的属性用法。）  
  
<a name="xamlAttributeUsage_FlowDirection"></a>   
## <a name="xaml-attribute-usage"></a>XAML 属性用法  
 \<*object* **FlowDirection**="<xref:System.Windows.FlowDirection>"/>  
  
<a name="xamlTextUsage_FlowDirection"></a>   
## <a name="xaml-text-usage"></a>XAML 文本使用情况  
 也可以不是类上设置此属性<xref:System.Windows.FrameworkElement>派生类中，由以下[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]附加属性用法：  
  
 `<` *对象* `FrameworkElement.` **FlowDirection**="<xref:System.Windows.FlowDirection>`"/>`  
  
<a name="dependencyPropertyInfo_FlowDirection"></a>   
## <a name="dependency-property-information"></a>依赖项属性信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.FrameworkElement.FlowDirectionProperty>|  
|元数据属性设置为 `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>, <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A>, <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
 此属性是依赖项属性和附加的属性。请参阅备注。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FlowDirectionProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty FlowDirectionProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty FlowDirectionProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.FlowDirectionProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly FlowDirectionProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ FlowDirectionProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable FlowDirectionProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.FlowDirectionProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="P:System.Windows.FrameworkElement.FlowDirection" /> 依赖项属性。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FocusVisualStyle">
      <MemberSignature Language="C#" Value="public System.Windows.Style FocusVisualStyle { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Style FocusVisualStyle" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.FocusVisualStyle" />
      <MemberSignature Language="VB.NET" Value="Public Property FocusVisualStyle As Style" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Style ^ FocusVisualStyle { System::Windows::Style ^ get(); void set(System::Windows::Style ^ value); };" />
      <MemberSignature Language="F#" Value="member this.FocusVisualStyle : System.Windows.Style with get, set" Usage="System.Windows.FrameworkElement.FocusVisualStyle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Style</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个属性，该属性允许自定义此元素在捕获到键盘焦点时要应用于此元素的外观、效果或其他样式特征。</summary>
        <value>要应用于焦点的所需样式。 该依赖项属性中声明的默认值是一个空的静态 <see cref="T:System.Windows.Style" />。 但是，运行时的有效值通常是（但并非总是）控件的主题支持所提供的样式。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此属性会影响视觉外观，但不会报告<xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A>元数据中。 这是因为可视外观更改是事件驱动和在任何时候，可能不适用，因此通常不应报告元数据中的任何视觉对象或布局信息。  
  
 从概念上讲，焦点应用于控件的可视行为应一致控件控件。 强制实施一致性的最合理方法是仅当您在创作整个主题更改焦点视觉样式。 将此属性设置各个控件样式上而不是作为主题的一部分不是预期的用法的此属性，因为它可能会导致混乱的用户体验对键盘焦点。 如果你想是故意不一致的整个主题的特定于控件的行为，更好的方法是使用触发器在样式中的个别输入的状态属性，如<xref:System.Windows.UIElement.IsFocused%2A>或<xref:System.Windows.UIElement.IsKeyboardFocusWithin%2A>，并为此，在没有一种方法以可视方式会影响任何现有的焦点视觉样式。 有关详细信息的设计意图<xref:System.Windows.FrameworkElement.FocusVisualStyle%2A>及替代焦点属性，请参阅[控件，以及 FocusVisualStyle 中的焦点设置样式](~/docs/framework/wpf/advanced/styling-for-focus-in-controls-and-focusvisualstyle.md)。  
  
<a name="xamlAttributeUsage_FocusVisualStyle"></a>   
## <a name="xaml-attribute-usage"></a>XAML 属性用法  
  
```  
<object FocusVisualStyle="{resourceExtension styleResourceKey}"/>  
```  
  
<a name="xamlPropertyElementUsage_FocusVisualStyle"></a>   
## <a name="xaml-property-element-usage"></a>XAML 属性元素用法  
  
<a name="xamlValues_FocusVisualStyle"></a>   
## <a name="xaml-values"></a>XAML 值  
 *resourceExtension*  
 以下项之一:、 或。 请参阅[XAML 资源](~/docs/framework/wpf/advanced/xaml-resources.md)。  
  
 *styleResourceKey*  
 标识所请求的样式的键。 键引用中的现有资源<xref:System.Windows.ResourceDictionary>。  
  
> [!NOTE]
>  属性元素语法就从技术上讲，但不是建议这样做。 请参阅[内联样式和模板](~/docs/framework/wpf/advanced/inline-styles-and-templates.md)。 绑定引用使用或<xref:System.Windows.Data.Binding>也是可行的但不常见。  
  
<a name="dependencyPropertyInfo_FocusVisualStyle"></a>   
## <a name="dependency-property-information"></a>依赖项属性信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.FrameworkElement.FocusVisualStyleProperty>|  
|元数据属性设置为 `true`|无|  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkElement.MoveFocus(System.Windows.Input.TraversalRequest)" />
      </Docs>
    </Member>
    <Member MemberName="FocusVisualStyleProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty FocusVisualStyleProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty FocusVisualStyleProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.FocusVisualStyleProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly FocusVisualStyleProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ FocusVisualStyleProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable FocusVisualStyleProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.FocusVisualStyleProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="P:System.Windows.FrameworkElement.FocusVisualStyle" /> 依赖项属性。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ForceCursor">
      <MemberSignature Language="C#" Value="public bool ForceCursor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ForceCursor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.ForceCursor" />
      <MemberSignature Language="VB.NET" Value="Public Property ForceCursor As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ForceCursor { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.ForceCursor : bool with get, set" Usage="System.Windows.FrameworkElement.ForceCursor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值指示此 <see cref="T:System.Windows.FrameworkElement" /> 是否应该强制[!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)] 按照 <see cref="P:System.Windows.FrameworkElement.Cursor" /> 属性所声明的方式呈现光标。</summary>
        <value>如果强制光标在位于此元素（包括所有子元素）上时的呈现使用光标的当前 <see cref="P:System.Windows.FrameworkElement.Cursor" /> 设置，则为 <see langword="true" />；否则为 <see langword="false" />。 默认值为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果此属性设置为`true`将覆盖由子元素的光标首选项。 这样做因此一般情况下应用程序[!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)]可能容易引起混淆的用户，尤其是如果子元素尝试指定游标。 设置<xref:System.Windows.FrameworkElement.ForceCursor%2A>控件子类化或组合的情况下方案中更合适。  
  
<a name="dependencyPropertyInfo_ForceCursor"></a>   
## <a name="dependency-property-information"></a>依赖项属性信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.FrameworkElement.ForceCursorProperty>|  
|元数据属性设置为 `true`|无|  
  
   
  
## Examples  
 下面的示例强制游标值。  
  
 [!code-xaml[ForceCursor#ForceCursor](~/samples/snippets/csharp/VS_Snippets_Wpf/ForceCursor/CS/default.xaml#forcecursor)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Input.Cursor" />
      </Docs>
    </Member>
    <Member MemberName="ForceCursorProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ForceCursorProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ForceCursorProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.ForceCursorProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ForceCursorProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ForceCursorProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable ForceCursorProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.ForceCursorProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="P:System.Windows.FrameworkElement.ForceCursor" /> 依赖项属性。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetBindingExpression">
      <MemberSignature Language="C#" Value="public System.Windows.Data.BindingExpression GetBindingExpression (System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Data.BindingExpression GetBindingExpression(class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.GetBindingExpression(System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetBindingExpression (dp As DependencyProperty) As BindingExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Data::BindingExpression ^ GetBindingExpression(System::Windows::DependencyProperty ^ dp);" />
      <MemberSignature Language="F#" Value="member this.GetBindingExpression : System.Windows.DependencyProperty -&gt; System.Windows.Data.BindingExpression" Usage="frameworkElement.GetBindingExpression dp" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Data.BindingExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="dp">从中获取绑定的目标 <see cref="T:System.Windows.DependencyProperty" />。</param>
        <summary>返回表示指定属性上的绑定的 <see cref="T:System.Windows.Data.BindingExpression" />。</summary>
        <returns>如果目标属性具有活动绑定，将返回 <see cref="T:System.Windows.Data.BindingExpression" />；否则返回 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 检查返回值是否为`null`是一种技术可用于确定属性是否具有活动的绑定。  
  
 此方法是实际上就是方便周围的包装<xref:System.Windows.Data.BindingOperations.GetBindingExpression%2A?displayProperty=nameWithType>方法。 <xref:System.Windows.FrameworkElement.GetBindingExpression%2A> 将传递的当前实例和`dp`参数<xref:System.Windows.Data.BindingOperations.GetBindingExpression%2A?displayProperty=nameWithType>。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Data.BindingOperations" />
      </Docs>
    </Member>
    <Member MemberName="GetFlowDirection">
      <MemberSignature Language="C#" Value="public static System.Windows.FlowDirection GetFlowDirection (System.Windows.DependencyObject element);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Windows.FlowDirection GetFlowDirection(class System.Windows.DependencyObject element) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.GetFlowDirection(System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFlowDirection (element As DependencyObject) As FlowDirection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::FlowDirection GetFlowDirection(System::Windows::DependencyObject ^ element);" />
      <MemberSignature Language="F#" Value="static member GetFlowDirection : System.Windows.DependencyObject -&gt; System.Windows.FlowDirection" Usage="System.Windows.FrameworkElement.GetFlowDirection element" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.FlowDirection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="element">要为其返回 <see cref="P:System.Windows.FrameworkElement.FlowDirection" /> 的元素。</param>
        <summary>获取指定的 <see cref="T:System.Windows.DependencyObject" /> 的 <see cref="P:System.Windows.FrameworkElement.FlowDirection" /> 附加属性值。</summary>
        <returns>所请求的流方向（作为一个枚举值）。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法的主要目的是支持的附加的属性语法<xref:System.Windows.FrameworkElement.FlowDirection%2A>属性，从而使子元素的提供<xref:System.Windows.FrameworkElement>来指定在其父元素的排列方式的流动方向。 要获取其值在当前<xref:System.Windows.FrameworkElement>，使用 direct[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]访问器<xref:System.Windows.FrameworkElement.FlowDirection%2A>。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.FrameworkElement.FlowDirection" />
      </Docs>
    </Member>
    <Member MemberName="GetLayoutClip">
      <MemberSignature Language="C#" Value="protected override System.Windows.Media.Geometry GetLayoutClip (System.Windows.Size layoutSlotSize);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Windows.Media.Geometry GetLayoutClip(valuetype System.Windows.Size layoutSlotSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.GetLayoutClip(System.Windows.Size)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function GetLayoutClip (layoutSlotSize As Size) As Geometry" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Windows::Media::Geometry ^ GetLayoutClip(System::Windows::Size layoutSlotSize);" />
      <MemberSignature Language="F#" Value="override this.GetLayoutClip : System.Windows.Size -&gt; System.Windows.Media.Geometry" Usage="frameworkElement.GetLayoutClip layoutSlotSize" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Geometry</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="layoutSlotSize" Type="System.Windows.Size" />
      </Parameters>
      <Docs>
        <param name="layoutSlotSize">执行可视化演示的元素的部分大小。</param>
        <summary>返回剪切蒙版的形状。 如果布局系统尝试排列的元素大小超过可用显示空间，将会应用蒙版。</summary>
        <returns>剪切形状。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 被减边距`layoutSlotSize`布局系统行为的一部分。  
  
 如果返回 null 引用指示没有剪辑将会发生。 默认实现始终返回`null`时<xref:System.Windows.UIElement.ClipToBounds%2A>是`false`。 此方法重写 <xref:System.Windows.UIElement.GetLayoutClip%2A?displayProperty=nameWithType>。 <xref:System.Windows.FrameworkElement>实现使用<xref:System.Windows.FrameworkElement.MaxHeight%2A>和<xref:System.Windows.FrameworkElement.MaxWidth%2A>其计算中。 多个类的子类<xref:System.Windows.FrameworkElement>再次重写此方法。 <xref:System.Windows.Documents.Adorner.GetLayoutClip%2A?displayProperty=nameWithType>将重写以便始终返回`null`因为装饰器通常都特意普通的界限外。 <xref:System.Windows.Controls.Canvas.GetLayoutClip%2A?displayProperty=nameWithType> 并<xref:System.Windows.Controls.InkPresenter.GetLayoutClip%2A?displayProperty=nameWithType>返回`null`如果<xref:System.Windows.UIElement.ClipToBounds%2A>是`false`。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>默认实现始终返回<see langword="null" />时<see cref="P:System.Windows.UIElement.ClipToBounds" />是<see langword="false" />。 重写通常会保留此行为，但是有一些例外，具体取决于关系和派生的类和其布局逻辑而不是类的基类的目的。</para>
        </block>
        <altmember cref="P:System.Windows.UIElement.Clip" />
        <altmember cref="P:System.Windows.UIElement.ClipToBounds" />
      </Docs>
    </Member>
    <Member MemberName="GetTemplateChild">
      <MemberSignature Language="C#" Value="protected internal System.Windows.DependencyObject GetTemplateChild (string childName);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance class System.Windows.DependencyObject GetTemplateChild(string childName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.GetTemplateChild(System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Function GetTemplateChild (childName As String) As DependencyObject" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; System::Windows::DependencyObject ^ GetTemplateChild(System::String ^ childName);" />
      <MemberSignature Language="F#" Value="member this.GetTemplateChild : string -&gt; System.Windows.DependencyObject" Usage="frameworkElement.GetTemplateChild childName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="childName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="childName">要查找的子级的名称。</param>
        <summary>返回实例化的 <see cref="T:System.Windows.Controls.ControlTemplate" /> 可视化树中的命名元素。</summary>
        <returns>请求的元素。 如果具有所请求名称的元素不存在，则可以为 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 中的模板[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]具有独立的名称范围。 这是因为模板可以重复使用，并且在模板中定义的任何名称不能保持唯一时实例化其模板，每个控件的多个实例。 调用<xref:System.Windows.FrameworkElement.GetTemplateChild%2A>方法返回对它实例化之后，来自模板的对象的引用。 不能使用<xref:System.Windows.FrameworkElement.FindName%2A?displayProperty=nameWithType>方法来查找模板中的项，因为<xref:System.Windows.FrameworkElement.FindName%2A?displayProperty=nameWithType>中一种更通用的作用范围，并且没有之间没有连接<xref:System.Windows.Controls.ControlTemplate>类本身和实例化的模板后应用该策略。  
  
 <xref:System.Windows.FrameworkTemplate.FindName%2A?displayProperty=nameWithType> 提供了与此方法相同的功能。 <xref:System.Windows.FrameworkTemplate.FindName%2A?displayProperty=nameWithType> 而不是公共受保护，并使用正确名称范围措施，使其能够访问内部元素，将查找名为其中的项的模板。 使用<xref:System.Windows.FrameworkTemplate.FindName%2A?displayProperty=nameWithType>时您需要先获取其父控件之外的元素。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkTemplate.FindName(System.String,System.Windows.FrameworkElement)" />
      </Docs>
    </Member>
    <Member MemberName="GetUIParentCore">
      <MemberSignature Language="C#" Value="protected internal override System.Windows.DependencyObject GetUIParentCore ();" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance class System.Windows.DependencyObject GetUIParentCore() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.GetUIParentCore" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides Function GetUIParentCore () As DependencyObject" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override System::Windows::DependencyObject ^ GetUIParentCore();" />
      <MemberSignature Language="F#" Value="override this.GetUIParentCore : unit -&gt; System.Windows.DependencyObject" Usage="frameworkElement.GetUIParentCore " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>如果没有视觉父级，则返回此元素的备用逻辑父级。</summary>
        <returns>当此方法的 WPF 框架级别实现具有非视觉父级连接时，即返回 <see langword="null" /> 之外的内容。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法重写 <xref:System.Windows.UIElement.GetUIParentCore%2A?displayProperty=nameWithType>。 默认值<xref:System.Windows.FrameworkElement>实现返回预期的单个可视化父级，即获取相同的结果<xref:System.Windows.FrameworkElement.Parent%2A>值。 在派生的类实现可能会返回备用的父关系。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.FrameworkElement.Parent" />
      </Docs>
    </Member>
    <Member MemberName="GetVisualChild">
      <MemberSignature Language="C#" Value="protected override System.Windows.Media.Visual GetVisualChild (int index);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Windows.Media.Visual GetVisualChild(int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.GetVisualChild(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function GetVisualChild (index As Integer) As Visual" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Windows::Media::Visual ^ GetVisualChild(int index);" />
      <MemberSignature Language="F#" Value="override this.GetVisualChild : int -&gt; System.Windows.Media.Visual" Usage="frameworkElement.GetVisualChild index" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Visual</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">集合中请求的子元素的从零开始的索引。</param>
        <summary>重写 <see cref="M:System.Windows.Media.Visual.GetVisualChild(System.Int32)" />，然后从子元素集合返回指定索引处的子级。</summary>
        <returns>请求的子元素。 它不应返回 <see langword="null" />；如果提供的索引超出范围，将引发异常。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在<xref:System.Windows.FrameworkElement>实现中，唯一有效索引为零。 内容模型<xref:System.Windows.FrameworkElement.GetVisualChild%2A>支持零个或一个子元素，不是集合。  
  
   
  
## Examples  
 下面的示例演示如何自定义装饰器使用的值来声明<xref:System.Windows.Media.VisualCollection>它为其多个可视子级维护。 通过重写之一报告这些值<xref:System.Windows.FrameworkElement.VisualChildrenCount%2A>和<xref:System.Windows.FrameworkElement.GetVisualChild%2A>。  
  
 [!code-csharp[Adorners_ResizingAdorner#FEVisualOverridesPre](~/samples/snippets/csharp/VS_Snippets_Wpf/Adorners_ResizingAdorner/CSharp/ResizingAdorner.cs#fevisualoverridespre)]
 [!code-vb[Adorners_ResizingAdorner#FEVisualOverridesPre](~/samples/snippets/visualbasic/VS_Snippets_Wpf/Adorners_ResizingAdorner/visualbasic/resizingadorner.vb#fevisualoverridespre)]  
[!code-csharp[Adorners_ResizingAdorner#FEVisualOverrides](~/samples/snippets/csharp/VS_Snippets_Wpf/Adorners_ResizingAdorner/CSharp/ResizingAdorner.cs#fevisualoverrides)]
[!code-vb[Adorners_ResizingAdorner#FEVisualOverrides](~/samples/snippets/visualbasic/VS_Snippets_Wpf/Adorners_ResizingAdorner/visualbasic/resizingadorner.vb#fevisualoverrides)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>此实现中时才有效不维护任何更具描述性的可视子元素集合的元素。 具有此类集合的任何元素必须重写此方法，并将索引映射到支持的该元素的子元素集合中的等效索引。 从零到范围中的索引<see cref="P:System.Windows.FrameworkElement.VisualChildrenCount" />（减一），则应返回有效的元素; 任何其他索引应引发超出范围异常。 支持的子集合，而且重写的元素类型的示例<see cref="M:System.Windows.FrameworkElement.GetVisualChild(System.Int32)" />若要返回多个可能的子<see cref="T:System.Windows.Controls.Panel" />。  
  
中的默认实现<see cref="T:System.Windows.FrameworkElement" />假定只有一个可视化子级。 为传递的任何值<paramref name="index" />以外的零个原因的异常引发。 几种常见的元素，如修饰器、 装饰器或具有专用呈现的元素替代<see cref="T:System.Windows.FrameworkElement" />实现 （属于间接基类实现）。 某些实现仍强制实施一个可视化子级，而另一些则允许集合。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Height">
      <MemberSignature Language="C#" Value="public double Height { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 Height" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.Height" />
      <MemberSignature Language="VB.NET" Value="Public Property Height As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double Height { double get(); void set(double value); };" />
      <MemberSignature Language="F#" Value="member this.Height : double with get, set" Usage="System.Windows.FrameworkElement.Height" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Windows.LengthConverter))</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.None, Readability=System.Windows.Readability.Unreadable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置元素的建议高度。</summary>
        <value>元素的高度（以 [!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)] 为单位）。 默认值为 <see cref="F:System.Double.NaN" />。 此值必须等于或大于 0.0。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.FrameworkElement.Height%2A> 是一个三个可写属性上<xref:System.Windows.FrameworkElement>指定高度信息。 其他两个<xref:System.Windows.FrameworkElement.MinHeight%2A>和<xref:System.Windows.FrameworkElement.MaxHeight%2A>。 如果冲突之间这三个值，确定高度的实际的应用程序的顺序是： 首先<xref:System.Windows.FrameworkElement.MinHeight%2A>必须遵守，然后<xref:System.Windows.FrameworkElement.MaxHeight%2A>，最后，如果它在指定边界内<xref:System.Windows.FrameworkElement.Height%2A>。  
  
 此元素是一些其他元素中的子元素，然后将此属性设置为一个值真的只建议的值。 布局系统，以及父元素的特定布局逻辑将使用值为非绑定输入在布局过程。 在实践中，<xref:System.Windows.FrameworkElement>几乎始终是也是如此。 的子元素，即使您设置<xref:System.Windows.FrameworkElement.Height%2A>上<xref:System.Windows.Window>。 (有关<xref:System.Windows.Window>，值时的基础的应用程序模型建立创建 Hwnd 的基本呈现假设使用托管的应用程序。)  
  
 除了在可接受<xref:System.Double>值，此属性也可以是<xref:System.Double.NaN?displayProperty=nameWithType>。 这是如何在代码中指定自动调整大小行为。 在[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]值设置为字符串"Auto"（不区分大小写） 以启用自动调整大小行为。 自动调整大小行为意味着该元素将填满可用的高度。 但是请注意，特定控件通常提供通过将禁用自动调整大小行为，除非专门重新启用了其默认主题样式的默认值。  
  
 此属性的返回值始终是任何已设置为它的值相同。 与之相反，值<xref:System.Windows.FrameworkElement.ActualHeight%2A>可能会有所不同。 这种情况可能是以静态方式因布局拒绝出于某种原因，建议的大小或暂时不可用。 布局系统本身相对于属性系统的集以异步方式工作<xref:System.Windows.FrameworkElement.Height%2A>和可能不处理特定大小调整属性的更改。  
  
 值限制<xref:System.Double>值强制实施<xref:System.Windows.ValidateValueCallback>机制。 如果您尝试设置一个无效值，则会运行时异常。  
  
 除了验证检查，还有用于绑定的不确定性上限值<xref:System.Windows.FrameworkElement.Height%2A>，由布局系统强制执行 (这是一个非常大的数字，大于<xref:System.Single.MaxValue?displayProperty=nameWithType>但小于<xref:System.Double.MaxValue?displayProperty=nameWithType>)。 如果你超出此限制，该元素将不会呈现，并不会引发异常。 未设置<xref:System.Windows.FrameworkElement.Height%2A>远远大于任何可能的可视显示，或您的最大大小可能会超出此非确定性上限的值。  
  
<a name="xamlAttributeUsage_Height"></a>   
## <a name="xaml-attribute-usage"></a>XAML 属性用法  
  
```  
<object Height="double"/>  
- or -  
<object Height="qualifiedDouble"/>  
- or -  
<object Height="Auto"/>  
```  
  
<a name="xamlValues_Height"></a>   
## <a name="xaml-values"></a>XAML 值  
 *double*  
 <xref:System.Double>  
  
 字符串表示形式<xref:System.Double>值等于或大于 0.0。 请参阅“备注”以了解上限信息。 此值解释为[!INCLUDE[TLA#tla_dipixel](~/includes/tlasharptla-dipixel-md.md)]度量。 字符串不需要显式包括小数点。 例如，值的`1`是可接受。  
  
 *qualifiedDouble*  
 一个*双*值，上文所述跟以下单位声明字符串之一： `px`， `in`， `cm`， `pt`。  
  
 `px` （默认值） [!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]  
  
 `in` 为英寸;1 中为 96px = =  
  
 `cm` 为厘米;1cm==(96/2.54) px  
  
 `pt` 为点;1pt==(96/72) px  
  
 **Auto**  
 启用自动调整大小行为。 请参阅“备注”。  
  
<a name="dependencyPropertyInfo_Height"></a>   
## <a name="dependency-property-information"></a>依赖项属性信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.FrameworkElement.HeightProperty>|  
|元数据属性设置为 `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.FrameworkElement.ActualHeight" />
      </Docs>
    </Member>
    <Member MemberName="HeightProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty HeightProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty HeightProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.HeightProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly HeightProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ HeightProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable HeightProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.HeightProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="P:System.Windows.FrameworkElement.Height" /> 依赖项属性。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="HorizontalAlignment">
      <MemberSignature Language="C#" Value="public System.Windows.HorizontalAlignment HorizontalAlignment { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.HorizontalAlignment HorizontalAlignment" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.HorizontalAlignment" />
      <MemberSignature Language="VB.NET" Value="Public Property HorizontalAlignment As HorizontalAlignment" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::HorizontalAlignment HorizontalAlignment { System::Windows::HorizontalAlignment get(); void set(System::Windows::HorizontalAlignment value); };" />
      <MemberSignature Language="F#" Value="member this.HorizontalAlignment : System.Windows.HorizontalAlignment with get, set" Usage="System.Windows.FrameworkElement.HorizontalAlignment" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.HorizontalAlignment</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置在父元素(如 Panel 或项控件)中组合此元素时所应用的水平对齐特征。</summary>
        <value>水平对齐设置，它是一个枚举值。 默认值为 <see cref="F:System.Windows.HorizontalAlignment.Stretch" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当<xref:System.Windows.FrameworkElement.Height%2A>并<xref:System.Windows.FrameworkElement.Width%2A>元素上显式设置属性，这些度量值在布局期间较高的优先级并且将取消设置的典型效果<xref:System.Windows.FrameworkElement.HorizontalAlignment%2A>到<xref:System.Windows.HorizontalAlignment.Stretch>。  
  
 <xref:System.Windows.FrameworkElement.HorizontalAlignment%2A> 是[!INCLUDE[TLA#tla_net](~/includes/tlasharptla-net-md.md)]属性访问器，它实际上是依赖项属性。 此特定的依赖项属性经常具有子类化元素，尤其是控件中以不同方式设置其原本"默认"值。 这通常发生在两种方式之一： 为特定的子类，但具有不同的元数据设置其默认值; 重新注册该依赖项属性或者应用了默认样式以不同方式设置该依赖项属性值。 例如，明显"default"的<xref:System.Windows.FrameworkElement.HorizontalAlignment%2A>有关<xref:System.Windows.Controls.Label>控件将是<xref:System.Windows.HorizontalAlignment.Left>，即使<xref:System.Windows.Controls.Label>继承<xref:System.Windows.FrameworkElement.HorizontalAlignment%2A>直接从<xref:System.Windows.FrameworkElement>。 这是因为该值的默认样式中已重置<xref:System.Windows.Controls.Label>，样式的控件模板中。  
  
 <xref:System.Windows.Controls.Canvas> 不使用<xref:System.Windows.FrameworkElement.HorizontalAlignment%2A>构成布局，因为时<xref:System.Windows.Controls.Canvas>根据绝对定位。  
  
 当由继承<xref:System.Windows.Controls.Label>或派生类中，<xref:System.Windows.Controls.Label>重新定义为此依赖项属性的默认值<xref:System.Windows.HorizontalAlignment.Left>。  
  
<a name="dependencyPropertyInfo_HorizontalAlignment"></a>   
## <a name="dependency-property-information"></a>依赖项属性信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.FrameworkElement.HorizontalAlignmentProperty>|  
|元数据属性设置为 `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsArrange%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HorizontalAlignmentProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty HorizontalAlignmentProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty HorizontalAlignmentProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.HorizontalAlignmentProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly HorizontalAlignmentProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ HorizontalAlignmentProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable HorizontalAlignmentProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.HorizontalAlignmentProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="P:System.Windows.FrameworkElement.HorizontalAlignment" /> 依赖项属性。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="InheritanceBehavior">
      <MemberSignature Language="C#" Value="protected internal System.Windows.InheritanceBehavior InheritanceBehavior { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.InheritanceBehavior InheritanceBehavior" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.InheritanceBehavior" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Property InheritanceBehavior As InheritanceBehavior" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; property System::Windows::InheritanceBehavior InheritanceBehavior { System::Windows::InheritanceBehavior get(); void set(System::Windows::InheritanceBehavior value); };" />
      <MemberSignature Language="F#" Value="member this.InheritanceBehavior : System.Windows.InheritanceBehavior with get, set" Usage="System.Windows.FrameworkElement.InheritanceBehavior" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.InheritanceBehavior</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置属性值继承、资源键查找和RelativeSource FindAncestor 查找的范围限制。</summary>
        <value>枚举的一个值。 默认值为 <see cref="F:System.Windows.InheritanceBehavior.Default" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在元素中的某些边界树集<xref:System.Windows.FrameworkElement.InheritanceBehavior%2A>以故意限制继承行为，强制资源查找，检查应用程序资源，或防止 RelativeSource FindAncestor 查找查询当前元素的范围或任何深一层。 使用的绑定时发生 RelativeSource FindAncestor 查找<xref:System.Windows.Data.RelativeSource>具有其<xref:System.Windows.Data.RelativeSource.Mode%2A>属性设置为<xref:System.Windows.Data.RelativeSourceMode.FindAncestor?displayProperty=nameWithType>值。  
  
 如果你想要设置此属性在派生的类，应在静态构造函数中或其他初始化例程中再这样做。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.Frame" />
      </Docs>
    </Member>
    <Member MemberName="Initialized">
      <MemberSignature Language="C#" Value="public event EventHandler Initialized;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Initialized" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkElement.Initialized" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Initialized As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Initialized;" />
      <MemberSignature Language="F#" Value="member this.Initialized : EventHandler " Usage="member this.Initialized : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>初始化此 <see cref="T:System.Windows.FrameworkElement" /> 时发生。 此事件与 <see cref="P:System.Windows.FrameworkElement.IsInitialized" /> 属性的值从 <see langword="false" />（或未定义）更改为 <see langword="true" /> 的情况相符。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 将此事件时引发<xref:System.Windows.FrameworkElement.EndInit%2A>或<xref:System.Windows.FrameworkElement.OnVisualParentChanged%2A>调用方法。 对这两种方法的调用可以具有来自应用程序代码或通过[!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)]处理器行为时[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]处理页。  
  
 您是否选择处理<xref:System.Windows.FrameworkElement.Loaded>或<xref:System.Windows.FrameworkElement.Initialized>取决于您的要求。 如果不需要读取元素的属性，想要重置的属性，并且不需要的任何布局信息，<xref:System.Windows.FrameworkElement.Initialized>可能是更好的事件以对其执行操作。 如果需要元素可用的所有属性，并且您将设置属性的可能将布局重置<xref:System.Windows.FrameworkElement.Loaded>可能是更好的事件以对其执行操作。 如果您的处理程序将重置由布局系统来表示新的布局传递需要解释的任何属性，则请注意的可重入性。 (您可能需要检查<xref:System.Windows.FrameworkPropertyMetadata>上如果您不确定哪些属性可能需要一种新布局的属性的值将传递更改时。)  
  
 有关序列的对象事件的详细信息<xref:System.Windows.FrameworkElement>，并且还为多个相关应用程序和元素类，请参阅[对象生存期事件](~/docs/framework/wpf/advanced/object-lifetime-events.md)。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkElement.OnInitialized(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="InputScope">
      <MemberSignature Language="C#" Value="public System.Windows.Input.InputScope InputScope { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Input.InputScope InputScope" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.InputScope" />
      <MemberSignature Language="VB.NET" Value="Public Property InputScope As InputScope" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Input::InputScope ^ InputScope { System::Windows::Input::InputScope ^ get(); void set(System::Windows::Input::InputScope ^ value); };" />
      <MemberSignature Language="F#" Value="member this.InputScope : System.Windows.Input.InputScope with get, set" Usage="System.Windows.FrameworkElement.InputScope" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.InputScope</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置此 <see cref="T:System.Windows.FrameworkElement" /> 使用的输入的上下文。</summary>
        <value>解释输入范围，在该输入范围内修改从其他输入法输入的方式。 默认值为 <see langword="null" />（这导致对命令的默认处理）。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此依赖属性继承属性值。 如果没有为其他值的子元素<xref:System.Windows.FrameworkElement.InputScope%2A>建立本地值或样式，通过属性系统会将设置此值为<xref:System.Windows.FrameworkElement.InputScope%2A>分配有此值最接近的上级元素的值。  
  
 尽管[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]语法使用情况列出和语法上允许，则将此属性设置[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]并不常见。  
  
<a name="dependencyPropertyInfo_InputScope"></a>   
## <a name="dependency-property-information"></a>依赖项属性信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.FrameworkElement.InputScopeProperty>|  
|元数据属性设置为 `true`|<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Input.InputScope" />
        <altmember cref="T:System.Windows.IInputElement" />
      </Docs>
    </Member>
    <Member MemberName="InputScopeProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty InputScopeProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty InputScopeProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.InputScopeProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly InputScopeProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ InputScopeProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable InputScopeProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.InputScopeProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="P:System.Windows.FrameworkElement.InputScope" /> 依赖项属性。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsInitialized">
      <MemberSignature Language="C#" Value="public bool IsInitialized { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsInitialized" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.IsInitialized" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsInitialized As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsInitialized { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsInitialized : bool" Usage="System.Windows.FrameworkElement.IsInitialized" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示此元素是否已初始化（在 [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] 处理器处理的过程中初始化，或通过显式调用其 <see cref="M:System.Windows.FrameworkElement.EndInit" /> 方法进行初始化）。</summary>
        <value>如果已通过上述 [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] 处理或方法调用初始化此元素，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此属性也可能`true`如果此元素被移动逻辑树中以便它有了新的父元素，并因此重新。  
  
 此属性很有用，如果您还使用了<xref:System.Windows.FrameworkElement.BeginInit%2A>和<xref:System.Windows.FrameworkElement.EndInit%2A>。 由加载逻辑树中的元素[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]处理器都保证会进行初始化。 不在逻辑树中的元素将初始化时<xref:System.Windows.FrameworkElement.EndInit%2A>调用。 缺少的任何特定处理的情况下<xref:System.Windows.FrameworkElement.BeginInit%2A>和<xref:System.Windows.FrameworkElement.EndInit%2A>，这会立即构造函数将返回已初始化的结果。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsLoaded">
      <MemberSignature Language="C#" Value="public bool IsLoaded { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsLoaded" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.IsLoaded" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsLoaded As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsLoaded { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsLoaded : bool" Usage="System.Windows.FrameworkElement.IsLoaded" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示是否已加载此元素以供呈现。</summary>
        <value>如果当前元素被附加到元素树，则为 <see langword="true" />；如果该元素从未附加到所加载的元素树，则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 从新构造<xref:System.Windows.FrameworkElement>，此属性以`false`，并保持`true`设置为后`true`，即使该元素由代码随后删除从已连接的逻辑树。 `true` 元素加载到演示文稿引擎时，将按常规的表示逻辑设置状态。  
  
 通常情况下，已加载的元素是呈现，而不是全部<xref:System.Windows.FrameworkElement>派生的类具有一个演示文稿和其他属性，如<xref:System.Windows.UIElement.Visibility%2A>可能影响表示形式。  
  
   
  
## Examples  
 下面的示例实现两个处理程序： 一个处理<xref:System.Windows.FrameworkElement.Loaded>根元素，从而可以确定该事件的重要性在于，加载页面根元素的事件。 另一个处理程序挂钩到一个用户控件，并且调用<xref:System.Windows.FrameworkElement.IsLoaded%2A>可确保根元素是加载完全。 这两个处理程序调用同一函数 （未显示），将填充新数据的子元素。  
  
 [!code-csharp[GroupBoxExample#FEIsLoaded](~/samples/snippets/csharp/VS_Snippets_Wpf/GroupBoxExample/CSharp/Page1.xaml.cs#feisloaded)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.FrameworkElement.Loaded" />
      </Docs>
    </Member>
    <Member MemberName="Language">
      <MemberSignature Language="C#" Value="public System.Windows.Markup.XmlLanguage Language { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Markup.XmlLanguage Language" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.Language" />
      <MemberSignature Language="VB.NET" Value="Public Property Language As XmlLanguage" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Markup::XmlLanguage ^ Language { System::Windows::Markup::XmlLanguage ^ get(); void set(System::Windows::Markup::XmlLanguage ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Language : System.Windows.Markup.XmlLanguage with get, set" Usage="System.Windows.FrameworkElement.Language" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Markup.XmlLanguage</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置应用于某个元素的本地化/全球化语言信息。</summary>
        <value>此元素的语言信息。 默认值是一个 <see cref="T:System.Windows.Markup.XmlLanguage" />，它的 <see cref="P:System.Windows.Markup.XmlLanguage.IetfLanguageTag" /> 值设置为字符串 "en-US"。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 字符串格式遵循 RFC 3066 标准。 例如，美国英语是"EN-US"。 值和格式的详细信息，请参阅<xref:System.Windows.Markup.XmlLanguage>。  
  
 此依赖属性继承属性值。 如果没有为其他值的子元素<xref:System.Windows.FrameworkElement.Language%2A>建立通过本地值或样式，属性系统将设置此值为<xref:System.Windows.FrameworkElement.Language%2A>分配有此值最接近的上级元素的值。  
  
 [!INCLUDE[TLA2#tla_xml](~/includes/tla2sharptla-xml-md.md)] 定义的常规含义`xml:lang`属性。 <xref:System.Windows.FrameworkElement.Language%2A> 实质上是公开的此属性为依赖属性的含义。 <xref:System.Windows.FrameworkElement.Language%2A> 可以进行调整，以编程方式，并且可以参与属性系统值继承中，等同于一种方法如何`xml:lang`属性可以继承中的子元素范围[!INCLUDE[TLA2#tla_xml](~/includes/tla2sharptla-xml-md.md)]。 如果您设置<xref:System.Windows.FrameworkElement.Language%2A>，该值将成为`xml:lang`并覆盖任何以前的值。 有关详细信息，请参阅[xml: lang 处理在 XAML 中](~/docs/framework/xaml-services/xml-lang-handling-in-xaml.md)。  
  
<a name="dependencyPropertyInfo_CultureInfo"></a>   
## <a name="dependency-property-information"></a>依赖项属性信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.FrameworkElement.LanguageProperty>|  
|元数据属性设置为 `true`|<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LanguageProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty LanguageProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty LanguageProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.LanguageProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly LanguageProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ LanguageProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable LanguageProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.LanguageProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="P:System.Windows.FrameworkElement.Language" /> 依赖项属性。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LayoutTransform">
      <MemberSignature Language="C#" Value="public System.Windows.Media.Transform LayoutTransform { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Media.Transform LayoutTransform" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.LayoutTransform" />
      <MemberSignature Language="VB.NET" Value="Public Property LayoutTransform As Transform" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Media::Transform ^ LayoutTransform { System::Windows::Media::Transform ^ get(); void set(System::Windows::Media::Transform ^ value); };" />
      <MemberSignature Language="F#" Value="member this.LayoutTransform : System.Windows.Media.Transform with get, set" Usage="System.Windows.FrameworkElement.LayoutTransform" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Transform</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置在执行布局时应该应用于此元素的图形转换方式。</summary>
        <value>此元素应该使用的转换。 默认值为 <see cref="P:System.Windows.Media.Transform.Identity" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 与此相反<xref:System.Windows.UIElement.RenderTransform%2A>，<xref:System.Windows.FrameworkElement.LayoutTransform%2A>将会影响布局的结果。  
  
 设置转换提供了强大功能的缩放和旋转。 但是，<xref:System.Windows.FrameworkElement.LayoutTransform%2A>忽略<xref:System.Windows.Media.TranslateTransform>操作。 这是因为的子元素的布局系统行为<xref:System.Windows.FrameworkElement>自动更正任何偏移量到布局中的缩放或旋转元素的位置和坐标系统的父元素。  
  
 <xref:System.Windows.FrameworkElement.LayoutTransform%2A> 如果方案不需要布局系统的整个处理过程中调用它，可能导致到应用程序性能差。 当应用<xref:System.Windows.FrameworkElement.LayoutTransform%2A>到<xref:System.Windows.Controls.Panel.Children%2A>的集合<xref:System.Windows.Controls.Panel>，它将触发一个新的布局系统传递和强制屏幕上的所有对象重新度量和重新排列。 如果要更新的完整应用程序[!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)]，此功能可能会完全所需内容。 但是，如果不需要完整布局处理过程，使用<xref:System.Windows.UIElement.RenderTransform%2A>属性，它不会调用布局系统，因此，通常是这种情况下更好的选择。  
  
 示例方案其中<xref:System.Windows.FrameworkElement.LayoutTransform%2A>情况下可包括： 旋转元素从水平到垂直或执行相反，菜单组件等元素 （放大） 缩放获得焦点时，提供编辑行为，等等。  
  
<a name="dependencyPropertyInfo_LayoutTransform"></a>   
## <a name="dependency-property-information"></a>依赖项属性信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.FrameworkElement.LayoutTransformProperty>|  
|元数据属性设置为 `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
   
  
## Examples  
 下面的示例演示如何应用<xref:System.Windows.FrameworkElement.LayoutTransform%2A>的元素。 该示例创建的实例<xref:System.Windows.Controls.Button>并托管在父级中<xref:System.Windows.Controls.Grid>。 它还使用<xref:System.Windows.FrameworkElement.LayoutTransform%2A>属性，将应用<xref:System.Windows.Media.RotateTransform>到<xref:System.Windows.Controls.Button>。  
  
 [!code-cpp[LayoutTransform#1](~/samples/snippets/cpp/VS_Snippets_Wpf/LayoutTransform/CPP/LayoutTransform.cpp#1)]
 [!code-csharp[LayoutTransform#1](~/samples/snippets/csharp/VS_Snippets_Wpf/LayoutTransform/CSharp/LayoutTransform.cs#1)]
 [!code-vb[LayoutTransform#1](~/samples/snippets/visualbasic/VS_Snippets_Wpf/LayoutTransform/VisualBasic/LayoutTransform.vb#1)]
 [!code-xaml[LayoutTransform#1](~/samples/snippets/xaml/VS_Snippets_Wpf/LayoutTransform/XAML/default.xaml#1)]  
  
 ]]></format>
        </remarks>
        <related type="ExternalDocumentation" href="http://go.microsoft.com/fwlink/?LinkID=158252">2d 转换示例</related>
      </Docs>
    </Member>
    <Member MemberName="LayoutTransformProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty LayoutTransformProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty LayoutTransformProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.LayoutTransformProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly LayoutTransformProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ LayoutTransformProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable LayoutTransformProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.LayoutTransformProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="P:System.Windows.FrameworkElement.LayoutTransform" /> 依赖项属性。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Loaded">
      <MemberSignature Language="C#" Value="public event System.Windows.RoutedEventHandler Loaded;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.RoutedEventHandler Loaded" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkElement.Loaded" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Loaded As RoutedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::RoutedEventHandler ^ Loaded;" />
      <MemberSignature Language="F#" Value="member this.Loaded : System.Windows.RoutedEventHandler " Usage="member this.Loaded : System.Windows.RoutedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当对元素进行布局、呈现，且可将其用于交互时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.FrameworkElement.Loaded> 通常的最后一个事件中引发元素初始化序列。 始终会引发此事件之后<xref:System.Windows.FrameworkElement.Initialized>。 您是否选择处理<xref:System.Windows.FrameworkElement.Loaded>或<xref:System.Windows.FrameworkElement.Initialized>取决于您的要求。 如果不需要读取元素的属性，想要重置的属性，并且不需要的任何布局信息，<xref:System.Windows.FrameworkElement.Initialized>可能是更好的事件以对其执行操作。 如果需要元素可用的所有属性，并且您将设置属性的可能将布局重置<xref:System.Windows.FrameworkElement.Loaded>可能是更好的事件以对其执行操作。 如果您的处理程序将重置由布局系统来表示新的布局传递需要解释的任何属性，则请注意的可重入性。 (您可能需要检查<xref:System.Windows.FrameworkPropertyMetadata>上如果您不确定哪些属性可能需要一种新布局的属性的值将传递更改时。)  
  
 有关序列的对象事件的详细信息<xref:System.Windows.FrameworkElement>，并且还为多个相关应用程序和元素类，请参阅[对象生存期事件](~/docs/framework/wpf/advanced/object-lifetime-events.md)。  
  
 直接路由的事件不遵循路由，而仅处理引发它们在同一元素中。 直接路由的事件支持其他路由的事件行为： 它们支持的可访问的处理程序集合，并可用作<xref:System.Windows.EventTrigger>样式中。  
  
 <xref:System.Windows.FrameworkElement.Loaded> 和<xref:System.Windows.FrameworkElement.Unloaded>可能同时会引发用户启动系统主题更改控件上。 主题更改都会导致控件模板，并包含可视化树，从而导致整个控件以卸载并重新加载的失效。 因此<xref:System.Windows.FrameworkElement.Loaded>不能假设发生仅当一个页面首次加载通过导航到页。  
  
<a name="routedEventInfo_Loaded"></a>   
## <a name="routed-event-information"></a>路由事件信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.FrameworkElement.LoadedEvent>|  
|路由策略|直接|  
|委托|<xref:System.Windows.RoutedEventHandler>|  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.UIElement.OnRender(System.Windows.Media.DrawingContext)" />
      </Docs>
    </Member>
    <Member MemberName="LoadedEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent LoadedEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent LoadedEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.LoadedEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly LoadedEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ LoadedEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable LoadedEvent : System.Windows.RoutedEvent" Usage="System.Windows.FrameworkElement.LoadedEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="E:System.Windows.FrameworkElement.Loaded" /> 路由事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在注册路由事件时创建路由事件标识符。 这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。 可以使用这些标识符添加类处理程序。  
  
 有关注册路由事件的更多信息，请参见 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。 有关使用路由事件标识符添加类处理程序的更多信息，请参见 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LogicalChildren">
      <MemberSignature Language="C#" Value="protected internal virtual System.Collections.IEnumerator LogicalChildren { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.IEnumerator LogicalChildren" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.LogicalChildren" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable ReadOnly Property LogicalChildren As IEnumerator" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual property System::Collections::IEnumerator ^ LogicalChildren { System::Collections::IEnumerator ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.LogicalChildren : System.Collections.IEnumerator" Usage="System.Windows.FrameworkElement.LogicalChildren" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取此元素的逻辑子元素的一个枚举器。</summary>
        <value>此元素的逻辑子元素的一个枚举数。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.FrameworkElement.LogicalChildren%2A> 可以循环访问子元素。 这是对于那些可能不具有已定义的专用集合，但仍包含一个以上的子元素，尤其是<xref:System.Windows.FrameworkContentElement>子元素。  
  
 有关如何使用的详细信息<xref:System.Windows.FrameworkElement.LogicalChildren%2A>并<xref:System.Windows.FrameworkElement.AddLogicalChild%2A>，请参阅[WPF 中的树](~/docs/framework/wpf/advanced/trees-in-wpf.md)。  
  
 ]]></format>
        </remarks>
        <related type="Article" href="http://msdn.microsoft.com/library/c5358e14-d24c-44c7-b5eb-6062a4fd981c">x:Array 标记扩展</related>
      </Docs>
    </Member>
    <Member MemberName="Margin">
      <MemberSignature Language="C#" Value="public System.Windows.Thickness Margin { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Thickness Margin" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.Margin" />
      <MemberSignature Language="VB.NET" Value="Public Property Margin As Thickness" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Thickness Margin { System::Windows::Thickness get(); void set(System::Windows::Thickness value); };" />
      <MemberSignature Language="F#" Value="member this.Margin : System.Windows.Thickness with get, set" Usage="System.Windows.FrameworkElement.Margin" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Thickness</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置元素的外边距。</summary>
        <value>提供元素的边距值。 默认值是所有属性都等于 0（零）的 <see cref="T:System.Windows.Thickness" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 位置，此元素与布局创建时，将相邻的其他元素之间的间距[!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)]。 共享的元素可能是对等元素 （如公共父控件的集合中的其他元素），或者也可能是此元素的父级。  
  
 <xref:System.Windows.FrameworkElement.Margin%2A> 设置为<xref:System.Windows.Thickness>结构而不是一个数字，以便可以进行非对称设置边距。 <xref:System.Windows.Thickness>结构本身支持字符串类型转换，以便您可以指定非对称<xref:System.Windows.FrameworkElement.Margin%2A>中[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]还特性语法。  
  
 非零的边距之外的元素布局空间<xref:System.Windows.FrameworkElement.ActualWidth%2A>和<xref:System.Windows.FrameworkElement.ActualHeight%2A>。  
  
 边距是累加性的同级元素在布局中;例如，它们都具有 30 的边距设置相连的边缘的两个相邻元素将有 60 之间的距离单位。  
  
 具有边距设置的元素通常不会约束指定的大小<xref:System.Windows.FrameworkElement.Margin%2A>分配的矩形空间是否不足够大的边距加上元素的内容区域。 计算布局时，会改为约束的元素的内容区域。 边距将受限的唯一情况也是如果内容已局限到零。  
  
<a name="xamlAttributeUsage_Margin"></a>   
## <a name="xaml-attribute-usage"></a>XAML 属性用法  
  
```  
<object Margin="left,top,right,bottom"/>  
- or -  
<object Margin="left,top"/>  
- or -  
<object Margin="thicknessReference"/>  
```  
  
<a name="xamlPropertyElementUsage_Margin"></a>   
## <a name="xaml-property-element-usage"></a>XAML 属性元素用法  
  
```  
<object>  
  <object.Margin>  
    <Thickness Left="left" Top="top" Right="right" Bottom="bottom"/>  
  </object.Margin>  
</object>  
```  
  
<a name="xamlValues_Margin"></a>   
## <a name="xaml-values"></a>XAML 值  
 *左、 上、 右、 下*  
 0 之间的数字值和<xref:System.Double.PositiveInfinity>指定的四个可能的维属性<xref:System.Windows.Thickness>结构。  
  
 特性用法还将接受缩写的值提供，对称和以逻辑方式按顺序应用的。 例如，`Margin="20"`解释为<xref:System.Windows.Thickness>，所有属性均设置为 20。 `Margin="20,50"` 将被解释为平均值<xref:System.Windows.Thickness>与<xref:System.Windows.Thickness.Left%2A>并<xref:System.Windows.Thickness.Right%2A>设置为 20，和<xref:System.Windows.Thickness.Top%2A>和<xref:System.Windows.Thickness.Bottom%2A>设置为 50。  
  
 默认单位<xref:System.Windows.Thickness>度量值是[!INCLUDE[TLA#tla_dipixel](~/includes/tlasharptla-dipixel-md.md)]。 此外可以通过追加单位类型字符串来指定其他单位`cm`， `in`，或`pt`到任何度量值。  
  
 数字值作为提供[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]属性不需要指定小数点 （0 是可以接受，无需将提供为 0.0）。 有关详细信息[!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)]使用情况，请参阅<xref:System.Windows.Thickness>。  
  
 *thicknessReference*  
 对现有的对象引用<xref:System.Windows.Thickness>。 这可能是`}`、 a、 或`}`引用。 有关详细信息[!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)]使用情况，请参阅<xref:System.Windows.Thickness>。  
  
<a name="dependencyPropertyInfo_Margin"></a>   
## <a name="dependency-property-information"></a>依赖项属性信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.FrameworkElement.MarginProperty>|  
|元数据属性设置为 `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Thickness" />
      </Docs>
    </Member>
    <Member MemberName="MarginProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty MarginProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty MarginProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.MarginProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MarginProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ MarginProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable MarginProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.MarginProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="P:System.Windows.FrameworkElement.Margin" /> 依赖项属性。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MaxHeight">
      <MemberSignature Language="C#" Value="public double MaxHeight { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 MaxHeight" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.MaxHeight" />
      <MemberSignature Language="VB.NET" Value="Public Property MaxHeight As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double MaxHeight { double get(); void set(double value); };" />
      <MemberSignature Language="F#" Value="member this.MaxHeight : double with get, set" Usage="System.Windows.FrameworkElement.MaxHeight" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Windows.LengthConverter))</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.None, Readability=System.Windows.Readability.Unreadable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置元素的最大高度约束。</summary>
        <value>元素的最大高度，单位是[!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]。 默认值为 <see cref="F:System.Double.PositiveInfinity" />。 该值可以是等于或大于 0.0 的任何值。 <see cref="F:System.Double.PositiveInfinity" /> 也有效。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 这是三个属性之一上<xref:System.Windows.FrameworkElement>指定高度信息。 其他两个<xref:System.Windows.FrameworkElement.MinHeight%2A>和<xref:System.Windows.FrameworkElement.Height%2A>。  如果这些值之间存在冲突，确定高度的实际应用程序的顺序是： 首先<xref:System.Windows.FrameworkElement.MinHeight%2A>必须采用，然后<xref:System.Windows.FrameworkElement.MaxHeight%2A>，最后每个都在限制之内，如果<xref:System.Windows.FrameworkElement.Height%2A>。  
  
 值限制<xref:System.Double>值强制实施<xref:System.Windows.ValidateValueCallback>机制。 如果您尝试设置无效的值是引发运行时异常。  
  
<a name="xamlAttributeUsage_MaxHeight"></a>   
## <a name="xaml-attribute-usage"></a>XAML 属性用法  
  
```  
<object MaxHeight="double"/>  
- or –  
<object MaxHeight ="qualifiedDouble"/>  
```  
  
<a name="xamlValues_MaxHeight"></a>   
## <a name="xaml-values"></a>XAML 值  
 *double*  
 <xref:System.Double>  
  
 字符串表示形式<xref:System.Double>值等于或大于 0.0。 这被解释为[!INCLUDE[TLA#tla_dipixel](~/includes/tlasharptla-dipixel-md.md)]度量。 字符串不需要显式包括小数点。 例如，值的`1`是可接受。  
  
 相同<xref:System.Double>属性值部分中提到的范围限制适用，只不过必须使用[X:static 标记扩展](~/docs/framework/xaml-services/x-static-markup-extension.md)您是否需要显式设置此值为<xref:System.Double.PositiveInfinity>。  
  
 *qualifiedDouble*  
 一个*双*值，上文所述跟以下单位声明字符串之一： `px`， `in`， `cm`， `pt`。  
  
 `px` （默认值） [!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]  
  
 `in` 为英寸;1 中为 96px = =  
  
 `cm` 为厘米;1cm==(96/2.54) px  
  
 `pt` 为点;1pt==(96/72) px  
  
<a name="dependencyPropertyInfo_MaxHeight"></a>   
## <a name="dependency-property-information"></a>依赖项属性信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.FrameworkElement.MaxHeightProperty>|  
|元数据属性设置为 `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MaxHeightProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty MaxHeightProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty MaxHeightProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.MaxHeightProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MaxHeightProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ MaxHeightProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable MaxHeightProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.MaxHeightProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="P:System.Windows.FrameworkElement.MaxHeight" /> 依赖项属性。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MaxWidth">
      <MemberSignature Language="C#" Value="public double MaxWidth { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 MaxWidth" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.MaxWidth" />
      <MemberSignature Language="VB.NET" Value="Public Property MaxWidth As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double MaxWidth { double get(); void set(double value); };" />
      <MemberSignature Language="F#" Value="member this.MaxWidth : double with get, set" Usage="System.Windows.FrameworkElement.MaxWidth" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Windows.LengthConverter))</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.None, Readability=System.Windows.Readability.Unreadable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置元素的最大宽度约束。</summary>
        <value>元素的最大宽度，单位是[!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]。 默认值为 <see cref="F:System.Double.PositiveInfinity" />。 该值可以是等于或大于 0.0 的任何值。 <see cref="F:System.Double.PositiveInfinity" /> 也有效。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 这是三个属性之一上<xref:System.Windows.FrameworkElement>指定宽度的信息。 其他两个<xref:System.Windows.FrameworkElement.MinWidth%2A>和<xref:System.Windows.FrameworkElement.Width%2A>。 如果这些值之间存在冲突，应用程序实际宽度确定的顺序是： 首先<xref:System.Windows.FrameworkElement.MinWidth%2A>必须采用，然后<xref:System.Windows.FrameworkElement.MaxWidth%2A>，最后每个都在限制之内，如果<xref:System.Windows.FrameworkElement.Width%2A>。  
  
 值限制<xref:System.Double>值强制实施<xref:System.Windows.ValidateValueCallback>机制。 如果您尝试设置一个无效值，则会运行时异常。  
  
<a name="xamlAttributeUsage_MaxWidth"></a>   
## <a name="xaml-attribute-usage"></a>XAML 属性用法  
  
```  
<object MaxWidth="double"/>  
- or -  
<object MaxWidth="qualifiedDouble"/>  
```  
  
<a name="xamlValues_MaxWidth"></a>   
## <a name="xaml-values"></a>XAML 值  
 *double*  
 <xref:System.Double>  
  
 字符串表示形式<xref:System.Double>值等于或大于 0.0。 这被解释为[!INCLUDE[TLA#tla_dipixel](~/includes/tlasharptla-dipixel-md.md)]度量。 字符串不需要显式包括小数点。 例如，值的`1`是可接受。  
  
 相同<xref:System.Double>属性值部分中提到的范围限制适用，只不过必须使用[X:static 标记扩展](~/docs/framework/xaml-services/x-static-markup-extension.md)若要设置此值为<xref:System.Double.PositiveInfinity>。  
  
 *qualifiedDouble*  
 一个*双*值，上文所述跟以下单位声明字符串之一： `px`， `in`， `cm`， `pt`。  
  
 `px` （默认值） [!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]  
  
 `in` 为英寸;1 中为 96px = =  
  
 `cm` 为厘米;1cm==(96/2.54) px  
  
 `pt` 为点;1pt==(96/72) px  
  
<a name="dependencyPropertyInfo_MaxWidth"></a>   
## <a name="dependency-property-information"></a>依赖项属性信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.FrameworkElement.MaxWidthProperty>|  
|元数据属性设置为 `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MaxWidthProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty MaxWidthProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty MaxWidthProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.MaxWidthProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MaxWidthProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ MaxWidthProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable MaxWidthProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.MaxWidthProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="P:System.Windows.FrameworkElement.MaxWidth" /> 依赖项属性。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MeasureCore">
      <MemberSignature Language="C#" Value="protected override sealed System.Windows.Size MeasureCore (System.Windows.Size availableSize);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance valuetype System.Windows.Size MeasureCore(valuetype System.Windows.Size availableSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.MeasureCore(System.Windows.Size)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides NotOverridable Function MeasureCore (availableSize As Size) As Size" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Windows::Size MeasureCore(System::Windows::Size availableSize);" />
      <MemberSignature Language="F#" Value="override this.MeasureCore : System.Windows.Size -&gt; System.Windows.Size" Usage="frameworkElement.MeasureCore availableSize" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Size</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="availableSize" Type="System.Windows.Size" />
      </Parameters>
      <Docs>
        <param name="availableSize">父元素可以赋予子元素的可用大小。</param>
        <summary>实现 <see cref="T:System.Windows.FrameworkElement" /> 的基本测量处理过程布局系统行为。</summary>
        <returns>此元素在布局中的所需大小。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法重写<xref:System.Windows.UIElement.MeasureCore%2A?displayProperty=nameWithType>连接的 WPF 核心级别和 WPF 框架级别的布局度量值实现。 <xref:System.Windows.FrameworkElement>实现将密封方法。 若要调整基于 WPF 框架级别的任何元素的度量传递布局行为，请重写<xref:System.Windows.FrameworkElement.MeasureOverride%2A>相反。 若要调整的测量处理过程有意不会在 WPF 框架级别上生成或使用的元素的布局行为<xref:System.Windows.FrameworkElement>，重写<xref:System.Windows.UIElement.MeasureCore%2A?displayProperty=nameWithType>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MeasureOverride">
      <MemberSignature Language="C#" Value="protected virtual System.Windows.Size MeasureOverride (System.Windows.Size availableSize);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance valuetype System.Windows.Size MeasureOverride(valuetype System.Windows.Size availableSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.MeasureOverride(System.Windows.Size)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function MeasureOverride (availableSize As Size) As Size" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Windows::Size MeasureOverride(System::Windows::Size availableSize);" />
      <MemberSignature Language="F#" Value="abstract member MeasureOverride : System.Windows.Size -&gt; System.Windows.Size&#xA;override this.MeasureOverride : System.Windows.Size -&gt; System.Windows.Size" Usage="frameworkElement.MeasureOverride availableSize" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Size</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="availableSize" Type="System.Windows.Size" />
      </Parameters>
      <Docs>
        <param name="availableSize">此元素可提供给子元素的可用大小。 可指定无穷大作为一个值，该值指示元素将调整到适应内容的大小。</param>
        <summary>当在派生类中重写时，请测量子元素在布局中所需的大小，然后确定 <see cref="T:System.Windows.FrameworkElement" /> 派生类的大小。</summary>
        <returns>此元素基于其对子元素大小的计算确定它在布局期间所需要的大小。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 重写<xref:System.Windows.FrameworkElement.MeasureOverride%2A>来实现您的元素的自定义布局大小调整行为，如它参与了[!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)]布局系统。 您的实现应执行以下操作：  
  
1.  循环访问元素的特定集合的一部分的格式，请调用子级数<xref:System.Windows.UIElement.Measure%2A>每个子元素上。  
  
2.  立即获取<xref:System.Windows.UIElement.DesiredSize%2A>对子 (这设置为一个属性后<xref:System.Windows.UIElement.Measure%2A>称为)。  
  
3.  计算所需的子元素的测量值，基于父项的净大小。  
  
 返回值<xref:System.Windows.FrameworkElement.MeasureOverride%2A>应为元素自己的所需的大小，然后将成为当前元素的父元素的输入的度量值。 这一过程将继续通过布局系统，直到达到的页的根元素。  
  
 在此过程中，子元素可能会返回一个较大<xref:System.Windows.UIElement.DesiredSize%2A>大小大于初始`availableSize`来指示子元素，需要更多的空间。 通过引入可滚动区域，通过调整父控件，通过建立某种方式的堆叠顺序或任意数量的解决方案来测量或排列内容的大小，可能会在您自己的实现中处理这。  
  
> [!IMPORTANT]
>  元素应调用<xref:System.Windows.UIElement.Measure%2A>在每个在此过程中的子活动，否则为子元素将不会正确调整大小或排列。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>非编译的以下代码显示了此实现模式。  <c>VisualChildren</c>表示应定义您自己的元素的子级的可枚举集合属性。 该属性可以命名任何内容。 <c>VisualChildren</c>是此示例中的占位符名称<c>VisualChildren</c>不是[!INCLUDE[TLA#tla_api](~/includes/tlasharptla-api-md.md)]提供的[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]或一部分命名模式...  
  
[！ 代码 csharp[CorePseudocode #FEMeasureOverride](~/samples/snippets/csharp/VS_Snippets_Wpf/CorePseudocode/CSharp/corepseudocode.cs#femeasureoverride)] [！ 代码 vb[CorePseudocode #FEMeasureOverride](~/samples/snippets/visualbasic/VS_Snippets_Wpf/CorePseudocode/visualbasic/corepseudocode.vb#femeasureoverride)]</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="MinHeight">
      <MemberSignature Language="C#" Value="public double MinHeight { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 MinHeight" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.MinHeight" />
      <MemberSignature Language="VB.NET" Value="Public Property MinHeight As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double MinHeight { double get(); void set(double value); };" />
      <MemberSignature Language="F#" Value="member this.MinHeight : double with get, set" Usage="System.Windows.FrameworkElement.MinHeight" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Windows.LengthConverter))</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.None, Readability=System.Windows.Readability.Unreadable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置元素的最小高度约束。</summary>
        <value>元素的最小高度，单位是[!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]。 默认值为 0.0。 该值可以是等于或大于 0.0 的任何值。 但是，<see cref="F:System.Double.PositiveInfinity" /> 无效，<see cref="F:System.Double.NaN" /> 也无效。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 这是三个属性之一上<xref:System.Windows.FrameworkElement>指定高度信息。  其他两个<xref:System.Windows.FrameworkElement.Height%2A>和<xref:System.Windows.FrameworkElement.MaxHeight%2A>。 如果这些值之间存在冲突，确定高度的实际应用程序的顺序是： 首先<xref:System.Windows.FrameworkElement.MinHeight%2A>必须采用，然后<xref:System.Windows.FrameworkElement.MaxHeight%2A>，最后每个都在限制之内，如果<xref:System.Windows.FrameworkElement.Height%2A>。  
  
 值限制<xref:System.Double>值强制实施<xref:System.Windows.ValidateValueCallback>机制。 如果您尝试设置一个无效值，则会运行时异常。  
  
<a name="xamlAttributeUsage_MinHeight"></a>   
## <a name="xaml-attribute-usage"></a>XAML 属性用法  
  
```  
<object MinHeight="double"/>  
- or -  
<object MinHeight="qualifiedDouble"/>  
```  
  
<a name="xamlValues_MinHeight"></a>   
## <a name="xaml-values"></a>XAML 值  
 *double*  
 <xref:System.Double>  
  
 字符串表示形式<xref:System.Double>值等于或大于 0.0。 这被解释为[!INCLUDE[TLA#tla_dipixel](~/includes/tlasharptla-dipixel-md.md)]度量。 字符串不需要显式包括小数点。 例如，值的`1`是可接受。  
  
 相同<xref:System.Double>属性值部分中提到的范围限制适用。  
  
 *qualifiedDouble*  
 一个*双*值，上文所述跟以下单位声明字符串之一： `px`， `in`， `cm`， `pt`。  
  
 `px` （默认值） [!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]  
  
 `in` 为英寸;1 中为 96px = =  
  
 `cm` 为厘米;1cm==(96/2.54) px  
  
 `pt` 为点;1pt==(96/72) px  
  
<a name="dependencyPropertyInfo_MinHeight"></a>   
## <a name="dependency-property-information"></a>依赖项属性信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.FrameworkElement.MinHeightProperty>|  
|元数据属性设置为 `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MinHeightProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty MinHeightProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty MinHeightProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.MinHeightProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MinHeightProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ MinHeightProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable MinHeightProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.MinHeightProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="P:System.Windows.FrameworkElement.MinHeight" /> 依赖项属性。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MinWidth">
      <MemberSignature Language="C#" Value="public double MinWidth { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 MinWidth" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.MinWidth" />
      <MemberSignature Language="VB.NET" Value="Public Property MinWidth As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double MinWidth { double get(); void set(double value); };" />
      <MemberSignature Language="F#" Value="member this.MinWidth : double with get, set" Usage="System.Windows.FrameworkElement.MinWidth" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Windows.LengthConverter))</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.None, Readability=System.Windows.Readability.Unreadable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置元素的最小宽度约束。</summary>
        <value>元素的最小宽度，单位是[!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]。 默认值为 0.0。 该值可以是等于或大于 0.0 的任何值。 但是，<see cref="F:System.Double.PositiveInfinity" /> 无效，<see cref="F:System.Double.NaN" /> 也无效。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 这是三个属性之一上<xref:System.Windows.FrameworkElement>指定宽度的信息。  其他两个<xref:System.Windows.FrameworkElement.Width%2A>和<xref:System.Windows.FrameworkElement.MaxWidth%2A>。  如果这些值之间存在冲突，应用程序实际宽度确定的顺序是： 首先<xref:System.Windows.FrameworkElement.MinWidth%2A>必须采用，然后<xref:System.Windows.FrameworkElement.MaxWidth%2A>，最后每个都在限制之内，如果<xref:System.Windows.FrameworkElement.Width%2A>。  
  
 值限制<xref:System.Double>值强制实施<xref:System.Windows.ValidateValueCallback>机制。 如果您尝试设置一个无效值，则会运行时异常。  
  
<a name="xamlAttributeUsage_MinWidth"></a>   
## <a name="xaml-attribute-usage"></a>XAML 属性用法  
  
```  
<object MinWidth="double"/>  
- or -  
<object MinWidth="qualifiedDouble"/>  
```  
  
<a name="xamlValues_MinWidth"></a>   
## <a name="xaml-values"></a>XAML 值  
 *double*  
 <xref:System.Double>  
  
 字符串表示形式<xref:System.Double>值等于或大于 0.0。 这被解释为[!INCLUDE[TLA#tla_dipixel](~/includes/tlasharptla-dipixel-md.md)]度量。 字符串不需要显式包括小数点。 例如，值的`1`是可接受。  
  
 相同<xref:System.Double>属性值部分中提到的范围限制适用。  
  
 *qualifiedDouble*  
 一个*双*值，上文所述跟以下单位声明字符串之一： `px`， `in`， `cm`， `pt`。  
  
 `px` （默认值） [!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]  
  
 `in` 为英寸;1 中为 96px = =  
  
 `cm` 为厘米;1cm==(96/2.54) px  
  
 `pt` 为点;1pt==(96/72) px  
  
<a name="dependencyPropertyInfo_MinWidth"></a>   
## <a name="dependency-property-information"></a>依赖项属性信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.FrameworkElement.MinWidthProperty>|  
|元数据属性设置为 `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MinWidthProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty MinWidthProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty MinWidthProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.MinWidthProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MinWidthProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ MinWidthProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable MinWidthProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.MinWidthProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="P:System.Windows.FrameworkElement.MinWidth" /> 依赖项属性。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MoveFocus">
      <MemberSignature Language="C#" Value="public override sealed bool MoveFocus (System.Windows.Input.TraversalRequest request);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool MoveFocus(class System.Windows.Input.TraversalRequest request) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.MoveFocus(System.Windows.Input.TraversalRequest)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides NotOverridable Function MoveFocus (request As TraversalRequest) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool MoveFocus(System::Windows::Input::TraversalRequest ^ request);" />
      <MemberSignature Language="F#" Value="override this.MoveFocus : System.Windows.Input.TraversalRequest -&gt; bool" Usage="frameworkElement.MoveFocus request" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="request" Type="System.Windows.Input.TraversalRequest" />
      </Parameters>
      <Docs>
        <param name="request">焦点要移动的方向，作为一个枚举值。</param>
        <summary>以提供的遍历方向将键盘焦点从此元素移到其他元素上。</summary>
        <returns>如果焦点移动成功，则返回 <see langword="true" />；如果指定方向上不存在目标元素，或者未能将键盘焦点移到目标元素上，则返回 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此实现将重写<xref:System.Windows.UIElement.MoveFocus%2A?displayProperty=nameWithType>并密封方法。  
  
   
  
## Examples  
 下面的示例实现的处理程序处理多个可能的按钮输入。 每个按钮都表示一个可能<xref:System.Windows.Input.FocusNavigationDirection>。 处理程序将跟踪与当前的键盘焦点，并调用元素<xref:System.Windows.FrameworkElement.MoveFocus%2A>在该元素，通过指定相应<xref:System.Windows.Input.FocusNavigationDirection>初始化为<xref:System.Windows.Input.TraversalRequest>类型提供的参数。  
  
 [!code-csharp[FocusSample#FocusSampleMoveFocus](~/samples/snippets/csharp/VS_Snippets_Wpf/FocusSample/CSharp/Window1.xaml.cs#focussamplemovefocus)]
 [!code-vb[FocusSample#FocusSampleMoveFocus](~/samples/snippets/visualbasic/VS_Snippets_Wpf/FocusSample/visualbasic/window1.xaml.vb#focussamplemovefocus)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.UIElement.MoveFocus(System.Windows.Input.TraversalRequest)" />
        <altmember cref="M:System.Windows.UIElement.Focus" />
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public string Name { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.Name" />
      <MemberSignature Language="VB.NET" Value="Public Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Name { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Name : string with get, set" Usage="System.Windows.FrameworkElement.Name" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.IFrameworkInputElement.Name</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.MergableProperty(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.NeverLocalize)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Windows.Markup.DesignerSerializationOptions</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5">
          <AttributeName>System.Windows.Markup.DesignerSerializationOptions(System.Windows.Markup.DesignerSerializationOptions.SerializeAsAttribute)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置元素的标识名称。 该名称提供一个引用，以便当 [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] 处理器在处理过程中构造标记元素之后，代码隐藏（如事件处理程序代码）可以对该元素进行引用。</summary>
        <value>元素的名称。 默认值为一个空字符串。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此属性的最常见用法是指定[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]作为标记中的属性的元素名称。  
  
 此属性实质上是提供一个 WPF 框架级便捷属性来设置[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] [X:name 指令](~/docs/framework/xaml-services/x-name-directive.md)。  
  
 名称必须是唯一名称范围内。 有关详细信息，请参阅[WPF XAML 名称范围](~/docs/framework/wpf/advanced/wpf-xaml-namescopes.md)。  
  
 获取<xref:System.Windows.FrameworkElement.Name%2A>如果要创建中的元素的代码并不常用。 如果已在代码中具有适当的引用，只需调用方法和属性在元素上的引用通常并不需要<xref:System.Windows.FrameworkElement.Name%2A>。 与此例外情况是如果<xref:System.Windows.FrameworkElement.Name%2A>字符串具有某些重载的含义，例如用于中显示该名称是否[!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)]。 设置<xref:System.Windows.FrameworkElement.Name%2A>从代码隐藏如果原始<xref:System.Windows.FrameworkElement.Name%2A>从标记中设置也不建议，并将属性更改后加载[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]不会更改原始对象引用。 仅当在分析过程中显式创建基础名称范围时，会创建对象引用。 具体而言，必须调用<xref:System.Windows.FrameworkElement.RegisterName%2A>以进行有效的更改到<xref:System.Windows.FrameworkElement.Name%2A>已加载元素的属性。  
  
 一个值得一提设置情况<xref:System.Windows.FrameworkElement.Name%2A>从代码很重要时，可以注册名称的元素的演示图板将运行，以便它们可以在运行时引用。 可以注册名称之前，可能还需要实例化并分配<xref:System.Windows.NameScope>实例。 请参阅示例部分中，或[情节提要概述](~/docs/framework/wpf/graphics-multimedia/storyboards-overview.md)。  
  
 设置<xref:System.Windows.FrameworkElement.Name%2A>代码中具有有限的应用程序，但获取元素的<xref:System.Windows.FrameworkElement.Name%2A>更为常见。 一个特殊的情况是如果你的应用程序支持其中页面重新加载到应用程序，而且运行的时代码不一定是代码隐藏定义该页面的导航模型。 实用程序方法<xref:System.Windows.FrameworkElement.FindName%2A>，这是可从任何<xref:System.Windows.FrameworkElement>，可以找到的任何元素<xref:System.Windows.FrameworkElement.Name%2A>在该元素的逻辑树中，搜索树以递归方式将根据需要。 也可以使用<xref:System.Windows.LogicalTreeHelper.FindLogicalNode%2A>的静态方法<xref:System.Windows.LogicalTreeHelper>，其还会<xref:System.Windows.FrameworkElement.Name%2A>字符串作为参数。  
  
 通常使用的根元素 (<xref:System.Windows.Window>，<xref:System.Windows.Controls.Page>例如) 实现该接口<xref:System.Windows.Markup.INameScope>。 此接口的实现需要强制实施的名称会明确其作用域内。 定义此接口的根元素还定义名称范围行为边界的所有相关[!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)]。  
  
 <xref:System.Windows.FrameworkElement.Name%2A>属性也可作为其他进程的标识符。 例如，[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]自动化模型将使用<xref:System.Windows.FrameworkElement.Name%2A>作为客户端和提供程序的 AutomationId。  
  
 所使用的字符串值<xref:System.Windows.FrameworkElement.Name%2A>具有一些限制，如下所规定的基础[X:name 指令](~/docs/framework/xaml-services/x-name-directive.md)定义的[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]规范。 最值得注意的是，<xref:System.Windows.FrameworkElement.Name%2A>必须以字母或下划线字符 (_) 开头，并且必须包含字母、 数字或下划线。 有关详细信息，请参阅[WPF XAML 名称范围](~/docs/framework/wpf/advanced/wpf-xaml-namescopes.md)。  
  
 <xref:System.Windows.FrameworkElement.Name%2A> 是一个不能进行动画处理的很少依赖项属性 (<xref:System.Windows.UIPropertyMetadata.IsAnimationProhibited%2A>是`true`元数据中)，因为名称本身是所必需的定位动画。 数据绑定<xref:System.Windows.FrameworkElement.Name%2A>是从技术上讲是可行的但是极少见的方案，因为数据绑定<xref:System.Windows.FrameworkElement.Name%2A>不能提供的属性的主要用途： 若要隐藏代码提供的标识符连接点。  
  
<a name="dependencyPropertyInfo_Name"></a>   
## <a name="dependency-property-information"></a>依赖项属性信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.FrameworkElement.NameProperty>|  
|元数据属性设置为 `true`|<xref:System.Windows.UIPropertyMetadata.IsAnimationProhibited%2A>|  
  
   
  
## Examples  
 下面的示例设置<xref:System.Windows.FrameworkElement.Name%2A>在代码中，属性，然后注册到新创建的名称<xref:System.Windows.NameScope>通过调用<xref:System.Windows.FrameworkElement.RegisterName%2A>。 如下图所示的方法是必需的进行动画处理与情节提要，情节提要需要按确定由于<xref:System.Windows.FrameworkElement.Name%2A>，并且不能为目标的对象引用。  
  
 [!code-csharp[animateHeight_procedural#FEName](~/samples/snippets/csharp/VS_Snippets_Wpf/animateHeight_procedural/CSharp/AnimatedHeightExample.cs#fename)]
 [!code-vb[animateHeight_procedural#FEName](~/samples/snippets/visualbasic/VS_Snippets_Wpf/animateHeight_procedural/visualbasic/animatedheightexample.vb#fename)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="NameProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty NameProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty NameProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.NameProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly NameProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ NameProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable NameProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.NameProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="P:System.Windows.FrameworkElement.Name" /> 依赖项属性。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnApplyTemplate">
      <MemberSignature Language="C#" Value="public virtual void OnApplyTemplate ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void OnApplyTemplate() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.OnApplyTemplate" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub OnApplyTemplate ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void OnApplyTemplate();" />
      <MemberSignature Language="F#" Value="abstract member OnApplyTemplate : unit -&gt; unit&#xA;override this.OnApplyTemplate : unit -&gt; unit" Usage="frameworkElement.OnApplyTemplate " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>在派生类中重写后，每当应用程序代码或内部进程调用 <see cref="M:System.Windows.FrameworkElement.ApplyTemplate" />，都将调用此方法。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法具有默认实现。  
  
 模板是来自的 Template 属性的元素的已完成可视化树的一部分<xref:System.Windows.Style>元素应用。 有关详细信息，请参阅[样式设置和模板化](~/docs/framework/wpf/controls/styling-and-templating.md)。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>派生类的<see cref="T:System.Windows.FrameworkElement" />可以使用此方法作为通知的各种可能方案： 
-你可以调用您自己的代码生成元素可视化树的其余部分的实现。  
  
-你可以运行依赖于例如获取对来自模板的命名元素的引用，已应用的模板中的可视化树的代码。  
  
-你可以引入仅存在意义模板中的可视化树完成后的服务。  
  
-你可以设置的状态和依赖于其他因素在模板中的元素的属性。 例如，属性值可能仅可检测到通过了解父元素，或当特定派生类使用一个通用的模板。  
  
实施者应始终调用前其自己的实现的基实现。 <see cref="T:System.Windows.FrameworkElement" /> 本身不具有默认实现，但插入类可能。  
  
 <see cref="T:System.Windows.Controls.Control" /> 提供了类似的重写<see cref="M:System.Windows.Controls.Control.OnTemplateChanged(System.Windows.Controls.ControlTemplate,System.Windows.Controls.ControlTemplate)" />。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnContextMenuClosing">
      <MemberSignature Language="C#" Value="protected virtual void OnContextMenuClosing (System.Windows.Controls.ContextMenuEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnContextMenuClosing(class System.Windows.Controls.ContextMenuEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.OnContextMenuClosing(System.Windows.Controls.ContextMenuEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnContextMenuClosing (e As ContextMenuEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnContextMenuClosing(System::Windows::Controls::ContextMenuEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnContextMenuClosing : System.Windows.Controls.ContextMenuEventArgs -&gt; unit&#xA;override this.OnContextMenuClosing : System.Windows.Controls.ContextMenuEventArgs -&gt; unit" Usage="frameworkElement.OnContextMenuClosing e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Controls.ContextMenuEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">提供与事件有关的数据。</param>
        <summary>每当未处理的 <see cref="E:System.Windows.FrameworkElement.ContextMenuClosing" /> 路由事件在其路由中到达此类时调用。 实现此方法可为此事件添加类处理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法具有默认实现。 继承中的中间类已经实现了此方法的情况下，仍应调用基实现。  
  
 此方法的目的是某种程度上类似于[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]事件模式 On * 方法： 它提供了方法来处理从派生类的类处理程序而不是实例处理程序匹配的事件。 在这种情况下匹配事件是路由的事件。 On * 方法的实现模式是不同的路由事件，因为路由的事件可能由子元素，不一定是将调用处理程序，因此您的实现将需要使事件参数的源的元素引发将属性转换为帐户 （和不应尝试重新引发该事件在大多数情况下）。 子类<xref:System.Windows.FrameworkElement>无法选择路由收到事件时调用私有类处理程序方法。 一个可能的方案是采用的事件自变量并谨慎地将事件标记为已处理。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnContextMenuOpening">
      <MemberSignature Language="C#" Value="protected virtual void OnContextMenuOpening (System.Windows.Controls.ContextMenuEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnContextMenuOpening(class System.Windows.Controls.ContextMenuEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.OnContextMenuOpening(System.Windows.Controls.ContextMenuEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnContextMenuOpening (e As ContextMenuEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnContextMenuOpening(System::Windows::Controls::ContextMenuEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnContextMenuOpening : System.Windows.Controls.ContextMenuEventArgs -&gt; unit&#xA;override this.OnContextMenuOpening : System.Windows.Controls.ContextMenuEventArgs -&gt; unit" Usage="frameworkElement.OnContextMenuOpening e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Controls.ContextMenuEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.Windows.RoutedEventArgs" />。</param>
        <summary>每当未处理的 <see cref="E:System.Windows.FrameworkElement.ContextMenuOpening" /> 路由事件在其路由中到达此类时调用。 实现此方法可为此事件添加类处理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法具有默认实现。 继承中的中间类已经实现了此方法的情况下，仍应调用基实现。  
  
 此方法的目的是某种程度上类似于[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]事件模式 On * 方法： 它提供了方法来处理从派生类的类处理程序而不是实例处理程序匹配的事件。 在这种情况下匹配事件是路由的事件。 On * 方法的实现模式是不同的路由事件，因为路由的事件可能由子元素，不一定是将调用处理程序，因此您的实现将需要使事件参数的源的元素引发将属性转换为帐户 （和不应尝试重新引发该事件在大多数情况下）。 子类<xref:System.Windows.FrameworkElement>无法选择路由收到事件时调用私有类处理程序方法。 一个可能的方案是采用的事件自变量并谨慎地将事件标记为已处理。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnGotFocus">
      <MemberSignature Language="C#" Value="protected override void OnGotFocus (System.Windows.RoutedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnGotFocus(class System.Windows.RoutedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.OnGotFocus(System.Windows.RoutedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnGotFocus (e As RoutedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnGotFocus(System::Windows::RoutedEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnGotFocus : System.Windows.RoutedEventArgs -&gt; unit" Usage="frameworkElement.OnGotFocus e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.RoutedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.Windows.RoutedEventArgs" />。</param>
        <summary>每当未处理的 <see cref="E:System.Windows.UIElement.GotFocus" /> 事件在其路由中到达此元素时调用。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 与一些其他不同 * 由基元素公开的方法<xref:System.Windows.FrameworkElement.OnGotFocus%2A>具有默认实现。 具体而言，它具有将基元素的下一级别中的空实现，重写实现<xref:System.Windows.UIElement.OnGotFocus%2A>。 调用时，<xref:System.Windows.FrameworkElement.OnGotFocus%2A>在事件从由于键盘焦点的当前元素的位置的情况下此元素上设置相应的焦点行为。 <xref:System.Windows.FrameworkElement.OnGotFocus%2A>处理程序不会将标记为已处理，即使焦点设置到当前元素的事件参数。 如果事件的源树 （不是当前元素） 中的另一个元素，该处理程序没有任何影响。  
  
 可以重写此方法，以便更改在元素上的默认焦点行为，但请注意，更改焦点行为在这种方式可能更好地完成通过不允许要在所有可获得焦点的元素 (请参阅<xref:System.Windows.UIElement.Focusable%2A>)。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>如果你想要标记为已处理参数中，您应注意的事件处理在元素树中其他父元素中的后果。 由于此处理程序使用冒泡路由事件，因此将焦点设置为当前<paramref name="sender" />每个事件自变量可能不太合适。 焦点可能需要转到复合的子元素或父元素，具体取决于特定控件的组合。 如果该事件路由通过可视化树的整个属于您编写的控件的组合的情况下，仅建议因此将焦点事件标记为已处理。</para>
        </block>
        <altmember cref="P:System.Windows.UIElement.Focusable" />
      </Docs>
    </Member>
    <Member MemberName="OnInitialized">
      <MemberSignature Language="C#" Value="protected virtual void OnInitialized (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnInitialized(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.OnInitialized(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnInitialized (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnInitialized(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnInitialized : EventArgs -&gt; unit&#xA;override this.OnInitialized : EventArgs -&gt; unit" Usage="frameworkElement.OnInitialized e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.Windows.RoutedEventArgs" />。</param>
        <summary>引发 <see cref="E:System.Windows.FrameworkElement.Initialized" /> 事件。 每当在内部将 <see cref="P:System.Windows.FrameworkElement.IsInitialized" /> 设置为 <see langword="true" /> 时调用此方法。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在此特定 * 方法不是类处理程序挂钩。 也不会它完全遵循以下的既定[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]上 * 方法约定匹配的事件，可以禁用通过重写此方法并不调用基实现。  
  
 请注意，<xref:System.Windows.FrameworkElement.IsInitialized%2A>属性是只读的因此不能设置<xref:System.Windows.FrameworkElement.IsInitialized%2A>强制初始化行为。 初始化状态设置旨在只能由[!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)]框架。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>此虚方法的默认实现将引发上述事件。 重写应调用基实现来保留此行为。 如果您不能调用基实现，不只您不会引发<see cref="E:System.Windows.FrameworkElement.Initialized" />事件，如通常预期的那样<see cref="T:System.Windows.FrameworkElement" />派生的类，但也将禁止显示两个重要样式和主题样式的初始化操作实现此基实现。</para>
        </block>
        <altmember cref="M:System.Windows.FrameworkElement.OnApplyTemplate" />
        <altmember cref="E:System.Windows.FrameworkElement.Initialized" />
      </Docs>
    </Member>
    <Member MemberName="OnPropertyChanged">
      <MemberSignature Language="C#" Value="protected override void OnPropertyChanged (System.Windows.DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnPropertyChanged(valuetype System.Windows.DependencyPropertyChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnPropertyChanged (e As DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnPropertyChanged(System::Windows::DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="F#" Value="abstract member OnPropertyChanged : System.Windows.DependencyPropertyChangedEventArgs -&gt; unit&#xA;override this.OnPropertyChanged : System.Windows.DependencyPropertyChangedEventArgs -&gt; unit" Usage="frameworkElement.OnPropertyChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DependencyPropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">描述已更改的属性的事件数据（包括旧值和新值）。</param>
        <summary>每当更新此 <see cref="T:System.Windows.FrameworkElement" /> 上任何依赖项属性的有效值时调用。 将在实参形参中报告已更改的特定依赖属性。 重写 <see cref="M:System.Windows.DependencyObject.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法不应以通常将检测到属性更改或失效。 它改为适用于修改常规失效模式如果特定的信息了解了宽分类的属性。  
  
 调用此方法可能很多时候一个对象的生命周期内。 因此，可以实现更好的性能，如果重写特定属性的元数据，然后将附加<xref:System.Windows.CoerceValueCallback>或<xref:System.Windows.PropertyChangedCallback>各个属性的函数。 但是，应使用此方法，如果<xref:System.Windows.FrameworkElement>包括大量的值相关的依赖项属性，或如果它包含逻辑，例如呈现行为，必须重新运行多个相关的属性失效的情况。  
  
 请注意，没有具有相同名称`OnPropertyChanged`具有不同签名的方法 (参数类型是<xref:System.ComponentModel.PropertyChangedEventArgs>)，可能出现在多个类。 是否`OnPropertyChanged`用于数据对象通知，并且是为协定的一部分<xref:System.ComponentModel.INotifyPropertyChanged>。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>始终调用基实现中，您的实现中的第一个操作。 如果不这样做将大大禁用整个[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]属性系统，这会导致不正确的值报告。 特定于<see cref="T:System.Windows.FrameworkElement" />实现也是负责维护的各种影响可视用户界面的属性的正确状态。 其中包括验证基于在适当的样式的更改可视化树。</para>
        </block>
        <altmember cref="M:System.Windows.DependencyObject.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
        <altmember cref="T:System.Windows.PropertyChangedCallback" />
      </Docs>
    </Member>
    <Member MemberName="OnRenderSizeChanged">
      <MemberSignature Language="C#" Value="protected internal override void OnRenderSizeChanged (System.Windows.SizeChangedInfo sizeInfo);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance void OnRenderSizeChanged(class System.Windows.SizeChangedInfo sizeInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.OnRenderSizeChanged(System.Windows.SizeChangedInfo)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides Sub OnRenderSizeChanged (sizeInfo As SizeChangedInfo)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override void OnRenderSizeChanged(System::Windows::SizeChangedInfo ^ sizeInfo);" />
      <MemberSignature Language="F#" Value="override this.OnRenderSizeChanged : System.Windows.SizeChangedInfo -&gt; unit" Usage="frameworkElement.OnRenderSizeChanged sizeInfo" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sizeInfo" Type="System.Windows.SizeChangedInfo" />
      </Parameters>
      <Docs>
        <param name="sizeInfo">更改中所涉及新旧大小的详细信息。</param>
        <summary>通过使用指定的信息作为最终事件数据的一部分来引发 <see cref="E:System.Windows.FrameworkElement.SizeChanged" /> 事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法重写 <xref:System.Windows.UIElement.OnRenderSizeChanged%2A>。 如果调用此方法将重置<xref:System.Windows.FrameworkElement.ActualWidth%2A>属性，<xref:System.Windows.FrameworkElement.ActualHeight%2A>中提供的参数，更改属性，或两者，具体取决于为指定的内容，并且将始终引发此事件。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>不重写此方法对于典型布局方案。 布局系统的操作特意异步的方式，以确保所有可能的布局排列和度量值的情况下都考虑在内。 布局系统重写方法<see cref="M:System.Windows.FrameworkElement.MeasureOverride(System.Windows.Size)" />和<see cref="M:System.Windows.FrameworkElement.ArrangeOverride(System.Windows.Size)" />通常足以满足任何必需的布局自定义项。 <see cref="M:System.Windows.FrameworkElement.OnRenderSizeChanged(System.Windows.SizeChangedInfo)" /> 公开为虚拟机。 您可以重写<see cref="M:System.Windows.FrameworkElement.OnRenderSizeChanged(System.Windows.SizeChangedInfo)" />来更正为异常用例的运行时行为改变与相关的输入事件与控件结合使用以响应重新组合可能会提供不准确的布局信息。  
  
你仍然可以重写此方法在派生类 （它是受保护但未密封） 中。 始终调用基实现以保留前面所述的行为，除非有特定原因需要禁用默认的 WPF 框架级别呈现行为。 无法引发<see cref="E:System.Windows.FrameworkElement.SizeChanged" />事件将导致非标准的布局行为，如果使用标准的 WPF 框架级别的布局系统实现。</para>
        </block>
        <altmember cref="M:System.Windows.FrameworkElement.MeasureOverride(System.Windows.Size)" />
        <altmember cref="M:System.Windows.FrameworkElement.ArrangeOverride(System.Windows.Size)" />
        <altmember cref="M:System.Windows.UIElement.OnRender(System.Windows.Media.DrawingContext)" />
      </Docs>
    </Member>
    <Member MemberName="OnStyleChanged">
      <MemberSignature Language="C#" Value="protected internal virtual void OnStyleChanged (System.Windows.Style oldStyle, System.Windows.Style newStyle);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnStyleChanged(class System.Windows.Style oldStyle, class System.Windows.Style newStyle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.OnStyleChanged(System.Windows.Style,System.Windows.Style)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnStyleChanged (oldStyle As Style, newStyle As Style)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnStyleChanged(System::Windows::Style ^ oldStyle, System::Windows::Style ^ newStyle);" />
      <MemberSignature Language="F#" Value="abstract member OnStyleChanged : System.Windows.Style * System.Windows.Style -&gt; unit&#xA;override this.OnStyleChanged : System.Windows.Style * System.Windows.Style -&gt; unit" Usage="frameworkElement.OnStyleChanged (oldStyle, newStyle)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldStyle" Type="System.Windows.Style" />
        <Parameter Name="newStyle" Type="System.Windows.Style" />
      </Parameters>
      <Docs>
        <param name="oldStyle">旧样式。</param>
        <param name="newStyle">新样式。</param>
        <summary>当此元素上使用的样式更改时（将使布局失效）调用。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法具有一个默认实现，设置说明样式更改条件的内部标志。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>通常不必重写此方法。 任何涉及到度量值的样式或排列过程更改都会触发另一个呈现循环，假定的典型实现<see cref="M:System.Windows.FrameworkElement.ArrangeOverride(System.Windows.Size)" />  /  <see cref="M:System.Windows.FrameworkElement.MeasureOverride(System.Windows.Size)" />，或默认值。 重写<see cref="M:System.Windows.FrameworkElement.OnStyleChanged(System.Windows.Style,System.Windows.Style)" />可能适用如果您<see cref="M:System.Windows.FrameworkElement.ArrangeOverride(System.Windows.Size)" />  /  <see cref="M:System.Windows.FrameworkElement.MeasureOverride(System.Windows.Size)" />实现特意优化或支持部分更新，但仍想要更直接地将更改应用于样式。 (部分更新将尝试避免对多个增量调用<see cref="M:System.Windows.UIElement.Measure(System.Windows.Size)" />和<see cref="M:System.Windows.UIElement.Arrange(System.Windows.Rect)" />上的任何子元素)。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnToolTipClosing">
      <MemberSignature Language="C#" Value="protected virtual void OnToolTipClosing (System.Windows.Controls.ToolTipEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnToolTipClosing(class System.Windows.Controls.ToolTipEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.OnToolTipClosing(System.Windows.Controls.ToolTipEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnToolTipClosing (e As ToolTipEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnToolTipClosing(System::Windows::Controls::ToolTipEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnToolTipClosing : System.Windows.Controls.ToolTipEventArgs -&gt; unit&#xA;override this.OnToolTipClosing : System.Windows.Controls.ToolTipEventArgs -&gt; unit" Usage="frameworkElement.OnToolTipClosing e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Controls.ToolTipEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">提供与事件有关的数据。</param>
        <summary>每当未处理的 <see cref="E:System.Windows.FrameworkElement.ToolTipClosing" /> 路由事件在其路由中到达此类时调用。 实现此方法可为此事件添加类处理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法具有默认实现。 继承中的中间类已经实现了此方法的情况下，仍应调用基实现。  
  
 此方法的目的是某种程度上类似于[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]事件模式 On * 方法： 它提供了方法来处理从派生类的类处理程序而不是实例处理程序匹配的事件。 在这种情况下匹配事件是路由的事件。 On * 方法的实现模式是不同的路由事件，因为路由的事件可能由子元素，不一定是将调用处理程序，因此您的实现将需要使事件参数的源的元素引发将属性转换为帐户 （和不应尝试重新引发该事件在大多数情况下）。 子类<xref:System.Windows.FrameworkElement>无法选择路由收到事件时调用私有类处理程序方法。 一个可能的方案是采用的事件自变量并谨慎地将事件标记为已处理。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnToolTipOpening">
      <MemberSignature Language="C#" Value="protected virtual void OnToolTipOpening (System.Windows.Controls.ToolTipEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnToolTipOpening(class System.Windows.Controls.ToolTipEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.OnToolTipOpening(System.Windows.Controls.ToolTipEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnToolTipOpening (e As ToolTipEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnToolTipOpening(System::Windows::Controls::ToolTipEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnToolTipOpening : System.Windows.Controls.ToolTipEventArgs -&gt; unit&#xA;override this.OnToolTipOpening : System.Windows.Controls.ToolTipEventArgs -&gt; unit" Usage="frameworkElement.OnToolTipOpening e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Controls.ToolTipEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">提供与事件有关的数据。</param>
        <summary>每当 <see cref="E:System.Windows.FrameworkElement.ToolTipOpening" /> 路由事件在其路由中到达此类时调用。 实现此方法可为此事件添加类处理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法具有默认实现。 继承中的中间类已经实现了此方法的情况下，仍应调用基实现。  
  
 此方法的目的是某种程度上类似于[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]事件模式 On * 方法： 它提供了方法来处理从派生类的类处理程序而不是实例处理程序匹配的事件。 在这种情况下匹配事件是路由的事件。 On * 方法的实现模式是不同的路由事件，因为路由的事件可能由子元素，不一定是将调用处理程序，因此您的实现将需要使事件参数的源的元素引发将属性转换为帐户 （和不应尝试重新引发该事件在大多数情况下）。 子类<xref:System.Windows.FrameworkElement>无法选择路由收到事件时调用私有类处理程序方法。 一个可能的方案是采用的事件自变量并谨慎地将事件标记为已处理来缩短路由。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnVisualParentChanged">
      <MemberSignature Language="C#" Value="protected internal override void OnVisualParentChanged (System.Windows.DependencyObject oldParent);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance void OnVisualParentChanged(class System.Windows.DependencyObject oldParent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.OnVisualParentChanged(System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides Sub OnVisualParentChanged (oldParent As DependencyObject)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override void OnVisualParentChanged(System::Windows::DependencyObject ^ oldParent);" />
      <MemberSignature Language="F#" Value="override this.OnVisualParentChanged : System.Windows.DependencyObject -&gt; unit" Usage="frameworkElement.OnVisualParentChanged oldParent" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldParent" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="oldParent">旧的父元素。 可以为 <see langword="null" />，指示元素未曾有过可视化父级。</param>
        <summary>当此元素父级在可视化树中发生更改时进行了调用。 重写 <see cref="M:System.Windows.UIElement.OnVisualParentChanged(System.Windows.DependencyObject)" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 可视化树与从逻辑树可能不同，因为它会省略 （如集合），您可以看到，未呈现的元素，并且展开一些元素根据其主题和样式的组合。 有关详细信息，请参见 [WPF 中的树](~/docs/framework/wpf/advanced/trees-in-wpf.md)。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>此虚方法的默认实现的新父级中查询、 引发各种初始化事件，并将内部标志设置有关初始化状态的<see cref="T:System.Windows.FrameworkElement" />根据需要。 最后，它将调用所声明的连续的基实现<see cref="T:System.Windows.UIElement" />，这反过来调用其基类<see cref="T:System.Windows.Media.Visual" />。 始终调用基实现来保留此行为，否则此元素时声明为另一个元素的子元素的元素树行为可能不按预期方式。  
  
了几个现有[!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)]类重写此方法，例如： <see cref="M:System.Windows.Window.OnVisualParentChanged(System.Windows.DependencyObject)" />， <see cref="M:System.Windows.Controls.ListBoxItem.OnVisualParentChanged(System.Windows.DependencyObject)" />。 最常见的方案是强制执行新的父项必须是特定类型。 这样做可能会引发异常，如果新的父项无法通过某种方式类型测试。 此方案中的专用的版本的列表项和菜单项，这没有意义任何外部父 visual 拥有正确的集合来存储它们在实现中存在。 请注意，这种情况下不一定是引发异常，因为可能存在依赖于重新设置父级即暂时没有其"regular"的父级的元素的设计器方案。  
  
也通常是根元素，如某些元素中被重写此方法<see cref="T:System.Windows.Window" />。 另一种情况是在标记，但这是明显的根元素的元素自动生成已编译的逻辑树中的更高版本的基础结构 (如<see cref="T:System.Windows.Controls.Page" />)。 <see cref="T:System.Windows.Window" />和<see cref="T:System.Windows.Controls.Page" />实现特意密封此方法。</para>
        </block>
        <altmember cref="M:System.Windows.Media.Visual.OnVisualParentChanged(System.Windows.DependencyObject)" />
        <altmember cref="M:System.Windows.Window.OnVisualParentChanged(System.Windows.DependencyObject)" />
      </Docs>
    </Member>
    <Member MemberName="OverridesDefaultStyle">
      <MemberSignature Language="C#" Value="public bool OverridesDefaultStyle { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool OverridesDefaultStyle" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.OverridesDefaultStyle" />
      <MemberSignature Language="VB.NET" Value="Public Property OverridesDefaultStyle As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool OverridesDefaultStyle { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.OverridesDefaultStyle : bool with get, set" Usage="System.Windows.FrameworkElement.OverridesDefaultStyle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值指示此元素是否并入主题样式中的样式属性。</summary>
        <value>如果此元素不使用主题样式属性，则为 <see langword="true" />；所有源于样式的属性均来自本地应用程序样式，不会应用主题样式属性。 如果首先应用了应用程序样式，然后将主题样式应用于未在应用程序样式中专门设置的属性，则为 <see langword="false" />。 默认值为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此属性的最常见用法是间接提供主题样式的样式资源库中使用。  
  
> [!IMPORTANT]
>  如果您设置<xref:System.Windows.FrameworkElement.OverridesDefaultStyle%2A>到`true`上一个控件，则会禁用由主题样式提供的默认控件模板。 该控件模板通常包含内容表示器，并提供基本其他复合元素[!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)]功能和控件的视觉效果。 如果你想要继续支持默认主题样式与相同的功能的控件，您必须提供具有相同的结构将复制的控件模板替代样式。 有关详细信息，请参阅[控件创作概述](~/docs/framework/wpf/controls/control-authoring-overview.md)。  
  
<a name="dependencyPropertyInfo_OverridesDefaultStyle"></a>   
## <a name="dependency-property-information"></a>依赖项属性信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.FrameworkElement.OverridesDefaultStyleProperty>|  
|元数据属性设置为 `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OverridesDefaultStyleProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty OverridesDefaultStyleProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty OverridesDefaultStyleProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.OverridesDefaultStyleProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly OverridesDefaultStyleProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ OverridesDefaultStyleProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable OverridesDefaultStyleProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.OverridesDefaultStyleProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="P:System.Windows.FrameworkElement.OverridesDefaultStyle" /> 依赖项属性。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Parent">
      <MemberSignature Language="C#" Value="public System.Windows.DependencyObject Parent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.DependencyObject Parent" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.Parent" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Parent As DependencyObject" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::DependencyObject ^ Parent { System::Windows::DependencyObject ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Parent : System.Windows.DependencyObject" Usage="System.Windows.FrameworkElement.Parent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取此元素的逻辑父元素。</summary>
        <value>此元素的逻辑父级。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.FrameworkElement.Parent%2A> 可能是`null`情况下，元素已实例化，但未附加到任何最终将连接到的页级别的根元素或应用程序对象的逻辑树中。  
  
 请注意，具体取决于应用程序的功能，可能发生更改的元素的逻辑父级保留此属性的值将不反映所做的更改。 需要它之前，通常应获取的值。  
  
 请参阅[WPF 中的树](~/docs/framework/wpf/advanced/trees-in-wpf.md)逻辑树遍历，有关详细信息和方案使用<xref:System.Windows.FrameworkElement.Parent%2A>发现适合作为父元素的技术。  
  
 属性引擎将后可能重新计算所有属性值的元素父级，因为某些属性继承值到逻辑树。 <xref:System.Windows.FrameworkElement.DataContext%2A>适用于绑定可以还元素的父级更改。  
  
 更改元素的父级通常只能通过集合的操作，通过使用专用添加或删除方法，或通过设置内容属性的元素。  
  
 使用的最典型情形<xref:System.Windows.FrameworkElement.Parent%2A>属性将获取的引用，然后获取各种<xref:System.Windows.FrameworkElement>从父对象的属性值。 对于模板，<xref:System.Windows.FrameworkElement.Parent%2A>模板的最终将`null`。 若要忽略这一点并扩展到实际应用了模板的逻辑树，请使用<xref:System.Windows.FrameworkElement.TemplatedParent%2A>。  
  
 请注意，此属性不会报告用例从逻辑树父的变化位置中的可视化树父级。 可视化树父级不是常规应用程序的情况下通常很重要，但可能是某些可视化级别情况所需的父元素。 请参阅 <xref:System.Windows.Media.VisualTreeHelper>。  
  
   
  
## Examples  
 下面的示例显示了代码检查某个元素的父级，然后使用从父对象的属性值来设置要匹配的子元素的属性。 在这种情况下它们会影响呈现大小的属性。  
  
 [!code-csharp[GeometryDesigner#FEParentProperty](~/samples/snippets/csharp/VS_Snippets_Wpf/GeometryDesigner/CSharp/Window1.xaml.cs#feparentproperty)]
 [!code-vb[GeometryDesigner#FEParentProperty](~/samples/snippets/visualbasic/VS_Snippets_Wpf/GeometryDesigner/visualbasic/window1.xaml.vb#feparentproperty)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.FrameworkElement.TemplatedParent" />
        <altmember cref="T:System.Windows.LogicalTreeHelper" />
      </Docs>
    </Member>
    <Member MemberName="ParentLayoutInvalidated">
      <MemberSignature Language="C#" Value="protected internal virtual void ParentLayoutInvalidated (System.Windows.UIElement child);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void ParentLayoutInvalidated(class System.Windows.UIElement child) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.ParentLayoutInvalidated(System.Windows.UIElement)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub ParentLayoutInvalidated (child As UIElement)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void ParentLayoutInvalidated(System::Windows::UIElement ^ child);" />
      <MemberSignature Language="F#" Value="abstract member ParentLayoutInvalidated : System.Windows.UIElement -&gt; unit&#xA;override this.ParentLayoutInvalidated : System.Windows.UIElement -&gt; unit" Usage="frameworkElement.ParentLayoutInvalidated child" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="child" Type="System.Windows.UIElement" />
      </Parameters>
      <Docs>
        <param name="child">报告更改的子元素。</param>
        <summary>在 <see cref="T:System.Windows.FrameworkElement" /> 的专用子类中支持增量布局实现。 如果子元素包含无效属性，且该属性在元数据中标记为影响布局过程中父元素的测量或排列过程的因素，则调用 <see cref="M:System.Windows.FrameworkElement.ParentLayoutInvalidated(System.Windows.UIElement)" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果此元素具有子元素的某些属性已失效，并且该属性被标记为<xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A>或<xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A>在属性元数据在注册过程中，调用此方法。 方法调用将通知父元素的特定子元素必须是重新测量，如果此元素支持的布局部分 （增量） 更新。  
  
 默认情况下<xref:System.Windows.FrameworkElement>不支持增量布局，然后在<xref:System.Windows.FrameworkElement>这类方法具有默认实现。 将需要重写此方法的方案并不常用，因为它要求您修改默认布局系统行为。  
  
 示例实现方案可能是一个类包含明显比 WPF 框架级别的布局系统更严格的可能的子元素的类型限制。 由于这些自定义元素的特性，可能有意延迟属性更改时实现一些自定义布局行为。 例如，/排列度量值的方法重写，以优化的子元素的 try 呈现处理过程，可以延迟某些类型的更改通常会导致另一个布局处理过程。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PredictFocus">
      <MemberSignature Language="C#" Value="public override sealed System.Windows.DependencyObject PredictFocus (System.Windows.Input.FocusNavigationDirection direction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Windows.DependencyObject PredictFocus(valuetype System.Windows.Input.FocusNavigationDirection direction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.PredictFocus(System.Windows.Input.FocusNavigationDirection)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides NotOverridable Function PredictFocus (direction As FocusNavigationDirection) As DependencyObject" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Windows::DependencyObject ^ PredictFocus(System::Windows::Input::FocusNavigationDirection direction);" />
      <MemberSignature Language="F#" Value="override this.PredictFocus : System.Windows.Input.FocusNavigationDirection -&gt; System.Windows.DependencyObject" Usage="frameworkElement.PredictFocus direction" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="direction" Type="System.Windows.Input.FocusNavigationDirection" />
      </Parameters>
      <Docs>
        <param name="direction">应确定其预期焦点更改的方向。</param>
        <summary>根据提供的焦点移动方向，确定在此元素之后接收焦点的下一个元素，但不实际移动焦点。</summary>
        <returns>如果实际遍历了焦点，则为焦点将要移到的下一个元素。 如果焦点不能按提供的方向相对于此元素移动，则可能返回 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.FrameworkElement.MoveFocus%2A> 是实际移动焦点的相关的方法。  
  
   
  
## Examples  
 下面的示例实现的处理程序处理多个可能的按钮输入，表示一种可能的每个按钮<xref:System.Windows.Input.FocusNavigationDirection>。 处理程序将跟踪与当前的键盘焦点，并调用元素<xref:System.Windows.FrameworkElement.PredictFocus%2A>在该元素，并指定相应<xref:System.Windows.Input.FocusNavigationDirection>初始化为<xref:System.Windows.Input.TraversalRequest>类型提供的参数。 而不是移动到该元素作为<xref:System.Windows.FrameworkElement.MoveFocus%2A>一样，该处理程序更改可视化效果用于预测的焦点目标物理尺寸。  
  
 [!code-csharp[FocusSample#FEPredictFocus](~/samples/snippets/csharp/VS_Snippets_Wpf/FocusSample/CSharp/Window1.xaml.cs#fepredictfocus)]
 [!code-vb[FocusSample#FEPredictFocus](~/samples/snippets/visualbasic/VS_Snippets_Wpf/FocusSample/visualbasic/window1.xaml.vb#fepredictfocus)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">在 <see cref="T:System.Windows.Input.TraversalRequest" /> 中指定了以下方向之一：<see cref="F:System.Windows.Input.FocusNavigationDirection.Next" />、<see cref="F:System.Windows.Input.FocusNavigationDirection.Previous" />、<see cref="F:System.Windows.Input.FocusNavigationDirection.First" />、<see cref="F:System.Windows.Input.FocusNavigationDirection.Last" />。 对于 <see cref="M:System.Windows.FrameworkElement.PredictFocus(System.Windows.Input.FocusNavigationDirection)" /> 来说，这些方向是非法的（但对于 <see cref="M:System.Windows.FrameworkElement.MoveFocus(System.Windows.Input.TraversalRequest)" /> 来说是合法的）。</exception>
        <altmember cref="M:System.Windows.FrameworkElement.MoveFocus(System.Windows.Input.TraversalRequest)" />
        <altmember cref="M:System.Windows.UIElement.PredictFocus(System.Windows.Input.FocusNavigationDirection)" />
      </Docs>
    </Member>
    <Member MemberName="RegisterName">
      <MemberSignature Language="C#" Value="public void RegisterName (string name, object scopedElement);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterName(string name, object scopedElement) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.RegisterName(System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RegisterName (name As String, scopedElement As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterName(System::String ^ name, System::Object ^ scopedElement);" />
      <MemberSignature Language="F#" Value="member this.RegisterName : string * obj -&gt; unit" Usage="frameworkElement.RegisterName (name, scopedElement)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="scopedElement" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="name">要在指定的名称-对象映射中使用的名称。</param>
        <param name="scopedElement">映射的对象。</param>
        <summary>提供一个可简化对 <see cref="T:System.Windows.NameScope" /> 注册方法访问的访问器。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法是调用的便捷方法<xref:System.Windows.NameScope.RegisterName%2A>。 该实现将检查后续父元素，直到它找到的适用<xref:System.Windows.NameScope>实现，它可以通过查找的元素，实现<xref:System.Windows.Markup.INameScope>。 有关名称范围的详细信息，请参阅[WPF XAML 名称范围](~/docs/framework/wpf/advanced/wpf-xaml-namescopes.md)。  
  
 调用<xref:System.Windows.FrameworkElement.RegisterName%2A>为正确挂钩的应用程序时在代码中创建动画演示图板是必需的。 这是因为其中一个主要的演示图板属性<xref:System.Windows.Media.Animation.Storyboard.TargetName%2A>，使用运行时名称查找而不是要采用对目标元素的引用。 即使该元素是通过从代码引用可访问，这是如此。 为什么需要注册名称的情节提要目标的详细信息，请参阅[情节提要概述](~/docs/framework/wpf/graphics-multimedia/storyboards-overview.md)。  
  
   
  
## Examples  
 [!code-csharp[StoryboardBeginAnimation_procedural_snip#NameScopeExample](~/samples/snippets/csharp/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/CSharp/ScopeExample.cs#namescopeexample)]
 [!code-vb[StoryboardBeginAnimation_procedural_snip#NameScopeExample](~/samples/snippets/visualbasic/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/visualbasic/scopeexample.vb#namescopeexample)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.NameScope.RegisterName(System.String,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="RemoveLogicalChild">
      <MemberSignature Language="C#" Value="protected internal void RemoveLogicalChild (object child);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance void RemoveLogicalChild(object child) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.RemoveLogicalChild(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Sub RemoveLogicalChild (child As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; void RemoveLogicalChild(System::Object ^ child);" />
      <MemberSignature Language="F#" Value="member this.RemoveLogicalChild : obj -&gt; unit" Usage="frameworkElement.RemoveLogicalChild child" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="child" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="child">要移除的元素。</param>
        <summary>从此元素的逻辑树中删除所提供的对象。 <see cref="T:System.Windows.FrameworkElement" /> 将更新受影响的逻辑树父级指针，以便与此删除操作保持同步。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用此方法的实现的对象的表示逻辑子级的元素的集合。 这可以在属性 getter 或 setter，类处理程序的`Changed`事件、 构造函数，或在集合中的类型本身。  
  
 为控件创作者，操作逻辑树在此级别不是建议的做法，除非提供的基控件类的内容模型不适当。 子类化的级别，请考虑<xref:System.Windows.Controls.ContentControl>， <xref:System.Windows.Controls.ItemsControl>，和<xref:System.Windows.Controls.HeaderedItemsControl>。 这些类提供与特定强制通过专用的逻辑子级的内容模型[!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)]，以及对其他功能中通常所需的支持[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]如通过模板设置样式的控件。  
  
   
  
## Examples  
 下面的示例实现`Child`的自定义属性<xref:System.Windows.FrameworkElement>执行其自己的可视化层实现的。 该属性的设计，以便如果的值发生更改，从逻辑树中，以及特定于类的可视集合中删除旧值。 将缓存这些值，并随后将新值添加到标准 WPF 框架级别逻辑树和自定义可视化的集合。  
  
 [!code-csharp[CompositionTargetRenderingAnimations#AddRemoveLogicalChild](~/samples/snippets/csharp/VS_Snippets_Wpf/CompositionTargetRenderingAnimations/CSharp/ParticleEffectExamples/OverlayRenderDecorator.cs#addremovelogicalchild)]
 [!code-vb[CompositionTargetRenderingAnimations#AddRemoveLogicalChild](~/samples/snippets/visualbasic/VS_Snippets_Wpf/CompositionTargetRenderingAnimations/visualbasic/particleeffectexamples/overlayrenderdecorator.vb#addremovelogicalchild)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkElement.AddLogicalChild(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="RequestBringIntoView">
      <MemberSignature Language="C#" Value="public event System.Windows.RequestBringIntoViewEventHandler RequestBringIntoView;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.RequestBringIntoViewEventHandler RequestBringIntoView" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkElement.RequestBringIntoView" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event RequestBringIntoView As RequestBringIntoViewEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::RequestBringIntoViewEventHandler ^ RequestBringIntoView;" />
      <MemberSignature Language="F#" Value="member this.RequestBringIntoView : System.Windows.RequestBringIntoViewEventHandler " Usage="member this.RequestBringIntoView : System.Windows.RequestBringIntoViewEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RequestBringIntoViewEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当在此元素上调用 <see cref="M:System.Windows.FrameworkElement.BringIntoView(System.Windows.Rect)" /> 时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此事件表示为父<xref:System.Windows.Controls.ScrollViewer>（或派生类），该元素将引发<xref:System.Windows.FrameworkElement.RequestBringIntoView>事件应为可见的可滚动区域内。 <xref:System.Windows.Controls.ScrollViewer>然后会将标记<xref:System.Windows.FrameworkElement.RequestBringIntoView>为已处理，通过使用事件的类处理的事件。 一般情况下<xref:System.Windows.FrameworkElement.RequestBringIntoView>事件数据应不会标记为已处理通过控制滚动区域，任何类或任何实例处理程序，因为执行此操作将影响与名为的元素的预期目标<xref:System.Windows.FrameworkElement.BringIntoView%2A>。  
  
<a name="routedEventInfo_RequestBringIntoView"></a>   
## <a name="routed-event-information"></a>路由事件信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.FrameworkElement.RequestBringIntoViewEvent>|  
|路由策略|浮升|  
|委托|<xref:System.Windows.RequestBringIntoViewEventHandler>|  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkElement.BringIntoView(System.Windows.Rect)" />
        <altmember cref="T:System.Windows.Controls.ScrollViewer" />
      </Docs>
    </Member>
    <Member MemberName="RequestBringIntoViewEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent RequestBringIntoViewEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent RequestBringIntoViewEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.RequestBringIntoViewEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly RequestBringIntoViewEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ RequestBringIntoViewEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable RequestBringIntoViewEvent : System.Windows.RoutedEvent" Usage="System.Windows.FrameworkElement.RequestBringIntoViewEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="E:System.Windows.FrameworkElement.RequestBringIntoView" /> 路由事件。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Resources">
      <MemberSignature Language="C#" Value="public System.Windows.ResourceDictionary Resources { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.ResourceDictionary Resources" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.Resources" />
      <MemberSignature Language="VB.NET" Value="Public Property Resources As ResourceDictionary" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::ResourceDictionary ^ Resources { System::Windows::ResourceDictionary ^ get(); void set(System::Windows::ResourceDictionary ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Resources : System.Windows.ResourceDictionary with get, set" Usage="System.Windows.FrameworkElement.Resources" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.Markup.IHaveResources.Resources</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Windows.Markup.Ambient</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.ResourceDictionary</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置本地定义的资源字典。</summary>
        <value>资源中当前本地定义的字典，其中的每个资源均可通过键进行访问。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 可以完全或部分中定义的资源字典[!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)]通常创建为属性元素中，并且通常是针对任何单独的页面或应用程序的根元素上。 在此级别将资源字典可以更轻松地找到从页面中的各个子元素 （或从任何页上，在应用程序的情况下）。 在大多数应用程序方案中，我们建议样式定义为使用的资源字典中的对象元素或定义为外部资源中，以便整个样式资源可以是自包含 （此方法有助于单独设计器从开发人员的责任由分隔的物理文件，需要编辑职责）。  
  
 请注意，此属性返回该元素内直接声明仅的资源字典。 这是不同于实际资源查找过程，其中的子元素可以访问任何向上递归搜索每个父元素中定义的资源。  
  
 资源还可以通过从集合中的代码引用，但请注意在创建资源[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]绝对不可访问，直到<xref:System.Windows.FrameworkElement.Loaded>引起声明该字典的元素。 实际上，资源进行分析以异步方式和 not 甚至<xref:System.Windows.FrameworkElement.Loaded>事件是可以引用保障[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]定义资源。 出于此原因，通常只应访问[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]定义的资源作为的一部分运行时代码，或通过其他[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]技术，如样式或特性值的资源扩展引用。 当通过代码访问资源时，它在实质上是等效于从进行的引用[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]。  
  
 基础<xref:System.Windows.ResourceDictionary>支持添加、 删除或使用代码查询从集合中的资源所需的方法。 <xref:System.Windows.FrameworkElement.Resources%2A>属性是可以设置以支持此方案的完全替换的元素是一个新的或不同的资源集合<xref:System.Windows.ResourceDictionary>。  
  
 请注意，[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]所示的语法不包含的元素<xref:System.Windows.ResourceDictionary>。 这是隐式集合语法; 的示例表示集合元素的标记，则可以省略。 改为指定作为项目添加到集合的元素。 有关隐式集合的详细信息和[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]，请参阅[XAML 语法详述](~/docs/framework/wpf/advanced/xaml-syntax-in-detail.md)。 一种情况下，<xref:System.Windows.ResourceDictionary>元素是引入合并的字典，这种情况下是否存在通常没有子元素，如仍指定显式<xref:System.Windows.ResourceDictionary>。 有关详细信息，请参阅[合并资源字典](~/docs/framework/wpf/advanced/merged-resource-dictionaries.md)。  
  
<a name="xamlPropertyElementUsage_Resources"></a>   
## <a name="xaml-property-element-usage"></a>XAML 属性元素用法  
  
```  
<object>  
  <object.Resources>  
    oneOrMoreResourceElements  
  </object.Resources>  
</object>  
```  
  
<a name="xamlValues_Resources"></a>   
## <a name="xaml-values"></a>XAML 值  
 *oneOrMoreResourceElements*  
 一个或多个对象元素，其中每个定义的资源。 在每个每个资源属性元素<xref:System.Windows.ResourceDictionary>必须具有唯一值[X:key 指令](~/docs/framework/xaml-services/x-key-directive.md)，从检索值时，它可作为唯一键<xref:System.Windows.ResourceDictionary>。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Application.Resources" />
        <related type="Article" href="http://msdn.microsoft.com/library/1985cd45-f197-42d5-b75e-886add64b248">X:key 特性</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="SetBinding">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>为指定的依赖属性向此元素附加一个绑定。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetBinding">
      <MemberSignature Language="C#" Value="public System.Windows.Data.BindingExpression SetBinding (System.Windows.DependencyProperty dp, string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Data.BindingExpression SetBinding(class System.Windows.DependencyProperty dp, string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.SetBinding(System.Windows.DependencyProperty,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function SetBinding (dp As DependencyProperty, path As String) As BindingExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Data::BindingExpression ^ SetBinding(System::Windows::DependencyProperty ^ dp, System::String ^ path);" />
      <MemberSignature Language="F#" Value="member this.SetBinding : System.Windows.DependencyProperty * string -&gt; System.Windows.Data.BindingExpression" Usage="frameworkElement.SetBinding (dp, path)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Data.BindingExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="dp">标识应该建立绑定的目标属性。</param>
        <param name="path">源属性名称或用于绑定的属性的路径。</param>
        <summary>将提供的源属性名作为数据源的路径限定，从而将绑定附加到此元素上。</summary>
        <returns>记录绑定的条件。 此返回值可用于错误检查。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法是调用的便捷方法<xref:System.Windows.Data.BindingOperations.SetBinding%2A?displayProperty=nameWithType>，其中将当前实例作为传递<xref:System.Windows.DependencyObject>，并创建一个新<xref:System.Windows.Data.Binding>基于所提供`path`参数。 此签名是更方便，如果您要建立一个简单的默认绑定。 如果你需要指定任何绑定属性为非默认条件，或者想要使用<xref:System.Windows.Data.MultiBinding>或<xref:System.Windows.Data.PriorityBinding>，则应使用<xref:System.Windows.FrameworkElement.SetBinding%28System.Windows.DependencyProperty%2CSystem.Windows.Data.BindingBase%29>签名。  
  
   
  
## Examples  
 下面的示例设置使用特定路径的绑定。  
  
 [!code-csharp[BaseElementsSmorgasbord#SetBindingPath](~/samples/snippets/csharp/VS_Snippets_Wpf/BaseElementsSmorgasbord/CSharp/Page1.xaml.cs#setbindingpath)]
 [!code-vb[BaseElementsSmorgasbord#SetBindingPath](~/samples/snippets/visualbasic/VS_Snippets_Wpf/BaseElementsSmorgasbord/visualbasic/page1.xaml.vb#setbindingpath)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetBinding">
      <MemberSignature Language="C#" Value="public System.Windows.Data.BindingExpressionBase SetBinding (System.Windows.DependencyProperty dp, System.Windows.Data.BindingBase binding);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Data.BindingExpressionBase SetBinding(class System.Windows.DependencyProperty dp, class System.Windows.Data.BindingBase binding) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.SetBinding(System.Windows.DependencyProperty,System.Windows.Data.BindingBase)" />
      <MemberSignature Language="VB.NET" Value="Public Function SetBinding (dp As DependencyProperty, binding As BindingBase) As BindingExpressionBase" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Data::BindingExpressionBase ^ SetBinding(System::Windows::DependencyProperty ^ dp, System::Windows::Data::BindingBase ^ binding);" />
      <MemberSignature Language="F#" Value="member this.SetBinding : System.Windows.DependencyProperty * System.Windows.Data.BindingBase -&gt; System.Windows.Data.BindingExpressionBase" Usage="frameworkElement.SetBinding (dp, binding)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Data.BindingExpressionBase</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="binding" Type="System.Windows.Data.BindingBase" />
      </Parameters>
      <Docs>
        <param name="dp">标识应在其中建立绑定的属性。</param>
        <param name="binding">表示数据绑定的详细信息。</param>
        <summary>基于已提供的绑定对象将一个绑定附加到此元素上。</summary>
        <returns>记录绑定的条件。 此返回值可用于错误检查。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法是调用的便捷方法<xref:System.Windows.Data.BindingOperations.SetBinding%2A?displayProperty=nameWithType>，其中将当前实例作为传递<xref:System.Windows.DependencyObject>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetFlowDirection">
      <MemberSignature Language="C#" Value="public static void SetFlowDirection (System.Windows.DependencyObject element, System.Windows.FlowDirection value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetFlowDirection(class System.Windows.DependencyObject element, valuetype System.Windows.FlowDirection value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.SetFlowDirection(System.Windows.DependencyObject,System.Windows.FlowDirection)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetFlowDirection (element As DependencyObject, value As FlowDirection)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetFlowDirection(System::Windows::DependencyObject ^ element, System::Windows::FlowDirection value);" />
      <MemberSignature Language="F#" Value="static member SetFlowDirection : System.Windows.DependencyObject * System.Windows.FlowDirection -&gt; unit" Usage="System.Windows.FrameworkElement.SetFlowDirection (element, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="value" Type="System.Windows.FlowDirection" />
      </Parameters>
      <Docs>
        <param name="element">指定流方向的元素。</param>
        <param name="value">一个枚举值，用于指定方向。</param>
        <summary>设置所提供元素的 <see cref="P:System.Windows.FrameworkElement.FlowDirection" /> 附加属性的值。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法支持的附加的属性语法<xref:System.Windows.FrameworkElement.FlowDirection%2A>属性，从而使子元素的提供<xref:System.Windows.FrameworkElement>来指定在其父元素的排列方式的流动方向。 若要将值设置对当前<xref:System.Windows.FrameworkElement>，使用 direct[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]访问器<xref:System.Windows.FrameworkElement.FlowDirection%2A>。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.FrameworkElement.FlowDirection" />
      </Docs>
    </Member>
    <Member MemberName="SetResourceReference">
      <MemberSignature Language="C#" Value="public void SetResourceReference (System.Windows.DependencyProperty dp, object name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetResourceReference(class System.Windows.DependencyProperty dp, object name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.SetResourceReference(System.Windows.DependencyProperty,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetResourceReference (dp As DependencyProperty, name As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetResourceReference(System::Windows::DependencyProperty ^ dp, System::Object ^ name);" />
      <MemberSignature Language="F#" Value="member this.SetResourceReference : System.Windows.DependencyProperty * obj -&gt; unit" Usage="frameworkElement.SetResourceReference (dp, name)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="name" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="dp">资源绑定到的属性。</param>
        <param name="name">资源的名称。</param>
        <summary>搜索具有指定名称的资源，并且为指定的属性设置一个指向该资源的资源引用。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 资源引用是类似于使用[DynamicResource 标记扩展](~/docs/framework/wpf/advanced/dynamicresource-markup-extension.md)标记中。 资源引用创建一个内部表达式，用于提供在运行时的延迟基础上的指定属性的值。 将重新计算表达式时资源字典指示更改的值通过内部事件，或者每当重新设定当前元素 （父级更改会更改字典查找路径）。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkElement.FindResource(System.Object)" />
        <altmember cref="P:System.Windows.Application.Resources" />
        <altmember cref="P:System.Windows.FrameworkElement.Resources" />
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeResources">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeResources ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeResources() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.ShouldSerializeResources" />
      <MemberSignature Language="VB.NET" Value="Public Function ShouldSerializeResources () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ShouldSerializeResources();" />
      <MemberSignature Language="F#" Value="member this.ShouldSerializeResources : unit -&gt; bool" Usage="frameworkElement.ShouldSerializeResources " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回一个值，该值指示序列化过程是否应该序列化 <see cref="P:System.Windows.FrameworkElement.Resources" /> 属性的内容。</summary>
        <returns>如果应当序列化 <see cref="P:System.Windows.FrameworkElement.Resources" /> 属性值，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 这将返回`true`只要本地没有至少一个键控的资源<xref:System.Windows.FrameworkElement.Resources%2A>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeStyle">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeStyle ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeStyle() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.ShouldSerializeStyle" />
      <MemberSignature Language="VB.NET" Value="Public Function ShouldSerializeStyle () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ShouldSerializeStyle();" />
      <MemberSignature Language="F#" Value="member this.ShouldSerializeStyle : unit -&gt; bool" Usage="frameworkElement.ShouldSerializeStyle " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回一个值，该值指示序列化过程是否应该序列化 <see cref="P:System.Windows.FrameworkElement.Style" /> 属性的内容。</summary>
        <returns>如果应当序列化 <see cref="P:System.Windows.FrameworkElement.Style" /> 属性值，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 这将返回`true`如果<xref:System.Windows.Style>本地设置。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeTriggers">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeTriggers ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeTriggers() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.ShouldSerializeTriggers" />
      <MemberSignature Language="VB.NET" Value="Public Function ShouldSerializeTriggers () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ShouldSerializeTriggers();" />
      <MemberSignature Language="F#" Value="member this.ShouldSerializeTriggers : unit -&gt; bool" Usage="frameworkElement.ShouldSerializeTriggers " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回一个值，该值指示序列化过程是否应该序列化 <see cref="P:System.Windows.FrameworkElement.Triggers" /> 属性的内容。</summary>
        <returns>如果应当序列化 <see cref="P:System.Windows.FrameworkElement.Triggers" /> 属性值，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法返回`true`如果<xref:System.Windows.FrameworkElement.Triggers%2A>本地设置属性。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SizeChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.SizeChangedEventHandler SizeChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.SizeChangedEventHandler SizeChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkElement.SizeChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event SizeChanged As SizeChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::SizeChangedEventHandler ^ SizeChanged;" />
      <MemberSignature Language="F#" Value="member this.SizeChanged : System.Windows.SizeChangedEventHandler " Usage="member this.SizeChanged : System.Windows.SizeChangedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.SizeChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当此元素上的 <see cref="P:System.Windows.FrameworkElement.ActualHeight" /> 或 <see cref="P:System.Windows.FrameworkElement.ActualWidth" /> 属性的值发生更改时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 直接路由的事件不遵循路由，而仅处理引发它们在同一元素中。 直接路由的事件支持其他路由的事件行为： 它们支持的可访问的处理程序集合，并可用作<xref:System.Windows.EventTrigger>样式中。  
  
 布局系统中读取属性中的<xref:System.Windows.SizeChangedEventArgs>此事件，以确定是否应视为报告的大小更改重要的自变量类。 这允许布局系统或应用特定于控件的布局实现不会强制执行布局更改以可视方式无法觉察旧的和新的高度或宽度值之间的差异。 感觉不差异可能是由于舍入或相同的结果计算的浮点数据类型。  
  
<a name="routedEventInfo_SizeChanged"></a>   
## <a name="routed-event-information"></a>路由事件信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.FrameworkElement.SizeChangedEvent>|  
|路由策略|直接|  
|委托|<xref:System.Windows.SizeChangedEventHandler>|  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.FrameworkElement.Height" />
        <altmember cref="P:System.Windows.FrameworkElement.Width" />
      </Docs>
    </Member>
    <Member MemberName="SizeChangedEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent SizeChangedEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent SizeChangedEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.SizeChangedEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly SizeChangedEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ SizeChangedEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable SizeChangedEvent : System.Windows.RoutedEvent" Usage="System.Windows.FrameworkElement.SizeChangedEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="E:System.Windows.FrameworkElement.SizeChanged" /> 路由事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在注册路由事件时创建路由事件标识符。 这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。 可以使用这些标识符添加类处理程序。  
  
 有关注册路由事件的更多信息，请参见 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。 有关使用路由事件标识符添加类处理程序的更多信息，请参见 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SourceUpdated">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt; SourceUpdated;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Data.DataTransferEventArgs&gt; SourceUpdated" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkElement.SourceUpdated" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event SourceUpdated As EventHandler(Of DataTransferEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Windows::Data::DataTransferEventArgs ^&gt; ^ SourceUpdated;" />
      <MemberSignature Language="F#" Value="member this.SourceUpdated : EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt; " Usage="member this.SourceUpdated : System.EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当此元素上的任何现有属性绑定的源值发生更改时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此事件创建一个别名<xref:System.Windows.Data.Binding.SourceUpdated>引发的任何事件<xref:System.Windows.Data.Binding>与此元素关联。  
  
<a name="xamlAttributeUsage_SourceUpdated"></a>   
## <a name="xaml-attribute-usage"></a>XAML 属性用法  
  
```  
<object SourceUpdated="eventHandler"/>  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Data.Binding.SourceUpdated" />
      </Docs>
    </Member>
    <Member MemberName="Style">
      <MemberSignature Language="C#" Value="public System.Windows.Style Style { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Style Style" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.Style" />
      <MemberSignature Language="VB.NET" Value="Public Property Style As Style" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Style ^ Style { System::Windows::Style ^ get(); void set(System::Windows::Style ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Style : System.Windows.Style with get, set" Usage="System.Windows.FrameworkElement.Style" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Style</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置此元素呈现时所使用的样式。</summary>
        <value>若存在，则为此元素适用的非默认样式。 否则为 <see langword="null" />。 默认情况下构造的 <see cref="T:System.Windows.FrameworkElement" /> 的默认值为 <see langword="null" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 对于控件，当前样式通常提供的控件主题中的默认样式或样式中通常应用于该类型的控件在页面或应用程序级别 （隐式样式） 的资源。 此属性不会设置或返回默认 （主题） 样式，但它确实会隐式样式或显式样式的元素上起作用。 如果存在隐式或显式样式，并不重要是指定为资源，还是本地定义的样式。  
  
 设置样式存在一些限制。 你可以重置整个<xref:System.Windows.FrameworkElement.Style%2A>属性设置为一个新<xref:System.Windows.Style>在任何时候，这将强制布局重新组合。 但是，一旦加载的元素，该样式放置在使用<xref:System.Windows.Style>应被视为密封。 尝试对正在使用样式的任何单个属性进行更改 (如的在集合中的任何内容<xref:System.Windows.Style.Setters%2A>) 会导致引发异常。 在标记中定义的样式被视为一旦加载从资源字典 （适用于资源），或包含在页面加载 （适用于内联样式），可使用。  
  
 <xref:System.Windows.FrameworkElement.Style%2A> 是具有特殊的优先顺序的依赖项属性。 本地设置样式通常在进行操作的最高优先级属性系统中。 如果<xref:System.Windows.FrameworkElement.Style%2A>属性系统检查隐式样式中指定该类型的本地或应用程序资源加载期间在此情况下，为 null。 如果样式是完成此步骤后仍然为 null 则出于演示目的的有效样式通常来自默认 （主题） 样式，但默认样式中不会返回<xref:System.Windows.FrameworkElement.Style%2A>属性值。 请参阅[依赖属性值优先级](~/docs/framework/wpf/advanced/dependency-property-value-precedence.md)或[样式和模板化](~/docs/framework/wpf/controls/styling-and-templating.md)。  
  
<a name="xamlAttributeUsage_Style"></a>   
## <a name="xaml-attribute-usage"></a>XAML 属性用法  
  
```  
<object Style="{resourceExtension styleResourceKey}"/>  
```  
  
<a name="xamlPropertyElementUsage_Style"></a>   
## <a name="xaml-property-element-usage"></a>XAML 属性元素用法  
  
<a name="xamlValues_Style"></a>   
## <a name="xaml-values"></a>XAML 值  
 *resourceExtension*  
 以下项之一:、 或。 请参阅[XAML 资源](~/docs/framework/wpf/advanced/xaml-resources.md)。  
  
 *styleResourceKey*  
 标识所请求的样式的键。 键引用中的现有资源<xref:System.Windows.ResourceDictionary>。  
  
> [!NOTE]
>  属性元素语法就从技术上讲，但大多数样式的情况下不建议这样做。 请参阅[内联样式和模板](~/docs/framework/wpf/advanced/inline-styles-and-templates.md)。 绑定引用使用或<xref:System.Windows.Data.Binding>也是可行的但不常见。  
  
<a name="dependencyPropertyInfo_Style"></a>   
## <a name="dependency-property-information"></a>依赖项属性信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.FrameworkElement.StyleProperty>|  
|元数据属性设置为 `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
   
  
## Examples  
 下面的示例在资源字典中定义的样式。  
  
 [!code-xaml[FEResource#StyleProperty](~/samples/snippets/csharp/VS_Snippets_Wpf/FEResource/CS/default.xaml#styleproperty)]  
[!code-xaml[FEResource#StyleProperty2](~/samples/snippets/csharp/VS_Snippets_Wpf/FEResource/CS/default.xaml#styleproperty2)]  
[!code-xaml[FEResource#StyleProperty3](~/samples/snippets/csharp/VS_Snippets_Wpf/FEResource/CS/default.xaml#styleproperty3)]  
[!code-xaml[FEResource#StyleProperty4](~/samples/snippets/csharp/VS_Snippets_Wpf/FEResource/CS/default.xaml#styleproperty4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StyleProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty StyleProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty StyleProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.StyleProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly StyleProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ StyleProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable StyleProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.StyleProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="P:System.Windows.FrameworkElement.Style" /> 依赖项属性。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable">
      <MemberSignature Language="C#" Value="bool IQueryAmbient.IsAmbientPropertyAvailable (string propertyName);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(string propertyName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.System#Windows#Markup#IQueryAmbient#IsAmbientPropertyAvailable(System.String)" />
      <MemberSignature Language="VB.NET" Value="Function IsAmbientPropertyAvailable (propertyName As String) As Boolean Implements IQueryAmbient.IsAmbientPropertyAvailable" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(System::String ^ propertyName) = System::Windows::Markup::IQueryAmbient::IsAmbientPropertyAvailable;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="propertyName">请求的环境属性的名称。</param>
        <summary>有关此成员的说明，请参见 <see cref="M:System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(System.String)" /> 方法。</summary>
        <returns>如果 <paramref name="propertyName" /> 可用，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此成员是显式的接口成员实现。 它只能在 <xref:System.Windows.FrameworkElement> 实例强制转换为 <xref:System.Windows.Markup.IQueryAmbient> 接口时使用。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Tag">
      <MemberSignature Language="C#" Value="public object Tag { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Tag" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.Tag" />
      <MemberSignature Language="VB.NET" Value="Public Property Tag As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ Tag { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Tag : obj with get, set" Usage="System.Windows.FrameworkElement.Tag" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.NeverLocalize)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置任意对象值，该值可用于存储关于此元素的自定义信息。</summary>
        <value>预期值。 此属性没有默认值。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此属性是类似于其他 Microsoft 编程模型，如 Visual Basic 应用程序或 Windows 窗体中的标记属性。 <xref:System.Windows.FrameworkElement.Tag%2A> 用于提供可以在其中存储有关任何一些基本的自定义信息的预先存在的属性位置<xref:System.Windows.FrameworkElement>而无需你为子类元素。  
  
 由于此属性需要一个对象，需要设置以便使用属性元素用法<xref:System.Windows.FrameworkElement.Tag%2A>在 XAML 中为具有已知和内置类型转换器，如字符串的对象以外的任何属性。 以这种方式使用对象通常不是标准的 WPF 命名空间内，因此可能需要将命名空间映射到外部命名空间，以便作为 XAML 元素引入。 有关详细信息，请参阅[XAML 命名空间和 Namespace 映射 WPF XAML](~/docs/framework/wpf/advanced/xaml-namespaces-and-namespace-mapping-for-wpf-xaml.md)并[XAML 及 WPF 的自定义类](~/docs/framework/wpf/advanced/xaml-and-custom-classes-for-wpf.md)。  
  
<a name="dependencyPropertyInfo_Tag"></a>   
## <a name="dependency-property-information"></a>依赖项属性信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.FrameworkElement.TagProperty>|  
|元数据属性设置为 `true`|无|  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.FrameworkElement.Name" />
      </Docs>
    </Member>
    <Member MemberName="TagProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty TagProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty TagProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.TagProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TagProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ TagProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable TagProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.TagProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="P:System.Windows.FrameworkElement.Tag" /> 依赖项属性。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TargetUpdated">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt; TargetUpdated;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Data.DataTransferEventArgs&gt; TargetUpdated" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkElement.TargetUpdated" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event TargetUpdated As EventHandler(Of DataTransferEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Windows::Data::DataTransferEventArgs ^&gt; ^ TargetUpdated;" />
      <MemberSignature Language="F#" Value="member this.TargetUpdated : EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt; " Usage="member this.TargetUpdated : System.EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当此元素上的任何属性绑定的目标值发生更改时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此事件创建一个别名<xref:System.Windows.Data.Binding.TargetUpdated>引发的任何事件<xref:System.Windows.Data.Binding>与此元素关联。 这通常意味着，所讨论的绑定是双向绑定，且它的绑定的依赖属性将确定的是现在根据任何验证或属性或数据源所支持的缓存方案无效以前的属性值。  
  
 使用事件数据的<xref:System.Windows.FrameworkElement.TargetUpdated>事件以确定报告的目标值更新的特定属性。  
  
<a name="xamlAttributeUsage_TargetUpdated"></a>   
## <a name="xaml-attribute-usage"></a>XAML 属性用法  
  
```  
<object TargetUpdated="eventHandler"/>  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Data.Binding.TargetUpdated" />
      </Docs>
    </Member>
    <Member MemberName="TemplatedParent">
      <MemberSignature Language="C#" Value="public System.Windows.DependencyObject TemplatedParent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.DependencyObject TemplatedParent" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.TemplatedParent" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TemplatedParent As DependencyObject" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::DependencyObject ^ TemplatedParent { System::Windows::DependencyObject ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.TemplatedParent : System.Windows.DependencyObject" Usage="System.Windows.FrameworkElement.TemplatedParent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取对此元素的模板父级的引用。 如果该元素不是通过模板创建的，则此属性无关。</summary>
        <value>元素的<see cref="T:System.Windows.FrameworkTemplate" /><see cref="P:System.Windows.FrameworkTemplate.VisualTree" />导致要创建此元素。 此值通常为<see langword="null" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.FrameworkElement.TemplatedParent%2A> 通常是`null`在你的应用程序标记或代码中创建的对象。 这是因为你创建这些对象直接，无需通过一个模板。 对象引用获得通过遍历逻辑树从根路径，或通过典型的名称的引用，不是来自模板。  
  
 事例<xref:System.Windows.FrameworkElement.TemplatedParent%2A>可能不是`null`包括命中测试遍历可视化树与某些低级别输入事件的事件处理等操作<xref:System.Windows.Media.VisualTreeHelper>，或使用的枚举器，这可能会返回提供的元素从模板。 另一种情况是如果明确调用<xref:System.Windows.FrameworkTemplate.FindName%2A>针对现有<xref:System.Windows.FrameworkTemplate>并且使用返回的对象。  
  
 模板实际上是共享的对象，其中只有一次创建模板的内容。 因此，如果您获得来自模板的元素的对象引用，可能会发现明显的逻辑树不会访问到页面根。 若要连接到该页面的逻辑树这样的模板引用，应会看到<xref:System.Windows.FrameworkElement.TemplatedParent%2A>值并继续根据需要该元素树中导航。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToolTip">
      <MemberSignature Language="C#" Value="public object ToolTip { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object ToolTip" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.ToolTip" />
      <MemberSignature Language="VB.NET" Value="Public Property ToolTip As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ ToolTip { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ToolTip : obj with get, set" Usage="System.Windows.FrameworkElement.ToolTip" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Bindable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Category("Appearance")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.ToolTip)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置在[!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)] 中为此元素显示的工具提示对象。</summary>
        <value>工具提示对象。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果此属性的值属于类型<xref:System.Windows.Controls.ToolTip>，，则该值是将在中使用工具提示[!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)]。  如果值为任何其他类型，则该值将用作*内容*为<xref:System.Windows.Controls.ToolTip>提供系统 （构造）。 有关详情，请参阅<xref:System.Windows.Controls.ToolTipService>。 服务类提供了可用于进一步自定义的附加的属性<xref:System.Windows.Controls.ToolTip>。  
  
<a name="xamlAttributeUsage_ToolTip"></a>   
## <a name="xaml-attribute-usage"></a>XAML 属性用法  
  
```  
<object ToolTip="toolTipContent"/>  
```  
  
<a name="xamlPropertyElementUsage_ToolTip"></a>   
## <a name="xaml-property-element-usage"></a>XAML 属性元素用法  
  
```  
<object>  
  <object.ToolTip>  
    <ToolTip .../>  
  </object.ToolTip>  
</object>  
- or -  
<object>  
  <object.ToolTip>  
    toolTipObjectContent  
  </object.ToolTip>  
</object>  
```  
  
<a name="xamlValues_ToolTip"></a>   
## <a name="xaml-values"></a>XAML 值  
 *toolTipContent*  
 将成为显示的文本的字符串<xref:System.Windows.FrameworkElement.ToolTip%2A>。  
  
 *toolTipObjectContent*  
 对象元素窗体，应使用的内容作为中提供某些对象<xref:System.Windows.FrameworkElement>。 通常，这是<xref:System.Windows.FrameworkElement>或创建布局的组合的情况下的某些其他元素<xref:System.Windows.FrameworkElement.ToolTip%2A>，最终包含在该组合中的文本内容。 在此使用情况<xref:System.Windows.Controls.ToolTip>元素创建隐式地从已分析[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]，并*经过*内容设置为其<xref:System.Windows.Controls.ContentControl.Content%2A?displayProperty=nameWithType>属性。  
  
 <`ToolTip` .../>  
 请参阅 <xref:System.Windows.Controls.ToolTip>。  
  
<a name="dependencyPropertyInfo_ToolTip"></a>   
## <a name="dependency-property-information"></a>依赖项属性信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.FrameworkElement.ToolTipProperty>|  
|元数据属性设置为 `true`|无|  
  
   
  
## Examples  
 下面的示例创建<xref:System.Windows.Controls.ToolTip>中的代码，然后设置<xref:System.Windows.FrameworkElement.ToolTip%2A>属性上的<xref:System.Windows.Controls.Primitives.StatusBar>控件。  
  
 [!code-csharp[StatusBar#MakeProgressBar](~/samples/snippets/csharp/VS_Snippets_Wpf/StatusBar/CSharp/Window1.xaml.cs#makeprogressbar)]
 [!code-vb[StatusBar#MakeProgressBar](~/samples/snippets/visualbasic/VS_Snippets_Wpf/StatusBar/visualbasic/window1.xaml.vb#makeprogressbar)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToolTipClosing">
      <MemberSignature Language="C#" Value="public event System.Windows.Controls.ToolTipEventHandler ToolTipClosing;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Controls.ToolTipEventHandler ToolTipClosing" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkElement.ToolTipClosing" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ToolTipClosing As ToolTipEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Controls::ToolTipEventHandler ^ ToolTipClosing;" />
      <MemberSignature Language="F#" Value="member this.ToolTipClosing : System.Windows.Controls.ToolTipEventHandler " Usage="member this.ToolTipClosing : System.Windows.Controls.ToolTipEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.ToolTipEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在元素上的任何工具提示关闭之前发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 将标记<xref:System.Windows.FrameworkElement.ToolTipClosing>为已处理的事件不会取消关闭工具提示。 工具提示显示后，关闭工具提示仅在响应用户与 UI 交互完成。  
  
 此事件不能为<xref:System.Windows.EventTrigger>样式中。 这是因为此事件的标识符字段重新使用从服务不公开的服务级别事件的添加/删除事件方法的实现。  
  
<a name="routedEventInfo_ToolTipClosing"></a>   
## <a name="routed-event-information"></a>路由事件信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.FrameworkElement.ToolTipClosingEvent>|  
|路由策略|直接|  
|委托|<xref:System.Windows.Controls.ToolTipEventHandler>|  
  
-   重写<xref:System.Windows.FrameworkElement.OnToolTipClosing%2A>实现类处理此事件在派生类中。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.ToolTip" />
      </Docs>
    </Member>
    <Member MemberName="ToolTipClosingEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent ToolTipClosingEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent ToolTipClosingEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.ToolTipClosingEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ToolTipClosingEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ ToolTipClosingEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable ToolTipClosingEvent : System.Windows.RoutedEvent" Usage="System.Windows.FrameworkElement.ToolTipClosingEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="E:System.Windows.FrameworkElement.ToolTipClosing" /> 路由事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在注册路由事件时创建路由事件标识符。 这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。 可以使用这些标识符添加类处理程序。  
  
 有关注册路由事件的更多信息，请参见 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。 有关使用路由事件标识符添加类处理程序的更多信息，请参见 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToolTipOpening">
      <MemberSignature Language="C#" Value="public event System.Windows.Controls.ToolTipEventHandler ToolTipOpening;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Controls.ToolTipEventHandler ToolTipOpening" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkElement.ToolTipOpening" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ToolTipOpening As ToolTipEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Controls::ToolTipEventHandler ^ ToolTipOpening;" />
      <MemberSignature Language="F#" Value="member this.ToolTipOpening : System.Windows.Controls.ToolTipEventHandler " Usage="member this.ToolTipOpening : System.Windows.Controls.ToolTipEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.ToolTipEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在元素上的任何工具提示打开时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要防止出现在 UI 中，您的处理程序的工具提示<xref:System.Windows.FrameworkElement.ToolTipOpening>可以将标记<xref:System.Windows.Controls.ToolTipEventArgs>所处理的事件数据。 否则，显示工具提示，使用的值<xref:System.Windows.FrameworkElement.ToolTip%2A>作为工具提示内容的属性。 另一种情形是，可以编写的处理程序的值重置<xref:System.Windows.FrameworkElement.ToolTip%2A>是事件源，将显示工具提示之前的元素的属性。  
  
 <xref:System.Windows.FrameworkElement.ToolTipOpening> 如果将不会引发的值<xref:System.Windows.FrameworkElement.ToolTip%2A>是`null`或其他取消设置。 不要特意设置<xref:System.Windows.FrameworkElement.ToolTip%2A>到`null`工具提示处于打开状态，或打开; 这不会关闭工具提示的效果，并改为将在 UI 中创建不需要的可视化项目时。  
  
 <xref:System.Windows.FrameworkElement.ToolTipOpening>事件不能为<xref:System.Windows.EventTrigger>样式中。 这是因为此事件的标识符字段重新使用从服务不公开的服务级别事件的添加/删除事件方法的实现。  
  
<a name="routedEventInfo_ToolTipOpening"></a>   
## <a name="routed-event-information"></a>路由事件信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.FrameworkElement.ToolTipOpeningEvent>|  
|路由策略|直接|  
|委托|<xref:System.Windows.Controls.ToolTipEventHandler>|  
  
-   重写<xref:System.Windows.FrameworkElement.OnToolTipClosing%2A>实现类处理此事件在派生类中。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.ToolTip" />
      </Docs>
    </Member>
    <Member MemberName="ToolTipOpeningEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent ToolTipOpeningEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent ToolTipOpeningEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.ToolTipOpeningEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ToolTipOpeningEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ ToolTipOpeningEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable ToolTipOpeningEvent : System.Windows.RoutedEvent" Usage="System.Windows.FrameworkElement.ToolTipOpeningEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="E:System.Windows.FrameworkElement.ToolTipOpening" /> 路由事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在注册路由事件时创建路由事件标识符。 这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。 可以使用这些标识符添加类处理程序。  
  
 有关注册路由事件的更多信息，请参见 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。 有关使用路由事件标识符添加类处理程序的更多信息，请参见 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToolTipProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ToolTipProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ToolTipProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.ToolTipProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ToolTipProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ToolTipProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable ToolTipProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.ToolTipProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="P:System.Windows.FrameworkElement.ToolTip" /> 依赖项属性。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Triggers">
      <MemberSignature Language="C#" Value="public System.Windows.TriggerCollection Triggers { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.TriggerCollection Triggers" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.Triggers" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Triggers As TriggerCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::TriggerCollection ^ Triggers { System::Windows::TriggerCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Triggers : System.Windows.TriggerCollection" Usage="System.Windows.FrameworkElement.Triggers" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Content)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.TriggerCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取直接在此元素上或在子元素中建立的触发器的集合。</summary>
        <value>一个强类型的 <see cref="T:System.Windows.Trigger" /> 对象集合。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  此属性只能设置[!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)]通过集合语法所示，或通过访问的集合对象并使用它的各种方法，例如 Add。 要访问的集合对象本身的属性是只读的集合本身是可读写。 属性仅存在于根元素;尝试查找它或将其设置其他位置将导致引发异常。  
  
 此属性不会启用你能够检查作为中此元素上使用的样式的一部分存在的触发器。 它只报告按原义添加到集合中，在标记或代码中的触发器的集合。 元素通常没有现有的默认情况下此类元素 (通过模板实例);很多常见的来自控件组合建立在样式中的触发器。  
  
 在行为方面 (以及尝试确定哪个效果来自哪个元素的声明<xref:System.Windows.FrameworkElement.Triggers%2A>集合)，触发条件和触发器效果可能位于此元素，或者可能对其逻辑树中的子元素。 请注意，如果您使用生存期事件如<xref:System.Windows.FrameworkElement.Loaded>若要获取此集合，子元素的触发器可能无法完全加载，并且该集合将为小于在运行时将真正。  
  
 请注意，在元素上建立的触发器的集合仅支持<xref:System.Windows.EventTrigger>，不包含属性触发器 (<xref:System.Windows.Trigger>)。 如果需要属性触发器，必须将这些样式或模板中，然后将指定该样式或模板的元素可以直接通过<xref:System.Windows.FrameworkElement.Style%2A>属性，或通过隐式样式引用间接。  
  
<a name="xamlPropertyElementUsage_Triggers"></a>   
## <a name="xaml-property-element-usage"></a>XAML 属性元素用法  
  
```  
<object>  
  <object.Triggers>  
    oneOrMoreTriggers  
  </object.Triggers>  
</object>  
```  
  
<a name="xamlValues_Triggers"></a>   
## <a name="xaml-values"></a>XAML 值  
 *oneOrMoreTriggers*  
 一个或多个定义<xref:System.Windows.EventTrigger>元素。 每个此类触发器应包含有效的情节提要操作和引用。 请注意，此集合可以只建立一个页面的根元素上。 有关详细信息，请参阅[情节提要概述](~/docs/framework/wpf/graphics-multimedia/storyboards-overview.md)。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.EventTrigger" />
      </Docs>
    </Member>
    <Member MemberName="TryFindResource">
      <MemberSignature Language="C#" Value="public object TryFindResource (object resourceKey);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object TryFindResource(object resourceKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.TryFindResource(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryFindResource (resourceKey As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ TryFindResource(System::Object ^ resourceKey);" />
      <MemberSignature Language="F#" Value="member this.TryFindResource : obj -&gt; obj" Usage="frameworkElement.TryFindResource resourceKey" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="resourceKey" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="resourceKey">要查找的资源的键标识符。</param>
        <summary>搜索具有指定键的资源，如果找到，则返回该资源。</summary>
        <returns>找到的资源；如果未找到具有所提供 <paramref name="key" /> 的资源，则为 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果调用元素上找不到资源，通过逻辑树向上搜索父资源树，树的方法相同资源时的搜索请求时由参数在运行时。 该方法返回`null`仅当在资源树中，每次树的现有条件的任何位置都不存在该密钥的任何资源的<xref:System.Windows.FrameworkElement.TryFindResource%2A>调用。  
  
 通常，会立即强制转换为已尝试设置为返回的资源值的属性的类型的返回值。  
  
 <xref:System.Windows.FrameworkElement.FindResource%2A>方法具有类似行为，不同之处在于它将引发异常，如果返回具有提供的键资源。  
  
   
  
## Examples  
 下面的示例实现一个按钮处理程序，其中点击集的按钮为资源定义画笔其背景中获取通过调用<xref:System.Windows.FrameworkElement.TryFindResource%2A>本身上。 此操作将沿着元素树并查找资源 (资源本身中定义[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]并且不会显示)。  
  
 [!code-csharp[BaseElementsSmorgasbord#FETryFindResource](~/samples/snippets/csharp/VS_Snippets_Wpf/BaseElementsSmorgasbord/CSharp/Page1.xaml.cs#fetryfindresource)]
 [!code-vb[BaseElementsSmorgasbord#FETryFindResource](~/samples/snippets/visualbasic/VS_Snippets_Wpf/BaseElementsSmorgasbord/visualbasic/page1.xaml.vb#fetryfindresource)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkElement.FindResource(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Unloaded">
      <MemberSignature Language="C#" Value="public event System.Windows.RoutedEventHandler Unloaded;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.RoutedEventHandler Unloaded" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkElement.Unloaded" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Unloaded As RoutedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::RoutedEventHandler ^ Unloaded;" />
      <MemberSignature Language="F#" Value="member this.Unloaded : System.Windows.RoutedEventHandler " Usage="member this.Unloaded : System.Windows.RoutedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当从加载的元素的元素树中移除元素时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 直接路由的事件不遵循路由，而仅处理引发它们在同一元素中。 直接路由的事件支持其他路由的事件行为： 它们支持的可访问的处理程序集合，并可用作<xref:System.Windows.EventTrigger>样式中。  
  
 <xref:System.Windows.FrameworkElement.Loaded> 和<xref:System.Windows.FrameworkElement.Unloaded>可能同时会引发用户启动系统主题更改控件上。 主题更改都会导致控件模板，并包含可视化树，从而导致整个控件以卸载并重新加载的失效。 因此<xref:System.Windows.FrameworkElement.Unloaded>不能假设只会在导航离开页面。  
  
 请注意，<xref:System.Windows.FrameworkElement.Unloaded>应用程序开始关闭后不会引发事件。 应用程序关闭时所定义的条件出现<xref:System.Windows.Application.ShutdownMode%2A>属性时发生。 如果处理程序中的清理代码放<xref:System.Windows.FrameworkElement.Unloaded>事件，例如针对<xref:System.Windows.Window>或<xref:System.Windows.Controls.UserControl>，它可能不会按预期方式调用。  
  
<a name="routedEventInfo_Unloaded"></a>   
## <a name="routed-event-information"></a>路由事件信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.FrameworkElement.UnloadedEvent>|  
|路由策略|直接|  
|委托|<xref:System.Windows.RoutedEventHandler>|  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.FrameworkElement.Loaded" />
      </Docs>
    </Member>
    <Member MemberName="UnloadedEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent UnloadedEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent UnloadedEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.UnloadedEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly UnloadedEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ UnloadedEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable UnloadedEvent : System.Windows.RoutedEvent" Usage="System.Windows.FrameworkElement.UnloadedEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="E:System.Windows.FrameworkElement.Unloaded" /> 路由事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在注册路由事件时创建路由事件标识符。 这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。 可以使用这些标识符添加类处理程序。  
  
 有关注册路由事件的更多信息，请参见 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。 有关使用路由事件标识符添加类处理程序的更多信息，请参见 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UnregisterName">
      <MemberSignature Language="C#" Value="public void UnregisterName (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void UnregisterName(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.UnregisterName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub UnregisterName (name As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void UnregisterName(System::String ^ name);" />
      <MemberSignature Language="F#" Value="member this.UnregisterName : string -&gt; unit" Usage="frameworkElement.UnregisterName name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">要从当前范围中移除的名称-对象对的名称。</param>
        <summary>简化对 <see cref="T:System.Windows.NameScope" /> 注销方法的访问。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果你想要重新注册该名称与另一个元素只需取消注册名称到系统。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkElement.RegisterName(System.String,System.Object)" />
        <altmember cref="T:System.Windows.NameScope" />
      </Docs>
    </Member>
    <Member MemberName="UpdateDefaultStyle">
      <MemberSignature Language="C#" Value="public void UpdateDefaultStyle ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void UpdateDefaultStyle() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.UpdateDefaultStyle" />
      <MemberSignature Language="VB.NET" Value="Public Sub UpdateDefaultStyle ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void UpdateDefaultStyle();" />
      <MemberSignature Language="F#" Value="member this.UpdateDefaultStyle : unit -&gt; unit" Usage="frameworkElement.UpdateDefaultStyle " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>将默认样式重新应用至当前 <see cref="T:System.Windows.FrameworkElement" />。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UseLayoutRounding">
      <MemberSignature Language="C#" Value="public bool UseLayoutRounding { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UseLayoutRounding" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.UseLayoutRounding" />
      <MemberSignature Language="VB.NET" Value="Public Property UseLayoutRounding As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UseLayoutRounding { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.UseLayoutRounding : bool with get, set" Usage="System.Windows.FrameworkElement.UseLayoutRounding" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值指示是否应向此元素的大小和位置布局应用布局舍入。</summary>
        <value>如果应用布局舍入，则为 <see langword="true" />；否则为 <see langword="false" />。 默认值为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当<xref:System.Windows.FrameworkElement.UseLayoutRounding%2A>的元素的属性是`true`，过程中所计算的所有非整数像素值<xref:System.Windows.UIElement.Measure%2A>和<xref:System.Windows.UIElement.Arrange%2A>传递舍入为整数像素值。  
  
 此属性的子元素继承。  
  
> [!NOTE]
>  应设置<xref:System.Windows.FrameworkElement.UseLayoutRounding%2A>到`true`根元素上。 布局系统将子坐标添加到父坐标中;因此，如果父级坐标的像素边界上，子坐标也不是像素边界上。 如果<xref:System.Windows.FrameworkElement.UseLayoutRounding%2A>不能在根目录设置，设置<xref:System.Windows.UIElement.SnapsToDevicePixels%2A>在子活动以获取你想要的效果。  
  
 对象绘制像素边界上消除了抗锯齿边缘不再处于中间设备像素时，生成的半透明边缘。 下图显示位置在设备像素的中间的一个像素宽度行的输出。 在左侧的行不使用布局舍入，并且是抗锯齿。 在右侧行使用布局舍入。  
  
 ![反&#45;锯齿的线与单像素线进行比较。](~/add/media/pixelsnaplinecompare.PNG "抗锯齿的线与单像素线进行比较。")  
  
 当你使用布局舍入和<xref:System.Windows.GridUnitType.Star>大小调整，布局系统中的列或行的度量值以避免子像素呈现中创建微小的差异。 例如，如果网格具有 100 3 列每个大小的总宽度<xref:System.Windows.GridUnitType.Star>，而不是创建三个列的宽度相等时为 33.3，布局系统创建 2 个具有 33 到一个宽度为 34 的宽度的列。  
  
> [!NOTE]
>  在.NET 4.6 是对布局舍入以减少带边框的控件中的剪切实例进行更改。 默认情况下，如果您的目标框架是.NET Framework 4.6 或更高版本启用此功能。 面向早期版本的 framework 的应用程序可以选择使用新行为通过将以下设置添加到 app.config 文件：`<runtime><AppContextSwitchOverrides value="Switch.MS.Internal.DoNotApplyLayoutRoundingToMarginsAndBorderThickness=false"/></runtime>`设置.NET Framework 4.6 上运行应用程序时才会生效。  
  
   
  
## Examples  
 下面的示例演示了效果的<xref:System.Windows.FrameworkElement.UseLayoutRounding%2A>属性具有单个像素宽度行上。 在左侧的行不会使用布局舍入，并在右侧行使用布局舍入。 如果缓慢调整窗口的大小，您可以看到不同的布局舍入。  
  
```xaml  
  
<Page x:Class="LayoutRounding.Lines"  
    xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"  
    xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"  
    Title="Lines" Name="linesPage"  
    >  
  <StackPanel Width="150"  Margin="7" Orientation="Horizontal">  
    <!-- Single pixel line with layout rounding turned OFF.-->  
    <Rectangle UseLayoutRounding="False"  
       Width="45.5" Margin="10" Height="1" Fill="Red"/>  
    <!-- Single pixel line with layout rounding turned ON.-->  
    <Rectangle UseLayoutRounding="True"  
      Width="45.5" Margin="10" Height="1" Fill="Red"/>  
  </StackPanel>  
  <!-- Background Grid -->  
  <Page.Background>  
    <DrawingBrush  Viewport="0,0,10,10" ViewportUnits="Absolute" TileMode="Tile">  
      <DrawingBrush.Drawing>  
        <DrawingGroup>  
          <GeometryDrawing Brush="White">  
            <GeometryDrawing.Geometry>  
              <RectangleGeometry Rect="0,0,1,1" />  
            </GeometryDrawing.Geometry>  
          </GeometryDrawing>  
          <GeometryDrawing Geometry="M0,0 L1,0 1,0.1, 0,0.1Z " Brush="#CCCCFF" />  
          <GeometryDrawing Geometry="M0,0 L0,1 0.1,1, 0.1,0Z" Brush="#CCCCFF" />  
        </DrawingGroup>  
      </DrawingBrush.Drawing>  
    </DrawingBrush>  
  </Page.Background>  
</Page>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UseLayoutRoundingProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty UseLayoutRoundingProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty UseLayoutRoundingProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.UseLayoutRoundingProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly UseLayoutRoundingProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ UseLayoutRoundingProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable UseLayoutRoundingProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.UseLayoutRoundingProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="P:System.Windows.FrameworkElement.UseLayoutRounding" /> 依赖项属性。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="VerticalAlignment">
      <MemberSignature Language="C#" Value="public System.Windows.VerticalAlignment VerticalAlignment { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.VerticalAlignment VerticalAlignment" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.VerticalAlignment" />
      <MemberSignature Language="VB.NET" Value="Public Property VerticalAlignment As VerticalAlignment" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::VerticalAlignment VerticalAlignment { System::Windows::VerticalAlignment get(); void set(System::Windows::VerticalAlignment value); };" />
      <MemberSignature Language="F#" Value="member this.VerticalAlignment : System.Windows.VerticalAlignment with get, set" Usage="System.Windows.FrameworkElement.VerticalAlignment" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.VerticalAlignment</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置在父元素（如面板或项控件）中组合此元素时所应用的垂直对齐特征。</summary>
        <value>垂直对齐设置。 默认值为 <see cref="F:System.Windows.VerticalAlignment.Stretch" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当<xref:System.Windows.FrameworkElement.Height%2A>并<xref:System.Windows.FrameworkElement.Width%2A>元素上显式设置属性，这些度量值会优先考虑布局，并且取消的此属性设置为常规效果<xref:System.Windows.VerticalAlignment.Stretch>。  
  
 <xref:System.Windows.FrameworkElement.VerticalAlignment%2A> 是[!INCLUDE[TLA#tla_net](~/includes/tlasharptla-net-md.md)]属性访问器，它实际上是依赖项属性。 此特定的依赖项属性经常具有派生的元素类，尤其是控件中以不同方式设置其原本"默认"值。 这通常发生在两种方式之一： 为特定的派生类，但具有不同的元数据设置其默认值; 重新注册该依赖项属性或者应用了默认样式以不同方式设置该依赖项属性值。 例如，明显"default"的<xref:System.Windows.FrameworkElement.VerticalAlignment%2A>有关<xref:System.Windows.Controls.ComboBoxItem>控件将是<xref:System.Windows.VerticalAlignment.Center>，即使<xref:System.Windows.Controls.ComboBoxItem>继承<xref:System.Windows.FrameworkElement.VerticalAlignment%2A>直接从<xref:System.Windows.FrameworkElement>。 这是因为该值的默认样式中已重置<xref:System.Windows.Controls.ComboBoxItem>，样式的控件模板中。  
  
 <xref:System.Windows.Controls.Canvas> 不使用<xref:System.Windows.FrameworkElement.VerticalAlignment%2A>构成布局，因为时<xref:System.Windows.Controls.Canvas>根据绝对定位。  
  
 当由继承<xref:System.Windows.Controls.ComboBoxItem>或任何派生类中，<xref:System.Windows.Controls.ComboBoxItem>重新定义为此属性的默认值<xref:System.Windows.VerticalAlignment.Center>。  
  
<a name="dependencyPropertyInfo_VerticalAlignment"></a>   
## <a name="dependency-property-information"></a>依赖项属性信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.FrameworkElement.VerticalAlignmentProperty>|  
|元数据属性设置为 `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsArrange%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VerticalAlignmentProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty VerticalAlignmentProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty VerticalAlignmentProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.VerticalAlignmentProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly VerticalAlignmentProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ VerticalAlignmentProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable VerticalAlignmentProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.VerticalAlignmentProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="P:System.Windows.FrameworkElement.VerticalAlignment" /> 依赖项属性。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="VisualChildrenCount">
      <MemberSignature Language="C#" Value="protected override int VisualChildrenCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 VisualChildrenCount" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.VisualChildrenCount" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides ReadOnly Property VisualChildrenCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property int VisualChildrenCount { int get(); };" />
      <MemberSignature Language="F#" Value="member this.VisualChildrenCount : int" Usage="System.Windows.FrameworkElement.VisualChildrenCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取此元素内可视子元素的数目。</summary>
        <value>此元素内可视子元素的数目。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.FrameworkElement>的实现<xref:System.Windows.FrameworkElement.VisualChildrenCount%2A>始终返回零个或一个。 维护可能会超过一个的可视子集合的类必须重写此属性和<xref:System.Windows.FrameworkElement.GetVisualChild%2A>。  
  
 此属性通常用于确定当前的子集合，以便实现的布局重写的上限 (<xref:System.Windows.FrameworkElement.MeasureOverride%2A>， <xref:System.Windows.FrameworkElement.ArrangeOverride%2A>)。  
  
   
  
## Examples  
 下面的示例演示如何自定义装饰器使用的值来声明<xref:System.Windows.Media.VisualCollection>它维护其多个可视化子级并报告这些值通过重写之一<xref:System.Windows.FrameworkElement.VisualChildrenCount%2A>和<xref:System.Windows.FrameworkElement.GetVisualChild%2A>。  
  
 [!code-csharp[Adorners_ResizingAdorner#FEVisualOverridesPre](~/samples/snippets/csharp/VS_Snippets_Wpf/Adorners_ResizingAdorner/CSharp/ResizingAdorner.cs#fevisualoverridespre)]
 [!code-vb[Adorners_ResizingAdorner#FEVisualOverridesPre](~/samples/snippets/visualbasic/VS_Snippets_Wpf/Adorners_ResizingAdorner/visualbasic/resizingadorner.vb#fevisualoverridespre)]  
[!code-csharp[Adorners_ResizingAdorner#FEVisualOverrides](~/samples/snippets/csharp/VS_Snippets_Wpf/Adorners_ResizingAdorner/CSharp/ResizingAdorner.cs#fevisualoverrides)]
[!code-vb[Adorners_ResizingAdorner#FEVisualOverrides](~/samples/snippets/visualbasic/VS_Snippets_Wpf/Adorners_ResizingAdorner/visualbasic/resizingadorner.vb#fevisualoverrides)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>如果您的类支持多个可视子子元素集合中，重写此属性以返回该集合中元素的计数。 即使集合对象本身返回计数时，必须执行此操作。 在 WPF 框架级别的元素的布局逻辑假定所有元素将都返回有效计数通过其<see cref="P:System.Windows.FrameworkElement.VisualChildrenCount" />属性。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Width">
      <MemberSignature Language="C#" Value="public double Width { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 Width" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.Width" />
      <MemberSignature Language="VB.NET" Value="Public Property Width As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double Width { double get(); void set(double value); };" />
      <MemberSignature Language="F#" Value="member this.Width : double with get, set" Usage="System.Windows.FrameworkElement.Width" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Windows.LengthConverter))</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.None, Readability=System.Windows.Readability.Unreadable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置元素的宽度。</summary>
        <value>元素的宽度，单位是[!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]。 默认值为 <see cref="F:System.Double.NaN" />。 此值必须等于或大于 0.0。 请参阅“备注”以了解上限信息。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 这是三个属性之一上<xref:System.Windows.FrameworkElement>指定宽度的信息。  其他两个<xref:System.Windows.FrameworkElement.MinWidth%2A>和<xref:System.Windows.FrameworkElement.MaxWidth%2A>。  如果这些值之间存在冲突，应用程序实际宽度确定的顺序是： 首先<xref:System.Windows.FrameworkElement.MinWidth%2A>必须采用，然后<xref:System.Windows.FrameworkElement.MaxWidth%2A>，最后每个都在限制之内，如果<xref:System.Windows.FrameworkElement.Width%2A>。  
  
 此属性的返回值始终是任何已设置为它的值相同。 与之相反，值<xref:System.Windows.FrameworkElement.ActualWidth%2A>可能会有所不同。 布局可能已被拒绝的建议的大小出于某种原因。 此外，布局系统本身以异步方式工作相对于的属性系统集<xref:System.Windows.FrameworkElement.Width%2A>和可能不处理特定大小调整属性的更改。  
  
 除了在可接受<xref:System.Double>值，此属性也可以是<xref:System.Double.NaN?displayProperty=nameWithType>。 这是如何指定自动调整大小行为。 在[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]值设置为字符串"Auto"（不区分大小写） 以启用自动调整大小行为。 自动调整大小行为意味着该元素将填满可用的宽度。 但是请注意，特定控件通常提供将禁用自动调整大小行为，除非专门重新启用了其默认样式中的默认值。  
  
 除了验证检查，还有用于绑定的不确定性上限值<xref:System.Windows.FrameworkElement.Width%2A>，由布局系统强制执行 (这是一个非常大的数字，大于<xref:System.Single.MaxValue?displayProperty=nameWithType>但小于<xref:System.Double.MaxValue?displayProperty=nameWithType>)。 如果你超出此限制，该元素将不会呈现，并不会引发异常。 未设置<xref:System.Windows.FrameworkElement.Width%2A>远远大于任何可能的可视显示，或您的最大大小可能会超出此非确定性上限的值。  
  
<a name="xamlAttributeUsage_Width"></a>   
## <a name="xaml-attribute-usage"></a>XAML 属性用法  
  
```  
<object Width="double"/>  
- or –  
<object Width ="qualifiedDouble"/>  
- or -  
<object Width ="Auto"/>  
```  
  
<a name="xamlValues_Width"></a>   
## <a name="xaml-values"></a>XAML 值  
 *double*  
 <xref:System.Double>  
  
 字符串表示形式<xref:System.Double>值等于或大于 0.0。 请参阅“备注”以了解上限信息。 此值解释为[!INCLUDE[TLA#tla_dipixel](~/includes/tlasharptla-dipixel-md.md)]度量。 字符串不需要显式包括小数点。 例如，值的`1`是可接受。  
  
 *qualifiedDouble*  
 一个*双*值，上文所述跟以下单位声明字符串之一： `px`， `in`， `cm`， `pt`。  
  
 `px` （默认值） [!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]  
  
 `in` 为英寸;1 中为 96px = =  
  
 `cm` 为厘米;1cm==(96/2.54) px  
  
 `pt` 为点;1pt==(96/72) px  
  
 `Auto`  
 启用自动调整大小行为。 请参阅“备注”。  
  
<a name="dependencyPropertyInfo_Width"></a>   
## <a name="dependency-property-information"></a>依赖项属性信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.FrameworkElement.WidthProperty>|  
|元数据属性设置为 `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WidthProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty WidthProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty WidthProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.WidthProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly WidthProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ WidthProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable WidthProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.WidthProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="P:System.Windows.FrameworkElement.Width" /> 依赖项属性。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>