<Type Name="PropertyMetadata" FullName="System.Windows.PropertyMetadata">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="7bab463ec19438453c1818b250c1ed9bf8e3cb1f" />
    <Meta Name="ms.sourcegitcommit" Value="5a49536d99d2d0b54e4cb7280870903e043272df" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-CN" />
    <Meta Name="ms.lasthandoff" Value="07/03/2018" />
    <Meta Name="ms.locfileid" Value="37490967" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class PropertyMetadata" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit PropertyMetadata extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Windows.PropertyMetadata" />
  <TypeSignature Language="VB.NET" Value="Public Class PropertyMetadata" />
  <TypeSignature Language="C++ CLI" Value="public ref class PropertyMetadata" />
  <TypeSignature Language="F#" Value="type PropertyMetadata = class" />
  <AssemblyInfo>
    <AssemblyName>WindowsBase</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>
      <span data-ttu-id="3a655-101">定义依赖属性在应用于特定类型（包括该属性向其注册的条件）时行为的某些方面。</span>
      <span class="sxs-lookup">
        <span data-stu-id="3a655-101">Defines certain behavior aspects of a dependency property as it is applied to a specific type, including conditions it was registered with.</span>
      </span>
    </summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3a655-102">属性元数据可以定义和依赖关系属性注册过程中调用时使用<xref:System.Windows.DependencyProperty.Register%2A>方法 （或附加的属性或只读依赖属性的变体），或调用时的原始所有者注册后<xref:System.Windows.DependencyPropertyKey.OverrideMetadata%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="3a655-102">Property metadata can be defined and used during dependency property registration when calling the <xref:System.Windows.DependencyProperty.Register%2A> method (or variations for attached properties or read-only dependency properties), or after original owner registration when calling the <xref:System.Windows.DependencyPropertyKey.OverrideMetadata%2A> method.</span></span> <span data-ttu-id="3a655-103"><xref:System.Windows.DependencyProperty.AddOwner%2A> 此外会获取属性元数据。</span><span class="sxs-lookup"><span data-stu-id="3a655-103"><xref:System.Windows.DependencyProperty.AddOwner%2A> also takes property metadata.</span></span>  
  
 <span data-ttu-id="3a655-104">此类是具体的基类，可在每个这些调用。</span><span class="sxs-lookup"><span data-stu-id="3a655-104">This class is a concrete base class that can be used in each of these calls.</span></span> <span data-ttu-id="3a655-105">但是，是很常见，用于指定元数据使用派生类之一如<xref:System.Windows.FrameworkPropertyMetadata>。</span><span class="sxs-lookup"><span data-stu-id="3a655-105">However, it is very common to specify metadata using one of the derived classes such as <xref:System.Windows.FrameworkPropertyMetadata>.</span></span> <span data-ttu-id="3a655-106">这些派生的类支持更多详细元数据可用于检测或启用仅在实现某些属性系统和布局行为的布尔属性值作为[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]框架级别。</span><span class="sxs-lookup"><span data-stu-id="3a655-106">These derived classes support more detailed metadata carried as Boolean property values, which are useful for either detecting or enabling some property system and layout behaviors that are only implemented at the [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] framework level.</span></span>  
  
 <span data-ttu-id="3a655-107">此类的多个属性是读写权限的对象模型，但只能在实例中正在使用的属性系统操作，如之前编写<xref:System.Windows.DependencyProperty.Register%2A>或<xref:System.Windows.DependencyPropertyKey.OverrideMetadata%2A>。</span><span class="sxs-lookup"><span data-stu-id="3a655-107">Several properties of this class are read-write to the object model, but can only be written prior to the instance being used in a property system operation such as <xref:System.Windows.DependencyProperty.Register%2A> or <xref:System.Windows.DependencyPropertyKey.OverrideMetadata%2A>.</span></span> <span data-ttu-id="3a655-108">每个属性可能也已设置由构造函数，但公开，以便<xref:System.Windows.PropertyMetadata.Merge%2A>方法实现可以设置它们。</span><span class="sxs-lookup"><span data-stu-id="3a655-108">Each of these properties could also have been set by the constructor but are exposed so that <xref:System.Windows.PropertyMetadata.Merge%2A> method implementations can set them.</span></span>  
  
<a name="xamlTextUsage_PropertyMetadata"></a>   
## <a name="xaml-text-usage"></a><span data-ttu-id="3a655-109">XAML 文本使用情况</span><span class="sxs-lookup"><span data-stu-id="3a655-109">XAML Text Usage</span></span>  
 <span data-ttu-id="3a655-110">此类型和成员的这种类型，通常不用于在[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]。</span><span class="sxs-lookup"><span data-stu-id="3a655-110">This type, and members of this type, are not typically used in [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].</span></span>  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="3a655-111">初始化 <see cref="T:System.Windows.PropertyMetadata" /> 类的新实例。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a655-111">Initializes a new instance of the <see cref="T:System.Windows.PropertyMetadata" /> class.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public PropertyMetadata ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.PropertyMetadata.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; PropertyMetadata();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="3a655-112">初始化 <see cref="T:System.Windows.PropertyMetadata" /> 类的新实例。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a655-112">Initializes a new instance of the <see cref="T:System.Windows.PropertyMetadata" /> class.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public PropertyMetadata (object defaultValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.PropertyMetadata.#ctor(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (defaultValue As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; PropertyMetadata(System::Object ^ defaultValue);" />
      <MemberSignature Language="F#" Value="new System.Windows.PropertyMetadata : obj -&gt; System.Windows.PropertyMetadata" Usage="new System.Windows.PropertyMetadata defaultValue" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="defaultValue">
          <span data-ttu-id="3a655-113">要为依赖项对象指定的默认值，通常作为某种特定类型的值提供。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a655-113">The default value to specify for a dependency property, usually provided as a value of some specific type.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="3a655-114">使用此元数据将应用于的依赖项对象的指定默认值，初始化 <see cref="T:System.Windows.PropertyMetadata" /> 类的新实例。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a655-114">Initializes a new instance of the <see cref="T:System.Windows.PropertyMetadata" /> class with a specified default value for the dependency property that this metadata will be applied to.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3a655-115">为提供的值的类型`defaultValue`必须匹配或与此元数据将应用于的依赖项属性的原始注册中指定的类型。</span><span class="sxs-lookup"><span data-stu-id="3a655-115">The type of the value provided for `defaultValue` must be match or be related to the type specified in the original registration of the dependency property that this metadata will be applied to.</span></span> <span data-ttu-id="3a655-116">因为不匹配 （不匹配会引发运行时异常） 在编译期间不检测，则可能很难调试，元数据默认值类型的依赖属性应用于类型之间的不匹配。</span><span class="sxs-lookup"><span data-stu-id="3a655-116">Mismatches between metadata default value type and the type of the dependency property it is being applied to can be difficult to debug, because the mismatch is not detectable during compilation (the mismatch will raise a run-time exception).</span></span>  
  
 <span data-ttu-id="3a655-117">尽管它是默认的无参数构造函数中，每`defaultValue`的<xref:System.Windows.DependencyProperty.UnsetValue>不能指定。</span><span class="sxs-lookup"><span data-stu-id="3a655-117">Although it is the default per the parameterless constructor, a `defaultValue` of <xref:System.Windows.DependencyProperty.UnsetValue> cannot be specified.</span></span> <span data-ttu-id="3a655-118">尝试这样做将引发异常。</span><span class="sxs-lookup"><span data-stu-id="3a655-118">Attempting to do so will raise an exception.</span></span>  
  
   
  
## Examples  
 [!code-csharp[PropertyMetadataAPIs#Initpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initpm)]  
[!code-csharp[PropertyMetadataAPIs#PMCtor1param](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#pmctor1param)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="3a655-119">
            <paramref name="defaultValue" /> 不能设置为值 <see cref="F:System.Windows.DependencyProperty.UnsetValue" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a655-119">
              <paramref name="defaultValue" /> cannot be set to the value <see cref="F:System.Windows.DependencyProperty.UnsetValue" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public PropertyMetadata (System.Windows.PropertyChangedCallback propertyChangedCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Windows.PropertyChangedCallback propertyChangedCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.PropertyMetadata.#ctor(System.Windows.PropertyChangedCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; PropertyMetadata(System::Windows::PropertyChangedCallback ^ propertyChangedCallback);" />
      <MemberSignature Language="F#" Value="new System.Windows.PropertyMetadata : System.Windows.PropertyChangedCallback -&gt; System.Windows.PropertyMetadata" Usage="new System.Windows.PropertyMetadata propertyChangedCallback" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
      </Parameters>
      <Docs>
        <param name="propertyChangedCallback">
          <span data-ttu-id="3a655-120">对处理程序实现的引用，每当属性的有效值更改时，属性系统都将调用该处理程序实现。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a655-120">Reference to a handler implementation that is to be called by the property system whenever the effective value of the property changes.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="3a655-121">用指定的 <see cref="T:System.Windows.PropertyMetadata" /> 实现引用初始化 <see cref="T:System.Windows.PropertyChangedCallback" /> 类的新实例。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a655-121">Initializes a new instance of the <see cref="T:System.Windows.PropertyMetadata" /> class with the specified <see cref="T:System.Windows.PropertyChangedCallback" /> implementation reference.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 [!code-csharp[PropertyMetadataAPIs#Initpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initpm)]  
[!code-csharp[PropertyMetadataAPIs#PMCtor1paramcallback](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#pmctor1paramcallback)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public PropertyMetadata (object defaultValue, System.Windows.PropertyChangedCallback propertyChangedCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue, class System.Windows.PropertyChangedCallback propertyChangedCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.PropertyMetadata.#ctor(System.Object,System.Windows.PropertyChangedCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; PropertyMetadata(System::Object ^ defaultValue, System::Windows::PropertyChangedCallback ^ propertyChangedCallback);" />
      <MemberSignature Language="F#" Value="new System.Windows.PropertyMetadata : obj * System.Windows.PropertyChangedCallback -&gt; System.Windows.PropertyMetadata" Usage="new System.Windows.PropertyMetadata (defaultValue, propertyChangedCallback)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
      </Parameters>
      <Docs>
        <param name="defaultValue">
          <span data-ttu-id="3a655-122">依赖项对象的默认值，通常作为某种特定类型的值提供。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a655-122">The default value of the dependency property, usually provided as a value of some specific type.</span>
          </span>
        </param>
        <param name="propertyChangedCallback">
          <span data-ttu-id="3a655-123">对处理程序实现的引用，每当属性的有效值更改时，属性系统都将调用该处理程序实现。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a655-123">Reference to a handler implementation that is to be called by the property system whenever the effective value of the property changes.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="3a655-124">用指定的默认值和 <see cref="T:System.Windows.PropertyMetadata" /> 实现引用初始化 <see cref="T:System.Windows.PropertyChangedCallback" /> 类的新实例。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a655-124">Initializes a new instance of the <see cref="T:System.Windows.PropertyMetadata" /> class with the specified default value and <see cref="T:System.Windows.PropertyChangedCallback" /> implementation reference.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3a655-125">提供的值的类型`defaultValue`必须匹配或与此元数据将应用于的依赖项属性的原始注册中指定的类型。</span><span class="sxs-lookup"><span data-stu-id="3a655-125">The type of the value provided `defaultValue` must be match or be related to the type specified in the original registration of the dependency property that this metadata will be applied to.</span></span> <span data-ttu-id="3a655-126">因为不匹配 （不匹配会引发运行时异常） 在编译期间不检测，则可能很难调试，元数据默认值类型的依赖属性应用于类型之间的不匹配。</span><span class="sxs-lookup"><span data-stu-id="3a655-126">Mismatches between metadata default value type and the type of the dependency property it is being applied to can be difficult to debug, because the mismatch is not detectable during compilation (the mismatch will raise a run-time exception).</span></span>  
  
 <span data-ttu-id="3a655-127">尽管它是默认的无参数构造函数中，每`defaultValue`的<xref:System.Windows.DependencyProperty.UnsetValue>不能指定。</span><span class="sxs-lookup"><span data-stu-id="3a655-127">Although it is the default per the parameterless constructor, a `defaultValue` of <xref:System.Windows.DependencyProperty.UnsetValue> cannot be specified.</span></span> <span data-ttu-id="3a655-128">尝试这样做将引发异常。</span><span class="sxs-lookup"><span data-stu-id="3a655-128">Attempting to do so will raise an exception.</span></span>  
  
   
  
## Examples  
 [!code-csharp[PropertyMetadataAPIs#Initpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initpm)]  
[!code-csharp[PropertyMetadataAPIs#PMCtor2param](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#pmctor2param)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="3a655-129">
            <paramref name="defaultValue" /> 不能设置为值 <see cref="F:System.Windows.DependencyProperty.UnsetValue" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a655-129">
              <paramref name="defaultValue" /> cannot be set to the value <see cref="F:System.Windows.DependencyProperty.UnsetValue" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public PropertyMetadata (object defaultValue, System.Windows.PropertyChangedCallback propertyChangedCallback, System.Windows.CoerceValueCallback coerceValueCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue, class System.Windows.PropertyChangedCallback propertyChangedCallback, class System.Windows.CoerceValueCallback coerceValueCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.PropertyMetadata.#ctor(System.Object,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; PropertyMetadata(System::Object ^ defaultValue, System::Windows::PropertyChangedCallback ^ propertyChangedCallback, System::Windows::CoerceValueCallback ^ coerceValueCallback);" />
      <MemberSignature Language="F#" Value="new System.Windows.PropertyMetadata : obj * System.Windows.PropertyChangedCallback * System.Windows.CoerceValueCallback -&gt; System.Windows.PropertyMetadata" Usage="new System.Windows.PropertyMetadata (defaultValue, propertyChangedCallback, coerceValueCallback)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
        <Parameter Name="coerceValueCallback" Type="System.Windows.CoerceValueCallback" />
      </Parameters>
      <Docs>
        <param name="defaultValue">
          <span data-ttu-id="3a655-130">依赖项对象的默认值，通常作为某种特定类型的值提供。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a655-130">The default value of the dependency property, usually provided as a value of some specific type.</span>
          </span>
        </param>
        <param name="propertyChangedCallback">
          <span data-ttu-id="3a655-131">对处理程序实现的引用，每当属性的有效值更改时，属性系统都将调用该处理程序实现。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a655-131">Reference to a handler implementation that is to be called by the property system whenever the effective value of the property changes.</span>
          </span>
        </param>
        <param name="coerceValueCallback">
          <span data-ttu-id="3a655-132">对处理程序实现的引用，每当属性系统对该属性调用 <see cref="M:System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)" /> 时都将调用此处理程序实现。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a655-132">Reference to a handler implementation that is to be called whenever the property system calls <see cref="M:System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)" /> against this property.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="3a655-133">用指定的默认值和回调初始化 <see cref="T:System.Windows.PropertyMetadata" /> 类的新实例。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a655-133">Initializes a new instance of the <see cref="T:System.Windows.PropertyMetadata" /> class with the specified default value and callbacks.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3a655-134">如果你想要指定<xref:System.Windows.CoerceValueCallback>而非<xref:System.Windows.PropertyChangedCallback>，可以将传递`null`为`propertyChangedCallback`参数。</span><span class="sxs-lookup"><span data-stu-id="3a655-134">If you want to specify a <xref:System.Windows.CoerceValueCallback> but not a <xref:System.Windows.PropertyChangedCallback>, you can pass `null` for the `propertyChangedCallback` parameter.</span></span>  
  
 <span data-ttu-id="3a655-135">为提供的值的类型`defaultValue`必须匹配或与此元数据将应用于的依赖项属性的原始注册中指定的类型。</span><span class="sxs-lookup"><span data-stu-id="3a655-135">The type of the value provided for `defaultValue` must be match or be related to the type specified in the original registration of the dependency property that this metadata will be applied to.</span></span> <span data-ttu-id="3a655-136">因为不匹配 （不匹配会引发运行时异常） 在编译期间不检测，则可能很难调试，元数据默认值类型的依赖属性应用于类型之间的不匹配。</span><span class="sxs-lookup"><span data-stu-id="3a655-136">Mismatches between metadata default value type and the type of the dependency property it is being applied to can be difficult to debug, because the mismatch is not detectable during compilation (the mismatch will raise a run-time exception).</span></span>  
  
 <span data-ttu-id="3a655-137">尽管它是默认的无参数构造函数中，每`defaultValue`的<xref:System.Windows.DependencyProperty.UnsetValue>不能指定。</span><span class="sxs-lookup"><span data-stu-id="3a655-137">Although it is the default per the parameterless constructor, a `defaultValue` of <xref:System.Windows.DependencyProperty.UnsetValue> cannot be specified.</span></span> <span data-ttu-id="3a655-138">尝试这样做将引发异常。</span><span class="sxs-lookup"><span data-stu-id="3a655-138">Attempting to do so will raise an exception.</span></span>  
  
   
  
## Examples  
 [!code-csharp[PropertyMetadataAPIs#Initpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initpm)]  
[!code-csharp[PropertyMetadataAPIs#PMCtor3param](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#pmctor3param)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="3a655-139">
            <paramref name="defaultValue" /> 不能设置为值 <see cref="F:System.Windows.DependencyProperty.UnsetValue" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a655-139">
              <paramref name="defaultValue" /> cannot be set to the value <see cref="F:System.Windows.DependencyProperty.UnsetValue" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="CoerceValueCallback">
      <MemberSignature Language="C#" Value="public System.Windows.CoerceValueCallback CoerceValueCallback { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.CoerceValueCallback CoerceValueCallback" />
      <MemberSignature Language="DocId" Value="P:System.Windows.PropertyMetadata.CoerceValueCallback" />
      <MemberSignature Language="VB.NET" Value="Public Property CoerceValueCallback As CoerceValueCallback" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::CoerceValueCallback ^ CoerceValueCallback { System::Windows::CoerceValueCallback ^ get(); void set(System::Windows::CoerceValueCallback ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CoerceValueCallback : System.Windows.CoerceValueCallback with get, set" Usage="System.Windows.PropertyMetadata.CoerceValueCallback" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.CoerceValueCallback</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="3a655-140">获取或设置对此元数据中所指定 <see cref="T:System.Windows.CoerceValueCallback" /> 实现的引用。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a655-140">Gets or sets a reference to a <see cref="T:System.Windows.CoerceValueCallback" /> implementation specified in this metadata.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="3a655-141">一个 <see cref="T:System.Windows.CoerceValueCallback" /> 实现引用。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a655-141">A <see cref="T:System.Windows.CoerceValueCallback" /> implementation reference.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3a655-142">属性元数据中的回叫不通常是公共成员上包含的类型，因此此属性的值并不重要的大多数情况下，只需使用现有依赖属性的元数据。</span><span class="sxs-lookup"><span data-stu-id="3a655-142">The callbacks in property metadata are not typically public members on the containing type, so the value of this property is not important for most scenarios that just consume an existing dependency property's metadata.</span></span> <span data-ttu-id="3a655-143">此属性公开的一个原因是，因此，如果基本元数据和重写/添加元数据指定元数据子类可以执行其所需的合并逻辑<xref:System.Windows.CoerceValueCallback>。</span><span class="sxs-lookup"><span data-stu-id="3a655-143">One reason this property is exposed is so that metadata subclasses can perform their desired merge logic if both base metadata and overriding/adding metadata specify a <xref:System.Windows.CoerceValueCallback>.</span></span> <span data-ttu-id="3a655-144">但是，默认值合并为逻辑<xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A>是替换上一个。</span><span class="sxs-lookup"><span data-stu-id="3a655-144">However, the default merge logic for a <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> is to replace the previous one.</span></span>  
  
 <span data-ttu-id="3a655-145"><xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> 为读写对象模型中定义。</span><span class="sxs-lookup"><span data-stu-id="3a655-145"><xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> is defined in the object model as read-write.</span></span> <span data-ttu-id="3a655-146">也是如此<xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A>的初始化后可调整<xref:System.Windows.PropertyMetadata>对象本身。</span><span class="sxs-lookup"><span data-stu-id="3a655-146">This is so <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> can be adjusted after initialization of the <xref:System.Windows.PropertyMetadata> object itself.</span></span> <span data-ttu-id="3a655-147">但是，一旦调用的一部分使用元数据<xref:System.Windows.DependencyProperty.Register%2A>， <xref:System.Windows.DependencyProperty.AddOwner%2A>，或<xref:System.Windows.DependencyProperty.OverrideMetadata%2A>、 属性系统将密封该元数据实例和属性都被视为不可变。</span><span class="sxs-lookup"><span data-stu-id="3a655-147">However, once the metadata is consumed as part of a call to <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, or <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, the property system will seal that metadata instance and the properties are now considered immutable.</span></span> <span data-ttu-id="3a655-148">尝试设置<xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A>一旦<xref:System.Windows.PropertyMetadata.IsSealed%2A>是`true`对此元数据实例将引发异常。</span><span class="sxs-lookup"><span data-stu-id="3a655-148">Attempting to set <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> once <xref:System.Windows.PropertyMetadata.IsSealed%2A> is `true` on this metadata instance will raise an exception.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="3a655-149">将元数据属性应用于依赖属性操作后，无法设置该属性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a655-149">Cannot set a metadata property once it is applied to a dependency property operation.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="DefaultValue">
      <MemberSignature Language="C#" Value="public object DefaultValue { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object DefaultValue" />
      <MemberSignature Language="DocId" Value="P:System.Windows.PropertyMetadata.DefaultValue" />
      <MemberSignature Language="VB.NET" Value="Public Property DefaultValue As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ DefaultValue { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.DefaultValue : obj with get, set" Usage="System.Windows.PropertyMetadata.DefaultValue" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="3a655-150">获取或设置依赖属性的默认值。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a655-150">Gets or sets the default value of the dependency property.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="3a655-151">属性的默认值。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a655-151">The default value of the property.</span>
          </span>
          <span data-ttu-id="3a655-152">上的默认值<see cref="T:System.Windows.PropertyMetadata" />的无参数构造函数创建的实例将<see cref="F:System.Windows.DependencyProperty.UnsetValue" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a655-152">The default value on a <see cref="T:System.Windows.PropertyMetadata" /> instance created with the parameterless constructor will be <see cref="F:System.Windows.DependencyProperty.UnsetValue" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3a655-153"><xref:System.Windows.PropertyMetadata.DefaultValue%2A> 为读写对象模型中定义。</span><span class="sxs-lookup"><span data-stu-id="3a655-153"><xref:System.Windows.PropertyMetadata.DefaultValue%2A> is defined in the object model as read-write.</span></span> <span data-ttu-id="3a655-154">也是如此<xref:System.Windows.PropertyMetadata.DefaultValue%2A>的初始化后可调整<xref:System.Windows.PropertyMetadata>对象本身。</span><span class="sxs-lookup"><span data-stu-id="3a655-154">This is so <xref:System.Windows.PropertyMetadata.DefaultValue%2A> can be adjusted after initialization of the <xref:System.Windows.PropertyMetadata> object itself.</span></span> <span data-ttu-id="3a655-155">但是，一旦调用的一部分使用元数据<xref:System.Windows.DependencyProperty.Register%2A>， <xref:System.Windows.DependencyProperty.AddOwner%2A>，或<xref:System.Windows.DependencyProperty.OverrideMetadata%2A>、 属性系统将密封该元数据实例和属性都被视为不可变。</span><span class="sxs-lookup"><span data-stu-id="3a655-155">However, once the metadata is consumed as part of a call to <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, or <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, the property system will seal that metadata instance and the properties are now considered immutable.</span></span> <span data-ttu-id="3a655-156">尝试设置<xref:System.Windows.PropertyMetadata.DefaultValue%2A>一旦<xref:System.Windows.PropertyMetadata.IsSealed%2A>是`true`对此元数据实例将引发异常。</span><span class="sxs-lookup"><span data-stu-id="3a655-156">Attempting to set <xref:System.Windows.PropertyMetadata.DefaultValue%2A> once <xref:System.Windows.PropertyMetadata.IsSealed%2A> is `true` on this metadata instance will raise an exception.</span></span>  
  
 <span data-ttu-id="3a655-157">尽管它是默认的无参数构造函数中，每`defaultValue`的<xref:System.Windows.DependencyProperty.UnsetValue>不能使用设置<xref:System.Windows.PropertyMetadata.DefaultValue%2A>或构造函数。</span><span class="sxs-lookup"><span data-stu-id="3a655-157">Although it is the default per the parameterless constructor, a `defaultValue` of <xref:System.Windows.DependencyProperty.UnsetValue> cannot be set using either <xref:System.Windows.PropertyMetadata.DefaultValue%2A> or the constructor.</span></span> <span data-ttu-id="3a655-158">尝试这样做将引发异常。</span><span class="sxs-lookup"><span data-stu-id="3a655-158">Attempting to do so will raise an exception.</span></span>  
  
<a name="xamlTextUsage_PropertyChangedCallback"></a>   
## <a name="xaml-text-usage"></a><span data-ttu-id="3a655-159">XAML 文本使用情况</span><span class="sxs-lookup"><span data-stu-id="3a655-159">XAML Text Usage</span></span>  
 <span data-ttu-id="3a655-160">此类型的成员通常不使用在[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]。</span><span class="sxs-lookup"><span data-stu-id="3a655-160">Members of this type are not typically used in [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="3a655-161">创建之后不能设置为值 <see cref="F:System.Windows.DependencyProperty.UnsetValue" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a655-161">Cannot be set to the value <see cref="F:System.Windows.DependencyProperty.UnsetValue" /> once created.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="3a655-162">将元数据属性应用于依赖属性操作后，无法设置该属性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a655-162">Cannot set a metadata property once it is applied to a dependency property operation.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="IsSealed">
      <MemberSignature Language="C#" Value="protected bool IsSealed { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSealed" />
      <MemberSignature Language="DocId" Value="P:System.Windows.PropertyMetadata.IsSealed" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property IsSealed As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property bool IsSealed { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSealed : bool" Usage="System.Windows.PropertyMetadata.IsSealed" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="3a655-163">获取一个值，该值确定是否已通过某种方式将元数据应用于属性，从而导致该元数据实例变为不可变状态。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a655-163">Gets a value that determines whether the metadata has been applied to a property in some way, resulting in the immutable state of that metadata instance.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="3a655-164">如果元数据实例不可变，则为 <see langword="true" />；否则为 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a655-164">
              <see langword="true" /> if the metadata instance is immutable; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3a655-165">各种属性<xref:System.Windows.PropertyMetadata>，如<xref:System.Windows.PropertyMetadata.DefaultValue%2A>，为可读写的对象模型中定义。</span><span class="sxs-lookup"><span data-stu-id="3a655-165">Various properties of <xref:System.Windows.PropertyMetadata>, such as <xref:System.Windows.PropertyMetadata.DefaultValue%2A>, are defined in the object model as read-write.</span></span> <span data-ttu-id="3a655-166">这是使这些属性可以进行调整后的初始化<xref:System.Windows.PropertyMetadata>对象本身。</span><span class="sxs-lookup"><span data-stu-id="3a655-166">This is so those properties can be adjusted after initialization of the <xref:System.Windows.PropertyMetadata> object itself.</span></span> <span data-ttu-id="3a655-167">但是，一旦调用的一部分应用于依赖属性元数据<xref:System.Windows.DependencyProperty.Register%2A>， <xref:System.Windows.DependencyProperty.AddOwner%2A>，或<xref:System.Windows.DependencyProperty.OverrideMetadata%2A>、 属性系统将密封该元数据实例和属性都被视为不可变。</span><span class="sxs-lookup"><span data-stu-id="3a655-167">However, once the metadata is applied to a dependency property as part of a call to <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, or <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, the property system will seal that metadata instance and the properties are now considered immutable.</span></span> <span data-ttu-id="3a655-168">在这些调用，之一时<xref:System.Windows.PropertyMetadata.OnApply%2A>调用时，此属性的值设置为`true`。</span><span class="sxs-lookup"><span data-stu-id="3a655-168">At the time of one of these calls, <xref:System.Windows.PropertyMetadata.OnApply%2A> is called, and the value of this property is set to `true`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3a655-169">以下示例检查<xref:System.Windows.PropertyMetadata.IsSealed%2A>之前设置操作中的自定义元数据属性。</span><span class="sxs-lookup"><span data-stu-id="3a655-169">The following example  checks <xref:System.Windows.PropertyMetadata.IsSealed%2A> prior to a set operation of a custom metadata property.</span></span>  
  
 [!code-csharp[PropertyMetadataAPIs#MergeImpl](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#mergeimpl)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.PropertyMetadata.OnApply(System.Windows.DependencyProperty,System.Type)" />
      </Docs>
    </Member>
    <Member MemberName="Merge">
      <MemberSignature Language="C#" Value="protected virtual void Merge (System.Windows.PropertyMetadata baseMetadata, System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Merge(class System.Windows.PropertyMetadata baseMetadata, class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.PropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Merge (baseMetadata As PropertyMetadata, dp As DependencyProperty)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Merge(System::Windows::PropertyMetadata ^ baseMetadata, System::Windows::DependencyProperty ^ dp);" />
      <MemberSignature Language="F#" Value="abstract member Merge : System.Windows.PropertyMetadata * System.Windows.DependencyProperty -&gt; unit&#xA;override this.Merge : System.Windows.PropertyMetadata * System.Windows.DependencyProperty -&gt; unit" Usage="propertyMetadata.Merge (baseMetadata, dp)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="baseMetadata" Type="System.Windows.PropertyMetadata" />
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="baseMetadata">
          <span data-ttu-id="3a655-170">要与此实例的值合并的基元数据。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a655-170">The base metadata to merge with this instance's values.</span>
          </span>
        </param>
        <param name="dp">
          <span data-ttu-id="3a655-171">要应用此元数据的依赖项对象。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a655-171">The dependency property to which this metadata is being applied.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="3a655-172">将此元数据与基元数据合并。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a655-172">Merges this metadata with the base metadata.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3a655-173">重写元数据时，此方法在内部使用 (<xref:System.Windows.DependencyProperty.OverrideMetadata%2A>方法)。</span><span class="sxs-lookup"><span data-stu-id="3a655-173">This method is used internally when metadata is being overridden (<xref:System.Windows.DependencyProperty.OverrideMetadata%2A> method).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3a655-174">下面的示例实现其他属性添加到属性元数据的自定义元数据类型的合并。</span><span class="sxs-lookup"><span data-stu-id="3a655-174">The following example implements a merge for a custom metadata type that adds an additional property to the property metadata.</span></span>  
  
 [!code-csharp[PropertyMetadataAPIs#MergeImpl](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#mergeimpl)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <span data-ttu-id="3a655-175">
            <para>类派生的实现<see cref="T:System.Windows.PropertyMetadata" />应重写此方法要考虑的他们已在其实现中添加了任何元数据属性。例如，您的实现可能会添加一个新的按标志枚举值，和<see cref="M:System.Windows.PropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)" />实现应能够正确组合这些标志。始终调用您的实现代码之前, 的基实现，因为基实现负责合并已定义的所有属性<see cref="T:System.Windows.PropertyMetadata" />类型。合并的具体行为取决于您是。您可以选择具有值的组合，如果派生的元数据保留在默认情况下或基于类型的属性已添加到您的特定元数据类，以及它们的含义的许多其他行为还原为基值的值。</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="3a655-175">
              <para>Class implementations that derive from <see cref="T:System.Windows.PropertyMetadata" /> should override this method to account for any metadata properties they have added in their implementations. For instance, your implementation might have added a new flagwise enumeration value, and the <see cref="M:System.Windows.PropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)" /> implementation should then be able to combine those flags correctly.  Always call the base implementation prior to your implementation code, because the base implementation takes care of merging all the properties already defined on the <see cref="T:System.Windows.PropertyMetadata" /> type.  The exact behavior of the merge is up to you. You could choose to have values combined, revert to base value if the derived metadata were left at the default, or many other behaviors based on the types of properties you have added to your particular metadata class, and their meanings.</para>
            </span>
          </span>
        </block>
        <altmember cref="M:System.Windows.FrameworkPropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)" />
      </Docs>
    </Member>
    <Member MemberName="OnApply">
      <MemberSignature Language="C#" Value="protected virtual void OnApply (System.Windows.DependencyProperty dp, Type targetType);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnApply(class System.Windows.DependencyProperty dp, class System.Type targetType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.PropertyMetadata.OnApply(System.Windows.DependencyProperty,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnApply (dp As DependencyProperty, targetType As Type)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnApply(System::Windows::DependencyProperty ^ dp, Type ^ targetType);" />
      <MemberSignature Language="F#" Value="abstract member OnApply : System.Windows.DependencyProperty * Type -&gt; unit&#xA;override this.OnApply : System.Windows.DependencyProperty * Type -&gt; unit" Usage="propertyMetadata.OnApply (dp, targetType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="targetType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="dp">
          <span data-ttu-id="3a655-176">已应用了元数据的依赖项对象。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a655-176">The dependency property to which the metadata has been applied.</span>
          </span>
        </param>
        <param name="targetType">
          <span data-ttu-id="3a655-177">与此元数据关联的类型（如果这是特定于类型的元数据）。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a655-177">The type associated with this metadata if this is type-specific metadata.</span>
          </span>
          <span data-ttu-id="3a655-178">如果这是默认元数据，则此值为 null 引用。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a655-178">If this is default metadata, this value is a null reference.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="3a655-179">当此元数据已经应用到一个属性时（这表明正在密封元数据）调用。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a655-179">Called when this metadata has been applied to a property, which indicates that the metadata is being sealed.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3a655-180">子类应确保： 数据结构的任何可变性<xref:System.Windows.PropertyMetadata>子类应将标记为不可变一次<xref:System.Windows.PropertyMetadata.OnApply%2A>调用。</span><span class="sxs-lookup"><span data-stu-id="3a655-180">Subclasses should assure that any mutability of the data structure of a <xref:System.Windows.PropertyMetadata> subclass should be marked as immutable once <xref:System.Windows.PropertyMetadata.OnApply%2A> is called.</span></span> <span data-ttu-id="3a655-181">元数据应用到属性系统操作后，将调用此 （注册、 将所有者添加、 重写元数据）。</span><span class="sxs-lookup"><span data-stu-id="3a655-181">This will be called once the metadata is applied to a property system operation (register, add owner, override metadata).</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PropertyChangedCallback">
      <MemberSignature Language="C#" Value="public System.Windows.PropertyChangedCallback PropertyChangedCallback { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.PropertyChangedCallback PropertyChangedCallback" />
      <MemberSignature Language="DocId" Value="P:System.Windows.PropertyMetadata.PropertyChangedCallback" />
      <MemberSignature Language="VB.NET" Value="Public Property PropertyChangedCallback As PropertyChangedCallback" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::PropertyChangedCallback ^ PropertyChangedCallback { System::Windows::PropertyChangedCallback ^ get(); void set(System::Windows::PropertyChangedCallback ^ value); };" />
      <MemberSignature Language="F#" Value="member this.PropertyChangedCallback : System.Windows.PropertyChangedCallback with get, set" Usage="System.Windows.PropertyMetadata.PropertyChangedCallback" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.PropertyChangedCallback</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="3a655-182">获取或设置对此元数据中所指定 <see cref="T:System.Windows.PropertyChangedCallback" /> 实现的引用。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a655-182">Gets or sets a reference to a <see cref="T:System.Windows.PropertyChangedCallback" /> implementation specified in this metadata.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="3a655-183">一个 <see cref="T:System.Windows.PropertyChangedCallback" /> 实现引用。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a655-183">A <see cref="T:System.Windows.PropertyChangedCallback" /> implementation reference.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3a655-184">属性元数据中的回叫不通常是公共成员上定义的类型，因此此属性的值并不重要的大多数情况下，只需使用现有依赖属性的元数据。</span><span class="sxs-lookup"><span data-stu-id="3a655-184">The callbacks in property metadata are not typically public members on the defining type, so the value of this property is not important for most scenarios that just consume an existing dependency property's metadata.</span></span> <span data-ttu-id="3a655-185">此属性公开的一个原因是，因此，如果基本元数据和重写/添加元数据指定元数据类可以执行其所需的合并逻辑<xref:System.Windows.PropertyChangedCallback>。</span><span class="sxs-lookup"><span data-stu-id="3a655-185">One reason this property is exposed is so that metadata classes can perform their desired merge logic if both base metadata and overriding/adding metadata specify a <xref:System.Windows.PropertyChangedCallback>.</span></span> <span data-ttu-id="3a655-186">默认的合并逻辑是保持所有<xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A>实现中，一个表并调用每个项，通过运行第一个层次结构中的最深类建立的回调。</span><span class="sxs-lookup"><span data-stu-id="3a655-186">The default merge logic for is to maintain all <xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A> implementations in a table and call each of them, with callbacks established by the deepest class in hierarchy running first.</span></span>  
  
 <span data-ttu-id="3a655-187"><xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A> 为读写对象模型中定义。</span><span class="sxs-lookup"><span data-stu-id="3a655-187"><xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A> is defined in the object model as read-write.</span></span> <span data-ttu-id="3a655-188">也是如此<xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A>的初始化后可调整<xref:System.Windows.PropertyMetadata>对象本身。</span><span class="sxs-lookup"><span data-stu-id="3a655-188">This is so <xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A> can be adjusted after initialization of the <xref:System.Windows.PropertyMetadata> object itself.</span></span> <span data-ttu-id="3a655-189">但是，一旦调用的一部分使用元数据<xref:System.Windows.DependencyProperty.Register%2A>， <xref:System.Windows.DependencyProperty.AddOwner%2A>，或<xref:System.Windows.DependencyProperty.OverrideMetadata%2A>、 属性系统将密封该元数据实例和属性都被视为不可变。</span><span class="sxs-lookup"><span data-stu-id="3a655-189">However, once the metadata is consumed as part of a call to <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, or <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, the property system will seal that metadata instance and the properties are now considered immutable.</span></span> <span data-ttu-id="3a655-190">尝试设置<xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A>一旦<xref:System.Windows.PropertyMetadata.IsSealed%2A>是`true`对此元数据实例将引发异常。</span><span class="sxs-lookup"><span data-stu-id="3a655-190">Attempting to set <xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A> once <xref:System.Windows.PropertyMetadata.IsSealed%2A> is `true` on this metadata instance will raise an exception.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="3a655-191">将元数据属性应用于依赖属性操作后，无法设置该属性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3a655-191">Cannot set a metadata property once it is applied to a dependency property operation.</span>
          </span>
        </exception>
      </Docs>
    </Member>
  </Members>
</Type>