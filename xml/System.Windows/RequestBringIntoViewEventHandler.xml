<Type Name="RequestBringIntoViewEventHandler" FullName="System.Windows.RequestBringIntoViewEventHandler">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="1fabd3e8ca79d0ed50a5a9c8a6f00299e7b8f9dd" />
    <Meta Name="ms.sourcegitcommit" Value="434f60616a9793fa8436744549fc856e94f7a648" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-CN" />
    <Meta Name="ms.lasthandoff" Value="08/24/2018" />
    <Meta Name="ms.locfileid" Value="37491188" />
  </Metadata>
  <TypeSignature Language="C#" Value="public delegate void RequestBringIntoViewEventHandler(object sender, RequestBringIntoViewEventArgs e);" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed RequestBringIntoViewEventHandler extends System.MulticastDelegate" />
  <TypeSignature Language="DocId" Value="T:System.Windows.RequestBringIntoViewEventHandler" />
  <TypeSignature Language="VB.NET" Value="Public Delegate Sub RequestBringIntoViewEventHandler(sender As Object, e As RequestBringIntoViewEventArgs)" />
  <TypeSignature Language="C++ CLI" Value="public delegate void RequestBringIntoViewEventHandler(System::Object ^ sender, RequestBringIntoViewEventArgs ^ e);" />
  <TypeSignature Language="F#" Value="type RequestBringIntoViewEventHandler = delegate of obj * RequestBringIntoViewEventArgs -&gt; unit" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Delegate</BaseTypeName>
  </Base>
  <Parameters>
    <Parameter Name="sender" Type="System.Object" />
    <Parameter Name="e" Type="System.Windows.RequestBringIntoViewEventArgs" />
  </Parameters>
  <ReturnValue>
    <ReturnType>System.Void</ReturnType>
  </ReturnValue>
  <Docs>
    <param name="sender">
      <span data-ttu-id="684c4-101">事件处理程序附加到的对象。</span>
      <span class="sxs-lookup">
        <span data-stu-id="684c4-101">The object where the event handler is attached.</span>
      </span>
    </param>
    <param name="e">
      <span data-ttu-id="684c4-102">事件数据。</span>
      <span class="sxs-lookup">
        <span data-stu-id="684c4-102">The event data.</span>
      </span>
    </param>
    <summary>
      <span data-ttu-id="684c4-103">表示将处理 <see cref="E:System.Windows.FrameworkElement.RequestBringIntoView" /> 路由事件的方法。</span>
      <span class="sxs-lookup">
        <span data-stu-id="684c4-103">Represents the method that will handle the <see cref="E:System.Windows.FrameworkElement.RequestBringIntoView" /> routed event.</span>
      </span>
    </summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="684c4-104">处理此事件通常仅完成中支持可滚动区域，或否则有意设置其呈现大小小于组合的元素所需大小的子元素内容，并仅可通过谨慎地处理一旦它在元素树向上路由，并且已达到提供滚动区域支持的第一个父事件。</span><span class="sxs-lookup"><span data-stu-id="684c4-104">Handling this event is typically only done within elements that support a scrollable region, or otherwise deliberately set their rendering size smaller than the combined desired size of their child element content, and is only done by deliberately handling the event once it has routed upwards in the element tree and has reached the first parent that offers scrolling region support.</span></span> <span data-ttu-id="684c4-105">处理是通常所需的用户控件的方式滚动区域的现有实现<xref:System.Windows.Controls.ScrollViewer>。</span><span class="sxs-lookup"><span data-stu-id="684c4-105">An existing implementation that handles scrolling regions in a manner that is typically desirable for user controls is <xref:System.Windows.Controls.ScrollViewer>.</span></span> <span data-ttu-id="684c4-106">如果从其中派生<xref:System.Windows.Controls.ScrollViewer>，可以注册的类处理程序<xref:System.Windows.FrameworkElement.RequestBringIntoView?displayProperty=nameWithType>和补充该事件的基类处理。</span><span class="sxs-lookup"><span data-stu-id="684c4-106">If you derive from <xref:System.Windows.Controls.ScrollViewer>, you can register a class handler for <xref:System.Windows.FrameworkElement.RequestBringIntoView?displayProperty=nameWithType> and supplement the base class handling of the event.</span></span> <span data-ttu-id="684c4-107">您还应考虑使用或类处理的类定义<xref:System.Windows.Controls.ScrollViewer.ScrollChanged>而不是事件<xref:System.Windows.FrameworkElement.RequestBringIntoView?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="684c4-107">You should also consider using or class-handling the class-defined <xref:System.Windows.Controls.ScrollViewer.ScrollChanged> event instead of <xref:System.Windows.FrameworkElement.RequestBringIntoView?displayProperty=nameWithType>.</span></span> <span data-ttu-id="684c4-108">或者，如果您创建一个完全自定义类，不是派生自<xref:System.Windows.Controls.ScrollViewer>，则仍然可以添加类处理通过调用<xref:System.Windows.EventManager.RegisterClassHandler%2A?displayProperty=nameWithType>类实例化中。</span><span class="sxs-lookup"><span data-stu-id="684c4-108">Alternatively, if you create an entirely custom class that does not derive from <xref:System.Windows.Controls.ScrollViewer>, you can still add class handling by calling <xref:System.Windows.EventManager.RegisterClassHandler%2A?displayProperty=nameWithType> in your class instantiation.</span></span>  <span data-ttu-id="684c4-109">类处理的详细信息，请参阅[路由事件标记为已处理，和类处理](~/docs/framework/wpf/advanced/marking-routed-events-as-handled-and-class-handling.md)。</span><span class="sxs-lookup"><span data-stu-id="684c4-109">For details on class handling, see [Marking Routed Events as Handled, and Class Handling](~/docs/framework/wpf/advanced/marking-routed-events-as-handled-and-class-handling.md).</span></span>  
  
 <span data-ttu-id="684c4-110">内容元素可能会导致要由其内容宿主引发的事件 (通过调用<xref:System.Windows.FrameworkContentElement.BringIntoView%2A>和引发<xref:System.Windows.FrameworkElement.RequestBringIntoView?displayProperty=nameWithType>来自内容主机)。</span><span class="sxs-lookup"><span data-stu-id="684c4-110">Content elements can cause the event to be raised by their content hosts (through calling <xref:System.Windows.FrameworkContentElement.BringIntoView%2A> and raising <xref:System.Windows.FrameworkElement.RequestBringIntoView?displayProperty=nameWithType> from the content host).</span></span> <span data-ttu-id="684c4-111">同样，可以请求要使用的帮助器方法放入视图的逻辑树元素<xref:System.Windows.LogicalTreeHelper.BringIntoView%2A?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="684c4-111">Similarly, you can request logical tree elements to be brought into view with the helper method <xref:System.Windows.LogicalTreeHelper.BringIntoView%2A?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="684c4-112">一个<xref:System.Windows.Controls.ListBox>实现相关但不同的方法<xref:System.Windows.Controls.ListBox.ScrollIntoView%2A>。</span><span class="sxs-lookup"><span data-stu-id="684c4-112">A <xref:System.Windows.Controls.ListBox> implements a related but different method <xref:System.Windows.Controls.ListBox.ScrollIntoView%2A>.</span></span>  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.RequestBringIntoViewEventArgs" />
    <altmember cref="P:System.Windows.UIElement.ClipToBounds" />
    <altmember cref="T:System.Windows.Controls.Primitives.ScrollBar" />
    <altmember cref="T:System.Windows.Controls.ScrollViewer" />
    <altmember cref="M:System.Windows.FrameworkElement.BringIntoView(System.Windows.Rect)" />
    <altmember cref="M:System.Windows.LogicalTreeHelper.BringIntoView(System.Windows.DependencyObject)" />
  </Docs>
</Type>