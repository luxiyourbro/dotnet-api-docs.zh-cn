<Type Name="XmlSerializer" FullName="System.Xml.Serialization.XmlSerializer">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="27ab9939bf5a4c79ef30685cadd432730d74118c" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-CN" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36438815" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class XmlSerializer" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit XmlSerializer extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Xml.Serialization.XmlSerializer" />
  <TypeSignature Language="VB.NET" Value="Public Class XmlSerializer" />
  <TypeSignature Language="C++ CLI" Value="public ref class XmlSerializer" />
  <TypeSignature Language="F#" Value="type XmlSerializer = class" />
  <AssemblyInfo>
    <AssemblyName>System.Xml.XmlSerializer</AssemblyName>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Xml</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>在对象和 XML 文档之间进行序列化和反序列化操作。 <see cref="T:System.Xml.Serialization.XmlSerializer" /> 使您得以控制如何将对象编码到 XML 中。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 XML 序列化是将对象的公共属性和字段转换为序列格式（这里是指 XML）以便存储或传输的过程。 反序列化中重新创建对象的 XML 输出从其原始状态。 你可以将序列化视为一种方法将对象的状态保存到流或缓冲区。 例如，ASP.NET 使用<xref:System.Xml.Serialization.XmlSerializer>类 XML Web 服务消息进行编码。  
  
 对象中的数据是用编程语言构造来描述的，如类、字段、属性、基元类型、数组，甚至 <xref:System.Xml.XmlElement> 或 <xref:System.Xml.XmlAttribute> 对象形式的嵌入 XML。 你可以创建您自己的类，具有属性，或使用批注的选择[XML 架构定义工具 (Xsd.exe)](http://msdn.microsoft.com/library/a6e6e65c-347f-4494-9457-653bf29baac2)生成基于现有 XML 架构定义 (XSD) 文档的类。 如果你有一个 XML 架构，你可以运行 Xsd.exe 生成的类，强类型化为架构并使用要遵守序列化时的架构属性批注的一组。  
  
 若要将数据传输对象和 XML 之间需要映射到 XML 架构的编程语言构造从和 XML 架构的编程语言构造。 <xref:System.Xml.Serialization.XmlSerializer>和 Xsd.exe 等相关的工具提供这两种技术在同时设计时和运行时之间的桥梁。 在设计时，使用 Xsd.exe 从自定义类生成 XML 架构文档 (.xsd) 或生成从给定的架构的类。 在任一情况下，类进行批注使用自定义属性，以指示<xref:System.Xml.Serialization.XmlSerializer>如何 XML 架构系统和公共语言运行时之间进行映射。 在运行时，这些类的实例可以序列化为遵循给定的架构的 XML 文档。 同样，可以将这些 XML 文档反序列化到运行时对象中。 请注意，XML 架构是可选的在设计时或运行时并不是必需的。  
  
## <a name="controlling-generated-xml"></a>控制生成的 XML  
 若要控制生成的 XML，你可以应用于类和成员特殊属性。 例如，若要指定不同的 XML 元素名称，将应用<xref:System.Xml.Serialization.XmlElementAttribute>到一个公共字段或属性和一组<xref:System.Xml.Serialization.XmlElementAttribute.ElementName%2A>属性。 类似的属性的完整列表，请参阅[属性，控制 XML 序列化](http://msdn.microsoft.com/library/414b820f-a696-4206-b576-2711d85490c7)。 你也可以实现<xref:System.Xml.Serialization.IXmlSerializable>接口来控制 XML 输出。  
  
 如果生成的 XML 必须符合万维网联合会 (www.w3.org) 文档的第 5 节中，"简单对象访问协议 (SOAP) 1.1"，您必须先构造<xref:System.Xml.Serialization.XmlSerializer>与<xref:System.Xml.Serialization.XmlTypeMapping>。 若要进一步控制编码的 SOAP XML，使用中列出的属性[属性，控制编码 SOAP 序列化](http://msdn.microsoft.com/library/93ee258c-9c0f-4a08-897c-c10db7a00f91)。  
  
 与<xref:System.Xml.Serialization.XmlSerializer>可以充分利用的使用强类型化的类和仍具有 XML 的灵活性。 使用类型的字段或属性<xref:System.Xml.XmlElement>，<xref:System.Xml.XmlAttribute>或<xref:System.Xml.XmlNode>在强类型类中，你可以读入 XML 文档的各部分直接 XML 对象。  
  
 如果你使用可扩展的 XML 架构，你还可以使用<xref:System.Xml.Serialization.XmlAnyElementAttribute>和<xref:System.Xml.Serialization.XmlAnyAttributeAttribute>属性进行序列化和反序列化的原始架构中找不到元素或属性。 若要使用的对象，应用<xref:System.Xml.Serialization.XmlAnyElementAttribute>给返回的数组的字段<xref:System.Xml.XmlElement>对象，或应用<xref:System.Xml.Serialization.XmlAnyAttributeAttribute>给返回的数组的字段<xref:System.Xml.XmlAttribute>对象。  
  
 如果属性或字段返回一个复杂对象（如数组或类实例），则 <xref:System.Xml.Serialization.XmlSerializer> 将其转换为嵌套在主 XML 文档内的元素。 例如，下面的代码中的第一个类返回第二个类的实例。  
  
```vb  
Public Class MyClass  
    Public MyObjectProperty As MyObject  
End Class  
  
Public Class MyObject  
    Public ObjectName As String  
End Class  
```  
  
```csharp  
public class MyClass  
{  
    public MyObject MyObjectProperty;  
}  
public class MyObject  
{  
    public string ObjectName;  
}  
```  
  
 序列化，XML 输出如下所示：  
  
```  
<MyClass>  
  <MyObjectProperty>  
  <ObjectName>My String</ObjectName>  
  </MyObjectProperty>  
</MyClass>  
```  
  
 如果架构包含的元素将是可选 (minOccurs = '0')，或如果架构包含默认值，可以有两个选项。 一个选项是使用<xref:System.ComponentModel.DefaultValueAttribute?displayProperty=nameWithType>来指定默认值，在下面的代码所示。  
  
```vb  
Public Class PurchaseOrder  
    <System.ComponentModel.DefaultValueAttribute ("2002")> _  
    Public Year As String  
End Class  
```  
  
```csharp  
public class PurchaseOrder  
{  
    [System.ComponentModel.DefaultValueAttribute ("2002")]  
    public string Year;  
}  
```  
  
 另一个选项是使用特殊的模式创建布尔字段识别<xref:System.Xml.Serialization.XmlSerializer>，并将应用<xref:System.Xml.Serialization.XmlIgnoreAttribute>到字段。 模式创建的形式`propertyNameSpecified`。 例如，如果没有名为"MyFirstName"还将创建名为"MyFirstNameSpecified"的字段的字段指示<xref:System.Xml.Serialization.XmlSerializer>是否生成名为"MyFirstName"的 XML 元素。 这在下面的示例中显示。  
  
```vb  
Public Class OptionalOrder  
    ' This field's value should not be serialized   
    ' if it is uninitialized.  
    Public FirstOrder As String  
  
    ' Use the XmlIgnoreAttribute to ignore the   
    ' special field named "FirstOrderSpecified".  
    <System.Xml.Serialization.XmlIgnoreAttribute> _  
    Public FirstOrderSpecified As Boolean  
End Class  
```  
  
```csharp  
public class OptionalOrder  
{  
    // This field should not be serialized   
    // if it is uninitialized.  
    public string FirstOrder;  
  
    // Use the XmlIgnoreAttribute to ignore the   
    // special field named "FirstOrderSpecified".  
    [System.Xml.Serialization.XmlIgnoreAttribute]  
    public bool FirstOrderSpecified;  
}  
```  
  
## <a name="overriding-default-serialization"></a>重写默认序列化  
 你也可以通过创建一个适当的属性，并将其添加到的实例来替代序列化的对象及其字段和属性的任何集<xref:System.Xml.Serialization.XmlAttributes>类。 重写这种方式中的序列化有两个用途： 首先，你可以控制和增加的 DLL 中找到的对象序列化，即使到源，则不能访问其次，你可以创建一组可序列化的类，但采用多种方式对象进行序列化。 有关更多详细信息，请参阅<xref:System.Xml.Serialization.XmlAttributeOverrides>类和[如何： 控制序列化的派生类](http://msdn.microsoft.com/library/caa92596-9e15-4d91-acbe-56911ef47a84)。  
  
 若要序列化对象，调用<xref:System.Xml.Serialization.XmlSerializer.Serialize%2A>方法。 若要反序列化对象，调用<xref:System.Xml.Serialization.XmlSerializer.Deserialize%2A>方法。  
  
 若要将 XML 命名空间添加到 XML 文档，请参阅<xref:System.Xml.Serialization.XmlSerializerNamespaces>。  
  
> [!NOTE]
>  <xref:System.Xml.Serialization.XmlSerializer>提供到实现类的特殊处理<xref:System.Collections.IEnumerable>或<xref:System.Collections.ICollection>。 实现 <xref:System.Collections.IEnumerable> 的类必须实现采用单个参数的公共 `Add` 方法。 `Add`方法的参数必须是相同的类型是从返回`Current`上从返回的值的属性`GetEnumerator`，或者为该类型的基之一。 一个类以实现<xref:System.Collections.ICollection>(如<xref:System.Collections.CollectionBase>) 除了<xref:System.Collections.IEnumerable>必须具有一个公共`Item`索引属性 （C# 中的索引器） 采用一个整数，且它必须具有公共`Count`的整数类型的属性。 参数`Add`方法必须是同一类型，从返回`Item`属性，或者为该类型的基之一。 为类，该实现<xref:System.Collections.ICollection>，将检索要序列化的值从索引`Item`属性，不是通过调用`GetEnumerator`。  
  
 您必须有权写入到临时目录 （如由 TEMP 环境变量定义） 反序列化对象。  
  
## <a name="dynamically-generated-assemblies"></a>动态生成的程序集  
 为了提高性能，XML 序列化基础结构将动态生成要序列化和反序列化指定的类型的程序集。 基础结构找到并重新使用这些程序集。 仅在使用以下构造函数时，会出现此行为：  
  
 <xref:System.Xml.Serialization.XmlSerializer.%23ctor%28System.Type%29?displayProperty=nameWithType>  
  
 <xref:System.Xml.Serialization.XmlSerializer.%23ctor%28System.Type%2CSystem.String%29?displayProperty=nameWithType>  
  
 如果你使用任何其他构造函数，同一个程序集的多个版本生成，并永远不会卸载，从而导致内存泄漏和性能低下。 最简单的解决方案是使用前面所述的两个构造函数之一。 否则，你必须在其中缓存中的程序集<xref:System.Collections.Hashtable>，下面的示例中所示。  
  
```csharp  
Hashtable serializers = new Hashtable();  
  
// Use the constructor that takes a type and XmlRootAttribute.  
XmlSerializer s = new XmlSerializer(typeof(MyClass), myRoot);  
  
// Implement a method named GenerateKey that creates unique keys   
// for each instance of the XmlSerializer. The code should take   
// into account all parameters passed to the XmlSerializer   
// constructor.  
object key = GenerateKey(typeof(MyClass), myRoot);  
  
// Check the local cache for a matching serializer.  
XmlSerializer ser = (XmlSerializer)serializers[key];  
if (ser == null)   
{  
    ser = new XmlSerializer(typeof(MyClass), myRoot);  
    // Cache the serializer.  
    serializers[key] = ser;  
}  
else  
{  
    // Use the serializer to serialize, or deserialize.  
}  
```  
  
```vb  
Dim serializers As New Hashtable()  
  
' Use the constructor that takes a type and XmlRootAttribute.  
Dim s As New XmlSerializer(GetType([MyClass]), myRoot)  
  
' Implement a method named GenerateKey that creates unique keys   
' for each instance of the XmlSerializer. The code should take   
' into account all parameters passed to the XmlSerializer   
' constructor.  
Dim key As Object = GenerateKey(GetType([MyClass]), myRoot)  
  
' Check the local cache for a matching serializer.  
Dim ser As XmlSerializer = CType(serializers(key), XmlSerializer)  
  
If ser Is Nothing Then  
    ser = New XmlSerializer(GetType([MyClass]), myRoot)  
    ' Cache the serializer.  
    serializers(key) = ser  
Else   
    ' Use the serializer to serialize, or deserialize.  
End If  
```  
  
## <a name="serialization-of-arraylist-and-generic-list"></a>序列化 ArrayList 以及泛型列表  
 <xref:System.Xml.Serialization.XmlSerializer>无法序列化或反序列化以下：  
  
-   数组 <xref:System.Collections.ArrayList>  
  
-   数组 <xref:System.Collections.Generic.List%601>  
  
## <a name="serialization-of-enumerations-of-unsigned-long"></a>序列化的无符号长整型的枚举  
 <xref:System.Xml.Serialization.XmlSerializer>不能实例化以序列化枚举，如果以下条件为真： 枚举为无符号长整型 (`ulong` C# 中) 和枚举包含具有的值大于任何成员9223372036854775807。 例如，以下无法序列化。  
  
```  
public enum LargeNumbers: ulong  
{  
    a = 9223372036854775808  
}  
// At runtime, the following code will fail.  
xmlSerializer mySerializer=new XmlSerializer(typeof(LargeNumbers));  
```  
  
## <a name="objects-marked-with-the-obsolete-attribute-no-longer-serialized"></a>用过时不再序列化的属性标记的对象  
 在[!INCLUDE[netfx35_short](~/includes/netfx35-short-md.md)]<xref:System.Xml.Serialization.XmlSerializer>类不再将标记为的对象序列化为`[Obsolete]`。  
  
   
  
## Examples  
 下面的示例包含两个主要类：`PurchaseOrder`和`Test`。 `PurchaseOrder`类包含单个购买有关的信息。 `Test`类包含创建采购订单，以及读取创建的采购订单的方法。  
  
 [!code-cpp[Classic XmlSerializer Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic XmlSerializer Example/CPP/source.cpp#1)]
 [!code-csharp[Classic XmlSerializer Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic XmlSerializer Example/CS/source.cs#1)]
 [!code-vb[Classic XmlSerializer Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic XmlSerializer Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>此类型是线程安全的。</threadsafe>
    <altmember cref="T:System.Xml.Serialization.XmlAttributeOverrides" />
    <altmember cref="T:System.Xml.Serialization.XmlAttributes" />
    <altmember cref="T:System.Xml.Serialization.XmlSerializer" />
    <altmember cref="P:System.Xml.Serialization.XmlAttributes.XmlText" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlSerializer</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>初始化 <see cref="T:System.Xml.Serialization.XmlSerializer" /> 类的新实例。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected XmlSerializer ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Serialization.XmlSerializer.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; XmlSerializer();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlSerializer</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>初始化 <see cref="T:System.Xml.Serialization.XmlSerializer" /> 类的新实例。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XmlSerializer (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Serialization.XmlSerializer.#ctor(System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XmlSerializer(Type ^ type);" />
      <MemberSignature Language="F#" Value="new System.Xml.Serialization.XmlSerializer : Type -&gt; System.Xml.Serialization.XmlSerializer" Usage="new System.Xml.Serialization.XmlSerializer type" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlSerializer</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="type">此 <see cref="T:System.Xml.Serialization.XmlSerializer" /> 可序列化的对象的类型。</param>
        <summary>初始化 <see cref="T:System.Xml.Serialization.XmlSerializer" /> 类的新实例，该类可以将指定类型的对象序列化为 XML 文档，也可以将 XML 文档反序列化为指定类型的对象。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 通常情况下，应用程序定义了几个类的<xref:System.Xml.Serialization.XmlSerializer>将转换为单个 XML 实例文档。 但是，<xref:System.Xml.Serialization.XmlSerializer>必须知道只有一个类型-表示的 XML 根元素的类的类型。 <xref:System.Xml.Serialization.XmlSerializer>自动序列化所有从属类的实例。 同样，仅的 XML 根元素的类型是必需的反序列化的。  
  
   
  
## Examples  
 下面的示例构造<xref:System.Xml.Serialization.XmlSerializer>，将已命名的对象序列化为`Widget`。 该示例将之前调用该对象的各种属性<xref:System.Xml.Serialization.XmlSerializer.Serialize%2A>方法。  
  
 [!code-cpp[Classic XmlSerializer.XmlSerializer6 Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic XmlSerializer.XmlSerializer6 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic XmlSerializer.XmlSerializer6 Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic XmlSerializer.XmlSerializer6 Example/CS/source.cs#1)]
 [!code-vb[Classic XmlSerializer.XmlSerializer6 Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic XmlSerializer.XmlSerializer6 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Xml.Serialization.XmlSerializer.Serialize(System.IO.TextWriter,System.Object)" />
        <altmember cref="M:System.Xml.Serialization.XmlSerializer.Deserialize(System.IO.Stream)" />
        <altmember cref="T:System.Xml.Serialization.XmlAttributes" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XmlSerializer (System.Xml.Serialization.XmlTypeMapping xmlTypeMapping);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Xml.Serialization.XmlTypeMapping xmlTypeMapping) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Serialization.XmlSerializer.#ctor(System.Xml.Serialization.XmlTypeMapping)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XmlSerializer(System::Xml::Serialization::XmlTypeMapping ^ xmlTypeMapping);" />
      <MemberSignature Language="F#" Value="new System.Xml.Serialization.XmlSerializer : System.Xml.Serialization.XmlTypeMapping -&gt; System.Xml.Serialization.XmlSerializer" Usage="new System.Xml.Serialization.XmlSerializer xmlTypeMapping" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlSerializer</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="xmlTypeMapping" Type="System.Xml.Serialization.XmlTypeMapping" />
      </Parameters>
      <Docs>
        <param name="xmlTypeMapping">将一种类型映射到另一种类型的 <see cref="T:System.Xml.Serialization.XmlTypeMapping" />。</param>
        <summary>使用将一个类型映射到另一个类型的对象来初始化 <see cref="T:System.Xml.Serialization.XmlSerializer" /> 类的实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此构造函数用于创建<xref:System.Xml.Serialization.XmlSerializer>将对象序列化为 SOAP 消息。 若要控制生成的 SOAP 消息，请使用在中找到的特殊属性 （以单词"Soap"开头）<xref:System.Xml.Serialization>命名空间。  
  
   
  
## Examples  
 下面的示例序列化类名为`Group`。 序列化`GroupName`，`IgnoreThis`字段和的成员`GroupType`枚举将被重写。 在`CreateOverrideSerializer`方法，<xref:System.Xml.Serialization.SoapAttributeOverrides>对象在创建后，为每个重写的成员或枚举即<xref:System.Xml.Serialization.SoapAttributes>对象创建相应的属性设置，并添加到<xref:System.Xml.Serialization.SoapAttributeOverrides>对象。 <xref:System.Xml.Serialization.XmlMapping>对象使用创建<xref:System.Xml.Serialization.SoapAttributeOverrides>对象，并且<xref:System.Xml.Serialization.XmlMapping>对象用于创建<xref:System.Xml.Serialization.XmlSerializer>可重写默认的序列化。  
  
 [!code-cpp[SoapAttributesOverrides#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SoapAttributesOverrides/CPP/soapover.cpp#1)]
 [!code-csharp[SoapAttributesOverrides#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SoapAttributesOverrides/CS/soapover.cs#1)]
 [!code-vb[SoapAttributesOverrides#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/SoapAttributesOverrides/VB/SoapOver.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.Serialization.XmlAttributes" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XmlSerializer (Type type, string defaultNamespace);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Type type, string defaultNamespace) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Serialization.XmlSerializer.#ctor(System.Type,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XmlSerializer(Type ^ type, System::String ^ defaultNamespace);" />
      <MemberSignature Language="F#" Value="new System.Xml.Serialization.XmlSerializer : Type * string -&gt; System.Xml.Serialization.XmlSerializer" Usage="new System.Xml.Serialization.XmlSerializer (type, defaultNamespace)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlSerializer</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="defaultNamespace" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">此 <see cref="T:System.Xml.Serialization.XmlSerializer" /> 可序列化的对象的类型。</param>
        <param name="defaultNamespace">用于所有 XML 元素的默认命名空间。</param>
        <summary>初始化 <see cref="T:System.Xml.Serialization.XmlSerializer" /> 类的新实例，该类可以将指定类型的对象序列化为 XML 文档，也可以将 XML 文档反序列化为指定类型的对象。 指定所有 XML 元素的默认命名空间。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下面的示例构造<xref:System.Xml.Serialization.XmlSerializer>，将已命名的对象序列化为`Widget`。 该示例将之前调用该对象的各种属性<xref:System.Xml.Serialization.XmlSerializer.Serialize%2A>方法。  
  
 [!code-cpp[Classic XmlSerializer.XmlSerializer1 Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic XmlSerializer.XmlSerializer1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic XmlSerializer.XmlSerializer1 Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic XmlSerializer.XmlSerializer1 Example/CS/source.cs#1)]
 [!code-vb[Classic XmlSerializer.XmlSerializer1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic XmlSerializer.XmlSerializer1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.Serialization.XmlAttributes" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XmlSerializer (Type type, Type[] extraTypes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Type type, class System.Type[] extraTypes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Serialization.XmlSerializer.#ctor(System.Type,System.Type[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XmlSerializer(Type ^ type, cli::array &lt;Type ^&gt; ^ extraTypes);" />
      <MemberSignature Language="F#" Value="new System.Xml.Serialization.XmlSerializer : Type * Type[] -&gt; System.Xml.Serialization.XmlSerializer" Usage="new System.Xml.Serialization.XmlSerializer (type, extraTypes)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlSerializer</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="extraTypes" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="type">此 <see cref="T:System.Xml.Serialization.XmlSerializer" /> 可序列化的对象的类型。</param>
        <param name="extraTypes">要序列化的其他对象类型的 <see cref="T:System.Type" /> 数组。</param>
        <summary>初始化 <see cref="T:System.Xml.Serialization.XmlSerializer" /> 类的新实例，该类可以将指定类型的对象序列化为 XML 文档，也可以将 XML 文档反序列化为指定类型的对象。 如果属性或字段返回一个数组，则 <paramref name="extraTypes" /> 参数指定可插入到该数组的对象。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 默认情况下，如果公共属性或字段返回一个对象或数组的对象，将自动序列的对象类型。 但是，如果类包含的字段或属性的返回类型的数组<xref:System.Object>，任何对象可以插入到该数组。 在这种情况下，<xref:System.Xml.Serialization.XmlSerializer>预期插入到的所有可能的对象类型，必须指示<xref:System.Object>数组。 若要执行此操作，使用`extraTypes`参数来指定要序列化或反序列化的额外的对象类型。  
  
 你还可以使用`extraTypes`参数来指定类型派生自的基类。 例如，假设一个名为的基本类`Phone`存在，和一个名为类`InternationalPhone`派生自它。 使用`extraTypes`参数来指定派生的类型。  
  
   
  
## Examples  
 下面的示例序列化包含返回的对象数组的公共字段的类的实例。 `extraTypes`参数<xref:System.Xml.Serialization.XmlSerializer>构造函数指定数组中的可序列化的对象的类型。  
  
 [!code-cpp[Classic XmlSerializer.XmlSerializer3 Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic XmlSerializer.XmlSerializer3 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic XmlSerializer.XmlSerializer3 Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic XmlSerializer.XmlSerializer3 Example/CS/source.cs#1)]
 [!code-vb[Classic XmlSerializer.XmlSerializer3 Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic XmlSerializer.XmlSerializer3 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.Serialization.XmlAttributes" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XmlSerializer (Type type, System.Xml.Serialization.XmlAttributeOverrides overrides);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Type type, class System.Xml.Serialization.XmlAttributeOverrides overrides) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Serialization.XmlSerializer.#ctor(System.Type,System.Xml.Serialization.XmlAttributeOverrides)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XmlSerializer(Type ^ type, System::Xml::Serialization::XmlAttributeOverrides ^ overrides);" />
      <MemberSignature Language="F#" Value="new System.Xml.Serialization.XmlSerializer : Type * System.Xml.Serialization.XmlAttributeOverrides -&gt; System.Xml.Serialization.XmlSerializer" Usage="new System.Xml.Serialization.XmlSerializer (type, overrides)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlSerializer</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="overrides" Type="System.Xml.Serialization.XmlAttributeOverrides" />
      </Parameters>
      <Docs>
        <param name="type">要序列化的对象的类型。</param>
        <param name="overrides">一个 <see cref="T:System.Xml.Serialization.XmlAttributeOverrides" />。</param>
        <summary>初始化 <see cref="T:System.Xml.Serialization.XmlSerializer" /> 类的新实例，该类可以将指定类型的对象序列化为 XML 文档，也可以将 XML 文档反序列化为指定类型的对象。 要序列化的每个对象本身可包含类的实例，此重载可使用其他类重写这些实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `overrides`参数可以用于控制如何以 xml 格式编码字段和属性。 这些设置将覆盖任何存在的对象的属性。 无法修改的源代码或多个编码所需的相同的类时，这很有用。  
  
   
  
## Examples  
 下面的示例序列化定义在 DLL 中，并为此，将替代在 DLL 中找到的公共成员的类的实例。  
  
 [!code-cpp[Classic XmlSerializer.XmlSerializer4 Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic XmlSerializer.XmlSerializer4 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic XmlSerializer.XmlSerializer4 Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic XmlSerializer.XmlSerializer4 Example/CS/source.cs#1)]
 [!code-vb[Classic XmlSerializer.XmlSerializer4 Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic XmlSerializer.XmlSerializer4 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.Serialization.XmlAttributeOverrides" />
        <altmember cref="T:System.Xml.Serialization.XmlAttributes" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XmlSerializer (Type type, System.Xml.Serialization.XmlRootAttribute root);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Type type, class System.Xml.Serialization.XmlRootAttribute root) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Serialization.XmlSerializer.#ctor(System.Type,System.Xml.Serialization.XmlRootAttribute)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XmlSerializer(Type ^ type, System::Xml::Serialization::XmlRootAttribute ^ root);" />
      <MemberSignature Language="F#" Value="new System.Xml.Serialization.XmlSerializer : Type * System.Xml.Serialization.XmlRootAttribute -&gt; System.Xml.Serialization.XmlSerializer" Usage="new System.Xml.Serialization.XmlSerializer (type, root)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlSerializer</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="root" Type="System.Xml.Serialization.XmlRootAttribute" />
      </Parameters>
      <Docs>
        <param name="type">此 <see cref="T:System.Xml.Serialization.XmlSerializer" /> 可序列化的对象的类型。</param>
        <param name="root">表示 XML 根元素的 <see cref="T:System.Xml.Serialization.XmlRootAttribute" />。</param>
        <summary>初始化 <see cref="T:System.Xml.Serialization.XmlSerializer" /> 类的新实例，该类可以将指定类型的对象序列化为 XML 文档，也可以将 XML 文档反序列化为指定类型的对象。 还可以指定作为 XML 根元素使用的类。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 XML 文档的根元素包括所有其他元素。 默认情况下，通过将指定的对象`type`参数序列化为根元素。 属性，如 XML 元素名称的根元素中，将从`type`对象。 但是，`root`参数使你可以通过指定替换默认对象的信息<xref:System.Xml.Serialization.XmlRootAttribute>; 的对象允许你设置不同的命名空间、 元素名称和等等。  
  
   
  
## Examples  
 下面的示例构造<xref:System.Xml.Serialization.XmlSerializer>使用<xref:System.Xml.Serialization.XmlRootAttribute>包含各种属性的 XML 根元素，如其命名空间和元素的名称。  
  
 [!code-cpp[Classic XmlSerializer.XmlSerializer2 Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic XmlSerializer.XmlSerializer2 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic XmlSerializer.XmlSerializer2 Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic XmlSerializer.XmlSerializer2 Example/CS/source.cs#1)]
 [!code-vb[Classic XmlSerializer.XmlSerializer2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic XmlSerializer.XmlSerializer2 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.Serialization.XmlAttributes" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XmlSerializer (Type type, System.Xml.Serialization.XmlAttributeOverrides overrides, Type[] extraTypes, System.Xml.Serialization.XmlRootAttribute root, string defaultNamespace);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Type type, class System.Xml.Serialization.XmlAttributeOverrides overrides, class System.Type[] extraTypes, class System.Xml.Serialization.XmlRootAttribute root, string defaultNamespace) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Serialization.XmlSerializer.#ctor(System.Type,System.Xml.Serialization.XmlAttributeOverrides,System.Type[],System.Xml.Serialization.XmlRootAttribute,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XmlSerializer(Type ^ type, System::Xml::Serialization::XmlAttributeOverrides ^ overrides, cli::array &lt;Type ^&gt; ^ extraTypes, System::Xml::Serialization::XmlRootAttribute ^ root, System::String ^ defaultNamespace);" />
      <MemberSignature Language="F#" Value="new System.Xml.Serialization.XmlSerializer : Type * System.Xml.Serialization.XmlAttributeOverrides * Type[] * System.Xml.Serialization.XmlRootAttribute * string -&gt; System.Xml.Serialization.XmlSerializer" Usage="new System.Xml.Serialization.XmlSerializer (type, overrides, extraTypes, root, defaultNamespace)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlSerializer</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="overrides" Type="System.Xml.Serialization.XmlAttributeOverrides" />
        <Parameter Name="extraTypes" Type="System.Type[]" />
        <Parameter Name="root" Type="System.Xml.Serialization.XmlRootAttribute" />
        <Parameter Name="defaultNamespace" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">此 <see cref="T:System.Xml.Serialization.XmlSerializer" /> 可序列化的对象的类型。</param>
        <param name="overrides">一个 <see cref="T:System.Xml.Serialization.XmlAttributeOverrides" />，它扩展或重写<c>type</c> 参数中指定类的行为。</param>
        <param name="extraTypes">要序列化的其他对象类型的 <see cref="T:System.Type" /> 数组。</param>
        <param name="root">定义 XML 根元素属性的 <see cref="T:System.Xml.Serialization.XmlRootAttribute" />。</param>
        <param name="defaultNamespace">XML 文档中所有 XML 元素的默认命名空间。</param>
        <summary>初始化 <see cref="T:System.Xml.Serialization.XmlSerializer" /> 类的新实例，该类可将 <see cref="T:System.Object" /> 类型的对象序列化为 XML 文档实例，并可将 XML 文档实例反序列化为 <see cref="T:System.Object" /> 类型的对象。 要序列化的每个对象本身可包含类的实例，此重载可使用其他类重写这些实例。 此重载还指定所有 XML 元素的默认命名空间和用作 XML 根元素的类。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `overrides`参数允许进行创建 [XmlSerializer 构造函数 (类型，XmlAttributeOverrides，Type\<xref:System.Xml.Serialization.XmlSerializer >，序列化扩展或重写的行为的类基本类。 例如，假如有一个 DLL，它是可以创建继承或扩展 DLL 中包含的类的类。 要序列化此类，必须使用的实例 [XmlSerializer 构造函数 (类型，XmlAttributeOverrides，Type\<xref:System.Xml.Serialization.XmlAttributeOverrides > 类构造 [XmlSerializer 构造函数 （时类型，XmlAttributeOverrides，Type\<xref:System.Xml.Serialization.XmlSerializer >。 有关更多详细信息，请参阅 [XmlSerializer 构造函数 (类型，XmlAttributeOverrides，Type\<xref:System.Xml.Serialization.XmlAttributeOverrides >。  
  
 默认情况下，如果公共属性或字段返回一个对象或数组的对象，将自动序列的对象类型。 但是，如果类包含的字段或属性的返回类型的数组 [XmlSerializer 构造函数 (类型，XmlAttributeOverrides，Type\<xref:System.Object >，任何对象可以插入到该数组。 在这种情况下，[XmlSerializer 构造函数 (类型，XmlAttributeOverrides，Type\<xref:System.Xml.Serialization.XmlSerializer > 需要插入到 [XmlSerializer 的所有可能的对象类型，必须指示构造函数 (类型，XmlAttributeOverrides，Type\<xref:System.Object > 数组。 若要执行此操作，使用`extraTypes`参数来指定要序列化或反序列化的额外的对象类型。  
  
 XML 文档的根元素包括所有其他元素。 默认情况下，通过将指定的对象`type`参数序列化为根元素。 属性，如 XML 元素名称的根元素，将从`type`对象。 但是，`root`参数使你可以通过指定替换默认对象的信息 [XmlSerializer 构造函数 (类型，XmlAttributeOverrides，Type\<xref:System.Xml.Serialization.XmlRootAttribute >;对象允许你设置不同的命名空间、 元素名称和等等。  
  
 使用`defaultName`参数来指定由生成的所有 XML 元素的默认命名空间 [XmlSerializer 构造函数 (类型，XmlAttributeOverrides，Type\<xref:System.Xml.Serialization.XmlSerializer >。  
  
   
  
## Examples  
 下面的示例序列化在 DLL 中，并为此定义，因此重写在类中找到的公共成员的类的实例。 该示例还指定额外类型外，所有 XML 元素和要使用提供的 XML 根元素信息的类的默认命名空间的数组。 该示例假定开头的代码已被编译到名为 DLL `HighSchool`。  
  
 [!code-cpp[Classic XmlSerializer.XmlSerializer Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic XmlSerializer.XmlSerializer Example/CPP/source.cpp#1)]
 [!code-csharp[Classic XmlSerializer.XmlSerializer Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic XmlSerializer.XmlSerializer Example/CS/source.cs#1)]
 [!code-vb[Classic XmlSerializer.XmlSerializer Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic XmlSerializer.XmlSerializer Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.Serialization.XmlAttributeOverrides" />
        <altmember cref="T:System.Xml.Serialization.XmlRootAttribute" />
        <altmember cref="T:System.Xml.Serialization.XmlAttributes" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XmlSerializer (Type type, System.Xml.Serialization.XmlAttributeOverrides overrides, Type[] extraTypes, System.Xml.Serialization.XmlRootAttribute root, string defaultNamespace, string location);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Type type, class System.Xml.Serialization.XmlAttributeOverrides overrides, class System.Type[] extraTypes, class System.Xml.Serialization.XmlRootAttribute root, string defaultNamespace, string location) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Serialization.XmlSerializer.#ctor(System.Type,System.Xml.Serialization.XmlAttributeOverrides,System.Type[],System.Xml.Serialization.XmlRootAttribute,System.String,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XmlSerializer(Type ^ type, System::Xml::Serialization::XmlAttributeOverrides ^ overrides, cli::array &lt;Type ^&gt; ^ extraTypes, System::Xml::Serialization::XmlRootAttribute ^ root, System::String ^ defaultNamespace, System::String ^ location);" />
      <MemberSignature Language="F#" Value="new System.Xml.Serialization.XmlSerializer : Type * System.Xml.Serialization.XmlAttributeOverrides * Type[] * System.Xml.Serialization.XmlRootAttribute * string * string -&gt; System.Xml.Serialization.XmlSerializer" Usage="new System.Xml.Serialization.XmlSerializer (type, overrides, extraTypes, root, defaultNamespace, location)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlSerializer</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="overrides" Type="System.Xml.Serialization.XmlAttributeOverrides" />
        <Parameter Name="extraTypes" Type="System.Type[]" />
        <Parameter Name="root" Type="System.Xml.Serialization.XmlRootAttribute" />
        <Parameter Name="defaultNamespace" Type="System.String" />
        <Parameter Name="location" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">此 <see cref="T:System.Xml.Serialization.XmlSerializer" /> 可序列化的对象的类型。</param>
        <param name="overrides">一个 <see cref="T:System.Xml.Serialization.XmlAttributeOverrides" />，它扩展或重写<c>type</c> 参数中指定类的行为。</param>
        <param name="extraTypes">要序列化的其他对象类型的 <see cref="T:System.Type" /> 数组。</param>
        <param name="root">定义 XML 根元素属性的 <see cref="T:System.Xml.Serialization.XmlRootAttribute" />。</param>
        <param name="defaultNamespace">XML 文档中所有 XML 元素的默认命名空间。</param>
        <param name="location">该类型的位置。</param>
        <summary>初始化 <see cref="T:System.Xml.Serialization.XmlSerializer" /> 类的新实例，该类可将 <see cref="T:System.Object" /> 类型的对象序列化为 XML 文档实例，并可将 XML 文档实例反序列化为 <see cref="T:System.Object" /> 类型的对象。 要序列化的每个对象本身可包含类的实例，此重载可使用其他类重写这些实例。 此重载还指定所有 XML 元素的默认命名空间和用作 XML 根元素的类。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XmlSerializer (Type type, System.Xml.Serialization.XmlAttributeOverrides overrides, Type[] extraTypes, System.Xml.Serialization.XmlRootAttribute root, string defaultNamespace, string location, System.Security.Policy.Evidence evidence);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Type type, class System.Xml.Serialization.XmlAttributeOverrides overrides, class System.Type[] extraTypes, class System.Xml.Serialization.XmlRootAttribute root, string defaultNamespace, string location, class System.Security.Policy.Evidence evidence) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Serialization.XmlSerializer.#ctor(System.Type,System.Xml.Serialization.XmlAttributeOverrides,System.Type[],System.Xml.Serialization.XmlRootAttribute,System.String,System.String,System.Security.Policy.Evidence)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XmlSerializer(Type ^ type, System::Xml::Serialization::XmlAttributeOverrides ^ overrides, cli::array &lt;Type ^&gt; ^ extraTypes, System::Xml::Serialization::XmlRootAttribute ^ root, System::String ^ defaultNamespace, System::String ^ location, System::Security::Policy::Evidence ^ evidence);" />
      <MemberSignature Language="F#" Value="new System.Xml.Serialization.XmlSerializer : Type * System.Xml.Serialization.XmlAttributeOverrides * Type[] * System.Xml.Serialization.XmlRootAttribute * string * string * System.Security.Policy.Evidence -&gt; System.Xml.Serialization.XmlSerializer" Usage="new System.Xml.Serialization.XmlSerializer (type, overrides, extraTypes, root, defaultNamespace, location, evidence)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("This method is obsolete and will be removed in a future release of the .NET Framework. Please use a XmlSerializer constructor overload which does not take an Evidence parameter. See http://go2.microsoft.com/fwlink/?LinkId=131738 for more information.")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="overrides" Type="System.Xml.Serialization.XmlAttributeOverrides" />
        <Parameter Name="extraTypes" Type="System.Type[]" />
        <Parameter Name="root" Type="System.Xml.Serialization.XmlRootAttribute" />
        <Parameter Name="defaultNamespace" Type="System.String" />
        <Parameter Name="location" Type="System.String" />
        <Parameter Name="evidence" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="type">此 <see cref="T:System.Xml.Serialization.XmlSerializer" /> 可序列化的对象的类型。</param>
        <param name="overrides">一个 <see cref="T:System.Xml.Serialization.XmlAttributeOverrides" />，它扩展或重写<c>type</c> 参数中指定类的行为。</param>
        <param name="extraTypes">要序列化的其他对象类型的 <see cref="T:System.Type" /> 数组。</param>
        <param name="root">定义 XML 根元素属性的 <see cref="T:System.Xml.Serialization.XmlRootAttribute" />。</param>
        <param name="defaultNamespace">XML 文档中所有 XML 元素的默认命名空间。</param>
        <param name="location">该类型的位置。</param>
        <param name="evidence">
          <see cref="T:System.Security.Policy.Evidence" /> 类的实例，其中包含访问类型所需的凭据。</param>
        <summary>初始化 <see cref="T:System.Xml.Serialization.XmlSerializer" /> 类的新实例，该类可以将指定类型的对象序列化为 XML 文档，也可以将 XML 文档反序列化为指定类型的对象。 此重载允许您提供在序列化或反序列化操作过程中可能遇到的其他类型；还允许您提供所有 XML 元素的默认命名空间，作为 XML 根元素使用的类，类的位置和访问所需的凭据。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 允许更精确地控制到临时目录的访问并阻止注入代码和利用。 若要使用此方法，指定的位置，并仅向特定用户授予访问。 管理员可以设置策略的证据列表的匹配权限的证据。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanDeserialize">
      <MemberSignature Language="C#" Value="public virtual bool CanDeserialize (System.Xml.XmlReader xmlReader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool CanDeserialize(class System.Xml.XmlReader xmlReader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Serialization.XmlSerializer.CanDeserialize(System.Xml.XmlReader)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool CanDeserialize(System::Xml::XmlReader ^ xmlReader);" />
      <MemberSignature Language="F#" Value="abstract member CanDeserialize : System.Xml.XmlReader -&gt; bool&#xA;override this.CanDeserialize : System.Xml.XmlReader -&gt; bool" Usage="xmlSerializer.CanDeserialize xmlReader" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlSerializer</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="xmlReader" Type="System.Xml.XmlReader" />
      </Parameters>
      <Docs>
        <param name="xmlReader">指向要反序列化的文档的 <see cref="T:System.Xml.XmlReader" />。</param>
        <summary>获取一个值，该值指示此 <see cref="T:System.Xml.Serialization.XmlSerializer" /> 是否可以反序列化指定的 XML 文档。</summary>
        <returns>如果此 <see cref="T:System.Xml.Serialization.XmlSerializer" /> 可以反序列化 <see cref="T:System.Xml.XmlReader" /> 指向的对象，则为 <see langword="true" />，否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下面的示例调用<xref:System.Xml.Serialization.XmlSerializer.CanDeserialize%2A>方法检查 XML 文档是否可以反序列化。  
  
 [!code-cpp[Classic XmlSerializer.CanDeserialize Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic XmlSerializer.CanDeserialize Example/CPP/source.cpp#1)]
 [!code-csharp[Classic XmlSerializer.CanDeserialize Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic XmlSerializer.CanDeserialize Example/CS/source.cs#1)]
 [!code-vb[Classic XmlSerializer.CanDeserialize Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic XmlSerializer.CanDeserialize Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Xml.Serialization.XmlSerializer.Deserialize(System.IO.Stream)" />
      </Docs>
    </Member>
    <Member MemberName="CreateReader">
      <MemberSignature Language="C#" Value="protected virtual System.Xml.Serialization.XmlSerializationReader CreateReader ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Xml.Serialization.XmlSerializationReader CreateReader() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Serialization.XmlSerializer.CreateReader" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function CreateReader () As XmlSerializationReader" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Xml::Serialization::XmlSerializationReader ^ CreateReader();" />
      <MemberSignature Language="F#" Value="abstract member CreateReader : unit -&gt; System.Xml.Serialization.XmlSerializationReader&#xA;override this.CreateReader : unit -&gt; System.Xml.Serialization.XmlSerializationReader" Usage="xmlSerializer.CreateReader " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlSerializer</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Serialization.XmlSerializationReader</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回一个对象，该对象用于读取要进行序列化的 XML 文档。</summary>
        <returns>一个用于读取 XML 文档的 <see cref="T:System.Xml.Serialization.XmlSerializationReader" />。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotImplementedException">当未在子类中重写该方法时，为访问该方法进行的任何尝试。</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateWriter">
      <MemberSignature Language="C#" Value="protected virtual System.Xml.Serialization.XmlSerializationWriter CreateWriter ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Xml.Serialization.XmlSerializationWriter CreateWriter() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Serialization.XmlSerializer.CreateWriter" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function CreateWriter () As XmlSerializationWriter" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Xml::Serialization::XmlSerializationWriter ^ CreateWriter();" />
      <MemberSignature Language="F#" Value="abstract member CreateWriter : unit -&gt; System.Xml.Serialization.XmlSerializationWriter&#xA;override this.CreateWriter : unit -&gt; System.Xml.Serialization.XmlSerializationWriter" Usage="xmlSerializer.CreateWriter " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlSerializer</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Serialization.XmlSerializationWriter</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>当在派生类中重写时，返回用于序列化对象的编写器。</summary>
        <returns>实现 <see cref="T:System.Xml.Serialization.XmlSerializationWriter" /> 类的实例。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotImplementedException">当未在子类中重写该方法时，为访问该方法进行的任何尝试。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Deserialize">
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlSerializer</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>反序列化 XML 文档。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Deserialize">
      <MemberSignature Language="C#" Value="public object Deserialize (System.IO.Stream stream);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object Deserialize(class System.IO.Stream stream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Serialization.XmlSerializer.Deserialize(System.IO.Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ Deserialize(System::IO::Stream ^ stream);" />
      <MemberSignature Language="F#" Value="member this.Deserialize : System.IO.Stream -&gt; obj" Usage="xmlSerializer.Deserialize stream" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlSerializer</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="stream">包含要反序列化的 XML 文档的 <see cref="T:System.IO.Stream" />。</param>
        <summary>反序列化指定 <see cref="T:System.IO.Stream" /> 包含的 XML 文档。</summary>
        <returns>正被反序列化的 <see cref="T:System.Object" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 反序列化是读取 XML 文档，并构造强类型化为文档 XML 架构 (XSD) 的对象的过程。  
  
 在反序列化之前,<xref:System.Xml.Serialization.XmlSerializer>必须使用要反序列化的对象的类型构造。  
  
 使用`stream`参数来指定派生自对象<xref:System.IO.Stream>类，该类用于写入流。 派生自的类<xref:System.IO.Stream>类包括：  
  
-   <xref:System.IO.BufferedStream>  
  
-   <xref:System.IO.FileStream>  
  
-   <xref:System.IO.MemoryStream>  
  
-   <xref:System.Net.Sockets.NetworkStream>  
  
-   <xref:System.Security.Cryptography.CryptoStream>  
  
> [!NOTE]
>  <xref:System.Xml.Serialization.XmlSerializer>无法反序列化以下： 数组<xref:System.Collections.ArrayList>和数组<xref:System.Collections.Generic.List%601>。  
  
   
  
## Examples  
 下面的示例进行反序列化对象使用<xref:System.IO.Stream>对象。  
  
 [!code-cpp[Classic XmlSerializer.Deserialize Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic XmlSerializer.Deserialize Example/CPP/source.cpp#1)]
 [!code-csharp[Classic XmlSerializer.Deserialize Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic XmlSerializer.Deserialize Example/CS/source.cs#1)]
 [!code-vb[Classic XmlSerializer.Deserialize Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic XmlSerializer.Deserialize Example/VB/source.vb#1)]
 [!code-xml[Classic XmlSerializer.Deserialize Example#1](~/samples/snippets/common/VS_Snippets_Remoting/Classic XmlSerializer.Deserialize Example/Common/simple.xml#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.Serialization.XmlAttributes" />
        <altmember cref="M:System.Xml.Serialization.XmlSerializer.CanDeserialize(System.Xml.XmlReader)" />
        <altmember cref="M:System.Xml.Serialization.XmlSerializer.Serialize(System.IO.TextWriter,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Deserialize">
      <MemberSignature Language="C#" Value="public object Deserialize (System.IO.TextReader textReader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object Deserialize(class System.IO.TextReader textReader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Serialization.XmlSerializer.Deserialize(System.IO.TextReader)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ Deserialize(System::IO::TextReader ^ textReader);" />
      <MemberSignature Language="F#" Value="member this.Deserialize : System.IO.TextReader -&gt; obj" Usage="xmlSerializer.Deserialize textReader" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlSerializer</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="textReader" Type="System.IO.TextReader" />
      </Parameters>
      <Docs>
        <param name="textReader">包含要反序列化的 XML 文档的 <see cref="T:System.IO.TextReader" />。</param>
        <summary>反序列化指定 <see cref="T:System.IO.TextReader" /> 包含的 XML 文档。</summary>
        <returns>正被反序列化的 <see cref="T:System.Object" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 反序列化是： 读取的 XML 文档实例，并构造的对象被强类型化为 XML 架构 (XSD) 文档的过程。  
  
 在反序列化之前,<xref:System.Xml.Serialization.XmlSerializer>必须使用要反序列化的对象的类型构造。  
  
 继承自的类<xref:System.IO.TextReader>包括<xref:System.IO.StringReader>和<xref:System.IO.StreamReader>。 如果你使用<xref:System.IO.StreamReader>进行反序列化对象，您必须先构造<xref:System.IO.StreamReader>与相应<xref:System.Text.Encoding>。 指定的 XML 文档的编码将被忽略。  
  
> [!NOTE]
>  若要使用指定的 XML 文档的编码，使用<xref:System.Xml.Serialization.XmlSerializer.Deserialize%2A>采用重载<xref:System.Xml.XmlReader>相反。 <xref:System.Xml.XmlReader>自动检测并使用指定的 XML 文档的编码。  
  
> [!NOTE]
>  <xref:System.Xml.Serialization.XmlSerializer>无法反序列化以下： 数组<xref:System.Collections.ArrayList>和数组<xref:System.Collections.Generic.List%601>。  
  
   
  
## Examples  
 下面的示例进行反序列化对象使用<xref:System.IO.TextReader>对象。  
  
 [!code-cpp[Classic XmlSerializer.Deserialize1 Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic XmlSerializer.Deserialize1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic XmlSerializer.Deserialize1 Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic XmlSerializer.Deserialize1 Example/CS/source.cs#1)]
 [!code-vb[Classic XmlSerializer.Deserialize1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic XmlSerializer.Deserialize1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">反序列化期间发生错误。 使用 <see cref="P:System.Exception.InnerException" /> 属性时可使用原始异常。</exception>
        <altmember cref="T:System.Xml.Serialization.XmlAttributes" />
        <altmember cref="M:System.Xml.Serialization.XmlSerializer.CanDeserialize(System.Xml.XmlReader)" />
        <altmember cref="M:System.Xml.Serialization.XmlSerializer.Serialize(System.IO.TextWriter,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Deserialize">
      <MemberSignature Language="C#" Value="protected virtual object Deserialize (System.Xml.Serialization.XmlSerializationReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance object Deserialize(class System.Xml.Serialization.XmlSerializationReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Serialization.XmlSerializer.Deserialize(System.Xml.Serialization.XmlSerializationReader)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function Deserialize (reader As XmlSerializationReader) As Object" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Object ^ Deserialize(System::Xml::Serialization::XmlSerializationReader ^ reader);" />
      <MemberSignature Language="F#" Value="abstract member Deserialize : System.Xml.Serialization.XmlSerializationReader -&gt; obj&#xA;override this.Deserialize : System.Xml.Serialization.XmlSerializationReader -&gt; obj" Usage="xmlSerializer.Deserialize reader" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlSerializer</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.Serialization.XmlSerializationReader" />
      </Parameters>
      <Docs>
        <param name="reader">包含要反序列化的 XML 文档的 <see cref="T:System.Xml.Serialization.XmlSerializationReader" />。</param>
        <summary>反序列化指定 <see cref="T:System.Xml.Serialization.XmlSerializationReader" /> 包含的 XML 文档。</summary>
        <returns>反序列化的对象。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotImplementedException">当未在子类中重写该方法时，为访问该方法进行的任何尝试。</exception>
      </Docs>
    </Member>
    <Member MemberName="Deserialize">
      <MemberSignature Language="C#" Value="public object Deserialize (System.Xml.XmlReader xmlReader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object Deserialize(class System.Xml.XmlReader xmlReader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Serialization.XmlSerializer.Deserialize(System.Xml.XmlReader)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ Deserialize(System::Xml::XmlReader ^ xmlReader);" />
      <MemberSignature Language="F#" Value="member this.Deserialize : System.Xml.XmlReader -&gt; obj" Usage="xmlSerializer.Deserialize xmlReader" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlSerializer</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="xmlReader" Type="System.Xml.XmlReader" />
      </Parameters>
      <Docs>
        <param name="xmlReader">包含要反序列化的 XML 文档的 <see cref="T:System.Xml.XmlReader" />。</param>
        <summary>反序列化指定 <see cref="T:System.Xml.XmlReader" /> 包含的 XML 文档。</summary>
        <returns>正被反序列化的 <see cref="T:System.Object" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 反序列化是： 读取的 XML 文档实例，并构造的对象被强类型化为 XML 架构 (XSD) 文档的过程。  
  
 在反序列化之前,<xref:System.Xml.Serialization.XmlSerializer>必须使用要反序列化的对象的类型构造。  
  
 <xref:System.Xml.XmlReader>自动检测并使用指定的 XML 文档的编码。  
  
> [!NOTE]
>  <xref:System.Xml.Serialization.XmlSerializer>无法反序列化以下： 数组<xref:System.Collections.ArrayList>和数组<xref:System.Collections.Generic.List%601>。  
  
   
  
## Examples  
 下面的示例进行反序列化对象使用<xref:System.Xml.XmlReader>。  
  
 [!code-cpp[Classic XmlSerializer.Deserialize2 Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic XmlSerializer.Deserialize2 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic XmlSerializer.Deserialize2 Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic XmlSerializer.Deserialize2 Example/CS/source.cs#1)]
 [!code-vb[Classic XmlSerializer.Deserialize2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic XmlSerializer.Deserialize2 Example/VB/source.vb#1)]
 [!code-xml[Classic XmlSerializer.Deserialize2 Example#1](~/samples/snippets/common/VS_Snippets_Remoting/Classic XmlSerializer.Deserialize2 Example/Common/simple.xml#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">反序列化期间发生错误。 使用 <see cref="P:System.Exception.InnerException" /> 属性时可使用原始异常。</exception>
        <altmember cref="T:System.Xml.Serialization.XmlAttributes" />
        <altmember cref="M:System.Xml.Serialization.XmlSerializer.CanDeserialize(System.Xml.XmlReader)" />
        <altmember cref="M:System.Xml.Serialization.XmlSerializer.Serialize(System.IO.TextWriter,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Deserialize">
      <MemberSignature Language="C#" Value="public object Deserialize (System.Xml.XmlReader xmlReader, string encodingStyle);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object Deserialize(class System.Xml.XmlReader xmlReader, string encodingStyle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Serialization.XmlSerializer.Deserialize(System.Xml.XmlReader,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ Deserialize(System::Xml::XmlReader ^ xmlReader, System::String ^ encodingStyle);" />
      <MemberSignature Language="F#" Value="member this.Deserialize : System.Xml.XmlReader * string -&gt; obj" Usage="xmlSerializer.Deserialize (xmlReader, encodingStyle)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlSerializer</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="xmlReader" Type="System.Xml.XmlReader" />
        <Parameter Name="encodingStyle" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="xmlReader">包含要反序列化的 XML 文档的 <see cref="T:System.Xml.XmlReader" />。</param>
        <param name="encodingStyle">序列化的 XML 的编码样式。</param>
        <summary>反序列化指定 <see cref="T:System.Xml.XmlReader" /> 和编码样式包含的 XML 文档。</summary>
        <returns>反序列化的对象。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 反序列化是： 读取的 XML 文档实例，并构造的对象被强类型化为 XML 架构 (XSD) 文档的过程。  
  
 在反序列化之前,<xref:System.Xml.Serialization.XmlSerializer>必须使用要反序列化的对象的类型构造。  
  
 设置`encodingStyle`参数"http://schemas.xmlsoap.org/soap/encoding/ "为 SOAP 1.1 版编码;否则，将其设置为"http://www.w3.org/2001/12/soap-encoding"的 SOAP 版本 1.2 编码。  
  
 **请注意**<xref:System.Xml.Serialization.XmlSerializer>无法反序列化以下： 数组<xref:System.Collections.ArrayList>和数组<xref:System.Collections.Generic.List%601>。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">反序列化期间发生错误。 使用 <see cref="P:System.Exception.InnerException" /> 属性时可使用原始异常。</exception>
        <altmember cref="T:System.Xml.Serialization.XmlAttributes" />
        <altmember cref="M:System.Xml.Serialization.XmlSerializer.CanDeserialize(System.Xml.XmlReader)" />
        <altmember cref="M:System.Xml.Serialization.XmlSerializer.Serialize(System.IO.TextWriter,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Deserialize">
      <MemberSignature Language="C#" Value="public object Deserialize (System.Xml.XmlReader xmlReader, System.Xml.Serialization.XmlDeserializationEvents events);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object Deserialize(class System.Xml.XmlReader xmlReader, valuetype System.Xml.Serialization.XmlDeserializationEvents events) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Serialization.XmlSerializer.Deserialize(System.Xml.XmlReader,System.Xml.Serialization.XmlDeserializationEvents)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ Deserialize(System::Xml::XmlReader ^ xmlReader, System::Xml::Serialization::XmlDeserializationEvents events);" />
      <MemberSignature Language="F#" Value="member this.Deserialize : System.Xml.XmlReader * System.Xml.Serialization.XmlDeserializationEvents -&gt; obj" Usage="xmlSerializer.Deserialize (xmlReader, events)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlSerializer</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="xmlReader" Type="System.Xml.XmlReader" />
        <Parameter Name="events" Type="System.Xml.Serialization.XmlDeserializationEvents" />
      </Parameters>
      <Docs>
        <param name="xmlReader">包含要反序列化的文档的 <see cref="T:System.Xml.XmlReader" />。</param>
        <param name="events">
          <see cref="T:System.Xml.Serialization.XmlDeserializationEvents" /> 类的实例。</param>
        <summary>反序列化一个由指定的 <see cref="T:System.Xml.XmlReader" /> 包含的 XML 文档，并允许重写反序列化过程中发生的事件。</summary>
        <returns>正被反序列化的 <see cref="T:System.Object" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 正在被反序列化的对象。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Deserialize">
      <MemberSignature Language="C#" Value="public object Deserialize (System.Xml.XmlReader xmlReader, string encodingStyle, System.Xml.Serialization.XmlDeserializationEvents events);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object Deserialize(class System.Xml.XmlReader xmlReader, string encodingStyle, valuetype System.Xml.Serialization.XmlDeserializationEvents events) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Serialization.XmlSerializer.Deserialize(System.Xml.XmlReader,System.String,System.Xml.Serialization.XmlDeserializationEvents)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ Deserialize(System::Xml::XmlReader ^ xmlReader, System::String ^ encodingStyle, System::Xml::Serialization::XmlDeserializationEvents events);" />
      <MemberSignature Language="F#" Value="member this.Deserialize : System.Xml.XmlReader * string * System.Xml.Serialization.XmlDeserializationEvents -&gt; obj" Usage="xmlSerializer.Deserialize (xmlReader, encodingStyle, events)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlSerializer</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="xmlReader" Type="System.Xml.XmlReader" />
        <Parameter Name="encodingStyle" Type="System.String" />
        <Parameter Name="events" Type="System.Xml.Serialization.XmlDeserializationEvents" />
      </Parameters>
      <Docs>
        <param name="xmlReader">
          <see cref="T:System.Xml.XmlReader" /> 类的实例，用于读取文档。</param>
        <param name="encodingStyle">使用的编码方式。</param>
        <param name="events">
          <see cref="T:System.Xml.Serialization.XmlDeserializationEvents" /> 类的实例。</param>
        <summary>使用指定的 <see cref="T:System.Xml.XmlReader" /> 包含的数据反序列化该对象。</summary>
        <returns>正在被反序列化的对象。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法是必需的反序列化的未知标头的仅 Web 服务方案。 此方法，你可以避免在 Web 服务方法中的事件同步。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="FromMappings">
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>从指定的映射返回 <see cref="T:System.Xml.Serialization.XmlSerializer" /> 类的实例。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FromMappings">
      <MemberSignature Language="C#" Value="public static System.Xml.Serialization.XmlSerializer[] FromMappings (System.Xml.Serialization.XmlMapping[] mappings);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.Serialization.XmlSerializer[] FromMappings(class System.Xml.Serialization.XmlMapping[] mappings) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Serialization.XmlSerializer.FromMappings(System.Xml.Serialization.XmlMapping[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FromMappings (mappings As XmlMapping()) As XmlSerializer()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Xml::Serialization::XmlSerializer ^&gt; ^ FromMappings(cli::array &lt;System::Xml::Serialization::XmlMapping ^&gt; ^ mappings);" />
      <MemberSignature Language="F#" Value="static member FromMappings : System.Xml.Serialization.XmlMapping[] -&gt; System.Xml.Serialization.XmlSerializer[]" Usage="System.Xml.Serialization.XmlSerializer.FromMappings mappings" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlSerializer</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Serialization.XmlSerializer[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mappings" Type="System.Xml.Serialization.XmlMapping[]" />
      </Parameters>
      <Docs>
        <param name="mappings">将一种类型映射到另一种类型的 <see cref="T:System.Xml.Serialization.XmlTypeMapping" /> 的数组。</param>
        <summary>返回从 <see cref="T:System.Xml.Serialization.XmlSerializer" /> 对象的数组创建的 <see cref="T:System.Xml.Serialization.XmlTypeMapping" /> 对象的数组。</summary>
        <returns>一个 <see cref="T:System.Xml.Serialization.XmlSerializer" /> 对象数组。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FromMappings">
      <MemberSignature Language="C#" Value="public static System.Xml.Serialization.XmlSerializer[] FromMappings (System.Xml.Serialization.XmlMapping[] mappings, System.Security.Policy.Evidence evidence);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.Serialization.XmlSerializer[] FromMappings(class System.Xml.Serialization.XmlMapping[] mappings, class System.Security.Policy.Evidence evidence) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Serialization.XmlSerializer.FromMappings(System.Xml.Serialization.XmlMapping[],System.Security.Policy.Evidence)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Xml::Serialization::XmlSerializer ^&gt; ^ FromMappings(cli::array &lt;System::Xml::Serialization::XmlMapping ^&gt; ^ mappings, System::Security::Policy::Evidence ^ evidence);" />
      <MemberSignature Language="F#" Value="static member FromMappings : System.Xml.Serialization.XmlMapping[] * System.Security.Policy.Evidence -&gt; System.Xml.Serialization.XmlSerializer[]" Usage="System.Xml.Serialization.XmlSerializer.FromMappings (mappings, evidence)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("This method is obsolete and will be removed in a future release of the .NET Framework. Please use an overload of FromMappings which does not take an Evidence parameter. See http://go2.microsoft.com/fwlink/?LinkId=131738 for more information.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Xml.Serialization.XmlSerializer[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mappings" Type="System.Xml.Serialization.XmlMapping[]" />
        <Parameter Name="evidence" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="mappings">一个 <see cref="T:System.Xml.Serialization.XmlMapping" /> 对象的数组，这些对象用于将一个类型映射到另一个类型。</param>
        <param name="evidence">
          <see cref="T:System.Security.Policy.Evidence" /> 类的实例，包含为公共语言运行时策略系统提供的主机数据和程序集数据。</param>
        <summary>返回 <see cref="T:System.Xml.Serialization.XmlSerializer" /> 类的实例，该类通过一个 XML 类型到另一个 XML 类型的映射来创建。</summary>
        <returns>
          <see cref="T:System.Xml.Serialization.XmlSerializer" /> 类的实例。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FromMappings">
      <MemberSignature Language="C#" Value="public static System.Xml.Serialization.XmlSerializer[] FromMappings (System.Xml.Serialization.XmlMapping[] mappings, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.Serialization.XmlSerializer[] FromMappings(class System.Xml.Serialization.XmlMapping[] mappings, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Serialization.XmlSerializer.FromMappings(System.Xml.Serialization.XmlMapping[],System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Xml::Serialization::XmlSerializer ^&gt; ^ FromMappings(cli::array &lt;System::Xml::Serialization::XmlMapping ^&gt; ^ mappings, Type ^ type);" />
      <MemberSignature Language="F#" Value="static member FromMappings : System.Xml.Serialization.XmlMapping[] * Type -&gt; System.Xml.Serialization.XmlSerializer[]" Usage="System.Xml.Serialization.XmlSerializer.FromMappings (mappings, type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlSerializer</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Serialization.XmlSerializer[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mappings" Type="System.Xml.Serialization.XmlMapping[]" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="mappings">一个 <see cref="T:System.Xml.Serialization.XmlMapping" /> 对象数组。</param>
        <param name="type">反序列化的对象的 <see cref="T:System.Type" />。</param>
        <summary>从指定的映射返回 <see cref="T:System.Xml.Serialization.XmlSerializer" /> 类的实例。</summary>
        <returns>
          <see cref="T:System.Xml.Serialization.XmlSerializer" /> 类的实例。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FromTypes">
      <MemberSignature Language="C#" Value="public static System.Xml.Serialization.XmlSerializer[] FromTypes (Type[] types);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.Serialization.XmlSerializer[] FromTypes(class System.Type[] types) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Serialization.XmlSerializer.FromTypes(System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FromTypes (types As Type()) As XmlSerializer()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Xml::Serialization::XmlSerializer ^&gt; ^ FromTypes(cli::array &lt;Type ^&gt; ^ types);" />
      <MemberSignature Language="F#" Value="static member FromTypes : Type[] -&gt; System.Xml.Serialization.XmlSerializer[]" Usage="System.Xml.Serialization.XmlSerializer.FromTypes types" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlSerializer</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Serialization.XmlSerializer[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="types" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="types">一个 <see cref="T:System.Type" /> 对象数组。</param>
        <summary>返回从类型数组创建的 <see cref="T:System.Xml.Serialization.XmlSerializer" /> 对象的数组。</summary>
        <returns>一个 <see cref="T:System.Xml.Serialization.XmlSerializer" /> 对象数组。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Xml.Serialization.XmlSerializer.FromTypes%2A>方法可以有效地创建的数组<xref:System.Xml.Serialization.XmlSerializer>用于处理的数组对象<xref:System.Type>对象。  
  
   
  
## Examples  
 下面的示例使用<xref:System.Xml.Serialization.XmlSerializer.FromTypes%2A>方法返回的数组<xref:System.Xml.Serialization.XmlSerializer>对象。 代码包含用于创建数组的每个的三个类定义<xref:System.Type>对象。  
  
 [!code-cpp[Classic XmlSerializer.FromTypes Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic XmlSerializer.FromTypes Example/CPP/source.cpp#1)]
 [!code-csharp[Classic XmlSerializer.FromTypes Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic XmlSerializer.FromTypes Example/CS/source.cs#1)]
 [!code-vb[Classic XmlSerializer.FromTypes Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic XmlSerializer.FromTypes Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.Serialization.XmlAttributes" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GenerateSerializer">
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>返回一个程序集，其中包含类型化的序列化程序。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [XML 序列化程序生成器工具 (Sgen.exe)](~/docs/standard/serialization/xml-serializer-generator-tool-sgen-exe.md)创建类型的 XML 序列化程序集指定的程序集中，以提高运行时性能<xref:System.Xml.Serialization.XmlSerializer>时序列化或反序列化的对象指定的类型。 使用<xref:System.Xml.Serialization.XmlSerializer.GetXmlSerializerAssemblyName%2A>返回此类程序集的名称。  
  
 如果你要分发的客户端应用程序调用的 Web 服务的一部分的此类程序集，则可以应用<xref:System.Xml.Serialization.XmlSerializerAssemblyAttribute>为客户端类型，以指定的位置和名称的程序集。  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="GenerateSerializer">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly GenerateSerializer (Type[] types, System.Xml.Serialization.XmlMapping[] mappings);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly GenerateSerializer(class System.Type[] types, class System.Xml.Serialization.XmlMapping[] mappings) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Serialization.XmlSerializer.GenerateSerializer(System.Type[],System.Xml.Serialization.XmlMapping[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GenerateSerializer (types As Type(), mappings As XmlMapping()) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ GenerateSerializer(cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Xml::Serialization::XmlMapping ^&gt; ^ mappings);" />
      <MemberSignature Language="F#" Value="static member GenerateSerializer : Type[] * System.Xml.Serialization.XmlMapping[] -&gt; System.Reflection.Assembly" Usage="System.Xml.Serialization.XmlSerializer.GenerateSerializer (types, mappings)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="mappings" Type="System.Xml.Serialization.XmlMapping[]" />
      </Parameters>
      <Docs>
        <param name="types">类型集合。</param>
        <param name="mappings">一个 <see cref="T:System.Xml.Serialization.XmlMapping" /> 对象的集合，用于将一个类型转换为另一个类型。</param>
        <summary>使用指定映射返回一个程序集，该程序集包含的自定义序列化程序用于序列化或反序列化指定的一个或多个类型。</summary>
        <returns>一个 <see cref="T:System.Reflection.Assembly" /> 对象，包含提供的类型和映射的序列化程序。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GenerateSerializer">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly GenerateSerializer (Type[] types, System.Xml.Serialization.XmlMapping[] mappings, System.CodeDom.Compiler.CompilerParameters parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly GenerateSerializer(class System.Type[] types, class System.Xml.Serialization.XmlMapping[] mappings, class System.CodeDom.Compiler.CompilerParameters parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Serialization.XmlSerializer.GenerateSerializer(System.Type[],System.Xml.Serialization.XmlMapping[],System.CodeDom.Compiler.CompilerParameters)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GenerateSerializer (types As Type(), mappings As XmlMapping(), parameters As CompilerParameters) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ GenerateSerializer(cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Xml::Serialization::XmlMapping ^&gt; ^ mappings, System::CodeDom::Compiler::CompilerParameters ^ parameters);" />
      <MemberSignature Language="F#" Value="static member GenerateSerializer : Type[] * System.Xml.Serialization.XmlMapping[] * System.CodeDom.Compiler.CompilerParameters -&gt; System.Reflection.Assembly" Usage="System.Xml.Serialization.XmlSerializer.GenerateSerializer (types, mappings, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="mappings" Type="System.Xml.Serialization.XmlMapping[]" />
        <Parameter Name="parameters" Type="System.CodeDom.Compiler.CompilerParameters" />
      </Parameters>
      <Docs>
        <param name="types">一个 <see cref="T:System.Type" /> 类型的数组，其中包含的对象用于对数据进行序列化和反序列化。</param>
        <param name="mappings">一个 <see cref="T:System.Xml.Serialization.XmlMapping" /> 类型的数组，它将 XML 数据映射到类型数据。</param>
        <param name="parameters">
          <see cref="T:System.CodeDom.Compiler.CompilerParameters" /> 类的实例，表示用于调用编译器的参数。</param>
        <summary>使用指定映射、编译器设置和选项返回一个程序集，该程序集包含的自定义序列化程序用于序列化或反序列化指定的一个或多个类型。</summary>
        <returns>
          <see cref="T:System.Reflection.Assembly" /> 包含 <see cref="T:System.Xml.Serialization.XmlSerializer" /> 的专用版本。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetXmlSerializerAssemblyName">
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>返回程序集的名称，该程序集包含专门为序列化或反序列化特定类型创建的 <see cref="T:System.Xml.Serialization.XmlSerializer" /> 的一个或多个版本。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [XML 序列化程序生成器工具 (Sgen.exe)](~/docs/standard/serialization/xml-serializer-generator-tool-sgen-exe.md)创建类型的 XML 序列化程序集指定的程序集中，以提高运行时性能<xref:System.Xml.Serialization.XmlSerializer>时序列化或反序列化的对象指定的类型。 使用<xref:System.Xml.Serialization.XmlSerializer.GetXmlSerializerAssemblyName%2A>返回此类程序集的名称。  
  
 如果你要分发的客户端应用程序调用的 Web 服务的一部分的此类程序集，则可以应用<xref:System.Xml.Serialization.XmlSerializerAssemblyAttribute>为客户端类型，以指定的位置和名称的程序集。  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetXmlSerializerAssemblyName">
      <MemberSignature Language="C#" Value="public static string GetXmlSerializerAssemblyName (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetXmlSerializerAssemblyName(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Serialization.XmlSerializer.GetXmlSerializerAssemblyName(System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetXmlSerializerAssemblyName(Type ^ type);" />
      <MemberSignature Language="F#" Value="static member GetXmlSerializerAssemblyName : Type -&gt; string" Usage="System.Xml.Serialization.XmlSerializer.GetXmlSerializerAssemblyName type" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlSerializer</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="type">正在进行反序列化的 <see cref="T:System.Type" />。</param>
        <summary>返回程序集的名称，该程序集包含专门为序列化或反序列化特定类型创建的 <see cref="T:System.Xml.Serialization.XmlSerializer" /> 的一个或多个版本。</summary>
        <returns>包含该类型的 <see cref="T:System.Xml.Serialization.XmlSerializer" /> 的程序集的名称。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [XML 序列化程序生成器工具 (Sgen.exe)](~/docs/standard/serialization/xml-serializer-generator-tool-sgen-exe.md)创建类型的 XML 序列化程序集指定的程序集中，以提高运行时性能<xref:System.Xml.Serialization.XmlSerializer>时序列化或反序列化的对象指定的类型。 使用<xref:System.Xml.Serialization.XmlSerializer.GetXmlSerializerAssemblyName%2A>返回此类程序集的名称。  
  
 如果你要分发的客户端应用程序调用的 Web 服务的一部分的此类程序集，则可以应用<xref:System.Xml.Serialization.XmlSerializerAssemblyAttribute>为客户端类型，以指定的位置和名称的程序集。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetXmlSerializerAssemblyName">
      <MemberSignature Language="C#" Value="public static string GetXmlSerializerAssemblyName (Type type, string defaultNamespace);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetXmlSerializerAssemblyName(class System.Type type, string defaultNamespace) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Serialization.XmlSerializer.GetXmlSerializerAssemblyName(System.Type,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetXmlSerializerAssemblyName(Type ^ type, System::String ^ defaultNamespace);" />
      <MemberSignature Language="F#" Value="static member GetXmlSerializerAssemblyName : Type * string -&gt; string" Usage="System.Xml.Serialization.XmlSerializer.GetXmlSerializerAssemblyName (type, defaultNamespace)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlSerializer</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="defaultNamespace" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">您关注的 <see cref="T:System.Type" />。</param>
        <param name="defaultNamespace">类型的命名空间。</param>
        <summary>返回程序集的名称，该程序集包含指定命名空间中指定类型的序列化程序。</summary>
        <returns>程序集的名称，该程序集包含专门生成的序列化程序。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [XML 序列化程序生成器工具 (Sgen.exe)](~/docs/standard/serialization/xml-serializer-generator-tool-sgen-exe.md)创建类型的 XML 序列化程序集指定的程序集中，以提高运行时性能<xref:System.Xml.Serialization.XmlSerializer>时序列化或反序列化的对象指定的类型。 使用<xref:System.Xml.Serialization.XmlSerializer.GetXmlSerializerAssemblyName%2A>返回此类程序集的名称。  
  
 如果你要分发的客户端应用程序调用的 Web 服务的一部分的此类程序集，则可以应用<xref:System.Xml.Serialization.XmlSerializerAssemblyAttribute>为客户端类型，以指定的位置和名称的程序集。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Serialize">
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlSerializer</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>将对象序列化到 XML 文档中。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Serialize">
      <MemberSignature Language="C#" Value="public void Serialize (System.IO.Stream stream, object o);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Serialize(class System.IO.Stream stream, object o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Serialization.XmlSerializer.Serialize(System.IO.Stream,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Serialize(System::IO::Stream ^ stream, System::Object ^ o);" />
      <MemberSignature Language="F#" Value="member this.Serialize : System.IO.Stream * obj -&gt; unit" Usage="xmlSerializer.Serialize (stream, o)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlSerializer</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="o" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="stream">用于编写 XML 文档的 <see cref="T:System.IO.Stream" />。</param>
        <param name="o">要序列化的 <see cref="T:System.Object" />。</param>
        <summary>使用指定的 <see cref="T:System.Object" /> 序列化指定的 <see cref="T:System.IO.Stream" /> 并将 XML 文档写入文件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Xml.Serialization.XmlSerializer.Serialize%2A>方法将 XML 转换为的公共字段和对象的读/写属性。 它不转换方法、 索引、 私有字段或只读属性。 要序列化的所有对象的字段和属性，公钥和私钥，使用<xref:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter>。  
  
 在`stream`参数，指定一个对象，派生自抽象<xref:System.IO.Stream>类。 派生自的类<xref:System.IO.Stream>包括：  
  
-   <xref:System.IO.BufferedStream>  
  
-   <xref:System.IO.FileStream>  
  
-   <xref:System.IO.MemoryStream>  
  
-   <xref:System.Net.Sockets.NetworkStream>  
  
-   <xref:System.Security.Cryptography.CryptoStream>  
  
> [!NOTE]
>  <xref:System.Xml.Serialization.XmlSerializer>无法序列化以下： 数组<xref:System.Collections.ArrayList>和数组<xref:System.Collections.Generic.List%601>。  
  
   
  
## Examples  
 下面的示例序列化对象使用<xref:System.IO.Stream>对象。  
  
 [!code-cpp[Classic XmlSerializer.Serialize2 Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic XmlSerializer.Serialize2 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic XmlSerializer.Serialize2 Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic XmlSerializer.Serialize2 Example/CS/source.cs#1)]
 [!code-vb[Classic XmlSerializer.Serialize2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic XmlSerializer.Serialize2 Example/VB/source.vb#1)]
 [!code-xml[Classic XmlSerializer.Serialize2 Example#1](~/samples/snippets/common/VS_Snippets_Remoting/Classic XmlSerializer.Serialize2 Example/Common/simple.xml#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">序列化期间发生错误。 使用 <see cref="P:System.Exception.InnerException" /> 属性时可使用原始异常。</exception>
        <altmember cref="T:System.Xml.Serialization.XmlAttributes" />
        <altmember cref="M:System.Xml.Serialization.XmlSerializer.Deserialize(System.IO.Stream)" />
      </Docs>
    </Member>
    <Member MemberName="Serialize">
      <MemberSignature Language="C#" Value="public void Serialize (System.IO.TextWriter textWriter, object o);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Serialize(class System.IO.TextWriter textWriter, object o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Serialization.XmlSerializer.Serialize(System.IO.TextWriter,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Serialize(System::IO::TextWriter ^ textWriter, System::Object ^ o);" />
      <MemberSignature Language="F#" Value="member this.Serialize : System.IO.TextWriter * obj -&gt; unit" Usage="xmlSerializer.Serialize (textWriter, o)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlSerializer</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="textWriter" Type="System.IO.TextWriter" />
        <Parameter Name="o" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="textWriter">用于编写 XML 文档的 <see cref="T:System.IO.TextWriter" />。</param>
        <param name="o">要序列化的 <see cref="T:System.Object" />。</param>
        <summary>使用指定的 <see cref="T:System.Object" /> 序列化指定的 <see cref="T:System.IO.TextWriter" /> 并将 XML 文档写入文件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Xml.Serialization.XmlSerializer.Serialize%2A>方法将 XML 转换为的公共字段和对象的读/写属性。 它不转换方法、 索引、 私有字段或只读属性。 要序列化对象的所有字段和属性，公钥和私钥，使用<xref:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter>。  
  
 在`textWriter`参数，指定一个对象，派生自抽象<xref:System.IO.TextWriter>类。 派生自的类<xref:System.IO.TextWriter>包括：  
  
-   <xref:System.IO.StreamWriter>  
  
-   <xref:System.IO.StringWriter>  
  
-   <xref:System.CodeDom.Compiler.IndentedTextWriter>  
  
> [!NOTE]
>  <xref:System.Xml.Serialization.XmlSerializer>无法序列化以下： 数组<xref:System.Collections.ArrayList>和数组<xref:System.Collections.Generic.List%601>。  
  
   
  
## Examples  
 下面的示例序列化对象使用<xref:System.IO.TextWriter>。  
  
 [!code-cpp[Classic XmlSerializer.Serialize Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic XmlSerializer.Serialize Example/CPP/source.cpp#1)]
 [!code-csharp[Classic XmlSerializer.Serialize Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic XmlSerializer.Serialize Example/CS/source.cs#1)]
 [!code-vb[Classic XmlSerializer.Serialize Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic XmlSerializer.Serialize Example/VB/source.vb#1)]
 [!code-xml[Classic XmlSerializer.Serialize Example#1](~/samples/snippets/common/VS_Snippets_Remoting/Classic XmlSerializer.Serialize Example/Common/simple.xml#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.Serialization.XmlAttributes" />
      </Docs>
    </Member>
    <Member MemberName="Serialize">
      <MemberSignature Language="C#" Value="protected virtual void Serialize (object o, System.Xml.Serialization.XmlSerializationWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Serialize(object o, class System.Xml.Serialization.XmlSerializationWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Serialization.XmlSerializer.Serialize(System.Object,System.Xml.Serialization.XmlSerializationWriter)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Serialize (o As Object, writer As XmlSerializationWriter)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Serialize(System::Object ^ o, System::Xml::Serialization::XmlSerializationWriter ^ writer);" />
      <MemberSignature Language="F#" Value="abstract member Serialize : obj * System.Xml.Serialization.XmlSerializationWriter -&gt; unit&#xA;override this.Serialize : obj * System.Xml.Serialization.XmlSerializationWriter -&gt; unit" Usage="xmlSerializer.Serialize (o, writer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlSerializer</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Object" />
        <Parameter Name="writer" Type="System.Xml.Serialization.XmlSerializationWriter" />
      </Parameters>
      <Docs>
        <param name="o">要序列化的 <see cref="T:System.Object" />。</param>
        <param name="writer">用于编写 XML 文档的 <see cref="T:System.Xml.Serialization.XmlSerializationWriter" />。</param>
        <summary>使用指定的 <see cref="T:System.Object" /> 序列化指定的 <see cref="T:System.Xml.Serialization.XmlSerializationWriter" /> 并将 XML 文档写入文件。</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotImplementedException">当未在子类中重写该方法时，为访问该方法进行的任何尝试。</exception>
      </Docs>
    </Member>
    <Member MemberName="Serialize">
      <MemberSignature Language="C#" Value="public void Serialize (System.Xml.XmlWriter xmlWriter, object o);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Serialize(class System.Xml.XmlWriter xmlWriter, object o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Serialization.XmlSerializer.Serialize(System.Xml.XmlWriter,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Serialize(System::Xml::XmlWriter ^ xmlWriter, System::Object ^ o);" />
      <MemberSignature Language="F#" Value="member this.Serialize : System.Xml.XmlWriter * obj -&gt; unit" Usage="xmlSerializer.Serialize (xmlWriter, o)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlSerializer</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="xmlWriter" Type="System.Xml.XmlWriter" />
        <Parameter Name="o" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="xmlWriter">用于编写 XML 文档的 <see cref="T:System.Xml.XmlWriter" />。</param>
        <param name="o">要序列化的 <see cref="T:System.Object" />。</param>
        <summary>使用指定的 <see cref="T:System.Object" /> 序列化指定的 <see cref="T:System.Xml.XmlWriter" /> 并将 XML 文档写入文件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Xml.Serialization.XmlSerializer.Serialize%2A>方法将 XML 转换为的公共字段和对象的读/写属性。 它不转换方法、 索引、 私有字段或只读属性。 要序列化对象的所有字段和属性，公钥和私钥，使用<xref:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter>。  
  
 在`xmlWriter`参数，指定一个对象，派生自抽象<xref:System.Xml.XmlWriter>类。 <xref:System.Xml.XmlTextWriter>派生自<xref:System.Xml.XmlWriter>。  
  
> [!NOTE]
>  <xref:System.Xml.Serialization.XmlSerializer>无法序列化以下： 数组<xref:System.Collections.ArrayList>和数组<xref:System.Collections.Generic.List%601>。  
  
   
  
## Examples  
 下面的示例序列化对象使用<xref:System.Xml.XmlWriter>。  
  
 [!code-cpp[Classic XmlSerializer.Serialize4 Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic XmlSerializer.Serialize4 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic XmlSerializer.Serialize4 Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic XmlSerializer.Serialize4 Example/CS/source.cs#1)]
 [!code-vb[Classic XmlSerializer.Serialize4 Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic XmlSerializer.Serialize4 Example/VB/source.vb#1)]
 [!code-xml[Classic XmlSerializer.Serialize4 Example#1](~/samples/snippets/common/VS_Snippets_Remoting/Classic XmlSerializer.Serialize4 Example/Common/simple.xml#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">序列化期间发生错误。 使用 <see cref="P:System.Exception.InnerException" /> 属性时可使用原始异常。</exception>
        <altmember cref="T:System.Xml.Serialization.XmlAttributes" />
        <altmember cref="M:System.Xml.Serialization.XmlSerializer.Deserialize(System.IO.Stream)" />
      </Docs>
    </Member>
    <Member MemberName="Serialize">
      <MemberSignature Language="C#" Value="public void Serialize (System.IO.Stream stream, object o, System.Xml.Serialization.XmlSerializerNamespaces namespaces);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Serialize(class System.IO.Stream stream, object o, class System.Xml.Serialization.XmlSerializerNamespaces namespaces) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Serialization.XmlSerializer.Serialize(System.IO.Stream,System.Object,System.Xml.Serialization.XmlSerializerNamespaces)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Serialize(System::IO::Stream ^ stream, System::Object ^ o, System::Xml::Serialization::XmlSerializerNamespaces ^ namespaces);" />
      <MemberSignature Language="F#" Value="member this.Serialize : System.IO.Stream * obj * System.Xml.Serialization.XmlSerializerNamespaces -&gt; unit" Usage="xmlSerializer.Serialize (stream, o, namespaces)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlSerializer</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="o" Type="System.Object" />
        <Parameter Name="namespaces" Type="System.Xml.Serialization.XmlSerializerNamespaces" />
      </Parameters>
      <Docs>
        <param name="stream">用于编写 XML 文档的 <see cref="T:System.IO.Stream" />。</param>
        <param name="o">要序列化的 <see cref="T:System.Object" />。</param>
        <param name="namespaces">该对象所引用的 <see cref="T:System.Xml.Serialization.XmlSerializerNamespaces" />。</param>
        <summary>使用引用指定命名空间的指定 <see cref="T:System.IO.Stream" /> 序列化指定的 <see cref="T:System.Object" /> 并将 XML 文档写入文件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当<xref:System.Xml.Serialization.XmlSerializer.Serialize%2A>调用方法、 公共字段和对象的读/写属性转换为 XML。 方法、 索引、 私有字段和只读属性不会序列化。 要序列化所有字段和属性，公钥和私钥，使用<xref:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter>。  
  
 使用`stream`参数来指定派生自抽象对象<xref:System.IO.Stream>类，该类用于写入流。 派生自的类<xref:System.IO.Stream>类包括：  
  
-   <xref:System.IO.BufferedStream>  
  
-   <xref:System.IO.FileStream>  
  
-   <xref:System.IO.MemoryStream>  
  
-   <xref:System.Net.Sockets.NetworkStream>  
  
-   <xref:System.Security.Cryptography.CryptoStream>  
  
> [!NOTE]
>  <xref:System.Xml.Serialization.XmlSerializer>无法序列化以下： 数组<xref:System.Collections.ArrayList>和数组<xref:System.Collections.Generic.List%601>。  
  
   
  
## Examples  
 下面的示例将具有的对象序列化为<xref:System.IO.Stream>对象。 此示例还创建<xref:System.Xml.Serialization.XmlSerializerNamespaces>并将两个命名空间添加到对象。 定义序列化的对象的类还使用特性化<xref:System.Xml.Serialization.XmlElementAttribute>特性来指定每个元素的命名空间。  
  
 [!code-cpp[Classic XmlSerializer.Serialize3 Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic XmlSerializer.Serialize3 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic XmlSerializer.Serialize3 Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic XmlSerializer.Serialize3 Example/CS/source.cs#1)]
 [!code-vb[Classic XmlSerializer.Serialize3 Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic XmlSerializer.Serialize3 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">序列化期间发生错误。 使用 <see cref="P:System.Exception.InnerException" /> 属性时可使用原始异常。</exception>
        <altmember cref="T:System.Xml.Serialization.XmlAttributes" />
        <altmember cref="M:System.Xml.Serialization.XmlSerializer.Deserialize(System.IO.Stream)" />
      </Docs>
    </Member>
    <Member MemberName="Serialize">
      <MemberSignature Language="C#" Value="public void Serialize (System.IO.TextWriter textWriter, object o, System.Xml.Serialization.XmlSerializerNamespaces namespaces);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Serialize(class System.IO.TextWriter textWriter, object o, class System.Xml.Serialization.XmlSerializerNamespaces namespaces) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Serialization.XmlSerializer.Serialize(System.IO.TextWriter,System.Object,System.Xml.Serialization.XmlSerializerNamespaces)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Serialize(System::IO::TextWriter ^ textWriter, System::Object ^ o, System::Xml::Serialization::XmlSerializerNamespaces ^ namespaces);" />
      <MemberSignature Language="F#" Value="member this.Serialize : System.IO.TextWriter * obj * System.Xml.Serialization.XmlSerializerNamespaces -&gt; unit" Usage="xmlSerializer.Serialize (textWriter, o, namespaces)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlSerializer</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="textWriter" Type="System.IO.TextWriter" />
        <Parameter Name="o" Type="System.Object" />
        <Parameter Name="namespaces" Type="System.Xml.Serialization.XmlSerializerNamespaces" />
      </Parameters>
      <Docs>
        <param name="textWriter">用于编写 XML 文档的 <see cref="T:System.IO.TextWriter" />。</param>
        <param name="o">要序列化的 <see cref="T:System.Object" />。</param>
        <param name="namespaces">包含生成的 XML 文档的命名空间的 <see cref="T:System.Xml.Serialization.XmlSerializerNamespaces" />。</param>
        <summary>使用指定的 <see cref="T:System.Object" /> 和指定命名空间序列化指定的 <see cref="T:System.IO.TextWriter" /> 并将 XML 文档写入文件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当<xref:System.Xml.Serialization.XmlSerializer.Serialize%2A>调用方法的公共字段和对象的读/写属性转换为 XML。 方法、 索引、 私有字段和只读属性不会序列化。 要序列化所有字段和属性，公钥和私钥，使用<xref:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter>。  
  
 使用`textWriter`参数来指定派生自抽象对象<xref:System.IO.TextWriter>类。 派生自的类<xref:System.IO.TextWriter>类包括：  
  
-   <xref:System.IO.StreamWriter>  
  
-   <xref:System.IO.StringWriter>  
  
-   <xref:System.CodeDom.Compiler.IndentedTextWriter>  
  
> [!NOTE]
>  <xref:System.Xml.Serialization.XmlSerializer>无法序列化以下： 数组<xref:System.Collections.ArrayList>和数组<xref:System.Collections.Generic.List%601>。  
  
   
  
## Examples  
 下面的示例将具有的对象序列化为<xref:System.IO.TextWriter>。 此示例还创建<xref:System.Xml.Serialization.XmlSerializerNamespaces>对象并将两个命名空间添加到对象。 定义序列化的对象的类还使用特性化<xref:System.Xml.Serialization.XmlElementAttribute>特性来指定每个元素的命名空间。  
  
 [!code-cpp[Classic XmlSerializer.Serialize1 Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic XmlSerializer.Serialize1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic XmlSerializer.Serialize1 Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic XmlSerializer.Serialize1 Example/CS/source.cs#1)]
 [!code-vb[Classic XmlSerializer.Serialize1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic XmlSerializer.Serialize1 Example/VB/source.vb#1)]
 [!code-xml[Classic XmlSerializer.Serialize1 Example#1](~/samples/snippets/common/VS_Snippets_Remoting/Classic XmlSerializer.Serialize1 Example/Common/simple.xml#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">序列化期间发生错误。 使用 <see cref="P:System.Exception.InnerException" /> 属性时可使用原始异常。</exception>
        <altmember cref="T:System.Xml.Serialization.XmlAttributes" />
      </Docs>
    </Member>
    <Member MemberName="Serialize">
      <MemberSignature Language="C#" Value="public void Serialize (System.Xml.XmlWriter xmlWriter, object o, System.Xml.Serialization.XmlSerializerNamespaces namespaces);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Serialize(class System.Xml.XmlWriter xmlWriter, object o, class System.Xml.Serialization.XmlSerializerNamespaces namespaces) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Serialization.XmlSerializer.Serialize(System.Xml.XmlWriter,System.Object,System.Xml.Serialization.XmlSerializerNamespaces)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Serialize(System::Xml::XmlWriter ^ xmlWriter, System::Object ^ o, System::Xml::Serialization::XmlSerializerNamespaces ^ namespaces);" />
      <MemberSignature Language="F#" Value="member this.Serialize : System.Xml.XmlWriter * obj * System.Xml.Serialization.XmlSerializerNamespaces -&gt; unit" Usage="xmlSerializer.Serialize (xmlWriter, o, namespaces)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlSerializer</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="xmlWriter" Type="System.Xml.XmlWriter" />
        <Parameter Name="o" Type="System.Object" />
        <Parameter Name="namespaces" Type="System.Xml.Serialization.XmlSerializerNamespaces" />
      </Parameters>
      <Docs>
        <param name="xmlWriter">用于编写 XML 文档的 <see cref="T:System.Xml.XmlWriter" />。</param>
        <param name="o">要序列化的 <see cref="T:System.Object" />。</param>
        <param name="namespaces">该对象所引用的 <see cref="T:System.Xml.Serialization.XmlSerializerNamespaces" />。</param>
        <summary>使用指定的 <see cref="T:System.Object" /> 和指定命名空间序列化指定的 <see cref="T:System.Xml.XmlWriter" /> 并将 XML 文档写入文件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当<xref:System.Xml.Serialization.XmlSerializer.Serialize%2A>调用方法、 公共字段和对象的读/写属性转换为 XML。 方法、 索引、 私有字段和只读属性不会序列化。 要序列化所有字段和属性，公钥和私钥，使用<xref:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter>。  
  
 使用`xmlWriter`参数来指定派生自抽象对象<xref:System.Xml.XmlWriter>类，该类用于写入 XML 文档。 <xref:System.Xml.XmlTextWriter>派生自<xref:System.Xml.XmlWriter>。  
  
> [!NOTE]
>  <xref:System.Xml.Serialization.XmlSerializer>无法序列化以下： 数组<xref:System.Collections.ArrayList>和数组<xref:System.Collections.Generic.List%601>。  
  
   
  
## Examples  
 下面的示例将具有的对象序列化为<xref:System.Xml.XmlWriter>。 此示例还创建<xref:System.Xml.Serialization.XmlSerializerNamespaces>并将两个命名空间添加到对象。 几个实例<xref:System.Xml.Serialization.XmlElementAttribute>类应用于类成员，以指定每个元素的命名空间。  
  
 [!code-cpp[Classic XmlSerializer.Serialize5 Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic XmlSerializer.Serialize5 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic XmlSerializer.Serialize5 Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic XmlSerializer.Serialize5 Example/CS/source.cs#1)]
 [!code-vb[Classic XmlSerializer.Serialize5 Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic XmlSerializer.Serialize5 Example/VB/source.vb#1)]
 [!code-xml[Classic XmlSerializer.Serialize5 Example#1](~/samples/snippets/common/VS_Snippets_Remoting/Classic XmlSerializer.Serialize5 Example/Common/simple.xml#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">序列化期间发生错误。 使用 <see cref="P:System.Exception.InnerException" /> 属性时可使用原始异常。</exception>
        <altmember cref="T:System.Xml.Serialization.XmlAttributes" />
        <altmember cref="M:System.Xml.Serialization.XmlSerializer.Deserialize(System.IO.Stream)" />
      </Docs>
    </Member>
    <Member MemberName="Serialize">
      <MemberSignature Language="C#" Value="public void Serialize (System.Xml.XmlWriter xmlWriter, object o, System.Xml.Serialization.XmlSerializerNamespaces namespaces, string encodingStyle);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Serialize(class System.Xml.XmlWriter xmlWriter, object o, class System.Xml.Serialization.XmlSerializerNamespaces namespaces, string encodingStyle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Serialization.XmlSerializer.Serialize(System.Xml.XmlWriter,System.Object,System.Xml.Serialization.XmlSerializerNamespaces,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Serialize(System::Xml::XmlWriter ^ xmlWriter, System::Object ^ o, System::Xml::Serialization::XmlSerializerNamespaces ^ namespaces, System::String ^ encodingStyle);" />
      <MemberSignature Language="F#" Value="member this.Serialize : System.Xml.XmlWriter * obj * System.Xml.Serialization.XmlSerializerNamespaces * string -&gt; unit" Usage="xmlSerializer.Serialize (xmlWriter, o, namespaces, encodingStyle)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlSerializer</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="xmlWriter" Type="System.Xml.XmlWriter" />
        <Parameter Name="o" Type="System.Object" />
        <Parameter Name="namespaces" Type="System.Xml.Serialization.XmlSerializerNamespaces" />
        <Parameter Name="encodingStyle" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="xmlWriter">用于编写 XML 文档的 <see cref="T:System.Xml.XmlWriter" />。</param>
        <param name="o">要序列化的对象。</param>
        <param name="namespaces">该对象所引用的 <see cref="T:System.Xml.Serialization.XmlSerializerNamespaces" />。</param>
        <param name="encodingStyle">序列化的 XML 的编码样式。</param>
        <summary>使用指定的 <see cref="T:System.Xml.XmlWriter" /> 和指定命名空间及编码样式序列化指定对象并将 XML 文档写入文件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当<xref:System.Xml.Serialization.XmlSerializer.Serialize%2A>调用方法、 公共字段和对象的读/写属性转换为 XML。 方法、 索引、 私有字段和只读属性不会序列化。 要序列化所有字段和属性，公钥和私钥，使用<xref:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter>。  
  
 使用`xmlWriter`参数来指定派生自抽象对象<xref:System.Xml.XmlWriter>类，该类用于写入 XML 文档。 <xref:System.Xml.XmlTextWriter>派生自<xref:System.Xml.XmlWriter>。  
  
 设置`encodingStyle`参数"http://schemas.xmlsoap.org/soap/encoding/"为 SOAP 1.1 版编码; 否则，将其设置为"http://www.w3.org/2001/12/soap-encoding"的 SOAP 版本 1.2 编码。  
  
> [!NOTE]
>  <xref:System.Xml.Serialization.XmlSerializer>无法序列化以下： 数组<xref:System.Collections.ArrayList>和数组<xref:System.Collections.Generic.List%601>。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">序列化期间发生错误。 使用 <see cref="P:System.Exception.InnerException" /> 属性时可使用原始异常。</exception>
        <altmember cref="T:System.Xml.Serialization.XmlAttributes" />
        <altmember cref="M:System.Xml.Serialization.XmlSerializer.Deserialize(System.IO.Stream)" />
      </Docs>
    </Member>
    <Member MemberName="Serialize">
      <MemberSignature Language="C#" Value="public void Serialize (System.Xml.XmlWriter xmlWriter, object o, System.Xml.Serialization.XmlSerializerNamespaces namespaces, string encodingStyle, string id);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Serialize(class System.Xml.XmlWriter xmlWriter, object o, class System.Xml.Serialization.XmlSerializerNamespaces namespaces, string encodingStyle, string id) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Serialization.XmlSerializer.Serialize(System.Xml.XmlWriter,System.Object,System.Xml.Serialization.XmlSerializerNamespaces,System.String,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Serialize(System::Xml::XmlWriter ^ xmlWriter, System::Object ^ o, System::Xml::Serialization::XmlSerializerNamespaces ^ namespaces, System::String ^ encodingStyle, System::String ^ id);" />
      <MemberSignature Language="F#" Value="member this.Serialize : System.Xml.XmlWriter * obj * System.Xml.Serialization.XmlSerializerNamespaces * string * string -&gt; unit" Usage="xmlSerializer.Serialize (xmlWriter, o, namespaces, encodingStyle, id)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlSerializer</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="xmlWriter" Type="System.Xml.XmlWriter" />
        <Parameter Name="o" Type="System.Object" />
        <Parameter Name="namespaces" Type="System.Xml.Serialization.XmlSerializerNamespaces" />
        <Parameter Name="encodingStyle" Type="System.String" />
        <Parameter Name="id" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="xmlWriter">用于编写 XML 文档的 <see cref="T:System.Xml.XmlWriter" />。</param>
        <param name="o">要序列化的对象。</param>
        <param name="namespaces">
          <see langword="XmlSerializaerNamespaces" /> 的实例，其中包含要使用的命名空间和前缀。</param>
        <param name="encodingStyle">该文档中使用的编码。</param>
        <param name="id">对于 SOAP 编码消息，这是用于生成 id 特性的基。</param>
        <summary>使用指定的 <see cref="T:System.Object" />、XML 命名空间和编码序列化指定的 <see cref="T:System.Xml.XmlWriter" /> 并将 XML 文档写入文件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 *Id*参数提供用于创建 SOAP id 的基本字符串。 默认情况下，它们是"id1"、"id2"等。 但如果参数设置为"myBase"生成的值是"myBaseid1"，"myBaseid2"，依此类推。 此功能用于创建跨整个的 SOAP 消息的唯一 id 值。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UnknownAttribute">
      <MemberSignature Language="C#" Value="public event System.Xml.Serialization.XmlAttributeEventHandler UnknownAttribute;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Xml.Serialization.XmlAttributeEventHandler UnknownAttribute" />
      <MemberSignature Language="DocId" Value="E:System.Xml.Serialization.XmlSerializer.UnknownAttribute" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event UnknownAttribute As XmlAttributeEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Xml::Serialization::XmlAttributeEventHandler ^ UnknownAttribute;" />
      <MemberSignature Language="F#" Value="member this.UnknownAttribute : System.Xml.Serialization.XmlAttributeEventHandler " Usage="member this.UnknownAttribute : System.Xml.Serialization.XmlAttributeEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlSerializer</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Serialization.XmlAttributeEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当 <see cref="T:System.Xml.Serialization.XmlSerializer" /> 在反序列化过程中遇到未知类型的 XML 特性时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 默认情况下，在调用<xref:System.Xml.Serialization.XmlSerializer.Deserialize%2A>方法，<xref:System.Xml.Serialization.XmlSerializer>会忽略未知类型的 XML 属性。 但是，你可以使用此事件来处理此类节点类型。  
  
 如果要反序列化类的实例包含返回的数组的字段<xref:System.Xml.XmlAttribute>对象和<xref:System.Xml.Serialization.XmlAnyAttributeAttribute>已应用于字段，<xref:System.Xml.Serialization.XmlSerializer.UnknownAttribute>事件不会发生。 相反，所有未知的 XML 属性将收集到数组。  
  
   
  
## Examples  
 下面的示例将打印在反序列化 XML 文档时遇到的任何未知属性有关的信息。  
  
 [!code-cpp[Classic XmlSerializer.UnknownAttribute Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic XmlSerializer.UnknownAttribute Example/CPP/source.cpp#1)]
 [!code-csharp[Classic XmlSerializer.UnknownAttribute Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic XmlSerializer.UnknownAttribute Example/CS/source.cs#1)]
 [!code-vb[Classic XmlSerializer.UnknownAttribute Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic XmlSerializer.UnknownAttribute Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.Serialization.XmlAnyAttributeAttribute" />
        <altmember cref="M:System.Xml.Serialization.XmlSerializer.CanDeserialize(System.Xml.XmlReader)" />
        <altmember cref="M:System.Xml.Serialization.XmlSerializer.Deserialize(System.IO.Stream)" />
        <altmember cref="E:System.Xml.Serialization.XmlSerializer.UnknownNode" />
        <altmember cref="T:System.Xml.Serialization.XmlAttributes" />
      </Docs>
    </Member>
    <Member MemberName="UnknownElement">
      <MemberSignature Language="C#" Value="public event System.Xml.Serialization.XmlElementEventHandler UnknownElement;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Xml.Serialization.XmlElementEventHandler UnknownElement" />
      <MemberSignature Language="DocId" Value="E:System.Xml.Serialization.XmlSerializer.UnknownElement" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event UnknownElement As XmlElementEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Xml::Serialization::XmlElementEventHandler ^ UnknownElement;" />
      <MemberSignature Language="F#" Value="member this.UnknownElement : System.Xml.Serialization.XmlElementEventHandler " Usage="member this.UnknownElement : System.Xml.Serialization.XmlElementEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlSerializer</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Serialization.XmlElementEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当 <see cref="T:System.Xml.Serialization.XmlSerializer" /> 在反序列化过程中遇到未知类型的 XML 元素时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 默认情况下，在调用<xref:System.Xml.Serialization.XmlSerializer.Deserialize%2A>方法，<xref:System.Xml.Serialization.XmlSerializer>会忽略未知类型的 XML 属性。 但是，你可以使用此事件来处理此类节点类型。  
  
> [!NOTE]
>  如果<xref:System.Xml.Serialization.XmlAnyElementAttribute>应用于返回的数组的字段<xref:System.Xml.XmlElement>对象，数组中收集所有未知的元素。 在这种情况下，<xref:System.Xml.Serialization.XmlSerializer.UnknownElement>事件不会发生。  
  
   
  
## Examples  
 下面的示例将名为的类反序列化`Group`从名为 UnknownElements.xml 的文件。 每当在不具备对应成员在类中，该文件中找到的元素<xref:System.Xml.Serialization.XmlSerializer.UnknownElement>事件发生。 若要试用示例，请将以下 XML 代码粘贴到名为 UnknownElements.xml 的文件。  
  
```  
<?xml version="1.0" encoding="utf-8"?>  
<Group xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">  
  <GroupName>MyGroup</GroupName>  
  <GroupSize>Large</GroupSize>  
  <GroupNumber>444</GroupNumber>  
  <GroupBase>West</GroupBase>  
</Group>  
```  
  
 [!code-cpp[XmlSerializer.UnknownElement Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/XmlSerializer.UnknownElement Example/CPP/unknownelement.cpp#1)]
 [!code-csharp[XmlSerializer.UnknownElement Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/XmlSerializer.UnknownElement Example/CS/unknownelement.cs#1)]
 [!code-vb[XmlSerializer.UnknownElement Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/XmlSerializer.UnknownElement Example/VB/unknownelement.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.Serialization.XmlAnyElementAttribute" />
        <altmember cref="E:System.Xml.Serialization.XmlSerializer.UnknownNode" />
        <altmember cref="E:System.Xml.Serialization.XmlSerializer.UnknownAttribute" />
        <altmember cref="T:System.Xml.Serialization.XmlAttributes" />
      </Docs>
    </Member>
    <Member MemberName="UnknownNode">
      <MemberSignature Language="C#" Value="public event System.Xml.Serialization.XmlNodeEventHandler UnknownNode;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Xml.Serialization.XmlNodeEventHandler UnknownNode" />
      <MemberSignature Language="DocId" Value="E:System.Xml.Serialization.XmlSerializer.UnknownNode" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event UnknownNode As XmlNodeEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Xml::Serialization::XmlNodeEventHandler ^ UnknownNode;" />
      <MemberSignature Language="F#" Value="member this.UnknownNode : System.Xml.Serialization.XmlNodeEventHandler " Usage="member this.UnknownNode : System.Xml.Serialization.XmlNodeEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlSerializer</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Serialization.XmlNodeEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当 <see cref="T:System.Xml.Serialization.XmlSerializer" /> 在反序列化过程中遇到未知类型的 XML 节点时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 默认情况下，在调用<xref:System.Xml.Serialization.XmlSerializer.Deserialize%2A>方法，<xref:System.Xml.Serialization.XmlSerializer>忽略未知类型的 XML 节点。 但是，你可以使用此事件来处理此类节点类型。  
  
   
  
## Examples  
 下面的示例将打印任何遇到未知节点的类型。  
  
 [!code-cpp[Classic XmlSerializer.UnknownNode Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic XmlSerializer.UnknownNode Example/CPP/source.cpp#1)]
 [!code-csharp[Classic XmlSerializer.UnknownNode Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic XmlSerializer.UnknownNode Example/CS/source.cs#1)]
 [!code-vb[Classic XmlSerializer.UnknownNode Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic XmlSerializer.UnknownNode Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.Serialization.XmlAnyElementAttribute" />
        <altmember cref="T:System.Xml.Serialization.XmlAnyAttributeAttribute" />
        <altmember cref="M:System.Xml.Serialization.XmlSerializer.CanDeserialize(System.Xml.XmlReader)" />
        <altmember cref="M:System.Xml.Serialization.XmlSerializer.Deserialize(System.IO.Stream)" />
        <altmember cref="E:System.Xml.Serialization.XmlSerializer.UnknownAttribute" />
        <altmember cref="T:System.Xml.Serialization.XmlAttributes" />
      </Docs>
    </Member>
    <Member MemberName="UnreferencedObject">
      <MemberSignature Language="C#" Value="public event System.Xml.Serialization.UnreferencedObjectEventHandler UnreferencedObject;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Xml.Serialization.UnreferencedObjectEventHandler UnreferencedObject" />
      <MemberSignature Language="DocId" Value="E:System.Xml.Serialization.XmlSerializer.UnreferencedObject" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event UnreferencedObject As UnreferencedObjectEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Xml::Serialization::UnreferencedObjectEventHandler ^ UnreferencedObject;" />
      <MemberSignature Language="F#" Value="member this.UnreferencedObject : System.Xml.Serialization.UnreferencedObjectEventHandler " Usage="member this.UnreferencedObject : System.Xml.Serialization.UnreferencedObjectEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlSerializer</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Serialization.UnreferencedObjectEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在反序列化 SOAP 编码的 XML 流的过程中发生，此时 <see cref="T:System.Xml.Serialization.XmlSerializer" /> 遇到未使用（或未引用）的识别类型。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Xml.Serialization.XmlSerializer.UnreferencedObject>才会发生事件时<xref:System.Xml.Serialization.XmlSerializer>用于反序列化包含符合万维网联合会 (www.w3.org) 文档，"简单对象访问协议 (SOAP) 1.1"的第 5 节的 SOAP 消息的 XML 文档。  
  
 第 5 节符合的文档是特殊格式。 最起码这样的文档包括 SOAP 消息的正文。 但是，而不是具有所有类型以内联方式定义文档中，某些类型定义可以编码为对文档中的顶级元素的引用。 因此，为引用的正文中找到每个元素，必须有一个包含类型定义的相应元素。 要关联的引用的元素和类型定义，类型定义应当有`id`属性设置为唯一字符串 ID 和引用的元素具有`href`属性引用相同的 id。  
  
```  
<Group xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema" id="id1" n1:GroupName=".NET" GroupNumber="ZDI=" CreationDate="2002-05-02" xmlns:n1="http:'www.cpandl.com">  
    <PosInt xsi:type="xsd:nonNegativeInteger">10000</PosInt>  
    <GroupVehicle href="#id2" />  
  </Group>  
  <Vehicle id="id2" n1:type="Vehicle" xmlns:n1="http://www.w3.org/2001/XMLSchema-instance">  
    <licenseNumber xmlns:q1="http://www.w3.org/2001/XMLSchema" n1:type="q1:string">1234</licenseNumber>  
  </Vehicle>  
```  
  
 <xref:System.Xml.Serialization.XmlSerializer.UnreferencedObject>事件发生时在文档中，找到的类型定义但在主正文中的无参数引用它。 发生事件时，你可以通过检查来检索未引用的对象的 XML 类型<xref:System.Xml.Serialization.UnreferencedObjectEventArgs.UnreferencedObject%2A>属性<xref:System.Xml.Serialization.UnreferencedObjectEventArgs>类。 返回对象的 XML ID<xref:System.Xml.Serialization.UnreferencedObjectEventArgs.UnreferencedId%2A>属性。  
  
 <xref:System.Xml.Serialization.XmlSerializer.UnreferencedObject>事件不应与混淆<xref:System.Xml.Serialization.XmlSerializer.UnknownElement>和<xref:System.Xml.Serialization.XmlSerializer.UnknownNode>没有对应的 XML 节点或元素类型的类成员时，可能发生的事件。  
  
   
  
## Examples  
 下面的示例添加<xref:System.Xml.Serialization.UnreferencedObjectEventHandler>到<xref:System.Xml.Serialization.XmlSerializer>。 事件由处理`Serializer``_``UnreferencedObject`方法。 若要运行该示例，剪切并粘贴到名为"UnrefObj.xml"的文件的以下 XML。  
  
```  
<wrapper>  
  <Group xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema" id="id1" n1:GroupName=".NET" xmlns:n1="http://www.cpandl.com">  
   </Group>  
<Vehicle id="id2" n1:type="Vehicle" xmlns:n1="http://www.w3.org/2001/XMLSchema-instance">  
    <licenseNumber xmlns:q1="http://www.w3.org/2001/XMLSchema" n1:type="q1:string">ABCD</licenseNumber>  
  </Vehicle>  
<Vehicle id="id3" n1:type="Vehicle" xmlns:n1="http://www.w3.org/2001/XMLSchema-instance">  
    <licenseNumber xmlns:q1="http://www.w3.org/2001/XMLSchema" n1:type="q1:string">1234</licenseNumber>  
  </Vehicle>  
</wrapper>  
```  
  
 [!code-cpp[UnreferencedObject Event Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/UnreferencedObject Event Example/CPP/unrefobj.cpp#1)]
 [!code-csharp[UnreferencedObject Event Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/UnreferencedObject Event Example/CS/unrefobj.cs#1)]
 [!code-vb[UnreferencedObject Event Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/UnreferencedObject Event Example/VB/unrefobj.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.Serialization.XmlAttributes" />
      </Docs>
    </Member>
  </Members>
</Type>