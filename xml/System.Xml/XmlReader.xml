<Type Name="XmlReader" FullName="System.Xml.XmlReader">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="37a353caf29d29c75ad340309265d0f066961606" />
    <Meta Name="ms.sourcegitcommit" Value="0ec122ee5f3681159b8460ab15b409fd6e3d3ae0" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-CN" />
    <Meta Name="ms.lasthandoff" Value="10/04/2018" />
    <Meta Name="ms.locfileid" Value="48647323" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class XmlReader : IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit XmlReader extends System.Object implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Xml.XmlReader" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class XmlReader&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class XmlReader abstract : IDisposable" />
  <TypeSignature Language="F#" Value="type XmlReader = class&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Xml</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Diagnostics.DebuggerDisplay("{debuggerDisplayProxy}")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>表示提供对 XML 数据进行快速、非缓存、只进访问的读取器。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Xml.XmlReader> 提供对文档或流中的 XML 数据的只进、 只读访问。 此类符合 W3C[可扩展标记语言 (XML) 1.0 （第四版）](https://www.w3.org/TR/2006/REC-xml-20060816/)并[命名空间中 XML 1.0 （第三版）](https://www.w3.org/TR/REC-xml-names/)建议。  
  
 <xref:System.Xml.XmlReader> 方法可以遍历 XML 数据并读取节点的内容。 类的属性反映的是读取器定位在当前节点的值。<xref:System.Xml.XmlReader.ReadState%2A>属性值指示的 XML 读取器的当前状态。 例如，该属性设置为<xref:System.Xml.ReadState.Initial?displayProperty=nameWithType>由<xref:System.Xml.XmlReader.Read%2A?displayProperty=nameWithType>方法并<xref:System.Xml.ReadState.Closed?displayProperty=nameWithType>通过<xref:System.Xml.XmlReader.Close%2A?displayProperty=nameWithType>方法。 <xref:System.Xml.XmlReader> 此外提供了数据一致性检查并根据 DTD 或架构验证。  
  
 <xref:System.Xml.XmlReader> 使用请求模型检索数据。 此模型：  
  
-   通过自然的、 由上而下的过程优化简化了状态管理。  
  
-   支持多个输入的流和分层。  
  
-   允许客户端为分析器提供到其中字符串直接写入，并因此可以避免的额外字符串副本的缓冲区。  
  
-   支持有选择地处理。 客户端可以跳过的项目并处理那些感兴趣的应用程序。 此外可以设置属性提前以管理 XML 流 （例如规范化） 的处理方式。  
  
 本节内容：  
  
 [创建 XML 读取器](#xmlreader_create)   
 [验证 XML 数据](#xmlreader_validate)   
 [数据一致性](#xmlreader_data)   
 [节点中导航](#xmlreader_nodes)   
 [读取 XML 元素](#xmlreader_elements)   
 [读取 XML 属性](#xmlreader_attributes)   
 [读取 XML 内容](#xmlreader_content)   
 [将转换为 CLR 类型](#xmlreader_clr)   
 [异步编程](#xmlreader_async)   
 [安全注意事项](#xmlreader_security)  
  
<a name="xmlreader_create"></a>   
## <a name="creating-an-xml-reader"></a>创建 XML 读取器  
 使用<xref:System.Xml.XmlReader.Create%2A>方法来创建<xref:System.Xml.XmlReader>实例。  
  
 虽然.NET Framework 提供的具体实现，但<xref:System.Xml.XmlReader>类，如<xref:System.Xml.XmlTextReader>， <xref:System.Xml.XmlNodeReader>，和<xref:System.Xml.XmlValidatingReader>类，我们建议仅在这些方案中使用的专用的类：  
  
-   当你想要读取从 XML DOM 子树<xref:System.Xml.XmlNode>对象，请使用<xref:System.Xml.XmlNodeReader>类。 （但是，此类不支持 DTD 或架构验证。）  
  
-   如果您必须根据请求展开实体，你不想将文本内容规范化，或者不希望默认情况下返回的属性，使用<xref:System.Xml.XmlTextReader>类。  
  
 若要指定一组你想要的 XML 读取器上启用的功能，请将传递<xref:System.Xml.XmlReaderSettings?displayProperty=nameWithType>对象传递给<xref:System.Xml.XmlReader.Create%2A>方法。 可以使用单个<xref:System.Xml.XmlReaderSettings?displayProperty=nameWithType>要使用的相同功能，创建多个读取器的对象或修改<xref:System.Xml.XmlReaderSettings?displayProperty=nameWithType>对象创建新的读取器具有一组不同的功能。 与现有读取器，可以方便地添加功能。  
  
 如果不使用<xref:System.Xml.XmlReaderSettings?displayProperty=nameWithType>对象，则使用默认设置。 请参阅<xref:System.Xml.XmlReader.Create%2A>引用页面了解详细信息。  
  
 <xref:System.Xml.XmlReader> 引发<xref:System.Xml.XmlException>的 XML 分析错误。 引发异常后，读取器状态不是可预测的。 例如，报告的节点类型可能不同于当前节点的实际节点类型。 使用<xref:System.Xml.XmlReader.ReadState%2A>属性检查是否在读取器处于错误状态。  
  
<a name="xmlreader_validate"></a>   
## <a name="validating-xml-data"></a>验证 XML 数据  
 若要定义的 XML 文档及其元素关系、 数据类型和内容约束的结构，请使用文档类型定义 (DTD) 或 XML 架构定义语言 (XSD) 架构。 如果满足定义的所有语法要求，则格式正确 XML 文档被视为[W3C XML 1.0 建议](https://www.w3.org/TR/2006/REC-xml-20060816/)。 如果它的格式正确并且符合其 DTD 或架构定义的约束，它被视为有效。 (请参阅[W3C XML 架构第 1 部分： 结构](https://www.w3.org/TR/xmlschema-1/)并[W3C XML 架构第 2 部分： 数据类型](https://www.w3.org/TR/xmlschema-2/)建议。)因此，虽然所有有效的 XML 文档都是格式正确的，但并不是所有格式正确的 XML 文档都是有效的。  
  
 您可以验证数据针对 DTD，内联 XSD 架构或 XSD 架构存储在<xref:System.Xml.Schema.XmlSchemaSet>对象 （缓存）; 上介绍了这些方案<xref:System.Xml.XmlReader.Create%2A>参考页。 <xref:System.Xml.XmlReader> 不支持 XML 数据缩减 (XDR) 架构验证。  
  
 在使用以下设置<xref:System.Xml.XmlReaderSettings>类，以指定哪种类型的验证，如果有的话，<xref:System.Xml.XmlReader>实例支持。  
  
|使用此<xref:System.Xml.XmlReaderSettings>成员|若要指定|  
|-----------------------------------------------------------------------------------------------------------------------------------------------------------|----------------|  
|<xref:System.Xml.XmlReaderSettings.DtdProcessing%2A> 属性|是否允许 DTD 处理。 默认设置为不允许 DTD 处理。|  
|<xref:System.Xml.XmlReaderSettings.ValidationType%2A> 属性|读取器是否应验证数据，以及要执行 （DTD 或架构） 的验证类型。 默认设置为无数据验证。|  
|<xref:System.Xml.XmlReaderSettings.ValidationEventHandler>事件|事件处理程序接收的验证事件的相关信息。 如果未提供事件处理程序，在出现第一个验证错误时将引发 <xref:System.Xml.XmlException>。|  
|<xref:System.Xml.XmlReaderSettings.ValidationFlags%2A> 属性|其他验证选项通过<xref:System.Xml.Schema.XmlSchemaValidationFlags>枚举成员：<br /><br /> -   `AllowXmlAttributes`-允许 XML 特性 (`xml:*`) 在实例文档，即使它们不在架构中定义中。 属性基于其数据类型进行验证。 请参阅<xref:System.Xml.Schema.XmlSchemaValidationFlags>设置以在特定方案中使用的参考页。 （默认情况下禁用）。<br />-   `ProcessIdentityConstraints` -处理标识约束 (`xs:ID`， `xs:IDREF`， `xs:key`， `xs:keyref`， `xs:unique`) 验证过程中遇到。 （默认情况下启用）。<br />-   `ProcessSchemaLocation` -处理由指定的架构`xsi:schemaLocation`或`xsi:noNamespaceSchemaLocation`属性。 （默认情况下启用）。<br />-   `ProcessInlineSchema`-在验证过程中处理内联 XML 架构。 （默认情况下禁用）。<br />-   `ReportValidationWarnings`-如果发生验证警告报告事件。 如果没有验证特定元素或属性时所依据的 DTD 或 XML 架构，通常会发出警告。 <xref:System.Xml.XmlReaderSettings.ValidationEventHandler> 用于通知。 （默认情况下禁用）。|  
|<xref:System.Xml.XmlReaderSettings.Schemas%2A>|用于验证的 <xref:System.Xml.Schema.XmlSchemaSet>。|  
|<xref:System.Xml.XmlReaderSettings.XmlResolver%2A> 属性|<xref:System.Xml.XmlResolver>用于解析和访问外部资源。 这可以包括外部实体，例如 DTD 和架构和任何`xs:include`或`xs:import`XML 架构中包含的元素。 如果未指定<xref:System.Xml.XmlResolver>，则<xref:System.Xml.XmlReader>使用的默认值<xref:System.Xml.XmlUrlResolver>使用没有用户凭据。|  
  
<a name="xmlreader_data"></a>   
## <a name="data-conformance"></a>数据一致性  
 通过创建的 XML 读取器<xref:System.Xml.XmlReader.Create%2A>方法默认情况下满足以下符合性要求：  
  
-   新行和属性值根据 W3C 进行规范化[XML 1.0 建议](https://www.w3.org/TR/2006/REC-xml-20060816/)。  
  
-   自动展开所有实体。  
  
-   即使在不会验证读取器时，总是会添加文档类型定义中声明的默认属性。  
  
-   允许的声明映射到正确的 XML 命名空间 URI 的 XML 前缀。  
  
-   在单个的表示法名称`NotationType`特性声明并`NmTokens`在单个`Enumeration`特性声明是不同的。  
  
 使用这些<xref:System.Xml.XmlReaderSettings>属性以指定类型的一致性检查你想要启用：  
  
|使用此<xref:System.Xml.XmlReaderSettings>属性|到|默认|  
|-------------------------------------------------------------------------------------------------------------------------------------------------------------|--------|-------------|  
|<xref:System.Xml.XmlReaderSettings.CheckCharacters%2A> 属性|启用或禁用以下检查：<br /><br /> 的由定义字符是合法的 XML 字符的范围内[2.2 字符](https://www.w3.org/TR/2006/REC-xml-20060816/#charsets)W3C XML 1.0 建议的部分。<br />的由定义所有 XML 名称都是否有效， [2.3 常用语法构造](https://www.w3.org/TR/2006/REC-xml-20060816/#NT-Name)W3C XML 1.0 建议的部分。<br /><br /> 当此属性设置为`true`（默认值），<xref:System.Xml.XmlException>引发异常，如果 XML 文件中包含非法字符或无效的 XML 名称 （例如，元素名称以数字开头）。|启用了字符和名称检查。<br /><br /> 将 <xref:System.Xml.XmlReaderSettings.CheckCharacters%2A> 设置为 `false` 会禁用对字符实体引用的字符检查。 如果读取器正在处理文本数据，始终检查 XML 名称是否有效，而不考虑此设置。 **注意：** XML 1.0 建议要求文档级别的一致性，如果存在 DTD。 因此，如果读取器配置为支持<xref:System.Xml.ConformanceLevel.Fragment?displayProperty=nameWithType>，但是 XML 数据包含文档类型定义 (DTD)<xref:System.Xml.XmlException>引发。|  
|<xref:System.Xml.XmlReaderSettings.ConformanceLevel%2A> 属性|选择强制实施的一致性的级别：<br /><br /> -   <xref:System.Xml.ConformanceLevel.Document>. 符合的规则[格式正确的 XML 1.0 文档](https://www.w3.org/TR/2006/REC-xml-20060816/#sec-well-formed)。<br />-   <xref:System.Xml.ConformanceLevel.Fragment>. 符合格式正确的文档片段，可以随着变化所消耗的规则[外部已分析的实体](https://www.w3.org/TR/2006/REC-xml-20060816/#wf-entities)。<br />-   <xref:System.Xml.ConformanceLevel.Auto>. 符合由读取器决定的级别。<br /><br /> 如果数据不符合规则，<xref:System.Xml.XmlException>引发异常。|<xref:System.Xml.ConformanceLevel.Document>|  
  
<a name="xmlreader_nodes"></a>   
## <a name="navigating-through-nodes"></a>节点中导航  
 当前节点是 XML 读取器当前定位在的 XML 节点。 所有<xref:System.Xml.XmlReader>方法执行与此节点及其所有相关的操作<xref:System.Xml.XmlReader>属性反映了当前节点的值。  
  
 以下方法轻松导航节点和分析数据。  
  
|使用此<xref:System.Xml.XmlReaderSettings>方法|到|  
|-----------------------------------------------------------------------------------------------------------------------------------------------------------|--------|  
|<xref:System.Xml.XmlReader.Read%2A>|读取的第一个节点，并进一步处理流的一个节点，一次。 此类调用通常执行内部`while`循环。<br /><br /> 使用<xref:System.Xml.XmlReader.NodeType%2A>属性来获取当前节点的类型 （例如，属性、 注释、 元素和等等）。|  
|<xref:System.Xml.XmlReader.Skip%2A>|跳过当前节点的子级，将移动到下一个节点。|  
|<xref:System.Xml.XmlReader.MoveToContent%2A> 和 <xref:System.Xml.XmlReader.MoveToContentAsync%2A>|跳过非内容节点，将移到下一个内容节点或文件的末尾。<br /><br /> 非内容节点包括<xref:System.Xml.XmlNodeType.ProcessingInstruction>， <xref:System.Xml.XmlNodeType.DocumentType>， <xref:System.Xml.XmlNodeType.Comment>， <xref:System.Xml.XmlNodeType.Whitespace>，和<xref:System.Xml.XmlNodeType.SignificantWhitespace>。<br /><br /> 内容节点包括非空白文本<xref:System.Xml.XmlNodeType.CDATA>， <xref:System.Xml.XmlNodeType.EntityReference> ，和<xref:System.Xml.XmlNodeType.EndEntity>。|  
|<xref:System.Xml.XmlReader.ReadSubtree%2A>|读取元素及其所有子级，并返回一个新<xref:System.Xml.XmlReader>实例设置为<xref:System.Xml.ReadState.Initial?displayProperty=nameWithType>。<br /><br /> 此方法可用于创建 XML 元素，则周围的边界例如，如果你想要将数据传递给另一个组件进行处理，并且你想要限制的数据量可以访问该组件。|  
  
 请参阅<xref:System.Xml.XmlReader.Read%2A?displayProperty=nameWithType>一次文本流的一个节点中导航和显示的每个节点类型的示例的参考页。  
  
 以下各节描述如何可以读取特定类型的数据，如元素、 特性和类型化数据。  
  
<a name="xmlreader_elements"></a>   
## <a name="reading-xml-elements"></a>读取 XML 元素  
 下表列出的方法和属性的<xref:System.Xml.XmlReader>类提供了用于处理元素。 在 <xref:System.Xml.XmlReader> 置于某个元素上之后，节点属性（例如 <xref:System.Xml.XmlReader.Name%2A>）将反映元素的值。 除了下面所述的成员之外，<xref:System.Xml.XmlReader> 类的任何常规方法和属性也可以用于处理元素。 例如，可以使用 <xref:System.Xml.XmlReader.ReadInnerXml%2A> 方法读取元素的内容。  
  
> [!NOTE]
>  请参阅部分 3.1 [W3C XML 1.0 建议](https://www.w3.org/TR/2006/REC-xml-20060816/#sec-starttags)有关的开始标记定义，结束标记和空元素标记。  
  
|使用此<xref:System.Xml.XmlReader>成员|到|  
|---------------------------------------------------------------------------------------------------------------------------------------------------|--------|  
|<xref:System.Xml.XmlReader.IsStartElement%2A> 方法|检查当前节点是开始标记还是空元素标记。|  
|<xref:System.Xml.XmlReader.ReadStartElement%2A> 方法|检查当前节点是一个元素，并使读取器前进到下一个节点 (调用<xref:System.Xml.XmlReader.IsStartElement%2A>跟<xref:System.Xml.XmlReader.Read%2A>)。|  
|<xref:System.Xml.XmlReader.ReadEndElement%2A> 方法|检查当前节点为结束标记，并使读取器前进到下一个节点。|  
|<xref:System.Xml.XmlReader.ReadElementString%2A> 方法|读取纯文本元素。|  
|<xref:System.Xml.XmlReader.ReadToDescendant%2A> 方法|使 XML 读取器前进到下一个具有指定的名称的后代 （子） 元素。|  
|<xref:System.Xml.XmlReader.ReadToNextSibling%2A> 方法|使 XML 读取器前进到具有指定的名称的下一个同级元素。|  
|<xref:System.Xml.XmlReader.IsEmptyElement%2A> 属性|检查当前元素是否为结束元素标记。 例如:<br /><br /> -   `<item num="123"/>` (<xref:System.Xml.XmlReader.IsEmptyElement%2A>是`true`。)<br />-   `<item num="123"> </item>` (<xref:System.Xml.XmlReader.IsEmptyElement%2A>是`false`，尽管该元素的内容为空。)|  
  
 读取元素的文本内容的示例，请参阅<xref:System.Xml.XmlReader.ReadString%2A>方法。 下面的示例使用的处理元素`while`循环。  
  
 [!code-csharp[XmlReaderBasic#10](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#10)]
 [!code-vb[XmlReaderBasic#10](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#10)]  
  
<a name="xmlreader_attributes"></a>   
## <a name="reading-xml-attributes"></a>读取 XML 属性  
 XML 属性最常见的元素，但它们还允许在 XML 声明和文档类型节点上。  
  
 当定位在元素节点上<xref:System.Xml.XmlReader.MoveToAttribute%2A>方法可以用来通过元素的属性列表。 请注意，之后<xref:System.Xml.XmlReader.MoveToAttribute%2A>已调用，节点属性如<xref:System.Xml.XmlReader.Name%2A>， <xref:System.Xml.XmlReader.NamespaceURI%2A>，和<xref:System.Xml.XmlReader.Prefix%2A>反映该属性的属性，不是该属性的元素的属性属于。  
  
 <xref:System.Xml.XmlReader>类提供了这些方法和属性来读取和处理的元素的属性。  
  
|使用此<xref:System.Xml.XmlReader>成员|到|  
|---------------------------------------------------------------------------------------------------------------------------------------------------|--------|  
|<xref:System.Xml.XmlReader.HasAttributes%2A> 属性|检查当前节点是否有任何属性。|  
|<xref:System.Xml.XmlReader.AttributeCount%2A> 属性|获取当前元素上的属性。|  
|<xref:System.Xml.XmlReader.MoveToFirstAttribute%2A> 方法|将移动到的元素中的第一个属性。|  
|<xref:System.Xml.XmlReader.MoveToNextAttribute%2A> 方法|将移动到下一个元素的属性中。|  
|<xref:System.Xml.XmlReader.MoveToAttribute%2A> 方法|将移动到指定的属性。|  
|<xref:System.Xml.XmlReader.GetAttribute%2A> 方法或<xref:System.Xml.XmlReader.Item%2A>属性|获取指定属性的值。|  
|<xref:System.Xml.XmlReader.IsDefault%2A> 属性|检查当前节点是否是从 DTD 或架构中定义的默认值生成属性。|  
|<xref:System.Xml.XmlReader.MoveToElement%2A> 方法|将移动到拥有当前属性的元素。 此方法用于通过其属性导航后返回到该元素。|  
|<xref:System.Xml.XmlReader.ReadAttributeValue%2A> 方法|属性值分析为一个或多个`Text`， `EntityReference`，或`EndEntity`节点。|  
  
 任何常规的 <xref:System.Xml.XmlReader> 方法和属性也可以用于处理属性。 例如，在 <xref:System.Xml.XmlReader> 位于某个属性上之后，<xref:System.Xml.XmlReader.Name%2A> 和 <xref:System.Xml.XmlReader.Value%2A> 属性将反映该属性的值。 也可以使用任何内容 `Read` 方法来获取属性的值。  
  
 此示例使用<xref:System.Xml.XmlReader.AttributeCount%2A>属性来浏览在元素上的所有属性。  
  
 [!code-csharp[XmlReaderBasic#1](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#1)]
 [!code-vb[XmlReaderBasic#1](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#1)]  
  
 此示例使用<xref:System.Xml.XmlReader.MoveToNextAttribute%2A>中的方法`while`循环来导航属性。  
  
 [!code-csharp[XmlReaderBasic#6](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#6)]
 [!code-vb[XmlReaderBasic#6](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#6)]  
  
 **读取 XML 声明节点的属性**  
  
 如果 XML 读取器定位在 XML 声明节点，<xref:System.Xml.XmlReader.Value%2A>属性返回版本、 独立版和编码信息作为单个字符串。 <xref:System.Xml.XmlReader> 创建的对象<xref:System.Xml.XmlReader.Create%2A>方法，<xref:System.Xml.XmlTextReader>类，和<xref:System.Xml.XmlValidatingReader>类公开版本、 独立版和编码项作为属性。  
  
 **读取文档类型节点的属性**  
  
 XML 读取器定位在文档类型节点上时<xref:System.Xml.XmlReader.GetAttribute%2A>方法和<xref:System.Xml.XmlReader.Item%2A>属性可以用于返回 SYSTEM 和 PUBLIC 文本的值。 例如，调用 `reader.GetAttribute("PUBLIC")` 将返回 PUBLIC 值。  
  
 **读取属性上处理指令节点**  
  
 在 <xref:System.Xml.XmlReader> 位于某个处理指令节点上时，<xref:System.Xml.XmlReader.Value%2A> 属性将返回整个文本内容。 处理指令节点中的项不会被作为属性对待。 它们不能使用读取<xref:System.Xml.XmlReader.GetAttribute%2A>或<xref:System.Xml.XmlReader.MoveToAttribute%2A>方法。  
  
<a name="xmlreader_content"></a>   
## <a name="reading-xml-content"></a>读取 XML 内容  
 XMLReader 类包括以下成员，从 XML 文件中读取内容并将内容返回为字符串值。 (若要返回的 CLR 类型，请参阅[下一节](#xmlreader_clr)。)  
  
|使用此<xref:System.Xml.XmlReader>成员|到|  
|---------------------------------------------------------------------------------------------------------------------------------------------------|--------|  
|<xref:System.Xml.XmlReader.Value%2A> 属性|获取当前节点的文本内容。 返回的值取决于节点类型中;请参阅<xref:System.Xml.XmlReader.Value%2A>引用页面了解详细信息。|  
|<xref:System.Xml.XmlReader.ReadString%2A> 方法|获取作为字符串的元素或文本节点的内容。 此方法停止处理指令和注释。<br /><br /> 此方法如何处理特定节点类型的详细信息，请参阅<xref:System.Xml.XmlReader.ReadString%2A>参考页。|  
|<xref:System.Xml.XmlReader.ReadInnerXml%2A> 和 <xref:System.Xml.XmlReader.ReadInnerXmlAsync%2A> 方法|获取当前节点，包括标记中，但不包括开始和结束标记的所有内容。 例如，对于：<br /><br /> `<node>this<child id="123"/></node>`<br /><br /> <xref:System.Xml.XmlReader.ReadInnerXml%2A> 返回：<br /><br /> `this<child id="123"/>`|  
|<xref:System.Xml.XmlReader.ReadOuterXml%2A> 和 <xref:System.Xml.XmlReader.ReadOuterXmlAsync%2A> 方法|获取当前节点及其子级，包括标记和开始/结束标记的所有内容。 例如，对于：<br /><br /> `<node>this<child id="123"/></node>`<br /><br /> <xref:System.Xml.XmlReader.ReadOuterXml%2A> 返回：<br /><br /> `<node>this<child id="123"/></node>`|  
  
<a name="xmlreader_clr"></a>   
## <a name="converting-to-clr-types"></a>将转换为 CLR 类型  
 可以使用的成员<xref:System.Xml.XmlReader>类 （在下表中列出） 来读取 XML 数据和返回值，作为公共语言运行时 (CLR) 类型，而不是字符串。 这些成员可以是最适合您的编码任务而无需手动分析或转换字符串值的表示形式获取值。  
  
-   **ReadElementContentAs**只能在元素节点类型上调用方法。 这些方法不能在包含子元素或混合内容的元素上使用。 在调用时，<xref:System.Xml.XmlReader> 对象读取开始标记，读取元素内容，然后移过结束元素标记。 将忽略处理指令和注释并展开实体。  
  
-   **ReadContentAs**方法读取读取器当前位置处的文本内容和 XML 数据不具有任何架构或数据类型信息与之关联，如果将文本内容转换为请求的返回类型。 文本、空白、有效空白和 CDATA 节串联在一起。 跳过注释和处理指令，而实体引用自动解决。  
  
 <xref:System.Xml.XmlReader>类使用定义的规则[W3C XML 架构第 2 部分： 数据类型](https://www.w3.org/TR/xmlschema-2/)建议。  
  
|使用此<xref:System.Xml.XmlReader>方法|返回此 CLR 类型|  
|--------------------------------------------------------------------------------------------------------------------------------------------------|-----------------------------|  
|<xref:System.Xml.XmlReader.ReadContentAsBoolean%2A> 和 <xref:System.Xml.XmlReader.ReadElementContentAsBoolean%2A>|<xref:System.Boolean>|  
|<xref:System.Xml.XmlReader.ReadContentAsDateTime%2A> 和 <xref:System.Xml.XmlReader.ReadElementContentAsDateTime%2A>|<xref:System.DateTime>|  
|<xref:System.Xml.XmlReader.ReadContentAsDouble%2A> 和 <xref:System.Xml.XmlReader.ReadElementContentAsDouble%2A>|<xref:System.Double>|  
|<xref:System.Xml.XmlReader.ReadContentAsLong%2A> 和 <xref:System.Xml.XmlReader.ReadElementContentAsLong%2A>|<xref:System.Int64>|  
|<xref:System.Xml.XmlReader.ReadContentAsInt%2A> 和 <xref:System.Xml.XmlReader.ReadElementContentAsInt%2A>|<xref:System.Int32>|  
|<xref:System.Xml.XmlReader.ReadContentAsString%2A> 和 <xref:System.Xml.XmlReader.ReadElementContentAsString%2A>|<xref:System.String>|  
|<xref:System.Xml.XmlReader.ReadContentAs%2A> 和 <xref:System.Xml.XmlReader.ReadElementContentAs%2A>|使用指定的类型`returnType`参数|  
|<xref:System.Xml.XmlReader.ReadContentAsObject%2A> 和 <xref:System.Xml.XmlReader.ReadElementContentAsObject%2A>|最适合的类型，由指定<xref:System.Xml.XmlReader.ValueType%2A?displayProperty=nameWithType>属性。 请参阅[System.Xml 类中的类型支持](~/docs/standard/data/xml/type-support-in-the-system-xml-classes.md)映射信息。|  
  
 如果元素不能轻松地转换为 CLR 类型由于其格式，可以使用架构映射，确保成功转换。 以下示例使用一个.xsd 文件将转换`hire-date`元素`xs:date`类型，然后使用<xref:System.Xml.XmlReader.ReadElementContentAsDateTime%2A>方法以返回元素作为<xref:System.DateTime>对象。  
  
 **输入 (hireDate.xml):**  
  
 [!code-xml[XmlReader.ReadElementContentAs#9](~/samples/snippets/xml/VS_Snippets_Data/XmlReader.ReadElementContentAs/XML/hireDate.xml#9)]  
  
 **架构 (hireDate.xsd):**  
  
 [!code-xml[XmlReader.ReadElementContentAs#10](~/samples/snippets/xml/VS_Snippets_Data/XmlReader.ReadElementContentAs/XML/hireDate.xsd#10)]  
  
 **代码：**  
  
 [!code-csharp[XmlReader.ReadElementContentAs#13](~/samples/snippets/csharp/VS_Snippets_Data/XmlReader.ReadElementContentAs/CS/readElementContentAs.cs#13)]
 [!code-vb[XmlReader.ReadElementContentAs#13](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReader.ReadElementContentAs/VB/readElementContentAs.vb#13)]  
  
 **输出：**  
  
```  
Six Month Review Date:  7/8/2003 12:00:00 AM  
```  
  
<a name="xmlreader_async"></a>   
## <a name="asynchronous-programming"></a>异步编程  
 大多数的<xref:System.Xml.XmlReader>方法都具有有"Async"它们的方法名称结尾处的异步对应项。 例如，异步等效于<xref:System.Xml.XmlReader.ReadContentAsObject%2A>是<xref:System.Xml.XmlReader.ReadContentAsObjectAsync%2A>。  
  
 可以通过异步方法调用使用以下方法：  
  
-   <xref:System.Xml.XmlReader.GetAttribute%2A>  
  
-   <xref:System.Xml.XmlReader.MoveToAttribute%2A>  
  
-   <xref:System.Xml.XmlReader.MoveToFirstAttribute%2A>  
  
-   <xref:System.Xml.XmlReader.MoveToNextAttribute%2A>  
  
-   <xref:System.Xml.XmlReader.MoveToElement%2A>  
  
-   <xref:System.Xml.XmlReader.ReadAttributeValue%2A>  
  
-   <xref:System.Xml.XmlReader.ReadSubtree%2A>  
  
-   <xref:System.Xml.XmlReader.ResolveEntity%2A>  
  
 以下各节介绍异步的方法没有异步对应项的使用情况。  
  
 **ReadStartElement 方法**  
  
 [!code-csharp[System.Xml.XmlReader.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.xml.xmlreader.class/cs/program.cs#1)]
 [!code-vb[System.Xml.XmlReader.Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.xml.xmlreader.class/vb/module1.vb#1)]  
  
 **ReadEndElement 方法**  
  
 [!code-csharp[System.Xml.XmlReader.Class#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.xml.xmlreader.class/cs/program.cs#2)]
 [!code-vb[System.Xml.XmlReader.Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.xml.xmlreader.class/vb/module1.vb#2)]  
  
 **ReadToNextSibling 方法**  
  
 [!code-csharp[System.Xml.XmlReader.Class#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.xml.xmlreader.class/cs/program.cs#3)]
 [!code-vb[System.Xml.XmlReader.Class#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.xml.xmlreader.class/vb/module1.vb#3)]  
  
 **ReadToFollowing 方法**  
  
 [!code-csharp[System.Xml.XmlReader.Class#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.xml.xmlreader.class/cs/program.cs#4)]
 [!code-vb[System.Xml.XmlReader.Class#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.xml.xmlreader.class/vb/module1.vb#4)]  
  
 **ReadToDescendant 方法**  
  
 [!code-csharp[System.Xml.XmlReader.Class#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.xml.xmlreader.class/cs/program.cs#5)]
 [!code-vb[System.Xml.XmlReader.Class#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.xml.xmlreader.class/vb/module1.vb#5)]  
  
<a name="xmlreader_security"></a>   
## <a name="security-considerations"></a>安全注意事项  
 使用时，请考虑以下<xref:System.Xml.XmlReader>类：  
  
-   从引发的异常<xref:System.Xml.XmlReader>可能会泄露冒泡到您的应用程序可能不希望的路径信息。 您的应用程序必须捕获异常并进行相应的处理。  
  
-   不要启用 DTD 处理，如果你担心拒绝服务问题或如果您正在处理不可信的源。 默认情况下禁用 DTD 处理<xref:System.Xml.XmlReader>创建的对象<xref:System.Xml.XmlReader.Create%2A>方法。  
  
     如果启用了 DTD 处理，可以使用 <xref:System.Xml.XmlSecureResolver> 限制 <xref:System.Xml.XmlReader> 可以访问的资源。 此外可以设计您的应用程序，以使 XML 处理受内存和时间约束。 例如，你可以配置 ASP.NET 应用程序中的超时限制。  
  
-   XML 数据可以包含对外部资源（例如架构文件）的引用。 默认情况下，通过解析外部资源<xref:System.Xml.XmlUrlResolver>使用没有用户凭据的对象。 通过执行下列操作之一，可以使此操作更加安全：  
  
    -   通过将 <xref:System.Xml.XmlReader> 属性设置为 <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType> 对象限制 <xref:System.Xml.XmlSecureResolver> 可访问的资源。  
  
    -   通过将 <xref:System.Xml.XmlReader> 属性设置为 <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType>，不允许 `null` 打开任何外部资源。  
  
-   <xref:System.Xml.Schema.XmlSchemaValidationFlags.ProcessInlineSchema>并<xref:System.Xml.Schema.XmlSchemaValidationFlags.ProcessSchemaLocation>验证标志<xref:System.Xml.XmlReaderSettings>对象不默认设置。 这样，在处理来自不可信的源的 XML 数据时，可以帮助防止 <xref:System.Xml.XmlReader> 受到基于架构的攻击。 设置了这些标志后，<xref:System.Xml.XmlReaderSettings.XmlResolver%2A> 对象的 <xref:System.Xml.XmlReaderSettings> 用于在 <xref:System.Xml.XmlReader> 中解析实例文档中遇到的架构位置。 如果<xref:System.Xml.XmlReaderSettings.XmlResolver%2A>属性设置为`null`，架构位置不是解析即使<xref:System.Xml.Schema.XmlSchemaValidationFlags.ProcessInlineSchema>和<xref:System.Xml.Schema.XmlSchemaValidationFlags.ProcessSchemaLocation>设置验证标志。  
  
     在验证过程中添加的架构会添加新类型，并且可能更改被验证的文档的验证结果。 因此，只应从可信的源解析外部架构。  
  
     我们建议禁用<xref:System.Xml.Schema.XmlSchemaValidationFlags.ProcessIdentityConstraints>标志时验证不可信的大型 XML 文档中的高可用性方案中，针对文档的很大程度上具有标识约束的架构。 默认情况下启用此标志。  
  
-   XML 数据可以包含大量属性、命名空间声明、嵌套元素等，需要大量的时间来处理。 将发送到的输入的大小限制<xref:System.Xml.XmlReader>，你可以：  
  
    -   通过设置限制的文档大小<xref:System.Xml.XmlReaderSettings.MaxCharactersInDocument%2A>属性。  
  
    -   限制通过设置扩展实体产生的字符数<xref:System.Xml.XmlReaderSettings.MaxCharactersFromEntities%2A>属性。  
  
    -   创建自定义`IStream`实现<xref:System.Xml.XmlReader>。  
  
-   <xref:System.Xml.XmlReader.ReadValueChunk%2A>方法可用于处理大数据的数据流。 此方法一次读取少量的字符，而不是为整个值分配单个字符串。  
  
-   在读取 XML 文档具有大量唯一的本地名称、 命名空间或前缀，则会出现问题。 如果您使用的派生的类<xref:System.Xml.XmlReader>，并调用<xref:System.Xml.XmlReader.LocalName%2A>， <xref:System.Xml.XmlReader.Prefix%2A>，或<xref:System.Xml.XmlReader.NamespaceURI%2A>每个项的属性，则返回的字符串添加到<xref:System.Xml.NameTable>。 包含的集合<xref:System.Xml.NameTable>绝不会减小大小，创建字符串句柄的虚拟内存泄漏。 有关这一种解决方法是从派生<xref:System.Xml.NameTable>类，并强制实施最大大小配额。 (没有方法来防止利用<xref:System.Xml.NameTable>，或切换<xref:System.Xml.NameTable>已满时)。 另一种缓解是避免使用提到的属性，并改用<xref:System.Xml.XmlReader.MoveToAttribute%2A>方法替换<xref:System.Xml.XmlReader.IsStartElement%2A>方法在可能的情况; 这些方法不返回的字符串和这样可以避免过度填充问题<xref:System.Xml.NameTable>集合。  
  
-   <xref:System.Xml.XmlReaderSettings> 对象可以包含敏感信息，例如用户凭据。 不可信的组件可能会使用 <xref:System.Xml.XmlReaderSettings> 对象及其用户凭据来创建 <xref:System.Xml.XmlReader> 对象，以读取数据。 缓存时要小心<xref:System.Xml.XmlReaderSettings>对象，或传递时<xref:System.Xml.XmlReaderSettings>到另一个对象从一个组件。  
  
-   不接受来自不可信的源的支持组件，例如 <xref:System.Xml.NameTable>、<xref:System.Xml.XmlNamespaceManager> 和 <xref:System.Xml.XmlResolver> 对象。  
  
   
  
## Examples  
 下面的代码示例演示如何使用异步 API 来分析 XML。  
  
 [!code-csharp[System.Xml.XmlReader.Class#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.xml.xmlreader.class/cs/program.cs#6)]
 [!code-vb[System.Xml.XmlReader.Class#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.xml.xmlreader.class/vb/module1.vb#6)]  
  
 ]]></format>
    </remarks>
    <related type="Article" href="http://msdn.microsoft.com/library/e695047f-3c0f-4045-8708-5baea91cc380">XML 文档和数据</related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected XmlReader ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; XmlReader();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>初始化 <see langword="XmlReader" /> 类的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在派生的类构造函数来初始化此类型中的状态将调用此构造函数。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AttributeCount">
      <MemberSignature Language="C#" Value="public abstract int AttributeCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 AttributeCount" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.AttributeCount" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property AttributeCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property int AttributeCount { int get(); };" />
      <MemberSignature Language="F#" Value="member this.AttributeCount : int" Usage="System.Xml.XmlReader.AttributeCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当在派生类中被重写时，获取当前节点上的属性数。</summary>
        <value>当前节点上的属性数目。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此属性是与相关`Element`，`DocumentType`和`XmlDeclaration`仅限节点。 （其他节点类型没有属性。）  
  
   
  
## Examples  
 下面的示例显示当前节点上的所有属性。  
  
 [!code-csharp[XmlReaderBasic#1](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#1)]
 [!code-vb[XmlReaderBasic#1](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”</exception>
      </Docs>
    </Member>
    <Member MemberName="BaseURI">
      <MemberSignature Language="C#" Value="public abstract string BaseURI { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string BaseURI" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.BaseURI" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property BaseURI As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::String ^ BaseURI { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.BaseURI : string" Usage="System.Xml.XmlReader.BaseURI" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当在派生类中被重写时，获取当前节点的基 URI。</summary>
        <value>当前节点的基 URI。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 联网的 XML 文档的聚合使用各种 W3C 标准包含机制的数据块组成，因此包含来自不同位置的节点。 DTD 实体就是一个例子，但这并不局限于 Dtd。 基 URI 将指示您从这些节点的源位置。 如果没有要返回的节点没有基 URI （例如，它们已从分析的内存中字符串），`String.Empty`返回。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”</exception>
      </Docs>
    </Member>
    <Member MemberName="CanReadBinaryContent">
      <MemberSignature Language="C#" Value="public virtual bool CanReadBinaryContent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanReadBinaryContent" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.CanReadBinaryContent" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property CanReadBinaryContent As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanReadBinaryContent { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanReadBinaryContent : bool" Usage="System.Xml.XmlReader.CanReadBinaryContent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示 <see cref="T:System.Xml.XmlReader" /> 是否实现二进制内容读取方法。</summary>
        <value>如果实现了二进制内容读取方法，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 二进制内容读取方法包括<xref:System.Xml.XmlReader.ReadContentAsBase64%2A>， <xref:System.Xml.XmlReader.ReadContentAsBinHex%2A>， <xref:System.Xml.XmlReader.ReadElementContentAsBase64%2A>，和<xref:System.Xml.XmlReader.ReadElementContentAsBinHex%2A>方法。 如果此属性返回`false`<xref:System.NotSupportedException>任何二进制文件读取时，将返回调用方法。  
  
 所有 Microsoft.NET Framework 实现<xref:System.Xml.XmlReader>类返回`true`此属性。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”</exception>
      </Docs>
    </Member>
    <Member MemberName="CanReadValueChunk">
      <MemberSignature Language="C#" Value="public virtual bool CanReadValueChunk { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanReadValueChunk" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.CanReadValueChunk" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property CanReadValueChunk As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanReadValueChunk { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanReadValueChunk : bool" Usage="System.Xml.XmlReader.CanReadValueChunk" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示 <see cref="T:System.Xml.XmlReader" /> 是否实现 <see cref="M:System.Xml.XmlReader.ReadValueChunk(System.Char[],System.Int32,System.Int32)" /> 方法。</summary>
        <value>如果 <see cref="T:System.Xml.XmlReader" /> 实现 <see cref="M:System.Xml.XmlReader.ReadValueChunk(System.Char[],System.Int32,System.Int32)" /> 方法，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 文本分析<xref:System.Xml.XmlReader>创建从静态对象<xref:System.Xml.XmlReader.Create%2A>方法将始终返回`true`。 所有其他 Microsoft.NET Framework 实现<xref:System.Xml.XmlReader>类，其中包括<xref:System.Xml.XmlTextReader>类中，返回`false`。  
  
 如果此属性返回`false`<xref:System.NotSupportedException>时，将返回<xref:System.Xml.XmlReader.ReadValueChunk%2A>调用方法。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”</exception>
      </Docs>
    </Member>
    <Member MemberName="CanResolveEntity">
      <MemberSignature Language="C#" Value="public virtual bool CanResolveEntity { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanResolveEntity" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.CanResolveEntity" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property CanResolveEntity As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanResolveEntity { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanResolveEntity : bool" Usage="System.Xml.XmlReader.CanResolveEntity" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示此读取器是否可以分析和解析实体。</summary>
        <value>如果此读取器可以分析和解析实体，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此属性始终返回`false`的实现<xref:System.Xml.XmlReader>不支持 DTD 信息。 在这种情况下，调用<xref:System.Xml.XmlReader.ResolveEntity%2A>将引发异常。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”</exception>
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public virtual void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.Close" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Close();" />
      <MemberSignature Language="F#" Value="abstract member Close : unit -&gt; unit&#xA;override this.Close : unit -&gt; unit" Usage="xmlReader.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>当在派生类中被重写时，将 <see cref="P:System.Xml.XmlReader.ReadState" /> 更改为 <see cref="F:System.Xml.ReadState.Closed" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法也会释放读取过程中占用任何资源。 如果<xref:System.Xml.XmlReader.Close%2A>已被调用，不执行任何操作。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Create">
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>创建一个新的 <see cref="T:System.Xml.XmlReader" /> 实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 大部分<xref:System.Xml.XmlReader.Create%2A>重载包括`settings`接受参数<xref:System.Xml.XmlReaderSettings>对象。 可以使用此对象：  
  
-   指定你希望在上受支持的功能<xref:System.Xml.XmlReader>对象。  
  
-   重复使用<xref:System.Xml.XmlReaderSettings>对象来创建多个读取器。 可以使用相同的设置创建多个具有相同功能的读取器。 或者，您可以在修改设置<xref:System.Xml.XmlReaderSettings>实例并创建新的读取器包含一组不同的功能。  
  
-   将功能添加到现有的 XML 读取器。 <xref:System.Xml.XmlReader.Create%2A> 方法可以接受其他 <xref:System.Xml.XmlReader> 对象。 基础<xref:System.Xml.XmlReader>对象可以是用户定义的读取器<xref:System.Xml.XmlTextReader>对象，或另一个<xref:System.Xml.XmlReader>你想要添加附加功能的实例。  
  
-   充分利用的功能，例如更好的一致性检查和符合性[XML 1.0 （第四版）](https://www.w3.org/TR/2006/REC-xml-20060816/)仅在可用的建议<xref:System.Xml.XmlReader>创建的静态对象<xref:System.Xml.XmlReader.Create%2A>方法。  
  
> [!NOTE]
>  尽管.NET Framework 包括的具体实现<xref:System.Xml.XmlReader>类，如<xref:System.Xml.XmlTextReader>， <xref:System.Xml.XmlNodeReader>，和<xref:System.Xml.XmlValidatingReader>类，我们建议您创建<xref:System.Xml.XmlReader>实例使用<xref:System.Xml.XmlReader.Create%2A>方法。  
  
## <a name="default-settings"></a>默认设置  
 如果您使用<xref:System.Xml.XmlReader.Create%2A>重载不接受<xref:System.Xml.XmlReaderSettings>对象，使用以下默认读取器设置：  
  
|设置|默认|  
|-------------|-------------|  
|<xref:System.Xml.XmlReaderSettings.CheckCharacters%2A>|`true`|  
|<xref:System.Xml.XmlReaderSettings.ConformanceLevel%2A>|<xref:System.Xml.ConformanceLevel.Document?displayProperty=nameWithType>|  
|<xref:System.Xml.XmlReaderSettings.IgnoreComments%2A>|`false`|  
|<xref:System.Xml.XmlReaderSettings.IgnoreProcessingInstructions%2A>|`false`|  
|<xref:System.Xml.XmlReaderSettings.IgnoreWhitespace%2A>|`false`|  
|<xref:System.Xml.XmlReaderSettings.LineNumberOffset%2A>|0|  
|<xref:System.Xml.XmlReaderSettings.LinePositionOffset%2A>|0|  
|<xref:System.Xml.XmlReaderSettings.NameTable%2A>|`null`|  
|<xref:System.Xml.XmlReaderSettings.DtdProcessing%2A>|<xref:System.Xml.DtdProcessing.Prohibit>|  
|<xref:System.Xml.XmlReaderSettings.Schemas%2A>|空的 <xref:System.Xml.Schema.XmlSchemaSet> 对象|  
|<xref:System.Xml.XmlReaderSettings.ValidationFlags%2A>|<xref:System.Xml.Schema.XmlSchemaValidationFlags.ProcessIdentityConstraints> 已启用|  
|<xref:System.Xml.XmlReaderSettings.ValidationType%2A>|<xref:System.Xml.ValidationType.None>|  
|<xref:System.Xml.XmlReaderSettings.XmlResolver%2A>|一个新 <xref:System.Xml.XmlUrlResolver> 对象。  从.NET Framework 4.5.2 开始，此设置的默认值为`null`。|  
  
## <a name="settings-for-common-scenarios"></a>常见方案的设置  
 以下是<xref:System.Xml.XmlReaderSettings>属性应设置为的部分典型的 XML 读取器方案。  
  
|需求|Set|  
|-----------------|---------|  
|数据必须是格式正确的 XML 文档。|<xref:System.Xml.XmlReaderSettings.ConformanceLevel%2A> 到<xref:System.Xml.ConformanceLevel.Document>。|  
|数据必须是格式正确的 XML 已分析实体。|<xref:System.Xml.XmlReaderSettings.ConformanceLevel%2A> 到<xref:System.Xml.ConformanceLevel.Fragment>。|  
|必须根据 DTD 验证数据。|<xref:System.Xml.XmlReaderSettings.DtdProcessing%2A> 至 <xref:System.Xml.DtdProcessing.Parse><br /><xref:System.Xml.XmlReaderSettings.ValidationType%2A> 到<xref:System.Xml.ValidationType.DTD>。|  
|必须根据 XML 架构验证数据。|<xref:System.Xml.XmlReaderSettings.ValidationType%2A> 至 <xref:System.Xml.ValidationType.Schema><br /><xref:System.Xml.XmlReaderSettings.Schemas%2A> 到<xref:System.Xml.Schema.XmlSchemaSet>用于进行验证。 请注意，<xref:System.Xml.XmlReader>不支持 XML 数据缩减 (XDR) 架构验证。|  
|必须根据内联 XML 架构验证数据。|<xref:System.Xml.XmlReaderSettings.ValidationType%2A> 至 <xref:System.Xml.ValidationType.Schema><br /><xref:System.Xml.XmlReaderSettings.ValidationFlags%2A> 到<xref:System.Xml.Schema.XmlSchemaValidationFlags.ProcessInlineSchema>。|  
|类型支持。|<xref:System.Xml.XmlReaderSettings.ValidationType%2A> 至 <xref:System.Xml.ValidationType.Schema><br /><xref:System.Xml.XmlReaderSettings.Schemas%2A> 到<xref:System.Xml.Schema.XmlSchemaSet>使用。|  
  
 <xref:System.Xml.XmlReader> 不支持 XML 数据缩减 (XDR) 架构验证。  
  
## <a name="asynchronous-programming"></a>异步编程  
 在同步模式下，<xref:System.Xml.XmlReader.Create%2A>方法从文件、 流或文本读取器的缓冲区中读取数据的第一个区块。 如果 I/O 操作失败，这可能会引发异常。 在异步模式下，第一次 I/O 操作使用的读取操作，进行，因此会引发的异常将读取的操作发生时引发。  
  
## <a name="security-considerations"></a>安全注意事项  
 默认情况下<xref:System.Xml.XmlReader>使用<xref:System.Xml.XmlUrlResolver>没有用户凭据以打开资源的对象。 这意味着，默认情况下，XML 读取器可以访问不需要凭据的任何位置。 使用<xref:System.Xml.XmlReaderSettings.XmlResolver%2A>属性来控制对资源的访问：  
  
-   设置<xref:System.Xml.XmlReaderSettings.XmlResolver%2A>到<xref:System.Xml.XmlSecureResolver>对象来限制 XML 读取器可以访问的资源。  
  
 或  
  
-   设置<xref:System.Xml.XmlReaderSettings.XmlResolver%2A>到`null`以防止打开任何外部资源的 XML 读取器。  
  
   
  
## Examples  
 此示例创建一个 XML 读取器中去除无意义的空白，去除注释，并执行片断级一致性检查。  
  
 [!code-csharp[XmlReader.Create#11](~/samples/snippets/csharp/VS_Snippets_Data/XmlReader.Create/CS/XmlReader_Create.cs#11)]
 [!code-vb[XmlReader.Create#11](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReader.Create/VB/XmlReader_Create.vb#11)]  
  
 下面的示例使用<xref:System.Xml.XmlUrlResolver>具有默认凭据访问的文件。  
  
 [!code-cpp[XmlReaderSettings.cctor#1](~/samples/snippets/cpp/VS_Snippets_Data/XmlReaderSettings.cctor/CPP/XmlReaderSettings.cctor.cpp#1)]
 [!code-csharp[XmlReaderSettings.cctor#1](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderSettings.cctor/CS/factory_rdr_cctor2.cs#1)]
 [!code-vb[XmlReaderSettings.cctor#1](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderSettings.cctor/VB/factory_rdr_cctor2.vb#1)]  
  
 [!code-cpp[XmlReaderSettings.cctor#2](~/samples/snippets/cpp/VS_Snippets_Data/XmlReaderSettings.cctor/CPP/XmlReaderSettings.cctor.cpp#2)]
 [!code-csharp[XmlReaderSettings.cctor#2](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderSettings.cctor/CS/factory_rdr_cctor2.cs#2)]
 [!code-vb[XmlReaderSettings.cctor#2](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderSettings.cctor/VB/factory_rdr_cctor2.vb#2)]  
  
 下面的代码包装在另一个读取器中的读取器实例。  
  
 [!code-csharp[XmlReader.Create#13](~/samples/snippets/csharp/VS_Snippets_Data/XmlReader.Create/CS/XmlReader_Create.cs#13)]
 [!code-vb[XmlReader.Create#13](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReader.Create/VB/XmlReader_Create.vb#13)]  
  
 此示例链接读取器以添加 DTD 和 XML 架构验证。  
  
 [!code-csharp[XmlReader.Create#12](~/samples/snippets/csharp/VS_Snippets_Data/XmlReader.Create/CS/XmlReader_Create.cs#12)]
 [!code-vb[XmlReader.Create#12](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReader.Create/VB/XmlReader_Create.vb#12)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Xml.XmlReader Create (System.IO.Stream input);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.XmlReader Create(class System.IO.Stream input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.Create(System.IO.Stream)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create (input As Stream) As XmlReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Xml::XmlReader ^ Create(System::IO::Stream ^ input);" />
      <MemberSignature Language="F#" Value="static member Create : System.IO.Stream -&gt; System.Xml.XmlReader" Usage="System.Xml.XmlReader.Create input" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlReader</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="input">包含 XML 数据的流。  
  
<see cref="T:System.Xml.XmlReader" /> 对流的前几个字节进行扫描，查找字节顺序标记或其他编码标志。 在确定编码方式后，使用该编码方式继续读取流，而处理过程继续将输入内容分析为 (Unicode) 字符流。</param>
        <summary>使用带默认设置的指定流创建新的 <see cref="T:System.Xml.XmlReader" /> 实例。</summary>
        <returns>一个用于读取数据流中所含数据的对象。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Xml.XmlReaderSettings>对象使用默认设置用于创建读取器。 如果你想要指定要创建的读取器上支持的功能，使用的重载<xref:System.Xml.XmlReaderSettings>对象作为其参数之一，并传入<xref:System.Xml.XmlReaderSettings>使用正确的设置的对象。  
  
 默认值<xref:System.Xml.XmlUrlResolver>不使用凭据用于访问任何外部资源，如文档类型定义 (DTD)、 实体、 架构和等等。  
  
> [!IMPORTANT]
>  从.NET Framework 4.5.2，无默认值开始<xref:System.Xml.XmlUrlResolver>提供。 如果解决方案同时面向.NET Framework 4.5.2 或更高版本中，指定<xref:System.Xml.XmlResolver>使用<xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType>属性。  
  
 如果需要身份验证的网络资源位于外部的资源，则指定<xref:System.Xml.XmlResolver>使用所需的凭据与<xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType>属性。  
  
 创建<xref:System.Xml.XmlReader>对象扩展实体引用，并执行 XML 标准化的新行字符。  
  
   
  
## Examples  
 下面的示例创建<xref:System.Xml.XmlReader>对象，用于读取来自<xref:System.IO.FileStream>。  
  
 [!code-csharp[XmlReader.Create#8](~/samples/snippets/csharp/VS_Snippets_Data/XmlReader.Create/CS/XmlReader_Create.cs#8)]
 [!code-vb[XmlReader.Create#8](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReader.Create/VB/XmlReader_Create.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> 值为 <see langword="null" />。</exception>
        <exception cref="T:System.Security.SecurityException">
          <see cref="T:System.Xml.XmlReader" /> 没有足够的权限访问 XML 数据的位置。</exception>
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Xml.XmlReader Create (System.IO.TextReader input);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.XmlReader Create(class System.IO.TextReader input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.Create(System.IO.TextReader)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create (input As TextReader) As XmlReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Xml::XmlReader ^ Create(System::IO::TextReader ^ input);" />
      <MemberSignature Language="F#" Value="static member Create : System.IO.TextReader -&gt; System.Xml.XmlReader" Usage="System.Xml.XmlReader.Create input" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlReader</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.IO.TextReader" />
      </Parameters>
      <Docs>
        <param name="input">从其中读取 XML 数据的文本读取器。 由于文本读取器返回的是 Unicode 字符流，因此，XML 读取器未使用 XML 声明中指定的编码对数据流进行解码。</param>
        <summary>使用指定的文本读取器创建一个新的 <see cref="T:System.Xml.XmlReader" /> 实例。</summary>
        <returns>一个用于读取数据流中所含数据的对象。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Xml.XmlReaderSettings>对象使用默认设置用于创建读取器。 如果你想要指定要创建的读取器上支持的功能，使用的重载<xref:System.Xml.XmlReaderSettings>对象作为其参数之一，并传入<xref:System.Xml.XmlReaderSettings>使用正确的设置的对象。  
  
 默认值<xref:System.Xml.XmlUrlResolver>不使用凭据用于访问任何外部资源，如文档类型定义 (DTD)、 实体、 架构和等等。  
  
> [!IMPORTANT]
>  从.NET Framework 4.5.2，无默认值开始<xref:System.Xml.XmlUrlResolver>提供。 如果解决方案同时面向.NET Framework 4.5.2 或更高版本中，指定<xref:System.Xml.XmlResolver>使用<xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType>属性。  
  
 如果需要身份验证的网络资源位于外部的资源，则指定<xref:System.Xml.XmlResolver>使用所需的凭据与<xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType>属性。  
  
 创建<xref:System.Xml.XmlReader>对象扩展实体引用，并执行 XML 标准化的新行字符。  
  
   
  
## Examples  
 下面的示例使用<xref:System.IO.StringReader>类读取 XML 字符串。  
  
 [!code-csharp[XmlReader.Create#7](~/samples/snippets/csharp/VS_Snippets_Data/XmlReader.Create/CS/XmlReader_Create.cs#7)]
 [!code-vb[XmlReader.Create#7](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReader.Create/VB/XmlReader_Create.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> 值为 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Xml.XmlReader Create (string inputUri);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.XmlReader Create(string inputUri) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.Create(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create (inputUri As String) As XmlReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Xml::XmlReader ^ Create(System::String ^ inputUri);" />
      <MemberSignature Language="F#" Value="static member Create : string -&gt; System.Xml.XmlReader" Usage="System.Xml.XmlReader.Create inputUri" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Xml.XmlReader</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inputUri" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="inputUri">包含 XML 数据的文件的 URI。 <see cref="T:System.Xml.XmlUrlResolver" /> 类用于将路径转换为规范化数据表示形式。</param>
        <summary>用指定的 URI 创建一个新的 <see cref="T:System.Xml.XmlReader" /> 实例。</summary>
        <returns>一个用于读取数据流中所含数据的对象。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Xml.XmlReaderSettings>对象使用默认设置用于创建读取器。 如果你想要指定要创建的读取器上支持的功能，使用的重载<xref:System.Xml.XmlReaderSettings>对象作为其参数之一，并传入<xref:System.Xml.XmlReaderSettings>使用正确的设置的对象。  
  
 默认值<xref:System.Xml.XmlUrlResolver>不使用凭据用于访问任何外部资源，如文档类型定义 (DTD)、 实体、 架构和等等。  
  
> [!IMPORTANT]
>  从.NET Framework 4.5.2，无默认值开始<xref:System.Xml.XmlUrlResolver>提供。 如果解决方案同时面向.NET Framework 4.5.2 或更高版本中，指定<xref:System.Xml.XmlResolver>使用<xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType>属性。  
  
 如果需要身份验证的网络资源位于外部的资源，则指定<xref:System.Xml.XmlResolver>使用所需的凭据与<xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType>属性。  
  
 创建<xref:System.Xml.XmlReader>对象扩展实体引用，并执行 XML 标准化的新行字符。  
  
   
  
## Examples  
 下面的示例创建<xref:System.Xml.XmlReader>对象，它读取 XML 数据文件指定的 URI。  
  
 [!code-csharp[XmlReader.Create#6](~/samples/snippets/csharp/VS_Snippets_Data/XmlReader.Create/CS/XmlReader_Create.cs#6)]
 [!code-vb[XmlReader.Create#6](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReader.Create/VB/XmlReader_Create.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="inputUri" /> 值为 <see langword="null" />。</exception>
        <exception cref="T:System.Security.SecurityException">
          <see cref="T:System.Xml.XmlReader" /> 没有足够的权限访问 XML 数据的位置。</exception>
        <exception cref="T:System.IO.FileNotFoundException">由 URI 标识的文件不存在。</exception>
        <exception cref="T:System.UriFormatException">
          <block subset="none" type="note">
            <para>  
 在<see href="https://go.microsoft.com/fwlink/?LinkID=247912">适用于 Windows 应用商店应用的 .NET</see> 或<see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">可移植类库</see>中，改为捕获基类异常 <see cref="T:System.FormatException" />。  
  
</para>
          </block>  
  
URI 格式不正确。</exception>
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Xml.XmlReader Create (System.IO.Stream input, System.Xml.XmlReaderSettings settings);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.XmlReader Create(class System.IO.Stream input, class System.Xml.XmlReaderSettings settings) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.Create(System.IO.Stream,System.Xml.XmlReaderSettings)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create (input As Stream, settings As XmlReaderSettings) As XmlReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Xml::XmlReader ^ Create(System::IO::Stream ^ input, System::Xml::XmlReaderSettings ^ settings);" />
      <MemberSignature Language="F#" Value="static member Create : System.IO.Stream * System.Xml.XmlReaderSettings -&gt; System.Xml.XmlReader" Usage="System.Xml.XmlReader.Create (input, settings)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlReader</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.IO.Stream" />
        <Parameter Name="settings" Type="System.Xml.XmlReaderSettings" />
      </Parameters>
      <Docs>
        <param name="input">包含 XML 数据的流。  
  
<see cref="T:System.Xml.XmlReader" /> 对流的前几个字节进行扫描，查找字节顺序标记或其他编码标志。 在确定编码方式后，使用该编码方式继续读取流，而处理过程继续将输入内容分析为 (Unicode) 字符流。</param>
        <param name="settings">新 <see cref="T:System.Xml.XmlReader" /> 实例的设置。 此值可为 <see langword="null" />。</param>
        <summary>使用指定的流和设置创建一个新的 <see cref="T:System.Xml.XmlReader" /> 实例。</summary>
        <returns>一个用于读取数据流中所含数据的对象。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 默认情况下<xref:System.Xml.XmlUrlResolver>不使用凭据用于访问任何外部资源，如文档类型定义 (DTD)、 实体、 架构和等等。  
  
> [!IMPORTANT]
>  从.NET Framework 4.5.2，无默认值开始<xref:System.Xml.XmlUrlResolver>提供。 如果解决方案同时面向.NET Framework 4.5.2 或更高版本中，指定<xref:System.Xml.XmlResolver>使用<xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType>属性。  
  
 如果需要身份验证的网络资源位于外部的资源，则使用<xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType>属性来指定<xref:System.Xml.XmlResolver>与所需的凭据。  
  
> [!IMPORTANT]
>  可以使用以下方法之一来控制哪些资源<xref:System.Xml.XmlReader>可以访问：  
>   
>  -   通过将 <xref:System.Xml.XmlReader> 属性设置为 <xref:System.Xml.XmlReaderSettings.XmlResolver%2A> 对象限制 <xref:System.Xml.XmlSecureResolver> 可访问的资源。  
>   
>  或  
>   
>  -   通过将 <xref:System.Xml.XmlReader> 属性设置为 <xref:System.Xml.XmlReaderSettings.XmlResolver%2A>，不允许 `null` 打开任何外部资源。  
  
 创建<xref:System.Xml.XmlReader>对象扩展实体引用，并执行 XML 标准化的新行字符。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> 值为 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Xml.XmlReader Create (System.IO.TextReader input, System.Xml.XmlReaderSettings settings);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.XmlReader Create(class System.IO.TextReader input, class System.Xml.XmlReaderSettings settings) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.Create(System.IO.TextReader,System.Xml.XmlReaderSettings)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create (input As TextReader, settings As XmlReaderSettings) As XmlReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Xml::XmlReader ^ Create(System::IO::TextReader ^ input, System::Xml::XmlReaderSettings ^ settings);" />
      <MemberSignature Language="F#" Value="static member Create : System.IO.TextReader * System.Xml.XmlReaderSettings -&gt; System.Xml.XmlReader" Usage="System.Xml.XmlReader.Create (input, settings)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlReader</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.IO.TextReader" />
        <Parameter Name="settings" Type="System.Xml.XmlReaderSettings" />
      </Parameters>
      <Docs>
        <param name="input">从其中读取 XML 数据的文本读取器。 由于文本读取器返回的是 Unicode 字符流，因此，XML 读取器未使用 XML 声明中指定的编码对数据流进行解码。</param>
        <param name="settings">新 <see cref="T:System.Xml.XmlReader" /> 的设置。 此值可为 <see langword="null" />。</param>
        <summary>使用指定的文本读取器和设置创建一个新的 <see cref="T:System.Xml.XmlReader" /> 实例。</summary>
        <returns>一个用于读取数据流中所含数据的对象。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 默认情况下<xref:System.Xml.XmlUrlResolver>不使用凭据用于访问任何外部资源，如文档类型定义 (DTD)、 实体、 架构和等等。  
  
> [!IMPORTANT]
>  从.NET Framework 4.5.2，无默认值开始<xref:System.Xml.XmlUrlResolver>提供。 如果解决方案同时面向.NET Framework 4.5.2 或更高版本中，指定<xref:System.Xml.XmlResolver>使用<xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType>属性。  
  
 如果需要身份验证的网络资源位于外部的资源，则使用<xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType>属性来指定<xref:System.Xml.XmlResolver>与所需的凭据。  
  
> [!IMPORTANT]
>  可以使用以下方法之一来控制哪些资源<xref:System.Xml.XmlReader>可以访问：  
>   
>  -   通过将 <xref:System.Xml.XmlReader> 属性设置为 <xref:System.Xml.XmlReaderSettings.XmlResolver%2A> 对象限制 <xref:System.Xml.XmlSecureResolver> 可访问的资源。  
>   
>  或  
>   
>  -   通过将 <xref:System.Xml.XmlReader> 属性设置为 <xref:System.Xml.XmlReaderSettings.XmlResolver%2A>，不允许 `null` 打开任何外部资源。  
  
 创建<xref:System.Xml.XmlReader>对象扩展实体引用，并执行 XML 标准化的新行字符。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> 值为 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Xml.XmlReader Create (string inputUri, System.Xml.XmlReaderSettings settings);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.XmlReader Create(string inputUri, class System.Xml.XmlReaderSettings settings) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.Create(System.String,System.Xml.XmlReaderSettings)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create (inputUri As String, settings As XmlReaderSettings) As XmlReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Xml::XmlReader ^ Create(System::String ^ inputUri, System::Xml::XmlReaderSettings ^ settings);" />
      <MemberSignature Language="F#" Value="static member Create : string * System.Xml.XmlReaderSettings -&gt; System.Xml.XmlReader" Usage="System.Xml.XmlReader.Create (inputUri, settings)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Xml.XmlReader</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inputUri" Type="System.String" />
        <Parameter Name="settings" Type="System.Xml.XmlReaderSettings" />
      </Parameters>
      <Docs>
        <param name="inputUri">包含 XML 数据的文件的 URI。 <see cref="T:System.Xml.XmlReaderSettings" /> 对象上的 <see cref="T:System.Xml.XmlResolver" /> 对象用于将路径转换为规范化数据表示形式。 如果 <see cref="P:System.Xml.XmlReaderSettings.XmlResolver" /> 为 <see langword="null" />，则使用新的 <see cref="T:System.Xml.XmlUrlResolver" /> 对象。</param>
        <param name="settings">新 <see cref="T:System.Xml.XmlReader" /> 实例的设置。 此值可为 <see langword="null" />。</param>
        <summary>使用指定的 URI 和设置创建新的 <see cref="T:System.Xml.XmlReader" /> 实例。</summary>
        <returns>一个用于读取数据流中所含数据的对象。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 默认情况下<xref:System.Xml.XmlUrlResolver>不使用凭据用于访问任何外部资源，如文档类型定义 (DTD)、 实体、 架构和等等。  
  
> [!IMPORTANT]
>  从.NET Framework 4.5.2，无默认值开始<xref:System.Xml.XmlUrlResolver>提供。 如果解决方案同时面向.NET Framework 4.5.2 或更高版本中，指定<xref:System.Xml.XmlResolver>使用<xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType>属性。  
  
 这意味着，<xref:System.Xml.XmlReader>可以访问任何不需要身份验证的位置。 如果需要身份验证的网络资源位于外部的资源，则使用<xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType>属性来指定<xref:System.Xml.XmlResolver>与所需的凭据。  
  
> [!IMPORTANT]
>  可以限制的资源的<xref:System.Xml.XmlReader>可以访问通过设置<xref:System.Xml.XmlReaderSettings.XmlResolver%2A>属性设置为<xref:System.Xml.XmlSecureResolver>对象。  
  
 创建<xref:System.Xml.XmlReader>对象扩展实体引用，并执行 XML 标准化的新行字符。  
  
   
  
## Examples  
 下面的示例创建<xref:System.Xml.XmlReader>支持文档类型定义 (DTD) 验证的对象。  
  
 [!code-csharp[XmlReader.Create#3](~/samples/snippets/csharp/VS_Snippets_Data/XmlReader.Create/CS/XmlReader_Create.cs#3)]
 [!code-vb[XmlReader.Create#3](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReader.Create/VB/XmlReader_Create.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="inputUri" /> 值为 <see langword="null" />。</exception>
        <exception cref="T:System.IO.FileNotFoundException">找不到 URI 指定的文件。</exception>
        <exception cref="T:System.UriFormatException">
          <block subset="none" type="note">
            <para>  
 在<see href="https://go.microsoft.com/fwlink/?LinkID=247912">适用于 Windows 应用商店应用的 .NET</see> 或<see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">可移植类库</see>中，改为捕获基类异常 <see cref="T:System.FormatException" />。  
  
</para>
          </block>  
  
URI 格式不正确。</exception>
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Xml.XmlReader Create (System.Xml.XmlReader reader, System.Xml.XmlReaderSettings settings);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.XmlReader Create(class System.Xml.XmlReader reader, class System.Xml.XmlReaderSettings settings) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.Create(System.Xml.XmlReader,System.Xml.XmlReaderSettings)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create (reader As XmlReader, settings As XmlReaderSettings) As XmlReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Xml::XmlReader ^ Create(System::Xml::XmlReader ^ reader, System::Xml::XmlReaderSettings ^ settings);" />
      <MemberSignature Language="F#" Value="static member Create : System.Xml.XmlReader * System.Xml.XmlReaderSettings -&gt; System.Xml.XmlReader" Usage="System.Xml.XmlReader.Create (reader, settings)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlReader</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
        <Parameter Name="settings" Type="System.Xml.XmlReaderSettings" />
      </Parameters>
      <Docs>
        <param name="reader">要用作基础 XML 编写器的对象。</param>
        <param name="settings">新 <see cref="T:System.Xml.XmlReader" /> 实例的设置。  
  
<see cref="T:System.Xml.XmlReaderSettings" /> 对象的一致性级别要么必须与基础读取器的一致性级别匹配，要么必须设置为 <see cref="F:System.Xml.ConformanceLevel.Auto" />。</param>
        <summary>使用指定的 XML 读取器和设置创建一个新的 <see cref="T:System.Xml.XmlReader" /> 实例。</summary>
        <returns>在指定的 <see cref="T:System.Xml.XmlReader" /> 对象周围包装的对象。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法允许将其他功能添加到基础<xref:System.Xml.XmlReader>对象。 基础<xref:System.Xml.XmlReader>对象可以是另一个<xref:System.Xml.XmlReader>对象创建的<xref:System.Xml.XmlReader.Create%2A>方法，或<xref:System.Xml.XmlReader>对象使用的一个具体创建<xref:System.Xml.XmlReader>实现。  
  
 默认值<xref:System.Xml.XmlUrlResolver>不使用凭据用于访问如架构的任何外部资源。  
  
> [!IMPORTANT]
>  从.NET Framework 4.5.2，无默认值开始<xref:System.Xml.XmlUrlResolver>提供。 如果解决方案同时面向.NET Framework 4.5.2 或更高版本中，指定<xref:System.Xml.XmlResolver>使用<xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType>属性。  
  
 如果需要身份验证的网络资源位于外部的资源，则指定<xref:System.Xml.XmlResolver>使用所需的凭据与<xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType>属性。  
  
> [!IMPORTANT]
>  可以使用以下方法之一来控制哪些资源<xref:System.Xml.XmlReader>可以访问：  
>   
>  -   通过将 <xref:System.Xml.XmlReader> 属性设置为 <xref:System.Xml.XmlReaderSettings.XmlResolver%2A> 对象限制 <xref:System.Xml.XmlSecureResolver> 可访问的资源。  
>   
>  或  
>   
>  -   通过将 <xref:System.Xml.XmlReader> 属性设置为 <xref:System.Xml.XmlReaderSettings.XmlResolver%2A>，不允许 `null` 打开任何外部资源。  
  
 创建<xref:System.Xml.XmlReader>对象扩展实体引用，并执行 XML 标准化的新行字符。  
  
   
  
## Examples  
 下面的示例创建一个验证<xref:System.Xml.XmlReader>对象，包装在<xref:System.Xml.XmlNodeReader>对象。  
  
 [!code-csharp[XmlReader.Create#5](~/samples/snippets/csharp/VS_Snippets_Data/XmlReader.Create/CS/XmlReader_Create.cs#5)]
 [!code-vb[XmlReader.Create#5](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReader.Create/VB/XmlReader_Create.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="reader" /> 值为 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Xml.XmlReaderSettings" /> 对象指定的一致性级别与基础读取器的一致性级别不一致。  
  
或 
基础 <see cref="T:System.Xml.XmlReader" /> 处于 <see cref="F:System.Xml.ReadState.Error" /> 或 <see cref="F:System.Xml.ReadState.Closed" /> 状态。</exception>
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Xml.XmlReader Create (System.IO.Stream input, System.Xml.XmlReaderSettings settings, string baseUri);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.XmlReader Create(class System.IO.Stream input, class System.Xml.XmlReaderSettings settings, string baseUri) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.Create(System.IO.Stream,System.Xml.XmlReaderSettings,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create (input As Stream, settings As XmlReaderSettings, baseUri As String) As XmlReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Xml::XmlReader ^ Create(System::IO::Stream ^ input, System::Xml::XmlReaderSettings ^ settings, System::String ^ baseUri);" />
      <MemberSignature Language="F#" Value="static member Create : System.IO.Stream * System.Xml.XmlReaderSettings * string -&gt; System.Xml.XmlReader" Usage="System.Xml.XmlReader.Create (input, settings, baseUri)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlReader</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.IO.Stream" />
        <Parameter Name="settings" Type="System.Xml.XmlReaderSettings" />
        <Parameter Name="baseUri" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="input">包含 XML 数据的流。  
  
<see cref="T:System.Xml.XmlReader" /> 对流的前几个字节进行扫描，查找字节顺序标记或其他编码标志。 在确定编码方式后，使用该编码方式继续读取流，而处理过程继续将输入内容分析为 (Unicode) 字符流。</param>
        <param name="settings">新 <see cref="T:System.Xml.XmlReader" /> 实例的设置。 此值可为 <see langword="null" />。</param>
        <param name="baseUri">正在读取的实体或文档的基 URI。 此值可为 <see langword="null" />。  
  
 **安全说明** 基 URI 用于解析 XML 文档的相对 URI。 不要使用来自非信任源的基 URI。</param>
        <summary>使用指定的流、基 URI 和设置创建一个新的 <see cref="T:System.Xml.XmlReader" /> 实例。</summary>
        <returns>一个用于读取数据流中所含数据的对象。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 默认情况下<xref:System.Xml.XmlUrlResolver>不使用凭据用于访问任何外部资源，如文档类型定义 (DTD)、 实体、 架构和等等。  
  
> [!IMPORTANT]
>  从.NET Framework 4.5.2，无默认值开始<xref:System.Xml.XmlUrlResolver>提供。 如果解决方案同时面向.NET Framework 4.5.2 或更高版本中，指定<xref:System.Xml.XmlResolver>使用<xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType>属性。  
  
 如果需要身份验证的网络资源位于外部的资源，则使用<xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType>属性来指定<xref:System.Xml.XmlResolver>与所需的凭据。  
  
> [!IMPORTANT]
>  可以使用以下方法之一来控制哪些资源<xref:System.Xml.XmlReader>可以访问：  
>   
>  -   通过将 <xref:System.Xml.XmlReader> 属性设置为 <xref:System.Xml.XmlReaderSettings.XmlResolver%2A> 对象限制 <xref:System.Xml.XmlSecureResolver> 可访问的资源。  
>   
>  或  
>   
>  -   通过将 <xref:System.Xml.XmlReader> 属性设置为 <xref:System.Xml.XmlReaderSettings.XmlResolver%2A>，不允许 `null` 打开任何外部资源。  
  
 创建<xref:System.Xml.XmlReader>对象扩展实体引用，并执行 XML 标准化的新行字符。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> 值为 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Xml.XmlReader Create (System.IO.Stream input, System.Xml.XmlReaderSettings settings, System.Xml.XmlParserContext inputContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.XmlReader Create(class System.IO.Stream input, class System.Xml.XmlReaderSettings settings, class System.Xml.XmlParserContext inputContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.Create(System.IO.Stream,System.Xml.XmlReaderSettings,System.Xml.XmlParserContext)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create (input As Stream, settings As XmlReaderSettings, inputContext As XmlParserContext) As XmlReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Xml::XmlReader ^ Create(System::IO::Stream ^ input, System::Xml::XmlReaderSettings ^ settings, System::Xml::XmlParserContext ^ inputContext);" />
      <MemberSignature Language="F#" Value="static member Create : System.IO.Stream * System.Xml.XmlReaderSettings * System.Xml.XmlParserContext -&gt; System.Xml.XmlReader" Usage="System.Xml.XmlReader.Create (input, settings, inputContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlReader</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.IO.Stream" />
        <Parameter Name="settings" Type="System.Xml.XmlReaderSettings" />
        <Parameter Name="inputContext" Type="System.Xml.XmlParserContext" />
      </Parameters>
      <Docs>
        <param name="input">包含 XML 数据的流。  
  
<see cref="T:System.Xml.XmlReader" /> 对流的前几个字节进行扫描，查找字节顺序标记或其他编码标志。 在确定编码方式后，使用该编码方式继续读取流，而处理过程继续将输入内容分析为 (Unicode) 字符流。</param>
        <param name="settings">新 <see cref="T:System.Xml.XmlReader" /> 实例的设置。 此值可为 <see langword="null" />。</param>
        <param name="inputContext">分析 XML 片段所需的上下文信息. 上下文信息可以包括要使用的 <see cref="T:System.Xml.XmlNameTable" />、编码、命名空间范围、当前的 <c>xml:lang</c> 和 <c>xml:space</c> 范围、基 URI 和文档类型定义。  
  
此值可为 <see langword="null" />。</param>
        <summary>使用指定的流、设置和用于分析的上下文信息创建一个新的 <see cref="T:System.Xml.XmlReader" /> 实例。</summary>
        <returns>一个用于读取数据流中所含数据的对象。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 默认情况下<xref:System.Xml.XmlUrlResolver>不使用凭据用于访问任何外部资源，如文档类型定义 (DTD)、 实体、 架构和等等。  
  
> [!IMPORTANT]
>  从.NET Framework 4.5.2，无默认值开始<xref:System.Xml.XmlUrlResolver>提供。 如果解决方案同时面向.NET Framework 4.5.2 或更高版本中，指定<xref:System.Xml.XmlResolver>使用<xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType>属性。  
  
 如果需要身份验证的网络资源位于外部的资源，则使用<xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType>属性来指定<xref:System.Xml.XmlResolver>与所需的凭据。  
  
> [!IMPORTANT]
>  可以使用以下方法之一来控制哪些资源<xref:System.Xml.XmlReader>可以访问：  
>   
>  -   通过将 <xref:System.Xml.XmlReader> 属性设置为 <xref:System.Xml.XmlReaderSettings.XmlResolver%2A> 对象限制 <xref:System.Xml.XmlSecureResolver> 可访问的资源。  
>   
>  或  
>   
>  -   通过将 <xref:System.Xml.XmlReader> 属性设置为 <xref:System.Xml.XmlReaderSettings.XmlResolver%2A>，不允许 `null` 打开任何外部资源。  
  
 创建<xref:System.Xml.XmlReader>对象扩展实体引用，并执行 XML 标准化的新行字符。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> 值为 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Xml.XmlReader Create (System.IO.TextReader input, System.Xml.XmlReaderSettings settings, string baseUri);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.XmlReader Create(class System.IO.TextReader input, class System.Xml.XmlReaderSettings settings, string baseUri) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.Create(System.IO.TextReader,System.Xml.XmlReaderSettings,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create (input As TextReader, settings As XmlReaderSettings, baseUri As String) As XmlReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Xml::XmlReader ^ Create(System::IO::TextReader ^ input, System::Xml::XmlReaderSettings ^ settings, System::String ^ baseUri);" />
      <MemberSignature Language="F#" Value="static member Create : System.IO.TextReader * System.Xml.XmlReaderSettings * string -&gt; System.Xml.XmlReader" Usage="System.Xml.XmlReader.Create (input, settings, baseUri)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlReader</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.IO.TextReader" />
        <Parameter Name="settings" Type="System.Xml.XmlReaderSettings" />
        <Parameter Name="baseUri" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="input">从其中读取 XML 数据的文本读取器。 由于文本读取器返回的是 Unicode 字符流，因此，<see cref="T:System.Xml.XmlReader" /> 未使用 XML 声明中指定的编码对数据流进行解码。</param>
        <param name="settings">新 <see cref="T:System.Xml.XmlReader" /> 实例的设置。 此值可为 <see langword="null" />。</param>
        <param name="baseUri">正在读取的实体或文档的基 URI。 此值可为 <see langword="null" />。  
  
 **安全说明** 基 URI 用于解析 XML 文档的相对 URI。 不要使用来自非信任源的基 URI。</param>
        <summary>使用指定的文本读取器、设置和基 URI 创建一个新的 <see cref="T:System.Xml.XmlReader" />。</summary>
        <returns>一个用于读取数据流中所含数据的对象。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 默认情况下<xref:System.Xml.XmlUrlResolver>不使用凭据用于访问任何外部资源，如文档类型定义 (DTD)、 实体、 架构和等等。  
  
> [!IMPORTANT]
>  从.NET Framework 4.5.2，无默认值开始<xref:System.Xml.XmlUrlResolver>提供。 如果解决方案同时面向.NET Framework 4.5.2 或更高版本中，指定<xref:System.Xml.XmlResolver>使用<xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType>属性。  
  
 如果需要身份验证的网络资源位于外部的资源，则使用<xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType>属性来指定<xref:System.Xml.XmlResolver>与所需的凭据。  
  
> [!IMPORTANT]
>  可以使用以下方法之一来控制哪些资源<xref:System.Xml.XmlReader>可以访问：  
>   
>  -   通过将 <xref:System.Xml.XmlReader> 属性设置为 <xref:System.Xml.XmlReaderSettings.XmlResolver%2A> 对象限制 <xref:System.Xml.XmlSecureResolver> 可访问的资源。  
>   
>  或  
>   
>  -   通过将 <xref:System.Xml.XmlReader> 属性设置为 <xref:System.Xml.XmlReaderSettings.XmlResolver%2A>，不允许 `null` 打开任何外部资源。  
  
 创建<xref:System.Xml.XmlReader>对象扩展实体引用，并执行 XML 标准化的新行字符。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> 值为 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Xml.XmlReader Create (System.IO.TextReader input, System.Xml.XmlReaderSettings settings, System.Xml.XmlParserContext inputContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.XmlReader Create(class System.IO.TextReader input, class System.Xml.XmlReaderSettings settings, class System.Xml.XmlParserContext inputContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.Create(System.IO.TextReader,System.Xml.XmlReaderSettings,System.Xml.XmlParserContext)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create (input As TextReader, settings As XmlReaderSettings, inputContext As XmlParserContext) As XmlReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Xml::XmlReader ^ Create(System::IO::TextReader ^ input, System::Xml::XmlReaderSettings ^ settings, System::Xml::XmlParserContext ^ inputContext);" />
      <MemberSignature Language="F#" Value="static member Create : System.IO.TextReader * System.Xml.XmlReaderSettings * System.Xml.XmlParserContext -&gt; System.Xml.XmlReader" Usage="System.Xml.XmlReader.Create (input, settings, inputContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlReader</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.IO.TextReader" />
        <Parameter Name="settings" Type="System.Xml.XmlReaderSettings" />
        <Parameter Name="inputContext" Type="System.Xml.XmlParserContext" />
      </Parameters>
      <Docs>
        <param name="input">从其中读取 XML 数据的文本读取器。 由于文本读取器返回的是 Unicode 字符流，因此，XML 读取器未使用 XML 声明中指定的编码对数据流进行解码。</param>
        <param name="settings">新 <see cref="T:System.Xml.XmlReader" /> 实例的设置。 此值可为 <see langword="null" />。</param>
        <param name="inputContext">分析 XML 片段所需的上下文信息. 上下文信息可以包括要使用的 <see cref="T:System.Xml.XmlNameTable" />、编码、命名空间范围、当前的 <c>xml:lang</c> 和 <c>xml:space</c> 范围、基 URI 和文档类型定义。  
  
此值可为 <see langword="null" />。</param>
        <summary>使用指定的文本读取器、设置和要用于分析的上下文信息创建一个新的 <see cref="T:System.Xml.XmlReader" /> 实例。</summary>
        <returns>一个用于读取数据流中所含数据的对象。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 默认情况下<xref:System.Xml.XmlUrlResolver>不使用凭据用于访问任何外部资源，如文档类型定义 (DTD)、 实体、 架构和等等。  
  
> [!IMPORTANT]
>  从.NET Framework 4.5.2，无默认值开始<xref:System.Xml.XmlUrlResolver>提供。 如果解决方案同时面向.NET Framework 4.5.2 或更高版本中，指定<xref:System.Xml.XmlResolver>使用<xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType>属性。  
  
 如果需要身份验证的网络资源位于外部的资源，则使用<xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType>属性来指定<xref:System.Xml.XmlResolver>与所需的凭据。  
  
> [!IMPORTANT]
>  可以使用以下方法之一来控制哪些资源<xref:System.Xml.XmlReader>可以访问：  
>   
>  -   通过将 <xref:System.Xml.XmlReader> 属性设置为 <xref:System.Xml.XmlReaderSettings.XmlResolver%2A> 对象限制 <xref:System.Xml.XmlSecureResolver> 可访问的资源。  
>   
>  或  
>   
>  -   通过将 <xref:System.Xml.XmlReader> 属性设置为 <xref:System.Xml.XmlReaderSettings.XmlResolver%2A>，不允许 `null` 打开任何外部资源。  
  
 创建<xref:System.Xml.XmlReader>对象扩展实体引用，并执行 XML 标准化的新行字符。  
  
   
  
## Examples  
 下面的示例创建<xref:System.Xml.XmlReader>对象，它读取 XML 片段。  
  
 [!code-csharp[XmlReader.Create#1](~/samples/snippets/csharp/VS_Snippets_Data/XmlReader.Create/CS/XmlReader_Create.cs#1)]
 [!code-vb[XmlReader.Create#1](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReader.Create/VB/XmlReader_Create.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> 值为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <see cref="P:System.Xml.XmlReaderSettings.NameTable" /> 和 <see cref="P:System.Xml.XmlParserContext.NameTable" /> 属性都包含值。 （只能设置并使用这些 <see langword="NameTable" /> 属性之中的一个）。</exception>
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Xml.XmlReader Create (string inputUri, System.Xml.XmlReaderSettings settings, System.Xml.XmlParserContext inputContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.XmlReader Create(string inputUri, class System.Xml.XmlReaderSettings settings, class System.Xml.XmlParserContext inputContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.Create(System.String,System.Xml.XmlReaderSettings,System.Xml.XmlParserContext)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create (inputUri As String, settings As XmlReaderSettings, inputContext As XmlParserContext) As XmlReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Xml::XmlReader ^ Create(System::String ^ inputUri, System::Xml::XmlReaderSettings ^ settings, System::Xml::XmlParserContext ^ inputContext);" />
      <MemberSignature Language="F#" Value="static member Create : string * System.Xml.XmlReaderSettings * System.Xml.XmlParserContext -&gt; System.Xml.XmlReader" Usage="System.Xml.XmlReader.Create (inputUri, settings, inputContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlReader</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inputUri" Type="System.String" />
        <Parameter Name="settings" Type="System.Xml.XmlReaderSettings" />
        <Parameter Name="inputContext" Type="System.Xml.XmlParserContext" />
      </Parameters>
      <Docs>
        <param name="inputUri">包含 XML 数据的文件的 URI。 <see cref="T:System.Xml.XmlReaderSettings" /> 对象上的 <see cref="T:System.Xml.XmlResolver" /> 对象用于将路径转换为规范化数据表示形式。 如果 <see cref="P:System.Xml.XmlReaderSettings.XmlResolver" /> 为 <see langword="null" />，则使用新的 <see cref="T:System.Xml.XmlUrlResolver" /> 对象。</param>
        <param name="settings">新 <see cref="T:System.Xml.XmlReader" /> 实例的设置。 此值可为 <see langword="null" />。</param>
        <param name="inputContext">分析 XML 片段所需的上下文信息. 上下文信息可以包括要使用的 <see cref="T:System.Xml.XmlNameTable" />、编码、命名空间范围、当前的 <c>xml:lang</c> 和 <c>xml:space</c> 范围、基 URI 和文档类型定义。  
  
此值可为 <see langword="null" />。</param>
        <summary>使用指定的 URI、设置和进行分析的上下文信息创建一个新的 <see cref="T:System.Xml.XmlReader" /> 实例。</summary>
        <returns>一个用于读取数据流中所含数据的对象。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 默认情况下<xref:System.Xml.XmlUrlResolver>不使用凭据用于访问任何外部资源，如文档类型定义 (DTD)、 实体、 架构和等等。  
  
> [!IMPORTANT]
>  从.NET Framework 4.5.2，无默认值开始<xref:System.Xml.XmlUrlResolver>提供。 如果解决方案同时面向.NET Framework 4.5.2 或更高版本中，指定<xref:System.Xml.XmlResolver>使用<xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType>属性。  
  
 这意味着，<xref:System.Xml.XmlReader>可以访问任何不需要身份验证的位置。 如果需要身份验证的网络资源位于外部的资源，则使用<xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType>属性来指定<xref:System.Xml.XmlResolver>与所需的凭据。  
  
> [!IMPORTANT]
>  可以限制的资源的<xref:System.Xml.XmlReader>可以访问通过设置<xref:System.Xml.XmlReaderSettings.XmlResolver%2A>属性设置为<xref:System.Xml.XmlSecureResolver>对象。  
  
 创建<xref:System.Xml.XmlReader>对象扩展实体引用，并执行 XML 标准化的新行字符。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <see langword="inputUri" /> 值为 <see langword="null" />。</exception>
        <exception cref="T:System.Security.SecurityException">
          <see cref="T:System.Xml.XmlReader" /> 没有足够的权限访问 XML 数据的位置。</exception>
        <exception cref="T:System.ArgumentException">
          <see cref="P:System.Xml.XmlReaderSettings.NameTable" /> 和 <see cref="P:System.Xml.XmlParserContext.NameTable" /> 属性都包含值。 （只能设置并使用这些 <see langword="NameTable" /> 属性之中的一个）。</exception>
        <exception cref="T:System.IO.FileNotFoundException">找不到 URI 指定的文件。</exception>
        <exception cref="T:System.UriFormatException">URI 格式不正确。</exception>
      </Docs>
    </Member>
    <Member MemberName="Depth">
      <MemberSignature Language="C#" Value="public abstract int Depth { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Depth" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.Depth" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property Depth As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property int Depth { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Depth : int" Usage="System.Xml.XmlReader.Depth" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当在派生类中被重写时，获取 XML 文档中当前节点的深度。</summary>
        <value>XML 文档中当前节点的深度。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 请参阅<xref:System.Xml.XmlTextReader.Depth%2A>(在`XmlTextReader`类) 使用此属性的示例。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Dispose">
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <exception cref="T:System.InvalidOperationException">在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情况下，将引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中”。</exception>
        <summary>释放 <see cref="T:System.Xml.XmlReader" /> 类使用的资源。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="xmlReader.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>释放 <see cref="T:System.Xml.XmlReader" /> 类的当前实例所使用的所有资源。</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”</exception>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="abstract member Dispose : bool -&gt; unit&#xA;override this.Dispose : bool -&gt; unit" Usage="xmlReader.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">若要释放托管资源和非托管资源，则为 <see langword="true" />；若仅释放非托管资源，则为 <see langword="false" />。</param>
        <summary>释放由 <see cref="T:System.Xml.XmlReader" /> 占用的非托管资源，还可以另外再释放托管资源。</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”</exception>
      </Docs>
    </Member>
    <Member MemberName="EOF">
      <MemberSignature Language="C#" Value="public abstract bool EOF { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EOF" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.EOF" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property EOF As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property bool EOF { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.EOF : bool" Usage="System.Xml.XmlReader.EOF" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当在派生类中被重写时，获取一个值，该值指示此读取器是否定位在流的结尾。</summary>
        <value>如果此读取器定位在流的结尾，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetAttribute">
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <exception cref="T:System.InvalidOperationException">在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情况下，将引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中”。</exception>
        <summary>当在派生类中被重写时，获取属性的值。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetAttribute">
      <MemberSignature Language="C#" Value="public abstract string GetAttribute (int i);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string GetAttribute(int32 i) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.GetAttribute(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetAttribute (i As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::String ^ GetAttribute(int i);" />
      <MemberSignature Language="F#" Value="abstract member GetAttribute : int -&gt; string" Usage="xmlReader.GetAttribute i" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="i" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="i">属性的索引。 索引是从零开始的。 （第一个属性的索引为 0。）</param>
        <summary>当在派生类中被重写时，获取具有指定索引的属性的值。</summary>
        <returns>指定的属性的值。 此方法不移动读取器。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下面的示例获取第三个属性的值。  
  
 [!code-csharp[XmlReaderBasic#2](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#2)]
 [!code-vb[XmlReaderBasic#2](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="i" /> 超出范围。 它必须是非负数且小于特性集合的大小。</exception>
        <exception cref="T:System.InvalidOperationException">在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”</exception>
      </Docs>
    </Member>
    <Member MemberName="GetAttribute">
      <MemberSignature Language="C#" Value="public abstract string GetAttribute (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string GetAttribute(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.GetAttribute(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetAttribute (name As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::String ^ GetAttribute(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member GetAttribute : string -&gt; string" Usage="xmlReader.GetAttribute name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">属性的限定名称。</param>
        <summary>当在派生类中被重写时，获取具有指定 <see cref="P:System.Xml.XmlReader.Name" /> 的属性的值。</summary>
        <returns>指定的属性的值。 如果找不到该属性，或者值为 <see langword="String.Empty" />，则返回 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法不移动读取器。  
  
 如果读取器定位在`DocumentType`节点，此方法可用于获取 PUBLIC 和 SYSTEM 文本，例如， `reader.GetAttribute("PUBLIC")`  
  
   
  
## Examples  
 下面的示例获取的 ISBN 属性的值。  
  
 [!code-csharp[XmlReaderBasic#3](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#3)]
 [!code-vb[XmlReaderBasic#3](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”</exception>
      </Docs>
    </Member>
    <Member MemberName="GetAttribute">
      <MemberSignature Language="C#" Value="public abstract string GetAttribute (string name, string namespaceURI);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string GetAttribute(string name, string namespaceURI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.GetAttribute(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetAttribute (name As String, namespaceURI As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::String ^ GetAttribute(System::String ^ name, System::String ^ namespaceURI);" />
      <MemberSignature Language="F#" Value="abstract member GetAttribute : string * string -&gt; string" Usage="xmlReader.GetAttribute (name, namespaceURI)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="namespaceURI" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">属性的本地名称。</param>
        <param name="namespaceURI">属性的命名空间 URI。</param>
        <summary>当在派生类中被重写时，获取具有指定 <see cref="P:System.Xml.XmlReader.LocalName" /> 和 <see cref="P:System.Xml.XmlReader.NamespaceURI" /> 的属性的值。</summary>
        <returns>指定的属性的值。 如果找不到该属性，或者值为 <see langword="String.Empty" />，则返回 <see langword="null" />。 此方法不移动读取器。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下面的 XML 包含特定命名空间中的一个属性：  
  
```xml  
<test xmlns:dt="urn:datatypes" dt:type="int"/>  
```  
  
 可以查找`dt:type`属性使用一个参数 （前缀和本地名称） 或 （本地名称和命名空间 URI） 的两个参数：  
  
```csharp  
String dt = reader.GetAttribute("dt:type");  
String dt2 = reader.GetAttribute("type","urn:datatypes");  
```  
  
 要查找`xmlns:dt`属性，请使用以下参数之一：  
  
```csharp  
String dt3 = reader.GetAttribute("xmlns:dt");  
String dt4 = reader.GetAttribute("dt",http://www.w3.org/2000/xmlns/);  
```  
  
 此外可以获取此信息使用<xref:System.Xml.XmlReader.Prefix%2A>属性。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”</exception>
      </Docs>
    </Member>
    <Member MemberName="GetValueAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;string&gt; GetValueAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;string&gt; GetValueAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.GetValueAsync" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetValueAsync () As Task(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task&lt;System::String ^&gt; ^ GetValueAsync();" />
      <MemberSignature Language="F#" Value="abstract member GetValueAsync : unit -&gt; System.Threading.Tasks.Task&lt;string&gt;&#xA;override this.GetValueAsync : unit -&gt; System.Threading.Tasks.Task&lt;string&gt;" Usage="xmlReader.GetValueAsync " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>异步获取当前节点的值。</summary>
        <returns>当前节点的值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要使用此方法，必须设置<xref:System.Xml.XmlReaderSettings.Async%2A>标记，用于`true`。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">调用了 <see cref="T:System.Xml.XmlReader" /> 异步方法，但未将 <see cref="P:System.Xml.XmlReaderSettings.Async" /> 标志设置为 <see langword="true" />。 在此情况下，将引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“若要使用 Async 方法，请将 XmlReaderSettings.Async 设置为 True。”</exception>
        <related type="Article" href="http://msdn.microsoft.com/library/db854f91-ccef-4035-ae4d-0911fde808c7">使用 Async 和 Await 的异步编程（C# 和 Visual Basic）</related>
      </Docs>
    </Member>
    <Member MemberName="HasAttributes">
      <MemberSignature Language="C#" Value="public virtual bool HasAttributes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasAttributes" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.HasAttributes" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property HasAttributes As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool HasAttributes { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.HasAttributes : bool" Usage="System.Xml.XmlReader.HasAttributes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示当前节点是否有任何属性。</summary>
        <value>如果当前节点具有属性，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下面的示例显示当前节点上的所有属性。  
  
 [!code-csharp[XmlReaderBasic#6](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#6)]
 [!code-vb[XmlReaderBasic#6](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”</exception>
      </Docs>
    </Member>
    <Member MemberName="HasValue">
      <MemberSignature Language="C#" Value="public virtual bool HasValue { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasValue" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.HasValue" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property HasValue As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool HasValue { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.HasValue : bool" Usage="System.Xml.XmlReader.HasValue" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当在派生类中被重写时，获取一个值，该值指示当前节点是否可以具有 <see cref="P:System.Xml.XmlReader.Value" />。</summary>
        <value>如果读取器当前定位在的节点可以具有 <see langword="Value" />，则为 <see langword="true" />；否则为 <see langword="false" />。 如果为 <see langword="false" />，则节点值为 <see langword="String.Empty" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出具有要返回的值的节点类型。  
  
|节点类型|“值”|  
|---------------|-----------|  
|`Attribute`|属性的值。|  
|`CDATA`|CDATA 节的内容。|  
|`Comment`|注释的内容。|  
|`DocumentType`|内部子集。|  
|`ProcessingInstruction`|全部内容（不包括指令目标）。|  
|`SignificantWhitespace`|混合内容模型中标记之间的空白。|  
|`Text`|文本节点的内容。|  
|`Whitespace`|标记之间的空白。|  
|`XmlDeclaration`|声明的内容。|  
  
   
  
## Examples  
 请参阅<xref:System.Xml.XmlTextReader.HasValue%2A>(在`XmlTextReader`类) 使用此方法的示例。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”</exception>
      </Docs>
    </Member>
    <Member MemberName="IsDefault">
      <MemberSignature Language="C#" Value="public virtual bool IsDefault { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsDefault" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.IsDefault" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsDefault As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsDefault { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsDefault : bool" Usage="System.Xml.XmlReader.IsDefault" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当在派生类中被重写时，获取一个值，该值指示当前节点是否是从 DTD 或架构中定义的默认值生成的特性。</summary>
        <value>如果当前节点是其值从 DTD 或架构中定义的默认值生成的属性，则为 <see langword="true" />；如果属性值为显式设置的，则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `IsDefault` 始终返回`false`的实现`XmlReader`不支持架构或 DTD 信息。 此属性仅适用于属性节点。  
  
   
  
## Examples  
 下面的示例显示在根元素上的所有属性。  
  
```csharp  
using System;  
using System.IO;  
using System.Xml;  
  
public class Sample   
{  
  public static void Main(){  
  
    // Create the reader.  
    XmlReader reader = XmlReader.Create("book4.xml");  
  
    reader.MoveToContent();  
  
    // Display each of the attribute nodes, including default attributes.  
    while (reader.MoveToNextAttribute()){  
        if (reader.IsDefault)  
          Console.Write("(default attribute) ");  
        Console.WriteLine("{0} = {1}", reader.Name, reader.Value);    
    }             
  
    //Close the reader.  
    reader.Close();       
  
  }  
} // End class  
```  
  
 该示例使用以下文件作为输入。  
  
 `book4.xml`  
  
```xml  
<!DOCTYPE book SYSTEM 'book.dtd'>  
<book ISBN = '1-861001-57-5'>  
  <title>Pride And Prejudice</title>  
  <price>19.95</price>  
</book>  
```  
  
 `book.dtd`  
  
```  
<!ELEMENT book (title,price)>   
<!ATTLIST book   
   genre CDATA "novel"  
   ISBN CDATA #REQUIRED>  
<!ELEMENT title (#PCDATA)>  
<!ELEMENT price (#PCDATA)>  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”</exception>
      </Docs>
    </Member>
    <Member MemberName="IsEmptyElement">
      <MemberSignature Language="C#" Value="public abstract bool IsEmptyElement { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsEmptyElement" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.IsEmptyElement" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property IsEmptyElement As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property bool IsEmptyElement { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsEmptyElement : bool" Usage="System.Xml.XmlReader.IsEmptyElement" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当在派生类中被重写时，获取一个值，该值指示当前节点是否为空元素（例如 <c>&lt;MyElement/&gt;</c>）。</summary>
        <value>
          <see langword="true" /> 如果当前节点是一个元素 (<see cref="P:System.Xml.XmlReader.NodeType" />等于<see langword="XmlNodeType.Element" />)，结尾<c> / &gt; </c>; 否则为<see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此属性使您能够确定下面各项之间的差异：  
  
 `<item num="123"/>` (`IsEmptyElement`是`true`)。  
  
 `<item num="123"></item>` (`IsEmptyElement`是`false`，尽管元素内容为空)。  
  
 相应`EndElement`节点不为空元素生成。  
  
 如果默认的内容已添加到由于架构验证的元素`IsEmptyElement`仍返回`true`。 它没有任何影响在该元素是否有默认值。 换而言之，`IsEmptyElement`只是报告是否在源文档中的元素必须为结束元素标记。  
  
   
  
## Examples  
 以下示例显示每个元素的文本内容。  
  
 [!code-csharp[XmlReaderBasic#10](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#10)]
 [!code-vb[XmlReaderBasic#10](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#10)]  
  
 该示例使用该文件，`elems.xml`作为输入。  
  
 [!code-xml[XML_Core_Files#3](~/samples/snippets/xml/VS_Snippets_Data/XML_Core_Files/XML/elems.xml#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”</exception>
      </Docs>
    </Member>
    <Member MemberName="IsName">
      <MemberSignature Language="C#" Value="public static bool IsName (string str);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsName(string str) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.IsName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsName (str As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsName(System::String ^ str);" />
      <MemberSignature Language="F#" Value="static member IsName : string -&gt; bool" Usage="System.Xml.XmlReader.IsName str" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="str">要验证的名称。</param>
        <summary>返回一个值，该值指示字符串自变量是否是有效的 XML 名称。</summary>
        <returns>如果该名称有效，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法使用[W3C XML 1.0 建议](http://go.microsoft.com/fwlink/?LinkId=49863)以确定名称是否有效。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="str" /> 值为 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="IsNameToken">
      <MemberSignature Language="C#" Value="public static bool IsNameToken (string str);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsNameToken(string str) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.IsNameToken(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsNameToken (str As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsNameToken(System::String ^ str);" />
      <MemberSignature Language="F#" Value="static member IsNameToken : string -&gt; bool" Usage="System.Xml.XmlReader.IsNameToken str" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="str">要验证的名称标记。</param>
        <summary>返回一个值，该值指示该字符串自变量是否是有效的 XML 名称标记。</summary>
        <returns>如果它是有效的名称标记，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法使用[W3C XML 1.0 建议](http://go.microsoft.com/fwlink/?LinkId=49863)以确定是否为有效名称标记。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="str" /> 值为 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="IsStartElement">
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <exception cref="T:System.InvalidOperationException">在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情况下，将引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中”。</exception>
        <summary>测试当前内容节点是否是开始标记。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsStartElement">
      <MemberSignature Language="C#" Value="public virtual bool IsStartElement ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsStartElement() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.IsStartElement" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsStartElement () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsStartElement();" />
      <MemberSignature Language="F#" Value="abstract member IsStartElement : unit -&gt; bool&#xA;override this.IsStartElement : unit -&gt; bool" Usage="xmlReader.IsStartElement " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>调用 <see cref="M:System.Xml.XmlReader.MoveToContent" /> 并测试当前内容节点是否是开始标记或空元素标记。</summary>
        <returns>如果 <see cref="M:System.Xml.XmlReader.MoveToContent" /> 找到开始标记或空元素标记，则为 <see langword="true" />；如果找到不同于 <see langword="false" /> 的节点类型，则为 <see langword="XmlNodeType.Element" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法将跳过空格、 注释和处理指令之前读取器定位在某个内容节点上。 然后，此方法测试如果当前节点是一个元素。  
  
   
  
## Examples  
 以下示例显示每个元素的文本内容。  
  
 [!code-csharp[XmlReaderBasic#10](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#10)]
 [!code-vb[XmlReaderBasic#10](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#10)]  
  
 该示例使用该文件，`elems.xml`作为输入。  
  
 [!code-xml[XML_Core_Files#3](~/samples/snippets/xml/VS_Snippets_Data/XML_Core_Files/XML/elems.xml#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException">在输入流中遇到不正确的 XML。</exception>
        <exception cref="T:System.InvalidOperationException">在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”</exception>
        <altmember cref="M:System.Xml.XmlReader.MoveToContent" />
      </Docs>
    </Member>
    <Member MemberName="IsStartElement">
      <MemberSignature Language="C#" Value="public virtual bool IsStartElement (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsStartElement(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.IsStartElement(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsStartElement (name As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsStartElement(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member IsStartElement : string -&gt; bool&#xA;override this.IsStartElement : string -&gt; bool" Usage="xmlReader.IsStartElement name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">与找到的元素的 <see langword="Name" /> 属性匹配的字符串。</param>
        <summary>调用 <see cref="M:System.Xml.XmlReader.MoveToContent" /> 并测试当前内容节点是否是开始标记或空元素标记，以及所找到元素的 <see cref="P:System.Xml.XmlReader.Name" /> 属性是否与给定的参数匹配。</summary>
        <returns>如果生成的节点是一个元素，且 <see langword="true" /> 属性与指定的字符串匹配，则为 <see langword="Name" />。 如果找到 <see langword="false" /> 之外的节点类型，或者元素的 <see langword="XmlNodeType.Element" /> 属性与指定的字符串不匹配，则为 <see langword="Name" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法将跳过空格、 注释和处理指令之前读取器定位在某个内容节点上。 然后，此方法测试如果当前节点是一个元素。  
  
   
  
## Examples  
 下面的示例显示每个价格元素。  
  
 [!code-csharp[XmlReaderBasic#17](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#17)]
 [!code-vb[XmlReaderBasic#17](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#17)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException">在输入流中遇到不正确的 XML。</exception>
        <exception cref="T:System.InvalidOperationException">在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”</exception>
        <altmember cref="M:System.Xml.XmlReader.MoveToContent" />
      </Docs>
    </Member>
    <Member MemberName="IsStartElement">
      <MemberSignature Language="C#" Value="public virtual bool IsStartElement (string localname, string ns);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsStartElement(string localname, string ns) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.IsStartElement(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsStartElement (localname As String, ns As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsStartElement(System::String ^ localname, System::String ^ ns);" />
      <MemberSignature Language="F#" Value="abstract member IsStartElement : string * string -&gt; bool&#xA;override this.IsStartElement : string * string -&gt; bool" Usage="xmlReader.IsStartElement (localname, ns)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="localname" Type="System.String" />
        <Parameter Name="ns" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="localname">与找到的元素的 <see langword="LocalName" /> 属性匹配的字符串。</param>
        <param name="ns">与找到的元素的 <see langword="NamespaceURI" /> 属性匹配的字符串。</param>
        <summary>调用 <see cref="M:System.Xml.XmlReader.MoveToContent" /> 并测试当前内容节点是否是开始标记或空元素标记，以及所找到元素的 <see cref="P:System.Xml.XmlReader.LocalName" /> 和 <see cref="P:System.Xml.XmlReader.NamespaceURI" /> 属性是否与给定的字符串匹配。</summary>
        <returns>如果生成的节点是一个元素，则为 <see langword="true" />。 如果找到 <see langword="false" /> 之外的节点类型，或者元素的 <see langword="XmlNodeType.Element" /> 和 <see langword="LocalName" /> 属性与指定的字符串不匹配，则为 <see langword="NamespaceURI" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法将跳过空格、 注释和处理指令之前读取器定位在某个内容节点上。 然后，此方法测试如果当前节点是一个元素。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException">在输入流中遇到不正确的 XML。</exception>
        <exception cref="T:System.InvalidOperationException">在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”</exception>
        <altmember cref="M:System.Xml.XmlReader.MoveToContent" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Item">
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <exception cref="T:System.InvalidOperationException">在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情况下，将引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中”。</exception>
        <summary>当在派生类中被重写时，获取此属性的值。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public virtual string this[int i] { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Item(int32)" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.Item(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Default Public Overridable ReadOnly Property Item(i As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ default[int] { System::String ^ get(int i); };" />
      <MemberSignature Language="F#" Value="member this.Item(int) : string" Usage="System.Xml.XmlReader.Item" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="i" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="i">属性的索引。</param>
        <summary>当在派生类中被重写时，获取具有指定索引的属性的值。</summary>
        <value>指定的属性的值。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此属性不会移动读取器。  
  
   
  
## Examples  
 下面的示例显示当前节点上的所有属性。  
  
 [!code-csharp[XmlReaderBasic#1](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#1)]
 [!code-vb[XmlReaderBasic#1](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”</exception>
        <altmember cref="M:System.Xml.XmlReader.GetAttribute(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public virtual string this[string name] { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Item(string)" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.Item(System.String)" />
      <MemberSignature Language="VB.NET" Value="Default Public Overridable ReadOnly Property Item(name As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ default[System::String ^] { System::String ^ get(System::String ^ name); };" />
      <MemberSignature Language="F#" Value="member this.Item(string) : string" Usage="System.Xml.XmlReader.Item" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">属性的限定名称。</param>
        <summary>当在派生类中被重写时，获取具有指定 <see cref="P:System.Xml.XmlReader.Name" /> 的属性的值。</summary>
        <value>指定的属性的值。 如果未找到该属性，则返回 <see langword="null" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此属性不会移动读取器。  
  
 如果读取器定位在`DocumentType`节点，此方法可用于获取 PUBLIC 和 SYSTEM 文本，例如， `reader["PUBLIC"]`  
  
   
  
## Examples  
 下面的示例获取的 ISBN 属性的值。  
  
 [!code-csharp[XmlReaderBasic#7](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#7)]
 [!code-vb[XmlReaderBasic#7](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”</exception>
        <altmember cref="M:System.Xml.XmlReader.GetAttribute(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public virtual string this[string name, string namespaceURI] { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Item(string, string)" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.Item(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Default Public Overridable ReadOnly Property Item(name As String, namespaceURI As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ default[System::String ^, System::String ^] { System::String ^ get(System::String ^ name, System::String ^ namespaceURI); };" />
      <MemberSignature Language="F#" Value="member this.Item(string * string) : string" Usage="System.Xml.XmlReader.Item" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="namespaceURI" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">属性的本地名称。</param>
        <param name="namespaceURI">属性的命名空间 URI。</param>
        <summary>当在派生类中被重写时，获取具有指定 <see cref="P:System.Xml.XmlReader.LocalName" /> 和 <see cref="P:System.Xml.XmlReader.NamespaceURI" /> 的属性的值。</summary>
        <value>指定的属性的值。 如果未找到该属性，则返回 <see langword="null" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此属性不会移动读取器。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”</exception>
        <altmember cref="M:System.Xml.XmlReader.GetAttribute(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="LocalName">
      <MemberSignature Language="C#" Value="public abstract string LocalName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string LocalName" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.LocalName" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property LocalName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::String ^ LocalName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.LocalName : string" Usage="System.Xml.XmlReader.LocalName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当在派生类中被重写时，获取当前节点的本地名称。</summary>
        <value>移除了前缀的当前节点的名称。 例如，<see langword="LocalName" />是<see langword="book" />元素<c> &lt;bk:book&gt;</c>。  
  
对于没有名称的节点类型（如 <see langword="Text" />、<see langword="Comment" /> 等），该属性返回 <see langword="String.Empty" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下面的示例显示每个节点的本地名称和，如果它们存在，前缀和命名空间 URI。  
  
 [!code-csharp[XmlReaderBasic#9](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#9)]
 [!code-vb[XmlReaderBasic#9](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#9)]  
  
 该示例使用的文件，book2.xml，  
  
 [!code-xml[XML_Core_Files#5](~/samples/snippets/xml/VS_Snippets_Data/XML_Core_Files/XML/book2.xml#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”</exception>
        <altmember cref="P:System.Xml.XmlReader.Name" />
      </Docs>
    </Member>
    <Member MemberName="LookupNamespace">
      <MemberSignature Language="C#" Value="public abstract string LookupNamespace (string prefix);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string LookupNamespace(string prefix) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.LookupNamespace(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function LookupNamespace (prefix As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::String ^ LookupNamespace(System::String ^ prefix);" />
      <MemberSignature Language="F#" Value="abstract member LookupNamespace : string -&gt; string" Usage="xmlReader.LookupNamespace prefix" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="prefix" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="prefix">要解析其命名空间 URI 的前缀。 若要匹配默认命名空间，请传递一个空字符串。</param>
        <summary>当在派生类中被重写时，在当前元素的范围内解析命名空间前缀。</summary>
        <returns>前缀映射到的命名空间 URI；如果未找到任何匹配的前缀，则为 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果读取器定位在以下 XML 字符串中`href`属性，该前缀`a`解析通过调用`reader.LookupNamespace("a")`。 返回的字符串是`urn:456`。  
  
```xml  
<root xmlns:a="urn:456">  
  <item>  
  <ref href="a:b"/>  
  </item>  
 </root>  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="MoveToAttribute">
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <exception cref="T:System.InvalidOperationException">在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情况下，将引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中”。</exception>
        <summary>当在派生类中被重写时，移动到指定的属性。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="MoveToAttribute">
      <MemberSignature Language="C#" Value="public virtual void MoveToAttribute (int i);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void MoveToAttribute(int32 i) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.MoveToAttribute(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub MoveToAttribute (i As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void MoveToAttribute(int i);" />
      <MemberSignature Language="F#" Value="abstract member MoveToAttribute : int -&gt; unit&#xA;override this.MoveToAttribute : int -&gt; unit" Usage="xmlReader.MoveToAttribute i" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="i" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="i">属性的索引。</param>
        <summary>当在派生类中被重写时，移动到具有指定索引的属性。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下面的示例显示当前节点上的所有属性。  
  
 [!code-csharp[XmlReaderBasic#4](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#4)]
 [!code-vb[XmlReaderBasic#4](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">参数为负值。</exception>
      </Docs>
    </Member>
    <Member MemberName="MoveToAttribute">
      <MemberSignature Language="C#" Value="public abstract bool MoveToAttribute (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool MoveToAttribute(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.MoveToAttribute(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function MoveToAttribute (name As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract bool MoveToAttribute(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member MoveToAttribute : string -&gt; bool" Usage="xmlReader.MoveToAttribute name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">属性的限定名称。</param>
        <summary>当在派生类中被重写时，移动到具有指定 <see cref="P:System.Xml.XmlReader.Name" /> 的属性。</summary>
        <returns>如果找到了属性，则为 <see langword="true" />；否则为 <see langword="false" />。 如果为 <see langword="false" />，则读取器的位置未改变。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在调用`MoveToAttribute`，则<xref:System.Xml.XmlReader.Name%2A>， <xref:System.Xml.XmlReader.NamespaceURI%2A>，和<xref:System.Xml.XmlReader.Prefix%2A>属性反映了该属性的属性。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”</exception>
        <exception cref="T:System.ArgumentException">参数是空字符串。</exception>
      </Docs>
    </Member>
    <Member MemberName="MoveToAttribute">
      <MemberSignature Language="C#" Value="public abstract bool MoveToAttribute (string name, string ns);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool MoveToAttribute(string name, string ns) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.MoveToAttribute(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function MoveToAttribute (name As String, ns As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract bool MoveToAttribute(System::String ^ name, System::String ^ ns);" />
      <MemberSignature Language="F#" Value="abstract member MoveToAttribute : string * string -&gt; bool" Usage="xmlReader.MoveToAttribute (name, ns)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="ns" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">属性的本地名称。</param>
        <param name="ns">属性的命名空间 URI。</param>
        <summary>当在派生类中被重写时，移动到具有指定的 <see cref="P:System.Xml.XmlReader.LocalName" /> 和 <see cref="P:System.Xml.XmlReader.NamespaceURI" /> 的属性。</summary>
        <returns>如果找到了属性，则为 <see langword="true" />；否则为 <see langword="false" />。 如果为 <see langword="false" />，则读取器的位置未改变。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在调用`MoveToAttribute`，则<xref:System.Xml.XmlReader.Name%2A>， <xref:System.Xml.XmlReader.NamespaceURI%2A>，和<xref:System.Xml.XmlReader.Prefix%2A>属性反映了该属性的属性。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”</exception>
        <exception cref="T:System.ArgumentNullException">两个参数值均为 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="MoveToContent">
      <MemberSignature Language="C#" Value="public virtual System.Xml.XmlNodeType MoveToContent ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Xml.XmlNodeType MoveToContent() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.MoveToContent" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function MoveToContent () As XmlNodeType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Xml::XmlNodeType MoveToContent();" />
      <MemberSignature Language="F#" Value="abstract member MoveToContent : unit -&gt; System.Xml.XmlNodeType&#xA;override this.MoveToContent : unit -&gt; System.Xml.XmlNodeType" Usage="xmlReader.MoveToContent " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlNodeType</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>检查当前节点是否是内容（非空白文本、<see langword="CDATA" />、<see langword="Element" />、<see langword="EndElement" />、<see langword="EntityReference" /> 或 <see langword="EndEntity" />）节点。 如果此节点不是内容节点，则读取器向前跳至下一个内容节点或文件结尾。 它跳过以下类型的节点：<see langword="ProcessingInstruction" />、<see langword="DocumentType" />、<see langword="Comment" />、<see langword="Whitespace" /> 或 <see langword="SignificantWhitespace" />。</summary>
        <returns>此方法找到的当前节点的 <see cref="P:System.Xml.XmlReader.NodeType" />；如果读取器已到达输入流的末尾，则为 <see langword="XmlNodeType.None" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果当前节点是属性节点，则此方法将读取器移回拥有该属性的元素。  
  
 此方法的异步版本，请参阅<xref:System.Xml.XmlReader.MoveToContentAsync%2A>。  
  
   
  
## Examples  
 当你想要编写代码，可以跳过随机 XML 标记，但不会中断时，这很有用。 例如，假设有以下代码：  
  
 [!code-cpp[Classic WebData XmlReader.MoveToContent Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlReader.MoveToContent Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlReader.MoveToContent Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlReader.MoveToContent Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlReader.MoveToContent Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlReader.MoveToContent Example/VB/source.vb#1)]  
  
 此代码可以处理以下输入但不会中断：  
  
```xml  
<price>123.4</price>  
```  
  
 和  
  
```xml  
<?xml version="1.0"><!DOCTYPE price SYSTEM  
  "abc"><price>123.4</price>  
```  
  
 和  
  
```xml  
<?xml version="1.0"><!DOCTYPE price SYSTEM "abc"  
  [<!ENTTIY p  
  "123.4">]><price>&p;</price>  
```  
  
 和  
  
```xml  
<!-- some test comment --><?processing  
  instruction?><price>123.4</price>  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException">在输入流中遇到不正确的 XML。</exception>
        <exception cref="T:System.InvalidOperationException">在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”</exception>
      </Docs>
    </Member>
    <Member MemberName="MoveToContentAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;System.Xml.XmlNodeType&gt; MoveToContentAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;valuetype System.Xml.XmlNodeType&gt; MoveToContentAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.MoveToContentAsync" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function MoveToContentAsync () As Task(Of XmlNodeType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task&lt;System::Xml::XmlNodeType&gt; ^ MoveToContentAsync();" />
      <MemberSignature Language="F#" Value="abstract member MoveToContentAsync : unit -&gt; System.Threading.Tasks.Task&lt;System.Xml.XmlNodeType&gt;&#xA;override this.MoveToContentAsync : unit -&gt; System.Threading.Tasks.Task&lt;System.Xml.XmlNodeType&gt;" Usage="xmlReader.MoveToContentAsync " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.DebuggerStepThrough</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Xml.XmlNodeType&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>异步检查当前节点是否为内容节点。 如果此节点不是内容节点，则读取器向前跳至下一个内容节点或文件结尾。</summary>
        <returns>此方法找到的当前节点的 <see cref="P:System.Xml.XmlReader.NodeType" />；如果读取器已到达输入流的末尾，则为 <see langword="XmlNodeType.None" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 这是异步版本<xref:System.Xml.XmlReader.MoveToContent%2A>，具有相同功能。 若要使用此方法，必须设置<xref:System.Xml.XmlReaderSettings.Async%2A>标记，用于`true`。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">调用了 <see cref="T:System.Xml.XmlReader" /> 异步方法，但未将 <see cref="P:System.Xml.XmlReaderSettings.Async" /> 标志设置为 <see langword="true" />。 在此情况下，将引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“若要使用 Async 方法，请将 XmlReaderSettings.Async 设置为 True。”</exception>
        <related type="Article" href="http://msdn.microsoft.com/library/db854f91-ccef-4035-ae4d-0911fde808c7">使用 Async 和 Await 的异步编程（C# 和 Visual Basic）</related>
      </Docs>
    </Member>
    <Member MemberName="MoveToElement">
      <MemberSignature Language="C#" Value="public abstract bool MoveToElement ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool MoveToElement() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.MoveToElement" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function MoveToElement () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract bool MoveToElement();" />
      <MemberSignature Language="F#" Value="abstract member MoveToElement : unit -&gt; bool" Usage="xmlReader.MoveToElement " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>当在派生类中被重写时，移动到包含当前属性节点的元素。</summary>
        <returns>如果读取器定位在属性上（读取器移动到拥有该属性的元素），则为 <see langword="true" />；如果读取器未定位在属性上（读取器的位置不更改），则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法用于通过其属性导航后返回到该元素。 此方法将读取器移动到以下节点类型之一： `Element`， `DocumentType`，或`XmlDeclaration`。  
  
   
  
## Examples  
 下面的示例显示当前节点上的所有属性。  
  
 [!code-csharp[XmlReaderBasic#4](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#4)]
 [!code-vb[XmlReaderBasic#4](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”</exception>
      </Docs>
    </Member>
    <Member MemberName="MoveToFirstAttribute">
      <MemberSignature Language="C#" Value="public abstract bool MoveToFirstAttribute ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool MoveToFirstAttribute() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.MoveToFirstAttribute" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function MoveToFirstAttribute () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract bool MoveToFirstAttribute();" />
      <MemberSignature Language="F#" Value="abstract member MoveToFirstAttribute : unit -&gt; bool" Usage="xmlReader.MoveToFirstAttribute " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>当在派生类中被重写时，移动到第一个属性。</summary>
        <returns>如果属性存在（读取器移动到第一个属性），则为 <see langword="true" />；否则为 <see langword="false" />（读取器的位置不更改）。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下面的示例获取的第一个属性的值。  
  
 [!code-csharp[XmlReaderBasic#5](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#5)]
 [!code-vb[XmlReaderBasic#5](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”</exception>
      </Docs>
    </Member>
    <Member MemberName="MoveToNextAttribute">
      <MemberSignature Language="C#" Value="public abstract bool MoveToNextAttribute ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool MoveToNextAttribute() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.MoveToNextAttribute" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function MoveToNextAttribute () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract bool MoveToNextAttribute();" />
      <MemberSignature Language="F#" Value="abstract member MoveToNextAttribute : unit -&gt; bool" Usage="xmlReader.MoveToNextAttribute " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>当在派生类中被重写时，移动到下一个属性。</summary>
        <returns>如果存在下一个属性，则为 <see langword="true" />；如果没有其他属性，则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果当前节点是元素节点，此方法等同于<xref:System.Xml.XmlReader.MoveToFirstAttribute%2A>。 如果`MoveToNextAttribute`返回`true`，读取器移动到下一步属性; 否则为读取器位置不会更改。  
  
   
  
## Examples  
 下面的示例显示当前节点上的所有属性。  
  
 [!code-csharp[XmlReaderBasic#6](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#6)]
 [!code-vb[XmlReaderBasic#6](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”</exception>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public virtual string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.Name" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Name { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Name : string" Usage="System.Xml.XmlReader.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当在派生类中被重写时，获取当前节点的限定名。</summary>
        <value>当前节点的限定名称。 例如，<see langword="Name" />是<see langword="bk:book" />元素<c> &lt;bk:book&gt;</c>。  
  
返回的名称取决于节点的 <see cref="P:System.Xml.XmlReader.NodeType" />。 下列节点类型返回所列的值。 所有其他节点类型返回空字符串。  
  
 <list type="table"><listheader><term> 节点类型 
 </term><description> name 
 </description></listheader><item><term><see langword="Attribute" /></term><description> 属性名。  
  
 </description></item><item><term><see langword="DocumentType" /></term><description> 文档类型名称。  
  
 </description></item><item><term><see langword="Element" /></term><description> 标记名称。  
  
 </description></item><item><term><see langword="EntityReference" /></term><description> 引用的实体的名称。  
  
 </description></item><item><term><see langword="ProcessingInstruction" /></term><description> 处理指令的目标。  
  
 </description></item><item><term><see langword="XmlDeclaration" /></term><description> 字符串 <see langword="xml" />。  
  
 </description></item></list></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下面的示例读取 XML 文件，并显示每个节点。  
  
 [!code-csharp[XmlReaderBasic#8](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#8)]
 [!code-vb[XmlReaderBasic#8](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#8)]  
  
 此示例使用`items.xml`文件。  
  
 [!code-xml[XML_Core_Files#2](~/samples/snippets/xml/VS_Snippets_Data/XML_Core_Files/XML/items.xml#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”</exception>
        <altmember cref="P:System.Xml.XmlReader.LocalName" />
      </Docs>
    </Member>
    <Member MemberName="NamespaceURI">
      <MemberSignature Language="C#" Value="public abstract string NamespaceURI { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string NamespaceURI" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.NamespaceURI" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property NamespaceURI As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::String ^ NamespaceURI { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.NamespaceURI : string" Usage="System.Xml.XmlReader.NamespaceURI" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当在派生类中被重写时，获取读取器定位在其上的节点的命名空间 URI（采用 W3C 命名空间规范中定义的形式）。</summary>
        <value>当前节点的命名空间 URI；否则为空字符串。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此属性是与相关`Element`和`Attribute`仅限节点。  
  
   
  
## Examples  
 下面的示例显示每个节点的本地名称和，如果它们存在，前缀和命名空间 URI。  
  
 [!code-csharp[XmlReaderBasic#9](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#9)]
 [!code-vb[XmlReaderBasic#9](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#9)]  
  
 该示例使用的文件，book2.xml，  
  
 [!code-xml[XML_Core_Files#5](~/samples/snippets/xml/VS_Snippets_Data/XML_Core_Files/XML/book2.xml#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”</exception>
      </Docs>
    </Member>
    <Member MemberName="NameTable">
      <MemberSignature Language="C#" Value="public abstract System.Xml.XmlNameTable NameTable { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xml.XmlNameTable NameTable" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.NameTable" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property NameTable As XmlNameTable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::Xml::XmlNameTable ^ NameTable { System::Xml::XmlNameTable ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.NameTable : System.Xml.XmlNameTable" Usage="System.Xml.XmlReader.NameTable" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlNameTable</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当在派生类中被重写时，获取与该实现关联的 <see cref="T:System.Xml.XmlNameTable" />。</summary>
        <value>
          <see langword="XmlNameTable" />，它使你能够获取该节点内字符串的原子化版本。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 从返回的所有节点和属性名称<xref:System.Xml.XmlReader>使用原子化`NameTable`。 当多次返回相同的名称 (例如， `Customer`)，然后相同`String`对象将返回为该名称。 这使您能够编写高效的代码，does 对象上而不是成本高昂的字符串比较这些字符串的比较。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”</exception>
        <altmember cref="T:System.Xml.XmlNameTable" />
      </Docs>
    </Member>
    <Member MemberName="NodeType">
      <MemberSignature Language="C#" Value="public abstract System.Xml.XmlNodeType NodeType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Xml.XmlNodeType NodeType" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.NodeType" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property NodeType As XmlNodeType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::Xml::XmlNodeType NodeType { System::Xml::XmlNodeType get(); };" />
      <MemberSignature Language="F#" Value="member this.NodeType : System.Xml.XmlNodeType" Usage="System.Xml.XmlReader.NodeType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlNodeType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当在派生类中被重写时，获取当前节点的类型。</summary>
        <value>指定当前节点的类型的枚举值之一。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下面的示例读取 XML 文件，并显示每个节点。  
  
 [!code-csharp[XmlReaderBasic#8](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#8)]
 [!code-vb[XmlReaderBasic#8](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#8)]  
  
 此示例使用`items.xml`文件。  
  
 [!code-xml[XML_Core_Files#2](~/samples/snippets/xml/VS_Snippets_Data/XML_Core_Files/XML/items.xml#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”</exception>
      </Docs>
    </Member>
    <Member MemberName="Prefix">
      <MemberSignature Language="C#" Value="public abstract string Prefix { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Prefix" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.Prefix" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property Prefix As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::String ^ Prefix { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Prefix : string" Usage="System.Xml.XmlReader.Prefix" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当在派生类中被重写时，获取与当前节点关联的命名空间前缀。</summary>
        <value>与当前节点关联的命名空间前缀。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下面的示例显示每个节点的本地名称和，如果它们存在，前缀和命名空间 URI。  
  
 [!code-csharp[XmlReaderBasic#9](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#9)]
 [!code-vb[XmlReaderBasic#9](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#9)]  
  
 该示例使用的文件，book2.xml，  
  
 [!code-xml[XML_Core_Files#5](~/samples/snippets/xml/VS_Snippets_Data/XML_Core_Files/XML/book2.xml#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”</exception>
      </Docs>
    </Member>
    <Member MemberName="QuoteChar">
      <MemberSignature Language="C#" Value="public virtual char QuoteChar { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance char QuoteChar" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.QuoteChar" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property QuoteChar As Char" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property char QuoteChar { char get(); };" />
      <MemberSignature Language="F#" Value="member this.QuoteChar : char" Usage="System.Xml.XmlReader.QuoteChar" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当在派生类中被重写时，获取用于括住特性节点值的引号字符。</summary>
        <value>用于括起属性节点的值的引号字符（" 或 '）。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此属性仅适用于属性节点。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”</exception>
      </Docs>
    </Member>
    <Member MemberName="Read">
      <MemberSignature Language="C#" Value="public abstract bool Read ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Read() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.Read" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function Read () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract bool Read();" />
      <MemberSignature Language="F#" Value="abstract member Read : unit -&gt; bool" Usage="xmlReader.Read " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>当在派生类中被重写时，从流中读取下一个节点。</summary>
        <returns>如果已成功读取下一节点，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当<xref:System.Xml.XmlReader>第一次创建并初始化，没有可用信息。 必须调用<xref:System.Xml.XmlReader.Read%2A>读取的第一个节点。 <xref:System.Xml.XmlReader.Read%2A>方法设置的 XML 读取器启动的状态<xref:System.Xml.ReadState>遍历 XML 文件按顺序直到达到的文件，此时该方法返回的值的末尾`false`。  
  
 此方法需要至少四个字节从数据流才能开始分析。 如果返回少于四个字节，并在流中没有更多的数据，该方法返回`false`。 如果在流中没有更多的数据，该方法将阻止分析直到收到的第四个字节。  
  
 此方法的异步版本，请参阅<xref:System.Xml.XmlReader.ReadAsync%2A>。  
  
   
  
## Examples  
 下面的示例读取 XML 文件，并显示每个节点。  
  
 [!code-csharp[XmlReaderBasic#8](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#8)]
 [!code-vb[XmlReaderBasic#8](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#8)]  
  
 此示例使用`items.xml`文件。  
  
 [!code-xml[XML_Core_Files#2](~/samples/snippets/xml/VS_Snippets_Data/XML_Core_Files/XML/items.xml#2)]  
  
 **输出：**  
  
```  
<Item>Test with an entity: 123</Item><Item>Test with a child element <more> stuff</Item><Item>Test with a CDATA section <![CDATA[<456>]]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException">分析 XML 时出错。</exception>
        <exception cref="T:System.InvalidOperationException">在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;bool&gt; ReadAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;bool&gt; ReadAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadAsync" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadAsync () As Task(Of Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task&lt;bool&gt; ^ ReadAsync();" />
      <MemberSignature Language="F#" Value="abstract member ReadAsync : unit -&gt; System.Threading.Tasks.Task&lt;bool&gt;&#xA;override this.ReadAsync : unit -&gt; System.Threading.Tasks.Task&lt;bool&gt;" Usage="xmlReader.ReadAsync " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Boolean&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>异步读取该流的下一个节点。</summary>
        <returns>如果成功读取了下一个节点，则为 <see langword="true" />；如果没有其他节点可读取，则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 这是异步版本<xref:System.Xml.XmlReader.Read%2A>，具有相同功能。 若要使用此方法，必须设置<xref:System.Xml.XmlReaderSettings.Async%2A>标记，用于`true`。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">调用了 <see cref="T:System.Xml.XmlReader" /> 异步方法，但未将 <see cref="P:System.Xml.XmlReaderSettings.Async" /> 标志设置为 <see langword="true" />。 在此情况下，将引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“若要使用 Async 方法，请将 XmlReaderSettings.Async 设置为 True。”</exception>
        <related type="Article" href="http://msdn.microsoft.com/library/db854f91-ccef-4035-ae4d-0911fde808c7">使用 Async 和 Await 的异步编程（C# 和 Visual Basic）</related>
      </Docs>
    </Member>
    <Member MemberName="ReadAttributeValue">
      <MemberSignature Language="C#" Value="public abstract bool ReadAttributeValue ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool ReadAttributeValue() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadAttributeValue" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function ReadAttributeValue () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract bool ReadAttributeValue();" />
      <MemberSignature Language="F#" Value="abstract member ReadAttributeValue : unit -&gt; bool" Usage="xmlReader.ReadAttributeValue " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>当在派生类中被重写时，将属性值解析为一个或多个 <see langword="Text" />、<see langword="EntityReference" /> 或 <see langword="EndEntity" /> 节点。</summary>
        <returns>如果有可返回的节点，则为 <see langword="true" />。  
  
 如果进行初始调用时读取器不是定位在属性节点上，或者如果已读取了所有属性值，则为 <see langword="false" />。  
  
如果是空属性（如 <c>misc=""</c>），则返回 <see langword="true" />，同时返回值为 <see langword="String.Empty" /> 的单个节点。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用此方法之后调用<xref:System.Xml.XmlReader.MoveToAttribute%2A>通读组成属性值的文本或实体引用节点。 <xref:System.Xml.XmlReader.Depth%2A>的属性值的节点是一个加上属性节点的深度; 它递增和递减一个单步执行和跳出执行常规实体引用时。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadContentAs">
      <MemberSignature Language="C#" Value="public virtual object ReadContentAs (Type returnType, System.Xml.IXmlNamespaceResolver namespaceResolver);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object ReadContentAs(class System.Type returnType, class System.Xml.IXmlNamespaceResolver namespaceResolver) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadContentAs(System.Type,System.Xml.IXmlNamespaceResolver)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadContentAs (returnType As Type, namespaceResolver As IXmlNamespaceResolver) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ ReadContentAs(Type ^ returnType, System::Xml::IXmlNamespaceResolver ^ namespaceResolver);" />
      <MemberSignature Language="F#" Value="abstract member ReadContentAs : Type * System.Xml.IXmlNamespaceResolver -&gt; obj&#xA;override this.ReadContentAs : Type * System.Xml.IXmlNamespaceResolver -&gt; obj" Usage="xmlReader.ReadContentAs (returnType, namespaceResolver)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="namespaceResolver" Type="System.Xml.IXmlNamespaceResolver" />
      </Parameters>
      <Docs>
        <param name="returnType">要返回的值的类型。  
  
 **注意**：随着 .NET Framework 3.5 的发布，<c>returnType</c> 参数的值现在可以是 <see cref="T:System.DateTimeOffset" /> 类型。</param>
        <param name="namespaceResolver">一个 <see cref="T:System.Xml.IXmlNamespaceResolver" /> 对象，用于解析与类型转换有关的任何命名空间前缀。 例如，将 <see cref="T:System.Xml.XmlQualifiedName" /> 对象转换为 <c>xs:string</c> 时可以使用此对象。  
  
此值可为 <see langword="null" />。</param>
        <summary>将内容作为指定类型的对象读取。</summary>
        <returns>已转换为请求类型的串联文本内容或属性值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法读取位于当前读取器位置的文本内容，并将其转换为请求的返回类型。 文本、空白、有效空白和 CDATA 节串联在一起。 跳过注释和处理指令，并自动解析实体引用。  
  
 此方法用于读取、 如果有必要，请将其转换并返回从当前节点的原子值项内容。 返回输入的类型是否为当前节点包含当前节点的值的目标类型的实例的类型的有效映射。 请参阅备注部分中的<xref:System.Xml.XmlReader>referencepage 有关默认映射的列表。  
  
 例如，如果你有以下 XML 文本：  
  
```xml  
<elem>123 <!-- comment --> <?pi my_text?> 456 <?pi another_pi?></elem>  
```  
  
 如果数据类型化和一个字符串数组，提供给<xref:System.Xml.XmlReader.ReadContentAs%2A>从根据有效的 CLR 类型映射的列表的字符串转换方法调用，则整数值。  
  
 如果数据是非类型化和一个字符串数组，提供给<xref:System.Xml.XmlReader.ReadContentAs%2A>方法调用，则将内容解析到单独的字符串。 一个包含两个字符串的数组返回的值"123"和"456"。 从内容不保留空格。  
  
 通常在读取非类型化的数据的内容被分析根据所提供的类型。 例如，如果一个整数数组提供给<xref:System.Xml.XmlReader.ReadContentAs%2A>方法调用，则字符串解析为一个整数数组{123,456}。  
  
 在下面的示例中的 XML 文本不是由空格分隔  
  
```xml  
<elem>123<!-- comment --><?pi my_text?>456789<?pi another_pi?></elem>  
```  
  
 如果内容未类型化和一个字符串数组，提供给<xref:System.Xml.XmlReader.ReadContentAs%2A>方法然后调用一个数组，包含一个具有值"123456789"返回串联的字符串。  
  
 下表描述了此方法将每个节点类型的处理。  
  
|XmlNodeType|返回值|读取器行为|  
|-----------------|------------------|---------------------|  
|`Text`<br /><br /> `CDATA`<br /><br /> `Whitespace`<br /><br /> `SignificantWhitespace`<br /><br /> `EntityReference`<br /><br /> `EndEntity`|将文本、CDATA、空白和有效空白节点的串联内容转换为所请求的类型。|移至下一个开始元素或结束元素标记。 实体引用自动展开。|  
|`Attribute`|与调用相同`XmlConvert.ToXxx`上属性值。|读取器仍保留在当前位置。|  
|`Comment`<br /><br /> `ProcessingInstruction`|忽略处理指令 (PI) 或注释，读取 PI 或注释后面的串联文本内容。|移至下一个开始元素或结束元素标记。 实体引用自动展开。|  
|`EndElement`|空字符串。|读取器仍保留在当前位置。|  
|`Element`<br /><br /> `XmlDeclaration`<br /><br /> `None`<br /><br /> `Document`<br /><br /> `DocumentType`<br /><br /> `Notation`<br /><br /> `Entity`<br /><br /> `DocumentFragment`|引发 <xref:System.InvalidOperationException>。|未定义，尽管通常读取器将保留在当前位置。|  
  
 有关详细信息，请参阅备注部分<xref:System.Xml.XmlReader>参考页和[W3C XML 架构第 2 部分： 数据类型](http://go.microsoft.com/fwlink/?LinkId=4871)建议。  
  
 此方法的异步版本，请参阅<xref:System.Xml.XmlReader.ReadContentAsAsync%2A>。  
  
   
  
## Examples  
 下面的示例使用<xref:System.Xml.XmlReader.ReadContentAs%2A>方法将返回到字符串对象的数组的颜色元素的内容。  
  
 [!code-csharp[XmlReader.ReadContentAs#2](~/samples/snippets/csharp/VS_Snippets_Data/XmlReader.ReadContentAs/CS/readContentAs.cs#2)]
 [!code-vb[XmlReader.ReadContentAs#2](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReader.ReadContentAs/VB/readContentAs.vb#2)]  
  
 示例使用 `dataFile_2.xml` 文件作为输入。  
  
 [!code-xml[XmlReader.ReadContentAs#3](~/samples/snippets/xml/VS_Snippets_Data/XmlReader.ReadContentAs/XML/dataFile_2.xml#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">内容格式不是目标类型的正确格式。</exception>
        <exception cref="T:System.InvalidCastException">试图进行的强制转换无效。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="returnType" /> 值为 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”</exception>
        <exception cref="T:System.OverflowException">读取 <see langword="Decimal.MaxValue" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadContentAsAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;object&gt; ReadContentAsAsync (Type returnType, System.Xml.IXmlNamespaceResolver namespaceResolver);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;object&gt; ReadContentAsAsync(class System.Type returnType, class System.Xml.IXmlNamespaceResolver namespaceResolver) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadContentAsAsync(System.Type,System.Xml.IXmlNamespaceResolver)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadContentAsAsync (returnType As Type, namespaceResolver As IXmlNamespaceResolver) As Task(Of Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task&lt;System::Object ^&gt; ^ ReadContentAsAsync(Type ^ returnType, System::Xml::IXmlNamespaceResolver ^ namespaceResolver);" />
      <MemberSignature Language="F#" Value="abstract member ReadContentAsAsync : Type * System.Xml.IXmlNamespaceResolver -&gt; System.Threading.Tasks.Task&lt;obj&gt;&#xA;override this.ReadContentAsAsync : Type * System.Xml.IXmlNamespaceResolver -&gt; System.Threading.Tasks.Task&lt;obj&gt;" Usage="xmlReader.ReadContentAsAsync (returnType, namespaceResolver)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.DebuggerStepThrough</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Object&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="namespaceResolver" Type="System.Xml.IXmlNamespaceResolver" />
      </Parameters>
      <Docs>
        <param name="returnType">要返回的值的类型。</param>
        <param name="namespaceResolver">一个 <see cref="T:System.Xml.IXmlNamespaceResolver" /> 对象，用于解析与类型转换有关的任何命名空间前缀。</param>
        <summary>将内容作为指定类型的对象异步读取。</summary>
        <returns>已转换为请求类型的串联文本内容或属性值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 这是异步版本<xref:System.Xml.XmlReader.ReadContentAs%2A>，具有相同功能。 若要使用此方法，必须设置<xref:System.Xml.XmlReaderSettings.Async%2A>标记，用于`true`。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">调用了 <see cref="T:System.Xml.XmlReader" /> 异步方法，但未将 <see cref="P:System.Xml.XmlReaderSettings.Async" /> 标志设置为 <see langword="true" />。 在此情况下，将引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“若要使用 Async 方法，请将 XmlReaderSettings.Async 设置为 True。”</exception>
        <related type="Article" href="http://msdn.microsoft.com/library/db854f91-ccef-4035-ae4d-0911fde808c7">使用 Async 和 Await 的异步编程（C# 和 Visual Basic）</related>
      </Docs>
    </Member>
    <Member MemberName="ReadContentAsBase64">
      <MemberSignature Language="C#" Value="public virtual int ReadContentAsBase64 (byte[] buffer, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 ReadContentAsBase64(unsigned int8[] buffer, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadContentAsBase64(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadContentAsBase64 (buffer As Byte(), index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int ReadContentAsBase64(cli::array &lt;System::Byte&gt; ^ buffer, int index, int count);" />
      <MemberSignature Language="F#" Value="abstract member ReadContentAsBase64 : byte[] * int * int -&gt; int&#xA;override this.ReadContentAsBase64 : byte[] * int * int -&gt; int" Usage="xmlReader.ReadContentAsBase64 (buffer, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">结果文本复制到的缓冲区。 此值不能为 <see langword="null" />。</param>
        <param name="index">缓冲区中的偏移，从这个位置开始将结果复制到缓冲区中。</param>
        <param name="count">要复制到缓冲区的最大字节数。 此方法返回复制的实际字节数。</param>
        <summary>读取内容并返回 Base64 解码的二进制字节。</summary>
        <returns>写入缓冲区的字节数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法的内容流式处理、 解码`Base64`内容，并返回已解码的二进制字节 (例如，内联`Base64`编码的 GIF 图像) 到缓冲区。 可以连续调用此方法，以读取大的嵌入文本流。 有关详细信息，请参阅 RFC 1521"MIME （多用途 Internet 邮件扩展） 部分一个： 用于指定和 Internet 消息正文的格式描述机制"。 您可以获得从 Rfc[征求意见文档网站](http://go.microsoft.com/fwlink/?LinkId=37119)。  
  
> [!NOTE]
>  不应访问的任何读取器属性调用之间<xref:System.Xml.XmlReader.ReadContentAsBase64%2A>方法，直到该方法返回值`0`。  
  
 此方法具有以下行为：  
  
-   <xref:System.Xml.XmlReader.ReadContentAsBase64%2A> 返回的值`0`时它已达到处理字节流的末尾。 读取器位于第一个非内容节点上。  
  
-   如果您需要更少，或的字节数比流读取器将保留在当前位置中剩余的精确数目。  
  
-   <xref:System.Xml.XmlReader.ReadContentAsBase64%2A> 不支持对以下 XML 节点类型： `Element`， `XmlDeclaration`， `None`， `Document`， `DocumentType`， `Notation`， `Entity`， `DocumentFragment`。  
  
 此方法的异步版本，请参阅<xref:System.Xml.XmlReader.ReadContentAsBase64Async%2A>。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> 值为 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">缓冲区中的索引或者索引与计数之和大于分配的缓冲区大小。</exception>
        <exception cref="T:System.NotSupportedException">
          <see cref="T:System.Xml.XmlReader" /> 实现不支持此方法。</exception>
        <altmember cref="M:System.Xml.XmlReader.ReadElementContentAsBase64(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="T:System.Xml.XmlNodeType" />
      </Docs>
    </Member>
    <Member MemberName="ReadContentAsBase64Async">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;int&gt; ReadContentAsBase64Async (byte[] buffer, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;int32&gt; ReadContentAsBase64Async(unsigned int8[] buffer, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadContentAsBase64Async(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadContentAsBase64Async (buffer As Byte(), index As Integer, count As Integer) As Task(Of Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task&lt;int&gt; ^ ReadContentAsBase64Async(cli::array &lt;System::Byte&gt; ^ buffer, int index, int count);" />
      <MemberSignature Language="F#" Value="abstract member ReadContentAsBase64Async : byte[] * int * int -&gt; System.Threading.Tasks.Task&lt;int&gt;&#xA;override this.ReadContentAsBase64Async : byte[] * int * int -&gt; System.Threading.Tasks.Task&lt;int&gt;" Usage="xmlReader.ReadContentAsBase64Async (buffer, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">结果文本复制到的缓冲区。 此值不能为 <see langword="null" />。</param>
        <param name="index">缓冲区中的偏移，从这个位置开始将结果复制到缓冲区中。</param>
        <param name="count">要复制到缓冲区的最大字节数。 此方法返回复制的实际字节数。</param>
        <summary>异步读取内容并返回 Base64 解码的二进制字节。</summary>
        <returns>写入缓冲区的字节数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 这是异步版本<xref:System.Xml.XmlReader.ReadContentAsBase64%2A>，具有相同功能。 若要使用此方法，必须设置<xref:System.Xml.XmlReaderSettings.Async%2A>标记，用于`true`。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">调用了 <see cref="T:System.Xml.XmlReader" /> 异步方法，但未将 <see cref="P:System.Xml.XmlReaderSettings.Async" /> 标志设置为 <see langword="true" />。 在此情况下，将引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“若要使用 Async 方法，请将 XmlReaderSettings.Async 设置为 True。”</exception>
        <related type="Article" href="http://msdn.microsoft.com/library/db854f91-ccef-4035-ae4d-0911fde808c7">使用 Async 和 Await 的异步编程（C# 和 Visual Basic）</related>
      </Docs>
    </Member>
    <Member MemberName="ReadContentAsBinHex">
      <MemberSignature Language="C#" Value="public virtual int ReadContentAsBinHex (byte[] buffer, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 ReadContentAsBinHex(unsigned int8[] buffer, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadContentAsBinHex(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadContentAsBinHex (buffer As Byte(), index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int ReadContentAsBinHex(cli::array &lt;System::Byte&gt; ^ buffer, int index, int count);" />
      <MemberSignature Language="F#" Value="abstract member ReadContentAsBinHex : byte[] * int * int -&gt; int&#xA;override this.ReadContentAsBinHex : byte[] * int * int -&gt; int" Usage="xmlReader.ReadContentAsBinHex (buffer, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">结果文本复制到的缓冲区。 此值不能为 <see langword="null" />。</param>
        <param name="index">缓冲区中的偏移，从这个位置开始将结果复制到缓冲区中。</param>
        <param name="count">要复制到缓冲区的最大字节数。 此方法返回复制的实际字节数。</param>
        <summary>读取内容并返回 <see langword="BinHex" /> 解码的二进制字节。</summary>
        <returns>写入缓冲区的字节数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法的内容流式处理、 解码`BinHex`内容，并返回已解码的二进制字节 (例如，内联`BinHex`编码的 GIF 图像) 到缓冲区。 可以连续调用此方法，以读取大的嵌入文本流。  
  
> [!NOTE]
>  不应访问的任何读取器属性调用之间<xref:System.Xml.XmlReader.ReadContentAsBinHex%2A>方法，直到该方法返回值`0`。  
  
 此方法具有以下行为：  
  
-   <xref:System.Xml.XmlReader.ReadContentAsBinHex%2A> 返回的值`0`时它已达到处理字节流的末尾。 读取器位于第一个非内容节点上。  
  
-   如果您要求更少，或在其当前位置中保留的字节数比在流中读取器保留的精确数目。  
  
-   <xref:System.Xml.XmlReader.ReadContentAsBinHex%2A> 不支持对以下 XML 节点类型： `Element`， `XmlDeclaration`， `None`， `Document`， `DocumentType`， `Notation, Entity`， `DocumentFragment`。  
  
 此方法的异步版本，请参阅<xref:System.Xml.XmlReader.ReadContentAsBinHexAsync%2A>。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> 值为 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">缓冲区中的索引或者索引与计数之和大于分配的缓冲区大小。</exception>
        <exception cref="T:System.NotSupportedException">
          <see cref="T:System.Xml.XmlReader" /> 实现不支持此方法。</exception>
        <altmember cref="M:System.Xml.XmlReader.ReadElementContentAsBinHex(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="T:System.Xml.XmlNodeType" />
      </Docs>
    </Member>
    <Member MemberName="ReadContentAsBinHexAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;int&gt; ReadContentAsBinHexAsync (byte[] buffer, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;int32&gt; ReadContentAsBinHexAsync(unsigned int8[] buffer, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadContentAsBinHexAsync(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadContentAsBinHexAsync (buffer As Byte(), index As Integer, count As Integer) As Task(Of Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task&lt;int&gt; ^ ReadContentAsBinHexAsync(cli::array &lt;System::Byte&gt; ^ buffer, int index, int count);" />
      <MemberSignature Language="F#" Value="abstract member ReadContentAsBinHexAsync : byte[] * int * int -&gt; System.Threading.Tasks.Task&lt;int&gt;&#xA;override this.ReadContentAsBinHexAsync : byte[] * int * int -&gt; System.Threading.Tasks.Task&lt;int&gt;" Usage="xmlReader.ReadContentAsBinHexAsync (buffer, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">结果文本复制到的缓冲区。 此值不能为 <see langword="null" />。</param>
        <param name="index">缓冲区中的偏移，从这个位置开始将结果复制到缓冲区中。</param>
        <param name="count">要复制到缓冲区的最大字节数。 此方法返回复制的实际字节数。</param>
        <summary>异步读取内容并返回 <see langword="BinHex" /> 解码的二进制字节。</summary>
        <returns>写入缓冲区的字节数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 这是异步版本<xref:System.Xml.XmlReader.ReadContentAsBinHex%2A>，具有相同功能。 若要使用此方法，必须设置<xref:System.Xml.XmlReaderSettings.Async%2A>标记，用于`true`。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">调用了 <see cref="T:System.Xml.XmlReader" /> 异步方法，但未将 <see cref="P:System.Xml.XmlReaderSettings.Async" /> 标志设置为 <see langword="true" />。 在此情况下，将引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“若要使用 Async 方法，请将 XmlReaderSettings.Async 设置为 True。”</exception>
        <related type="Article" href="http://msdn.microsoft.com/library/db854f91-ccef-4035-ae4d-0911fde808c7">使用 Async 和 Await 的异步编程（C# 和 Visual Basic）</related>
      </Docs>
    </Member>
    <Member MemberName="ReadContentAsBoolean">
      <MemberSignature Language="C#" Value="public virtual bool ReadContentAsBoolean ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool ReadContentAsBoolean() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadContentAsBoolean" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadContentAsBoolean () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool ReadContentAsBoolean();" />
      <MemberSignature Language="F#" Value="abstract member ReadContentAsBoolean : unit -&gt; bool&#xA;override this.ReadContentAsBoolean : unit -&gt; bool" Usage="xmlReader.ReadContentAsBoolean " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>将当前位置的文本内容作为 <see langword="Boolean" /> 读取。</summary>
        <returns>作为 <see cref="T:System.Boolean" /> 对象的文本内容。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法将文本、 空白、 有效空白和 CDATA 部分中，连接，将跳过任何注释或处理指令。 实体引用来自动解决。  
  
 如果将内容类型`xsd:boolean`，则读取器返回取消装箱<xref:System.Boolean>对象。 如果内容未类型化`xsd:boolean`，读取器将尝试将其转换为<xref:System.Boolean>根据定义的规则对象[W3C XML 架构第 2 部分： 数据类型](http://go.microsoft.com/fwlink/?LinkId=4871)建议。  
  
 下表描述了此方法将每个节点类型的处理。  
  
|XmlNodeType|返回值|读取器行为|  
|-----------------|------------------|---------------------|  
|`Text`<br /><br /> `CDATA`<br /><br /> `Whitespace`<br /><br /> `SignificantWhitespace`<br /><br /> `EntityReference`<br /><br /> `EndEntity`|将文本、CDATA、空白和有效空白节点的串联内容转换为所请求的类型。|移至下一个开始元素或结束元素标记。 实体引用自动展开。|  
|`Attribute`|与调用相同`XmlConvert.ToXxx`上属性值。|读取器仍保留在当前位置。|  
|`Comment`<br /><br /> `ProcessingInstruction`|忽略处理指令 (PI) 或注释，读取 PI 或注释后面的串联文本内容。|移至下一个开始元素或结束元素标记。 实体引用自动展开。|  
|`EndElement`|空字符串。|读取器仍保留在当前位置。|  
|`Element`<br /><br /> `XmlDeclaration`<br /><br /> `None`<br /><br /> `Document`<br /><br /> `DocumentType`<br /><br /> `Notation`<br /><br /> `Entity`<br /><br /> `DocumentFragment`|引发 <xref:System.InvalidOperationException>。|未定义，尽管通常读取器将保留在当前位置。|  
  
 有关详细信息，请参阅<xref:System.Xml.XmlReader>参考页和[W3C XML 架构第 2 部分： 数据类型](http://go.microsoft.com/fwlink/?LinkId=4871)建议。  
  
   
  
## Examples  
 下面的示例使用<xref:System.Xml.XmlReader.ReadContentAsBoolean%2A>方法来读取特性作为 B`oolean`值。  
  
 [!code-csharp[XmlReader.ReadContentAs#1](~/samples/snippets/csharp/VS_Snippets_Data/XmlReader.ReadContentAs/CS/readContentAs.cs#1)]
 [!code-vb[XmlReader.ReadContentAs#1](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReader.ReadContentAs/VB/readContentAs.vb#1)]  
  
 示例使用 `dataFile_2.xml` 文件作为输入。  
  
 [!code-xml[XmlReader.ReadContentAs#3](~/samples/snippets/xml/VS_Snippets_Data/XmlReader.ReadContentAs/XML/dataFile_2.xml#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidCastException">试图进行的强制转换无效。</exception>
        <exception cref="T:System.FormatException">该字符串格式无效。</exception>
        <exception cref="T:System.InvalidOperationException">在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadContentAsDateTime">
      <MemberSignature Language="C#" Value="public virtual DateTime ReadContentAsDateTime ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.DateTime ReadContentAsDateTime() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadContentAsDateTime" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadContentAsDateTime () As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual DateTime ReadContentAsDateTime();" />
      <MemberSignature Language="F#" Value="abstract member ReadContentAsDateTime : unit -&gt; DateTime&#xA;override this.ReadContentAsDateTime : unit -&gt; DateTime" Usage="xmlReader.ReadContentAsDateTime " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>将当前位置的文本内容作为 <see cref="T:System.DateTime" /> 对象读取。</summary>
        <returns>作为 <see cref="T:System.DateTime" /> 对象的文本内容。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法将文本、 空白、 有效空白和 CDATA 部分中，连接，将跳过任何注释或处理指令。 实体引用来自动解决。  
  
 如果将内容类型`xsd:dateTime`，则读取器返回取消装箱<xref:System.DateTime>对象。 如果内容未类型化`xsd:dateTime`，读取器将尝试将其转换为<xref:System.DateTime>根据定义的规则对象[W3C XML 架构第 2 部分： 数据类型](http://go.microsoft.com/fwlink/?LinkId=4871)建议。  
  
> [!NOTE]
>  如果内容类型化为 <xref:System.DateTime.Year%2A?displayProperty=nameWithType>，则不能使用 `xsd:gMonthDay` 值。 <xref:System.Xml.XmlReader> 始终设置<xref:System.DateTime.Year%2A?displayProperty=nameWithType>这种情况下值为 1904年。  
  
 下表描述了此方法将每个节点类型的处理。  
  
|XmlNodeType|返回值|读取器行为|  
|-----------------|------------------|---------------------|  
|`Text`<br /><br /> `CDATA`<br /><br /> `Whitespace`<br /><br /> `SignificantWhitespace`<br /><br /> `EntityReference`<br /><br /> `EndEntity`|将文本、CDATA、空白和有效空白节点的串联内容转换为所请求的类型。|移至下一个开始元素或结束元素标记。 实体引用自动展开。|  
|`Attribute`|与调用相同`XmlConvert.ToXxx`上属性值。|读取器仍保留在当前位置。|  
|`Comment`<br /><br /> `ProcessingInstruction`|忽略处理指令 (PI) 或注释，读取 PI 或注释后面的串联文本内容。|移至下一个开始元素或结束元素标记。 实体引用自动展开。|  
|`EndElement`|空字符串。|读取器仍保留在当前位置。|  
|`Element`<br /><br /> `XmlDeclaration`<br /><br /> `None`<br /><br /> `Document`<br /><br /> `DocumentType`<br /><br /> `Notation`<br /><br /> `Entity`<br /><br /> `DocumentFragment`|引发 <xref:System.InvalidOperationException>。|未定义，尽管通常读取器将保留在当前位置。|  
  
 有关详细信息，请参阅<xref:System.Xml.XmlReader>参考页和[W3C XML 架构第 2 部分： 数据类型](http://go.microsoft.com/fwlink/?LinkId=4871)建议。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidCastException">试图进行的强制转换无效。</exception>
        <exception cref="T:System.FormatException">该字符串格式无效。</exception>
        <exception cref="T:System.InvalidOperationException">在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadContentAsDateTimeOffset">
      <MemberSignature Language="C#" Value="public virtual DateTimeOffset ReadContentAsDateTimeOffset ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.DateTimeOffset ReadContentAsDateTimeOffset() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadContentAsDateTimeOffset" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadContentAsDateTimeOffset () As DateTimeOffset" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual DateTimeOffset ReadContentAsDateTimeOffset();" />
      <MemberSignature Language="F#" Value="abstract member ReadContentAsDateTimeOffset : unit -&gt; DateTimeOffset&#xA;override this.ReadContentAsDateTimeOffset : unit -&gt; DateTimeOffset" Usage="xmlReader.ReadContentAsDateTimeOffset " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTimeOffset</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>将当前位置的文本内容作为 <see cref="T:System.DateTimeOffset" /> 对象读取。</summary>
        <returns>作为 <see cref="T:System.DateTimeOffset" /> 对象的文本内容。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadContentAsDecimal">
      <MemberSignature Language="C#" Value="public virtual decimal ReadContentAsDecimal ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Decimal ReadContentAsDecimal() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadContentAsDecimal" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadContentAsDecimal () As Decimal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Decimal ReadContentAsDecimal();" />
      <MemberSignature Language="F#" Value="abstract member ReadContentAsDecimal : unit -&gt; decimal&#xA;override this.ReadContentAsDecimal : unit -&gt; decimal" Usage="xmlReader.ReadContentAsDecimal " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>将当前位置的文本内容作为 <see cref="T:System.Decimal" /> 对象读取。</summary>
        <returns>作为 <see cref="T:System.Decimal" /> 对象的当前位置的文本内容。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法将文本、 空白、 有效空白和 CDATA 部分中，连接，将跳过任何注释或处理指令。 实体引用来自动解决。  
  
 如果将内容类型`xsd:decimal`，则读取器返回取消装箱<xref:System.Decimal>对象。 如果内容未类型化`xsd:decimal`，读取器将尝试将其转换为<xref:System.Decimal>根据定义的规则对象[W3C XML 架构第 2 部分： 数据类型](http://go.microsoft.com/fwlink/?LinkId=4871)建议。  
  
 下表描述了此方法将每个节点类型的处理。  
  
|XmlNodeType|返回值|读取器行为|  
|-----------------|------------------|---------------------|  
|`Text`<br /><br /> `CDATA`<br /><br /> `Whitespace`<br /><br /> `SignificantWhitespace`<br /><br /> `EntityReference`<br /><br /> `EndEntity`|将文本、CDATA、空白和有效空白节点的串联内容转换为所请求的类型。|移至下一个开始元素或结束元素标记。 实体引用自动展开。|  
|`Attribute`|与调用相同`XmlConvert.ToXxx`上属性值。|读取器仍保留在当前位置。|  
|`Comment`<br /><br /> `ProcessingInstruction`|忽略处理指令 (PI) 或注释，读取 PI 或注释后面的串联文本内容。|移至下一个开始元素或结束元素标记。 实体引用自动展开。|  
|`EndElement`|空字符串。|读取器仍保留在当前位置。|  
|`Element`<br /><br /> `XmlDeclaration`<br /><br /> `None`<br /><br /> `Document`<br /><br /> `DocumentType`<br /><br /> `Notation`<br /><br /> `Entity`<br /><br /> `DocumentFragment`|引发 <xref:System.InvalidOperationException>。|未定义，尽管通常读取器将保留在当前位置。|  
  
 有关详细信息，请参阅<xref:System.Xml.XmlReader>参考页和[W3C XML 架构第 2 部分： 数据类型](http://go.microsoft.com/fwlink/?LinkId=4871)建议。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidCastException">试图进行的强制转换无效。</exception>
        <exception cref="T:System.FormatException">该字符串格式无效。</exception>
        <exception cref="T:System.InvalidOperationException">在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadContentAsDouble">
      <MemberSignature Language="C#" Value="public virtual double ReadContentAsDouble ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance float64 ReadContentAsDouble() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadContentAsDouble" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadContentAsDouble () As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual double ReadContentAsDouble();" />
      <MemberSignature Language="F#" Value="abstract member ReadContentAsDouble : unit -&gt; double&#xA;override this.ReadContentAsDouble : unit -&gt; double" Usage="xmlReader.ReadContentAsDouble " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>将当前位置的文本内容作为双精度浮点数读取。</summary>
        <returns>作为双精度浮点数的文本内容。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法将文本、 空白、 有效空白和 CDATA 部分中，连接，将跳过任何注释或处理指令。 实体引用来自动解决。  
  
 如果将内容类型`xsd:double`，读取器返回一个双精度浮点数。 如果内容未类型化`xsd:double`，读取器将尝试将其转换为根据定义的规则的双精度浮点数[W3C XML 架构第 2 部分： 数据类型](http://go.microsoft.com/fwlink/?LinkId=4871)建议。  
  
 下表描述了此方法将每个节点类型的处理。  
  
|XmlNodeType|返回值|读取器行为|  
|-----------------|------------------|---------------------|  
|`Text`<br /><br /> `CDATA`<br /><br /> `Whitespace`<br /><br /> `SignificantWhitespace`<br /><br /> `EntityReference`<br /><br /> `EndEntity`|将文本、CDATA、空白和有效空白节点的串联内容转换为所请求的类型。|移至下一个开始元素或结束元素标记。 实体引用自动展开。|  
|`Attribute`|与调用相同`XmlConvert.ToXxx`上属性值。|读取器仍保留在当前位置。|  
|`Comment`<br /><br /> `ProcessingInstruction`|忽略处理指令 (PI) 或注释，读取 PI 或注释后面的串联文本内容。|移至下一个开始元素或结束元素标记。 实体引用自动展开。|  
|`EndElement`|空字符串。|读取器仍保留在当前位置。|  
|`Element`<br /><br /> `XmlDeclaration`<br /><br /> `None`<br /><br /> `Document`<br /><br /> `DocumentType`<br /><br /> `Notation`<br /><br /> `Entity`<br /><br /> `DocumentFragment`|引发 <xref:System.InvalidOperationException>。|未定义，尽管通常读取器将保留在当前位置。|  
  
 有关详细信息，请参阅<xref:System.Xml.XmlReader>参考页和[W3C XML 架构第 2 部分： 数据类型](http://go.microsoft.com/fwlink/?LinkId=4871)建议。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidCastException">试图进行的强制转换无效。</exception>
        <exception cref="T:System.FormatException">该字符串格式无效。</exception>
        <exception cref="T:System.InvalidOperationException">在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadContentAsFloat">
      <MemberSignature Language="C#" Value="public virtual float ReadContentAsFloat ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance float32 ReadContentAsFloat() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadContentAsFloat" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadContentAsFloat () As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual float ReadContentAsFloat();" />
      <MemberSignature Language="F#" Value="abstract member ReadContentAsFloat : unit -&gt; single&#xA;override this.ReadContentAsFloat : unit -&gt; single" Usage="xmlReader.ReadContentAsFloat " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>将当前位置的文本内容作为单精度浮点数读取。</summary>
        <returns>作为单精度浮点数的当前位置的文本内容。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法将文本、 空白、 有效空白和 CDATA 部分中，连接，将跳过任何注释或处理指令。 实体引用来自动解决。  
  
 如果将内容类型`xsd:float`，读取器返回取消装箱单精度浮点数字。 如果内容未类型化`xsd:float`，读取器将尝试将其转换为单精度浮点数根据定义的规则[W3C XML 架构第 2 部分： 数据类型](http://go.microsoft.com/fwlink/?LinkId=4871)建议。  
  
 下表描述了此方法将每个节点类型的处理。  
  
|XmlNodeType|返回值|读取器行为|  
|-----------------|------------------|---------------------|  
|`Text`<br /><br /> `CDATA`<br /><br /> `Whitespace`<br /><br /> `SignificantWhitespace`<br /><br /> `EntityReference`<br /><br /> `EndEntity`|将文本、CDATA、空白和有效空白节点的串联内容转换为所请求的类型。|移至下一个开始元素或结束元素标记。 实体引用自动展开。|  
|`Attribute`|与调用相同`XmlConvert.ToXxx`上属性值。|读取器仍保留在当前位置。|  
|`Comment`<br /><br /> `ProcessingInstruction`|忽略处理指令 (PI) 或注释，读取 PI 或注释后面的串联文本内容。|移至下一个开始元素或结束元素标记。 实体引用自动展开。|  
|`EndElement`|空字符串。|读取器仍保留在当前位置。|  
|`Element`<br /><br /> `XmlDeclaration`<br /><br /> `None`<br /><br /> `Document`<br /><br /> `DocumentType`<br /><br /> `Notation`<br /><br /> `Entity`<br /><br /> `DocumentFragment`|引发 <xref:System.InvalidOperationException>。|未定义，尽管通常读取器将保留在当前位置。|  
  
 有关详细信息，请参阅备注部分<xref:System.Xml.XmlReader>参考页和[W3C XML 架构第 2 部分： 数据类型](http://go.microsoft.com/fwlink/?LinkId=4871)建议。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidCastException">试图进行的强制转换无效。</exception>
        <exception cref="T:System.FormatException">该字符串格式无效。</exception>
        <exception cref="T:System.InvalidOperationException">在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadContentAsInt">
      <MemberSignature Language="C#" Value="public virtual int ReadContentAsInt ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 ReadContentAsInt() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadContentAsInt" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadContentAsInt () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int ReadContentAsInt();" />
      <MemberSignature Language="F#" Value="abstract member ReadContentAsInt : unit -&gt; int&#xA;override this.ReadContentAsInt : unit -&gt; int" Usage="xmlReader.ReadContentAsInt " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>将当前位置的文本内容作为 32 位有符号整数读取。</summary>
        <returns>作为 32 位有符号整数的文本内容。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法将文本、 空白、 有效空白和 CDATA 部分中，连接，将跳过任何注释或处理指令。 实体引用来自动解决。  
  
 如果将内容类型`xsd:integer`，读取器返回未装箱的 32 位有符号的整数。 如果内容未类型化`xsd:integer`，读取器将尝试将其转换为 32 位有符号整数，根据定义的规则[W3C XML 架构第 2 部分： 数据类型](http://go.microsoft.com/fwlink/?LinkId=4871)建议。  
  
 下表描述了此方法将每个节点类型的处理。  
  
|XmlNodeType|返回值|读取器行为|  
|-----------------|------------------|---------------------|  
|`Text`<br /><br /> `CDATA`<br /><br /> `Whitespace`<br /><br /> `SignificantWhitespace`<br /><br /> `EntityReference`<br /><br /> `EndEntity`|将文本、CDATA、空白和有效空白节点的串联内容转换为所请求的类型。|移至下一个开始元素或结束元素标记。 实体引用自动展开。|  
|`Attribute`|与调用相同`XmlConvert.ToXxx`上属性值。|读取器仍保留在当前位置。|  
|`Comment`<br /><br /> `ProcessingInstruction`|忽略处理指令 (PI) 或注释，读取 PI 或注释后面的串联文本内容。|移至下一个开始元素或结束元素标记。 实体引用自动展开。|  
|`EndElement`|空字符串。|读取器仍保留在当前位置。|  
|`Element`<br /><br /> `XmlDeclaration`<br /><br /> `None`<br /><br /> `Document`<br /><br /> `DocumentType`<br /><br /> `Notation`<br /><br /> `Entity`<br /><br /> `DocumentFragment`|引发 <xref:System.InvalidOperationException>。|未定义，尽管通常读取器将保留在当前位置。|  
  
 有关详细信息，请参阅备注部分<xref:System.Xml.XmlReader>参考页和[W3C XML 架构第 2 部分： 数据类型](http://go.microsoft.com/fwlink/?LinkId=4871)建议。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidCastException">试图进行的强制转换无效。</exception>
        <exception cref="T:System.FormatException">该字符串格式无效。</exception>
        <exception cref="T:System.InvalidOperationException">在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadContentAsLong">
      <MemberSignature Language="C#" Value="public virtual long ReadContentAsLong ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int64 ReadContentAsLong() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadContentAsLong" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadContentAsLong () As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual long ReadContentAsLong();" />
      <MemberSignature Language="F#" Value="abstract member ReadContentAsLong : unit -&gt; int64&#xA;override this.ReadContentAsLong : unit -&gt; int64" Usage="xmlReader.ReadContentAsLong " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>将当前位置的文本内容作为 64 位有符号整数读取。</summary>
        <returns>作为 64 位有符号整数的文本内容。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法将文本、 空白、 有效空白和 CDATA 部分中，连接，将跳过任何注释或处理指令。 实体引用来自动解决。  
  
 如果将内容类型`xsd:long`，读取器返回未装箱的 64 位有符号的整数。 如果内容未类型化`xsd:long`，读取器将尝试将其转换为 64 位有符号整数，根据定义的规则[W3C XML 架构第 2 部分： 数据类型](http://go.microsoft.com/fwlink/?LinkId=4871)建议。  
  
 下表描述了此方法将每个节点类型。  
  
|XmlNodeType|返回值|读取器行为|  
|-----------------|------------------|---------------------|  
|`Text`<br /><br /> `CDATA`<br /><br /> `Whitespace`<br /><br /> `SignificantWhitespace`<br /><br /> `EntityReference`<br /><br /> `EndEntity`|将文本、CDATA、空白和有效空白节点的串联内容转换为所请求的类型。|移至下一个开始元素或结束元素标记。 实体引用自动展开。|  
|`Attribute`|与相同`XmlConvert.ToXxx`上属性值。|读取器将保留在当前位置|  
|`Comment`<br /><br /> `ProcessingInstruction`|忽略处理指令 (PI) 或注释，读取 PI 或注释后面的串联文本内容。|移至下一个开始元素或结束元素标记。 实体引用自动展开。|  
|`EndElement`|空字符串。|读取器仍保留在当前位置。|  
|`Element`<br /><br /> `XmlDeclaration`<br /><br /> `None`<br /><br /> `Document`<br /><br /> `DocumentType`<br /><br /> `Notation`<br /><br /> `Entity`<br /><br /> `DocumentFragment`|引发 <xref:System.InvalidOperationException>。|未定义，尽管通常读取器将保留在当前位置。|  
  
 有关详细信息，请参阅 <xref:System.Xml.XmlReader> 引用页的“备注”部分。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidCastException">试图进行的强制转换无效。</exception>
        <exception cref="T:System.FormatException">该字符串格式无效。</exception>
        <exception cref="T:System.InvalidOperationException">在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadContentAsObject">
      <MemberSignature Language="C#" Value="public virtual object ReadContentAsObject ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object ReadContentAsObject() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadContentAsObject" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadContentAsObject () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ ReadContentAsObject();" />
      <MemberSignature Language="F#" Value="abstract member ReadContentAsObject : unit -&gt; obj&#xA;override this.ReadContentAsObject : unit -&gt; obj" Usage="xmlReader.ReadContentAsObject " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>将当前位置的文本内容作为 <see cref="T:System.Object" /> 读取。</summary>
        <returns>作为最适当的公共语言运行时 (CLR) 对象的文本内容。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法将文本、 空白、 有效空白和 CDATA 部分中，连接，将跳过任何注释或处理指令。 实体引用来自动解决。  
  
 如果将内容类型，则读取器返回由指定的最适当类型的包装的 CLR<xref:System.Xml.XmlReader.ValueType%2A>属性。 如果内容为列表类型，读取器返回适当类型的装箱对象的数组。  
  
> [!NOTE]
>  如果在分析的内容时发生验证错误并将读取器<xref:System.Xml.XmlReader>对象创建的<xref:System.Xml.XmlReader.Create%2A>方法，则读取器返回作为字符串的内容。 换而言之验证错误或警告时，内容被视为非类型化。  
  
 如果内容未类型化，读取器将以字符串的形式返回内容。  
  
 下表描述了此方法将每个节点类型的处理。  
  
|XmlNodeType|返回值|读取器行为|  
|-----------------|------------------|---------------------|  
|`Text`<br /><br /> `CDATA`<br /><br /> `Whitespace`<br /><br /> `SignificantWhitespace`<br /><br /> `EntityReference`<br /><br /> `EndEntity`|将文本、CDATA、空白和有效空白节点的串联内容转换为所请求的类型。|移至下一个开始元素或结束元素标记。 实体引用自动展开。|  
|`Attribute`|与调用相同`XmlConvert.ToXxx`上属性值。|读取器将保留在当前位置|  
|`Comment`<br /><br /> `ProcessingInstruction`|忽略处理指令 (PI) 或注释，读取 PI 或注释后面的串联文本内容。|移至下一个开始元素或结束元素标记。 实体引用自动展开。|  
|`EndElement`|如果读取器为架构验证读取器的元素的值 (<xref:System.Xml.XmlReaderSettings.ValidationType%2A>设置为<xref:System.Xml.ValidationType.Schema>); 否则为空字符串。|读取器仍保留在当前位置。|  
|`Element`<br /><br /> `XmlDeclaration`<br /><br /> `None`<br /><br /> `Document`<br /><br /> `DocumentType`<br /><br /> `Notation`<br /><br /> `Entity`<br /><br /> `DocumentFragment`|引发 <xref:System.InvalidOperationException>。|未定义，尽管通常读取器将保留在当前位置。|  
  
 有关详细信息，请参阅备注部分<xref:System.Xml.XmlReader>参考页和[W3C XML 架构第 2 部分： 数据类型](http://go.microsoft.com/fwlink/?LinkId=4871)建议。  
  
 此方法的异步版本，请参阅<xref:System.Xml.XmlReader.ReadContentAsObjectAsync%2A>。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidCastException">试图进行的强制转换无效。</exception>
        <exception cref="T:System.FormatException">该字符串格式无效。</exception>
        <exception cref="T:System.InvalidOperationException">在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadContentAsObjectAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;object&gt; ReadContentAsObjectAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;object&gt; ReadContentAsObjectAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadContentAsObjectAsync" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadContentAsObjectAsync () As Task(Of Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task&lt;System::Object ^&gt; ^ ReadContentAsObjectAsync();" />
      <MemberSignature Language="F#" Value="abstract member ReadContentAsObjectAsync : unit -&gt; System.Threading.Tasks.Task&lt;obj&gt;&#xA;override this.ReadContentAsObjectAsync : unit -&gt; System.Threading.Tasks.Task&lt;obj&gt;" Usage="xmlReader.ReadContentAsObjectAsync " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.DebuggerStepThrough</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Object&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>将当前位置的文本内容作为 <see cref="T:System.Object" /> 对象异步读取。</summary>
        <returns>作为最适当的公共语言运行时 (CLR) 对象的文本内容。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 这是异步版本<xref:System.Xml.XmlReader.ReadContentAsObject%2A>，具有相同功能。 若要使用此方法，必须设置<xref:System.Xml.XmlReaderSettings.Async%2A>标记，用于`true`。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">调用了 <see cref="T:System.Xml.XmlReader" /> 异步方法，但未将 <see cref="P:System.Xml.XmlReaderSettings.Async" /> 标志设置为 <see langword="true" />。 在此情况下，将引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“若要使用 Async 方法，请将 XmlReaderSettings.Async 设置为 True。”</exception>
        <related type="Article" href="http://msdn.microsoft.com/library/db854f91-ccef-4035-ae4d-0911fde808c7">使用 Async 和 Await 的异步编程（C# 和 Visual Basic）</related>
      </Docs>
    </Member>
    <Member MemberName="ReadContentAsString">
      <MemberSignature Language="C#" Value="public virtual string ReadContentAsString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ReadContentAsString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadContentAsString" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadContentAsString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ReadContentAsString();" />
      <MemberSignature Language="F#" Value="abstract member ReadContentAsString : unit -&gt; string&#xA;override this.ReadContentAsString : unit -&gt; string" Usage="xmlReader.ReadContentAsString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>将当前位置的文本内容作为 <see cref="T:System.String" /> 对象读取。</summary>
        <returns>作为 <see cref="T:System.String" /> 对象的文本内容。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法将文本、 空白、 有效空白和 CDATA 部分中，连接，将跳过任何注释或处理指令。 实体引用来自动解决。  
  
 可以使用此方法将类型化的值转换为字符串，或跳过注释和处理指令时，读取的文本内容。  
  
 下表描述了此方法将每个节点类型的处理。  
  
|XmlNodeType|返回值|读取器行为|  
|-----------------|------------------|---------------------|  
|`Text`<br /><br /> `CDATA`<br /><br /> `Whitespace`<br /><br /> `SignificantWhitespace`<br /><br /> `EntityReference`<br /><br /> `EndEntity`|将文本、CDATA、空白和有效空白节点的串联内容转换为所请求的类型。|移至下一个开始元素或结束元素标记。 实体引用自动展开。|  
|`Attribute`|与调用相同`XmlConvert.ToXxx`上属性值。|读取器仍保留在当前位置。|  
|`Comment`<br /><br /> `ProcessingInstruction`|忽略处理指令 (PI) 或注释，读取 PI 或注释后面的串联文本内容。|移至下一个开始元素或结束元素标记。 实体引用自动展开。|  
|`EndElement`|空字符串。|读取器仍保留在当前位置。|  
|`Element`<br /><br /> `XmlDeclaration`<br /><br /> `None`<br /><br /> `Document`<br /><br /> `DocumentType`<br /><br /> `Notation`<br /><br /> `Entity`<br /><br /> `DocumentFragment`|引发 <xref:System.InvalidOperationException>。|未定义，尽管通常读取器将保留在当前位置。|  
  
 有关详细信息，请参阅备注部分<xref:System.Xml.XmlReader>参考页和[W3C XML 架构第 2 部分： 数据类型](http://go.microsoft.com/fwlink/?LinkId=4871)建议。  
  
 此方法的异步版本，请参阅<xref:System.Xml.XmlReader.ReadContentAsStringAsync%2A>。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidCastException">试图进行的强制转换无效。</exception>
        <exception cref="T:System.FormatException">该字符串格式无效。</exception>
        <exception cref="T:System.InvalidOperationException">在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadContentAsStringAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;string&gt; ReadContentAsStringAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;string&gt; ReadContentAsStringAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadContentAsStringAsync" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadContentAsStringAsync () As Task(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task&lt;System::String ^&gt; ^ ReadContentAsStringAsync();" />
      <MemberSignature Language="F#" Value="abstract member ReadContentAsStringAsync : unit -&gt; System.Threading.Tasks.Task&lt;string&gt;&#xA;override this.ReadContentAsStringAsync : unit -&gt; System.Threading.Tasks.Task&lt;string&gt;" Usage="xmlReader.ReadContentAsStringAsync " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>将当前位置的文本内容作为 <see cref="T:System.String" /> 对象异步读取。</summary>
        <returns>作为 <see cref="T:System.String" /> 对象的文本内容。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 这是异步版本<xref:System.Xml.XmlReader.ReadContentAsString%2A>，具有相同功能。 若要使用此方法，必须设置<xref:System.Xml.XmlReaderSettings.Async%2A>标记，用于`true`。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">调用了 <see cref="T:System.Xml.XmlReader" /> 异步方法，但未将 <see cref="P:System.Xml.XmlReaderSettings.Async" /> 标志设置为 <see langword="true" />。 在此情况下，将引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“若要使用 Async 方法，请将 XmlReaderSettings.Async 设置为 True。”</exception>
        <related type="Article" href="http://msdn.microsoft.com/library/db854f91-ccef-4035-ae4d-0911fde808c7">使用 Async 和 Await 的异步编程（C# 和 Visual Basic）</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadElementContentAs">
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <exception cref="T:System.InvalidOperationException">在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情况下，将引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中”。</exception>
        <summary>读取当前元素，并将内容作为指定类型的对象返回。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadElementContentAs">
      <MemberSignature Language="C#" Value="public virtual object ReadElementContentAs (Type returnType, System.Xml.IXmlNamespaceResolver namespaceResolver);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object ReadElementContentAs(class System.Type returnType, class System.Xml.IXmlNamespaceResolver namespaceResolver) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAs(System.Type,System.Xml.IXmlNamespaceResolver)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementContentAs (returnType As Type, namespaceResolver As IXmlNamespaceResolver) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ ReadElementContentAs(Type ^ returnType, System::Xml::IXmlNamespaceResolver ^ namespaceResolver);" />
      <MemberSignature Language="F#" Value="abstract member ReadElementContentAs : Type * System.Xml.IXmlNamespaceResolver -&gt; obj&#xA;override this.ReadElementContentAs : Type * System.Xml.IXmlNamespaceResolver -&gt; obj" Usage="xmlReader.ReadElementContentAs (returnType, namespaceResolver)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="namespaceResolver" Type="System.Xml.IXmlNamespaceResolver" />
      </Parameters>
      <Docs>
        <param name="returnType">要返回的值的类型。  
  
 **注意**：随着 .NET Framework 3.5 的发布，<c>returnType</c> 参数的值现在可以是 <see cref="T:System.DateTimeOffset" /> 类型。</param>
        <param name="namespaceResolver">一个 <see cref="T:System.Xml.IXmlNamespaceResolver" /> 对象，用于解析与类型转换有关的任何命名空间前缀。</param>
        <summary>将元素内容作为请求类型读取。</summary>
        <returns>转换为请求类型的对象的元素内容。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法读取开始标记，该元素的内容，并移过去的结束元素标记读取器。 扩展实体并将忽略处理指令和注释。 元素只能包含简单内容。 也就是说，它不能有子元素。  
  
 有关详细信息，请参阅备注部分<xref:System.Xml.XmlReader>参考页和[W3C XML 架构第 2 部分： 数据类型](http://go.microsoft.com/fwlink/?LinkId=4871)建议。  
  
 此方法的异步版本，请参阅<xref:System.Xml.XmlReader.ReadElementContentAsAsync%2A>。  
  
   
  
## Examples  
 下面的示例使用<xref:System.Xml.XmlReader.ReadElementContentAs%2A>方法来读取的内容`date`节点。  
  
 [!code-csharp[XmlReader.ReadElementContentAs#5](~/samples/snippets/csharp/VS_Snippets_Data/XmlReader.ReadElementContentAs/CS/readElementContentAs.cs#5)]
 [!code-vb[XmlReader.ReadElementContentAs#5](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReader.ReadElementContentAs/VB/readElementContentAs.vb#5)]  
  
 示例使用 `dataFile.xml` 文件作为输入。  
  
 [!code-xml[XmlReader.ReadElementContentAs#8](~/samples/snippets/xml/VS_Snippets_Data/XmlReader.ReadElementContentAs/XML/dataFile.xml#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”</exception>
        <exception cref="T:System.Xml.XmlException">当前元素包含子元素。  
  
或 
无法将元素内容转换成请求的类型。</exception>
        <exception cref="T:System.ArgumentNullException">使用 <see langword="null" /> 参数调用此方法。</exception>
        <exception cref="T:System.OverflowException">读取 <see langword="Decimal.MaxValue" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadElementContentAs">
      <MemberSignature Language="C#" Value="public virtual object ReadElementContentAs (Type returnType, System.Xml.IXmlNamespaceResolver namespaceResolver, string localName, string namespaceURI);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object ReadElementContentAs(class System.Type returnType, class System.Xml.IXmlNamespaceResolver namespaceResolver, string localName, string namespaceURI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAs(System.Type,System.Xml.IXmlNamespaceResolver,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementContentAs (returnType As Type, namespaceResolver As IXmlNamespaceResolver, localName As String, namespaceURI As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ ReadElementContentAs(Type ^ returnType, System::Xml::IXmlNamespaceResolver ^ namespaceResolver, System::String ^ localName, System::String ^ namespaceURI);" />
      <MemberSignature Language="F#" Value="abstract member ReadElementContentAs : Type * System.Xml.IXmlNamespaceResolver * string * string -&gt; obj&#xA;override this.ReadElementContentAs : Type * System.Xml.IXmlNamespaceResolver * string * string -&gt; obj" Usage="xmlReader.ReadElementContentAs (returnType, namespaceResolver, localName, namespaceURI)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="namespaceResolver" Type="System.Xml.IXmlNamespaceResolver" />
        <Parameter Name="localName" Type="System.String" />
        <Parameter Name="namespaceURI" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="returnType">要返回的值的类型。  
  
 **注意**：随着 .NET Framework 3.5 的发布，<c>returnType</c> 参数的值现在可以是 <see cref="T:System.DateTimeOffset" /> 类型。</param>
        <param name="namespaceResolver">一个 <see cref="T:System.Xml.IXmlNamespaceResolver" /> 对象，用于解析与类型转换有关的任何命名空间前缀。</param>
        <param name="localName">元素的本地名称。</param>
        <param name="namespaceURI">元素的命名空间 URI。</param>
        <summary>检查指定的本地名称和命名空间 URI 与当前元素的本地名称和命名空间 URI 是否匹配，然后将元素内容作为请求类型读取。</summary>
        <returns>转换为请求类型的对象的元素内容。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法读取开始标记，该元素的内容，并移过去的结束元素标记读取器。 扩展实体并将忽略处理指令和注释。 元素只能包含简单内容。 也就是说，它不能有子元素。  
  
 有关详细信息，请参阅备注部分<xref:System.Xml.XmlReader>参考页和[W3C XML 架构第 2 部分： 数据类型](http://go.microsoft.com/fwlink/?LinkId=4871)建议。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”</exception>
        <exception cref="T:System.Xml.XmlException">当前元素包含子元素。  
  
或 
无法将元素内容转换成请求的类型。</exception>
        <exception cref="T:System.ArgumentNullException">使用 <see langword="null" /> 参数调用此方法。</exception>
        <exception cref="T:System.ArgumentException">指定的本地名称和命名空间 URI 与所读取的当前元素的本地名称和命名空间 URI 不匹配。</exception>
        <exception cref="T:System.OverflowException">读取 <see langword="Decimal.MaxValue" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadElementContentAsAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;object&gt; ReadElementContentAsAsync (Type returnType, System.Xml.IXmlNamespaceResolver namespaceResolver);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;object&gt; ReadElementContentAsAsync(class System.Type returnType, class System.Xml.IXmlNamespaceResolver namespaceResolver) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsAsync(System.Type,System.Xml.IXmlNamespaceResolver)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementContentAsAsync (returnType As Type, namespaceResolver As IXmlNamespaceResolver) As Task(Of Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task&lt;System::Object ^&gt; ^ ReadElementContentAsAsync(Type ^ returnType, System::Xml::IXmlNamespaceResolver ^ namespaceResolver);" />
      <MemberSignature Language="F#" Value="abstract member ReadElementContentAsAsync : Type * System.Xml.IXmlNamespaceResolver -&gt; System.Threading.Tasks.Task&lt;obj&gt;&#xA;override this.ReadElementContentAsAsync : Type * System.Xml.IXmlNamespaceResolver -&gt; System.Threading.Tasks.Task&lt;obj&gt;" Usage="xmlReader.ReadElementContentAsAsync (returnType, namespaceResolver)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.DebuggerStepThrough</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Object&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="namespaceResolver" Type="System.Xml.IXmlNamespaceResolver" />
      </Parameters>
      <Docs>
        <param name="returnType">要返回的值的类型。</param>
        <param name="namespaceResolver">一个 <see cref="T:System.Xml.IXmlNamespaceResolver" /> 对象，用于解析与类型转换有关的任何命名空间前缀。</param>
        <summary>将元素内容作为请求类型异步读取。</summary>
        <returns>转换为请求类型的对象的元素内容。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 这是异步版本<xref:System.Xml.XmlReader.ReadElementContentAs%2A>，具有相同功能。 若要使用此方法，必须设置<xref:System.Xml.XmlReaderSettings.Async%2A>标记，用于`true`。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">调用了 <see cref="T:System.Xml.XmlReader" /> 异步方法，但未将 <see cref="P:System.Xml.XmlReaderSettings.Async" /> 标志设置为 <see langword="true" />。 在此情况下，将引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“若要使用 Async 方法，请将 XmlReaderSettings.Async 设置为 True。”</exception>
        <related type="Article" href="http://msdn.microsoft.com/library/db854f91-ccef-4035-ae4d-0911fde808c7">使用 Async 和 Await 的异步编程（C# 和 Visual Basic）</related>
      </Docs>
    </Member>
    <Member MemberName="ReadElementContentAsBase64">
      <MemberSignature Language="C#" Value="public virtual int ReadElementContentAsBase64 (byte[] buffer, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 ReadElementContentAsBase64(unsigned int8[] buffer, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsBase64(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementContentAsBase64 (buffer As Byte(), index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int ReadElementContentAsBase64(cli::array &lt;System::Byte&gt; ^ buffer, int index, int count);" />
      <MemberSignature Language="F#" Value="abstract member ReadElementContentAsBase64 : byte[] * int * int -&gt; int&#xA;override this.ReadElementContentAsBase64 : byte[] * int * int -&gt; int" Usage="xmlReader.ReadElementContentAsBase64 (buffer, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">结果文本复制到的缓冲区。 此值不能为 <see langword="null" />。</param>
        <param name="index">缓冲区中的偏移，从这个位置开始将结果复制到缓冲区中。</param>
        <param name="count">要复制到缓冲区的最大字节数。 此方法返回复制的实际字节数。</param>
        <summary>读取元素并对 <see langword="Base64" /> 内容进行解码。</summary>
        <returns>写入缓冲区的字节数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法读取元素内容中，将使用其解码`Base64`编码，并返回已解码的二进制字节 (例如，内联`Base64`-编码的 GIF 图像) 到缓冲区。 有关详细信息，请参阅 RFC 1521"MIME （多用途 Internet 邮件扩展） 部分一个： 用于指定和 Internet 消息正文的格式描述机制"。 您可以获得从 Rfc[征求意见文档网站](http://go.microsoft.com/fwlink/?LinkId=37119)。  
  
 <xref:System.Xml.XmlReader.ReadElementContentAsBase64%2A> 可仅读取简单内容的元素。 元素可以包含文本、 空白、 有效空白、 CDATA 节、 注释和处理指令。 它还可以包含实体引用，会自动扩展。 元素不能具有子元素。  
  
 此方法是非常类似于<xref:System.Xml.XmlReader.ReadContentAsBase64%2A>方法，但它只能在元素节点类型上调用。  
  
 如果`count`值高于在文档中的字节数是否等于在文档中的字节数或<xref:System.Xml.XmlReader>读取该文档中的所有剩余字节，并返回读取的字节数。 下一步<xref:System.Xml.XmlReader>方法调用会返回 0 并将读取器移动到节点以下`EndElement`。  
  
 如果您调用<xref:System.Xml.XmlReader.Read%2A>的所有元素内容使用之前，读取器的行为类似于第一个内容，然后<xref:System.Xml.XmlReader.Read%2A>调用方法。 这意味着读取器将读取所有文本，直到遇到结束元素。 然后它将阅读结束标记节点、 读取下一个节点，并最后将自身定位到下一个后续节点。  
  
 此方法的异步版本，请参阅<xref:System.Xml.XmlReader.ReadElementContentAsBase64Async%2A>。  
  
   
  
## Examples  
 下面的示例读取一个内联`Base64`编码的图像。 `Base64`内嵌入数据`<image>`元素。 一个<xref:System.IO.BinaryWriter>用于创建新的二进制数据文件。  
  
 [!code-csharp[XmlReader_Read_Write_Binary#4](~/samples/snippets/csharp/VS_Snippets_Data/XmlReader_Read_Write_Binary/CS/readBinary.cs#4)]
 [!code-vb[XmlReader_Read_Write_Binary#4](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReader_Read_Write_Binary/VB/readBinary.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> 值为 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">缓冲区中的索引或者索引与计数之和大于分配的缓冲区大小。</exception>
        <exception cref="T:System.NotSupportedException">
          <see cref="T:System.Xml.XmlReader" /> 实现不支持此方法。</exception>
        <exception cref="T:System.Xml.XmlException">该元素包含混合内容。</exception>
        <exception cref="T:System.FormatException">无法将内容转换成请求的类型。</exception>
        <altmember cref="M:System.Xml.XmlReader.ReadContentAsBase64(System.Byte[],System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="ReadElementContentAsBase64Async">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;int&gt; ReadElementContentAsBase64Async (byte[] buffer, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;int32&gt; ReadElementContentAsBase64Async(unsigned int8[] buffer, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsBase64Async(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementContentAsBase64Async (buffer As Byte(), index As Integer, count As Integer) As Task(Of Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task&lt;int&gt; ^ ReadElementContentAsBase64Async(cli::array &lt;System::Byte&gt; ^ buffer, int index, int count);" />
      <MemberSignature Language="F#" Value="abstract member ReadElementContentAsBase64Async : byte[] * int * int -&gt; System.Threading.Tasks.Task&lt;int&gt;&#xA;override this.ReadElementContentAsBase64Async : byte[] * int * int -&gt; System.Threading.Tasks.Task&lt;int&gt;" Usage="xmlReader.ReadElementContentAsBase64Async (buffer, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">结果文本复制到的缓冲区。 此值不能为 <see langword="null" />。</param>
        <param name="index">缓冲区中的偏移，从这个位置开始将结果复制到缓冲区中。</param>
        <param name="count">要复制到缓冲区的最大字节数。 此方法返回复制的实际字节数。</param>
        <summary>异步读取元素并对 <see langword="Base64" /> 内容进行解码。</summary>
        <returns>写入缓冲区的字节数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 这是异步版本<xref:System.Xml.XmlReader.ReadElementContentAsBase64%2A>，具有相同功能。 若要使用此方法，必须设置<xref:System.Xml.XmlReaderSettings.Async%2A>标记，用于`true`。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">调用了 <see cref="T:System.Xml.XmlReader" /> 异步方法，但未将 <see cref="P:System.Xml.XmlReaderSettings.Async" /> 标志设置为 <see langword="true" />。 在此情况下，将引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“若要使用 Async 方法，请将 XmlReaderSettings.Async 设置为 True。”</exception>
        <related type="Article" href="http://msdn.microsoft.com/library/db854f91-ccef-4035-ae4d-0911fde808c7">使用 Async 和 Await 的异步编程（C# 和 Visual Basic）</related>
      </Docs>
    </Member>
    <Member MemberName="ReadElementContentAsBinHex">
      <MemberSignature Language="C#" Value="public virtual int ReadElementContentAsBinHex (byte[] buffer, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 ReadElementContentAsBinHex(unsigned int8[] buffer, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsBinHex(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementContentAsBinHex (buffer As Byte(), index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int ReadElementContentAsBinHex(cli::array &lt;System::Byte&gt; ^ buffer, int index, int count);" />
      <MemberSignature Language="F#" Value="abstract member ReadElementContentAsBinHex : byte[] * int * int -&gt; int&#xA;override this.ReadElementContentAsBinHex : byte[] * int * int -&gt; int" Usage="xmlReader.ReadElementContentAsBinHex (buffer, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">结果文本复制到的缓冲区。 此值不能为 <see langword="null" />。</param>
        <param name="index">缓冲区中的偏移，从这个位置开始将结果复制到缓冲区中。</param>
        <param name="count">要复制到缓冲区的最大字节数。 此方法返回复制的实际字节数。</param>
        <summary>读取元素并对 <see langword="BinHex" /> 内容进行解码。</summary>
        <returns>写入缓冲区的字节数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法读取元素内容中，将使用其解码`BinHex`编码，并返回已解码的二进制字节 (例如，内联`BinHex`-编码的 GIF 图像) 到缓冲区。  
  
 此方法只能读取简单内容元素。 元素可以包含文本、 空白、 有效空白、 CDATA 节、 注释和处理指令。 它还可以包含实体引用，会自动扩展。 元素不能具有子元素。  
  
 此方法是非常类似于<xref:System.Xml.XmlReader.ReadContentAsBinHex%2A>方法，但它只能在元素节点类型上调用。  
  
 如果`count`值高于在文档中的字节数是否等于在文档中的字节数或<xref:System.Xml.XmlReader>读取该文档中的所有剩余字节，并返回读取的字节数。 下一步<xref:System.Xml.XmlReader>方法调用会返回 0 并将读取器移动到节点以下`EndElement`。  
  
 如果您调用<xref:System.Xml.XmlReader.Read%2A>的所有元素内容使用之前，读取器的行为类似于第一个内容，然后<xref:System.Xml.XmlReader.Read%2A>调用方法。 这意味着读取器将读取所有文本，直到遇到结束元素。 然后它将阅读结束标记节点、 读取下一个节点，并最后将自身定位到下一个后续节点。  
  
 此方法的异步版本，请参阅<xref:System.Xml.XmlReader.ReadElementContentAsBinHexAsync%2A>。  
  
   
  
## Examples  
 下面的示例读取一个内联`BinHex`编码的图像。 `BinHex`内嵌入数据`<image>`元素。 一个<xref:System.IO.BinaryWriter>用于创建新的二进制数据文件。  
  
 [!code-csharp[XmlReader_Read_Write_Binary#2](~/samples/snippets/csharp/VS_Snippets_Data/XmlReader_Read_Write_Binary/CS/readBinary.cs#2)]
 [!code-vb[XmlReader_Read_Write_Binary#2](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReader_Read_Write_Binary/VB/readBinary.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> 值为 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">缓冲区中的索引或者索引与计数之和大于分配的缓冲区大小。</exception>
        <exception cref="T:System.NotSupportedException">
          <see cref="T:System.Xml.XmlReader" /> 实现不支持此方法。</exception>
        <exception cref="T:System.Xml.XmlException">该元素包含混合内容。</exception>
        <exception cref="T:System.FormatException">无法将内容转换成请求的类型。</exception>
        <altmember cref="M:System.Xml.XmlReader.ReadContentAsBinHex(System.Byte[],System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="ReadElementContentAsBinHexAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;int&gt; ReadElementContentAsBinHexAsync (byte[] buffer, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;int32&gt; ReadElementContentAsBinHexAsync(unsigned int8[] buffer, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsBinHexAsync(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementContentAsBinHexAsync (buffer As Byte(), index As Integer, count As Integer) As Task(Of Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task&lt;int&gt; ^ ReadElementContentAsBinHexAsync(cli::array &lt;System::Byte&gt; ^ buffer, int index, int count);" />
      <MemberSignature Language="F#" Value="abstract member ReadElementContentAsBinHexAsync : byte[] * int * int -&gt; System.Threading.Tasks.Task&lt;int&gt;&#xA;override this.ReadElementContentAsBinHexAsync : byte[] * int * int -&gt; System.Threading.Tasks.Task&lt;int&gt;" Usage="xmlReader.ReadElementContentAsBinHexAsync (buffer, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">结果文本复制到的缓冲区。 此值不能为 <see langword="null" />。</param>
        <param name="index">缓冲区中的偏移，从这个位置开始将结果复制到缓冲区中。</param>
        <param name="count">要复制到缓冲区的最大字节数。 此方法返回复制的实际字节数。</param>
        <summary>异步读取元素并对 <see langword="BinHex" /> 内容进行解码。</summary>
        <returns>写入缓冲区的字节数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 这是异步版本<xref:System.Xml.XmlReader.ReadElementContentAsBinHex%2A>，具有相同功能。 若要使用此方法，必须设置<xref:System.Xml.XmlReaderSettings.Async%2A>标记，用于`true`。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">调用了 <see cref="T:System.Xml.XmlReader" /> 异步方法，但未将 <see cref="P:System.Xml.XmlReaderSettings.Async" /> 标志设置为 <see langword="true" />。 在此情况下，将引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“若要使用 Async 方法，请将 XmlReaderSettings.Async 设置为 True。”</exception>
        <related type="Article" href="http://msdn.microsoft.com/library/db854f91-ccef-4035-ae4d-0911fde808c7">使用 Async 和 Await 的异步编程（C# 和 Visual Basic）</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadElementContentAsBoolean">
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <exception cref="T:System.InvalidOperationException">在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情况下，将引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中”。</exception>
        <summary>将当前元素值作为 <see cref="T:System.Boolean" /> 对象读取。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadElementContentAsBoolean">
      <MemberSignature Language="C#" Value="public virtual bool ReadElementContentAsBoolean ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool ReadElementContentAsBoolean() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsBoolean" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementContentAsBoolean () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool ReadElementContentAsBoolean();" />
      <MemberSignature Language="F#" Value="abstract member ReadElementContentAsBoolean : unit -&gt; bool&#xA;override this.ReadElementContentAsBoolean : unit -&gt; bool" Usage="xmlReader.ReadElementContentAsBoolean " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>读取当前元素并将内容作为 <see cref="T:System.Boolean" /> 对象返回。</summary>
        <returns>作为 <see cref="T:System.Boolean" /> 对象的元素内容。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法读取开始标记，该元素的内容，并移过去的结束元素标记读取器。 扩展实体并将忽略处理指令和注释。 元素只能包含简单内容。 也就是说，它不能有子元素。  
  
 如果元素内容的类型`xsd:boolean`，则读取器返回取消装箱<xref:System.Boolean>对象。 如果内容未类型化`xsd:boolean`，读取器将尝试将其转换为<xref:System.Boolean>根据定义的规则对象[W3C XML 架构第 2 部分： 数据类型](http://go.microsoft.com/fwlink/?LinkId=4871)建议。  
  
 有关详细信息，请参阅 <xref:System.Xml.XmlReader> 引用页的“备注”部分。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”</exception>
        <exception cref="T:System.Xml.XmlException">当前元素包含子元素。  
  
或 
无法将元素内容转换为 <see cref="T:System.Boolean" /> 对象。</exception>
        <exception cref="T:System.ArgumentNullException">使用 <see langword="null" /> 参数调用此方法。</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadElementContentAsBoolean">
      <MemberSignature Language="C#" Value="public virtual bool ReadElementContentAsBoolean (string localName, string namespaceURI);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool ReadElementContentAsBoolean(string localName, string namespaceURI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsBoolean(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementContentAsBoolean (localName As String, namespaceURI As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool ReadElementContentAsBoolean(System::String ^ localName, System::String ^ namespaceURI);" />
      <MemberSignature Language="F#" Value="abstract member ReadElementContentAsBoolean : string * string -&gt; bool&#xA;override this.ReadElementContentAsBoolean : string * string -&gt; bool" Usage="xmlReader.ReadElementContentAsBoolean (localName, namespaceURI)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="localName" Type="System.String" />
        <Parameter Name="namespaceURI" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="localName">元素的本地名称。</param>
        <param name="namespaceURI">元素的命名空间 URI。</param>
        <summary>检查指定的本地名称和命名空间 URI 与当前元素的本地名称和命名空间 URI 是否匹配，然后读取当前元素，并将内容作为 <see cref="T:System.Boolean" /> 对象返回。</summary>
        <returns>作为 <see cref="T:System.Boolean" /> 对象的元素内容。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法读取开始标记，该元素的内容，并移过去的结束元素标记读取器。 扩展实体并将忽略处理指令和注释。 元素只能包含简单内容。 也就是说，它不能有子元素。  
  
 如果将内容类型`xsd:boolean`，则读取器返回取消装箱<xref:System.Boolean>对象。 如果内容未类型化`xsd:boolean`，读取器将尝试将其转换为<xref:System.Boolean>根据定义的规则对象[W3C XML 架构第 2 部分： 数据类型](http://go.microsoft.com/fwlink/?LinkId=4871)建议。  
  
 有关详细信息，请参阅 <xref:System.Xml.XmlReader> 引用页的“备注”部分。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”</exception>
        <exception cref="T:System.Xml.XmlException">当前元素包含子元素。  
  
或 
无法将元素内容转换成请求的类型。</exception>
        <exception cref="T:System.ArgumentNullException">使用 <see langword="null" /> 参数调用此方法。</exception>
        <exception cref="T:System.ArgumentException">指定的本地名称和命名空间 URI 与所读取的当前元素的本地名称和命名空间 URI 不匹配。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadElementContentAsDateTime">
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <exception cref="T:System.InvalidOperationException">在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情况下，将引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中”。</exception>
        <summary>读取当前元素并将内容作为 <see cref="T:System.DateTime" /> 对象返回。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadElementContentAsDateTime">
      <MemberSignature Language="C#" Value="public virtual DateTime ReadElementContentAsDateTime ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.DateTime ReadElementContentAsDateTime() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsDateTime" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementContentAsDateTime () As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual DateTime ReadElementContentAsDateTime();" />
      <MemberSignature Language="F#" Value="abstract member ReadElementContentAsDateTime : unit -&gt; DateTime&#xA;override this.ReadElementContentAsDateTime : unit -&gt; DateTime" Usage="xmlReader.ReadElementContentAsDateTime " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>读取当前元素并将内容作为 <see cref="T:System.DateTime" /> 对象返回。</summary>
        <returns>作为 <see cref="T:System.DateTime" /> 对象的元素内容。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法读取开始标记，该元素的内容，并移过去的结束元素标记读取器。 扩展实体并将忽略处理指令和注释。 元素只能包含简单内容。 也就是说，它不能有子元素。  
  
 如果将内容类型`xsd:dateTime`，则读取器返回取消装箱<xref:System.DateTime>对象。 如果内容未类型化`xsd:dateTime`，读取器将尝试将其转换为<xref:System.DateTime>根据定义的规则对象[W3C XML 架构第 2 部分： 数据类型](http://go.microsoft.com/fwlink/?LinkId=4871)建议。  
  
> [!NOTE]
>  如果内容类型化为 <xref:System.DateTime.Year%2A?displayProperty=nameWithType>，则不能使用 `xsd:gMonthDay` 值。 <xref:System.Xml.XmlReader> 始终设置<xref:System.DateTime.Year%2A?displayProperty=nameWithType>这种情况下值为 1904年。  
  
 有关详细信息，请参阅 <xref:System.Xml.XmlReader> 引用页的“备注”部分。  
  
   
  
## Examples  
 下面的示例使用<xref:System.Xml.XmlReader.ReadElementContentAsDateTime%2A>方法来读取的内容`date`元素。  
  
 [!code-csharp[XmlReader.ReadElementContentAs#4](~/samples/snippets/csharp/VS_Snippets_Data/XmlReader.ReadElementContentAs/CS/readElementContentAs.cs#4)]
 [!code-vb[XmlReader.ReadElementContentAs#4](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReader.ReadElementContentAs/VB/readElementContentAs.vb#4)]  
  
 示例使用 `dataFile.xml` 文件作为输入。  
  
 [!code-xml[XmlReader.ReadElementContentAs#8](~/samples/snippets/xml/VS_Snippets_Data/XmlReader.ReadElementContentAs/XML/dataFile.xml#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”</exception>
        <exception cref="T:System.Xml.XmlException">当前元素包含子元素。  
  
或 
无法将元素内容转换为 <see cref="T:System.DateTime" /> 对象。</exception>
        <exception cref="T:System.ArgumentNullException">使用 <see langword="null" /> 参数调用此方法。</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadElementContentAsDateTime">
      <MemberSignature Language="C#" Value="public virtual DateTime ReadElementContentAsDateTime (string localName, string namespaceURI);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.DateTime ReadElementContentAsDateTime(string localName, string namespaceURI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsDateTime(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementContentAsDateTime (localName As String, namespaceURI As String) As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual DateTime ReadElementContentAsDateTime(System::String ^ localName, System::String ^ namespaceURI);" />
      <MemberSignature Language="F#" Value="abstract member ReadElementContentAsDateTime : string * string -&gt; DateTime&#xA;override this.ReadElementContentAsDateTime : string * string -&gt; DateTime" Usage="xmlReader.ReadElementContentAsDateTime (localName, namespaceURI)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="localName" Type="System.String" />
        <Parameter Name="namespaceURI" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="localName">元素的本地名称。</param>
        <param name="namespaceURI">元素的命名空间 URI。</param>
        <summary>检查指定的本地名称和命名空间 URI 与当前元素的本地名称和命名空间 URI 是否匹配，然后读取当前元素，并将内容作为 <see cref="T:System.DateTime" /> 对象返回。</summary>
        <returns>作为 <see cref="T:System.DateTime" /> 对象的元素内容。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法读取开始标记，该元素的内容，并移过去的结束元素标记读取器。 扩展实体并将忽略处理指令和注释。 元素只能包含简单内容。 也就是说，它不能有子元素。  
  
 如果将内容类型`xsd:dateTime`，则读取器返回取消装箱<xref:System.DateTime>对象。 如果内容未类型化`xsd:dateTime`，读取器将尝试将其转换为<xref:System.DateTime>根据定义的规则对象[W3C XML 架构第 2 部分： 数据类型](http://go.microsoft.com/fwlink/?LinkId=4871)建议。  
  
> [!NOTE]
>  如果内容类型化为 <xref:System.DateTime.Year%2A?displayProperty=nameWithType>，则不能使用 `xsd:gMonthDay` 值。 <xref:System.Xml.XmlReader> 始终设置<xref:System.DateTime.Year%2A?displayProperty=nameWithType>这种情况下值为 1904年。  
  
 有关详细信息，请参阅 <xref:System.Xml.XmlReader> 引用页的“备注”部分。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”</exception>
        <exception cref="T:System.Xml.XmlException">当前元素包含子元素。  
  
或 
无法将元素内容转换成请求的类型。</exception>
        <exception cref="T:System.ArgumentNullException">使用 <see langword="null" /> 参数调用此方法。</exception>
        <exception cref="T:System.ArgumentException">指定的本地名称和命名空间 URI 与所读取的当前元素的本地名称和命名空间 URI 不匹配。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadElementContentAsDecimal">
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <exception cref="T:System.InvalidOperationException">在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情况下，将引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中”。</exception>
        <summary>将当前元素值作为 <see cref="T:System.Decimal" /> 对象读取。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadElementContentAsDecimal">
      <MemberSignature Language="C#" Value="public virtual decimal ReadElementContentAsDecimal ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Decimal ReadElementContentAsDecimal() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsDecimal" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementContentAsDecimal () As Decimal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Decimal ReadElementContentAsDecimal();" />
      <MemberSignature Language="F#" Value="abstract member ReadElementContentAsDecimal : unit -&gt; decimal&#xA;override this.ReadElementContentAsDecimal : unit -&gt; decimal" Usage="xmlReader.ReadElementContentAsDecimal " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>读取当前元素并将内容作为 <see cref="T:System.Decimal" /> 对象返回。</summary>
        <returns>作为 <see cref="T:System.Decimal" /> 对象的元素内容。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法读取开始标记，该元素的内容，并移过去的结束元素标记读取器。 扩展实体并将忽略处理指令和注释。 元素只能包含简单内容。 也就是说，它不能有子元素。  
  
 读取器将尝试将元素内容转换<xref:System.Decimal>根据定义的规则的对象[W3C XML 架构第 2 部分： 数据类型](http://go.microsoft.com/fwlink/?LinkId=4871)建议。  
  
 有关详细信息，请参阅 <xref:System.Xml.XmlReader> 引用页的“备注”部分。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”</exception>
        <exception cref="T:System.Xml.XmlException">当前元素包含子元素。  
  
或 
无法将元素内容转换为 <see cref="T:System.Decimal" />。</exception>
        <exception cref="T:System.ArgumentNullException">使用 <see langword="null" /> 参数调用此方法。</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadElementContentAsDecimal">
      <MemberSignature Language="C#" Value="public virtual decimal ReadElementContentAsDecimal (string localName, string namespaceURI);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Decimal ReadElementContentAsDecimal(string localName, string namespaceURI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsDecimal(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementContentAsDecimal (localName As String, namespaceURI As String) As Decimal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Decimal ReadElementContentAsDecimal(System::String ^ localName, System::String ^ namespaceURI);" />
      <MemberSignature Language="F#" Value="abstract member ReadElementContentAsDecimal : string * string -&gt; decimal&#xA;override this.ReadElementContentAsDecimal : string * string -&gt; decimal" Usage="xmlReader.ReadElementContentAsDecimal (localName, namespaceURI)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="localName" Type="System.String" />
        <Parameter Name="namespaceURI" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="localName">元素的本地名称。</param>
        <param name="namespaceURI">元素的命名空间 URI。</param>
        <summary>检查指定的本地名称和命名空间 URI 与当前元素的本地名称和命名空间 URI 是否匹配，然后读取当前元素，并将内容作为 <see cref="T:System.Decimal" /> 对象返回。</summary>
        <returns>作为 <see cref="T:System.Decimal" /> 对象的元素内容。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法读取开始标记，该元素的内容，并移过去的结束元素标记读取器。 扩展实体并将忽略处理指令和注释。 元素只能包含简单内容。 也就是说，它不能有子元素。  
  
 读取器将尝试将元素内容转换<xref:System.Decimal>根据定义的规则的对象[W3C XML 架构第 2 部分： 数据类型](http://go.microsoft.com/fwlink/?LinkId=4871)建议。  
  
 有关详细信息，请参阅 <xref:System.Xml.XmlReader> 引用页的“备注”部分。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”</exception>
        <exception cref="T:System.Xml.XmlException">当前元素包含子元素。  
  
或 
无法将元素内容转换为 <see cref="T:System.Decimal" />。</exception>
        <exception cref="T:System.ArgumentNullException">使用 <see langword="null" /> 参数调用此方法。</exception>
        <exception cref="T:System.ArgumentException">指定的本地名称和命名空间 URI 与所读取的当前元素的本地名称和命名空间 URI 不匹配。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadElementContentAsDouble">
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <exception cref="T:System.InvalidOperationException">在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情况下，将引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中”。</exception>
        <summary>读取当前元素并将内容作为双精度浮点数返回。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadElementContentAsDouble">
      <MemberSignature Language="C#" Value="public virtual double ReadElementContentAsDouble ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance float64 ReadElementContentAsDouble() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsDouble" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementContentAsDouble () As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual double ReadElementContentAsDouble();" />
      <MemberSignature Language="F#" Value="abstract member ReadElementContentAsDouble : unit -&gt; double&#xA;override this.ReadElementContentAsDouble : unit -&gt; double" Usage="xmlReader.ReadElementContentAsDouble " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>读取当前元素并将内容作为双精度浮点数返回。</summary>
        <returns>作为双精度浮点数的元素内容。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法读取开始标记，该元素的内容，并移过去的结束元素标记读取器。 扩展实体并将忽略处理指令和注释。 元素只能包含简单内容。 也就是说，它不能有子元素。  
  
 如果将内容类型`xsd:double`，读取器返回一个双精度浮点数。 如果内容未类型化`xsd:double`，读取器将尝试将其转换为根据定义的规则的双精度浮点数[W3C XML 架构第 2 部分： 数据类型](http://go.microsoft.com/fwlink/?LinkId=4871)建议。  
  
 有关详细信息，请参阅 <xref:System.Xml.XmlReader> 引用页的“备注”部分。  
  
   
  
## Examples  
 下面的示例使用方法返回的元素内容作为双精度浮点数。  
  
 [!code-csharp[XmlReader.ReadElementContentAs#7](~/samples/snippets/csharp/VS_Snippets_Data/XmlReader.ReadElementContentAs/CS/readElementContentAs.cs#7)]
 [!code-vb[XmlReader.ReadElementContentAs#7](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReader.ReadElementContentAs/VB/readElementContentAs.vb#7)]  
  
 示例使用 `dataFile.xml` 文件作为输入。  
  
 [!code-xml[XmlReader.ReadElementContentAs#8](~/samples/snippets/xml/VS_Snippets_Data/XmlReader.ReadElementContentAs/XML/dataFile.xml#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”</exception>
        <exception cref="T:System.Xml.XmlException">当前元素包含子元素。  
  
或 
无法将元素内容转换为双精度浮点数。</exception>
        <exception cref="T:System.ArgumentNullException">使用 <see langword="null" /> 参数调用此方法。</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadElementContentAsDouble">
      <MemberSignature Language="C#" Value="public virtual double ReadElementContentAsDouble (string localName, string namespaceURI);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance float64 ReadElementContentAsDouble(string localName, string namespaceURI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsDouble(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementContentAsDouble (localName As String, namespaceURI As String) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual double ReadElementContentAsDouble(System::String ^ localName, System::String ^ namespaceURI);" />
      <MemberSignature Language="F#" Value="abstract member ReadElementContentAsDouble : string * string -&gt; double&#xA;override this.ReadElementContentAsDouble : string * string -&gt; double" Usage="xmlReader.ReadElementContentAsDouble (localName, namespaceURI)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="localName" Type="System.String" />
        <Parameter Name="namespaceURI" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="localName">元素的本地名称。</param>
        <param name="namespaceURI">元素的命名空间 URI。</param>
        <summary>检查指定的本地名称和命名空间 URI 与当前元素的本地名称和命名空间 URI 是否匹配，然后读取当前元素，并将内容作为双精度浮点数返回。</summary>
        <returns>作为双精度浮点数的元素内容。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法读取开始标记，该元素的内容，并移过去的结束元素标记读取器。 扩展实体并将忽略处理指令和注释。 元素只能包含简单内容。 也就是说，它不能有子元素。  
  
 如果将内容类型`xsd:double`，读取器返回一个双精度浮点数。 如果内容未类型化`xsd:double`，读取器将尝试将其转换为根据定义的规则的双精度浮点数[W3C XML 架构第 2 部分： 数据类型](http://go.microsoft.com/fwlink/?LinkId=4871)建议。  
  
 有关详细信息，请参阅 <xref:System.Xml.XmlReader> 引用页的“备注”部分。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”</exception>
        <exception cref="T:System.Xml.XmlException">当前元素包含子元素。  
  
或 
无法将元素内容转换成请求的类型。</exception>
        <exception cref="T:System.ArgumentNullException">使用 <see langword="null" /> 参数调用此方法。</exception>
        <exception cref="T:System.ArgumentException">指定的本地名称和命名空间 URI 与所读取的当前元素的本地名称和命名空间 URI 不匹配。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadElementContentAsFloat">
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <exception cref="T:System.InvalidOperationException">在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情况下，将引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中”。</exception>
        <summary>将当前元素值作为单精度浮点数读取。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadElementContentAsFloat">
      <MemberSignature Language="C#" Value="public virtual float ReadElementContentAsFloat ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance float32 ReadElementContentAsFloat() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsFloat" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementContentAsFloat () As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual float ReadElementContentAsFloat();" />
      <MemberSignature Language="F#" Value="abstract member ReadElementContentAsFloat : unit -&gt; single&#xA;override this.ReadElementContentAsFloat : unit -&gt; single" Usage="xmlReader.ReadElementContentAsFloat " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>读取当前元素并将内容作为单精度浮点数返回。</summary>
        <returns>作为单精度浮点数的元素内容。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法读取开始标记，该元素的内容，并移过去的结束元素标记读取器。 扩展实体并将忽略处理指令和注释。 元素只能包含简单内容。 也就是说，它不能有子元素。  
  
 读取器将尝试将元素内容转换为单精度浮点数根据定义的规则[W3C XML 架构第 2 部分： 数据类型](http://go.microsoft.com/fwlink/?LinkId=4871)建议。  
  
 有关详细信息，请参阅 <xref:System.Xml.XmlReader> 引用页的“备注”部分。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”</exception>
        <exception cref="T:System.Xml.XmlException">当前元素包含子元素。  
  
或 
元素内容不能转换为单精度浮点数。</exception>
        <exception cref="T:System.ArgumentNullException">使用 <see langword="null" /> 参数调用此方法。</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadElementContentAsFloat">
      <MemberSignature Language="C#" Value="public virtual float ReadElementContentAsFloat (string localName, string namespaceURI);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance float32 ReadElementContentAsFloat(string localName, string namespaceURI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsFloat(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementContentAsFloat (localName As String, namespaceURI As String) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual float ReadElementContentAsFloat(System::String ^ localName, System::String ^ namespaceURI);" />
      <MemberSignature Language="F#" Value="abstract member ReadElementContentAsFloat : string * string -&gt; single&#xA;override this.ReadElementContentAsFloat : string * string -&gt; single" Usage="xmlReader.ReadElementContentAsFloat (localName, namespaceURI)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="localName" Type="System.String" />
        <Parameter Name="namespaceURI" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="localName">元素的本地名称。</param>
        <param name="namespaceURI">元素的命名空间 URI。</param>
        <summary>检查指定的本地名称和命名空间 URI 与当前元素的本地名称和命名空间 URI 是否匹配，然后读取当前元素，并将内容作为单精度浮点数返回。</summary>
        <returns>作为单精度浮点数的元素内容。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法读取开始标记，该元素的内容，并移过去的结束元素标记读取器。 扩展实体并将忽略处理指令和注释。 元素只能包含简单内容。 也就是说，它不能有子元素。  
  
 读取器将尝试将元素内容转换为单精度浮点数根据定义的规则[W3C XML 架构第 2 部分： 数据类型](http://go.microsoft.com/fwlink/?LinkId=4871)建议。  
  
 有关详细信息，请参阅 <xref:System.Xml.XmlReader> 引用页的“备注”部分。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”</exception>
        <exception cref="T:System.Xml.XmlException">当前元素包含子元素。  
  
或 
元素内容不能转换为单精度浮点数。</exception>
        <exception cref="T:System.ArgumentNullException">使用 <see langword="null" /> 参数调用此方法。</exception>
        <exception cref="T:System.ArgumentException">指定的本地名称和命名空间 URI 与所读取的当前元素的本地名称和命名空间 URI 不匹配。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadElementContentAsInt">
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <exception cref="T:System.InvalidOperationException">在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情况下，将引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中”。</exception>
        <summary>读取当前元素并将内容作为 32 位有符号整数返回。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadElementContentAsInt">
      <MemberSignature Language="C#" Value="public virtual int ReadElementContentAsInt ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 ReadElementContentAsInt() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsInt" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementContentAsInt () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int ReadElementContentAsInt();" />
      <MemberSignature Language="F#" Value="abstract member ReadElementContentAsInt : unit -&gt; int&#xA;override this.ReadElementContentAsInt : unit -&gt; int" Usage="xmlReader.ReadElementContentAsInt " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>读取当前元素并将内容作为 32 位有符号整数返回。</summary>
        <returns>作为 32 位有符号整数的元素内容。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法读取开始标记，该元素的内容，并移过去的结束元素标记读取器。 扩展实体并将忽略处理指令和注释。 元素只能包含简单内容。 也就是说，它不能有子元素。  
  
 如果将内容类型`xsd:integer`，读取器返回未装箱的 32 位有符号的整数。 如果内容未类型化`xsd:integer`，读取器将尝试将其转换为 32 位有符号整数，根据定义的规则[W3C XML 架构第 2 部分： 数据类型](http://go.microsoft.com/fwlink/?LinkId=4871)建议。  
  
 有关详细信息，请参阅 <xref:System.Xml.XmlReader> 引用页的“备注”部分。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”</exception>
        <exception cref="T:System.Xml.XmlException">当前元素包含子元素。  
  
或 
无法将元素内容转换为 32 位有符号整数。</exception>
        <exception cref="T:System.ArgumentNullException">使用 <see langword="null" /> 参数调用此方法。</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadElementContentAsInt">
      <MemberSignature Language="C#" Value="public virtual int ReadElementContentAsInt (string localName, string namespaceURI);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 ReadElementContentAsInt(string localName, string namespaceURI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsInt(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementContentAsInt (localName As String, namespaceURI As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int ReadElementContentAsInt(System::String ^ localName, System::String ^ namespaceURI);" />
      <MemberSignature Language="F#" Value="abstract member ReadElementContentAsInt : string * string -&gt; int&#xA;override this.ReadElementContentAsInt : string * string -&gt; int" Usage="xmlReader.ReadElementContentAsInt (localName, namespaceURI)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="localName" Type="System.String" />
        <Parameter Name="namespaceURI" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="localName">元素的本地名称。</param>
        <param name="namespaceURI">元素的命名空间 URI。</param>
        <summary>检查指定的本地名称和命名空间 URI 与当前元素的本地名称和命名空间 URI 是否匹配，然后读取当前元素，并将内容作为 32 位有符号整数返回。</summary>
        <returns>作为 32 位有符号整数的元素内容。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法读取开始标记，该元素的内容，并移过去的结束元素标记读取器。 扩展实体并将忽略处理指令和注释。 元素只能包含简单内容。 也就是说，它不能有子元素。  
  
 如果将内容类型`xsd:integer`，读取器返回未装箱的 32 位有符号的整数。 如果内容未类型化`xsd:integer`，读取器将尝试将其转换为 32 位有符号整数，根据定义的规则[W3C XML 架构第 2 部分： 数据类型](http://go.microsoft.com/fwlink/?LinkId=4871)建议。  
  
 有关详细信息，请参阅 <xref:System.Xml.XmlReader> 引用页的“备注”部分。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”</exception>
        <exception cref="T:System.Xml.XmlException">当前元素包含子元素。  
  
或 
无法将元素内容转换为 32 位有符号整数。</exception>
        <exception cref="T:System.ArgumentNullException">使用 <see langword="null" /> 参数调用此方法。</exception>
        <exception cref="T:System.ArgumentException">指定的本地名称和命名空间 URI 与所读取的当前元素的本地名称和命名空间 URI 不匹配。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadElementContentAsLong">
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <exception cref="T:System.InvalidOperationException">在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情况下，将引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中”。</exception>
        <summary>读取当前元素并将内容作为 64 位有符号整数返回。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadElementContentAsLong">
      <MemberSignature Language="C#" Value="public virtual long ReadElementContentAsLong ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int64 ReadElementContentAsLong() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsLong" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementContentAsLong () As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual long ReadElementContentAsLong();" />
      <MemberSignature Language="F#" Value="abstract member ReadElementContentAsLong : unit -&gt; int64&#xA;override this.ReadElementContentAsLong : unit -&gt; int64" Usage="xmlReader.ReadElementContentAsLong " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>读取当前元素并将内容作为 64 位有符号整数返回。</summary>
        <returns>作为 64 位有符号整数的元素内容。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法读取开始标记，该元素的内容，并移过去的结束元素标记读取器。 扩展实体并将忽略处理指令和注释。 元素只能包含简单内容。 也就是说，它不能有子元素。  
  
 如果将内容类型`xsd:long`，读取器返回未装箱的 64 位有符号的整数。 如果内容未类型化`xsd:long`，读取器将尝试将其转换为 64 位有符号整数，根据定义的规则[W3C XML 架构第 2 部分： 数据类型](http://go.microsoft.com/fwlink/?LinkId=4871)建议。  
  
 有关详细信息，请参阅 <xref:System.Xml.XmlReader> 引用页的“备注”部分。  
  
   
  
## Examples  
 下面的示例使用<xref:System.Xml.XmlReader.ReadElementContentAsLong%2A>方法来读取的内容`longValue`元素。  
  
 [!code-csharp[XmlReader.ReadElementContentAs#3](~/samples/snippets/csharp/VS_Snippets_Data/XmlReader.ReadElementContentAs/CS/readElementContentAs.cs#3)]
 [!code-vb[XmlReader.ReadElementContentAs#3](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReader.ReadElementContentAs/VB/readElementContentAs.vb#3)]  
  
 示例使用 `dataFile.xml` 文件作为输入。  
  
 [!code-xml[XmlReader.ReadElementContentAs#8](~/samples/snippets/xml/VS_Snippets_Data/XmlReader.ReadElementContentAs/XML/dataFile.xml#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”</exception>
        <exception cref="T:System.Xml.XmlException">当前元素包含子元素。  
  
或 
无法将元素内容转换为 64 位有符号整数。</exception>
        <exception cref="T:System.ArgumentNullException">使用 <see langword="null" /> 参数调用此方法。</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadElementContentAsLong">
      <MemberSignature Language="C#" Value="public virtual long ReadElementContentAsLong (string localName, string namespaceURI);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int64 ReadElementContentAsLong(string localName, string namespaceURI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsLong(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementContentAsLong (localName As String, namespaceURI As String) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual long ReadElementContentAsLong(System::String ^ localName, System::String ^ namespaceURI);" />
      <MemberSignature Language="F#" Value="abstract member ReadElementContentAsLong : string * string -&gt; int64&#xA;override this.ReadElementContentAsLong : string * string -&gt; int64" Usage="xmlReader.ReadElementContentAsLong (localName, namespaceURI)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="localName" Type="System.String" />
        <Parameter Name="namespaceURI" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="localName">元素的本地名称。</param>
        <param name="namespaceURI">元素的命名空间 URI。</param>
        <summary>检查指定的本地名称和命名空间 URI 与当前元素的本地名称和命名空间 URI 是否匹配，然后读取当前元素，并将内容作为 64 位有符号整数返回。</summary>
        <returns>作为 64 位有符号整数的元素内容。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法读取开始标记，该元素的内容，并移过去的结束元素标记读取器。 扩展实体并将忽略处理指令和注释。 元素只能包含简单内容。 也就是说，它不能有子元素。  
  
 如果将内容类型`xsd:long`，读取器返回未装箱的 64 位有符号的整数。 如果内容未类型化`xsd:long`，读取器将尝试将其转换为 64 位有符号整数，根据定义的规则[W3C XML 架构第 2 部分： 数据类型](http://go.microsoft.com/fwlink/?LinkId=4871)建议。  
  
 有关详细信息，请参阅 <xref:System.Xml.XmlReader> 引用页的“备注”部分。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”</exception>
        <exception cref="T:System.Xml.XmlException">当前元素包含子元素。  
  
或 
无法将元素内容转换为 64 位有符号整数。</exception>
        <exception cref="T:System.ArgumentNullException">使用 <see langword="null" /> 参数调用此方法。</exception>
        <exception cref="T:System.ArgumentException">指定的本地名称和命名空间 URI 与所读取的当前元素的本地名称和命名空间 URI 不匹配。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadElementContentAsObject">
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <exception cref="T:System.InvalidOperationException">在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情况下，将引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中”。</exception>
        <summary>读取当前元素并将内容作为 <see cref="T:System.Object" /> 返回。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadElementContentAsObject">
      <MemberSignature Language="C#" Value="public virtual object ReadElementContentAsObject ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object ReadElementContentAsObject() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsObject" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementContentAsObject () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ ReadElementContentAsObject();" />
      <MemberSignature Language="F#" Value="abstract member ReadElementContentAsObject : unit -&gt; obj&#xA;override this.ReadElementContentAsObject : unit -&gt; obj" Usage="xmlReader.ReadElementContentAsObject " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>读取当前元素并将内容作为 <see cref="T:System.Object" /> 返回。</summary>
        <returns>一个最适当类型的装箱的公共语言运行时 (CLR) 对象。 <see cref="P:System.Xml.XmlReader.ValueType" /> 属性确定了适当的 CLR 类型。 如果将内容类型化为列表类型，则此方法返回一个适当类型的装箱对象的数组。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法读取开始标记，该元素的内容，并移过去的结束元素标记读取器。 扩展实体并将忽略处理指令和注释。 元素只能包含简单内容。 也就是说，它不能有子元素。  
  
 有关详细信息，请参阅备注部分<xref:System.Xml.XmlReader>参考页和[W3C XML 架构第 2 部分： 数据类型](http://go.microsoft.com/fwlink/?LinkId=4871)建议。  
  
 此方法的异步版本，请参阅<xref:System.Xml.XmlReader.ReadElementContentAsObjectAsync%2A>。  
  
   
  
## Examples  
 下面的示例使用方法来读取的内容`price`节点。 读取器使用的架构中的信息将内容映射到正确的数据类型。  
  
 [!code-csharp[XmlReader.ReadElementContentAs#6](~/samples/snippets/csharp/VS_Snippets_Data/XmlReader.ReadElementContentAs/CS/readElementContentAs.cs#6)]
 [!code-vb[XmlReader.ReadElementContentAs#6](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReader.ReadElementContentAs/VB/readElementContentAs.vb#6)]  
  
 该示例使用以下两个文件  
  
 `item.xml`  
  
 [!code-xml[XmlReader.ReadElementContentAs#11](~/samples/snippets/xml/VS_Snippets_Data/XmlReader.ReadElementContentAs/XML/item.xml#11)]  
  
 `item.xsd`  
  
 [!code-xml[XmlReader.ReadElementContentAs#12](~/samples/snippets/xml/VS_Snippets_Data/XmlReader.ReadElementContentAs/XML/item.xsd#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”</exception>
        <exception cref="T:System.Xml.XmlException">当前元素包含子元素。  
  
或 
无法将元素内容转换成请求的类型</exception>
        <exception cref="T:System.ArgumentNullException">使用 <see langword="null" /> 参数调用此方法。</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadElementContentAsObject">
      <MemberSignature Language="C#" Value="public virtual object ReadElementContentAsObject (string localName, string namespaceURI);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object ReadElementContentAsObject(string localName, string namespaceURI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsObject(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementContentAsObject (localName As String, namespaceURI As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ ReadElementContentAsObject(System::String ^ localName, System::String ^ namespaceURI);" />
      <MemberSignature Language="F#" Value="abstract member ReadElementContentAsObject : string * string -&gt; obj&#xA;override this.ReadElementContentAsObject : string * string -&gt; obj" Usage="xmlReader.ReadElementContentAsObject (localName, namespaceURI)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="localName" Type="System.String" />
        <Parameter Name="namespaceURI" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="localName">元素的本地名称。</param>
        <param name="namespaceURI">元素的命名空间 URI。</param>
        <summary>检查指定的本地名称和命名空间 URI 与当前元素的本地名称和命名空间 URI 是否匹配，然后读取当前元素，并将内容作为 <see cref="T:System.Object" /> 返回。</summary>
        <returns>一个最适当类型的装箱的公共语言运行时 (CLR) 对象。 <see cref="P:System.Xml.XmlReader.ValueType" /> 属性确定了适当的 CLR 类型。 如果将内容类型化为列表类型，则此方法返回一个适当类型的装箱对象的数组。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法读取开始标记，该元素的内容，并移过去的结束元素标记读取器。 扩展实体并将忽略处理指令和注释。 元素只能包含简单内容。 也就是说，它不能有子元素。  
  
 有关详细信息，请参阅备注部分<xref:System.Xml.XmlReader>参考页和[W3C XML 架构第 2 部分： 数据类型](http://go.microsoft.com/fwlink/?LinkId=4871)建议。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”</exception>
        <exception cref="T:System.Xml.XmlException">当前元素包含子元素。  
  
或 
无法将元素内容转换成请求的类型。</exception>
        <exception cref="T:System.ArgumentNullException">使用 <see langword="null" /> 参数调用此方法。</exception>
        <exception cref="T:System.ArgumentException">指定的本地名称和命名空间 URI 与所读取的当前元素的本地名称和命名空间 URI 不匹配。</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadElementContentAsObjectAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;object&gt; ReadElementContentAsObjectAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;object&gt; ReadElementContentAsObjectAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsObjectAsync" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementContentAsObjectAsync () As Task(Of Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task&lt;System::Object ^&gt; ^ ReadElementContentAsObjectAsync();" />
      <MemberSignature Language="F#" Value="abstract member ReadElementContentAsObjectAsync : unit -&gt; System.Threading.Tasks.Task&lt;obj&gt;&#xA;override this.ReadElementContentAsObjectAsync : unit -&gt; System.Threading.Tasks.Task&lt;obj&gt;" Usage="xmlReader.ReadElementContentAsObjectAsync " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.DebuggerStepThrough</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Object&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>异步读取当前元素并将内容作为 <see cref="T:System.Object" /> 返回。</summary>
        <returns>一个最适当类型的装箱的公共语言运行时 (CLR) 对象。 <see cref="P:System.Xml.XmlReader.ValueType" /> 属性确定了适当的 CLR 类型。 如果将内容类型化为列表类型，则此方法返回一个适当类型的装箱对象的数组。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 这是异步版本<xref:System.Xml.XmlReader.ReadElementContentAsObject%2A>，具有相同功能。 若要使用此方法，必须设置<xref:System.Xml.XmlReaderSettings.Async%2A>标记，用于`true`。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">调用了 <see cref="T:System.Xml.XmlReader" /> 异步方法，但未将 <see cref="P:System.Xml.XmlReaderSettings.Async" /> 标志设置为 <see langword="true" />。 在此情况下，将引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“若要使用 Async 方法，请将 XmlReaderSettings.Async 设置为 True。”</exception>
        <related type="Article" href="http://msdn.microsoft.com/library/db854f91-ccef-4035-ae4d-0911fde808c7">使用 Async 和 Await 的异步编程（C# 和 Visual Basic）</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadElementContentAsString">
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <exception cref="T:System.InvalidOperationException">在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情况下，将引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中”。</exception>
        <summary>读取当前元素并将内容作为 <see cref="T:System.String" /> 对象返回。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadElementContentAsString">
      <MemberSignature Language="C#" Value="public virtual string ReadElementContentAsString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ReadElementContentAsString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsString" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementContentAsString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ReadElementContentAsString();" />
      <MemberSignature Language="F#" Value="abstract member ReadElementContentAsString : unit -&gt; string&#xA;override this.ReadElementContentAsString : unit -&gt; string" Usage="xmlReader.ReadElementContentAsString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>读取当前元素并将内容作为 <see cref="T:System.String" /> 对象返回。</summary>
        <returns>作为 <see cref="T:System.String" /> 对象的元素内容。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法读取开始标记，该元素的内容，并移过去的结束元素标记读取器。 扩展实体并将忽略处理指令和注释。 元素只能包含简单内容。 也就是说，它不能有子元素。  
  
 有关详细信息，请参阅备注部分<xref:System.Xml.XmlReader>参考页和[W3C XML 架构第 2 部分： 数据类型](http://go.microsoft.com/fwlink/?LinkId=4871)建议。  
  
 此方法的异步版本，请参阅<xref:System.Xml.XmlReader.ReadElementContentAsStringAsync%2A>。  
  
   
  
## Examples  
 下面的示例读取`stringValue`元素，并返回的文本内容 （忽略注释和处理指令）。  
  
 [!code-csharp[XmlReader.ReadElementContentAs#1](~/samples/snippets/csharp/VS_Snippets_Data/XmlReader.ReadElementContentAs/CS/readElementContentAs.cs#1)]
 [!code-vb[XmlReader.ReadElementContentAs#1](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReader.ReadElementContentAs/VB/readElementContentAs.vb#1)]  
  
 示例使用 `dataFile.xml` 文件作为输入。  
  
 [!code-xml[XmlReader.ReadElementContentAs#8](~/samples/snippets/xml/VS_Snippets_Data/XmlReader.ReadElementContentAs/XML/dataFile.xml#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”</exception>
        <exception cref="T:System.Xml.XmlException">当前元素包含子元素。  
  
或 
无法将元素内容转换为 <see cref="T:System.String" /> 对象。</exception>
        <exception cref="T:System.ArgumentNullException">使用 <see langword="null" /> 参数调用此方法。</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadElementContentAsString">
      <MemberSignature Language="C#" Value="public virtual string ReadElementContentAsString (string localName, string namespaceURI);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ReadElementContentAsString(string localName, string namespaceURI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsString(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementContentAsString (localName As String, namespaceURI As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ReadElementContentAsString(System::String ^ localName, System::String ^ namespaceURI);" />
      <MemberSignature Language="F#" Value="abstract member ReadElementContentAsString : string * string -&gt; string&#xA;override this.ReadElementContentAsString : string * string -&gt; string" Usage="xmlReader.ReadElementContentAsString (localName, namespaceURI)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="localName" Type="System.String" />
        <Parameter Name="namespaceURI" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="localName">元素的本地名称。</param>
        <param name="namespaceURI">元素的命名空间 URI。</param>
        <summary>检查指定的本地名称和命名空间 URI 与当前元素的本地名称和命名空间 URI 是否匹配，然后读取当前元素，并将内容作为 <see cref="T:System.String" /> 对象返回。</summary>
        <returns>作为 <see cref="T:System.String" /> 对象的元素内容。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法读取开始标记，该元素的内容，并移过去的结束元素标记读取器。 扩展实体并将忽略处理指令和注释。 元素只能包含简单内容。 也就是说，它不能有子元素。  
  
 有关详细信息，请参阅备注部分<xref:System.Xml.XmlReader>参考页和[W3C XML 架构第 2 部分： 数据类型](http://go.microsoft.com/fwlink/?LinkId=4871)建议。  
  
   
  
## Examples  
 下面的示例读取`stringValue`元素，并返回的文本内容 （忽略注释和处理指令）。  
  
 [!code-csharp[XmlReader.ReadElementContentAs#2](~/samples/snippets/csharp/VS_Snippets_Data/XmlReader.ReadElementContentAs/CS/readElementContentAs.cs#2)]
 [!code-vb[XmlReader.ReadElementContentAs#2](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReader.ReadElementContentAs/VB/readElementContentAs.vb#2)]  
  
 示例使用 `dataFile.xml` 文件作为输入。  
  
 [!code-xml[XmlReader.ReadElementContentAs#8](~/samples/snippets/xml/VS_Snippets_Data/XmlReader.ReadElementContentAs/XML/dataFile.xml#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”</exception>
        <exception cref="T:System.Xml.XmlException">当前元素包含子元素。  
  
或 
无法将元素内容转换为 <see cref="T:System.String" /> 对象。</exception>
        <exception cref="T:System.ArgumentNullException">使用 <see langword="null" /> 参数调用此方法。</exception>
        <exception cref="T:System.ArgumentException">指定的本地名称和命名空间 URI 与所读取的当前元素的本地名称和命名空间 URI 不匹配。</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadElementContentAsStringAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;string&gt; ReadElementContentAsStringAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;string&gt; ReadElementContentAsStringAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsStringAsync" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementContentAsStringAsync () As Task(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task&lt;System::String ^&gt; ^ ReadElementContentAsStringAsync();" />
      <MemberSignature Language="F#" Value="abstract member ReadElementContentAsStringAsync : unit -&gt; System.Threading.Tasks.Task&lt;string&gt;&#xA;override this.ReadElementContentAsStringAsync : unit -&gt; System.Threading.Tasks.Task&lt;string&gt;" Usage="xmlReader.ReadElementContentAsStringAsync " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.DebuggerStepThrough</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>异步读取当前元素并将内容作为 <see cref="T:System.String" /> 对象返回。</summary>
        <returns>作为 <see cref="T:System.String" /> 对象的元素内容。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 这是异步版本<xref:System.Xml.XmlReader.ReadElementContentAsString%2A>，具有相同功能。 若要使用此方法，必须设置<xref:System.Xml.XmlReaderSettings.Async%2A>标记，用于`true`。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">调用了 <see cref="T:System.Xml.XmlReader" /> 异步方法，但未将 <see cref="P:System.Xml.XmlReaderSettings.Async" /> 标志设置为 <see langword="true" />。 在此情况下，将引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“若要使用 Async 方法，请将 XmlReaderSettings.Async 设置为 True。”</exception>
        <related type="Article" href="http://msdn.microsoft.com/library/db854f91-ccef-4035-ae4d-0911fde808c7">使用 Async 和 Await 的异步编程（C# 和 Visual Basic）</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadElementString">
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <exception cref="T:System.InvalidOperationException">在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”</exception>
        <summary>读取只有简单文本的元素。 但是，建议改用 <see cref="Overload:System.Xml.XmlReader.ReadElementContentAsString" /> 方法，因为该方法可以更直接地处理此操作。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 我们建议你使用<xref:System.Xml.XmlReader.ReadElementContentAsString%2A>方法来读取文本元素。  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadElementString">
      <MemberSignature Language="C#" Value="public virtual string ReadElementString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ReadElementString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementString" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ReadElementString();" />
      <MemberSignature Language="F#" Value="abstract member ReadElementString : unit -&gt; string&#xA;override this.ReadElementString : unit -&gt; string" Usage="xmlReader.ReadElementString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>读取纯文本元素。 但是，建议改用 <see cref="M:System.Xml.XmlReader.ReadElementContentAsString" /> 方法，因为该方法可以更直接地处理此操作。</summary>
        <returns>所读取的元素中包含的文本。 如果元素为空，则返回一个空字符串。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 我们建议你使用<xref:System.Xml.XmlReader.ReadElementContentAsString>方法来读取文本元素。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException">下一个内容节点不是开始标记；或者找到的元素不包含简单文本值。</exception>
        <exception cref="T:System.InvalidOperationException">在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadElementString">
      <MemberSignature Language="C#" Value="public virtual string ReadElementString (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ReadElementString(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementString(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementString (name As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ReadElementString(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member ReadElementString : string -&gt; string&#xA;override this.ReadElementString : string -&gt; string" Usage="xmlReader.ReadElementString name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">要检查的名称。</param>
        <summary>在读取纯文本元素之前，检查所找到元素的 <see cref="P:System.Xml.XmlReader.Name" /> 属性是否与给定的字符串匹配。 但是，建议改用 <see cref="M:System.Xml.XmlReader.ReadElementContentAsString" /> 方法，因为该方法可以更直接地处理此操作。</summary>
        <returns>所读取的元素中包含的文本。 如果元素为空，则返回一个空字符串。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 我们建议你使用<xref:System.Xml.XmlReader.ReadElementContentAsString>方法来读取文本元素。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException">如果下一个内容节点不是一个开始标记；如果元素 <see langword="Name" /> 与给定的参数不匹配；或者如果找到的元素不包含简单的文本值。</exception>
        <exception cref="T:System.InvalidOperationException">在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadElementString">
      <MemberSignature Language="C#" Value="public virtual string ReadElementString (string localname, string ns);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ReadElementString(string localname, string ns) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementString(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementString (localname As String, ns As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ReadElementString(System::String ^ localname, System::String ^ ns);" />
      <MemberSignature Language="F#" Value="abstract member ReadElementString : string * string -&gt; string&#xA;override this.ReadElementString : string * string -&gt; string" Usage="xmlReader.ReadElementString (localname, ns)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="localname" Type="System.String" />
        <Parameter Name="ns" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="localname">要检查的本地名称。</param>
        <param name="ns">要检查的命名空间 URI。</param>
        <summary>在读取纯文本元素之前，检查所找到元素的 <see cref="P:System.Xml.XmlReader.LocalName" /> 和 <see cref="P:System.Xml.XmlReader.NamespaceURI" /> 属性是否与给定的字符串匹配。 但是，建议改用 <see cref="M:System.Xml.XmlReader.ReadElementContentAsString(System.String,System.String)" /> 方法，因为该方法可以更直接地处理此操作。</summary>
        <returns>所读取的元素中包含的文本。 如果元素为空，则返回一个空字符串。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 我们建议你使用<xref:System.Xml.XmlReader.ReadElementContentAsString%28System.String%2CSystem.String%29>方法来读取文本元素。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException">如果下一个内容节点不是一个开始标记；如果元素 <see langword="LocalName" /> 或 <see langword="NamespaceURI" /> 与给定的参数不匹配；或者如果找到的元素不包含简单的文本值。</exception>
        <exception cref="T:System.InvalidOperationException">在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadEndElement">
      <MemberSignature Language="C#" Value="public virtual void ReadEndElement ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ReadEndElement() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadEndElement" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub ReadEndElement ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ReadEndElement();" />
      <MemberSignature Language="F#" Value="abstract member ReadEndElement : unit -&gt; unit&#xA;override this.ReadEndElement : unit -&gt; unit" Usage="xmlReader.ReadEndElement " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>检查当前内容节点是否为结束标记并将读取器推进到下一个节点。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 以下示例显示每个元素的文本内容。  
  
 [!code-csharp[XmlReaderBasic#11](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#11)]
 [!code-vb[XmlReaderBasic#11](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#11)]  
  
 该示例使用`book3.xml`文件。  
  
 [!code-xml[XML_Core_Files#6](~/samples/snippets/xml/VS_Snippets_Data/XML_Core_Files/XML/book3.xml#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException">当前节点不是一个结束标记，或者如果在输入流中遇到不正确的 XML。</exception>
        <exception cref="T:System.InvalidOperationException">在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”</exception>
        <altmember cref="M:System.Xml.XmlReader.ReadStartElement" />
      </Docs>
    </Member>
    <Member MemberName="ReadInnerXml">
      <MemberSignature Language="C#" Value="public virtual string ReadInnerXml ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ReadInnerXml() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadInnerXml" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadInnerXml () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ReadInnerXml();" />
      <MemberSignature Language="F#" Value="abstract member ReadInnerXml : unit -&gt; string&#xA;override this.ReadInnerXml : unit -&gt; string" Usage="xmlReader.ReadInnerXml " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>当在派生类中被重写时，将所有内容（包括标记）当做字符串读取。</summary>
        <returns>当前节点中的所有 XML 内容（包括标记）。 如果当前节点没有任何子级，则返回空字符串。  
  
如果当前节点既非元素，也非属性，则返回空字符串。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法返回当前节点包括在标记中的所有内容。 不返回当前节点（开始标记）和对应的结束节点（结束标记）。 例如，如果你有以下：  
  
```xml  
<node>  
 this <child id="123"/>  
</node>  
```  
  
 `ReadInnerXml` 返回 `this <child id="123"/>`  
  
 此方法按以下方式处理元素和属性节点：  
  
|节点类型|在调用之前的位置|XML 片断|返回值|之后的位置|  
|---------------|------------------------------|------------------|------------------|-----------------------------|  
|`Element`|在 `item1` 开始标记上。|\<item1>text1\</item1>\<item2>text2\</item2>|text1|在 `item2` 开始标记上。|  
|`Attribute`|在 `attr1` 属性节点上。|\<item attr1="val1" attr2="val2">text\</item>|val1|保留在 `attr1` 属性节点上。|  
  
 如果读取器定位在叶节点上，则调用 `ReadInnerXml` 等效于调用 <xref:System.Xml.XmlReader.Read%2A>。 该方法将返回`String.Empty`（除非对于特性节点，在这种情况下返回的属性的值）。  
  
 此方法会检查格式正确的 XML。 如果`ReadInnerXml`从调用<xref:System.Xml.XmlValidatingReader>，此方法还可验证返回的内容。  
  
 在中实现<xref:System.Xml.XmlNodeReader>，<xref:System.Xml.XmlTextReader>并`XmlValidatingReader`类`ReadOuterXml`方法可以识别命名空间。  
  
 此方法的异步版本，请参阅<xref:System.Xml.XmlReader.ReadInnerXmlAsync%2A>。  
  
   
  
## Examples  
 下面的示例比较`ReadInnerXml`和<xref:System.Xml.XmlReader.ReadOuterXml%2A>方法。  
  
 [!code-csharp[XmlReaderBasic#12](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#12)]
 [!code-vb[XmlReaderBasic#12](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#12)]  
  
 该示例使用`2books.xml`文件作为输入。  
  
 [!code-xml[XML_Core_Files#7](~/samples/snippets/xml/VS_Snippets_Data/XML_Core_Files/XML/2books.xml#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException">XML 的格式不良，或分析 XML 时出错。</exception>
        <exception cref="T:System.InvalidOperationException">在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadInnerXmlAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;string&gt; ReadInnerXmlAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;string&gt; ReadInnerXmlAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadInnerXmlAsync" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadInnerXmlAsync () As Task(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task&lt;System::String ^&gt; ^ ReadInnerXmlAsync();" />
      <MemberSignature Language="F#" Value="abstract member ReadInnerXmlAsync : unit -&gt; System.Threading.Tasks.Task&lt;string&gt;&#xA;override this.ReadInnerXmlAsync : unit -&gt; System.Threading.Tasks.Task&lt;string&gt;" Usage="xmlReader.ReadInnerXmlAsync " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.DebuggerStepThrough</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>异步读取所有内容，包括作为字符串的标记。</summary>
        <returns>当前节点中的所有 XML 内容（包括标记）。 如果当前节点没有任何子级，则返回空字符串。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 这是异步版本<xref:System.Xml.XmlReader.ReadInnerXml%2A>，具有相同功能。 若要使用此方法，必须设置<xref:System.Xml.XmlReaderSettings.Async%2A>标记，用于`true`。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">调用了 <see cref="T:System.Xml.XmlReader" /> 异步方法，但未将 <see cref="P:System.Xml.XmlReaderSettings.Async" /> 标志设置为 <see langword="true" />。 在此情况下，将引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“若要使用 Async 方法，请将 XmlReaderSettings.Async 设置为 True。”</exception>
        <related type="Article" href="http://msdn.microsoft.com/library/db854f91-ccef-4035-ae4d-0911fde808c7">使用 Async 和 Await 的异步编程（C# 和 Visual Basic）</related>
      </Docs>
    </Member>
    <Member MemberName="ReadOuterXml">
      <MemberSignature Language="C#" Value="public virtual string ReadOuterXml ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ReadOuterXml() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadOuterXml" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadOuterXml () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ReadOuterXml();" />
      <MemberSignature Language="F#" Value="abstract member ReadOuterXml : unit -&gt; string&#xA;override this.ReadOuterXml : unit -&gt; string" Usage="xmlReader.ReadOuterXml " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>当在派生类中被重写时，读取表示该节点和所有它的子级的内容（包括标记）。</summary>
        <returns>如果读取器定位在元素或属性节点上，此方法将返回当前节点及其所有子级的所有 XML 内容（包括标记）；否则返回空字符串。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法是类似于<xref:System.Xml.XmlReader.ReadInnerXml%2A>但它还返回开始和结束标记。  
  
 此方法按以下方式处理元素和属性节点：  
  
|节点类型|在调用之前的位置|XML 片断|返回值|之后的位置|  
|---------------|------------------------------|------------------|------------------|-----------------------------|  
|`Element`|在 `item1` 开始标记上。|\<item1>text1\</item1>\<item2>text2\</item2>|\<item1>text1\</item1>|在 `item2` 开始标记上。|  
|`Attribute`|在 `attr1` 属性节点上。|\<item attr1="val1" attr2="val2">text\</item>|attr1="val1"|保留在 `attr1` 属性节点上。|  
  
 如果读取器定位在叶节点上，则调用 `ReadOuterXml` 等效于调用 <xref:System.Xml.XmlReader.Read%2A>。 该方法将返回`String.Empty`（除非对于特性节点，在这种情况下返回的属性标记）。  
  
 此方法会检查格式正确的 XML。 如果`ReadOuterXml`从调用<xref:System.Xml.XmlValidatingReader>，此方法还可验证返回的内容  
  
 在中实现<xref:System.Xml.XmlNodeReader>，<xref:System.Xml.XmlTextReader>并`XmlValidatingReader`类`ReadOuterXml`方法可以识别命名空间。 给定以下 XML 文本`<A xmlns:S="urn:1"><S:B>hello</S:B></A>`，如果读取器位于上`S:B`开始标记处，`ReadOuterXml`返回`<S:B xmlns:S="urn:1">hello<S:B/>`。  
  
 此方法的异步版本，请参阅<xref:System.Xml.XmlReader.ReadOuterXmlAsync%2A>。  
  
   
  
## Examples  
 下面的示例比较`ReadInnerXml`和`ReadOuterXml`方法。  
  
 [!code-csharp[XmlReaderBasic#12](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#12)]
 [!code-vb[XmlReaderBasic#12](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#12)]  
  
 该示例使用`2books.xml`文件作为输入。  
  
 [!code-xml[XML_Core_Files#7](~/samples/snippets/xml/VS_Snippets_Data/XML_Core_Files/XML/2books.xml#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException">XML 的格式不良，或分析 XML 时出错。</exception>
        <exception cref="T:System.InvalidOperationException">在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadOuterXmlAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;string&gt; ReadOuterXmlAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;string&gt; ReadOuterXmlAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadOuterXmlAsync" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadOuterXmlAsync () As Task(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task&lt;System::String ^&gt; ^ ReadOuterXmlAsync();" />
      <MemberSignature Language="F#" Value="abstract member ReadOuterXmlAsync : unit -&gt; System.Threading.Tasks.Task&lt;string&gt;&#xA;override this.ReadOuterXmlAsync : unit -&gt; System.Threading.Tasks.Task&lt;string&gt;" Usage="xmlReader.ReadOuterXmlAsync " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.DebuggerStepThrough</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>异步读取包含该节点和所有它的子级的内容（包括标记）。</summary>
        <returns>如果读取器定位在元素或属性节点上，此方法将返回当前节点及其所有子级的所有 XML 内容（包括标记）；否则返回空字符串。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 这是异步版本<xref:System.Xml.XmlReader.ReadOuterXml%2A>，具有相同功能。 若要使用此方法，必须设置<xref:System.Xml.XmlReaderSettings.Async%2A>标记，用于`true`。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">调用了 <see cref="T:System.Xml.XmlReader" /> 异步方法，但未将 <see cref="P:System.Xml.XmlReaderSettings.Async" /> 标志设置为 <see langword="true" />。 在此情况下，将引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“若要使用 Async 方法，请将 XmlReaderSettings.Async 设置为 True。”</exception>
        <related type="Article" href="http://msdn.microsoft.com/library/db854f91-ccef-4035-ae4d-0911fde808c7">使用 Async 和 Await 的异步编程（C# 和 Visual Basic）</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadStartElement">
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <exception cref="T:System.InvalidOperationException">在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情况下，将引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中”。</exception>
        <summary>检查当前节点是否为元素并将读取器推进到下一个节点。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadStartElement">
      <MemberSignature Language="C#" Value="public virtual void ReadStartElement ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ReadStartElement() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadStartElement" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub ReadStartElement ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ReadStartElement();" />
      <MemberSignature Language="F#" Value="abstract member ReadStartElement : unit -&gt; unit&#xA;override this.ReadStartElement : unit -&gt; unit" Usage="xmlReader.ReadStartElement " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>检查当前节点是否为元素并将读取器推进到下一个节点。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法调用<xref:System.Xml.XmlReader.IsStartElement%2A>跟<xref:System.Xml.XmlReader.Read%2A>以定位您在输入流中找到该元素的内容上。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException">在输入流中遇到不正确的 XML。</exception>
        <exception cref="T:System.InvalidOperationException">在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”</exception>
        <altmember cref="M:System.Xml.XmlReader.ReadEndElement" />
      </Docs>
    </Member>
    <Member MemberName="ReadStartElement">
      <MemberSignature Language="C#" Value="public virtual void ReadStartElement (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ReadStartElement(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadStartElement(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub ReadStartElement (name As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ReadStartElement(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member ReadStartElement : string -&gt; unit&#xA;override this.ReadStartElement : string -&gt; unit" Usage="xmlReader.ReadStartElement name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">元素的限定名。</param>
        <summary>检查当前内容节点是否为具有给定 <see cref="P:System.Xml.XmlReader.Name" /> 的元素并将读取器推进到下一个节点。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 调用此方法对应于调用<xref:System.Xml.XmlReader.IsStartElement%2A>调用后跟<xref:System.Xml.XmlReader.Read%2A>。  
  
   
  
## Examples  
 以下示例显示每个元素的文本内容。  
  
 [!code-csharp[XmlReaderBasic#11](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#11)]
 [!code-vb[XmlReaderBasic#11](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#11)]  
  
 该示例使用`book3.xml`文件。  
  
 [!code-xml[XML_Core_Files#6](~/samples/snippets/xml/VS_Snippets_Data/XML_Core_Files/XML/book3.xml#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException">在输入流中遇到不正确的 XML。  
  
或 
元素的 <see cref="P:System.Xml.XmlReader.Name" /> 不匹配给定的 <paramref name="name" />。</exception>
        <exception cref="T:System.InvalidOperationException">在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”</exception>
        <altmember cref="M:System.Xml.XmlReader.ReadEndElement" />
      </Docs>
    </Member>
    <Member MemberName="ReadStartElement">
      <MemberSignature Language="C#" Value="public virtual void ReadStartElement (string localname, string ns);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ReadStartElement(string localname, string ns) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadStartElement(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub ReadStartElement (localname As String, ns As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ReadStartElement(System::String ^ localname, System::String ^ ns);" />
      <MemberSignature Language="F#" Value="abstract member ReadStartElement : string * string -&gt; unit&#xA;override this.ReadStartElement : string * string -&gt; unit" Usage="xmlReader.ReadStartElement (localname, ns)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="localname" Type="System.String" />
        <Parameter Name="ns" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="localname">元素的本地名称。</param>
        <param name="ns">元素的命名空间 URI。</param>
        <summary>检查当前内容节点是否为具有给定 <see cref="P:System.Xml.XmlReader.LocalName" /> 和 <see cref="P:System.Xml.XmlReader.NamespaceURI" /> 的元素并将读取器推进到下一个节点。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 调用此方法对应于调用<xref:System.Xml.XmlReader.IsStartElement%2A>调用后跟<xref:System.Xml.XmlReader.Read%2A>。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException">在输入流中遇到不正确的 XML。  
  
或 
所找到元素的 <see cref="P:System.Xml.XmlReader.LocalName" /> 和 <see cref="P:System.Xml.XmlReader.NamespaceURI" /> 属性与给定的参数不匹配。</exception>
        <exception cref="T:System.InvalidOperationException">在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”</exception>
        <altmember cref="M:System.Xml.XmlReader.ReadEndElement" />
      </Docs>
    </Member>
    <Member MemberName="ReadState">
      <MemberSignature Language="C#" Value="public abstract System.Xml.ReadState ReadState { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Xml.ReadState ReadState" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.ReadState" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property ReadState As ReadState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::Xml::ReadState ReadState { System::Xml::ReadState get(); };" />
      <MemberSignature Language="F#" Value="member this.ReadState : System.Xml.ReadState" Usage="System.Xml.XmlReader.ReadState" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.ReadState</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当在派生类中被重写时，获取读取器的状态。</summary>
        <value>指定读取器的状态的枚举值之一。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Xml.XmlReader.ReadState%2A>属性具有以下值之一：  
  
-   <xref:System.Xml.ReadState.Initial>当<xref:System.Xml.XmlReader.Read%2A?displayProperty=nameWithType>调用方法。  
  
-   <xref:System.Xml.ReadState.Interactive>当<xref:System.Xml.XmlReader.Read%2A?displayProperty=nameWithType>已调用方法，并且不能对读取器调用其他方法。  
  
-   <xref:System.Xml.ReadState.EndOfFile>当 XML 文档的最终达到了成功。  
  
-   <xref:System.Xml.ReadState.Closed>当<xref:System.Xml.XmlReader.Close%2A?displayProperty=nameWithType>调用方法。  
  
-   <xref:System.Xml.ReadState.Error>当发生错误，无法继续执行读取的操作。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadString">
      <MemberSignature Language="C#" Value="public virtual string ReadString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ReadString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadString" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ReadString();" />
      <MemberSignature Language="F#" Value="abstract member ReadString : unit -&gt; string&#xA;override this.ReadString : unit -&gt; string" Usage="xmlReader.ReadString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>当在派生类中被重写时，将元素或文本节点的内容当做字符串读取。 但是，建议改用 <see cref="Overload:System.Xml.XmlReader.ReadElementContentAsString" /> 方法，因为该方法可以更直接地处理此操作。</summary>
        <returns>元素的内容或空字符串。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 我们建议你使用<xref:System.Xml.XmlReader.ReadElementContentAsString%2A>方法读取元素或文本节点作为字符串的内容。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException">分析 XML 时出错。</exception>
        <exception cref="T:System.InvalidOperationException">在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadSubtree">
      <MemberSignature Language="C#" Value="public virtual System.Xml.XmlReader ReadSubtree ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Xml.XmlReader ReadSubtree() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadSubtree" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadSubtree () As XmlReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Xml::XmlReader ^ ReadSubtree();" />
      <MemberSignature Language="F#" Value="abstract member ReadSubtree : unit -&gt; System.Xml.XmlReader&#xA;override this.ReadSubtree : unit -&gt; System.Xml.XmlReader" Usage="xmlReader.ReadSubtree " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlReader</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回新的 <see langword="XmlReader" /> 实例，此实例可用于读取当前节点及其所有子节点。</summary>
        <returns>设置为 <see cref="F:System.Xml.ReadState.Initial" /> 的新 XML 实例。 调用 <see cref="M:System.Xml.XmlReader.Read" /> 方法时，会将新的读取器定位在调用 <see cref="M:System.Xml.XmlReader.ReadSubtree" /> 方法之前的当前节点上。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Xml.XmlReader.ReadSubtree%2A> 只能在元素节点上调用。 读取整个子树后，调用<xref:System.Xml.XmlReader.Read%2A>方法将返回`false`。 当新的 XML 读取器已关闭，定位于原始 readeris`EndElement`的子树的节点。 因此，如果您调用<xref:System.Xml.XmlReader.ReadSubtree%2A>未关闭的书元素后读取和新的 XML 读取器子树, 的开始标记上的方法，原始的 XML 读取器定位在的书元素的结束标记。  
  
 在关闭新的读取器之前，不应对原始读取器执行任何操作。 不支持此操作，因为这样可能会导致意想不到的行为。  
  
> [!NOTE]
>  <xref:System.Xml.XmlReader.ReadSubtree%2A>方法不适用于 creatingcopies 可以独立使用的 XML 数据。 它的和精心设计创建 XML 元素周围的边界。 如果你想要将数据传递给另一个组件进行处理，并且您希望限制该组件可以访问你的数据，这非常有用。 当传递的 XML 读取器返回的<xref:System.Xml.XmlReader.ReadSubtree%2A>到另一个应用程序，该应用程序的方法可以访问仅该 XML 元素，不是整个 XML 文档。  
  
   
  
## Examples  
 下面的示例显示如何使用 <xref:System.Xml.XmlReader.ReadSubtree%2A> 方法。  
  
 [!code-csharp[XmlReaderBasic#13](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#13)]
 [!code-vb[XmlReaderBasic#13](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#13)]  
  
 使用以下 XML 数据来运行本主题中的示例：  
  
```xml  
<?xml version="1.0" encoding="utf-8" ?>  
<Books>  
  <Book>  
    <Title>A Brief History of Time</Title>  
  </Book>  
  <Book>  
    <Title>Principle Of Relativity</Title>  
  </Book>  
  <Book>  
    <Title>Victory of Reason</Title>  
  </Book>  
  <Book>  
    <Title>The Unicorn that did not Fail</Title>  
  </Book>  
  <Book>  
    <Title>Rational Ontology</Title>  
  </Book>  
  <Book>  
    <Title>The Meaning of Pizza</Title>  
  </Book>  
</Books>  
  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadToDescendant">
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <exception cref="T:System.InvalidOperationException">在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情况下，将引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中”。</exception>
        <summary>让 <see cref="T:System.Xml.XmlReader" /> 前进到下一个匹配的子代元素。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadToDescendant">
      <MemberSignature Language="C#" Value="public virtual bool ReadToDescendant (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool ReadToDescendant(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadToDescendant(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadToDescendant (name As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool ReadToDescendant(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member ReadToDescendant : string -&gt; bool&#xA;override this.ReadToDescendant : string -&gt; bool" Usage="xmlReader.ReadToDescendant name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">要移动到的元素的限定名。</param>
        <summary>让 <see cref="T:System.Xml.XmlReader" /> 前进到下一个具有指定限定名的子代元素。</summary>
        <returns>如果找到匹配的子代元素，则为 <see langword="true" />；否则为 <see langword="false" />。 如果未找到匹配的子元素，<see cref="T:System.Xml.XmlReader" /> 将定位在元素的结束标记（<see cref="P:System.Xml.XmlReader.NodeType" /> 为 <see langword="XmlNodeType.EndElement" />）上。  
  
如果调用 <see cref="T:System.Xml.XmlReader" /> 时没有将 <see cref="M:System.Xml.XmlReader.ReadToDescendant(System.String)" /> 定位在某个元素上，则此方法返回 <see langword="false" /> 且 <see cref="T:System.Xml.XmlReader" /> 的位置保持不变。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下面的示例分析的第二个 book 节点。  
  
 [!code-csharp[XmlReaderBasic#14](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#14)]
 [!code-vb[XmlReaderBasic#14](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#14)]  
  
 该示例使用该文件，`2books.xml`作为输入。  
  
 [!code-xml[XML_Core_Files#7](~/samples/snippets/xml/VS_Snippets_Data/XML_Core_Files/XML/2books.xml#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”</exception>
        <exception cref="T:System.ArgumentException">参数是空字符串。</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadToDescendant">
      <MemberSignature Language="C#" Value="public virtual bool ReadToDescendant (string localName, string namespaceURI);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool ReadToDescendant(string localName, string namespaceURI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadToDescendant(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadToDescendant (localName As String, namespaceURI As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool ReadToDescendant(System::String ^ localName, System::String ^ namespaceURI);" />
      <MemberSignature Language="F#" Value="abstract member ReadToDescendant : string * string -&gt; bool&#xA;override this.ReadToDescendant : string * string -&gt; bool" Usage="xmlReader.ReadToDescendant (localName, namespaceURI)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="localName" Type="System.String" />
        <Parameter Name="namespaceURI" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="localName">要移动到的元素的本地名称。</param>
        <param name="namespaceURI">要移动到的元素的命名空间 URI。</param>
        <summary>让 <see cref="T:System.Xml.XmlReader" /> 前进到下一个具有指定的本地名称和命名空间 URI 的子代元素。</summary>
        <returns>如果找到匹配的子代元素，则为 <see langword="true" />；否则为 <see langword="false" />。 如果未找到匹配的子元素，<see cref="T:System.Xml.XmlReader" /> 将定位在元素的结束标记（<see cref="P:System.Xml.XmlReader.NodeType" /> 为 <see langword="XmlNodeType.EndElement" />）上。  
  
如果调用 <see cref="T:System.Xml.XmlReader" /> 时没有将 <see cref="M:System.Xml.XmlReader.ReadToDescendant(System.String,System.String)" /> 定位在某个元素上，则此方法返回 <see langword="false" /> 且 <see cref="T:System.Xml.XmlReader" /> 的位置保持不变。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”</exception>
        <exception cref="T:System.ArgumentNullException">两个参数值均为 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadToFollowing">
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <exception cref="T:System.InvalidOperationException">在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情况下，将引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中”。</exception>
        <summary>一直读取，直到找到命名元素。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadToFollowing">
      <MemberSignature Language="C#" Value="public virtual bool ReadToFollowing (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool ReadToFollowing(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadToFollowing(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadToFollowing (name As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool ReadToFollowing(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member ReadToFollowing : string -&gt; bool&#xA;override this.ReadToFollowing : string -&gt; bool" Usage="xmlReader.ReadToFollowing name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">元素的限定名。</param>
        <summary>一直读取，直到找到具有指定限定名的元素。</summary>
        <returns>如果找到匹配的元素，则为 <see langword="true" />；否则为 <see langword="false" /> 且 <see cref="T:System.Xml.XmlReader" /> 位于文件的末尾。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法是功能上等效执行`following::name`从当前节点的 XPath 表达式。 它提供了在 XML 文档中查找命名的元素的快速方法。 将读取器推进到与指定的名称相匹配，并返回下一个后续元素`true`如果找到匹配的元素。 使用下面的示例中，读取器将读取到指定的元素的第一个实例向前读取时。  
  
```xml  
<!--"sample.xml"-->  
<?xmlversion="1.0">  
   <items>  
      <item xmls="urn:1"/>  
   </items>  
</xml>  
  
```  
  
```csharp  
XmlTextReader reader = newXmlTextReader("sample.xml");  
  
reader.ReadToFollowing("item");  
  
```  
  
 可以在所有节点类型上调用此方法。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”</exception>
        <exception cref="T:System.ArgumentException">参数是空字符串。</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadToFollowing">
      <MemberSignature Language="C#" Value="public virtual bool ReadToFollowing (string localName, string namespaceURI);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool ReadToFollowing(string localName, string namespaceURI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadToFollowing(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadToFollowing (localName As String, namespaceURI As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool ReadToFollowing(System::String ^ localName, System::String ^ namespaceURI);" />
      <MemberSignature Language="F#" Value="abstract member ReadToFollowing : string * string -&gt; bool&#xA;override this.ReadToFollowing : string * string -&gt; bool" Usage="xmlReader.ReadToFollowing (localName, namespaceURI)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="localName" Type="System.String" />
        <Parameter Name="namespaceURI" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="localName">元素的本地名称。</param>
        <param name="namespaceURI">元素的命名空间 URI。</param>
        <summary>一直读取，直到找到具有指定的本地名称和命名空间 URI 的元素。</summary>
        <returns>如果找到匹配的元素，则为 <see langword="true" />；否则为 <see langword="false" /> 且 <see cref="T:System.Xml.XmlReader" /> 位于文件的末尾。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法是功能上等效执行`following::name`从当前节点的 XPath 表达式。 它提供了在 XML 文档中查找命名的元素的快速方法。 将读取器推进到与指定的名称相匹配，并返回下一个后续元素`true`如果找到匹配的元素。  
  
```xml  
<!--"sample.xml"-->  
<?xmlversion="1.0">  
   <items>  
      <item xmls="urn:1"/>  
   </items>  
</xml>  
  
```  
  
```csharp  
XmlTextReader reader = newXmlTextReader("sample.xml");  
  
reader.ReadToFollowing("item", "urn:1");  
  
```  
  
 可以在所有节点类型上调用此方法。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”</exception>
        <exception cref="T:System.ArgumentNullException">两个参数值均为 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadToNextSibling">
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <exception cref="T:System.InvalidOperationException">在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情况下，将引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中”。</exception>
        <summary>让 <see langword="XmlReader" /> 前进到下一个匹配的同级元素。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadToNextSibling">
      <MemberSignature Language="C#" Value="public virtual bool ReadToNextSibling (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool ReadToNextSibling(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadToNextSibling(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadToNextSibling (name As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool ReadToNextSibling(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member ReadToNextSibling : string -&gt; bool&#xA;override this.ReadToNextSibling : string -&gt; bool" Usage="xmlReader.ReadToNextSibling name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">要移动到的同级元素的限定名。</param>
        <summary>让 <see langword="XmlReader" /> 前进到下一个具有指定限定名的同级元素。</summary>
        <returns>如果找到匹配的同级元素，则为 <see langword="true" />；否则为 <see langword="false" />。 如果没有找到匹配的同级元素，<see langword="XmlReader" /> 会定位在父元素的结束标记（<see cref="P:System.Xml.XmlReader.NodeType" /> 为 <see langword="XmlNodeType.EndElement" />）上。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  不要调用<xref:System.Xml.XmlReader.ReadToNextSibling%2A>时`XmlReader`是初始状态 (<xref:System.Xml.XmlReader.ReadState%2A>是<xref:System.Xml.ReadState.Initial>)。 您可以调用<xref:System.Xml.XmlReader.Read%2A>以前进`XmlReader`，然后调用<xref:System.Xml.XmlReader.ReadToNextSibling%2A>方法。  
  
   
  
## Examples  
 下面的示例读取每个 book 节点上的 ISBN 属性。  
  
 [!code-csharp[XmlReaderBasic#15](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#15)]
 [!code-vb[XmlReaderBasic#15](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#15)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”</exception>
        <exception cref="T:System.ArgumentException">参数是空字符串。</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadToNextSibling">
      <MemberSignature Language="C#" Value="public virtual bool ReadToNextSibling (string localName, string namespaceURI);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool ReadToNextSibling(string localName, string namespaceURI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadToNextSibling(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadToNextSibling (localName As String, namespaceURI As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool ReadToNextSibling(System::String ^ localName, System::String ^ namespaceURI);" />
      <MemberSignature Language="F#" Value="abstract member ReadToNextSibling : string * string -&gt; bool&#xA;override this.ReadToNextSibling : string * string -&gt; bool" Usage="xmlReader.ReadToNextSibling (localName, namespaceURI)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="localName" Type="System.String" />
        <Parameter Name="namespaceURI" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="localName">要移动到的同级元素的本地名称。</param>
        <param name="namespaceURI">你希望移动到的同级元素的命名空间 URI。</param>
        <summary>将 <see langword="XmlReader" /> 推进到具有指定的本地名称和命名空间 URI 的下一个同级元素。</summary>
        <returns>如果找到匹配的同级元素，则为 <see langword="true" />；否则为 <see langword="false" />。 如果没有找到匹配的同级元素，<see langword="XmlReader" /> 会定位在父元素的结束标记（<see cref="P:System.Xml.XmlReader.NodeType" /> 为 <see langword="XmlNodeType.EndElement" />）上。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  不要调用<xref:System.Xml.XmlReader.ReadToNextSibling%2A>时`XmlReader`是初始状态 (<xref:System.Xml.XmlReader.ReadState%2A>是<xref:System.Xml.ReadState.Initial>)。 您可以调用<xref:System.Xml.XmlReader.Read%2A>以前进`XmlReader`，然后调用<xref:System.Xml.XmlReader.ReadToNextSibling%2A>方法。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”</exception>
        <exception cref="T:System.ArgumentNullException">两个参数值均为 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadValueChunk">
      <MemberSignature Language="C#" Value="public virtual int ReadValueChunk (char[] buffer, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 ReadValueChunk(char[] buffer, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadValueChunk(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadValueChunk (buffer As Char(), index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int ReadValueChunk(cli::array &lt;char&gt; ^ buffer, int index, int count);" />
      <MemberSignature Language="F#" Value="abstract member ReadValueChunk : char[] * int * int -&gt; int&#xA;override this.ReadValueChunk : char[] * int * int -&gt; int" Usage="xmlReader.ReadValueChunk (buffer, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Char[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">作为文本内容写入到的缓冲区的字符数组。 此值不能为 <see langword="null" />。</param>
        <param name="index">缓冲区中的偏移量，<see cref="T:System.Xml.XmlReader" /> 可以从这个位置开始复制结果。</param>
        <param name="count">要复制到缓冲区中的最大字符数。 此方法返回复制的实际字符数。</param>
        <summary>读取嵌入在 XML 文档中的大量文本流。</summary>
        <returns>读取到缓冲区中的字符数。 如果不再有文本内容，则返回值零。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法，读取非常大的文本流以流的形式，即，XML 文档中嵌入的少量一次而不是为整个值分配单个字符串的字符。 可以具有值的任何节点上调用此方法 (<xref:System.Xml.XmlReader.HasValue%2A>是`true`)，但实际的节点值只会发生流式处理文本、 空白和有效空白节点上调用时。 其他节点类型的值进行缓存，包括属性和 CDATA 节点。  
  
 此方法返回的内容<xref:System.Xml.XmlReader.Value%2A>属性并不会移动<xref:System.Xml.XmlReader>。  
  
 此方法读取指定的数量的字符 (`count`) 的字符缓冲区的节点值 (`buffer`) 指定的偏移量处 (`index`)，并返回写入到缓冲区的字符数。 它将返回`0`当它达到值的末尾。 它不能重启以再次读取该值。  
  
 在调用之间<xref:System.Xml.XmlReader.ReadValueChunk%2A><xref:System.Xml.XmlReader>属性不会更改除<xref:System.Xml.XmlReader.Value%2A>属性。 时<xref:System.Xml.XmlReader.Value%2A>属性访问它也可能返回的部分值 (包含字符尚不支持返回<xref:System.Xml.XmlReader.ReadValueChunk%2A>) 或全部值，具体取决于实现。 所有<xref:System.Xml.XmlReader>中的实现<xref:System.Xml>命名空间部分为返回值<xref:System.Xml.XmlReader.Value%2A>属性实现。  
  
 任何读取方法可以调用之间调用<xref:System.Xml.XmlReader.ReadValueChunk%2A>。 如果发生这种情况，<xref:System.Xml.XmlReader>移动到下<xref:System.Xml.XmlNodeType>中的流，并且还未返回任何字符被跳过。  
  
 可能有一种情况时<xref:System.Xml.XmlReader.ReadValueChunk%2A>返回请求的字符数小于。 例如，如果在位置 127 和 128 将代理项对具有 200 个字符长值，您调用<xref:System.Xml.XmlReader.ReadValueChunk%2A>128 个字符的缓冲区，使用方法调用将返回而不是请求 128 127 个字符。 则将在下一步中返回的代理项对<xref:System.Xml.XmlReader.ReadValueChunk%2A>调用。 在这种情况下，<xref:System.Xml.XmlReader.ReadValueChunk%2A>未返回所请求的 128 个字符，因为这样做因此将导致在缓冲区末尾的不完整代理项对。  
  
 此方法的异步版本，请参阅<xref:System.Xml.XmlReader.ReadValueChunkAsync%2A>。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> 值为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">缓冲区中的索引或者索引与计数之和大于分配的缓冲区大小。</exception>
        <exception cref="T:System.NotSupportedException">
          <see cref="T:System.Xml.XmlReader" /> 实现不支持此方法。</exception>
        <exception cref="T:System.Xml.XmlException">XML 数据不是格式良好的。</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadValueChunkAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;int&gt; ReadValueChunkAsync (char[] buffer, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;int32&gt; ReadValueChunkAsync(char[] buffer, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadValueChunkAsync(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadValueChunkAsync (buffer As Char(), index As Integer, count As Integer) As Task(Of Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task&lt;int&gt; ^ ReadValueChunkAsync(cli::array &lt;char&gt; ^ buffer, int index, int count);" />
      <MemberSignature Language="F#" Value="abstract member ReadValueChunkAsync : char[] * int * int -&gt; System.Threading.Tasks.Task&lt;int&gt;&#xA;override this.ReadValueChunkAsync : char[] * int * int -&gt; System.Threading.Tasks.Task&lt;int&gt;" Usage="xmlReader.ReadValueChunkAsync (buffer, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Char[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">作为文本内容写入到的缓冲区的字符数组。 此值不能为 <see langword="null" />。</param>
        <param name="index">缓冲区中的偏移量，<see cref="T:System.Xml.XmlReader" /> 可以从这个位置开始复制结果。</param>
        <param name="count">要复制到缓冲区中的最大字符数。 此方法返回复制的实际字符数。</param>
        <summary>异步读取嵌入在 XML 文档中的大量文本流。</summary>
        <returns>读取到缓冲区中的字符数。 如果不再有文本内容，则返回值零。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 这是异步版本<xref:System.Xml.XmlReader.ReadValueChunk%2A>，具有相同功能。 若要使用此方法，必须设置<xref:System.Xml.XmlReaderSettings.Async%2A>标记，用于`true`。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">调用了 <see cref="T:System.Xml.XmlReader" /> 异步方法，但未将 <see cref="P:System.Xml.XmlReaderSettings.Async" /> 标志设置为 <see langword="true" />。 在此情况下，将引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“若要使用 Async 方法，请将 XmlReaderSettings.Async 设置为 True。”</exception>
        <related type="Article" href="http://msdn.microsoft.com/library/db854f91-ccef-4035-ae4d-0911fde808c7">使用 Async 和 Await 的异步编程（C# 和 Visual Basic）</related>
      </Docs>
    </Member>
    <Member MemberName="ResolveEntity">
      <MemberSignature Language="C#" Value="public abstract void ResolveEntity ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ResolveEntity() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ResolveEntity" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Sub ResolveEntity ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void ResolveEntity();" />
      <MemberSignature Language="F#" Value="abstract member ResolveEntity : unit -&gt; unit" Usage="xmlReader.ResolveEntity " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>当在派生类中被重写时，解析 <see langword="EntityReference" /> 节点的实体引用。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果读取器定位在`EntityReference`节点 (`XmlNodeType.EntityReference`)，如果<xref:System.Xml.XmlReader.Read%2A>之后的调用此方法中，实体替换文本进行分析。 完成实体替换文本后，`EndEntity`返回节点关闭实体引用作用域。  
  
> [!NOTE]
>  调用此方法后，如果实体是一部分的属性值，则必须调用<xref:System.Xml.XmlReader.ReadAttributeValue%2A>来单步执行该实体。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”</exception>
        <altmember cref="T:System.Xml.EntityHandling" />
        <altmember cref="P:System.Xml.XmlReader.CanResolveEntity" />
      </Docs>
    </Member>
    <Member MemberName="SchemaInfo">
      <MemberSignature Language="C#" Value="public virtual System.Xml.Schema.IXmlSchemaInfo SchemaInfo { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xml.Schema.IXmlSchemaInfo SchemaInfo" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.SchemaInfo" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property SchemaInfo As IXmlSchemaInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Xml::Schema::IXmlSchemaInfo ^ SchemaInfo { System::Xml::Schema::IXmlSchemaInfo ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SchemaInfo : System.Xml.Schema.IXmlSchemaInfo" Usage="System.Xml.XmlReader.SchemaInfo" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Schema.IXmlSchemaInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取作为架构验证结果分配给当前节点的架构信息。</summary>
        <value>一个包含当前节点的架构信息的 <see cref="T:System.Xml.Schema.IXmlSchemaInfo" /> 对象。 架构信息可以在元素、特性或具有非空 <see cref="P:System.Xml.XmlReader.ValueType" />（类型化值）的文本节点上设置。  
  
如果当前节点不属于上述节点类型，或者如果 <see langword="XmlReader" /> 实例未报告架构信息，则此属性返回 <see langword="null" />。  
  
如果从 <see cref="T:System.Xml.XmlTextReader" /> 或 <see cref="T:System.Xml.XmlValidatingReader" /> 对象调用此属性，则此属性总是返回 <see langword="null" />。 这些 <see langword="XmlReader" /> 实现不会通过 <see langword="SchemaInfo" /> 属性公开架构信息。  
  
 <block subset="none" type="note"><para>  
 如果必须为某个元素获取架构验证后信息集 (PSVI)，请在此元素的结束标记处（而不是在开始标记处）放置读取器。 您可以通过读取器的 <see langword="SchemaInfo" /> 属性获取 PSVI。 通过 <see cref="Overload:System.Xml.XmlReader.Create" /> 并使用设置为 <see cref="P:System.Xml.XmlReaderSettings.ValidationType" /> 的 <see cref="F:System.Xml.ValidationType.Schema" /> 属性创建的验证读取器具有完整的 PSVI，仅在将读取器放置在元素的结束标记处时，此 PSVI 才对元素可用。  
  
</para></block></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Xml.Schema.IXmlSchemaInfo>接口中公开一部分的后架构验证信息集 (PSVI) 与 XML 节点关联。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”</exception>
      </Docs>
    </Member>
    <Member MemberName="Settings">
      <MemberSignature Language="C#" Value="public virtual System.Xml.XmlReaderSettings Settings { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xml.XmlReaderSettings Settings" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.Settings" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Settings As XmlReaderSettings" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Xml::XmlReaderSettings ^ Settings { System::Xml::XmlReaderSettings ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Settings : System.Xml.XmlReaderSettings" Usage="System.Xml.XmlReader.Settings" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlReaderSettings</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取用于创建此 <see cref="T:System.Xml.XmlReader" /> 实例的 <see cref="T:System.Xml.XmlReaderSettings" /> 对象。</summary>
        <value>用于创建此读取器实例的 <see cref="T:System.Xml.XmlReaderSettings" /> 对象。 如果此读取器不是使用 <see cref="Overload:System.Xml.XmlReader.Create" /> 方法创建的，则此属性返回 <see langword="null" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  <xref:System.Xml.XmlReaderSettings>对象可以包含敏感信息，如用户凭据。 应用程序时一定要谨慎缓存此对象或将其传递到另一个组件。  
  
 <xref:System.Xml.XmlReaderSettings>类用于指定要创建的读取器实例上支持的功能集。 <xref:System.Xml.XmlReaderSettings>不能修改此属性返回的对象。 任何尝试更改单个设置导致引发异常。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”</exception>
      </Docs>
    </Member>
    <Member MemberName="Skip">
      <MemberSignature Language="C#" Value="public virtual void Skip ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Skip() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.Skip" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Skip ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Skip();" />
      <MemberSignature Language="F#" Value="abstract member Skip : unit -&gt; unit&#xA;override this.Skip : unit -&gt; unit" Usage="xmlReader.Skip " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>跳过当前节点的子级。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在下面的 XML 输入，是否读取器定位在`<a>`节点或其属性、 调用任一`Skip`定位到读取器`<b>`节点。  
  
 如果读取器定位在叶节点上已 (如`<x>`节点或文本节点`abc`)，则调用`Skip`等同于调用<xref:System.Xml.XmlReader.Read%2A>。  
  
```xml  
<a name="bob" age="123">  
 <x/>abc<y/>  
</a>  
<b>  
...  
</b>  
```  
  
 此方法会检查格式正确的 XML。  
  
 如果读取器<xref:System.Xml.XmlValidatingReader>，此方法还可验证已跳过的内容。  
  
 `XmlReader`实现确定是否`Skip`方法将扩展外部实体。 下表描述了是否为各种类型的扩展的外部实体`XmlReader`对象。  
  
|XmlReader 的类型|展开外部实体|  
|-----------------------|-------------------------------|  
|<xref:System.Xml.XmlTextReader>|不是。|  
|<xref:System.Xml.XmlReader> 创建实例<xref:System.Xml.XmlReader.Create%2A>正在读取的文本数据的方法。|不是。|  
|<xref:System.Xml.XmlReader> 创建实例<xref:System.Xml.XmlReader.Create%2A>正在读取的二进制数据的方法。|不适用。|  
|架构验证<xref:System.Xml.XmlReader>实例创建的<xref:System.Xml.XmlReader.Create%2A>方法。|可以。|  
|<xref:System.Xml.XmlValidatingReader>|可以。|  
|<xref:System.Xml.XmlReader> 返回实例<xref:System.Xml.XPath.XPathNavigator>对象。|不适用。|  
|<xref:System.Xml.XmlNodeReader>|不是。|  
|<xref:System.Xml.XmlReader> 实例包装在另一个<xref:System.Xml.XmlReader>实例。|取决于基础实现<xref:System.Xml.XmlReader>。 (`Skip`方法对基础<xref:System.Xml.XmlReader>称为)。|  
  
 此方法的异步版本，请参阅<xref:System.Xml.XmlReader.SkipAsync%2A>。  
  
   
  
## Examples  
 下面的示例分析 XML 文件的第二个 book 节点上启动。  
  
 [!code-csharp[XmlReaderBasic#14](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#14)]
 [!code-vb[XmlReaderBasic#14](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#14)]  
  
 该示例使用该文件，`2books.xml`作为输入。  
  
 [!code-xml[XML_Core_Files#7](~/samples/snippets/xml/VS_Snippets_Data/XML_Core_Files/XML/2books.xml#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”</exception>
      </Docs>
    </Member>
    <Member MemberName="SkipAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task SkipAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task SkipAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.SkipAsync" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function SkipAsync () As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task ^ SkipAsync();" />
      <MemberSignature Language="F#" Value="abstract member SkipAsync : unit -&gt; System.Threading.Tasks.Task&#xA;override this.SkipAsync : unit -&gt; System.Threading.Tasks.Task" Usage="xmlReader.SkipAsync " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>异步跳过当前节点的子级。</summary>
        <returns>当前节点。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 这是异步版本<xref:System.Xml.XmlReader.Skip%2A>，具有相同功能。 若要使用此方法，必须设置<xref:System.Xml.XmlReaderSettings.Async%2A>标记，用于`true`。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">调用了 <see cref="T:System.Xml.XmlReader" /> 异步方法，但未将 <see cref="P:System.Xml.XmlReaderSettings.Async" /> 标志设置为 <see langword="true" />。 在此情况下，将引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“若要使用 Async 方法，请将 XmlReaderSettings.Async 设置为 True。”</exception>
        <related type="Article" href="http://msdn.microsoft.com/library/db854f91-ccef-4035-ae4d-0911fde808c7">使用 Async 和 Await 的异步编程（C# 和 Visual Basic）</related>
      </Docs>
    </Member>
    <Member MemberName="System.IDisposable.Dispose">
      <MemberSignature Language="C#" Value="void IDisposable.Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.IDisposable.Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.System#IDisposable#Dispose" />
      <MemberSignature Language="VB.NET" Value="Sub Dispose () Implements IDisposable.Dispose" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.IDisposable.Dispose() = IDisposable::Dispose;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>有关此成员的说明，请参阅 <see cref="M:System.IDisposable.Dispose" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

此成员是显式的接口成员实现。 它只能在 <xref:System.Xml.XmlReader> 实例强制转换为 <xref:System.IDisposable> 接口时使用。

此成员的行为可能以不同的方式中使用时[可移植类库](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md)项目。 有关详细信息，请参阅[可移植类库中的 API 差异](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/gg597392(v=vs.100))。

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Value">
      <MemberSignature Language="C#" Value="public abstract string Value { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Value" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.Value" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property Value As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::String ^ Value { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Value : string" Usage="System.Xml.XmlReader.Value" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当在派生类中被重写时，获取当前节点的文本值。</summary>
        <value>返回的值取决于节点的 <see cref="P:System.Xml.XmlReader.NodeType" />。 下表列出具有要返回的值的节点类型。 所有其他节点类型返回 <see langword="String.Empty" />。  
  
 <list type="table"><listheader><term> 节点类型 
 </term><description> “值” 
 </description></listheader><item><term><see langword="Attribute" /></term><description> 属性的值。  
  
 </description></item><item><term><see langword="CDATA" /></term><description> CDATA 节的内容。  
  
 </description></item><item><term><see langword="Comment" /></term><description> 注释的内容。  
  
 </description></item><item><term><see langword="DocumentType" /></term><description> 内部子集。  
  
 </description></item><item><term><see langword="ProcessingInstruction" /></term><description> 全部内容（不包括指令目标）。  
  
 </description></item><item><term><see langword="SignificantWhitespace" /></term><description> 混合内容模型中标记之间的空白。  
  
 </description></item><item><term><see langword="Text" /></term><description> 文本节点的内容。  
  
 </description></item><item><term><see langword="Whitespace" /></term><description> 标记之间的空白。  
  
 </description></item><item><term><see langword="XmlDeclaration" /></term><description> 声明的内容。  
  
 </description></item></list></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此属性的异步版本，请参阅<xref:System.Xml.XmlReader.GetValueAsync%2A>方法。  
  
   
  
## Examples  
 下面的示例读取 XML 文件，并显示每个节点。  
  
 [!code-csharp[XmlReaderBasic#8](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#8)]
 [!code-vb[XmlReaderBasic#8](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#8)]  
  
 此示例使用`items.xml`文件。  
  
 [!code-xml[XML_Core_Files#2](~/samples/snippets/xml/VS_Snippets_Data/XML_Core_Files/XML/items.xml#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”</exception>
      </Docs>
    </Member>
    <Member MemberName="ValueType">
      <MemberSignature Language="C#" Value="public virtual Type ValueType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type ValueType" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.ValueType" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property ValueType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ ValueType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ValueType : Type" Usage="System.Xml.XmlReader.ValueType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取当前节点的公共语言运行时 (CLR) 类型。</summary>
        <value>与节点的类型化值对应的 CLR 类型。 默认值为 <see langword="System.String" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 请参阅[System.Xml 类中的类型支持](~/docs/standard/data/xml/type-support-in-the-system-xml-classes.md)有关默认映射的列表。  
  
 类型的元素`xs:int`已`ValueType`的`System.Int32`默认情况下。 但是，`ValueType`可能是可以映射到的有效类型之一`xs:int`，如`System.Int16`或`System.Double`。  
  
 如果节点为非类型化，或者如果节点是一个包含混合的内容的元素，则节点值映射到`System.String`类型。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”</exception>
        <block subset="none" type="overrides">
          <para>实施者必须提供<see langword="ValueType" />对于每个节点，即使它只是<see langword="System.String" />类型。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="XmlLang">
      <MemberSignature Language="C#" Value="public virtual string XmlLang { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string XmlLang" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.XmlLang" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property XmlLang As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ XmlLang { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.XmlLang : string" Usage="System.Xml.XmlReader.XmlLang" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当在派生类中被重写时，获取当前的 <see langword="xml:lang" /> 范围。</summary>
        <value>当前 <see langword="xml:lang" /> 范围。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此属性表示`xml:lang`中当前节点所在作用域。 例如，下面是与 XML 片段`xml:lang`设置为美国英语的根元素中：  
  
```xml  
<root xml:lang="en-us">   
<name>Fred</name>   
</root>   
```  
  
 当读取器定位在`name`元素中，您可以使用此属性以发现它是美国英语的作用域中`xml:lang`属性。  
  
   
  
## Examples  
 请参阅<xref:System.Xml.XmlTextReader.XmlLang%2A?displayProperty=nameWithType>有关使用此属性的示例。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”</exception>
        <altmember cref="P:System.Xml.XmlReader.XmlSpace" />
      </Docs>
    </Member>
    <Member MemberName="XmlSpace">
      <MemberSignature Language="C#" Value="public virtual System.Xml.XmlSpace XmlSpace { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Xml.XmlSpace XmlSpace" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.XmlSpace" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property XmlSpace As XmlSpace" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Xml::XmlSpace XmlSpace { System::Xml::XmlSpace get(); };" />
      <MemberSignature Language="F#" Value="member this.XmlSpace : System.Xml.XmlSpace" Usage="System.Xml.XmlReader.XmlSpace" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlSpace</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当在派生类中被重写时，获取当前的 <see langword="xml:space" /> 范围。</summary>
        <value>
          <see cref="T:System.Xml.XmlSpace" /> 值之一。 如果不存在任何 <see langword="xml:space" /> 范围，则该属性默认值为 <see langword="XmlSpace.None" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 请参阅<xref:System.Xml.XmlTextReader.XmlSpace%2A>(在`XmlTextReader`类) 使用此属性的示例。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”</exception>
        <altmember cref="P:System.Xml.XmlReader.XmlLang" />
      </Docs>
    </Member>
  </Members>
</Type>