<Type Name="XmlReaderSettings" FullName="System.Xml.XmlReaderSettings">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="c213148f0dbb23e978f0919a5769cbf74113221f" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-CN" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36434249" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class XmlReaderSettings" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit XmlReaderSettings extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Xml.XmlReaderSettings" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class XmlReaderSettings" />
  <TypeSignature Language="C++ CLI" Value="public ref class XmlReaderSettings sealed" />
  <TypeSignature Language="F#" Value="type XmlReaderSettings = class" />
  <AssemblyInfo>
    <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Xml</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>指定在由 <see cref="T:System.Xml.XmlReader" /> 方法创建的 <see cref="Overload:System.Xml.XmlReader.Create" /> 对象上支持的一组功能。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 你使用<xref:System.Xml.XmlReader.Create%2A>方法来获取<xref:System.Xml.XmlReader>实例。 此方法使用<xref:System.Xml.XmlReaderSettings>类，以指定要在中实现的功能<xref:System.Xml.XmlReader>对象创建。  
  
 请参阅备注部分的<xref:System.Xml.XmlReader>和<xref:System.Xml.XmlReader.Create%2A>引用有关要用于一致性检查、 验证和其他常见方案的设置信息的页面。 请参阅<xref:System.Xml.XmlReaderSettings.%23ctor>构造函数的默认设置的列表。  
  
## <a name="security-considerations"></a>安全注意事项  
 使用时，请考虑以下<xref:System.Xml.XmlReaderSettings>类。  
  
-   默认情况下不设置 <xref:System.Xml.Schema.XmlSchemaValidationFlags.ProcessInlineSchema> 对象的 <xref:System.Xml.Schema.XmlSchemaValidationFlags.ProcessSchemaLocation> 和 <xref:System.Xml.XmlReaderSettings> 验证标志。 设置了这些标志后，<xref:System.Xml.XmlReaderSettings.XmlResolver%2A> 对象的 <xref:System.Xml.XmlReaderSettings> 用于在 <xref:System.Xml.XmlReader> 中解析实例文档中遇到的架构位置。 如果<xref:System.Xml.XmlReaderSettings.XmlResolver%2A>对象是`null`，则不解析架构位置即使<xref:System.Xml.Schema.XmlSchemaValidationFlags.ProcessInlineSchema>和<xref:System.Xml.Schema.XmlSchemaValidationFlags.ProcessSchemaLocation>设置验证标志。  
  
-   在验证过程中添加的架构会添加新类型，并且可能更改被验证的文档的验证结果。 因此，只应从可信的源解析外部架构。  
  
-   验证错误消息可能会公开敏感的内容模型的信息。 验证错误和警告消息使用处理<xref:System.Xml.Schema.ValidationEventHandler>委托，或作为公开<xref:System.Xml.Schema.XmlSchemaValidationException>如果没有事件处理程序提供给<xref:System.Xml.XmlReaderSettings>对象 (验证警告不会导致<xref:System.Xml.Schema.XmlSchemaValidationException>引发)。 此内容模型信息不应在不受信任的方案中公开。 验证警告消息默认情况下禁止显示，并且可以通过设置报告<xref:System.Xml.Schema.XmlSchemaValidationFlags.ReportValidationWarnings>标志。  
  
-   <xref:System.Xml.Schema.XmlSchemaException.SourceUri%2A>属性<xref:System.Xml.Schema.XmlSchemaValidationException>返回导致异常的架构文件的 URI 路径。 <xref:System.Xml.Schema.XmlSchemaException.SourceUri%2A>不应在不受信任的方案中公开属性。  
  
-   禁用<xref:System.Xml.Schema.XmlSchemaValidationFlags.ProcessIdentityConstraints>高可用性方案中，针对具有标识约束的架构中通过文档的很大程度的验证不受信任的大型 XML 文档时，建议标志 （默认情况下启用）。  
  
-   <xref:System.Xml.XmlReaderSettings> 对象可以包含敏感信息，例如用户凭据。 在缓存 <xref:System.Xml.XmlReaderSettings> 对象时，或在将 <xref:System.Xml.XmlReaderSettings> 对象从一个组件传递到另一个组件时，应小心。  
  
-   默认情况下禁用 DTD 处理。 如果启用 DTD 处理，你需要注意： 包括来自受信任的源和可能的拒绝服务攻击的 Dtd。 使用<xref:System.Xml.XmlSecureResolver>来限制的资源，<xref:System.Xml.XmlReader>可以访问。  
  
-   不接受来自不可信的源的支持组件，例如 <xref:System.Xml.NameTable>、<xref:System.Xml.XmlNamespaceManager> 和 <xref:System.Xml.XmlResolver> 对象。  
  
-   使用 <xref:System.Xml.XmlReader> 的应用程序的内存使用量可能与分析的 XML 文档的大小有关。 拒绝服务攻击的一种形式是提交过大的 XML 文档进行分析。 你可以限制可以通过设置分析的文档的大小<xref:System.Xml.XmlReaderSettings.MaxCharactersInDocument%2A>属性，然后限制通过设置扩展实体产生的字符数<xref:System.Xml.XmlReaderSettings.MaxCharactersFromEntities%2A>属性。  
  
   
  
## Examples  
 下面的示例创建<xref:System.Xml.XmlReader>使用<xref:System.Xml.XmlUrlResolver>使用必要的凭据。  
  
 [!code-csharp[XmlReader.Create#2](~/samples/snippets/csharp/VS_Snippets_Data/XmlReader.Create/CS/XmlReader_Create.cs#2)]
 [!code-vb[XmlReader.Create#2](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReader.Create/VB/XmlReader_Create.vb#2)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>初始化 <see cref="T:System.Xml.XmlReaderSettings" /> 类的新实例。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XmlReaderSettings ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReaderSettings.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XmlReaderSettings();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>初始化 <see cref="T:System.Xml.XmlReaderSettings" /> 类的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表显示的实例的初始属性值<xref:System.Xml.XmlReaderSettings>。  
  
|Property|初始值|  
|--------------|-------------------|  
|<xref:System.Xml.XmlReaderSettings.Async%2A>|`false`。|  
|<xref:System.Xml.XmlReaderSettings.CheckCharacters%2A>|`true`。|  
|<xref:System.Xml.XmlReaderSettings.ConformanceLevel%2A>|<xref:System.Xml.ConformanceLevel.Document>。|  
|<xref:System.Xml.XmlReaderSettings.IgnoreComments%2A>|`false`。|  
|<xref:System.Xml.XmlReaderSettings.IgnoreProcessingInstructions%2A>|`false`。|  
|<xref:System.Xml.XmlReaderSettings.IgnoreWhitespace%2A>|`false`。|  
|<xref:System.Xml.XmlReaderSettings.LineNumberOffset%2A>|0.|  
|<xref:System.Xml.XmlReaderSettings.LinePositionOffset%2A>|0.|  
|<xref:System.Xml.XmlReaderSettings.MaxCharactersFromEntities%2A>|（没有扩展实体产生的字符数没有限制） 为 0。|  
|<xref:System.Xml.XmlReaderSettings.MaxCharactersInDocument%2A>|0 （在 XML 文档的大小没有限制）。|  
|<xref:System.Xml.XmlReaderSettings.NameTable%2A>|`null`。|  
|<xref:System.Xml.XmlTextReader.DtdProcessing%2A>|<xref:System.Xml.DtdProcessing.Prohibit>|  
|<xref:System.Xml.XmlReaderSettings.ProhibitDtd%2A>|`true`。 此属性已过时。 请改用 <xref:System.Xml.XmlTextReader.DtdProcessing%2A>。 如果已设置<xref:System.Xml.XmlReaderSettings.ProhibitDtd%2A>为其默认值`true`设置<xref:System.Xml.XmlTextReader.DtdProcessing%2A>到`Prohibit`。 如果已设置<xref:System.Xml.XmlReaderSettings.ProhibitDtd%2A>到`false`设置<xref:System.Xml.XmlTextReader.DtdProcessing%2A>到`Parse`。|  
|<xref:System.Xml.XmlReaderSettings.Schemas%2A>|一个空 <xref:System.Xml.Schema.XmlSchemaSet> 对象。|  
|<xref:System.Xml.XmlReaderSettings.ValidationFlags%2A>|<xref:System.Xml.Schema.XmlSchemaValidationFlags.ProcessIdentityConstraints>。|  
|<xref:System.Xml.XmlReaderSettings.ValidationType%2A>|<xref:System.Xml.ValidationType.None>。|  
|<xref:System.Xml.XmlReaderSettings.XmlResolver%2A>|一个新 <xref:System.Xml.XmlUrlResolver> 对象。|  
  
   
  
## Examples  
 以下命令将创建可用于构造去除处理指令、 注释和无关紧要的空白区域的读取器的设置对象。  
  
 [!code-cpp[XmlReaderSettings.cctor#1](~/samples/snippets/cpp/VS_Snippets_Data/XmlReaderSettings.cctor/CPP/XmlReaderSettings.cctor.cpp#1)]
 [!code-csharp[XmlReaderSettings.cctor#1](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderSettings.cctor/CS/factory_rdr_cctor2.cs#1)]
 [!code-vb[XmlReaderSettings.cctor#1](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderSettings.cctor/VB/factory_rdr_cctor2.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.XmlReader" />
        <altmember cref="M:System.Xml.XmlReader.Create(System.String)" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XmlReaderSettings (System.Xml.XmlResolver resolver);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Xml.XmlResolver resolver) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReaderSettings.#ctor(System.Xml.XmlResolver)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (resolver As XmlResolver)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XmlReaderSettings(System::Xml::XmlResolver ^ resolver);" />
      <MemberSignature Language="F#" Value="new System.Xml.XmlReaderSettings : System.Xml.XmlResolver -&gt; System.Xml.XmlReaderSettings" Usage="new System.Xml.XmlReaderSettings resolver" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("This API supports the .NET Framework infrastructure and is not intended to be used directly from your code.", true)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="resolver" Type="System.Xml.XmlResolver" />
      </Parameters>
      <Docs>
        <param name="resolver">XML 解析器。</param>
        <summary>初始化 <see cref="T:System.Xml.XmlReaderSettings" /> 类的新实例。</summary>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.Xml.XmlReader" />
        <altmember cref="M:System.Xml.XmlReader.Create(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Async">
      <MemberSignature Language="C#" Value="public bool Async { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Async" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReaderSettings.Async" />
      <MemberSignature Language="VB.NET" Value="Public Property Async As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Async { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Async : bool with get, set" Usage="System.Xml.XmlReaderSettings.Async" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置是否可对特定 <see cref="T:System.Xml.XmlReader" /> 实例使用异步 <see cref="T:System.Xml.XmlReader" /> 方法。</summary>
        <value>则可以使用异步方法，则为 <see langword="true" />；否则，为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 必须将此值设置为`true`当你创建一个新<xref:System.Xml.XmlReader>实例如果你想要使用异步<xref:System.Xml.XmlReader>该实例上的方法。 后<xref:System.Xml.XmlReader>创建实例，<xref:System.Xml.XmlReaderSettings.Async%2A>属性是只读的。 此属性的默认值为 `false`。  
  
 通过将忽略此标志<xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType>重载。 这意味着，如果你创建一个新<xref:System.Xml.XmlReader>基于现有<xref:System.Xml.XmlReader>，异步行为取决于输入<xref:System.Xml.XmlReader>，并且不能使用<xref:System.Xml.XmlReaderSettings.Async%2A>更改异步行为的标志。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CheckCharacters">
      <MemberSignature Language="C#" Value="public bool CheckCharacters { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CheckCharacters" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReaderSettings.CheckCharacters" />
      <MemberSignature Language="VB.NET" Value="Public Property CheckCharacters As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CheckCharacters { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.CheckCharacters : bool with get, set" Usage="System.Xml.XmlReaderSettings.CheckCharacters" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值指示是否进行字符检查。</summary>
        <value>如果进行字符检查，则为 <see langword="true" />；否则为 <see langword="false" />。 默认值为 <see langword="true" />。  
  
 <block subset="none" type="note"><para> 如果<see cref="T:System.Xml.XmlReader" />是处理文本数据时，它始终检查的 XML 名称和文本内容是否有效，而不考虑属性设置。设置<see cref="P:System.Xml.XmlReaderSettings.CheckCharacters" />到<see langword="false" />关闭检查的字符实体引用的字符。  </para></block></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此属性指示要检查的 XML 数据中进行读取，并引发中的字符的 XML 读取器<xref:System.Xml.XmlException>如果任何字符都是合法的 XML 字符范围之外。 如果启用字符检查，必须确保符合下列条件：  
  
-   字符都是合法的 XML 字符，范围内，定义[2.2 字符](https://www.w3.org/TR/2006/REC-xml-20060816/#charsets)W3C XML 1.0 建议的部分。  
  
-   按照定义，所有 XML 名称都是否有效， [2.3 常见语法构造](https://www.w3.org/TR/2006/REC-xml-20060816/#NT-Name)W3C XML 1.0 建议的部分。  
  
 当此属性设置为`true`，这是默认设置，<xref:System.Xml.XmlException>如果 XML 文件包含非法字符或无效的 XML 名称将引发异常 （例如，元素名称与大量开始）。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public System.Xml.XmlReaderSettings Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Xml.XmlReaderSettings Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReaderSettings.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Function Clone () As XmlReaderSettings" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Xml::XmlReaderSettings ^ Clone();" />
      <MemberSignature Language="F#" Value="member this.Clone : unit -&gt; System.Xml.XmlReaderSettings" Usage="xmlReaderSettings.Clone " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlReaderSettings</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>创建 <see cref="T:System.Xml.XmlReaderSettings" /> 实例的副本。</summary>
        <returns>克隆的 <see cref="T:System.Xml.XmlReaderSettings" /> 对象。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 克隆<xref:System.Xml.XmlReaderSettings>而不会影响原始对象上的设置可以修改对象。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.XmlReader" />
        <altmember cref="M:System.Xml.XmlReader.Create(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CloseInput">
      <MemberSignature Language="C#" Value="public bool CloseInput { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CloseInput" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReaderSettings.CloseInput" />
      <MemberSignature Language="VB.NET" Value="Public Property CloseInput As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CloseInput { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.CloseInput : bool with get, set" Usage="System.Xml.XmlReaderSettings.CloseInput" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值指示当读取器关闭时，是否应关闭基础流或 <see cref="T:System.IO.TextReader" />。</summary>
        <value>如果当读取器关闭时基础流或 <see cref="T:System.IO.TextReader" /> 也应关闭，则为 <see langword="true" />；否则为 <see langword="false" />。 默认值为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当流时使用此设置或<xref:System.IO.TextReader>传递给<xref:System.Xml.XmlReader.Create%2A>方法。 如果流由其自己的处理的读取器创建，如在使用一个 URI 或在打开外部文档类型定义时，创建读取器，它始终关闭读取器关闭时。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ConformanceLevel">
      <MemberSignature Language="C#" Value="public System.Xml.ConformanceLevel ConformanceLevel { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Xml.ConformanceLevel ConformanceLevel" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReaderSettings.ConformanceLevel" />
      <MemberSignature Language="VB.NET" Value="Public Property ConformanceLevel As ConformanceLevel" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xml::ConformanceLevel ConformanceLevel { System::Xml::ConformanceLevel get(); void set(System::Xml::ConformanceLevel value); };" />
      <MemberSignature Language="F#" Value="member this.ConformanceLevel : System.Xml.ConformanceLevel with get, set" Usage="System.Xml.XmlReaderSettings.ConformanceLevel" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.ConformanceLevel</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置 <see cref="T:System.Xml.XmlReader" /> 将遵循的一致性级别。</summary>
        <value>指定一致性级别（XML 读取器将强制该级别）的枚举值之一。 默认值为 <see cref="F:System.Xml.ConformanceLevel.Document" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 通过创建的 XML 读取器<xref:System.Xml.XmlReader.Create%2A>方法默认情况下满足以下的法规遵从性要求：  
  
-   新行和属性值进行规范化根据 W3C [XML 1.0 建议](https://www.w3.org/TR/2006/REC-xml-20060816/)。  
  
-   自动展开所有实体。  
  
-   始终添加文档类型定义中声明的默认属性，即使读取器不会验证也是如此。  
  
-   允许的 XML 前缀映射到正确的 XML 命名空间 URI 的声明。  
  
-   在一次的表示法名称`NotationType`特性声明和`NmTokens`在单个`Enumeration`属性声明各不相同。  
  
 你可以使用<xref:System.Xml.XmlReaderSettings.ConformanceLevel%2A>属性来检查并确保正在读取的流符合格式正确的 XML 1.0 文档或文档片段的规则。 如果数据不符，<xref:System.Xml.XmlException>引发异常。 默认值是<xref:System.Xml.ConformanceLevel.Document?displayProperty=nameWithType>（文档级一致性）。  
  
 三个一致性级别包括：  
  
|设置|描述|  
|-------------|-----------------|  
|<xref:System.Xml.ConformanceLevel.Document>|可确保 XML 数据符合格式正确的 XML 1.0 文档的规则。 此检查级别确保任何处理器可以使用作为正在读取的流[格式良好的 XML 1.0 文档](https://www.w3.org/TR/2006/REC-xml-20060816/#sec-well-formed)。<br /><br /> 读取器检查下列事项：<br /><br /> -顶级项不得包含 XML 声明、 文档类型定义 (DTD)、 元素、 注释、 空白区域或处理指令以外的任何节点。<br />XML 数据必须具有恰好一个顶级元素节点。|  
|<xref:System.Xml.ConformanceLevel.Fragment>|可确保 XML 数据符合格式正确的 XML 1.0 文档片段的规则。<br /><br /> 此设置接受包含多个根元素的 XML 数据或位于顶级的文本节点。 此检查级别确保任何处理器可以使用作为正在读取的流[外部分析实体](https://www.w3.org/TR/2006/REC-xml-20060816/#wf-entities)。|  
|<xref:System.Xml.ConformanceLevel.Auto>|指定读取器应确定的一致性检查基于传入数据的级别。<br /><br /> 如果 XML 数据包含 DTD 信息，将应用文档一致性检查。<br /><br /> 如果 XML 数据包含下列某一项，将应用片断一致性检查。<br /><br /> 根级别的文本、 CDATA 或实体引用节点。<br />的在根级别多个元素。<br />的在根级别任何元素。<br /><br /> 如果存在冲突，例如在根级别存在文本节点和 DTD 时，将引发 <xref:System.Xml.XmlException>。<br /><br /> 如果使用 <xref:System.Xml.XmlReader.Create%2A> 方法为现有 <xref:System.Xml.XmlReader> 添加附加功能，可以在包装方案中使用此设置。 在这种情况下，<xref:System.Xml.ConformanceLevel.Document?displayProperty=nameWithType>不会添加任何新的一致性检查。 一致性检查留给正在包装的 <xref:System.Xml.XmlReader>。|  
  
> [!NOTE]
>  如果存在 DTD，XML 1.0 建议要求文档级别的一致性。 因此，如果读取器配置为支持<xref:System.Xml.ConformanceLevel.Fragment?displayProperty=nameWithType>，但 XML 数据包含文档类型定义 (DTD)<xref:System.Xml.XmlException>引发。  
  
 下面是如何读取器处理具体取决于的设置的特定一致性冲突<xref:System.Xml.XmlReaderSettings.ConformanceLevel%2A>属性：  
  
|条件|<xref:System.Xml.ConformanceLevel.Document>|<xref:System.Xml.ConformanceLevel.Fragment>|<xref:System.Xml.ConformanceLevel.Auto>|  
|---------------|---------------------------------------------------------------------------------------------------------------------------------------------------|---------------------------------------------------------------------------------------------------------------------------------------------------|-----------------------------------------------------------------------------------------------------------------------------------------------|  
|文本或类型化的值将显示最高层。|<xref:System.Xml.XmlException> 则会引发。|不被视为违反了为此设置。|不被视为违反了为此设置。|  
|多个元素不显示最高层。|<xref:System.Xml.XmlException> 则会引发。|不被视为违反了为此设置。|不被视为违反了为此设置。|  
|顶级项是空格。|不被视为违反了为此设置。|不被视为违反了为此设置。|不被视为违反了为此设置。|  
|顶级项是 （被识别为文本节点） 的属性。|<xref:System.Xml.XmlException> 则会引发。|不被视为违反了为此设置。|不被视为违反了为此设置。|  
|发现多个连续的文本节点。|不被视为违反了为此设置。|不被视为违反了为此设置。|不被视为违反了为此设置。|  
|在相同的局部范围中两次声明了相同的命名空间前缀。|<xref:System.Xml.XmlException> 则会引发。|<xref:System.Xml.XmlException> 则会引发。|<xref:System.Xml.XmlException> 则会引发。|  
|在本地作用域中不存在的元素或属性中的命名空间。|<xref:System.Xml.XmlException> 则会引发。|<xref:System.Xml.XmlException> 则会引发。|<xref:System.Xml.XmlException> 则会引发。|  
|数据包含前缀和命名空间不匹配。|<xref:System.Xml.XmlException> 则会引发。|<xref:System.Xml.XmlException> 则会引发。|<xref:System.Xml.XmlException> 则会引发。|  
|`xml:space` 属性包含无效值。|<xref:System.Xml.XmlException> 则会引发。|<xref:System.Xml.XmlException> 则会引发。|<xref:System.Xml.XmlException> 则会引发。|  
|遇到无效的名称。|<xref:System.Xml.XmlException> 则会引发。|<xref:System.Xml.XmlException> 则会引发。|<xref:System.Xml.XmlException> 则会引发。|  
|`xml`前缀不符合http://www.w3.org/XML/1998/namespaceURI。|<xref:System.Xml.XmlException> 则会引发。|<xref:System.Xml.XmlException> 则会引发。|<xref:System.Xml.XmlException> 则会引发。|  
  
   
  
## Examples  
 下面的示例创建<xref:System.Xml.XmlReader>读取的 XML 片段的对象。  
  
 [!code-csharp[XmlReader.Create#1](~/samples/snippets/csharp/VS_Snippets_Data/XmlReader.Create/CS/XmlReader_Create.cs#1)]
 [!code-vb[XmlReader.Create#1](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReader.Create/VB/XmlReader_Create.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Xml.XmlReader.Create(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="DtdProcessing">
      <MemberSignature Language="C#" Value="public System.Xml.DtdProcessing DtdProcessing { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Xml.DtdProcessing DtdProcessing" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReaderSettings.DtdProcessing" />
      <MemberSignature Language="VB.NET" Value="Public Property DtdProcessing As DtdProcessing" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xml::DtdProcessing DtdProcessing { System::Xml::DtdProcessing get(); void set(System::Xml::DtdProcessing value); };" />
      <MemberSignature Language="F#" Value="member this.DtdProcessing : System.Xml.DtdProcessing with get, set" Usage="System.Xml.XmlReaderSettings.DtdProcessing" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.DtdProcessing</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置确定 DTD 的处理的值。</summary>
        <value>确定 DTD 的处理的枚举值之一。 默认值为 <see cref="F:System.Xml.DtdProcessing.Prohibit" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用 W3C 中定义的有效性约束实现文档类型定义 (DTD) 验证[可扩展标记语言 (XML) 1.0 （第四个版本） 建议](https://www.w3.org/TR/2006/REC-xml-20060816/)。 Dtd 使用正式语法来描述的结构和语法符合 XML 文档;它们指定的内容和 XML 文档的允许值。  
  
 此属性可以具有下列值之一：  
  
-   <xref:System.Xml.DtdProcessing.Parse?displayProperty=nameWithType> 若要启用 DTD 处理。  
  
-   <xref:System.Xml.DtdProcessing.Prohibit?displayProperty=nameWithType> 引发<xref:System.Xml.XmlException>遇到 DTD 时出现异常。  
  
-   <xref:System.Xml.DtdProcessing.Ignore?displayProperty=nameWithType> 若要禁用 DTD 处理，但不警告或异常。  
  
 为针对 DTD 执行验证，<xref:System.Xml.XmlReader> 使用 XML 文档的 DOCTYPE 声明中所定义的 DTD。 DOCTYPE 声明既可以指向内联 DTD，也可以是对外部 DTD 文件的引用。 若要验证对 DTD 的 XML 文件：  
  
-   将 <xref:System.Xml.XmlReaderSettings.DtdProcessing%2A?displayProperty=nameWithType> 属性设置为 `DtdProcessing.Parse.`  
  
-   将 <xref:System.Xml.XmlReaderSettings.ValidationType%2A?displayProperty=nameWithType> 属性设置为 `ValidationType.DTD`。  
  
-   如果 DTD 是存储在要求进行身份验证的网络资源上的外部文件，请将具有必要凭据的 <xref:System.Xml.XmlResolver> 对象传递给 <xref:System.Xml.XmlReader.Create%2A> 方法。  
  
> [!IMPORTANT]
>  如果<xref:System.Xml.XmlReaderSettings.DtdProcessing%2A>属性设置为<xref:System.Xml.DtdProcessing.Ignore?displayProperty=nameWithType>、<xref:System.Xml.XmlReader>将不报告 Dtd。 这意味着 DTD/DOCTYPE 上输出都将丢失。  
  
   
  
## Examples  
 以下示例使用 DTD 文件验证 XML 文件。  
  
 [!code-cpp[XmlReaderSettings.DtdValidate#1](~/samples/snippets/cpp/VS_Snippets_Data/XmlReaderSettings.DtdValidate/CPP/XmlReaderSettings.DtdValidate.cpp#1)]
 [!code-csharp[XmlReaderSettings.DtdValidate#1](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderSettings.DtdValidate/CS/validdtd.cs#1)]
 [!code-vb[XmlReaderSettings.DtdValidate#1](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderSettings.DtdValidate/VB/validdtd.vb#1)]  
  
## <a name="input"></a>输入  
 示例使用 `itemDTD.xml` 文件作为输入。  
  
 [!code-xml[XmlReaderSettings.DtdValidate#2](~/samples/snippets/xml/VS_Snippets_Data/XmlReaderSettings.DtdValidate/XML/itemDTD.xml#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IgnoreComments">
      <MemberSignature Language="C#" Value="public bool IgnoreComments { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IgnoreComments" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReaderSettings.IgnoreComments" />
      <MemberSignature Language="VB.NET" Value="Public Property IgnoreComments As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IgnoreComments { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.IgnoreComments : bool with get, set" Usage="System.Xml.XmlReaderSettings.IgnoreComments" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值指示是否忽略注释。</summary>
        <value>如果忽略注释，则为 <see langword="true" />；否则为 <see langword="false" />。 默认值为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此属性设置为`true`可能会导致从读取器返回的多个连续的文本节点。 这不会影响验证。  
  
   
  
## Examples  
 以下命令将创建可用于构造去除处理指令、 注释和无关紧要的空白区域的读取器的设置对象。  
  
 [!code-cpp[XmlReaderSettings.cctor#1](~/samples/snippets/cpp/VS_Snippets_Data/XmlReaderSettings.cctor/CPP/XmlReaderSettings.cctor.cpp#1)]
 [!code-csharp[XmlReaderSettings.cctor#1](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderSettings.cctor/CS/factory_rdr_cctor2.cs#1)]
 [!code-vb[XmlReaderSettings.cctor#1](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderSettings.cctor/VB/factory_rdr_cctor2.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Xml.XmlReader.Create(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="IgnoreProcessingInstructions">
      <MemberSignature Language="C#" Value="public bool IgnoreProcessingInstructions { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IgnoreProcessingInstructions" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReaderSettings.IgnoreProcessingInstructions" />
      <MemberSignature Language="VB.NET" Value="Public Property IgnoreProcessingInstructions As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IgnoreProcessingInstructions { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.IgnoreProcessingInstructions : bool with get, set" Usage="System.Xml.XmlReaderSettings.IgnoreProcessingInstructions" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值指示是否忽略处理指令。</summary>
        <value>如果忽略处理指令，则为 <see langword="true" />；否则为 <see langword="false" />。 默认值为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此属性设置为`true`可能会导致从读取器返回的多个连续的文本节点。 这不会影响验证。  
  
   
  
## Examples  
 以下命令将创建可用于构造去除处理指令、 注释和无关紧要的空白区域的读取器的设置对象。  
  
 [!code-cpp[XmlReaderSettings.cctor#1](~/samples/snippets/cpp/VS_Snippets_Data/XmlReaderSettings.cctor/CPP/XmlReaderSettings.cctor.cpp#1)]
 [!code-csharp[XmlReaderSettings.cctor#1](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderSettings.cctor/CS/factory_rdr_cctor2.cs#1)]
 [!code-vb[XmlReaderSettings.cctor#1](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderSettings.cctor/VB/factory_rdr_cctor2.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Xml.XmlReader.Create(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="IgnoreWhitespace">
      <MemberSignature Language="C#" Value="public bool IgnoreWhitespace { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IgnoreWhitespace" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReaderSettings.IgnoreWhitespace" />
      <MemberSignature Language="VB.NET" Value="Public Property IgnoreWhitespace As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IgnoreWhitespace { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.IgnoreWhitespace : bool with get, set" Usage="System.Xml.XmlReaderSettings.IgnoreWhitespace" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值指示是否忽略无关紧要的空白区域。</summary>
        <value>如果忽略空白，则为 <see langword="true" />；否则为 <see langword="false" />。 默认值为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 不被视为是有意义的空白包括空格、 制表符和用来分隔为了提高可读性的标记的空行。 此示例是元素内容中的空格。  
  
 此属性设置不会影响在混合内容的模式下或在范围内发生的空白区域中标记之间的空白区域`xml:space='preserve'`属性。  
  
   
  
## Examples  
 以下命令将创建可用于构造去除处理指令、 注释和无关紧要的空白区域的读取器的设置对象。  
  
 [!code-cpp[XmlReaderSettings.cctor#1](~/samples/snippets/cpp/VS_Snippets_Data/XmlReaderSettings.cctor/CPP/XmlReaderSettings.cctor.cpp#1)]
 [!code-csharp[XmlReaderSettings.cctor#1](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderSettings.cctor/CS/factory_rdr_cctor2.cs#1)]
 [!code-vb[XmlReaderSettings.cctor#1](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderSettings.cctor/VB/factory_rdr_cctor2.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Xml.XmlReader.Create(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="LineNumberOffset">
      <MemberSignature Language="C#" Value="public int LineNumberOffset { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 LineNumberOffset" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReaderSettings.LineNumberOffset" />
      <MemberSignature Language="VB.NET" Value="Public Property LineNumberOffset As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int LineNumberOffset { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.LineNumberOffset : int with get, set" Usage="System.Xml.XmlReaderSettings.LineNumberOffset" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置 <see cref="T:System.Xml.XmlReader" /> 对象的行号偏移量。</summary>
        <value>行号偏移量。 默认值为 0。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Xml.XmlReaderSettings.LineNumberOffset%2A>设置确定的点其中<xref:System.Xml.IXmlLineInfo.LineNumber%2A>属性开始计数。 这是更大的文档中嵌入 XML 数据的情况下很有用。 例如，如果您的 XML 数据嵌入在一个更大的文档，并且你的数据从文档的第 101 行开始，你可能想要指定读取器开始第 100 行。 因此，如果读取器引发了异常分析 XML 的第一行时，它将报告为第 101 行，而不是第 1 行的行号。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Xml.XmlReader.Create(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="LinePositionOffset">
      <MemberSignature Language="C#" Value="public int LinePositionOffset { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 LinePositionOffset" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReaderSettings.LinePositionOffset" />
      <MemberSignature Language="VB.NET" Value="Public Property LinePositionOffset As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int LinePositionOffset { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.LinePositionOffset : int with get, set" Usage="System.Xml.XmlReaderSettings.LinePositionOffset" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置 <see cref="T:System.Xml.XmlReader" /> 对象的行位置偏移量。</summary>
        <value>行位置偏移量。 默认值为 0。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Xml.XmlReaderSettings.LinePositionOffset%2A>设置确定的点其中<xref:System.Xml.IXmlLineInfo.LinePosition%2A>属性开始计数。 如果您的 XML 数据嵌入在较大的文档和 XML 的开头没有新行，这非常有用。 在这种情况下，如果读取器引发分析 XML 时出现异常，您希望其返回的行位置相对于主文档，而不仅仅是相对于 XML 片段。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Xml.XmlReader.Create(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="MaxCharactersFromEntities">
      <MemberSignature Language="C#" Value="public long MaxCharactersFromEntities { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 MaxCharactersFromEntities" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReaderSettings.MaxCharactersFromEntities" />
      <MemberSignature Language="VB.NET" Value="Public Property MaxCharactersFromEntities As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long MaxCharactersFromEntities { long get(); void set(long value); };" />
      <MemberSignature Language="F#" Value="member this.MaxCharactersFromEntities : int64 with get, set" Usage="System.Xml.XmlReaderSettings.MaxCharactersFromEntities" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值指示文档中允许扩展实体产生的最大字符数。</summary>
        <value>扩展实体中允许的最大字符数。 默认值为 0。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 零 (0) 值表示的扩展实体产生的字符数没有限制。 一个非零值指定的最大可以扩展实体产生的字符数。  
  
 如果读取器将尝试读取以便扩展的大小将超过此属性包含实体的文档<xref:System.Xml.XmlException>将引发。  
  
 此属性，可以以缓解拒绝服务攻击，攻击者提交尝试超过内存限制通过扩展实体的 XML 文档。 通过限制从扩展实体产生的字符，可以检测攻击，并可靠地进行恢复。  
  
   
  
## Examples  
 下面的代码设置此属性，然后尝试分析包含扩展的大小大于所设定的限制为的实体的文档。 在实际方案中，你将设置此限制为一个足够大，尚未处理有效的文档的值足够小，以限制从恶意文档的威胁。  
  
```csharp  
string markup =  
@"<!DOCTYPE Root [  
  <!ENTITY anEntity ""Expands to more than 30 characters"">  
  <!ELEMENT Root (#PCDATA)>  
]>  
<Root>Content &anEntity;</Root>";  
  
XmlReaderSettings settings = new XmlReaderSettings();  
settings.DtdProcessing = DtdProcessing.Parse;  
settings.ValidationType = ValidationType.DTD;  
settings.MaxCharactersFromEntities = 30;  
  
try  
{  
    XmlReader reader = XmlReader.Create(new StringReader(markup), settings);  
    while (reader.Read()) { }  
}  
catch (XmlException ex)  
{  
    Console.WriteLine(ex.Message);  
}  
```  
  
```vb  
Dim markup As String = _  
    "<!DOCTYPE Root [" + Environment.NewLine + _  
    "  <!ENTITY anEntity ""Expands to more than 30 characters"">" + Environment.NewLine + _  
    "  <!ELEMENT Root (#PCDATA)>" + Environment.NewLine + _  
    ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MaxCharactersInDocument">
      <MemberSignature Language="C#" Value="public long MaxCharactersInDocument { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 MaxCharactersInDocument" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReaderSettings.MaxCharactersInDocument" />
      <MemberSignature Language="VB.NET" Value="Public Property MaxCharactersInDocument As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long MaxCharactersInDocument { long get(); void set(long value); };" />
      <MemberSignature Language="F#" Value="member this.MaxCharactersInDocument : int64 with get, set" Usage="System.Xml.XmlReaderSettings.MaxCharactersInDocument" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值指明 XML 文档中所允许的最大字符数。 零 (0) 值表示对 XML 文档的大小没有限制。 非零值指定最大大小（以字符数计）。</summary>
        <value>XML 文档中所允许的最大字符数。 默认值为 0。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 零 (0) 值表示的已分析文档中的字符数没有限制。 一个非零值指定的最大可以分析的字符数。  
  
 文档的最大字符计数包括从扩展实体产生的字符数。  
  
 如果读取器将尝试读取的文档大小超过此属性，<xref:System.Xml.XmlException>将引发。  
  
 此属性，可以以缓解拒绝服务攻击，攻击者提交极大的 XML 文档。 通过限制文档的大小，可以检测攻击，并可靠地进行恢复。  
  
   
  
## Examples  
 下面的代码设置此属性，然后尝试分析文档大小超过限制。 在实际方案中，你将设置此限制为一个足够大，尚未处理有效的文档的值足够小，以限制从恶意文档的威胁。  
  
```csharp  
string markup = "<Root>Content</Root>";  
  
XmlReaderSettings settings = new XmlReaderSettings();  
settings.MaxCharactersInDocument = 10;  
  
try  
{  
    XmlReader reader = XmlReader.Create(new StringReader(markup), settings);  
    while (reader.Read()) { }  
}  
catch (XmlException ex)  
{  
    Console.WriteLine(ex.Message);  
}  
```  
  
```vb  
Dim markup As String = "<Root>Content</Root>"  
  
Dim settings As XmlReaderSettings = New XmlReaderSettings()  
settings.MaxCharactersInDocument = 10  
  
Try  
    Dim reader As XmlReader = XmlReader.Create(New StringReader(markup), settings)  
    While (reader.Read())  
    End While  
Catch ex As XmlException  
    Console.WriteLine(ex.Message)  
End Try  
```  
  
 此代码生成以下输出：  
  
```  
There is an error in XML document (MaxCharactersInDocument, ).  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="NameTable">
      <MemberSignature Language="C#" Value="public System.Xml.XmlNameTable NameTable { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xml.XmlNameTable NameTable" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReaderSettings.NameTable" />
      <MemberSignature Language="VB.NET" Value="Public Property NameTable As XmlNameTable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xml::XmlNameTable ^ NameTable { System::Xml::XmlNameTable ^ get(); void set(System::Xml::XmlNameTable ^ value); };" />
      <MemberSignature Language="F#" Value="member this.NameTable : System.Xml.XmlNameTable with get, set" Usage="System.Xml.XmlReaderSettings.NameTable" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlNameTable</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置用于原子化字符串比较的 <see cref="T:System.Xml.XmlNameTable" />。</summary>
        <value>
          <see cref="T:System.Xml.XmlNameTable" />，它存储使用此 <see cref="T:System.Xml.XmlReader" /> 对象创建的所有 <see cref="T:System.Xml.XmlReaderSettings" /> 实例使用的所有原子化字符串。  默认值为 <see langword="null" />。 如果该值为<see langword="null" />，创建的 <see cref="T:System.Xml.XmlReader" /> 实例将使用新的空 <see cref="T:System.Xml.NameTable" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 将此属性设置为<xref:System.Xml.XmlNameTable>实例如果你想要共享一个公用名称表在所有之间创建<xref:System.Xml.XmlReader>实例。  
  
> [!NOTE]
>  <xref:System.Xml.NameTable> 类不是线程安全的。 因此它无法共享之间<xref:System.Xml.XmlReader>同时运行在不同线程中的对象。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ProhibitDtd">
      <MemberSignature Language="C#" Value="public bool ProhibitDtd { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ProhibitDtd" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReaderSettings.ProhibitDtd" />
      <MemberSignature Language="VB.NET" Value="Public Property ProhibitDtd As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ProhibitDtd { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.ProhibitDtd : bool with get, set" Usage="System.Xml.XmlReaderSettings.ProhibitDtd" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use XmlReaderSettings.DtdProcessing property instead.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值指示是否禁用文档类型定义 (DTD) 处理。 此属性已过时。 请改用 <see cref="P:System.Xml.XmlTextReader.DtdProcessing" />。</summary>
        <value>如果禁用 DTD 处理，则为 <see langword="true" />；否则为 <see langword="false" />。 默认值为 <see langword="true" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当设置为`true`、<xref:System.Xml.XmlReader>引发<xref:System.Xml.XmlException>时遇到任何 DTD 内容。 如果您担心拒绝服务问题或您在处理不可信的源，则不要启用 DTD 处理。  
  
 如果启用了 DTD 处理，可以使用 <xref:System.Xml.XmlSecureResolver> 限制 <xref:System.Xml.XmlReader> 可以访问的资源。 还可以设计应用程序以使 XML 处理受内存和时间的约束。 例如，在 ASP.NET 应用程序中配置超时限制。  
  
 此属性已过时。 请改用 <xref:System.Xml.XmlTextReader.DtdProcessing%2A>。 如果已设置<xref:System.Xml.XmlReaderSettings.ProhibitDtd%2A>为其默认值`true`设置<xref:System.Xml.XmlTextReader.DtdProcessing%2A>到`Prohibit`。 如果已设置<xref:System.Xml.XmlReaderSettings.ProhibitDtd%2A>到`false`设置<xref:System.Xml.XmlTextReader.DtdProcessing%2A>到`Parse`。  
  
   
  
## Examples  
 以下示例将验证使用 DTD 的数据。  
  
 [!code-cpp[XmlReaderSettings.DtdValidate#1](~/samples/snippets/cpp/VS_Snippets_Data/XmlReaderSettings.DtdValidate/CPP/XmlReaderSettings.DtdValidate.cpp#1)]
 [!code-csharp[XmlReaderSettings.DtdValidate#1](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderSettings.DtdValidate/CS/validdtd.cs#1)]
 [!code-vb[XmlReaderSettings.DtdValidate#1](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderSettings.DtdValidate/VB/validdtd.vb#1)]  
  
 该示例使用 itemDTD.xml 文件  
  
 [!code-xml[XmlReaderSettings.DtdValidate#2](~/samples/snippets/xml/VS_Snippets_Data/XmlReaderSettings.DtdValidate/XML/itemDTD.xml#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Reset">
      <MemberSignature Language="C#" Value="public void Reset ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Reset() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReaderSettings.Reset" />
      <MemberSignature Language="VB.NET" Value="Public Sub Reset ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Reset();" />
      <MemberSignature Language="F#" Value="member this.Reset : unit -&gt; unit" Usage="xmlReaderSettings.Reset " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>将设置类的成员重置为各自的默认值。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表显示的实例的初始属性值<xref:System.Xml.XmlReaderSettings>。  
  
|Property|初始值|  
|--------------|-------------------|  
|<xref:System.Xml.XmlReaderSettings.Async%2A>|`false`。|  
|<xref:System.Xml.XmlReaderSettings.CheckCharacters%2A>|`true`。|  
|<xref:System.Xml.XmlReaderSettings.ConformanceLevel%2A>|<xref:System.Xml.ConformanceLevel.Document>。|  
|<xref:System.Xml.XmlReaderSettings.IgnoreComments%2A>|`false`。|  
|<xref:System.Xml.XmlReaderSettings.IgnoreProcessingInstructions%2A>|`false`。|  
|<xref:System.Xml.XmlReaderSettings.IgnoreWhitespace%2A>|`false`。|  
|<xref:System.Xml.XmlReaderSettings.LineNumberOffset%2A>|0.|  
|<xref:System.Xml.XmlReaderSettings.LinePositionOffset%2A>|0.|  
|<xref:System.Xml.XmlReaderSettings.MaxCharactersFromEntities%2A>|（没有扩展实体产生的字符数没有限制） 为 0。|  
|<xref:System.Xml.XmlReaderSettings.MaxCharactersInDocument%2A>|0 （在 XML 文档的大小没有限制）。|  
|<xref:System.Xml.XmlReaderSettings.NameTable%2A>|`null`。|  
|<xref:System.Xml.XmlTextReader.DtdProcessing%2A>|<xref:System.Xml.DtdProcessing.Prohibit>|  
|<xref:System.Xml.XmlReaderSettings.ProhibitDtd%2A>|`true`。 此属性已过时。 请改用 <xref:System.Xml.XmlTextReader.DtdProcessing%2A>。 如果已设置<xref:System.Xml.XmlReaderSettings.ProhibitDtd%2A>为其默认值`true`设置<xref:System.Xml.XmlTextReader.DtdProcessing%2A>到`Prohibit`。 如果已设置<xref:System.Xml.XmlReaderSettings.ProhibitDtd%2A>到`false`设置<xref:System.Xml.XmlTextReader.DtdProcessing%2A>到`Parse`。|  
|<xref:System.Xml.XmlReaderSettings.Schemas%2A>|一个空 <xref:System.Xml.Schema.XmlSchemaSet> 对象。|  
|<xref:System.Xml.XmlReaderSettings.ValidationFlags%2A>|<xref:System.Xml.Schema.XmlSchemaValidationFlags.ProcessIdentityConstraints>。|  
|<xref:System.Xml.XmlReaderSettings.ValidationType%2A>|<xref:System.Xml.ValidationType.None>。|  
|<xref:System.Xml.XmlReaderSettings.XmlResolver%2A>|一个新 <xref:System.Xml.XmlUrlResolver> 对象。|  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.XmlReader" />
        <altmember cref="M:System.Xml.XmlReader.Create(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Schemas">
      <MemberSignature Language="C#" Value="public System.Xml.Schema.XmlSchemaSet Schemas { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xml.Schema.XmlSchemaSet Schemas" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReaderSettings.Schemas" />
      <MemberSignature Language="VB.NET" Value="Public Property Schemas As XmlSchemaSet" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xml::Schema::XmlSchemaSet ^ Schemas { System::Xml::Schema::XmlSchemaSet ^ get(); void set(System::Xml::Schema::XmlSchemaSet ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Schemas : System.Xml.Schema.XmlSchemaSet with get, set" Usage="System.Xml.XmlReaderSettings.Schemas" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Schema.XmlSchemaSet</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置在执行架构验证时使用的 <see cref="T:System.Xml.Schema.XmlSchemaSet" />。</summary>
        <value>当执行架构验证时使用的 <see cref="T:System.Xml.Schema.XmlSchemaSet" />。 默认为空的 <see cref="T:System.Xml.Schema.XmlSchemaSet" /> 对象。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  -   不要使用来自未知或不受信任的源或位置的架构。 这样会危及你的代码的安全性。  
> -   XML 架构 （包括内联架构） 的本质上就容易受到拒绝服务攻击;不要在不受信任的情况下接受它们。  
> -   架构验证错误消息和异常可能会公开有关内容模型或架构文件的 URI 路径的敏感信息。 请注意不要公开此信息来不受信任的调用方。  
> -   有关其他信息，请参阅的"安全注意事项"部分。  
  
 <xref:System.Xml.Schema.XmlSchemaSet>类只支持 XML 架构定义语言 (XSD) 架构。 <xref:System.Xml.XmlReader> 创建的实例<xref:System.Xml.XmlReader.Create%2A>方法不能配置为启用 XML 数据简化 (XDR) 架构验证。  
  
## <a name="security-considerations"></a>安全注意事项  
  
-   不要使用来自未知或不可信源的架构。 这样会危及你的代码的安全性。 <xref:System.Xml.XmlUrlResolver>类用于解析外部架构默认情况下。 若要禁用解析包含、 导入，而重新定义架构的元素，<xref:System.Xml.Schema.XmlSchemaSet.XmlResolver%2A?displayProperty=nameWithType>属性`null`。  
  
-   由于使用而引发的异常<xref:System.Xml.Schema.XmlSchemaSet>类，如<xref:System.Xml.Schema.XmlSchemaException>类可能包含不应在不受信任的方案中公开的敏感信息。 例如，<xref:System.Xml.Schema.XmlSchemaException.SourceUri%2A>属性<xref:System.Xml.Schema.XmlSchemaException>返回导致异常的架构文件的 URI 路径。 <xref:System.Xml.Schema.XmlSchemaException.SourceUri%2A>不应在不受信任的方案中公开属性。 应正确处理异常，以便在不受信任的情况下不公开此敏感信息。  
  
   
  
## Examples  
 下面的示例使用<xref:System.Xml.XmlReaderSettings>对象和<xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType>方法以将架构与 XML 文档相关联。 该架构添加到<xref:System.Xml.XmlReaderSettings.Schemas%2A>属性<xref:System.Xml.XmlReaderSettings>对象。 值<xref:System.Xml.XmlReaderSettings.Schemas%2A>属性是<xref:System.Xml.Schema.XmlSchemaSet>对象。 架构用于验证 XML 文档符合架构内容模型。 由处理架构验证错误和警告<xref:System.Xml.XmlReaderSettings.ValidationEventHandler>中定义<xref:System.Xml.XmlReaderSettings>对象。  
  
 [!code-cpp[XmlSchemaSetOverall Example#1](~/samples/snippets/cpp/VS_Snippets_Data/XmlSchemaSetOverall Example/CPP/xmlschemasetexample.cpp#1)]
 [!code-csharp[XmlSchemaSetOverall Example#1](~/samples/snippets/csharp/VS_Snippets_Data/XmlSchemaSetOverall Example/CS/xmlschemasetexample.cs#1)]
 [!code-vb[XmlSchemaSetOverall Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlSchemaSetOverall Example/VB/xmlschemasetexample.vb#1)]  
  
 该示例使用 books.xml 文件  
  
 [!code-xml[XmlSchemaSetOverall Example#2](~/samples/snippets/xml/VS_Snippets_Data/XmlSchemaSetOverall Example/XML/books.xml#2)]  
  
 该示例使用 books.xsd 文件作为输入。  
  
 [!code-xml[XmlSchemaSetOverall Example#3](~/samples/snippets/xml/VS_Snippets_Data/XmlSchemaSetOverall Example/XML/books.xsd#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.XmlReader" />
        <altmember cref="M:System.Xml.XmlReader.Create(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="ValidationEventHandler">
      <MemberSignature Language="C#" Value="public event System.Xml.Schema.ValidationEventHandler ValidationEventHandler;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Xml.Schema.ValidationEventHandler ValidationEventHandler" />
      <MemberSignature Language="DocId" Value="E:System.Xml.XmlReaderSettings.ValidationEventHandler" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Xml::Schema::ValidationEventHandler ^ ValidationEventHandler;" />
      <MemberSignature Language="F#" Value="member this.ValidationEventHandler : System.Xml.Schema.ValidationEventHandler " Usage="member this.ValidationEventHandler : System.Xml.Schema.ValidationEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Schema.ValidationEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在读取器遇到验证错误时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 这些事件发生时读取 XML 实例文档，如果<xref:System.Xml.XmlReaderSettings.ValidationType%2A>设置为<xref:System.Xml.ValidationType.DTD>或<xref:System.Xml.ValidationType.Schema>。 如果<xref:System.Xml.Schema.XmlSchemaValidationFlags.ReportValidationWarnings>上已启用设置<xref:System.Xml.XmlReaderSettings.ValidationFlags%2A>时遇到任何验证警告，也可能发生这些事件的属性。  
  
 如果读取器配置为进行验证且没有验证事件处理程序已设置，<xref:System.Xml.Schema.XmlSchemaValidationException>所有验证错误时都引发。 (验证警告不会导致<xref:System.Xml.Schema.XmlSchemaValidationException>引发)。  
  
> [!IMPORTANT]
>  验证错误消息可能会公开敏感的内容模型的信息。 验证错误和警告消息使用处理<xref:System.Xml.Schema.ValidationEventHandler>委托，或作为公开<xref:System.Xml.Schema.XmlSchemaValidationException>如果没有事件处理程序提供给<xref:System.Xml.XmlReaderSettings>对象 (验证警告不会导致<xref:System.Xml.Schema.XmlSchemaValidationException>引发)。 此内容模型信息不应在不受信任的方案中公开。 验证警告消息默认情况下禁止显示，并且可以通过设置报告<xref:System.Xml.Schema.XmlSchemaValidationFlags.ReportValidationWarnings>标志。  
>   
>  <xref:System.Xml.Schema.XmlSchemaException.SourceUri%2A>属性<xref:System.Xml.Schema.XmlSchemaValidationException>返回导致异常的架构文件的 URI 路径。 <xref:System.Xml.Schema.XmlSchemaException.SourceUri%2A>不应在不受信任的方案中公开属性。  
  
   
  
## Examples  
 下面的示例演示设置以指定要创建一个读取器来验证使用内联架构并显示验证警告。 验证事件处理程序使用<xref:System.Xml.Schema.XmlSeverityType>枚举，以了解警告和错误之间的区别。  
  
 [!code-csharp[XmlReaderSettings.IgnoreInlineSchema#1](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderSettings.IgnoreInlineSchema/CS/factory_rdr_cctor.cs#1)]
 [!code-vb[XmlReaderSettings.IgnoreInlineSchema#1](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderSettings.IgnoreInlineSchema/VB/factory_rdr_cctor.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.XmlReader" />
        <altmember cref="M:System.Xml.XmlReader.Create(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="ValidationFlags">
      <MemberSignature Language="C#" Value="public System.Xml.Schema.XmlSchemaValidationFlags ValidationFlags { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Xml.Schema.XmlSchemaValidationFlags ValidationFlags" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReaderSettings.ValidationFlags" />
      <MemberSignature Language="VB.NET" Value="Public Property ValidationFlags As XmlSchemaValidationFlags" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xml::Schema::XmlSchemaValidationFlags ValidationFlags { System::Xml::Schema::XmlSchemaValidationFlags get(); void set(System::Xml::Schema::XmlSchemaValidationFlags value); };" />
      <MemberSignature Language="F#" Value="member this.ValidationFlags : System.Xml.Schema.XmlSchemaValidationFlags with get, set" Usage="System.Xml.XmlReaderSettings.ValidationFlags" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Schema.XmlSchemaValidationFlags</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个指示架构验证设置的值。 此设置应用于验证架构的 <see cref="T:System.Xml.XmlReader" /> 对象（<see cref="P:System.Xml.XmlReaderSettings.ValidationType" /> 属性设置为 <see langword="ValidationType.Schema" />）。</summary>
        <value>指定验证选项的枚举值的按位组合。 <see cref="F:System.Xml.Schema.XmlSchemaValidationFlags.ProcessIdentityConstraints" /> 和 <see cref="F:System.Xml.Schema.XmlSchemaValidationFlags.AllowXmlAttributes" /> 默认情况下启用。 <see cref="F:System.Xml.Schema.XmlSchemaValidationFlags.ProcessInlineSchema" />、<see cref="F:System.Xml.Schema.XmlSchemaValidationFlags.ProcessSchemaLocation" /> 和 <see cref="F:System.Xml.Schema.XmlSchemaValidationFlags.ReportValidationWarnings" /> 默认情况下禁用。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  默认情况下不设置 <xref:System.Xml.Schema.XmlSchemaValidationFlags.ProcessInlineSchema> 对象的 <xref:System.Xml.Schema.XmlSchemaValidationFlags.ProcessSchemaLocation> 和 <xref:System.Xml.XmlReaderSettings> 验证标志。 设置了这些标志后，<xref:System.Xml.XmlReaderSettings.XmlResolver%2A> 对象的 <xref:System.Xml.XmlReaderSettings> 用于在 <xref:System.Xml.XmlReader> 中解析实例文档中遇到的架构位置。 如果<xref:System.Xml.XmlReaderSettings.XmlResolver%2A>对象是`null`，则不解析架构位置即使<xref:System.Xml.Schema.XmlSchemaValidationFlags.ProcessInlineSchema>和<xref:System.Xml.Schema.XmlSchemaValidationFlags.ProcessSchemaLocation>设置验证标志。  
>   
>  在验证过程中添加的架构会添加新类型，并且可能更改被验证的文档的验证结果。 因此，只应从可信的源解析外部架构。  
>   
>  禁用<xref:System.Xml.Schema.XmlSchemaValidationFlags.ProcessIdentityConstraints>高可用性方案中，针对具有标识约束的架构中通过文档的很大程度的验证不受信任的大型 XML 文档时，建议标志 （默认情况下启用）。  
  
   
  
## Examples  
 下面的示例通过启用验证内联 XML 架构对 XML 文件<xref:System.Xml.Schema.XmlSchemaValidationFlags.ProcessInlineSchema>设置。 XML 读取器配置为显示验证警告，sp 则还看到预期的警告根元素上。  
  
 [!code-csharp[XmlReaderSettings.IgnoreInlineSchema#1](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderSettings.IgnoreInlineSchema/CS/factory_rdr_cctor.cs#1)]
 [!code-vb[XmlReaderSettings.IgnoreInlineSchema#1](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderSettings.IgnoreInlineSchema/VB/factory_rdr_cctor.vb#1)]  
  
## <a name="input"></a>输入  
 示例使用 inlineSchema.xml 文件作为输入。  
  
 [!code-xml[XmlReaderSettings.IgnoreInlineSchema#3](~/samples/snippets/xml/VS_Snippets_Data/XmlReaderSettings.IgnoreInlineSchema/XML/inlineSchema.xml#3)]  
  
## <a name="output"></a>输出  
 警告： 匹配找不到架构。 未进行任何验证。 找不到元素“root”的架构信息。  
  
 验证错误： 元素 xsdHeadCount:HeadCount 具有无效子元素 division。 应包含“ID”。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.XmlReader" />
        <altmember cref="M:System.Xml.XmlReader.Create(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="ValidationType">
      <MemberSignature Language="C#" Value="public System.Xml.ValidationType ValidationType { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Xml.ValidationType ValidationType" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReaderSettings.ValidationType" />
      <MemberSignature Language="VB.NET" Value="Public Property ValidationType As ValidationType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xml::ValidationType ValidationType { System::Xml::ValidationType get(); void set(System::Xml::ValidationType value); };" />
      <MemberSignature Language="F#" Value="member this.ValidationType : System.Xml.ValidationType with get, set" Usage="System.Xml.XmlReaderSettings.ValidationType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.ValidationType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值指示 <see cref="T:System.Xml.XmlReader" /> 在读取时是否执行验证或类型分配。</summary>
        <value>
          <see cref="T:System.Xml.ValidationType" /> 的一个值指示 XmlReader 是否将呈现有效或当读取的时执行验证或类型分配。 默认值为 <see langword="ValidationType.None" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表描述了<xref:System.Xml.ValidationType>值。  
  
> [!NOTE]
>  <xref:System.Xml.ValidationType.Auto>和<xref:System.Xml.ValidationType.XDR>枚举的值为.NET Framework 2.0 版中过时。  
  
|ValidationType|描述|  
|--------------------|-----------------|  
|`DTD`|使用文档类型定义 (DTD) 执行验证。 **注意：** <xref:System.Xml.XmlReaderSettings.DtdProcessing%2A>属性还必须设置为<xref:System.Xml.DtdProcessing.Parse>。|  
|`None`|<xref:System.Xml.XmlReader>不会验证数据，或执行任何类型赋值。|  
|`Schema`|使用 XML 架构定义语言 (XSD) 架构执行验证和类型分配。 读取器访问使用以下 XML 架构：<br /><br /> -使用<xref:System.Xml.XmlReaderSettings.Schemas%2A>属性来访问<xref:System.Xml.Schema.XmlSchemaSet>与此读取器关联的对象。<br />-使用 XML 实例文档中包含内联架构。 (<xref:System.Xml.Schema.XmlSchemaValidationFlags.ProcessInlineSchema>必须启用选项。)<br />-使用指定的架构位置提示的 XML 架构 (`xsi:schemaLocation`或`xsi:noNamespaceSchemaLocation`属性) 在 XML 实例文档中找到。 (<xref:System.Xml.Schema.XmlSchemaValidationFlags.ProcessSchemaLocation>必须启用选项。)|  
  
   
  
## Examples  
 以下示例将验证使用存储在架构<xref:System.Xml.Schema.XmlSchemaSet>。  
  
 [!code-cpp[XmlReader_Validate_SchemaSet#1](~/samples/snippets/cpp/VS_Snippets_Data/XmlReader_Validate_SchemaSet/CPP/XmlReader_Validate_SchemaSet.cpp#1)]
 [!code-csharp[XmlReader_Validate_SchemaSet#1](~/samples/snippets/csharp/VS_Snippets_Data/XmlReader_Validate_SchemaSet/CS/validschemaset.cs#1)]
 [!code-vb[XmlReader_Validate_SchemaSet#1](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReader_Validate_SchemaSet/VB/validschemaset.vb#1)]  
  
 该示例使用以下输入的文件：  
  
 `booksSchemaFail.xml`  
  
 [!code-xml[XmlReader_Validate_SchemaSet#2](~/samples/snippets/xml/VS_Snippets_Data/XmlReader_Validate_SchemaSet/XML/booksschemafail.xml#2)]  
  
 `books.xsd`  
  
 [!code-xml[XmlReader_Validate_SchemaSet#3](~/samples/snippets/xml/VS_Snippets_Data/XmlReader_Validate_SchemaSet/XML/books.xsd#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.XmlReader" />
        <altmember cref="M:System.Xml.XmlReader.Create(System.String)" />
        <altmember cref="T:System.Xml.Schema.XmlSchemaValidationFlags" />
      </Docs>
    </Member>
    <Member MemberName="XmlResolver">
      <MemberSignature Language="C#" Value="public System.Xml.XmlResolver XmlResolver { set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xml.XmlResolver XmlResolver" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReaderSettings.XmlResolver" />
      <MemberSignature Language="VB.NET" Value="Public Property XmlResolver As XmlResolver" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xml::XmlResolver ^ XmlResolver {  void set(System::Xml::XmlResolver ^ value); };" />
      <MemberSignature Language="F#" Value="member this.XmlResolver : System.Xml.XmlResolver" Usage="System.Xml.XmlReaderSettings.XmlResolver" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlResolver</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>设置用来访问外部文档的 <see cref="T:System.Xml.XmlResolver" />。</summary>
        <value>用来访问外部文档的 <see cref="T:System.Xml.XmlResolver" />。 如果设置为 <see langword="null" />，当 <see cref="T:System.Xml.XmlException" /> 试图访问外部资源时，将引发 <see cref="T:System.Xml.XmlReader" />。 默认值为没有凭据的新 <see cref="T:System.Xml.XmlUrlResolver" />。  从.NET Framework 4.5.2 开始，此设置不会产生的默认值为<see langword="null" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Xml.XmlResolver>用于查找和打开 XML 实例文档，或用于找到并打开 XML 实例文档引用的任何外部资源。 这可能包括实体、 DTD 或架构。 <xref:System.Xml.XmlResolver.Credentials%2A?displayProperty=nameWithType>属性可以用于指定任何所需的网络身份验证的凭据。  
  
> [!IMPORTANT]
>  因为<xref:System.Xml.XmlReaderSettings.XmlResolver%2A>可以包含敏感信息，例如用户凭据，你应小心缓存时<xref:System.Xml.XmlReaderSettings>对象，或传递时<xref:System.Xml.XmlReaderSettings>到另一个组件中的对象。  
>   
>  <xref:System.Xml.XmlSecureResolver>可用来访问外部文档。 <xref:System.Xml.XmlSecureResolver>类可帮助保护另一个实现<xref:System.Xml.XmlResolver>通过包装<xref:System.Xml.XmlResolver>对象和限制的资源的基础<xref:System.Xml.XmlResolver>有权访问。  
>   
>  默认情况下不设置 <xref:System.Xml.Schema.XmlSchemaValidationFlags.ProcessInlineSchema> 对象的 <xref:System.Xml.Schema.XmlSchemaValidationFlags.ProcessSchemaLocation> 和 <xref:System.Xml.XmlReaderSettings> 验证标志。 设置了这些标志后，<xref:System.Xml.XmlReaderSettings.XmlResolver%2A> 对象的 <xref:System.Xml.XmlReaderSettings> 用于在 <xref:System.Xml.XmlReader> 中解析实例文档中遇到的架构位置。 如果<xref:System.Xml.XmlReaderSettings.XmlResolver%2A>对象是`null`，则不解析架构位置即使<xref:System.Xml.Schema.XmlSchemaValidationFlags.ProcessInlineSchema>和<xref:System.Xml.Schema.XmlSchemaValidationFlags.ProcessSchemaLocation>设置验证标志。  
>   
>  在验证过程中添加的架构会添加新类型，并且可能更改被验证的文档的验证结果。 因此，只应从可信的源解析外部架构。  
  
   
  
## Examples  
 下面的示例创建<xref:System.Xml.XmlReader>使用<xref:System.Xml.XmlSecureResolver>使用默认凭据。  
  
 [!code-csharp[XmlReader.Create#10](~/samples/snippets/csharp/VS_Snippets_Data/XmlReader.Create/CS/XmlReader_Create.cs#10)]
 [!code-vb[XmlReader.Create#10](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReader.Create/VB/XmlReader_Create.vb#10)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.XmlReader" />
        <altmember cref="M:System.Xml.XmlReader.Create(System.String)" />
      </Docs>
    </Member>
  </Members>
</Type>