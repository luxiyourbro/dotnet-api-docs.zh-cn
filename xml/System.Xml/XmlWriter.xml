<Type Name="XmlWriter" FullName="System.Xml.XmlWriter">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="40bc54b53ce3208b7438d85579468de6acaed98e" />
    <Meta Name="ms.sourcegitcommit" Value="9e06b87bcfa4347dbbaaa4b3cc36b43b93b5badb" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-CN" />
    <Meta Name="ms.lasthandoff" Value="11/20/2018" />
    <Meta Name="ms.locfileid" Value="52255193" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class XmlWriter : IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit XmlWriter extends System.Object implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Xml.XmlWriter" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class XmlWriter&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class XmlWriter abstract : IDisposable" />
  <TypeSignature Language="F#" Value="type XmlWriter = class&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Xml</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>表示一个写入器，该写入器提供一种快速、非缓存和只进方式以生成包含 XML 数据的流或文件。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Xml.XmlWriter>类将 XML 数据写入到流、 文件、 文本读取器或字符串。 它支持 W3C[可扩展标记语言 (XML) 1.0 （第四版）](https://www.w3.org/TR/2006/REC-xml-20060816/)并[命名空间中 XML 1.0 （第三版）](https://www.w3.org/TR/REC-xml-names/)建议。  
  
 成员<xref:System.Xml.XmlWriter>类使您能够：  
  
-   检查字符是不是合法的 XML 字符，元素和属性的名称是不是有效的 XML 名称。  
  
-   检查 XML 文档的格式是否正确。  
  
-   将二进制字节编码为 Base64 或 BinHex，并写出结果文本。  
  
-   通过使用公共语言运行时类型而不字符串，可以避免不得不手动执行值的转换传递值。  
  
-   将多个文档写入一个输出流。  
  
-   写出有效的名称、限定名和名称标记。  
  
 本节内容：  
  
 [创建 XML 编写器](#create)   
 [指定的输出格式](#output)   
 [数据一致性](#conformance)   
 [写入元素](#writing_elements)   
 [编写属性](#writing_attributes)   
 [处理命名空间](#handling_ns)   
 [写出类型化数据](#writing_types)   
 [关闭 XML 编写器](#close)   
 [异步编程](#async)   
 [安全注意事项](#security)  
  
<a name="create"></a>   
## <a name="creating-an-xml-writer"></a>创建 XML 编写器  
 若要创建<xref:System.Xml.XmlWriter>实例，请使用<xref:System.Xml.XmlWriter.Create%2A?displayProperty=nameWithType>方法。 若要指定一组你想要启用对 XML 编写器的功能，请将传递<xref:System.Xml.XmlWriterSettings>到<xref:System.Xml.XmlWriter.Create%2A>方法。 否则，使用默认设置。 请参阅<xref:System.Xml.XmlWriter.Create%2A>参考页的详细信息。  
  
<a name="output"></a>   
## <a name="specifying-the-output-format"></a>指定的输出格式  
 <xref:System.Xml.XmlWriterSettings>类包含多个属性，用于控制如何<xref:System.Xml.XmlWriter>输出的格式：  
  
|Property|描述|  
|--------------|-----------------|  
|<xref:System.Xml.XmlWriterSettings.Encoding%2A>|指定要使用的文本编码。 默认值为 `Encoding.UTF8`。|  
|<xref:System.Xml.XmlWriterSettings.Indent%2A>|指示是否使元素缩进。 默认值是`false`（任何缩进）。|  
|<xref:System.Xml.XmlWriterSettings.IndentChars%2A>|指定在缩进时要使用的字符串。 默认值为两个空格。|  
|<xref:System.Xml.XmlWriterSettings.NewLineChars%2A>|指定分行符要使用的字符串。 默认值为 `\r\n`（回车符、换行符）。|  
|<xref:System.Xml.XmlWriterSettings.NewLineHandling%2A>|指定如何处理换行符。|  
|<xref:System.Xml.XmlWriterSettings.NewLineOnAttributes%2A>|指示是否在新行上编写属性。 在使用此属性时，<xref:System.Xml.XmlWriterSettings.Indent%2A> 应设置为 `true`。 默认值为 `false`。|  
|<xref:System.Xml.XmlWriterSettings.OmitXmlDeclaration%2A>|指示是否编写 XML 声明。 默认值为 `false`。|  
  
 <xref:System.Xml.XmlWriterSettings.Indent%2A> 和 <xref:System.Xml.XmlWriterSettings.IndentChars%2A> 属性控制无效空白如何格式化。 例如，若要缩进元素节点：  
  
 [!code-csharp[XmlWriter_v2#8](~/samples/snippets/csharp/VS_Snippets_Data/XmlWriter_v2/CS/writer_v2.cs#8)]
 [!code-vb[XmlWriter_v2#8](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlWriter_v2/VB/writer_v2.vb#8)]  
  
 使用<xref:System.Xml.XmlWriterSettings.NewLineOnAttributes%2A>具有一个额外级别的缩进新行上编写每个属性：  
  
 [!code-csharp[XmlWriter_v2#9](~/samples/snippets/csharp/VS_Snippets_Data/XmlWriter_v2/CS/writer_v2.cs#9)]
 [!code-vb[XmlWriter_v2#9](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlWriter_v2/VB/writer_v2.vb#9)]  
  
<a name="conformance"></a>   
## <a name="data-conformance"></a>数据一致性  
 XML 编写器使用两个属性从<xref:System.Xml.XmlWriterSettings>类为数据一致性检查：  
  
-   <xref:System.Xml.XmlWriterSettings.CheckCharacters%2A>属性指示要检查字符并抛出的 XML 编写器<xref:System.Xml.XmlException>如果任何字符不在合法范围由 W3C 定义的异常。  
  
-   <xref:System.Xml.XmlWriterSettings.ConformanceLevel%2A>属性配置要检查正在写入的流符合格式正确的 XML 1.0 文档或文档片段的规则由 W3C 定义的 XML 编写器。 下表所述的三个一致性级别。 默认值为 <xref:System.Xml.ConformanceLevel.Document>。 有关详细信息，请参阅<xref:System.Xml.XmlWriterSettings.ConformanceLevel%2A?displayProperty=nameWithType>属性和<xref:System.Xml.ConformanceLevel?displayProperty=nameWithType>枚举。  
  
    |级别|描述|  
    |-----------|-----------------|  
    |<xref:System.Xml.ConformanceLevel.Document>|XML 输出符合格式正确的 XML 1.0 文档的规则，并可以处理由任何兼容的处理器。|  
    |<xref:System.Xml.ConformanceLevel.Fragment>|XML 输出符合格式正确的 XML 1.0 文档片断的规则。|  
    |<xref:System.Xml.ConformanceLevel.Auto>|XML 编写器可以决定确认检查应用 （文档或片段） 基于传入数据的级别。|  
  
<a name="writing_elements"></a>   
## <a name="writing-elements"></a>写入元素  
 可以使用以下<xref:System.Xml.XmlWriter>编写元素节点的方法。 有关示例，请参阅所列的方法。  
  
|使用|到|  
|---------|--------|  
|<xref:System.Xml.XmlWriter.WriteElementString%2A>|编写整个元素节点，包括字符串值。|  
|<xref:System.Xml.XmlWriter.WriteStartElement%2A>|若要使用多个方法调用编写元素值。  例如，可以调用 <xref:System.Xml.XmlWriter.WriteValue%2A> 来编写类型化的值，调用 <xref:System.Xml.XmlWriter.WriteCharEntity%2A> 来编写字符实体，调用 <xref:System.Xml.XmlWriter.WriteAttributeString%2A> 来编写属性，也可以编写子元素。 这是更复杂的版本<xref:System.Xml.XmlWriter.WriteElementString%2A>方法。<br /><br /> 若要关闭元素，则调用<xref:System.Xml.XmlWriter.WriteEndElement%2A>或<xref:System.Xml.XmlWriter.WriteFullEndElement%2A>方法。|  
|<xref:System.Xml.XmlWriter.WriteNode%2A>|若要复制的当前位置找到的元素节点<xref:System.Xml.XmlReader>或<xref:System.Xml.XPath.XPathNavigator>对象。 在调用时，会将源对象中的所有内容复制到 <xref:System.Xml.XmlWriter> 实例。|  
  
<a name="writing_attributes"></a>   
## <a name="writing-attributes"></a>编写属性  
 可以使用以下<xref:System.Xml.XmlWriter>方法在元素节点上编写属性。 这些方法还将用于创建命名空间声明某个元素上下, 一节中所述。  
  
|使用|到|  
|---------|--------|  
|<xref:System.Xml.XmlWriter.WriteAttributeString%2A>|若要编写整个属性节点，包括字符串值。|  
|<xref:System.Xml.XmlWriter.WriteStartAttribute%2A>|若要编写使用多个方法调用的属性值。 例如，可以调用<xref:System.Xml.XmlWriter.WriteValue%2A>编写类型化的值。 这是更复杂的版本<xref:System.Xml.XmlWriter.WriteElementString%2A>方法。<br /><br /> 若要关闭元素，则调用<xref:System.Xml.XmlWriter.WriteEndAttribute%2A>方法。|  
|<xref:System.Xml.XmlWriter.WriteAttributes%2A>|若要复制的当前位置找到的所有特性<xref:System.Xml.XmlReader>对象。 写入的属性取决于读取器当前所处的节点的类型：<br /><br /> -对于属性节点，它将写入当前属性，然后选择属性的其余部分直到元素结束标记。<br />-对于元素节点，它将写入包含该元素的所有属性。<br />-对于 XML 声明节点，它将写入的所有属性声明中。<br />-对于所有其他节点类型，该方法将引发异常。|  
  
<a name="handling_ns"></a>   
## <a name="handling-namespaces"></a>处理命名空间  
 命名空间用于限定 XML 文档中的元素和属性的名称。 Namespace 前缀将元素和属性与又与 URI 引用关联的命名空间相关联。 命名空间在 XML 文档中实现元素和属性名称的唯一性。  
  
 <xref:System.Xml.XmlWriter>维护对应于在当前命名空间范围内定义的所有命名空间的命名空间堆栈。 在编写元素和属性时，可以通过下列方式利用命名空间：  
  
-   通过使用手动声明命名空间<xref:System.Xml.XmlWriter.WriteAttributeString%2A>方法。 如果知道如何最大程度地优化命名空间声明的数目，可以使用此方法。 有关示例，请参阅<xref:System.Xml.XmlWriter.WriteAttributeString%28System.String%2CSystem.String%2CSystem.String%2CSystem.String%29>方法。  
  
-   用新的命名空间重写当前命名空间声明。 在下面的代码中，<xref:System.Xml.XmlWriter.WriteAttributeString%2A>方法将更改命名空间 URI 为`"x"`从前缀`"123"`到`"abc"`。  
  
     [!code-csharp[XmlWriter_v2#18](~/samples/snippets/csharp/VS_Snippets_Data/XmlWriter_v2/CS/writer_v2.cs#18)]
     [!code-vb[XmlWriter_v2#18](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlWriter_v2/VB/writer_v2.vb#18)]  
  
     代码生成以下 XML 字符串：  
  
    ```xml  
    <x:root xmlns:x="123">  
      <item xmlns:x="abc" />  
    </x:root>  
    ```  
  
-   在编写属性或元素时指定命名空间前缀。 许多用于编写元素和属性的方法使您能够执行此操作。 例如，<xref:System.Xml.XmlWriter.WriteStartElement%28System.String%2CSystem.String%2CSystem.String%29>方法写入的开始标记并将其与指定的命名空间和前缀关联起来。  
  
<a name="writing_types"></a>   
## <a name="writing-typed-data"></a>写出类型化数据  
 <xref:System.Xml.XmlWriter.WriteValue%2A>方法接受公共语言运行时 (CLR) 对象、 将输入的值转换为 XML 架构定义语言 (XSD) 数据类型转换规则，根据其字符串表示形式和签出通过使用写入<xref:System.Xml.XmlWriter.WriteString%2A>方法。 这是比使用中的方法更加容易<xref:System.Xml.XmlConvert>类写出之前将类型化的数据转换为字符串值。  
  
 写入到文本时，类型化的值序列化为文本使用<xref:System.Xml.XmlConvert>架构类型的规则。  
  
 对应于 CLR 类型的默认 XSD 数据类型，请参阅<xref:System.Xml.XmlWriter.WriteValue%2A>方法。  
  
 <xref:System.Xml.XmlWriter>还可用于写入 XML 数据存储。 例如，<xref:System.Xml.XPath.XPathNavigator> 类可以创建一个 <xref:System.Xml.XmlWriter> 对象，用于为 <xref:System.Xml.XmlDocument> 对象创建节点。 如果数据存储区包含架构信息可用，<xref:System.Xml.XmlWriter.WriteValue%2A>方法将引发异常，如果你尝试转换不允许的类型。如果数据存储没有架构信息，可供<xref:System.Xml.XmlWriter.WriteValue%2A>方法将所有值视为`xsd:anySimpleType`类型。  
  
<a name="close"></a>   
## <a name="closing-the-xml-writer"></a>关闭 XML 编写器  
 当你使用<xref:System.Xml.XmlWriter>直到您调用方法以输出 XML 中，元素和属性不会写入<xref:System.Xml.XmlWriter.Close%2A>方法。 例如，如果使用的<xref:System.Xml.XmlWriter>来填充<xref:System.Xml.XmlDocument>对象，将能够看到写入的元素和目标文档中的属性，直到您关闭<xref:System.Xml.XmlWriter>实例。  
  
<a name="async"></a>   
## <a name="asynchronous-programming"></a>异步编程  
 大多数的<xref:System.Xml.XmlWriter>方法都具有有"Async"它们的方法名称结尾处的异步对应项。 例如，异步等效于<xref:System.Xml.XmlWriter.WriteAttributeString%2A>是<xref:System.Xml.XmlWriter.WriteAttributeStringAsync%2A>。  
  
 有关<xref:System.Xml.XmlWriter.WriteValue%2A>方法，它不会有异步相对应，将返回值转换为一个字符串，并使用<xref:System.Xml.XmlWriter.WriteStringAsync%2A>方法相反。  
  
<a name="security"></a>   
## <a name="security-considerations"></a>安全注意事项  
 使用时，请考虑以下<xref:System.Xml.XmlWriter>类：  
  
-   引发的异常<xref:System.Xml.XmlWriter>可能会泄露冒泡到应用程序不希望的路径信息。 您的应用程序必须捕获异常并进行相应的处理。  
  
-   <xref:System.Xml.XmlWriter> 不会验证传递到任何数据<xref:System.Xml.XmlWriter.WriteDocType%2A>或<xref:System.Xml.XmlWriter.WriteRaw%2A>方法。 不应将任意数据传递给这些方法。  
  
   
  
## Examples  
 下面的代码示例演示如何使用异步 API 来生成 XML。  
  
```csharp  
async Task TestWriter(Stream stream)   
{  
    XmlWriterSettings settings = new XmlWriterSettings();  
    settings.Async = true;  
  
    using (XmlWriter writer = XmlWriter.Create(stream, settings)) {  
        await writer.WriteStartElementAsync("pf", "root", "http://ns");  
        await writer.WriteStartElementAsync(null, "sub", null);  
        await writer.WriteAttributeStringAsync(null, "att", null, "val");  
        await writer.WriteStringAsync("text");  
        await writer.WriteEndElementAsync();  
        await writer.WriteProcessingInstructionAsync("pName", "pValue");  
        await writer.WriteCommentAsync("cValue");  
        await writer.WriteCDataAsync("cdata value");  
        await writer.WriteEndElementAsync();  
        await writer.FlushAsync();  
    }  
}  
```  
  
 ]]></format>
    </remarks>
    <related type="Article" href="https://msdn.microsoft.com/library/e695047f-3c0f-4045-8708-5baea91cc380">XML 文档和数据</related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected XmlWriter ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlWriter.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; XmlWriter();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>初始化 <see cref="T:System.Xml.XmlWriter" /> 类的新实例。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public virtual void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlWriter.Close" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Close();" />
      <MemberSignature Language="F#" Value="abstract member Close : unit -&gt; unit&#xA;override this.Close : unit -&gt; unit" Usage="xmlWriter.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>当在派生类中被重写时，将关闭此流和基础流。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 自动关闭的任何元素或属性保持打开状态。  
  
> [!NOTE]
>  当你使用<xref:System.Xml.XmlWriter>将不写入输出 XML 中，元素和属性的方法，直到你调用<xref:System.Xml.XmlWriter.Close%2A>方法。 例如，如果您使用 XmlWriter 填充<xref:System.Xml.XmlDocument>，直到关闭<xref:System.Xml.XmlWriter>，您将无法再看到写入的元素和目标文档中的特性。  
  
   
  
## Examples  
 下面的示例将写入的 XML 节点。  
  
 [!code-cpp[XmlWriter.Close#1](~/samples/snippets/cpp/VS_Snippets_Data/XmlWriter.Close/CPP/XmlWriter.Close.cpp#1)]
 [!code-csharp[XmlWriter.Close#1](~/samples/snippets/csharp/VS_Snippets_Data/XmlWriter.Close/CS/writeelems.cs#1)]
 [!code-vb[XmlWriter.Close#1](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlWriter.Close/VB/writeelems.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlWriter" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Create">
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>创建一个新的 <see cref="T:System.Xml.XmlWriter" /> 实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 一些<xref:System.Xml.XmlWriter.Create%2A>重载包括`settings`接受参数<xref:System.Xml.XmlWriterSettings>对象。 可以使用此对象：  
  
-   指定要对所创建的受支持的功能<xref:System.Xml.XmlWriter>对象。  
  
-   重复使用<xref:System.Xml.XmlWriterSettings>对象来创建多个编写器对象。 将为每个创建的写入器复制 <xref:System.Xml.XmlWriterSettings> 对象并标记为只读。 更改 <xref:System.Xml.XmlWriterSettings> 实例上的设置不会影响具有相同设置的现有写入器。 因此，可以使用相同的设置创建多个具有相同功能的写入器。 也可以修改 <xref:System.Xml.XmlWriterSettings> 实例上的设置并创建具有不同功能集的新写入器。  
  
-   将功能添加到现有的 XML 编写器。 <xref:System.Xml.XmlWriter.Create%2A> 方法可以接受其他 <xref:System.Xml.XmlWriter> 对象。 基础<xref:System.Xml.XmlWriter>对象不一定要创建的静态 XML 编写器<xref:System.Xml.XmlWriter.Create%2A>方法。 例如，可以指定用户定义的 XML 编写器来添加附加功能。  
  
-   充分利用的功能，例如更好的一致性检查和符合性[XML 1.0 建议](https://www.w3.org/TR/2006/REC-xml-20060816/)仅在上可用<xref:System.Xml.XmlWriter>创建的静态对象<xref:System.Xml.XmlWriter.Create%2A>方法。  
  
 如果您使用<xref:System.Xml.XmlWriter.Create%2A>重载不接受<xref:System.Xml.XmlWriterSettings>对象，使用以下默认编写器设置：  
  
|设置|默认|  
|-------------|-------------|  
|<xref:System.Xml.XmlWriterSettings.CheckCharacters%2A>|`true`|  
|<xref:System.Xml.XmlWriterSettings.CloseOutput%2A>|`false`|  
|<xref:System.Xml.XmlWriterSettings.ConformanceLevel%2A>|<xref:System.Xml.ConformanceLevel.Document?displayProperty=nameWithType>|  
|<xref:System.Xml.XmlWriterSettings.Encoding%2A>|<xref:System.Text.Encoding.UTF8?displayProperty=nameWithType>|  
|<xref:System.Xml.XmlWriterSettings.Indent%2A>|`false`|  
|<xref:System.Xml.XmlWriterSettings.IndentChars%2A>|两个空格|  
|<xref:System.Xml.XmlWriterSettings.NamespaceHandling%2A>|<xref:System.Xml.NamespaceHandling.Default> （不执行删除）|  
|<xref:System.Xml.XmlWriterSettings.NewLineChars%2A>|`\r\n`（回车符、换行符）|  
|<xref:System.Xml.XmlWriterSettings.NewLineHandling%2A>|<xref:System.Xml.NewLineHandling.Replace?displayProperty=nameWithType>|  
|<xref:System.Xml.XmlWriterSettings.NewLineOnAttributes%2A>|`false`|  
|<xref:System.Xml.XmlWriterSettings.OmitXmlDeclaration%2A>|`false`|  
|<xref:System.Xml.XmlWriterSettings.OutputMethod%2A>|<xref:System.Xml.XmlOutputMethod.Xml?displayProperty=nameWithType>|  
|<xref:System.Xml.XmlWriterSettings.WriteEndDocumentOnClose%2A>|`true`|  
  
> [!NOTE]
>  尽管.NET Framework 包括<xref:System.Xml.XmlTextWriter>类，该类是一个具体的实现的<xref:System.Xml.XmlWriter>类中，我们建议您创建<xref:System.Xml.XmlWriter>实例使用<xref:System.Xml.XmlWriter.Create%2A>方法。  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Xml.XmlWriter Create (System.IO.Stream output);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.XmlWriter Create(class System.IO.Stream output) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlWriter.Create(System.IO.Stream)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create (output As Stream) As XmlWriter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Xml::XmlWriter ^ Create(System::IO::Stream ^ output);" />
      <MemberSignature Language="F#" Value="static member Create : System.IO.Stream -&gt; System.Xml.XmlWriter" Usage="System.Xml.XmlWriter.Create output" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Xml.XmlWriter</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="output" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="output">要对其写入的流。 <see cref="T:System.Xml.XmlWriter" /> 编写 XML 1.0 文本语法并将其追加到指定的流中。</param>
        <summary>使用指定的流创建一个新的 <see cref="T:System.Xml.XmlWriter" /> 实例。</summary>
        <returns>一个 <see cref="T:System.Xml.XmlWriter" /> 对象。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用此重载时<xref:System.Xml.XmlWriterSettings>对象具有以下默认设置用于创建 XML 编写器：  
  
|设置|默认|  
|-------------|-------------|  
|<xref:System.Xml.XmlWriterSettings.CheckCharacters%2A>|`true`|  
|<xref:System.Xml.XmlWriterSettings.CloseOutput%2A>|`false`|  
|<xref:System.Xml.XmlWriterSettings.ConformanceLevel%2A>|<xref:System.Xml.ConformanceLevel.Document?displayProperty=nameWithType>|  
|<xref:System.Xml.XmlWriterSettings.Encoding%2A>|<xref:System.Text.Encoding.UTF8?displayProperty=nameWithType>|  
|<xref:System.Xml.XmlWriterSettings.Indent%2A>|`false`|  
|<xref:System.Xml.XmlWriterSettings.IndentChars%2A>|两个空格|  
|<xref:System.Xml.XmlWriterSettings.NamespaceHandling%2A>|<xref:System.Xml.NamespaceHandling.Default> （不执行删除）|  
|<xref:System.Xml.XmlWriterSettings.NewLineChars%2A>|`\r\n`（回车符、换行符）|  
|<xref:System.Xml.XmlWriterSettings.NewLineHandling%2A>|<xref:System.Xml.NewLineHandling.Replace?displayProperty=nameWithType>|  
|<xref:System.Xml.XmlWriterSettings.NewLineOnAttributes%2A>|`false`|  
|<xref:System.Xml.XmlWriterSettings.OmitXmlDeclaration%2A>|`false`|  
|<xref:System.Xml.XmlWriterSettings.OutputMethod%2A>|<xref:System.Xml.XmlOutputMethod.Xml?displayProperty=nameWithType>|  
|<xref:System.Xml.XmlWriterSettings.WriteEndDocumentOnClose%2A>|`true`|  
  
 如果你想要指定要在创建编写器上支持的功能，使用重载采用<xref:System.Xml.XmlWriterSettings>对象作为其参数之一，并传入<xref:System.Xml.XmlWriterSettings>使用自定义设置的对象。  
  
 此外，XmlWriter 始终将字节顺序标记 (BOM) 写入基础数据流;但是，某些流必须不具有 BOM。 若要忽略 BOM，创建一个新<xref:System.Xml.XmlWriterSettings>对象并设置要将一个新的编码属性<xref:System.Text.UTF8Encoding>中构造函数设置为 false 的布尔值的对象。  
  
   
  
## Examples  
 下面的示例将 XML 片段写入到内存流。 (它使用<xref:System.Xml.XmlWriter.Create%28System.IO.Stream%2CSystem.Xml.XmlWriterSettings%29>重载，这还将在新的 XML 编写器实例上配置设置。)  
  
 [!code-csharp[XmlWriterSettings.CloseOutput#1](~/samples/snippets/csharp/VS_Snippets_Data/XmlWriterSettings.CloseOutput/CS/writestream2.cs#1)]
 [!code-vb[XmlWriterSettings.CloseOutput#1](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlWriterSettings.CloseOutput/VB/writestream2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="stream" /> 值为 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Xml.XmlWriter Create (System.IO.TextWriter output);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.XmlWriter Create(class System.IO.TextWriter output) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlWriter.Create(System.IO.TextWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create (output As TextWriter) As XmlWriter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Xml::XmlWriter ^ Create(System::IO::TextWriter ^ output);" />
      <MemberSignature Language="F#" Value="static member Create : System.IO.TextWriter -&gt; System.Xml.XmlWriter" Usage="System.Xml.XmlWriter.Create output" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Xml.XmlWriter</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="output" Type="System.IO.TextWriter" />
      </Parameters>
      <Docs>
        <param name="output">要写入的 <see cref="T:System.IO.TextWriter" />。 <see cref="T:System.Xml.XmlWriter" /> 编写 XML 1.0 文本语法，并将该语法追加到指定 <see cref="T:System.IO.TextWriter" />。</param>
        <summary>使用指定的 <see cref="T:System.Xml.XmlWriter" /> 创建一个新的 <see cref="T:System.IO.TextWriter" /> 实例。</summary>
        <returns>一个 <see cref="T:System.Xml.XmlWriter" /> 对象。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用此重载时<xref:System.Xml.XmlWriterSettings>对象使用默认设置用于创建 XML 编写器。  
  
|设置|默认|  
|-------------|-------------|  
|<xref:System.Xml.XmlWriterSettings.CheckCharacters%2A>|`true`|  
|<xref:System.Xml.XmlWriterSettings.CloseOutput%2A>|`false`|  
|<xref:System.Xml.XmlWriterSettings.ConformanceLevel%2A>|<xref:System.Xml.ConformanceLevel.Document?displayProperty=nameWithType>|  
|<xref:System.Xml.XmlWriterSettings.Encoding%2A>|<xref:System.Text.Encoding.UTF8?displayProperty=nameWithType>|  
|<xref:System.Xml.XmlWriterSettings.Indent%2A>|`false`|  
|<xref:System.Xml.XmlWriterSettings.IndentChars%2A>|两个空格|  
|<xref:System.Xml.XmlWriterSettings.NamespaceHandling%2A>|<xref:System.Xml.NamespaceHandling.Default> （不执行删除）|  
|<xref:System.Xml.XmlWriterSettings.NewLineChars%2A>|`\r\n`（回车符、换行符）|  
|<xref:System.Xml.XmlWriterSettings.NewLineHandling%2A>|<xref:System.Xml.NewLineHandling.Replace?displayProperty=nameWithType>|  
|<xref:System.Xml.XmlWriterSettings.NewLineOnAttributes%2A>|`false`|  
|<xref:System.Xml.XmlWriterSettings.OmitXmlDeclaration%2A>|`false`|  
|<xref:System.Xml.XmlWriterSettings.OutputMethod%2A>|<xref:System.Xml.XmlOutputMethod.Xml?displayProperty=nameWithType>|  
|<xref:System.Xml.XmlWriterSettings.WriteEndDocumentOnClose%2A>|`true`|  
  
 如果你想要指定要在创建编写器上支持的功能，使用重载采用<xref:System.Xml.XmlWriterSettings>对象作为其参数之一，并传入<xref:System.Xml.XmlWriterSettings>使用自定义设置的对象。  
  
   
  
## Examples  
 下面的示例创建的编写器输出到控制台。  
  
 [!code-csharp[XmlWriter_v2#3](~/samples/snippets/csharp/VS_Snippets_Data/XmlWriter_v2/CS/writer_v2.cs#3)]
 [!code-vb[XmlWriter_v2#3](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlWriter_v2/VB/writer_v2.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="text" /> 值为 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Xml.XmlWriter Create (string outputFileName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.XmlWriter Create(string outputFileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlWriter.Create(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create (outputFileName As String) As XmlWriter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Xml::XmlWriter ^ Create(System::String ^ outputFileName);" />
      <MemberSignature Language="F#" Value="static member Create : string -&gt; System.Xml.XmlWriter" Usage="System.Xml.XmlWriter.Create outputFileName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Xml.XmlWriter</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="outputFileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="outputFileName">要对其写入的文件。 <see cref="T:System.Xml.XmlWriter" /> 在指定路径上创建一个文件，并采用 XML 1.0 文本语法写入该文件。 <paramref name="outputFileName" /> 必须为文件系统路径。</param>
        <summary>使用指定的文件名创建一个新的 <see cref="T:System.Xml.XmlWriter" /> 实例。</summary>
        <returns>一个 <see cref="T:System.Xml.XmlWriter" /> 对象。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用此重载时<xref:System.Xml.XmlWriterSettings>对象使用默认设置用于创建 XML 编写器。  
  
|设置|默认|  
|-------------|-------------|  
|<xref:System.Xml.XmlWriterSettings.CheckCharacters%2A>|`true`|  
|<xref:System.Xml.XmlWriterSettings.CloseOutput%2A>|`false`|  
|<xref:System.Xml.XmlWriterSettings.ConformanceLevel%2A>|<xref:System.Xml.ConformanceLevel.Document?displayProperty=nameWithType>|  
|<xref:System.Xml.XmlWriterSettings.Encoding%2A>|<xref:System.Text.Encoding.UTF8?displayProperty=nameWithType>|  
|<xref:System.Xml.XmlWriterSettings.Indent%2A>|`false`|  
|<xref:System.Xml.XmlWriterSettings.IndentChars%2A>|两个空格|  
|<xref:System.Xml.XmlWriterSettings.NamespaceHandling%2A>|<xref:System.Xml.NamespaceHandling.Default> （不执行删除）|  
|<xref:System.Xml.XmlWriterSettings.NewLineChars%2A>|`\r\n`（回车符、换行符）|  
|<xref:System.Xml.XmlWriterSettings.NewLineHandling%2A>|<xref:System.Xml.NewLineHandling.Replace?displayProperty=nameWithType>|  
|<xref:System.Xml.XmlWriterSettings.NewLineOnAttributes%2A>|`false`|  
|<xref:System.Xml.XmlWriterSettings.OmitXmlDeclaration%2A>|`false`|  
|<xref:System.Xml.XmlWriterSettings.OutputMethod%2A>|<xref:System.Xml.XmlOutputMethod.Xml?displayProperty=nameWithType>|  
|<xref:System.Xml.XmlWriterSettings.WriteEndDocumentOnClose%2A>|`true`|  
  
 如果你想要指定要在创建 XML 编写器上支持的功能，使用重载采用<xref:System.Xml.XmlWriterSettings>对象作为其参数之一，并传入<xref:System.Xml.XmlWriterSettings>使用自定义设置的对象。  
  
   
  
## Examples  
 下面的示例创建<xref:System.Xml.XmlWriter>对象，并将写入 book 节点。  
  
 [!code-csharp[XmlWriter_v2#2](~/samples/snippets/csharp/VS_Snippets_Data/XmlWriter_v2/CS/writer_v2.cs#2)]
 [!code-vb[XmlWriter_v2#2](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlWriter_v2/VB/writer_v2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="url" /> 值为 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Xml.XmlWriter Create (System.Text.StringBuilder output);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.XmlWriter Create(class System.Text.StringBuilder output) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlWriter.Create(System.Text.StringBuilder)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create (output As StringBuilder) As XmlWriter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Xml::XmlWriter ^ Create(System::Text::StringBuilder ^ output);" />
      <MemberSignature Language="F#" Value="static member Create : System.Text.StringBuilder -&gt; System.Xml.XmlWriter" Usage="System.Xml.XmlWriter.Create output" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Xml.XmlWriter</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="output" Type="System.Text.StringBuilder" />
      </Parameters>
      <Docs>
        <param name="output">要写入的 <see cref="T:System.Text.StringBuilder" />。 由 <see cref="T:System.Xml.XmlWriter" /> 写入的内容被追加到 <see cref="T:System.Text.StringBuilder" />。</param>
        <summary>使用指定的 <see cref="T:System.Xml.XmlWriter" /> 创建一个新的 <see cref="T:System.Text.StringBuilder" /> 实例。</summary>
        <returns>一个 <see cref="T:System.Xml.XmlWriter" /> 对象。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用此重载时<xref:System.Xml.XmlWriterSettings>对象使用默认设置用于创建 XML 编写器。  
  
|设置|默认|  
|-------------|-------------|  
|<xref:System.Xml.XmlWriterSettings.CheckCharacters%2A>|`true`|  
|<xref:System.Xml.XmlWriterSettings.CloseOutput%2A>|`false`|  
|<xref:System.Xml.XmlWriterSettings.ConformanceLevel%2A>|<xref:System.Xml.ConformanceLevel.Document?displayProperty=nameWithType>|  
|<xref:System.Xml.XmlWriterSettings.Encoding%2A>|<xref:System.Text.Encoding.UTF8?displayProperty=nameWithType>|  
|<xref:System.Xml.XmlWriterSettings.Indent%2A>|`false`|  
|<xref:System.Xml.XmlWriterSettings.IndentChars%2A>|两个空格|  
|<xref:System.Xml.XmlWriterSettings.NamespaceHandling%2A>|<xref:System.Xml.NamespaceHandling.Default> （不执行删除）|  
|<xref:System.Xml.XmlWriterSettings.NewLineChars%2A>|`\r\n`（回车符、换行符）|  
|<xref:System.Xml.XmlWriterSettings.NewLineHandling%2A>|<xref:System.Xml.NewLineHandling.Replace?displayProperty=nameWithType>|  
|<xref:System.Xml.XmlWriterSettings.NewLineOnAttributes%2A>|`false`|  
|<xref:System.Xml.XmlWriterSettings.OmitXmlDeclaration%2A>|`false`|  
|<xref:System.Xml.XmlWriterSettings.OutputMethod%2A>|<xref:System.Xml.XmlOutputMethod.Xml?displayProperty=nameWithType>|  
|<xref:System.Xml.XmlWriterSettings.WriteEndDocumentOnClose%2A>|`true`|  
  
 如果你想要指定要在创建 XML 编写器上支持的功能，使用重载采用<xref:System.Xml.XmlWriterSettings>对象作为其参数之一，并传入<xref:System.Xml.XmlWriterSettings>使用自定义设置的对象。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="builder" /> 值为 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Xml.XmlWriter Create (System.Xml.XmlWriter output);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.XmlWriter Create(class System.Xml.XmlWriter output) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlWriter.Create(System.Xml.XmlWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create (output As XmlWriter) As XmlWriter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Xml::XmlWriter ^ Create(System::Xml::XmlWriter ^ output);" />
      <MemberSignature Language="F#" Value="static member Create : System.Xml.XmlWriter -&gt; System.Xml.XmlWriter" Usage="System.Xml.XmlWriter.Create output" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Xml.XmlWriter</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="output" Type="System.Xml.XmlWriter" />
      </Parameters>
      <Docs>
        <param name="output">要用作基础编写器的 <see cref="T:System.Xml.XmlWriter" /> 对象。</param>
        <summary>使用指定的 <see cref="T:System.Xml.XmlWriter" /> 对象创建一个新的 <see cref="T:System.Xml.XmlWriter" /> 实例。</summary>
        <returns>一个 <see cref="T:System.Xml.XmlWriter" /> 对象，是指定的 <see cref="T:System.Xml.XmlWriter" /> 对象周围的包装。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法允许将功能添加到基础<xref:System.Xml.XmlWriter>对象。 基础<xref:System.Xml.XmlWriter>对象可以是创建的对象<xref:System.Xml.XmlWriter.Create%2A?displayProperty=nameWithType>方法或使用创建的对象<xref:System.Xml.XmlTextWriter>实现。  
  
 使用此重载时<xref:System.Xml.XmlWriterSettings>对象使用默认设置用于创建 XML 编写器。  
  
|设置|默认|  
|-------------|-------------|  
|<xref:System.Xml.XmlWriterSettings.CheckCharacters%2A>|`true`|  
|<xref:System.Xml.XmlWriterSettings.CloseOutput%2A>|`false`|  
|<xref:System.Xml.XmlWriterSettings.ConformanceLevel%2A>|<xref:System.Xml.ConformanceLevel.Document?displayProperty=nameWithType>|  
|<xref:System.Xml.XmlWriterSettings.Encoding%2A>|<xref:System.Text.Encoding.UTF8?displayProperty=nameWithType>|  
|<xref:System.Xml.XmlWriterSettings.Indent%2A>|`false`|  
|<xref:System.Xml.XmlWriterSettings.IndentChars%2A>|两个空格|  
|<xref:System.Xml.XmlWriterSettings.NamespaceHandling%2A>|<xref:System.Xml.NamespaceHandling.Default> （不执行删除）|  
|<xref:System.Xml.XmlWriterSettings.NewLineChars%2A>|`\r\n`（回车符、换行符）|  
|<xref:System.Xml.XmlWriterSettings.NewLineHandling%2A>|<xref:System.Xml.NewLineHandling.Replace?displayProperty=nameWithType>|  
|<xref:System.Xml.XmlWriterSettings.NewLineOnAttributes%2A>|`false`|  
|<xref:System.Xml.XmlWriterSettings.OmitXmlDeclaration%2A>|`false`|  
|<xref:System.Xml.XmlWriterSettings.OutputMethod%2A>|<xref:System.Xml.XmlOutputMethod.Xml?displayProperty=nameWithType>|  
|<xref:System.Xml.XmlWriterSettings.WriteEndDocumentOnClose%2A>|`true`|  
  
 如果你想要指定要在创建 XML 编写器上支持的功能，使用重载采用<xref:System.Xml.XmlWriterSettings>对象作为其参数之一，并传入<xref:System.Xml.XmlWriterSettings>使用自定义设置的对象。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="writer" /> 值为 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Xml.XmlWriter Create (System.IO.Stream output, System.Xml.XmlWriterSettings settings);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.XmlWriter Create(class System.IO.Stream output, class System.Xml.XmlWriterSettings settings) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlWriter.Create(System.IO.Stream,System.Xml.XmlWriterSettings)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create (output As Stream, settings As XmlWriterSettings) As XmlWriter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Xml::XmlWriter ^ Create(System::IO::Stream ^ output, System::Xml::XmlWriterSettings ^ settings);" />
      <MemberSignature Language="F#" Value="static member Create : System.IO.Stream * System.Xml.XmlWriterSettings -&gt; System.Xml.XmlWriter" Usage="System.Xml.XmlWriter.Create (output, settings)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlWriter</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="output" Type="System.IO.Stream" />
        <Parameter Name="settings" Type="System.Xml.XmlWriterSettings" />
      </Parameters>
      <Docs>
        <param name="output">要对其写入的流。 <see cref="T:System.Xml.XmlWriter" /> 编写 XML 1.0 文本语法并将其追加到指定的流中。</param>
        <param name="settings">用于配置新 <see cref="T:System.Xml.XmlWriterSettings" /> 实例的 <see cref="T:System.Xml.XmlWriter" /> 对象。 如果这是 <see langword="null" />，则使用具有默认设置的 <see cref="T:System.Xml.XmlWriterSettings" />。  
  
如果将 <see cref="T:System.Xml.XmlWriter" /> 用于 <see cref="M:System.Xml.Xsl.XslCompiledTransform.Transform(System.String,System.Xml.XmlWriter)" /> 方法，则应使用 <see cref="P:System.Xml.Xsl.XslCompiledTransform.OutputSettings" /> 属性获取具有正确设置的 <see cref="T:System.Xml.XmlWriterSettings" /> 对象。 这样可以确保所创建的 <see cref="T:System.Xml.XmlWriter" /> 对象的输出设置是正确的。</param>
        <summary>使用流和 <see cref="T:System.Xml.XmlWriter" /> 对象创建一个新的 <see cref="T:System.Xml.XmlWriterSettings" /> 实例。</summary>
        <returns>一个 <see cref="T:System.Xml.XmlWriter" /> 对象。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 XmlWriter 始终将字节顺序标记 (BOM) 写入到基础数据流;但是，某些流必须不具有 BOM。 若要忽略 BOM，创建一个新<xref:System.Xml.XmlWriterSettings>对象并设置要将一个新的编码属性<xref:System.Text.UTF8Encoding>中构造函数设置为 false 的布尔值的对象。  
  
   
  
## Examples  
 下面的示例将 XML 片段写入到内存流。  
  
 [!code-csharp[XmlWriterSettings.CloseOutput#1](~/samples/snippets/csharp/VS_Snippets_Data/XmlWriterSettings.CloseOutput/CS/writestream2.cs#1)]
 [!code-vb[XmlWriterSettings.CloseOutput#1](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlWriterSettings.CloseOutput/VB/writestream2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="stream" /> 值为 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Xml.XmlWriter Create (System.IO.TextWriter output, System.Xml.XmlWriterSettings settings);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.XmlWriter Create(class System.IO.TextWriter output, class System.Xml.XmlWriterSettings settings) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlWriter.Create(System.IO.TextWriter,System.Xml.XmlWriterSettings)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create (output As TextWriter, settings As XmlWriterSettings) As XmlWriter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Xml::XmlWriter ^ Create(System::IO::TextWriter ^ output, System::Xml::XmlWriterSettings ^ settings);" />
      <MemberSignature Language="F#" Value="static member Create : System.IO.TextWriter * System.Xml.XmlWriterSettings -&gt; System.Xml.XmlWriter" Usage="System.Xml.XmlWriter.Create (output, settings)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlWriter</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="output" Type="System.IO.TextWriter" />
        <Parameter Name="settings" Type="System.Xml.XmlWriterSettings" />
      </Parameters>
      <Docs>
        <param name="output">要写入的 <see cref="T:System.IO.TextWriter" />。 <see cref="T:System.Xml.XmlWriter" /> 编写 XML 1.0 文本语法，并将该语法追加到指定 <see cref="T:System.IO.TextWriter" />。</param>
        <param name="settings">用于配置新 <see cref="T:System.Xml.XmlWriterSettings" /> 实例的 <see cref="T:System.Xml.XmlWriter" /> 对象。 如果这是 <see langword="null" />，则使用具有默认设置的 <see cref="T:System.Xml.XmlWriterSettings" />。  
  
如果将 <see cref="T:System.Xml.XmlWriter" /> 用于 <see cref="M:System.Xml.Xsl.XslCompiledTransform.Transform(System.String,System.Xml.XmlWriter)" /> 方法，则应使用 <see cref="P:System.Xml.Xsl.XslCompiledTransform.OutputSettings" /> 属性获取具有正确设置的 <see cref="T:System.Xml.XmlWriterSettings" /> 对象。 这样可以确保所创建的 <see cref="T:System.Xml.XmlWriter" /> 对象的输出设置是正确的。</param>
        <summary>使用 <see cref="T:System.Xml.XmlWriter" /> 和 <see cref="T:System.IO.TextWriter" /> 对象创建一个新的 <see cref="T:System.Xml.XmlWriterSettings" /> 实例。</summary>
        <returns>一个 <see cref="T:System.Xml.XmlWriter" /> 对象。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下面的示例写出一个 XML 字符串。  
  
 [!code-csharp[XmlWriter_v2#4](~/samples/snippets/csharp/VS_Snippets_Data/XmlWriter_v2/CS/writer_v2.cs#4)]
 [!code-vb[XmlWriter_v2#4](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlWriter_v2/VB/writer_v2.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="text" /> 值为 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Xml.XmlWriter Create (string outputFileName, System.Xml.XmlWriterSettings settings);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.XmlWriter Create(string outputFileName, class System.Xml.XmlWriterSettings settings) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlWriter.Create(System.String,System.Xml.XmlWriterSettings)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create (outputFileName As String, settings As XmlWriterSettings) As XmlWriter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Xml::XmlWriter ^ Create(System::String ^ outputFileName, System::Xml::XmlWriterSettings ^ settings);" />
      <MemberSignature Language="F#" Value="static member Create : string * System.Xml.XmlWriterSettings -&gt; System.Xml.XmlWriter" Usage="System.Xml.XmlWriter.Create (outputFileName, settings)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlWriter</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="outputFileName" Type="System.String" />
        <Parameter Name="settings" Type="System.Xml.XmlWriterSettings" />
      </Parameters>
      <Docs>
        <param name="outputFileName">要对其写入的文件。 <see cref="T:System.Xml.XmlWriter" /> 在指定路径上创建一个文件，并采用 XML 1.0 文本语法写入该文件。 <paramref name="outputFileName" /> 必须为文件系统路径。</param>
        <param name="settings">用于配置新 <see cref="T:System.Xml.XmlWriterSettings" /> 实例的 <see cref="T:System.Xml.XmlWriter" /> 对象。 如果这是 <see langword="null" />，则使用具有默认设置的 <see cref="T:System.Xml.XmlWriterSettings" />。  
  
如果将 <see cref="T:System.Xml.XmlWriter" /> 用于 <see cref="M:System.Xml.Xsl.XslCompiledTransform.Transform(System.String,System.Xml.XmlWriter)" /> 方法，则应使用 <see cref="P:System.Xml.Xsl.XslCompiledTransform.OutputSettings" /> 属性获取具有正确设置的 <see cref="T:System.Xml.XmlWriterSettings" /> 对象。 这样可以确保所创建的 <see cref="T:System.Xml.XmlWriter" /> 对象的输出设置是正确的。</param>
        <summary>使用文件名和 <see cref="T:System.Xml.XmlWriter" /> 对象创建一个新的 <see cref="T:System.Xml.XmlWriterSettings" /> 实例。</summary>
        <returns>一个 <see cref="T:System.Xml.XmlWriter" /> 对象。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下面的示例创建<xref:System.Xml.XmlWriter>具有已定义的设置对象。  
  
 [!code-csharp[XmlWriterSettings.Indent#1](~/samples/snippets/csharp/VS_Snippets_Data/XmlWriterSettings.Indent/CS/writeindent.cs#1)]
 [!code-vb[XmlWriterSettings.Indent#1](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlWriterSettings.Indent/VB/writeindent.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="url" /> 值为 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Xml.XmlWriter Create (System.Text.StringBuilder output, System.Xml.XmlWriterSettings settings);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.XmlWriter Create(class System.Text.StringBuilder output, class System.Xml.XmlWriterSettings settings) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlWriter.Create(System.Text.StringBuilder,System.Xml.XmlWriterSettings)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create (output As StringBuilder, settings As XmlWriterSettings) As XmlWriter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Xml::XmlWriter ^ Create(System::Text::StringBuilder ^ output, System::Xml::XmlWriterSettings ^ settings);" />
      <MemberSignature Language="F#" Value="static member Create : System.Text.StringBuilder * System.Xml.XmlWriterSettings -&gt; System.Xml.XmlWriter" Usage="System.Xml.XmlWriter.Create (output, settings)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlWriter</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="output" Type="System.Text.StringBuilder" />
        <Parameter Name="settings" Type="System.Xml.XmlWriterSettings" />
      </Parameters>
      <Docs>
        <param name="output">要写入的 <see cref="T:System.Text.StringBuilder" />。 由 <see cref="T:System.Xml.XmlWriter" /> 写入的内容被追加到 <see cref="T:System.Text.StringBuilder" />。</param>
        <param name="settings">用于配置新 <see cref="T:System.Xml.XmlWriterSettings" /> 实例的 <see cref="T:System.Xml.XmlWriter" /> 对象。 如果这是 <see langword="null" />，则使用具有默认设置的 <see cref="T:System.Xml.XmlWriterSettings" />。  
  
如果将 <see cref="T:System.Xml.XmlWriter" /> 用于 <see cref="M:System.Xml.Xsl.XslCompiledTransform.Transform(System.String,System.Xml.XmlWriter)" /> 方法，则应使用 <see cref="P:System.Xml.Xsl.XslCompiledTransform.OutputSettings" /> 属性获取具有正确设置的 <see cref="T:System.Xml.XmlWriterSettings" /> 对象。 这样可以确保所创建的 <see cref="T:System.Xml.XmlWriter" /> 对象的输出设置是正确的。</param>
        <summary>使用 <see cref="T:System.Xml.XmlWriter" /> 和 <see cref="T:System.Text.StringBuilder" /> 对象创建一个新的 <see cref="T:System.Xml.XmlWriterSettings" /> 实例。</summary>
        <returns>一个 <see cref="T:System.Xml.XmlWriter" /> 对象。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="builder" /> 值为 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Xml.XmlWriter Create (System.Xml.XmlWriter output, System.Xml.XmlWriterSettings settings);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.XmlWriter Create(class System.Xml.XmlWriter output, class System.Xml.XmlWriterSettings settings) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlWriter.Create(System.Xml.XmlWriter,System.Xml.XmlWriterSettings)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create (output As XmlWriter, settings As XmlWriterSettings) As XmlWriter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Xml::XmlWriter ^ Create(System::Xml::XmlWriter ^ output, System::Xml::XmlWriterSettings ^ settings);" />
      <MemberSignature Language="F#" Value="static member Create : System.Xml.XmlWriter * System.Xml.XmlWriterSettings -&gt; System.Xml.XmlWriter" Usage="System.Xml.XmlWriter.Create (output, settings)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlWriter</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="output" Type="System.Xml.XmlWriter" />
        <Parameter Name="settings" Type="System.Xml.XmlWriterSettings" />
      </Parameters>
      <Docs>
        <param name="output">要用作基础编写器的 <see cref="T:System.Xml.XmlWriter" /> 对象。</param>
        <param name="settings">用于配置新 <see cref="T:System.Xml.XmlWriterSettings" /> 实例的 <see cref="T:System.Xml.XmlWriter" /> 对象。 如果这是 <see langword="null" />，则使用具有默认设置的 <see cref="T:System.Xml.XmlWriterSettings" />。  
  
如果将 <see cref="T:System.Xml.XmlWriter" /> 用于 <see cref="M:System.Xml.Xsl.XslCompiledTransform.Transform(System.String,System.Xml.XmlWriter)" /> 方法，则应使用 <see cref="P:System.Xml.Xsl.XslCompiledTransform.OutputSettings" /> 属性获取具有正确设置的 <see cref="T:System.Xml.XmlWriterSettings" /> 对象。 这样可以确保所创建的 <see cref="T:System.Xml.XmlWriter" /> 对象的输出设置是正确的。</param>
        <summary>使用指定的 <see cref="T:System.Xml.XmlWriter" /> 和 <see cref="T:System.Xml.XmlWriter" /> 对象创建一个新的 <see cref="T:System.Xml.XmlWriterSettings" /> 实例。</summary>
        <returns>一个 <see cref="T:System.Xml.XmlWriter" /> 对象，是指定的 <see cref="T:System.Xml.XmlWriter" /> 对象周围的包装。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法允许将其他功能添加到基础<xref:System.Xml.XmlWriter>对象。 基础<xref:System.Xml.XmlWriter>对象可以是创建的对象<xref:System.Xml.XmlWriter.Create%2A?displayProperty=nameWithType>方法或使用创建的对象<xref:System.Xml.XmlTextWriter>实现。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="writer" /> 值为 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Dispose">
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <exception cref="T:System.InvalidOperationException">在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlWriter" /> 方法。 在此情况下，将引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中”。</exception>
        <summary>释放 <see cref="T:System.Xml.XmlWriter" /> 类使用的资源。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlWriter.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="xmlWriter.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>释放 <see cref="T:System.Xml.XmlWriter" /> 类的当前实例所使用的所有资源。</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlWriter" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”</exception>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlWriter.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="abstract member Dispose : bool -&gt; unit&#xA;override this.Dispose : bool -&gt; unit" Usage="xmlWriter.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">若要释放托管资源和非托管资源，则为 <see langword="true" />；若仅释放非托管资源，则为 <see langword="false" />。</param>
        <summary>释放由 <see cref="T:System.Xml.XmlWriter" /> 占用的非托管资源，还可以另外再释放托管资源。</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlWriter" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”</exception>
      </Docs>
    </Member>
    <Member MemberName="Flush">
      <MemberSignature Language="C#" Value="public abstract void Flush ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Flush() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlWriter.Flush" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Sub Flush ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void Flush();" />
      <MemberSignature Language="F#" Value="abstract member Flush : unit -&gt; unit" Usage="xmlWriter.Flush " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>当在派生类中被重写时，将缓冲区中的所有内容刷新到基础流，并同时刷新基础流。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 这称为而不是<xref:System.Xml.XmlWriter.Close%2A>当你想要写入到基础流的详细信息而不会丢失仍在缓冲区中。  
  
 此方法的异步版本，请参阅<xref:System.Xml.XmlWriter.FlushAsync%2A>。  
  
   
  
## Examples  
 下面的示例将两个 XML 片段。  
  
 [!code-cpp[XmlWriter.Flush#1](~/samples/snippets/cpp/VS_Snippets_Data/XmlWriter.Flush/CPP/write2docs_v2.cpp#1)]
 [!code-csharp[XmlWriter.Flush#1](~/samples/snippets/csharp/VS_Snippets_Data/XmlWriter.Flush/CS/write2docs_v2.cs#1)]
 [!code-vb[XmlWriter.Flush#1](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlWriter.Flush/VB/write2docs_v2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlWriter" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”</exception>
      </Docs>
    </Member>
    <Member MemberName="FlushAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task FlushAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task FlushAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlWriter.FlushAsync" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function FlushAsync () As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task ^ FlushAsync();" />
      <MemberSignature Language="F#" Value="abstract member FlushAsync : unit -&gt; System.Threading.Tasks.Task&#xA;override this.FlushAsync : unit -&gt; System.Threading.Tasks.Task" Usage="xmlWriter.FlushAsync " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>将缓冲区中的所有内容异步刷新到基础流，并同时刷新基础流。</summary>
        <returns>表示 <see langword="Flush" /> 异步操作的任务。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 这是异步版本<xref:System.Xml.XmlWriter.Flush%2A>，具有相同功能。 若要使用此方法，必须设置<xref:System.Xml.XmlWriterSettings.Async%2A>标记，用于`true`。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">调用了 <see cref="T:System.Xml.XmlWriter" /> 异步方法，但未将 <see cref="P:System.Xml.XmlWriterSettings.Async" /> 标志设置为 <see langword="true" />。 在这种情况下，将引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“如果要使用异步方法，请将 XmlWriterSettings.Async 设置为 true”。</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/db854f91-ccef-4035-ae4d-0911fde808c7">使用 Async 和 Await 的异步编程（C# 和 Visual Basic）</related>
      </Docs>
    </Member>
    <Member MemberName="LookupPrefix">
      <MemberSignature Language="C#" Value="public abstract string LookupPrefix (string ns);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string LookupPrefix(string ns) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlWriter.LookupPrefix(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function LookupPrefix (ns As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::String ^ LookupPrefix(System::String ^ ns);" />
      <MemberSignature Language="F#" Value="abstract member LookupPrefix : string -&gt; string" Usage="xmlWriter.LookupPrefix ns" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ns" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="ns">要查找其前缀的命名空间 URI。</param>
        <summary>当在派生类中被重写时，返回在当前命名空间范围中为该命名空间 URI 定义的最近的前缀。</summary>
        <returns>匹配的前缀；如果当前范围内未找到匹配的命名空间 URI，则为 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下面的示例写出一本书。  
  
 [!code-cpp[XmlWriter.WriteElementString#1](~/samples/snippets/cpp/VS_Snippets_Data/XmlWriter.WriteElementString/CPP/writeelemstring_v2.cpp#1)]
 [!code-csharp[XmlWriter.WriteElementString#1](~/samples/snippets/csharp/VS_Snippets_Data/XmlWriter.WriteElementString/CS/writeelemstring_v2.cs#1)]
 [!code-vb[XmlWriter.WriteElementString#1](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlWriter.WriteElementString/VB/writeelemstring_v2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="ns" /> 为 <see langword="null" /> 或 <see langword="String.Empty" />。</exception>
        <exception cref="T:System.InvalidOperationException">在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlWriter" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”</exception>
      </Docs>
    </Member>
    <Member MemberName="Settings">
      <MemberSignature Language="C#" Value="public virtual System.Xml.XmlWriterSettings Settings { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xml.XmlWriterSettings Settings" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlWriter.Settings" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Settings As XmlWriterSettings" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Xml::XmlWriterSettings ^ Settings { System::Xml::XmlWriterSettings ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Settings : System.Xml.XmlWriterSettings" Usage="System.Xml.XmlWriter.Settings" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlWriterSettings</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取用于创建此 <see cref="T:System.Xml.XmlWriter" /> 实例的 <see cref="T:System.Xml.XmlWriterSettings" /> 对象。</summary>
        <value>用于创建此编写器实例的 <see cref="T:System.Xml.XmlWriterSettings" /> 对象。 如果此编写器不是使用 <see cref="Overload:System.Xml.XmlWriter.Create" /> 方法创建的，则此属性返回 <see langword="null" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Xml.XmlWriterSettings>类用于指定要创建的编写器实例上支持的功能集。 <xref:System.Xml.XmlWriterSettings>返回对象<xref:System.Xml.XmlWriter.Settings%2A>无法修改属性。 任何尝试更改单个设置导致引发异常。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlWriter" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IDisposable.Dispose">
      <MemberSignature Language="C#" Value="void IDisposable.Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.IDisposable.Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlWriter.System#IDisposable#Dispose" />
      <MemberSignature Language="VB.NET" Value="Sub Dispose () Implements IDisposable.Dispose" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.IDisposable.Dispose() = IDisposable::Dispose;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>有关此成员的说明，请参阅 <see cref="M:System.IDisposable.Dispose" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

此成员是显式的接口成员实现。 它只能在 <xref:System.Xml.XmlWriter> 实例强制转换为 <xref:System.IDisposable> 接口时使用。

使用可移植类库项目中时，此成员行为可能有所不同 有关详细信息，请参阅[可移植类库中的 API 差异](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/gg597392(v=vs.100))。

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteAttributes">
      <MemberSignature Language="C#" Value="public virtual void WriteAttributes (System.Xml.XmlReader reader, bool defattr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void WriteAttributes(class System.Xml.XmlReader reader, bool defattr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlWriter.WriteAttributes(System.Xml.XmlReader,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub WriteAttributes (reader As XmlReader, defattr As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void WriteAttributes(System::Xml::XmlReader ^ reader, bool defattr);" />
      <MemberSignature Language="F#" Value="abstract member WriteAttributes : System.Xml.XmlReader * bool -&gt; unit&#xA;override this.WriteAttributes : System.Xml.XmlReader * bool -&gt; unit" Usage="xmlWriter.WriteAttributes (reader, defattr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
        <Parameter Name="defattr" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="reader">从其中复制属性的 <see langword="XmlReader" />。</param>
        <param name="defattr">如果为 <see langword="true" />，则从 <see langword="XmlReader" /> 中复制默认属性；否则为 <see langword="false" />。</param>
        <summary>当在派生类中被重写时，写出在 <see cref="T:System.Xml.XmlReader" /> 中当前位置找到的所有属性。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果读取器定位在`element`节点`WriteAttributes`将复制所有包含的属性。 如果读取器定位在`attribute`节点，此方法将写入当前属性，则属性的其余部分直到元素结束标记。 如果读取器定位在`XmlDeclaration`节点，此方法写入所有属性声明中。 如果读取器定位在任何其他节点类型上此方法将引发<xref:System.Xml.XmlException>。  
  
 如果使用调用此方法<xref:System.Xml.XmlValidatingReader>，以确保格式正确的 XML 编写时，会替换任何内容 （其中已从实体扩展） 都可能会导致无效的文档。 例如，如果属性包含`&gt;`已得到扩展，以确保格式正确的文档已展开的实体 > 时写出与替换`&gt;`。  
  
 此方法的异步版本，请参阅<xref:System.Xml.XmlWriter.WriteAttributesAsync%2A>。  
  
   
  
## Examples  
 下面的示例将所有元素都复制到输出中，标记名更改为大写，并将都复制保持不变的所有属性。  
  
 [!code-cpp[XmlWriter.WriteAttributes#1](~/samples/snippets/cpp/VS_Snippets_Data/XmlWriter.WriteAttributes/CPP/writeattrs_v2.cpp#1)]
 [!code-csharp[XmlWriter.WriteAttributes#1](~/samples/snippets/csharp/VS_Snippets_Data/XmlWriter.WriteAttributes/CS/writeattrs_v2.cs#1)]
 [!code-vb[XmlWriter.WriteAttributes#1](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlWriter.WriteAttributes/VB/writeattrs_v2.vb#1)]  
  
 该示例使用该文件，`test1.xml`作为输入。  
  
 [!code-xml[XmlWriter.WriteAttributes#2](~/samples/snippets/xml/VS_Snippets_Data/XmlWriter.WriteAttributes/XML/test1.xml#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="reader" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.Xml.XmlException">读取器不是定位在 <see langword="element" />、<see langword="attribute" /> 或 <see langword="XmlDeclaration" /> 节点上。</exception>
        <exception cref="T:System.InvalidOperationException">在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlWriter" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteAttributesAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task WriteAttributesAsync (System.Xml.XmlReader reader, bool defattr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task WriteAttributesAsync(class System.Xml.XmlReader reader, bool defattr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlWriter.WriteAttributesAsync(System.Xml.XmlReader,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function WriteAttributesAsync (reader As XmlReader, defattr As Boolean) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task ^ WriteAttributesAsync(System::Xml::XmlReader ^ reader, bool defattr);" />
      <MemberSignature Language="F#" Value="abstract member WriteAttributesAsync : System.Xml.XmlReader * bool -&gt; System.Threading.Tasks.Task&#xA;override this.WriteAttributesAsync : System.Xml.XmlReader * bool -&gt; System.Threading.Tasks.Task" Usage="xmlWriter.WriteAttributesAsync (reader, defattr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-2.2">
          <AttributeName>System.Diagnostics.DebuggerStepThrough</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
        <Parameter Name="defattr" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="reader">从其中复制属性的 <see langword="XmlReader" />。</param>
        <param name="defattr">如果为 <see langword="true" />，则从 <see langword="XmlReader" /> 中复制默认属性；否则为 <see langword="false" />。</param>
        <summary>在 <see cref="T:System.Xml.XmlReader" /> 中的当前位置异步写出找到的所有属性。</summary>
        <returns>表示 <see langword="WriteAttributes" /> 异步操作的任务。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 这是异步版本<xref:System.Xml.XmlWriter.WriteAttributes%2A>，具有相同功能。 若要使用此方法，必须设置<xref:System.Xml.XmlWriterSettings.Async%2A>标记，用于`true`。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">调用了 <see cref="T:System.Xml.XmlWriter" /> 异步方法，但未将 <see cref="P:System.Xml.XmlWriterSettings.Async" /> 标志设置为 <see langword="true" />。 在这种情况下，将引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“如果要使用异步方法，请将 XmlWriterSettings.Async 设置为 true”。</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/db854f91-ccef-4035-ae4d-0911fde808c7">使用 Async 和 Await 的异步编程（C# 和 Visual Basic）</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteAttributeString">
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <exception cref="T:System.InvalidOperationException">在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlWriter" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”</exception>
        <summary>当在派生类中被重写时，写入具有指定值的属性。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法的异步版本，请参阅<xref:System.Xml.XmlWriter.WriteElementStringAsync%2A>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteAttributeString">
      <MemberSignature Language="C#" Value="public void WriteAttributeString (string localName, string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteAttributeString(string localName, string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlWriter.WriteAttributeString(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteAttributeString (localName As String, value As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteAttributeString(System::String ^ localName, System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.WriteAttributeString : string * string -&gt; unit" Usage="xmlWriter.WriteAttributeString (localName, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="localName" Type="System.String" />
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="localName">属性的本地名称。</param>
        <param name="value">属性的值。</param>
        <summary>当在派生类中被重写时，写出具有指定的本地名称和值的属性。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `WriteAttributeString` 执行下列操作：  
  
-   如果属性值包含双引号或单引号，它们将替换`&quot;`和`&apos;`分别。  
  
-   如果编写`xml:space`属性，该编写器验证属性值是否有效。 (有效值`preserve`或`default`。)  
  
-   如果编写`xml:lang`属性，该编写器不会验证属性值是否符合 W3C XML 1.0 建议。  
  
 此方法的异步版本，请参阅<xref:System.Xml.XmlWriter.WriteAttributeStringAsync%2A>。  
  
   
  
## Examples  
 下面的示例写出一本书。  
  
 [!code-cpp[XmlWriter.WriteElementString#1](~/samples/snippets/cpp/VS_Snippets_Data/XmlWriter.WriteElementString/CPP/writeelemstring_v2.cpp#1)]
 [!code-csharp[XmlWriter.WriteElementString#1](~/samples/snippets/csharp/VS_Snippets_Data/XmlWriter.WriteElementString/CS/writeelemstring_v2.cs#1)]
 [!code-vb[XmlWriter.WriteElementString#1](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlWriter.WriteElementString/VB/writeelemstring_v2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlWriter" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”</exception>
        <exception cref="T:System.ArgumentException">
          <see langword="xml:space" /> 或 <see langword="xml:lang" /> 属性值无效。</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteAttributeString">
      <MemberSignature Language="C#" Value="public void WriteAttributeString (string localName, string ns, string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteAttributeString(string localName, string ns, string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlWriter.WriteAttributeString(System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteAttributeString (localName As String, ns As String, value As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteAttributeString(System::String ^ localName, System::String ^ ns, System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.WriteAttributeString : string * string * string -&gt; unit" Usage="xmlWriter.WriteAttributeString (localName, ns, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="localName" Type="System.String" />
        <Parameter Name="ns" Type="System.String" />
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="localName">属性的本地名称。</param>
        <param name="ns">与属性关联的命名空间 URI。</param>
        <param name="value">属性的值。</param>
        <summary>当在派生类中被重写时，写入具有指定的本地名称、命名空间 URI 和值的属性。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法写出具有用户定义的命名空间前缀的属性，并将其与给定的命名空间关联。 如果`localName`为"xmlns"，则此方法还将此视为命名空间声明。 在这种情况下，`ns`参数可以是`null`。  
  
 `WriteAttributeString` 执行下列操作：  
  
-   如果属性值包含双引号或单引号，它们将替换`&quot;`和`&apos;`分别。  
  
-   如果编写`xml:space`属性，该编写器验证属性值是否有效。 (有效值`preserve`或`default`。)  
  
-   如果编写`xml:lang`属性，该编写器不会验证属性值是否符合 W3C XML 1.0 建议。  
  
 此方法的异步版本，请参阅<xref:System.Xml.XmlWriter.WriteAttributeStringAsync%2A>。  
  
   
  
## Examples  
 下面的示例使用<xref:System.Xml.XmlWriter.WriteAttributeString%2A>方法编写命名空间声明。  
  
 [!code-cpp[XmlWriter.WriteAttributeString#1](~/samples/snippets/cpp/VS_Snippets_Data/XmlWriter.WriteAttributeString/CPP/writeattrstring.cpp#1)]
 [!code-csharp[XmlWriter.WriteAttributeString#1](~/samples/snippets/csharp/VS_Snippets_Data/XmlWriter.WriteAttributeString/CS/writeattrstring.cs#1)]
 [!code-vb[XmlWriter.WriteAttributeString#1](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlWriter.WriteAttributeString/VB/writeattrstring.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlWriter" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”</exception>
        <exception cref="T:System.ArgumentException">
          <see langword="xml:space" /> 或 <see langword="xml:lang" /> 属性值无效。</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteAttributeString">
      <MemberSignature Language="C#" Value="public void WriteAttributeString (string prefix, string localName, string ns, string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteAttributeString(string prefix, string localName, string ns, string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlWriter.WriteAttributeString(System.String,System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteAttributeString (prefix As String, localName As String, ns As String, value As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteAttributeString(System::String ^ prefix, System::String ^ localName, System::String ^ ns, System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.WriteAttributeString : string * string * string * string -&gt; unit" Usage="xmlWriter.WriteAttributeString (prefix, localName, ns, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="prefix" Type="System.String" />
        <Parameter Name="localName" Type="System.String" />
        <Parameter Name="ns" Type="System.String" />
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="prefix">属性的命名空间前缀。</param>
        <param name="localName">属性的本地名称。</param>
        <param name="ns">属性的命名空间 URI。</param>
        <param name="value">属性的值。</param>
        <summary>当在派生类中被重写时，写出具有指定的前缀、本地名称、命名空间 URI 和值的属性。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法写出具有用户定义的命名空间前缀的属性，并将其与给定的命名空间关联。 如果前缀为"xmlns"，然后此方法还将此视为命名空间声明，并将声明的前缀与给定的属性值中提供的 URI 的命名空间相关联。 在这种情况下`ns`参数可以是`null`。  
  
 `WriteAttributeString` 执行下列操作：  
  
-   如果属性值包含双引号或单引号，它们将替换`&quot;`和`&apos;`分别。  
  
-   如果编写`xml:space`属性，该编写器验证属性值是否有效。 (有效值`preserve`或`default`。)  
  
-   如果编写`xml:lang`属性，该编写器不会验证属性值是否符合 W3C XML 1.0 建议。  
  
 此方法的异步版本，请参阅<xref:System.Xml.XmlWriter.WriteAttributeStringAsync%2A>。  
  
   
  
## Examples  
 下面的示例使用<xref:System.Xml.XmlWriter.WriteAttributeString%2A>方法编写命名空间声明。  
  
 [!code-cpp[XmlWriter.WriteAttributeString#1](~/samples/snippets/cpp/VS_Snippets_Data/XmlWriter.WriteAttributeString/CPP/writeattrstring.cpp#1)]
 [!code-csharp[XmlWriter.WriteAttributeString#1](~/samples/snippets/csharp/VS_Snippets_Data/XmlWriter.WriteAttributeString/CS/writeattrstring.cs#1)]
 [!code-vb[XmlWriter.WriteAttributeString#1](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlWriter.WriteAttributeString/VB/writeattrstring.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlWriter" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”</exception>
        <exception cref="T:System.ArgumentException">
          <see langword="xml:space" /> 或 <see langword="xml:lang" /> 属性值无效。</exception>
        <exception cref="T:System.Xml.XmlException">
          <paramref name="localName" /> 或 <paramref name="ns" /> 为 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteAttributeStringAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task WriteAttributeStringAsync (string prefix, string localName, string ns, string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task WriteAttributeStringAsync(string prefix, string localName, string ns, string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlWriter.WriteAttributeStringAsync(System.String,System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function WriteAttributeStringAsync (prefix As String, localName As String, ns As String, value As String) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ WriteAttributeStringAsync(System::String ^ prefix, System::String ^ localName, System::String ^ ns, System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.WriteAttributeStringAsync : string * string * string * string -&gt; System.Threading.Tasks.Task" Usage="xmlWriter.WriteAttributeStringAsync (prefix, localName, ns, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="prefix" Type="System.String" />
        <Parameter Name="localName" Type="System.String" />
        <Parameter Name="ns" Type="System.String" />
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="prefix">属性的命名空间前缀。</param>
        <param name="localName">属性的本地名称。</param>
        <param name="ns">属性的命名空间 URI。</param>
        <param name="value">属性的值。</param>
        <summary>异步写出具有指定前缀、本地名称、命名空间 URI 和值的属性。</summary>
        <returns>表示 <see langword="WriteAttributeString" /> 异步操作的任务。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 这是异步版本<xref:System.Xml.XmlWriter.WriteAttributeString%2A>，具有相同功能。 若要使用此方法，必须设置<xref:System.Xml.XmlWriterSettings.Async%2A>标记，用于`true`。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">调用了 <see cref="T:System.Xml.XmlWriter" /> 异步方法，但未将 <see cref="P:System.Xml.XmlWriterSettings.Async" /> 标志设置为 <see langword="true" />。 在这种情况下，将引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“如果要使用异步方法，请将 XmlWriterSettings.Async 设置为 true”。</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/db854f91-ccef-4035-ae4d-0911fde808c7">使用 Async 和 Await 的异步编程（C# 和 Visual Basic）</related>
      </Docs>
    </Member>
    <Member MemberName="WriteBase64">
      <MemberSignature Language="C#" Value="public abstract void WriteBase64 (byte[] buffer, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void WriteBase64(unsigned int8[] buffer, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlWriter.WriteBase64(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Sub WriteBase64 (buffer As Byte(), index As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void WriteBase64(cli::array &lt;System::Byte&gt; ^ buffer, int index, int count);" />
      <MemberSignature Language="F#" Value="abstract member WriteBase64 : byte[] * int * int -&gt; unit" Usage="xmlWriter.WriteBase64 (buffer, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">要进行编码的字节数组。</param>
        <param name="index">缓冲区中指示要写入字节的起始位置的位置。</param>
        <param name="count">要写入的字节数。</param>
        <summary>当在派生类中被重写时，将指定的二进制字节编码为 Base64 并写出结果文本。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 例如，字节缓冲区可能包含 GIF 图像的二进制内容。 这显然不是有效的 XML。 `Base64`编码用于表示任意字节序列中的包含 65 US ASCII 字符的文本形式 ([A-Za-z0 9 + =]) 其中每个字符将编码的二进制数据的 6 位。 有关详细信息，请参阅请求注释 (RFC) 位于 1521年[征求意见文档网站](https://www.rfc-editor.org)。  
  
 此方法的异步版本，请参阅<xref:System.Xml.XmlWriter.WriteBase64Async%2A>。  
  
   
  
## Examples  
 下面的示例使用<xref:System.Xml.XmlWriter.WriteBase64%2A>方法来写入`Base64`数据。 `Base64`内嵌入数据`<image>`元素。  
  
 [!code-csharp[XmlReader_Read_Write_Binary#3](~/samples/snippets/csharp/VS_Snippets_Data/XmlReader_Read_Write_Binary/CS/readBinary.cs#3)]
 [!code-vb[XmlReader_Read_Write_Binary#3](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReader_Read_Write_Binary/VB/readBinary.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> 或 <paramref name="count" /> 小于零。  
  
或 
缓冲区长度减去 <paramref name="index" /> 小于 <paramref name="count" />。</exception>
        <exception cref="T:System.InvalidOperationException">在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlWriter" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteBase64Async">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task WriteBase64Async (byte[] buffer, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task WriteBase64Async(unsigned int8[] buffer, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlWriter.WriteBase64Async(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function WriteBase64Async (buffer As Byte(), index As Integer, count As Integer) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task ^ WriteBase64Async(cli::array &lt;System::Byte&gt; ^ buffer, int index, int count);" />
      <MemberSignature Language="F#" Value="abstract member WriteBase64Async : byte[] * int * int -&gt; System.Threading.Tasks.Task&#xA;override this.WriteBase64Async : byte[] * int * int -&gt; System.Threading.Tasks.Task" Usage="xmlWriter.WriteBase64Async (buffer, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">要进行编码的字节数组。</param>
        <param name="index">缓冲区中指示要写入字节的起始位置的位置。</param>
        <param name="count">要写入的字节数。</param>
        <summary>将指定的二进制字节异步编码为 Base64 并写出结果文本。</summary>
        <returns>表示 <see langword="WriteBase64" /> 异步操作的任务。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 这是异步版本<xref:System.Xml.XmlWriter.WriteBase64%2A>，具有相同功能。 若要使用此方法，必须设置<xref:System.Xml.XmlWriterSettings.Async%2A>标记，用于`true`。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">调用了 <see cref="T:System.Xml.XmlWriter" /> 异步方法，但未将 <see cref="P:System.Xml.XmlWriterSettings.Async" /> 标志设置为 <see langword="true" />。 在这种情况下，将引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“如果要使用异步方法，请将 XmlWriterSettings.Async 设置为 true”。</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/db854f91-ccef-4035-ae4d-0911fde808c7">使用 Async 和 Await 的异步编程（C# 和 Visual Basic）</related>
      </Docs>
    </Member>
    <Member MemberName="WriteBinHex">
      <MemberSignature Language="C#" Value="public virtual void WriteBinHex (byte[] buffer, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void WriteBinHex(unsigned int8[] buffer, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlWriter.WriteBinHex(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub WriteBinHex (buffer As Byte(), index As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void WriteBinHex(cli::array &lt;System::Byte&gt; ^ buffer, int index, int count);" />
      <MemberSignature Language="F#" Value="abstract member WriteBinHex : byte[] * int * int -&gt; unit&#xA;override this.WriteBinHex : byte[] * int * int -&gt; unit" Usage="xmlWriter.WriteBinHex (buffer, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">要进行编码的字节数组。</param>
        <param name="index">缓冲区中指示要写入字节的起始位置的位置。</param>
        <param name="count">要写入的字节数。</param>
        <summary>当在派生类中被重写时，将指定的二进制字节编码为 <see langword="BinHex" /> 并写出结果文本。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法的异步版本，请参阅<xref:System.Xml.XmlWriter.WriteBinHexAsync%2A>。  
  
   
  
## Examples  
 下面的示例使用<xref:System.Xml.XmlWriter.WriteBinHex%2A>方法来写入`BinHex`数据。 `BinHex`内嵌入数据`<image>`元素。  
  
 [!code-csharp[XmlReader_Read_Write_Binary#1](~/samples/snippets/csharp/VS_Snippets_Data/XmlReader_Read_Write_Binary/CS/readBinary.cs#1)]
 [!code-vb[XmlReader_Read_Write_Binary#1](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReader_Read_Write_Binary/VB/readBinary.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlWriter" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> 或 <paramref name="count" /> 小于零。  
  
或 
缓冲区长度减去 <paramref name="index" /> 小于 <paramref name="count" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteBinHexAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task WriteBinHexAsync (byte[] buffer, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task WriteBinHexAsync(unsigned int8[] buffer, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlWriter.WriteBinHexAsync(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function WriteBinHexAsync (buffer As Byte(), index As Integer, count As Integer) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task ^ WriteBinHexAsync(cli::array &lt;System::Byte&gt; ^ buffer, int index, int count);" />
      <MemberSignature Language="F#" Value="abstract member WriteBinHexAsync : byte[] * int * int -&gt; System.Threading.Tasks.Task&#xA;override this.WriteBinHexAsync : byte[] * int * int -&gt; System.Threading.Tasks.Task" Usage="xmlWriter.WriteBinHexAsync (buffer, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">要进行编码的字节数组。</param>
        <param name="index">缓冲区中指示要写入字节的起始位置的位置。</param>
        <param name="count">要写入的字节数。</param>
        <summary>将指定的二进制字节异步编码为 <see langword="BinHex" /> 并写出结果文本。</summary>
        <returns>表示 <see langword="WriteBinHex" /> 异步操作的任务。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 这是异步版本<xref:System.Xml.XmlWriter.WriteBinHex%2A>，具有相同功能。 若要使用此方法，必须设置<xref:System.Xml.XmlWriterSettings.Async%2A>标记，用于`true`。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">调用了 <see cref="T:System.Xml.XmlWriter" /> 异步方法，但未将 <see cref="P:System.Xml.XmlWriterSettings.Async" /> 标志设置为 <see langword="true" />。 在这种情况下，将引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“如果要使用异步方法，请将 XmlWriterSettings.Async 设置为 true”。</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/db854f91-ccef-4035-ae4d-0911fde808c7">使用 Async 和 Await 的异步编程（C# 和 Visual Basic）</related>
      </Docs>
    </Member>
    <Member MemberName="WriteCData">
      <MemberSignature Language="C#" Value="public abstract void WriteCData (string text);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void WriteCData(string text) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlWriter.WriteCData(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Sub WriteCData (text As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void WriteCData(System::String ^ text);" />
      <MemberSignature Language="F#" Value="abstract member WriteCData : string -&gt; unit" Usage="xmlWriter.WriteCData text" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="text" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="text">要放置在 CDATA 块中的文本。</param>
        <summary>当在派生类中被重写时，写出包含指定文本的 &lt;![CDATA[...]]&gt; 块。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果`text`可以是`null`或`String.Empty`，此方法会写入一个空的 CDATA 块，例如\<！ [CDATA]]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">该文本将导致格式不正确的 XML 文档。</exception>
        <exception cref="T:System.InvalidOperationException">在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlWriter" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteCDataAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task WriteCDataAsync (string text);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task WriteCDataAsync(string text) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlWriter.WriteCDataAsync(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function WriteCDataAsync (text As String) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task ^ WriteCDataAsync(System::String ^ text);" />
      <MemberSignature Language="F#" Value="abstract member WriteCDataAsync : string -&gt; System.Threading.Tasks.Task&#xA;override this.WriteCDataAsync : string -&gt; System.Threading.Tasks.Task" Usage="xmlWriter.WriteCDataAsync text" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="text" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="text">要放置在 CDATA 块中的文本。</param>
        <summary>异步写出一个包含指定文本的 &lt;![CDATA[...]]&gt; 块。</summary>
        <returns>表示 <see langword="WriteCData" /> 异步操作的任务。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 这是异步版本<xref:System.Xml.XmlWriter.WriteCData%2A>，具有相同功能。 若要使用此方法，必须设置<xref:System.Xml.XmlWriterSettings.Async%2A>标记，用于`true`。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">调用了 <see cref="T:System.Xml.XmlWriter" /> 异步方法，但未将 <see cref="P:System.Xml.XmlWriterSettings.Async" /> 标志设置为 <see langword="true" />。 在这种情况下，将引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“如果要使用异步方法，请将 XmlWriterSettings.Async 设置为 true”。</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/db854f91-ccef-4035-ae4d-0911fde808c7">使用 Async 和 Await 的异步编程（C# 和 Visual Basic）</related>
      </Docs>
    </Member>
    <Member MemberName="WriteCharEntity">
      <MemberSignature Language="C#" Value="public abstract void WriteCharEntity (char ch);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void WriteCharEntity(char ch) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlWriter.WriteCharEntity(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Sub WriteCharEntity (ch As Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void WriteCharEntity(char ch);" />
      <MemberSignature Language="F#" Value="abstract member WriteCharEntity : char -&gt; unit" Usage="xmlWriter.WriteCharEntity ch" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ch" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="ch">为其生成字符实体的 Unicode 字符。</param>
        <summary>当在派生类中被重写时，为指定的 Unicode 字符值强制生成字符实体。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法中的十六进制字符实体引用格式写入 Unicode 字符。  
  
 此方法的异步版本，请参阅<xref:System.Xml.XmlWriter.WriteCharEntityAsync%2A>。  
  
   
  
## Examples  
 请参阅<xref:System.Xml.XmlTextWriter.WriteCharEntity%2A?displayProperty=nameWithType>有关使用此方法的示例。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">该字符在代理项对字符范围 <see langword="0xd800" /> - <see langword="0xdfff" /> 内。</exception>
        <exception cref="T:System.InvalidOperationException">在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlWriter" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteCharEntityAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task WriteCharEntityAsync (char ch);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task WriteCharEntityAsync(char ch) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlWriter.WriteCharEntityAsync(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function WriteCharEntityAsync (ch As Char) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task ^ WriteCharEntityAsync(char ch);" />
      <MemberSignature Language="F#" Value="abstract member WriteCharEntityAsync : char -&gt; System.Threading.Tasks.Task&#xA;override this.WriteCharEntityAsync : char -&gt; System.Threading.Tasks.Task" Usage="xmlWriter.WriteCharEntityAsync ch" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ch" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="ch">为其生成字符实体的 Unicode 字符。</param>
        <summary>为指定的 Unicode 字符值异步强制生成字符实体。</summary>
        <returns>表示 <see langword="WriteCharEntity" /> 异步操作的任务。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 这是异步版本<xref:System.Xml.XmlWriter.WriteCharEntity%2A>，具有相同功能。 若要使用此方法，必须设置<xref:System.Xml.XmlWriterSettings.Async%2A>标记，用于`true`。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">调用了 <see cref="T:System.Xml.XmlWriter" /> 异步方法，但未将 <see cref="P:System.Xml.XmlWriterSettings.Async" /> 标志设置为 <see langword="true" />。 在这种情况下，将引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“如果要使用异步方法，请将 XmlWriterSettings.Async 设置为 true”。</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/db854f91-ccef-4035-ae4d-0911fde808c7">使用 Async 和 Await 的异步编程（C# 和 Visual Basic）</related>
      </Docs>
    </Member>
    <Member MemberName="WriteChars">
      <MemberSignature Language="C#" Value="public abstract void WriteChars (char[] buffer, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void WriteChars(char[] buffer, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlWriter.WriteChars(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Sub WriteChars (buffer As Char(), index As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void WriteChars(cli::array &lt;char&gt; ^ buffer, int index, int count);" />
      <MemberSignature Language="F#" Value="abstract member WriteChars : char[] * int * int -&gt; unit" Usage="xmlWriter.WriteChars (buffer, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Char[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">包含要写入的文本的字符数组。</param>
        <param name="index">缓冲区中指示要写入文本的起始位置的位置。</param>
        <param name="count">要写入的字符数。</param>
        <summary>当在派生类中被重写时，以每次一个缓冲区的方式写入文本。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法可用于一次写入大量的文本一个缓冲区。  
  
 必须进行特殊处理以确保`WriteChars`方法不会跨多个缓冲区写入不拆分代理项对字符。 XML 规范定义的有效范围为代理项对。  
  
 此方法的异步版本，请参阅<xref:System.Xml.XmlWriter.WriteCharsAsync%2A>。  
  
   
  
## Examples  
 [!code-csharp[XmlWriter.WriteChars#1](~/samples/snippets/csharp/VS_Snippets_Data/xmlwriter.writechars/cs/xmlwriterwritecharsexample.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> 或 <paramref name="count" /> 小于零。  
  
或 
缓冲区长度减去 <paramref name="index" /> 小于 <paramref name="count" />；此调用导致代理项对字符被拆分或写入无效的代理项对。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="buffer" /> 参数值无效。</exception>
        <exception cref="T:System.InvalidOperationException">在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlWriter" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteCharsAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task WriteCharsAsync (char[] buffer, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task WriteCharsAsync(char[] buffer, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlWriter.WriteCharsAsync(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function WriteCharsAsync (buffer As Char(), index As Integer, count As Integer) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task ^ WriteCharsAsync(cli::array &lt;char&gt; ^ buffer, int index, int count);" />
      <MemberSignature Language="F#" Value="abstract member WriteCharsAsync : char[] * int * int -&gt; System.Threading.Tasks.Task&#xA;override this.WriteCharsAsync : char[] * int * int -&gt; System.Threading.Tasks.Task" Usage="xmlWriter.WriteCharsAsync (buffer, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Char[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">包含要写入的文本的字符数组。</param>
        <param name="index">缓冲区中指示要写入文本的起始位置的位置。</param>
        <param name="count">要写入的字符数。</param>
        <summary>以每次一个缓冲区的方式异步写入文本。</summary>
        <returns>表示 <see langword="WriteChars" /> 异步操作的任务。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 这是异步版本<xref:System.Xml.XmlWriter.WriteChars%2A>，具有相同功能。 若要使用此方法，必须设置<xref:System.Xml.XmlWriterSettings.Async%2A>标记，用于`true`。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">调用了 <see cref="T:System.Xml.XmlWriter" /> 异步方法，但未将 <see cref="P:System.Xml.XmlWriterSettings.Async" /> 标志设置为 <see langword="true" />。 在这种情况下，将引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“如果要使用异步方法，请将 XmlWriterSettings.Async 设置为 true”。</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/db854f91-ccef-4035-ae4d-0911fde808c7">使用 Async 和 Await 的异步编程（C# 和 Visual Basic）</related>
      </Docs>
    </Member>
    <Member MemberName="WriteComment">
      <MemberSignature Language="C#" Value="public abstract void WriteComment (string text);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void WriteComment(string text) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlWriter.WriteComment(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Sub WriteComment (text As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void WriteComment(System::String ^ text);" />
      <MemberSignature Language="F#" Value="abstract member WriteComment : string -&gt; unit" Usage="xmlWriter.WriteComment text" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="text" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="text">要放在注释内的文本。</param>
        <summary>当在派生类中被重写时，写出包含指定文本的注释 &lt;!--...--&gt;。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果`text`可以是`null`或`String.Empty`，此方法写入的注释没有数据内容，例如\<！--->。  
  
 如果`text`包含无效的序列的两个短划线"-"<xref:System.Xml.XmlWriter>会引发<xref:System.ArgumentException>(<xref:System.Xml.XmlTextWriter>对象) 或短划线之间插入空格"-"，以便文本是一个有效的 XML 注释 (<xref:System.Xml.XmlWriter>所创建的对象<xref:System.Xml.XmlWriter.Create%2A>方法)。  
  
 此方法的异步版本，请参阅<xref:System.Xml.XmlWriter.WriteCommentAsync%2A>。  
  
   
  
## Examples  
 以下示例将编写一个表示一书的 XML 文件。  
  
 [!code-csharp[XmlWriter.WriteStartDocument#1](~/samples/snippets/csharp/VS_Snippets_Data/XmlWriter.WriteStartDocument/CS/writerbook_v2.cs#1)]
 [!code-vb[XmlWriter.WriteStartDocument#1](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlWriter.WriteStartDocument/VB/writerbook_v2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">该文本将导致格式不正确的 XML 文档。</exception>
        <exception cref="T:System.InvalidOperationException">在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlWriter" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteCommentAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task WriteCommentAsync (string text);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task WriteCommentAsync(string text) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlWriter.WriteCommentAsync(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function WriteCommentAsync (text As String) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task ^ WriteCommentAsync(System::String ^ text);" />
      <MemberSignature Language="F#" Value="abstract member WriteCommentAsync : string -&gt; System.Threading.Tasks.Task&#xA;override this.WriteCommentAsync : string -&gt; System.Threading.Tasks.Task" Usage="xmlWriter.WriteCommentAsync text" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="text" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="text">要放在注释内的文本。</param>
        <summary>异步写出一个包含指定文本的注释 &lt;!--...--&gt;。</summary>
        <returns>表示 <see langword="WriteComment" /> 异步操作的任务。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 这是异步版本<xref:System.Xml.XmlWriter.WriteComment%2A>，具有相同功能。 若要使用此方法，必须设置<xref:System.Xml.XmlWriterSettings.Async%2A>标记，用于`true`。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">调用了 <see cref="T:System.Xml.XmlWriter" /> 异步方法，但未将 <see cref="P:System.Xml.XmlWriterSettings.Async" /> 标志设置为 <see langword="true" />。 在这种情况下，将引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“如果要使用异步方法，请将 XmlWriterSettings.Async 设置为 true”。</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/db854f91-ccef-4035-ae4d-0911fde808c7">使用 Async 和 Await 的异步编程（C# 和 Visual Basic）</related>
      </Docs>
    </Member>
    <Member MemberName="WriteDocType">
      <MemberSignature Language="C#" Value="public abstract void WriteDocType (string name, string pubid, string sysid, string subset);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void WriteDocType(string name, string pubid, string sysid, string subset) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlWriter.WriteDocType(System.String,System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Sub WriteDocType (name As String, pubid As String, sysid As String, subset As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void WriteDocType(System::String ^ name, System::String ^ pubid, System::String ^ sysid, System::String ^ subset);" />
      <MemberSignature Language="F#" Value="abstract member WriteDocType : string * string * string * string -&gt; unit" Usage="xmlWriter.WriteDocType (name, pubid, sysid, subset)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="pubid" Type="System.String" />
        <Parameter Name="sysid" Type="System.String" />
        <Parameter Name="subset" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">DOCTYPE 的名称。 它必须是非空的。</param>
        <param name="pubid">如果非 null，则它还编写 PUBLIC "pubid" "sysid"，这里的 <paramref name="pubid" /> 和 <paramref name="sysid" /> 用给定参数的值替换。</param>
        <param name="sysid">如果 <paramref name="pubid" /> 为 <see langword="null" /> 而 <paramref name="sysid" /> 非 null，则它编写 SYSTEM "sysid"，这里的 <paramref name="sysid" /> 用此参数的值替换。</param>
        <param name="subset">如果非 null，则它写入 [subset]，其中 subset 替换为此自变量的值。</param>
        <summary>当在派生类中被重写时，写出具有指定名称和可选属性的 DOCTYPE 声明。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法不会检查中的无效字符`pubid`，`sysid`或`subset`。 它也不会检查内部子集的格式正确。  
  
> [!IMPORTANT]
>  <xref:System.Xml.XmlWriter>不会验证传递给数据<xref:System.Xml.XmlWriter.WriteDocType%2A>方法。 不应将任意数据传递给此方法。  
  
 此方法的异步版本，请参阅<xref:System.Xml.XmlWriter.WriteDocTypeAsync%2A>。  
  
   
  
## Examples  
 以下示例将编写一个表示一书的 XML 文件。  
  
 [!code-csharp[XmlWriter.WriteStartDocument#1](~/samples/snippets/csharp/VS_Snippets_Data/XmlWriter.WriteStartDocument/CS/writerbook_v2.cs#1)]
 [!code-vb[XmlWriter.WriteStartDocument#1](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlWriter.WriteStartDocument/VB/writerbook_v2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlWriter" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> 的值将导致无效的 XML。</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteDocTypeAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task WriteDocTypeAsync (string name, string pubid, string sysid, string subset);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task WriteDocTypeAsync(string name, string pubid, string sysid, string subset) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlWriter.WriteDocTypeAsync(System.String,System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function WriteDocTypeAsync (name As String, pubid As String, sysid As String, subset As String) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task ^ WriteDocTypeAsync(System::String ^ name, System::String ^ pubid, System::String ^ sysid, System::String ^ subset);" />
      <MemberSignature Language="F#" Value="abstract member WriteDocTypeAsync : string * string * string * string -&gt; System.Threading.Tasks.Task&#xA;override this.WriteDocTypeAsync : string * string * string * string -&gt; System.Threading.Tasks.Task" Usage="xmlWriter.WriteDocTypeAsync (name, pubid, sysid, subset)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="pubid" Type="System.String" />
        <Parameter Name="sysid" Type="System.String" />
        <Parameter Name="subset" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">DOCTYPE 的名称。 它必须是非空的。</param>
        <param name="pubid">如果非 null，则它还编写 PUBLIC "pubid" "sysid"，这里的 <paramref name="pubid" /> 和 <paramref name="sysid" /> 用给定参数的值替换。</param>
        <param name="sysid">如果 <paramref name="pubid" /> 为 <see langword="null" /> 而 <paramref name="sysid" /> 非 null，则它编写 SYSTEM "sysid"，这里的 <paramref name="sysid" /> 用此参数的值替换。</param>
        <param name="subset">如果非 null，则它写入 [subset]，其中 subset 替换为此自变量的值。</param>
        <summary>异步写入具有指定名称和可选属性的 DOCTYPE 声明。</summary>
        <returns>表示 <see langword="WriteDocType" /> 异步操作的任务。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 这是异步版本<xref:System.Xml.XmlWriter.WriteDocType%2A>，具有相同功能。 若要使用此方法，必须设置<xref:System.Xml.XmlWriterSettings.Async%2A>标记，用于`true`。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">调用了 <see cref="T:System.Xml.XmlWriter" /> 异步方法，但未将 <see cref="P:System.Xml.XmlWriterSettings.Async" /> 标志设置为 <see langword="true" />。 在这种情况下，将引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“如果要使用异步方法，请将 XmlWriterSettings.Async 设置为 true”。</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/db854f91-ccef-4035-ae4d-0911fde808c7">使用 Async 和 Await 的异步编程（C# 和 Visual Basic）</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteElementString">
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <exception cref="T:System.InvalidOperationException">在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlWriter" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”</exception>
        <summary>写入包含字符串值的元素。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法的异步版本，请参阅<xref:System.Xml.XmlWriter.WriteElementStringAsync%2A>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteElementString">
      <MemberSignature Language="C#" Value="public void WriteElementString (string localName, string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteElementString(string localName, string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlWriter.WriteElementString(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteElementString (localName As String, value As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteElementString(System::String ^ localName, System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.WriteElementString : string * string -&gt; unit" Usage="xmlWriter.WriteElementString (localName, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="localName" Type="System.String" />
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="localName">元素的本地名称。</param>
        <param name="value">元素的值。</param>
        <summary>写入具有指定的本地名称和值的元素。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法的异步版本，请参阅<xref:System.Xml.XmlWriter.WriteElementStringAsync%2A>。  
  
   
  
## Examples  
 以下示例使用多个写入方法来创建 XML 片段。  
  
 [!code-cpp[XmlWriter.WriteElementString#1](~/samples/snippets/cpp/VS_Snippets_Data/XmlWriter.WriteElementString/CPP/writeelemstring_v2.cpp#1)]
 [!code-csharp[XmlWriter.WriteElementString#1](~/samples/snippets/csharp/VS_Snippets_Data/XmlWriter.WriteElementString/CS/writeelemstring_v2.cs#1)]
 [!code-vb[XmlWriter.WriteElementString#1](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlWriter.WriteElementString/VB/writeelemstring_v2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="localName" /> 值是 <see langword="null" /> 或空字符串。  
  
或 
参数值无效。</exception>
        <exception cref="T:System.Text.EncoderFallbackException">缓冲区中有一个字符是有效的 XML 字符，但对于输出编码是无效的。 例如，如果输出编码为 ASCII，应该仅对元素和特性名使用从 0 到 127 范围内的字符。 无效的字符可能位于此方法的参数中，或者位于以前要写入缓冲区的方法的参数中。 如果可能，此类字符将使用字符实体引用进行转义（例如，在文本节点或特性值中）。 但是，不允许在元素名、特性名、注释、处理指令和 CDATA 节中使用字符实体引用。</exception>
        <exception cref="T:System.InvalidOperationException">在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlWriter" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteElementString">
      <MemberSignature Language="C#" Value="public void WriteElementString (string localName, string ns, string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteElementString(string localName, string ns, string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlWriter.WriteElementString(System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteElementString (localName As String, ns As String, value As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteElementString(System::String ^ localName, System::String ^ ns, System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.WriteElementString : string * string * string -&gt; unit" Usage="xmlWriter.WriteElementString (localName, ns, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="localName" Type="System.String" />
        <Parameter Name="ns" Type="System.String" />
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="localName">元素的本地名称。</param>
        <param name="ns">与元素关联的命名空间 URI。</param>
        <param name="value">元素的值。</param>
        <summary>写入具有指定的本地名称、命名空间 URI 和值的元素。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法的异步版本，请参阅<xref:System.Xml.XmlWriter.WriteElementStringAsync%2A>。  
  
   
  
## Examples  
 以下示例使用多个写入方法来创建 XML 片段。  
  
 [!code-cpp[XmlWriter.WriteElementString#1](~/samples/snippets/cpp/VS_Snippets_Data/XmlWriter.WriteElementString/CPP/writeelemstring_v2.cpp#1)]
 [!code-csharp[XmlWriter.WriteElementString#1](~/samples/snippets/csharp/VS_Snippets_Data/XmlWriter.WriteElementString/CS/writeelemstring_v2.cs#1)]
 [!code-vb[XmlWriter.WriteElementString#1](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlWriter.WriteElementString/VB/writeelemstring_v2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="localName" /> 值是 <see langword="null" /> 或空字符串。  
  
或 
参数值无效。</exception>
        <exception cref="T:System.Text.EncoderFallbackException">缓冲区中有一个字符是有效的 XML 字符，但对于输出编码是无效的。 例如，如果输出编码为 ASCII，应该仅对元素和特性名使用从 0 到 127 范围内的字符。 无效的字符可能位于此方法的参数中，或者位于以前要写入缓冲区的方法的参数中。 如果可能，此类字符将使用字符实体引用进行转义（例如，在文本节点或特性值中）。 但是，不允许在元素名、特性名、注释、处理指令和 CDATA 节中使用字符实体引用。</exception>
        <exception cref="T:System.InvalidOperationException">在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlWriter" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteElementString">
      <MemberSignature Language="C#" Value="public void WriteElementString (string prefix, string localName, string ns, string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteElementString(string prefix, string localName, string ns, string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlWriter.WriteElementString(System.String,System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteElementString (prefix As String, localName As String, ns As String, value As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteElementString(System::String ^ prefix, System::String ^ localName, System::String ^ ns, System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.WriteElementString : string * string * string * string -&gt; unit" Usage="xmlWriter.WriteElementString (prefix, localName, ns, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="prefix" Type="System.String" />
        <Parameter Name="localName" Type="System.String" />
        <Parameter Name="ns" Type="System.String" />
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="prefix">元素的前缀。</param>
        <param name="localName">元素的本地名称。</param>
        <param name="ns">元素的命名空间 URI。</param>
        <param name="value">元素的值。</param>
        <summary>写入具有指定的前缀、本地名称、命名空间 URI 和值的元素。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法的异步版本，请参阅<xref:System.Xml.XmlWriter.WriteElementStringAsync%2A>。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="localName" /> 值是 <see langword="null" /> 或空字符串。  
  
或 
参数值无效。</exception>
        <exception cref="T:System.Text.EncoderFallbackException">缓冲区中有一个字符是有效的 XML 字符，但对于输出编码是无效的。 例如，如果输出编码为 ASCII，应该仅对元素和特性名使用从 0 到 127 范围内的字符。 无效的字符可能位于此方法的参数中，或者位于以前要写入缓冲区的方法的参数中。 如果可能，此类字符将使用字符实体引用进行转义（例如，在文本节点或特性值中）。 但是，不允许在元素名、特性名、注释、处理指令和 CDATA 节中使用字符实体引用。</exception>
        <exception cref="T:System.InvalidOperationException">在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlWriter" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteElementStringAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task WriteElementStringAsync (string prefix, string localName, string ns, string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task WriteElementStringAsync(string prefix, string localName, string ns, string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlWriter.WriteElementStringAsync(System.String,System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function WriteElementStringAsync (prefix As String, localName As String, ns As String, value As String) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ WriteElementStringAsync(System::String ^ prefix, System::String ^ localName, System::String ^ ns, System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.WriteElementStringAsync : string * string * string * string -&gt; System.Threading.Tasks.Task" Usage="xmlWriter.WriteElementStringAsync (prefix, localName, ns, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-2.2">
          <AttributeName>System.Diagnostics.DebuggerStepThrough</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="prefix" Type="System.String" />
        <Parameter Name="localName" Type="System.String" />
        <Parameter Name="ns" Type="System.String" />
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="prefix">元素的前缀。</param>
        <param name="localName">元素的本地名称。</param>
        <param name="ns">元素的命名空间 URI。</param>
        <param name="value">元素的值。</param>
        <summary>异步写入具有指定的前缀、本地名称、命名空间 URI 和值的元素。</summary>
        <returns>表示 <see langword="WriteElementString" /> 异步操作的任务。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 这是异步版本<xref:System.Xml.XmlWriter.WriteElementString%2A>，具有相同功能。 若要使用此方法，必须设置<xref:System.Xml.XmlWriterSettings.Async%2A>标记，用于`true`。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">调用了 <see cref="T:System.Xml.XmlWriter" /> 异步方法，但未将 <see cref="P:System.Xml.XmlWriterSettings.Async" /> 标志设置为 <see langword="true" />。 在这种情况下，将引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“如果要使用异步方法，请将 XmlWriterSettings.Async 设置为 true”。</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/db854f91-ccef-4035-ae4d-0911fde808c7">使用 Async 和 Await 的异步编程（C# 和 Visual Basic）</related>
      </Docs>
    </Member>
    <Member MemberName="WriteEndAttribute">
      <MemberSignature Language="C#" Value="public abstract void WriteEndAttribute ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void WriteEndAttribute() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlWriter.WriteEndAttribute" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Sub WriteEndAttribute ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void WriteEndAttribute();" />
      <MemberSignature Language="F#" Value="abstract member WriteEndAttribute : unit -&gt; unit" Usage="xmlWriter.WriteEndAttribute " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>当在派生类中被重写时，关闭上一个 <see cref="M:System.Xml.XmlWriter.WriteStartAttribute(System.String,System.String)" /> 调用。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果调用`WriteStartAttribute`，可以使用此方法关闭该属性。  
  
 此外可以通过调用来关闭该属性`WriteStartAttribute`同样，调用<xref:System.Xml.XmlWriter.WriteAttributeString%2A>，或调用<xref:System.Xml.XmlWriter.WriteEndElement%2A>。  
  
> [!NOTE]
>  当你使用<xref:System.Xml.XmlWriter>将不写入输出 XML 中，元素和属性的方法，直到你调用<xref:System.Xml.XmlWriter.Close%2A>方法。 例如，如果您使用 XmlWriter 填充<xref:System.Xml.XmlDocument>，直到关闭<xref:System.Xml.XmlWriter>，您将无法再看到写入的元素和目标文档中的特性。  
  
 此方法的异步版本，请参阅<xref:System.Xml.XmlWriter.WriteEndAttributeAsync%2A>。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlWriter" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteEndAttributeAsync">
      <MemberSignature Language="C#" Value="protected internal virtual System.Threading.Tasks.Task WriteEndAttributeAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance class System.Threading.Tasks.Task WriteEndAttributeAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlWriter.WriteEndAttributeAsync" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Function WriteEndAttributeAsync () As Task" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual System::Threading::Tasks::Task ^ WriteEndAttributeAsync();" />
      <MemberSignature Language="F#" Value="abstract member WriteEndAttributeAsync : unit -&gt; System.Threading.Tasks.Task&#xA;override this.WriteEndAttributeAsync : unit -&gt; System.Threading.Tasks.Task" Usage="xmlWriter.WriteEndAttributeAsync " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>异步关闭前一个 <see cref="M:System.Xml.XmlWriter.WriteStartAttribute(System.String,System.String)" /> 调用。</summary>
        <returns>表示 <see langword="WriteEndAttribute" /> 异步操作的任务。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 这是异步版本<xref:System.Xml.XmlWriter.WriteEndAttribute%2A>，具有相同功能。 若要使用此方法，必须设置<xref:System.Xml.XmlWriterSettings.Async%2A>标记，用于`true`。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">调用了 <see cref="T:System.Xml.XmlWriter" /> 异步方法，但未将 <see cref="P:System.Xml.XmlWriterSettings.Async" /> 标志设置为 <see langword="true" />。 在这种情况下，将引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“如果要使用异步方法，请将 XmlWriterSettings.Async 设置为 true”。</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/db854f91-ccef-4035-ae4d-0911fde808c7">使用 Async 和 Await 的异步编程（C# 和 Visual Basic）</related>
      </Docs>
    </Member>
    <Member MemberName="WriteEndDocument">
      <MemberSignature Language="C#" Value="public abstract void WriteEndDocument ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void WriteEndDocument() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlWriter.WriteEndDocument" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Sub WriteEndDocument ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void WriteEndDocument();" />
      <MemberSignature Language="F#" Value="abstract member WriteEndDocument : unit -&gt; unit" Usage="xmlWriter.WriteEndDocument " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>当在派生类中被重写时，关闭任何打开的元素或属性并将写入器重新设置为起始状态。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  当你使用<xref:System.Xml.XmlWriter>将不写入输出 XML 中，元素和属性的方法，直到你调用<xref:System.Xml.XmlWriter.Close%2A>方法。 例如，如果您使用 XmlWriter 填充<xref:System.Xml.XmlDocument>，直到关闭<xref:System.Xml.XmlWriter>，您将无法再看到写入的元素和目标文档中的特性。  
  
 此方法的异步版本，请参阅<xref:System.Xml.XmlWriter.WriteEndDocumentAsync%2A>。  
  
   
  
## Examples  
 以下示例将编写一个表示一书的 XML 文件。  
  
 [!code-csharp[XmlWriter.WriteStartDocument#1](~/samples/snippets/csharp/VS_Snippets_Data/XmlWriter.WriteStartDocument/CS/writerbook_v2.cs#1)]
 [!code-vb[XmlWriter.WriteStartDocument#1](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlWriter.WriteStartDocument/VB/writerbook_v2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">XML 文档无效。</exception>
        <exception cref="T:System.InvalidOperationException">在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlWriter" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteEndDocumentAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task WriteEndDocumentAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task WriteEndDocumentAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlWriter.WriteEndDocumentAsync" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function WriteEndDocumentAsync () As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task ^ WriteEndDocumentAsync();" />
      <MemberSignature Language="F#" Value="abstract member WriteEndDocumentAsync : unit -&gt; System.Threading.Tasks.Task&#xA;override this.WriteEndDocumentAsync : unit -&gt; System.Threading.Tasks.Task" Usage="xmlWriter.WriteEndDocumentAsync " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>异步关闭任何打开的元素或属性并将写入器重新设置为起始状态。</summary>
        <returns>表示 <see langword="WriteEndDocument" /> 异步操作的任务。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 这是异步版本<xref:System.Xml.XmlWriter.WriteEndDocument%2A>，具有相同功能。 若要使用此方法，必须设置<xref:System.Xml.XmlWriterSettings.Async%2A>标记，用于`true`。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">调用了 <see cref="T:System.Xml.XmlWriter" /> 异步方法，但未将 <see cref="P:System.Xml.XmlWriterSettings.Async" /> 标志设置为 <see langword="true" />。 在这种情况下，将引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“如果要使用异步方法，请将 XmlWriterSettings.Async 设置为 true”。</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/db854f91-ccef-4035-ae4d-0911fde808c7">使用 Async 和 Await 的异步编程（C# 和 Visual Basic）</related>
      </Docs>
    </Member>
    <Member MemberName="WriteEndElement">
      <MemberSignature Language="C#" Value="public abstract void WriteEndElement ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void WriteEndElement() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlWriter.WriteEndElement" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Sub WriteEndElement ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void WriteEndElement();" />
      <MemberSignature Language="F#" Value="abstract member WriteEndElement : unit -&gt; unit" Usage="xmlWriter.WriteEndElement " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>当在派生类中被重写时，关闭一个元素并弹出相应的命名空间范围。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果元素不包含任何内容，短结束标记"/ >"编写;否则，编写完整的结束标记。  
  
> [!NOTE]
>  当你使用<xref:System.Xml.XmlWriter>将不写入输出 XML 中，元素和属性的方法，直到你调用<xref:System.Xml.XmlWriter.Close%2A>方法。 例如，如果 XmlWwriter 您用来填充<xref:System.Xml.XmlDocument>，直到关闭<xref:System.Xml.XmlWriter>，您将无法再看到写入的元素和目标文档中的特性。  
  
 此方法的异步版本，请参阅<xref:System.Xml.XmlWriter.WriteEndElementAsync%2A>。  
  
   
  
## Examples  
 下面的示例使用<xref:System.Xml.XmlWriter.WriteEndElement%2A>和<xref:System.Xml.XmlWriter.WriteFullEndElement%2A>方法。  
  
 [!code-csharp[XmlWriter.WriteFullEndElement#1](~/samples/snippets/csharp/VS_Snippets_Data/XmlWriter.WriteFullEndElement/CS/writerfullend_v2.cs#1)]
 [!code-vb[XmlWriter.WriteFullEndElement#1](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlWriter.WriteFullEndElement/VB/writerfullend_v2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlWriter" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteEndElementAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task WriteEndElementAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task WriteEndElementAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlWriter.WriteEndElementAsync" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function WriteEndElementAsync () As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task ^ WriteEndElementAsync();" />
      <MemberSignature Language="F#" Value="abstract member WriteEndElementAsync : unit -&gt; System.Threading.Tasks.Task&#xA;override this.WriteEndElementAsync : unit -&gt; System.Threading.Tasks.Task" Usage="xmlWriter.WriteEndElementAsync " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>异步关闭一个元素并弹出相应的命名空间范围。</summary>
        <returns>表示 <see langword="WriteEndElement" /> 异步操作的任务。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 这是异步版本<xref:System.Xml.XmlWriter.WriteEndElement%2A>，具有相同功能。 若要使用此方法，必须设置<xref:System.Xml.XmlWriterSettings.Async%2A>标记，用于`true`。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">调用了 <see cref="T:System.Xml.XmlWriter" /> 异步方法，但未将 <see cref="P:System.Xml.XmlWriterSettings.Async" /> 标志设置为 <see langword="true" />。 在这种情况下，将引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“如果要使用异步方法，请将 XmlWriterSettings.Async 设置为 true”。</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/db854f91-ccef-4035-ae4d-0911fde808c7">使用 Async 和 Await 的异步编程（C# 和 Visual Basic）</related>
      </Docs>
    </Member>
    <Member MemberName="WriteEntityRef">
      <MemberSignature Language="C#" Value="public abstract void WriteEntityRef (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void WriteEntityRef(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlWriter.WriteEntityRef(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Sub WriteEntityRef (name As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void WriteEntityRef(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member WriteEntityRef : string -&gt; unit" Usage="xmlWriter.WriteEntityRef name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">实体引用的名称。</param>
        <summary>当在派生类中被重写时，按 <see langword="&amp;name;" /> 写出实体引用。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法的异步版本，请参阅<xref:System.Xml.XmlWriter.WriteEntityRefAsync%2A>。  
  
   
  
## Examples  
 以下示例将编写一个表示一书的 XML 文件。  
  
 [!code-csharp[XmlWriter.WriteStartDocument#1](~/samples/snippets/csharp/VS_Snippets_Data/XmlWriter.WriteStartDocument/CS/writerbook_v2.cs#1)]
 [!code-vb[XmlWriter.WriteStartDocument#1](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlWriter.WriteStartDocument/VB/writerbook_v2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> 为 <see langword="null" /> 或 <see langword="String.Empty" />。</exception>
        <exception cref="T:System.InvalidOperationException">在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlWriter" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteEntityRefAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task WriteEntityRefAsync (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task WriteEntityRefAsync(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlWriter.WriteEntityRefAsync(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function WriteEntityRefAsync (name As String) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task ^ WriteEntityRefAsync(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member WriteEntityRefAsync : string -&gt; System.Threading.Tasks.Task&#xA;override this.WriteEntityRefAsync : string -&gt; System.Threading.Tasks.Task" Usage="xmlWriter.WriteEntityRefAsync name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">实体引用的名称。</param>
        <summary>按 <see langword="&amp;name;" /> 异步写出实体引用。</summary>
        <returns>表示 <see langword="WriteEntityRef" /> 异步操作的任务。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 这是异步版本<xref:System.Xml.XmlWriter.WriteEntityRef%2A>，具有相同功能。 若要使用此方法，必须设置<xref:System.Xml.XmlWriterSettings.Async%2A>标记，用于`true`。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">调用了 <see cref="T:System.Xml.XmlWriter" /> 异步方法，但未将 <see cref="P:System.Xml.XmlWriterSettings.Async" /> 标志设置为 <see langword="true" />。 在这种情况下，将引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“如果要使用异步方法，请将 XmlWriterSettings.Async 设置为 true”。</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/db854f91-ccef-4035-ae4d-0911fde808c7">使用 Async 和 Await 的异步编程（C# 和 Visual Basic）</related>
      </Docs>
    </Member>
    <Member MemberName="WriteFullEndElement">
      <MemberSignature Language="C#" Value="public abstract void WriteFullEndElement ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void WriteFullEndElement() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlWriter.WriteFullEndElement" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Sub WriteFullEndElement ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void WriteFullEndElement();" />
      <MemberSignature Language="F#" Value="abstract member WriteFullEndElement : unit -&gt; unit" Usage="xmlWriter.WriteFullEndElement " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>当在派生类中被重写时，关闭一个元素并弹出相应的命名空间范围。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法始终写入完整的结束标记。 处理元素必须包括完整的结束标记时，这很有用。 例如，浏览器要求 HTML 脚本块与要关闭" \< /脚本 >"。  
  
 此方法的异步版本，请参阅<xref:System.Xml.XmlWriter.WriteFullEndElementAsync%2A>。  
  
   
  
## Examples  
 下面的示例使用<xref:System.Xml.XmlWriter.WriteEndElement%2A>和<xref:System.Xml.XmlWriter.WriteFullEndElement%2A>方法。  
  
 [!code-csharp[XmlWriter.WriteFullEndElement#1](~/samples/snippets/csharp/VS_Snippets_Data/XmlWriter.WriteFullEndElement/CS/writerfullend_v2.cs#1)]
 [!code-vb[XmlWriter.WriteFullEndElement#1](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlWriter.WriteFullEndElement/VB/writerfullend_v2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlWriter" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteFullEndElementAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task WriteFullEndElementAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task WriteFullEndElementAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlWriter.WriteFullEndElementAsync" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function WriteFullEndElementAsync () As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task ^ WriteFullEndElementAsync();" />
      <MemberSignature Language="F#" Value="abstract member WriteFullEndElementAsync : unit -&gt; System.Threading.Tasks.Task&#xA;override this.WriteFullEndElementAsync : unit -&gt; System.Threading.Tasks.Task" Usage="xmlWriter.WriteFullEndElementAsync " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>异步关闭一个元素并弹出相应的命名空间范围。</summary>
        <returns>表示 <see langword="WriteFullEndElement" /> 异步操作的任务。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 这是异步版本<xref:System.Xml.XmlWriter.WriteFullEndElement%2A>，具有相同功能。 若要使用此方法，必须设置<xref:System.Xml.XmlWriterSettings.Async%2A>标记，用于`true`。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">调用了 <see cref="T:System.Xml.XmlWriter" /> 异步方法，但未将 <see cref="P:System.Xml.XmlWriterSettings.Async" /> 标志设置为 <see langword="true" />。 在这种情况下，将引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“如果要使用异步方法，请将 XmlWriterSettings.Async 设置为 true”。</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/db854f91-ccef-4035-ae4d-0911fde808c7">使用 Async 和 Await 的异步编程（C# 和 Visual Basic）</related>
      </Docs>
    </Member>
    <Member MemberName="WriteName">
      <MemberSignature Language="C#" Value="public virtual void WriteName (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void WriteName(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlWriter.WriteName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub WriteName (name As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void WriteName(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member WriteName : string -&gt; unit&#xA;override this.WriteName : string -&gt; unit" Usage="xmlWriter.WriteName name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">要写入的名称。</param>
        <summary>当在派生类中被重写时，写出指定的名称，确保它是符合 W3C XML 1.0 建议 (http://www.w3.org/TR/1998/REC-xml-19980210#NT-Name)) 的有效名称。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果<xref:System.Xml.XmlTextWriter.Namespaces%2A>设置为`true`，`WriteName`还会检查该名称也是根据 XML 建议中的 W3C 命名空间有效。  
  
 此方法的异步版本，请参阅<xref:System.Xml.XmlWriter.WriteNameAsync%2A>。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> 不是有效的 XML 名称，或者 <paramref name="name" /> 为 <see langword="null" /> 或 <see langword="String.Empty" />。</exception>
        <exception cref="T:System.InvalidOperationException">在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlWriter" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteNameAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task WriteNameAsync (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task WriteNameAsync(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlWriter.WriteNameAsync(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function WriteNameAsync (name As String) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task ^ WriteNameAsync(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member WriteNameAsync : string -&gt; System.Threading.Tasks.Task&#xA;override this.WriteNameAsync : string -&gt; System.Threading.Tasks.Task" Usage="xmlWriter.WriteNameAsync name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">要写入的名称。</param>
        <summary>异步写出指定的名称，确保它是符合 W3C XML 1.0 建议 (http://www.w3.org/TR/1998/REC-xml-19980210#NT-Name)) 的有效名称。</summary>
        <returns>表示 <see langword="WriteName" /> 异步操作的任务。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 这是异步版本<xref:System.Xml.XmlWriter.WriteName%2A>，具有相同功能。 若要使用此方法，必须设置<xref:System.Xml.XmlWriterSettings.Async%2A>标记，用于`true`。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">调用了 <see cref="T:System.Xml.XmlWriter" /> 异步方法，但未将 <see cref="P:System.Xml.XmlWriterSettings.Async" /> 标志设置为 <see langword="true" />。 在这种情况下，将引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“如果要使用异步方法，请将 XmlWriterSettings.Async 设置为 true”。</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/db854f91-ccef-4035-ae4d-0911fde808c7">使用 Async 和 Await 的异步编程（C# 和 Visual Basic）</related>
      </Docs>
    </Member>
    <Member MemberName="WriteNmToken">
      <MemberSignature Language="C#" Value="public virtual void WriteNmToken (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void WriteNmToken(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlWriter.WriteNmToken(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub WriteNmToken (name As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void WriteNmToken(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member WriteNmToken : string -&gt; unit&#xA;override this.WriteNmToken : string -&gt; unit" Usage="xmlWriter.WriteNmToken name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">要写入的名称。</param>
        <summary>当在派生类中被重写时，写出指定的名称，确保它是符合 W3C XML 1.0 建议 (http://www.w3.org/TR/1998/REC-xml-19980210#NT-Name)) 的有效 NmToken。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法的异步版本，请参阅<xref:System.Xml.XmlWriter.WriteNmTokenAsync%2A>。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> 不是有效的 NmToken；或者 <paramref name="name" /> 为 <see langword="null" /> 或 <see langword="String.Empty" />。</exception>
        <exception cref="T:System.InvalidOperationException">在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlWriter" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteNmTokenAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task WriteNmTokenAsync (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task WriteNmTokenAsync(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlWriter.WriteNmTokenAsync(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function WriteNmTokenAsync (name As String) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task ^ WriteNmTokenAsync(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member WriteNmTokenAsync : string -&gt; System.Threading.Tasks.Task&#xA;override this.WriteNmTokenAsync : string -&gt; System.Threading.Tasks.Task" Usage="xmlWriter.WriteNmTokenAsync name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">要写入的名称。</param>
        <summary>异步写出指定的名称，确保它是符合 W3C XML 1.0 建议 (http://www.w3.org/TR/1998/REC-xml-19980210#NT-Name)) 的有效 NmToken。</summary>
        <returns>表示 <see langword="WriteNmToken" /> 异步操作的任务。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 这是异步版本<xref:System.Xml.XmlWriter.WriteNmToken%2A>，具有相同功能。 若要使用此方法，必须设置<xref:System.Xml.XmlWriterSettings.Async%2A>标记，用于`true`。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">调用了 <see cref="T:System.Xml.XmlWriter" /> 异步方法，但未将 <see cref="P:System.Xml.XmlWriterSettings.Async" /> 标志设置为 <see langword="true" />。 在这种情况下，将引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“如果要使用异步方法，请将 XmlWriterSettings.Async 设置为 true”。</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/db854f91-ccef-4035-ae4d-0911fde808c7">使用 Async 和 Await 的异步编程（C# 和 Visual Basic）</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteNode">
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <exception cref="T:System.InvalidOperationException">在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlWriter" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”</exception>
        <summary>将所有内容从源对象复制到当前写入器实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法的异步版本，请参阅<xref:System.Xml.XmlWriter.WriteNodeAsync%2A>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteNode">
      <MemberSignature Language="C#" Value="public virtual void WriteNode (System.Xml.XmlReader reader, bool defattr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void WriteNode(class System.Xml.XmlReader reader, bool defattr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlWriter.WriteNode(System.Xml.XmlReader,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub WriteNode (reader As XmlReader, defattr As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void WriteNode(System::Xml::XmlReader ^ reader, bool defattr);" />
      <MemberSignature Language="F#" Value="abstract member WriteNode : System.Xml.XmlReader * bool -&gt; unit&#xA;override this.WriteNode : System.Xml.XmlReader * bool -&gt; unit" Usage="xmlWriter.WriteNode (reader, defattr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
        <Parameter Name="defattr" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="reader">要从其中进行读取的 <see cref="T:System.Xml.XmlReader" />。</param>
        <param name="defattr">如果为 <see langword="true" />，则从 <see langword="XmlReader" /> 中复制默认属性；否则为 <see langword="false" />。</param>
        <summary>当在派生类中被重写时，将全部内容从读取器复制到写入器并将读取器移动到下一个同级的开始位置。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表显示了此方法的支持的节点类型。  
  
|NodeType|WriteNode 行为|  
|--------------|------------------------|  
|`None`|写出而不考虑类型的所有节点。 也就是说，编写器使用<xref:System.Xml.XmlReader>并写出所有节点读取包括特性、 处理指令、 注释和等等。<br /><br /> 出现这种情况时<xref:System.Xml.XmlReader>处于初始状态。 (<xref:System.Xml.XmlReader.ReadState%2A?displayProperty=nameWithType>属性返回`ReaderState.Initial`)。|  
|`Element`|写出元素节点和任何属性节点。|  
|`Attribute`|无操作。 请改用 <xref:System.Xml.XmlWriter.WriteStartAttribute%2A> 或 <xref:System.Xml.XmlWriter.WriteAttributeString%2A>。|  
|`Text`|写出文本节点。|  
|`CDATA`|写出 CDATA 节节点。|  
|`EntityReference`|写出实体引用节点。|  
|`ProcessingInstruction`|写出处理指令节点。|  
|`Comment`|写出注释节点。|  
|`DocumentType`|写出文档类型节点。|  
|`SignificantWhitespace`|写出有意义的空白节点。|  
|`Whitespace`|写出空白节点。|  
|`EndElement`|写出的结束元素标记。|  
|`EndEntity`|无操作。|  
|`XmlDeclaration`|写出 XML 声明节点。|  
  
 如果读取器处于初始状态，此方法将读取器移动到文件的末尾。 如果读取器已在文件结尾或在关闭状态，此方法为非操作性。  
  
 下面的 C# 代码将整个 XML 输入的文档复制到控制台：  
  
```csharp  
XmlReader reader = XmlReader.Create(myfile);  
XmlWriter writer = XmlWriter.Create(Console.Out);  
writer.WriteNode(reader, false);  
```  
  
 如果已关闭的根节点和文档中其他位置定位下面的 C# 示例将正确地写出节点。  
  
```csharp  
XmlReader reader = XmlReader.Create(myfile);  
reader.Read(); // Read PI  
reader.Read(); // Read Comment  
reader.Read(); // Read DOCType  
XmlWriter writer = XmlWriter.Create(Console.Out);  
while (!reader.EOF){  
  writer.WriteNode(reader, false);  
 }  
```  
  
 如果读取器配置为返回的空白区域和编写器已配置为缩进输出，`WriteNode`可能产生奇怪的输出。 您将实质上将得到双重格式设置。  
  
 此方法的异步版本，请参阅<xref:System.Xml.XmlWriter.WriteNodeAsync%2A>。  
  
   
  
## Examples  
 下面的示例将第一个和最后一个 book 节点写出到控制台。  
  
 [!code-cpp[XmlWriter.WriteNode#1](~/samples/snippets/cpp/VS_Snippets_Data/XmlWriter.WriteNode/CPP/writenode.cpp#1)]
 [!code-csharp[XmlWriter.WriteNode#1](~/samples/snippets/csharp/VS_Snippets_Data/XmlWriter.WriteNode/CS/writenode.cs#1)]
 [!code-vb[XmlWriter.WriteNode#1](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlWriter.WriteNode/VB/writenode.vb#1)]  
  
 该示例使用该文件，`books.xml`作为输入。  
  
 [!code-xml[XmlWriter.WriteNode#2](~/samples/snippets/xml/VS_Snippets_Data/XmlWriter.WriteNode/XML/books.xml#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="reader" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="reader" /> 包含无效字符。</exception>
        <exception cref="T:System.InvalidOperationException">在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlWriter" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteNode">
      <MemberSignature Language="C#" Value="public virtual void WriteNode (System.Xml.XPath.XPathNavigator navigator, bool defattr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void WriteNode(class System.Xml.XPath.XPathNavigator navigator, bool defattr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlWriter.WriteNode(System.Xml.XPath.XPathNavigator,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub WriteNode (navigator As XPathNavigator, defattr As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void WriteNode(System::Xml::XPath::XPathNavigator ^ navigator, bool defattr);" />
      <MemberSignature Language="F#" Value="abstract member WriteNode : System.Xml.XPath.XPathNavigator * bool -&gt; unit&#xA;override this.WriteNode : System.Xml.XPath.XPathNavigator * bool -&gt; unit" Usage="xmlWriter.WriteNode (navigator, defattr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="navigator" Type="System.Xml.XPath.XPathNavigator" />
        <Parameter Name="defattr" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="navigator">要复制其内容的 <see cref="T:System.Xml.XPath.XPathNavigator" />。</param>
        <param name="defattr">如果复制默认特性，则为 <see langword="true" />；否则为 <see langword="false" />。</param>
        <summary>将所有内容从 <see cref="T:System.Xml.XPath.XPathNavigator" /> 对象复制到编写器。 <see cref="T:System.Xml.XPath.XPathNavigator" /> 的位置保持不变。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表显示了支持`XPath`此方法的节点类型。  
  
|XPathNodeType|WriteNode 行为|  
|-------------------|------------------------|  
|`Root`|写出而不考虑类型的所有节点。 也就是说，编写器使用<xref:System.Xml.XPath.XPathNavigator>并写出所有节点从根节点 （包括特性、 处理指令、 注释等）。|  
|`Element`|写出元素节点和任何属性节点。|  
|`Attribute`|无操作。 请改用 <xref:System.Xml.XmlWriter.WriteStartAttribute%2A> 或 <xref:System.Xml.XmlWriter.WriteAttributeString%2A>。|  
|`Text`|写出文本节点。|  
|`Namespace`|无操作。 使用<xref:System.Xml.XmlWriter.WriteStartAttribute%2A>或<xref:System.Xml.XmlWriter.WriteAttributeString%2A>方法编写命名空间声明。|  
|`ProcessingInstruction`|写出处理指令节点。|  
|`Comment`|写出注释节点。|  
|`SignificantWhitespace`|写出有意义的空白节点。|  
|`Whitespace`|写出空白节点。|  
  
 此方法的异步版本，请参阅<xref:System.Xml.XmlWriter.WriteNodeAsync%2A>。  
  
   
  
## Examples  
 下面的示例使用<xref:System.Xml.XmlWriter.WriteNode%2A>方法从文档中复制第一个 book 节点并将其写入到控制台。  
  
 [!code-csharp[XmlWriteNode_nav#1](~/samples/snippets/csharp/VS_Snippets_Data/XmlWriteNode_nav/CS/XmlWriteNode_nav.cs#1)]
 [!code-vb[XmlWriteNode_nav#1](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlWriteNode_nav/VB/XmlWriteNode_nav.vb#1)]  
  
 该示例使用 books.xml 文件作为输入。  
  
 [!code-xml[XPathXMLExamples#1](~/samples/snippets/xml/VS_Snippets_Data/XPathXMLExamples/XML/books.xml#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="navigator" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlWriter" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteNodeAsync">
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <exception cref="T:System.InvalidOperationException">调用了 <see cref="T:System.Xml.XmlWriter" /> 异步方法，但未将 <see cref="P:System.Xml.XmlWriterSettings.Async" /> 标志设置为 <see langword="true" />。 在这种情况下，将引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“如果要使用异步方法，请将 XmlWriterSettings.Async 设置为 true”。</exception>
        <summary>将所有内容从源对象异步复制到当前写入器实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 这是异步版本<xref:System.Xml.XmlWriter.WriteNode%2A>，具有相同功能。 若要使用此方法，必须设置<xref:System.Xml.XmlWriterSettings.Async%2A>标记，用于`true`。  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/db854f91-ccef-4035-ae4d-0911fde808c7">使用 Async 和 Await 的异步编程（C# 和 Visual Basic）</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteNodeAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task WriteNodeAsync (System.Xml.XmlReader reader, bool defattr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task WriteNodeAsync(class System.Xml.XmlReader reader, bool defattr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlWriter.WriteNodeAsync(System.Xml.XmlReader,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function WriteNodeAsync (reader As XmlReader, defattr As Boolean) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task ^ WriteNodeAsync(System::Xml::XmlReader ^ reader, bool defattr);" />
      <MemberSignature Language="F#" Value="abstract member WriteNodeAsync : System.Xml.XmlReader * bool -&gt; System.Threading.Tasks.Task&#xA;override this.WriteNodeAsync : System.Xml.XmlReader * bool -&gt; System.Threading.Tasks.Task" Usage="xmlWriter.WriteNodeAsync (reader, defattr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
        <Parameter Name="defattr" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="reader">要从其中进行读取的 <see cref="T:System.Xml.XmlReader" />。</param>
        <param name="defattr">如果为 <see langword="true" />，则从 <see langword="XmlReader" /> 中复制默认属性；否则为 <see langword="false" />。</param>
        <summary>将所有内容从读取器异步复制到写入器并将读取器移动到下一个同级的开头。</summary>
        <returns>表示 <see langword="WriteNode" /> 异步操作的任务。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 这是异步版本<xref:System.Xml.XmlWriter.WriteNode%2A>，具有相同功能。 若要使用此方法，必须设置<xref:System.Xml.XmlWriterSettings.Async%2A>标记，用于`true`。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">调用了 <see cref="T:System.Xml.XmlWriter" /> 异步方法，但未将 <see cref="P:System.Xml.XmlWriterSettings.Async" /> 标志设置为 <see langword="true" />。 在这种情况下，将引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“如果要使用异步方法，请将 XmlWriterSettings.Async 设置为 true”。</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/db854f91-ccef-4035-ae4d-0911fde808c7">使用 Async 和 Await 的异步编程（C# 和 Visual Basic）</related>
      </Docs>
    </Member>
    <Member MemberName="WriteNodeAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task WriteNodeAsync (System.Xml.XPath.XPathNavigator navigator, bool defattr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task WriteNodeAsync(class System.Xml.XPath.XPathNavigator navigator, bool defattr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlWriter.WriteNodeAsync(System.Xml.XPath.XPathNavigator,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function WriteNodeAsync (navigator As XPathNavigator, defattr As Boolean) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task ^ WriteNodeAsync(System::Xml::XPath::XPathNavigator ^ navigator, bool defattr);" />
      <MemberSignature Language="F#" Value="abstract member WriteNodeAsync : System.Xml.XPath.XPathNavigator * bool -&gt; System.Threading.Tasks.Task&#xA;override this.WriteNodeAsync : System.Xml.XPath.XPathNavigator * bool -&gt; System.Threading.Tasks.Task" Usage="xmlWriter.WriteNodeAsync (navigator, defattr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-2.2">
          <AttributeName>System.Diagnostics.DebuggerStepThrough</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="navigator" Type="System.Xml.XPath.XPathNavigator" />
        <Parameter Name="defattr" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="navigator">要复制其内容的 <see cref="T:System.Xml.XPath.XPathNavigator" />。</param>
        <param name="defattr">如果复制默认特性，则为 <see langword="true" />；否则为 <see langword="false" />。</param>
        <summary>从编写器的 <see cref="T:System.Xml.XPath.XPathNavigator" /> 对象中异步复制所有内容。 <see cref="T:System.Xml.XPath.XPathNavigator" /> 的位置保持不变。</summary>
        <returns>表示 <see langword="WriteNode" /> 异步操作的任务。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 这是异步版本<xref:System.Xml.XmlWriter.WriteNode%2A>，具有相同功能。 若要使用此方法，必须设置<xref:System.Xml.XmlWriterSettings.Async%2A>标记，用于`true`。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">调用了 <see cref="T:System.Xml.XmlWriter" /> 异步方法，但未将 <see cref="P:System.Xml.XmlWriterSettings.Async" /> 标志设置为 <see langword="true" />。 在这种情况下，将引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“如果要使用异步方法，请将 XmlWriterSettings.Async 设置为 true”。</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/db854f91-ccef-4035-ae4d-0911fde808c7">使用 Async 和 Await 的异步编程（C# 和 Visual Basic）</related>
      </Docs>
    </Member>
    <Member MemberName="WriteProcessingInstruction">
      <MemberSignature Language="C#" Value="public abstract void WriteProcessingInstruction (string name, string text);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void WriteProcessingInstruction(string name, string text) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlWriter.WriteProcessingInstruction(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Sub WriteProcessingInstruction (name As String, text As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void WriteProcessingInstruction(System::String ^ name, System::String ^ text);" />
      <MemberSignature Language="F#" Value="abstract member WriteProcessingInstruction : string * string -&gt; unit" Usage="xmlWriter.WriteProcessingInstruction (name, text)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="text" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">处理指令的名称。</param>
        <param name="text">要包括在处理指令中的文本。</param>
        <summary>当在派生类中被重写时，写出在名称和文本之间带有空格的处理指令，如下所示：&lt;?name text?&gt;。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法可用于写入 XML 声明 (而非<xref:System.Xml.XmlWriter.WriteStartDocument%2A>)。 这可能导致不正确地编写的编码属性。 例如，下面的 C# 代码将导致无效的 XML 文档，因为默认编码为 utf-8。  
  
```csharp  
XmlWriter writer = XmlWriter.Create("output.xml");  
writer.WriteProcessingInstruction("xml", "version='1.0' encoding='UTF-16'");  
writer.WriteStartElement("root");  
writer.Close();  
```  
  
 如果`text`可以是`null`或`String.Empty`，此方法写入`ProcessingInstruction`不包含数据内容，例如\<？ 名称？ >。  
  
 如果文本包含无效的序列"？ >"，则<xref:System.Xml.XmlWriter>会引发<xref:System.ArgumentException>(<xref:System.Xml.XmlTextWriter>对象) 或插入空格"？ >"以避免编写无效的 XML (<xref:System.Xml.XmlWriter>创建的对象<xref:System.Xml.XmlWriter.Create%2A>方法)。  
  
 此方法的异步版本，请参阅<xref:System.Xml.XmlWriter.WriteProcessingInstructionAsync%2A>。  
  
   
  
## Examples  
 以下示例将编写一个表示一书的 XML 文件。  
  
 [!code-csharp[XmlWriter.WriteStartDocument#1](~/samples/snippets/csharp/VS_Snippets_Data/XmlWriter.WriteStartDocument/CS/writerbook_v2.cs#1)]
 [!code-vb[XmlWriter.WriteStartDocument#1](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlWriter.WriteStartDocument/VB/writerbook_v2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">该文本将导致格式不正确的 XML 文档。  
  
 <paramref name="name" /> 为 <see langword="null" /> 或 <see langword="String.Empty" />。  
  
调用了 <see cref="M:System.Xml.XmlWriter.WriteStartDocument" /> 后，使用此方法创建 XML 声明。</exception>
        <exception cref="T:System.InvalidOperationException">在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlWriter" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteProcessingInstructionAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task WriteProcessingInstructionAsync (string name, string text);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task WriteProcessingInstructionAsync(string name, string text) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlWriter.WriteProcessingInstructionAsync(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function WriteProcessingInstructionAsync (name As String, text As String) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task ^ WriteProcessingInstructionAsync(System::String ^ name, System::String ^ text);" />
      <MemberSignature Language="F#" Value="abstract member WriteProcessingInstructionAsync : string * string -&gt; System.Threading.Tasks.Task&#xA;override this.WriteProcessingInstructionAsync : string * string -&gt; System.Threading.Tasks.Task" Usage="xmlWriter.WriteProcessingInstructionAsync (name, text)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="text" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">处理指令的名称。</param>
        <param name="text">要包括在处理指令中的文本。</param>
        <summary>异步写出在名称和文本之间有空格的处理指令，如下所示：&lt;?name text?&gt;。</summary>
        <returns>表示 <see langword="WriteProcessingInstruction" /> 异步操作的任务。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 这是异步版本<xref:System.Xml.XmlWriter.WriteProcessingInstruction%2A>，具有相同功能。 若要使用此方法，必须设置<xref:System.Xml.XmlWriterSettings.Async%2A>标记，用于`true`。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">调用了 <see cref="T:System.Xml.XmlWriter" /> 异步方法，但未将 <see cref="P:System.Xml.XmlWriterSettings.Async" /> 标志设置为 <see langword="true" />。 在这种情况下，将引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“如果要使用异步方法，请将 XmlWriterSettings.Async 设置为 true”。</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/db854f91-ccef-4035-ae4d-0911fde808c7">使用 Async 和 Await 的异步编程（C# 和 Visual Basic）</related>
      </Docs>
    </Member>
    <Member MemberName="WriteQualifiedName">
      <MemberSignature Language="C#" Value="public virtual void WriteQualifiedName (string localName, string ns);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void WriteQualifiedName(string localName, string ns) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlWriter.WriteQualifiedName(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub WriteQualifiedName (localName As String, ns As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void WriteQualifiedName(System::String ^ localName, System::String ^ ns);" />
      <MemberSignature Language="F#" Value="abstract member WriteQualifiedName : string * string -&gt; unit&#xA;override this.WriteQualifiedName : string * string -&gt; unit" Usage="xmlWriter.WriteQualifiedName (localName, ns)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="localName" Type="System.String" />
        <Parameter Name="ns" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="localName">要写入的本地名称。</param>
        <param name="ns">名称的命名空间 URI。</param>
        <summary>当在派生类中被重写时，写出命名空间限定的名称。 此方法查找位于给定命名空间范围内的前缀。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果`ns`生成映射到当前默认命名空间，没有前缀。  
  
 如果在编写属性值时，此方法将生成一个前缀`ns`找不到。 在编写元素内容时，会引发异常，如果`ns`找不到。  
  
> [!NOTE]
>  如果一个类派生自<xref:System.Xml.XmlWriter>不重写此方法`localName`不检查是有效的 W3C XML 名称。 在这种情况下之前调用此方法，, 该字符串的有效性可以检查<xref:System.Xml.XmlReader.IsName%2A>方法。  
  
 此方法的异步版本，请参阅<xref:System.Xml.XmlWriter.WriteQualifiedNameAsync%2A>。  
  
   
  
## Examples  
 该示例将写入以下元素：  
  
```xml  
<root xmlns:x="urn:abc">  
  <item href="#x:test"/>  
</root>  
```  
  
 [!code-csharp[XmlWriter_v2#5](~/samples/snippets/csharp/VS_Snippets_Data/XmlWriter_v2/CS/writer_v2.cs#5)]
 [!code-vb[XmlWriter_v2#5](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlWriter_v2/VB/writer_v2.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="localName" /> 为 <see langword="null" /> 或 <see langword="String.Empty" />。  
  
 <paramref name="localName" /> 不是有效的名称。</exception>
        <exception cref="T:System.InvalidOperationException">在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlWriter" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteQualifiedNameAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task WriteQualifiedNameAsync (string localName, string ns);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task WriteQualifiedNameAsync(string localName, string ns) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlWriter.WriteQualifiedNameAsync(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function WriteQualifiedNameAsync (localName As String, ns As String) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task ^ WriteQualifiedNameAsync(System::String ^ localName, System::String ^ ns);" />
      <MemberSignature Language="F#" Value="abstract member WriteQualifiedNameAsync : string * string -&gt; System.Threading.Tasks.Task&#xA;override this.WriteQualifiedNameAsync : string * string -&gt; System.Threading.Tasks.Task" Usage="xmlWriter.WriteQualifiedNameAsync (localName, ns)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-2.2">
          <AttributeName>System.Diagnostics.DebuggerStepThrough</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="localName" Type="System.String" />
        <Parameter Name="ns" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="localName">要写入的本地名称。</param>
        <param name="ns">名称的命名空间 URI。</param>
        <summary>异步写出命名空间限定的名称。 此方法查找位于给定命名空间范围内的前缀。</summary>
        <returns>表示 <see langword="WriteQualifiedName" /> 异步操作的任务。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 这是异步版本<xref:System.Xml.XmlWriter.WriteQualifiedName%2A>，具有相同功能。 若要使用此方法，必须设置<xref:System.Xml.XmlWriterSettings.Async%2A>标记，用于`true`。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">调用了 <see cref="T:System.Xml.XmlWriter" /> 异步方法，但未将 <see cref="P:System.Xml.XmlWriterSettings.Async" /> 标志设置为 <see langword="true" />。 在这种情况下，将引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“如果要使用异步方法，请将 XmlWriterSettings.Async 设置为 true”。</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/db854f91-ccef-4035-ae4d-0911fde808c7">使用 Async 和 Await 的异步编程（C# 和 Visual Basic）</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteRaw">
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <exception cref="T:System.InvalidOperationException">在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlWriter" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”</exception>
        <summary>当在派生类中被重写时，手动写入原始标记。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法的异步版本，请参阅<xref:System.Xml.XmlWriter.WriteRawAsync%2A>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteRaw">
      <MemberSignature Language="C#" Value="public abstract void WriteRaw (string data);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void WriteRaw(string data) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlWriter.WriteRaw(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Sub WriteRaw (data As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void WriteRaw(System::String ^ data);" />
      <MemberSignature Language="F#" Value="abstract member WriteRaw : string -&gt; unit" Usage="xmlWriter.WriteRaw data" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="data">包含要写入的文本的字符串。</param>
        <summary>当在派生类中被重写时，从字符串手动写入原始标记。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法不转义特殊字符。  
  
> [!IMPORTANT]
>  <xref:System.Xml.XmlWriter>不会验证传递给数据<xref:System.Xml.XmlWriter.WriteRaw%2A>方法。 不应将任意数据传递给此方法。  
  
 此方法的异步版本，请参阅<xref:System.Xml.XmlWriter.WriteRawAsync%2A>。  
  
   
  
## Examples  
 请参阅<xref:System.Xml.XmlTextWriter.WriteRaw%2A?displayProperty=nameWithType>有关使用此方法的示例。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="data" /> 为 <see langword="null" /> 或 <see langword="String.Empty" />。</exception>
        <exception cref="T:System.InvalidOperationException">在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlWriter" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteRaw">
      <MemberSignature Language="C#" Value="public abstract void WriteRaw (char[] buffer, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void WriteRaw(char[] buffer, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlWriter.WriteRaw(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Sub WriteRaw (buffer As Char(), index As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void WriteRaw(cli::array &lt;char&gt; ^ buffer, int index, int count);" />
      <MemberSignature Language="F#" Value="abstract member WriteRaw : char[] * int * int -&gt; unit" Usage="xmlWriter.WriteRaw (buffer, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Char[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">包含要写入的文本的字符数组。</param>
        <param name="index">缓冲区中的位置，指示要写入文本的起始位置。</param>
        <param name="count">要写入的字符数。</param>
        <summary>当在派生类中被重写时，从字符缓冲区手动写入原始标记。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法不转义特殊字符。  
  
> [!IMPORTANT]
>  <xref:System.Xml.XmlWriter>不会验证传递给数据<xref:System.Xml.XmlWriter.WriteRaw%2A>方法。 不应将任意数据传递给此方法。  
  
 此方法的异步版本，请参阅<xref:System.Xml.XmlWriter.WriteRawAsync%2A>。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> 或 <paramref name="count" /> 小于零。  
  
或 
缓冲区长度减去 <paramref name="index" /> 小于 <paramref name="count" />。</exception>
        <exception cref="T:System.InvalidOperationException">在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlWriter" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteRawAsync">
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <exception cref="T:System.InvalidOperationException">调用了 <see cref="T:System.Xml.XmlWriter" /> 异步方法，但未将 <see cref="P:System.Xml.XmlWriterSettings.Async" /> 标志设置为 <see langword="true" />。 在这种情况下，将引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“如果要使用异步方法，请将 XmlWriterSettings.Async 设置为 true”。</exception>
        <summary>手动异步写入原始标记。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 这是异步版本<xref:System.Xml.XmlWriter.WriteRaw%2A>，具有相同功能。 若要使用此方法，必须设置<xref:System.Xml.XmlWriterSettings.Async%2A>标记，用于`true`。  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/db854f91-ccef-4035-ae4d-0911fde808c7">使用 Async 和 Await 的异步编程（C# 和 Visual Basic）</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteRawAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task WriteRawAsync (string data);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task WriteRawAsync(string data) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlWriter.WriteRawAsync(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function WriteRawAsync (data As String) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task ^ WriteRawAsync(System::String ^ data);" />
      <MemberSignature Language="F#" Value="abstract member WriteRawAsync : string -&gt; System.Threading.Tasks.Task&#xA;override this.WriteRawAsync : string -&gt; System.Threading.Tasks.Task" Usage="xmlWriter.WriteRawAsync data" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="data">包含要写入的文本的字符串。</param>
        <summary>从字符串手动异步写入原始标记。</summary>
        <returns>表示 <see langword="WriteRaw" /> 异步操作的任务。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 这是异步版本<xref:System.Xml.XmlWriter.WriteRaw%2A>，具有相同功能。 若要使用此方法，必须设置<xref:System.Xml.XmlWriterSettings.Async%2A>标记，用于`true`。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">调用了 <see cref="T:System.Xml.XmlWriter" /> 异步方法，但未将 <see cref="P:System.Xml.XmlWriterSettings.Async" /> 标志设置为 <see langword="true" />。 在这种情况下，将引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“如果要使用异步方法，请将 XmlWriterSettings.Async 设置为 true”。</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/db854f91-ccef-4035-ae4d-0911fde808c7">使用 Async 和 Await 的异步编程（C# 和 Visual Basic）</related>
      </Docs>
    </Member>
    <Member MemberName="WriteRawAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task WriteRawAsync (char[] buffer, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task WriteRawAsync(char[] buffer, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlWriter.WriteRawAsync(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function WriteRawAsync (buffer As Char(), index As Integer, count As Integer) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task ^ WriteRawAsync(cli::array &lt;char&gt; ^ buffer, int index, int count);" />
      <MemberSignature Language="F#" Value="abstract member WriteRawAsync : char[] * int * int -&gt; System.Threading.Tasks.Task&#xA;override this.WriteRawAsync : char[] * int * int -&gt; System.Threading.Tasks.Task" Usage="xmlWriter.WriteRawAsync (buffer, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Char[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">包含要写入的文本的字符数组。</param>
        <param name="index">缓冲区中的位置，指示要写入文本的起始位置。</param>
        <param name="count">要写入的字符数。</param>
        <summary>从字符缓冲区手动异步写入原始标记。</summary>
        <returns>表示 <see langword="WriteRaw" /> 异步操作的任务。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 这是异步版本<xref:System.Xml.XmlWriter.WriteRaw%2A>，具有相同功能。 若要使用此方法，必须设置<xref:System.Xml.XmlWriterSettings.Async%2A>标记，用于`true`。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">调用了 <see cref="T:System.Xml.XmlWriter" /> 异步方法，但未将 <see cref="P:System.Xml.XmlWriterSettings.Async" /> 标志设置为 <see langword="true" />。 在这种情况下，将引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“如果要使用异步方法，请将 XmlWriterSettings.Async 设置为 true”。</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/db854f91-ccef-4035-ae4d-0911fde808c7">使用 Async 和 Await 的异步编程（C# 和 Visual Basic）</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteStartAttribute">
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <exception cref="T:System.InvalidOperationException">在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlWriter" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”</exception>
        <summary>当在派生类中被重写时，写入属性的起始内容。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法的异步版本，请参阅<xref:System.Xml.XmlWriter.WriteStartAttributeAsync%2A>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteStartAttribute">
      <MemberSignature Language="C#" Value="public void WriteStartAttribute (string localName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteStartAttribute(string localName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlWriter.WriteStartAttribute(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteStartAttribute (localName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteStartAttribute(System::String ^ localName);" />
      <MemberSignature Language="F#" Value="member this.WriteStartAttribute : string -&gt; unit" Usage="xmlWriter.WriteStartAttribute localName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="localName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="localName">属性的本地名称。</param>
        <summary>写入具有指定本地名称的属性的开头。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法可以编写使用多个写入方法的值。  
  
 此方法的异步版本，请参阅<xref:System.Xml.XmlWriter.WriteStartAttributeAsync%2A>。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlWriter" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”</exception>
        <exception cref="T:System.Text.EncoderFallbackException">缓冲区中有一个字符是有效的 XML 字符，但对于输出编码是无效的。 例如，如果输出编码为 ASCII，应该仅对元素和特性名使用从 0 到 127 范围内的字符。 无效的字符可能位于此方法的参数中，或者位于以前要写入缓冲区的方法的参数中。 如果可能，此类字符将使用字符实体引用进行转义（例如，在文本节点或特性值中）。 但是，不允许在元素名、特性名、注释、处理指令和 CDATA 节中使用字符实体引用。</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteStartAttribute">
      <MemberSignature Language="C#" Value="public void WriteStartAttribute (string localName, string ns);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteStartAttribute(string localName, string ns) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlWriter.WriteStartAttribute(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteStartAttribute (localName As String, ns As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteStartAttribute(System::String ^ localName, System::String ^ ns);" />
      <MemberSignature Language="F#" Value="member this.WriteStartAttribute : string * string -&gt; unit" Usage="xmlWriter.WriteStartAttribute (localName, ns)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="localName" Type="System.String" />
        <Parameter Name="ns" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="localName">属性的本地名称。</param>
        <param name="ns">属性的命名空间 URI。</param>
        <summary>写入具有指定本地名称和命名空间 URI 的属性的开头。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 这是更高级的版本<xref:System.Xml.XmlWriter.WriteAttributeString%2A>，可用于写入属性值使用多个写入方法，如<xref:System.Xml.XmlWriter.WriteString%2A>， <xref:System.Xml.XmlWriter.WriteQualifiedName%2A>，依次类推。  
  
 此方法的异步版本，请参阅<xref:System.Xml.XmlWriter.WriteStartAttributeAsync%2A>。  
  
   
  
## Examples  
 请参阅<xref:System.Xml.XmlTextWriter.WriteStartAttribute%2A?displayProperty=nameWithType>有关使用此方法的示例。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Text.EncoderFallbackException">缓冲区中有一个字符是有效的 XML 字符，但对于输出编码是无效的。 例如，如果输出编码为 ASCII，应该仅对元素和特性名使用从 0 到 127 范围内的字符。 无效的字符可能位于此方法的参数中，或者位于以前要写入缓冲区的方法的参数中。 如果可能，此类字符将使用字符实体引用进行转义（例如，在文本节点或特性值中）。 但是，不允许在元素名、特性名、注释、处理指令和 CDATA 节中使用字符实体引用。</exception>
        <exception cref="T:System.InvalidOperationException">在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlWriter" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”</exception>
        <altmember cref="M:System.Xml.XmlWriter.WriteEndAttribute" />
      </Docs>
    </Member>
    <Member MemberName="WriteStartAttribute">
      <MemberSignature Language="C#" Value="public abstract void WriteStartAttribute (string prefix, string localName, string ns);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void WriteStartAttribute(string prefix, string localName, string ns) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlWriter.WriteStartAttribute(System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Sub WriteStartAttribute (prefix As String, localName As String, ns As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void WriteStartAttribute(System::String ^ prefix, System::String ^ localName, System::String ^ ns);" />
      <MemberSignature Language="F#" Value="abstract member WriteStartAttribute : string * string * string -&gt; unit" Usage="xmlWriter.WriteStartAttribute (prefix, localName, ns)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="prefix" Type="System.String" />
        <Parameter Name="localName" Type="System.String" />
        <Parameter Name="ns" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="prefix">属性的命名空间前缀。</param>
        <param name="localName">属性的本地名称。</param>
        <param name="ns">属性的命名空间 URI。</param>
        <summary>当在派生类中被重写时，写入具有指定的前缀、本地名称和命名空间 URI 的属性的开头。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法可以编写使用多个写入方法的值。  
  
 此方法的异步版本，请参阅<xref:System.Xml.XmlWriter.WriteStartAttributeAsync%2A>。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Text.EncoderFallbackException">缓冲区中有一个字符是有效的 XML 字符，但对于输出编码是无效的。 例如，如果输出编码为 ASCII，应该仅对元素和特性名使用从 0 到 127 范围内的字符。 无效的字符可能位于此方法的参数中，或者位于以前要写入缓冲区的方法的参数中。 如果可能，此类字符将使用字符实体引用进行转义（例如，在文本节点或特性值中）。 但是，不允许在元素名、特性名、注释、处理指令和 CDATA 节中使用字符实体引用。</exception>
        <exception cref="T:System.InvalidOperationException">在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlWriter" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteStartAttributeAsync">
      <MemberSignature Language="C#" Value="protected internal virtual System.Threading.Tasks.Task WriteStartAttributeAsync (string prefix, string localName, string ns);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance class System.Threading.Tasks.Task WriteStartAttributeAsync(string prefix, string localName, string ns) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlWriter.WriteStartAttributeAsync(System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Function WriteStartAttributeAsync (prefix As String, localName As String, ns As String) As Task" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual System::Threading::Tasks::Task ^ WriteStartAttributeAsync(System::String ^ prefix, System::String ^ localName, System::String ^ ns);" />
      <MemberSignature Language="F#" Value="abstract member WriteStartAttributeAsync : string * string * string -&gt; System.Threading.Tasks.Task&#xA;override this.WriteStartAttributeAsync : string * string * string -&gt; System.Threading.Tasks.Task" Usage="xmlWriter.WriteStartAttributeAsync (prefix, localName, ns)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="prefix" Type="System.String" />
        <Parameter Name="localName" Type="System.String" />
        <Parameter Name="ns" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="prefix">属性的命名空间前缀。</param>
        <param name="localName">属性的本地名称。</param>
        <param name="ns">属性的命名空间 URI。</param>
        <summary>异步写入具有指定前缀、本地名称和命名空间 URI 的属性的开头。</summary>
        <returns>表示 <see langword="WriteStartAttribute" /> 异步操作的任务。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 这是异步版本<xref:System.Xml.XmlWriter.WriteStartAttribute%2A>，具有相同功能。 若要使用此方法，必须设置<xref:System.Xml.XmlWriterSettings.Async%2A>标记，用于`true`。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">调用了 <see cref="T:System.Xml.XmlWriter" /> 异步方法，但未将 <see cref="P:System.Xml.XmlWriterSettings.Async" /> 标志设置为 <see langword="true" />。 在这种情况下，将引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“如果要使用异步方法，请将 XmlWriterSettings.Async 设置为 true”。</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/db854f91-ccef-4035-ae4d-0911fde808c7">使用 Async 和 Await 的异步编程（C# 和 Visual Basic）</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteStartDocument">
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <exception cref="T:System.InvalidOperationException">在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlWriter" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”</exception>
        <summary>当在派生类中被重写时，写入 XML 声明。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法的异步版本，请参阅<xref:System.Xml.XmlWriter.WriteStartDocumentAsync%2A>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteStartDocument">
      <MemberSignature Language="C#" Value="public abstract void WriteStartDocument ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void WriteStartDocument() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlWriter.WriteStartDocument" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Sub WriteStartDocument ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void WriteStartDocument();" />
      <MemberSignature Language="F#" Value="abstract member WriteStartDocument : unit -&gt; unit" Usage="xmlWriter.WriteStartDocument " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>当在派生类中被重写时，写入版本为“1.0”的 XML 声明。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 由编写器的实现方式确定文档的编码级别。 例如，如果<xref:System.Text.Encoding>中指定对象`XmlTextWriter`构造函数中，这决定了编码属性的值。 此方法不创建独立属性。  
  
 当`WriteStartDocument`调用编写器验证你正在编写是格式正确的 XML 文档。 例如，它会检查 XML 声明是第一个节点，一个并只有一个根级别元素存在，依次类推。 如果未调用此方法，编写器将假定 XML 片段写入，并且不应用任何根级别规则。  
  
 如果`WriteStartDocument`已调用，然后<xref:System.Xml.XmlWriter.WriteProcessingInstruction%2A>方法用于创建另一个 XML 声明，将引发异常。  
  
 此方法的异步版本，请参阅<xref:System.Xml.XmlWriter.WriteStartDocumentAsync%2A>。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlWriter" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteStartDocument">
      <MemberSignature Language="C#" Value="public abstract void WriteStartDocument (bool standalone);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void WriteStartDocument(bool standalone) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlWriter.WriteStartDocument(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Sub WriteStartDocument (standalone As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void WriteStartDocument(bool standalone);" />
      <MemberSignature Language="F#" Value="abstract member WriteStartDocument : bool -&gt; unit" Usage="xmlWriter.WriteStartDocument standalone" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="standalone" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="standalone">如果为 <see langword="true" />，则它将写入"standalone=yes"；如果为 <see langword="false" />，则它将写入"standalone=no"。</param>
        <summary>当在派生类中被重写时，写入版本为“1.0”的 XML 声明和独立的属性。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 由编写器的实现方式确定文档的编码级别。 例如，如果<xref:System.Text.Encoding>中指定对象`XmlTextWriter`构造函数中，这决定了编码属性的值。  
  
 当`WriteStartDocument`是编写器调用，验证你正在编写是格式正确的 XML 文档。 例如，它会检查 XML 声明是第一个节点，一个并只有一个根级别元素存在，依次类推。 如果未调用此方法，编写器将假定 XML 片段写入，并且不应用任何根级别规则。  
  
 如果`WriteStartDocument`已调用，然后<xref:System.Xml.XmlWriter.WriteProcessingInstruction%2A>方法用于创建另一个 XML 声明，将引发异常。  
  
 此方法的异步版本，请参阅<xref:System.Xml.XmlWriter.WriteStartDocumentAsync%2A>。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlWriter" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteStartDocumentAsync">
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <exception cref="T:System.InvalidOperationException">调用了 <see cref="T:System.Xml.XmlWriter" /> 异步方法，但未将 <see cref="P:System.Xml.XmlWriterSettings.Async" /> 标志设置为 <see langword="true" />。 在这种情况下，将引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“如果要使用异步方法，请将 XmlWriterSettings.Async 设置为 true”。</exception>
        <summary>异步写入 XML 声明。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 这是异步版本<xref:System.Xml.XmlWriter.WriteStartDocument%2A>，具有相同功能。 若要使用此方法，必须设置<xref:System.Xml.XmlWriterSettings.Async%2A>标记，用于`true`。  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/db854f91-ccef-4035-ae4d-0911fde808c7">使用 Async 和 Await 的异步编程（C# 和 Visual Basic）</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteStartDocumentAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task WriteStartDocumentAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task WriteStartDocumentAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlWriter.WriteStartDocumentAsync" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function WriteStartDocumentAsync () As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task ^ WriteStartDocumentAsync();" />
      <MemberSignature Language="F#" Value="abstract member WriteStartDocumentAsync : unit -&gt; System.Threading.Tasks.Task&#xA;override this.WriteStartDocumentAsync : unit -&gt; System.Threading.Tasks.Task" Usage="xmlWriter.WriteStartDocumentAsync " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>异步写入版本为“1.0”的 XML 声明。</summary>
        <returns>表示 <see langword="WriteStartDocument" /> 异步操作的任务。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 这是异步版本<xref:System.Xml.XmlWriter.WriteStartDocument%2A>，具有相同功能。 若要使用此方法，必须设置<xref:System.Xml.XmlWriterSettings.Async%2A>标记，用于`true`。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">调用了 <see cref="T:System.Xml.XmlWriter" /> 异步方法，但未将 <see cref="P:System.Xml.XmlWriterSettings.Async" /> 标志设置为 <see langword="true" />。 在这种情况下，将引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“如果要使用异步方法，请将 XmlWriterSettings.Async 设置为 true”。</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/db854f91-ccef-4035-ae4d-0911fde808c7">使用 Async 和 Await 的异步编程（C# 和 Visual Basic）</related>
      </Docs>
    </Member>
    <Member MemberName="WriteStartDocumentAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task WriteStartDocumentAsync (bool standalone);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task WriteStartDocumentAsync(bool standalone) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlWriter.WriteStartDocumentAsync(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function WriteStartDocumentAsync (standalone As Boolean) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task ^ WriteStartDocumentAsync(bool standalone);" />
      <MemberSignature Language="F#" Value="abstract member WriteStartDocumentAsync : bool -&gt; System.Threading.Tasks.Task&#xA;override this.WriteStartDocumentAsync : bool -&gt; System.Threading.Tasks.Task" Usage="xmlWriter.WriteStartDocumentAsync standalone" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="standalone" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="standalone">如果为 <see langword="true" />，则它将写入"standalone=yes"；如果为 <see langword="false" />，则它将写入"standalone=no"。</param>
        <summary>异步写入版本为“1.0”的 XML 声明和独立的属性。</summary>
        <returns>表示 <see langword="WriteStartDocument" /> 异步操作的任务。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 这是异步版本<xref:System.Xml.XmlWriter.WriteStartDocument%2A>，具有相同功能。 若要使用此方法，必须设置<xref:System.Xml.XmlWriterSettings.Async%2A>标记，用于`true`。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">调用了 <see cref="T:System.Xml.XmlWriter" /> 异步方法，但未将 <see cref="P:System.Xml.XmlWriterSettings.Async" /> 标志设置为 <see langword="true" />。 在这种情况下，将引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“如果要使用异步方法，请将 XmlWriterSettings.Async 设置为 true”。</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/db854f91-ccef-4035-ae4d-0911fde808c7">使用 Async 和 Await 的异步编程（C# 和 Visual Basic）</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteStartElement">
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <exception cref="T:System.InvalidOperationException">在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlWriter" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”</exception>
        <summary>当在派生类中被重写时，写入指定的开始标记。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法的异步版本，请参阅<xref:System.Xml.XmlWriter.WriteStartElementAsync%2A>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteStartElement">
      <MemberSignature Language="C#" Value="public void WriteStartElement (string localName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteStartElement(string localName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlWriter.WriteStartElement(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteStartElement (localName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteStartElement(System::String ^ localName);" />
      <MemberSignature Language="F#" Value="member this.WriteStartElement : string -&gt; unit" Usage="xmlWriter.WriteStartElement localName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="localName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="localName">元素的本地名称。</param>
        <summary>当在派生类中被重写时，写出具有指定的本地名称的开始标记。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法的异步版本，请参阅<xref:System.Xml.XmlWriter.WriteStartElementAsync%2A>。  
  
   
  
## Examples  
 下面的示例将写入的 XML 节点。  
  
 [!code-cpp[XmlWriter.Close#1](~/samples/snippets/cpp/VS_Snippets_Data/XmlWriter.Close/CPP/XmlWriter.Close.cpp#1)]
 [!code-csharp[XmlWriter.Close#1](~/samples/snippets/csharp/VS_Snippets_Data/XmlWriter.Close/CS/writeelems.cs#1)]
 [!code-vb[XmlWriter.Close#1](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlWriter.Close/VB/writeelems.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlWriter" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”</exception>
        <exception cref="T:System.Text.EncoderFallbackException">缓冲区中有一个字符是有效的 XML 字符，但对于输出编码是无效的。 例如，如果输出编码为 ASCII，应该仅对元素和特性名使用从 0 到 127 范围内的字符。 无效的字符可能位于此方法的参数中，或者位于以前要写入缓冲区的方法的参数中。 如果可能，此类字符将使用字符实体引用进行转义（例如，在文本节点或特性值中）。 但是，不允许在元素名、特性名、注释、处理指令和 CDATA 节中使用字符实体引用。</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteStartElement">
      <MemberSignature Language="C#" Value="public void WriteStartElement (string localName, string ns);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteStartElement(string localName, string ns) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlWriter.WriteStartElement(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteStartElement (localName As String, ns As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteStartElement(System::String ^ localName, System::String ^ ns);" />
      <MemberSignature Language="F#" Value="member this.WriteStartElement : string * string -&gt; unit" Usage="xmlWriter.WriteStartElement (localName, ns)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="localName" Type="System.String" />
        <Parameter Name="ns" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="localName">元素的本地名称。</param>
        <param name="ns">与元素关联的命名空间 URI。 如果此命名空间已在范围中并具有关联的前缀，则写入器也将自动写入该前缀。</param>
        <summary>当在派生类中被重写时，写入指定的开始标记并将其与给定的命名空间关联起来。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 调用此方法可以写入属性，也可以创建后使用的内容<xref:System.Xml.XmlWriter.WriteComment%2A>， <xref:System.Xml.XmlWriter.WriteString%2A>，或`WriteStartElement`的子元素。 你可以关闭与元素<xref:System.Xml.XmlWriter.WriteEndElement%2A>或<xref:System.Xml.XmlWriter.WriteFullEndElement%2A>。 例如，下面的 C# 代码：  
  
```csharp  
writer.WriteStartElement("item",null);  
writer.WriteString("some text");  
writer.WriteEndElement();  
```  
  
 生成以下输出：  
  
```xml  
<item>some text</item>  
```  
  
 此方法的异步版本，请参阅<xref:System.Xml.XmlWriter.WriteStartElementAsync%2A>。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlWriter" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”</exception>
        <exception cref="T:System.Text.EncoderFallbackException">缓冲区中有一个字符是有效的 XML 字符，但对于输出编码是无效的。 例如，如果输出编码为 ASCII，应该仅对元素和特性名使用从 0 到 127 范围内的字符。 无效的字符可能位于此方法的参数中，或者位于以前要写入缓冲区的方法的参数中。 如果可能，此类字符将使用字符实体引用进行转义（例如，在文本节点或特性值中）。 但是，不允许在元素名、特性名、注释、处理指令和 CDATA 节中使用字符实体引用。</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteStartElement">
      <MemberSignature Language="C#" Value="public abstract void WriteStartElement (string prefix, string localName, string ns);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void WriteStartElement(string prefix, string localName, string ns) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlWriter.WriteStartElement(System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Sub WriteStartElement (prefix As String, localName As String, ns As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void WriteStartElement(System::String ^ prefix, System::String ^ localName, System::String ^ ns);" />
      <MemberSignature Language="F#" Value="abstract member WriteStartElement : string * string * string -&gt; unit" Usage="xmlWriter.WriteStartElement (prefix, localName, ns)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="prefix" Type="System.String" />
        <Parameter Name="localName" Type="System.String" />
        <Parameter Name="ns" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="prefix">元素的命名空间前缀。</param>
        <param name="localName">元素的本地名称。</param>
        <param name="ns">与元素关联的命名空间 URI。</param>
        <summary>当在派生类中被重写时，写入指定的开始标记并将其与给定的命名空间和前缀关联起来。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法的异步版本，请参阅<xref:System.Xml.XmlWriter.WriteStartElementAsync%2A>。  
  
   
  
## Examples  
 下面的示例写出 XML 片段。  
  
 [!code-cpp[XmlWriter.WriteElementString#1](~/samples/snippets/cpp/VS_Snippets_Data/XmlWriter.WriteElementString/CPP/writeelemstring_v2.cpp#1)]
 [!code-csharp[XmlWriter.WriteElementString#1](~/samples/snippets/csharp/VS_Snippets_Data/XmlWriter.WriteElementString/CS/writeelemstring_v2.cs#1)]
 [!code-vb[XmlWriter.WriteElementString#1](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlWriter.WriteElementString/VB/writeelemstring_v2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlWriter" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”</exception>
        <exception cref="T:System.Text.EncoderFallbackException">缓冲区中有一个字符是有效的 XML 字符，但对于输出编码是无效的。 例如，如果输出编码为 ASCII，应该仅对元素和特性名使用从 0 到 127 范围内的字符。 无效的字符可能位于此方法的参数中，或者位于以前要写入缓冲区的方法的参数中。 如果可能，此类字符将使用字符实体引用进行转义（例如，在文本节点或特性值中）。 但是，不允许在元素名、特性名、注释、处理指令和 CDATA 节中使用字符实体引用。</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteStartElementAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task WriteStartElementAsync (string prefix, string localName, string ns);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task WriteStartElementAsync(string prefix, string localName, string ns) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlWriter.WriteStartElementAsync(System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function WriteStartElementAsync (prefix As String, localName As String, ns As String) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task ^ WriteStartElementAsync(System::String ^ prefix, System::String ^ localName, System::String ^ ns);" />
      <MemberSignature Language="F#" Value="abstract member WriteStartElementAsync : string * string * string -&gt; System.Threading.Tasks.Task&#xA;override this.WriteStartElementAsync : string * string * string -&gt; System.Threading.Tasks.Task" Usage="xmlWriter.WriteStartElementAsync (prefix, localName, ns)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="prefix" Type="System.String" />
        <Parameter Name="localName" Type="System.String" />
        <Parameter Name="ns" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="prefix">元素的命名空间前缀。</param>
        <param name="localName">元素的本地名称。</param>
        <param name="ns">与元素关联的命名空间 URI。</param>
        <summary>异步写入指定的开始标记并将其与给定的命名空间和前缀关联起来。</summary>
        <returns>表示 <see langword="WriteStartElement" /> 异步操作的任务。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 这是异步版本<xref:System.Xml.XmlWriter.WriteStartElement%2A>，具有相同功能。 若要使用此方法，必须设置<xref:System.Xml.XmlWriterSettings.Async%2A>标记，用于`true`。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">调用了 <see cref="T:System.Xml.XmlWriter" /> 异步方法，但未将 <see cref="P:System.Xml.XmlWriterSettings.Async" /> 标志设置为 <see langword="true" />。 在这种情况下，将引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“如果要使用异步方法，请将 XmlWriterSettings.Async 设置为 true”。</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/db854f91-ccef-4035-ae4d-0911fde808c7">使用 Async 和 Await 的异步编程（C# 和 Visual Basic）</related>
      </Docs>
    </Member>
    <Member MemberName="WriteState">
      <MemberSignature Language="C#" Value="public abstract System.Xml.WriteState WriteState { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Xml.WriteState WriteState" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlWriter.WriteState" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property WriteState As WriteState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::Xml::WriteState WriteState { System::Xml::WriteState get(); };" />
      <MemberSignature Language="F#" Value="member this.WriteState : System.Xml.WriteState" Usage="System.Xml.XmlWriter.WriteState" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.WriteState</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当在派生类中被重写时，获取写入器的状态。</summary>
        <value>
          <see cref="T:System.Xml.WriteState" /> 值之一。</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlWriter" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteString">
      <MemberSignature Language="C#" Value="public abstract void WriteString (string text);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void WriteString(string text) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlWriter.WriteString(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Sub WriteString (text As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void WriteString(System::String ^ text);" />
      <MemberSignature Language="F#" Value="abstract member WriteString : string -&gt; unit" Usage="xmlWriter.WriteString text" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="text" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="text">要写入的文本。</param>
        <summary>当在派生类中被重写时，写入给定的文本内容。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `WriteString` 执行下列操作：  
  
-   字符`&`， `<`，并`>`替换为`&amp;`， `&lt;`，并`&gt;`分别。  
  
-   默认行为<xref:System.Xml.XmlWriter>使用创建<xref:System.Xml.XmlWriter.Create%2A>是引发<xref:System.ArgumentException>时尝试在范围 0-0x1f （不包括空白字符 0x9、 0xA 和 0xD） 中编写的字符值。 可以通过创建编写这些无效的 XML 字符<xref:System.Xml.XmlWriter>与<xref:System.Xml.XmlWriterSettings.CheckCharacters%2A>属性设置为`false`。 执行此操作将导致字符被替换为数字字符实体 (&\#0; 通过 & #0x1F)。 此外，<xref:System.Xml.XmlTextWriter>使用创建`new`运算符将默认情况下使用数字字符实体替换无效字符。  
  
 **请注意**Microsoft 不鼓励编写无效的 XML 字符，因为许多应用程序使用 XML 不用于处理无效字符的做法。  
  
-   如果`WriteString`调用中的属性值的上下文中，双引号和单引号将替换`&quot;`和`&apos;`分别。  
  
 例如，此输入字符串`test<item>test`形式写出  
  
```  
test&lt;item&gt;test  
```  
  
 如果`text`可以是`null`或`String.Empty`，此方法会写入任何数据内容的文本节点。  
  
 此方法的异步版本，请参阅<xref:System.Xml.XmlWriter.WriteStringAsync%2A>。  
  
   
  
## Examples  
 下面的示例将写入的 XML 节点。  
  
 [!code-cpp[XmlWriter.Close#1](~/samples/snippets/cpp/VS_Snippets_Data/XmlWriter.Close/CPP/XmlWriter.Close.cpp#1)]
 [!code-csharp[XmlWriter.Close#1](~/samples/snippets/csharp/VS_Snippets_Data/XmlWriter.Close/CS/writeelems.cs#1)]
 [!code-vb[XmlWriter.Close#1](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlWriter.Close/VB/writeelems.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">文本字符串包含无效的代理项对。</exception>
        <exception cref="T:System.InvalidOperationException">在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlWriter" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteStringAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task WriteStringAsync (string text);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task WriteStringAsync(string text) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlWriter.WriteStringAsync(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function WriteStringAsync (text As String) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task ^ WriteStringAsync(System::String ^ text);" />
      <MemberSignature Language="F#" Value="abstract member WriteStringAsync : string -&gt; System.Threading.Tasks.Task&#xA;override this.WriteStringAsync : string -&gt; System.Threading.Tasks.Task" Usage="xmlWriter.WriteStringAsync text" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="text" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="text">要写入的文本。</param>
        <summary>异步写入给定的文本内容。</summary>
        <returns>表示 <see langword="WriteString" /> 异步操作的任务。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 这是异步版本<xref:System.Xml.XmlWriter.WriteString%2A>，具有相同功能。 若要使用此方法，必须设置<xref:System.Xml.XmlWriterSettings.Async%2A>标记，用于`true`。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">调用了 <see cref="T:System.Xml.XmlWriter" /> 异步方法，但未将 <see cref="P:System.Xml.XmlWriterSettings.Async" /> 标志设置为 <see langword="true" />。 在这种情况下，将引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“如果要使用异步方法，请将 XmlWriterSettings.Async 设置为 true”。</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/db854f91-ccef-4035-ae4d-0911fde808c7">使用 Async 和 Await 的异步编程（C# 和 Visual Basic）</related>
      </Docs>
    </Member>
    <Member MemberName="WriteSurrogateCharEntity">
      <MemberSignature Language="C#" Value="public abstract void WriteSurrogateCharEntity (char lowChar, char highChar);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void WriteSurrogateCharEntity(char lowChar, char highChar) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlWriter.WriteSurrogateCharEntity(System.Char,System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Sub WriteSurrogateCharEntity (lowChar As Char, highChar As Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void WriteSurrogateCharEntity(char lowChar, char highChar);" />
      <MemberSignature Language="F#" Value="abstract member WriteSurrogateCharEntity : char * char -&gt; unit" Usage="xmlWriter.WriteSurrogateCharEntity (lowChar, highChar)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="lowChar" Type="System.Char" />
        <Parameter Name="highChar" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="lowChar">低代理项。 它必须是介于 0xDC00 和 0xDFFF 之间的值。</param>
        <param name="highChar">高代理项。 它必须是介于 0xD800 和 0xDBFF 之间的值。</param>
        <summary>当在派生类中被重写时，为代理项字符对生成并写入代理项字符实体。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法仅适用于使用 utf-16 编码的系统。  
  
 代理项字符实体以十六进制格式编写。 代理项字符的范围是到 # #x10ffff #x 10000。 下面的公式用于生成代理项字符实体: (`highChar` -0xD800) * 0x400 + (`lowChar` -介于 0xDC00) + 0x10000  
  
 对于 HTML 和 XML，文档字符集 （和数字字符引用表示法） 基于 UCS [ISO 10646]。 源文档中的单个数字字符引用可能会因此在某些情况下对应于字符串 （一个高代理项和低代理项） 中的两个 16 位单位。 这些 16 位单元称为代理项对。  
  
 有关代理项或多个字符的详细信息，请参阅的部分 3.7 的 Unicode 标准 3.0/Unicode 2.0 位于http://www.unicode.org，或在位于 W3C XML 1.0 建议的第 2.2 节http://www.w3.org/TR/REC-xml#charsets。  
  
 此方法的异步版本，请参阅<xref:System.Xml.XmlWriter.WriteSurrogateCharEntityAsync%2A>。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">传递了无效的代理项字符对。</exception>
        <exception cref="T:System.InvalidOperationException">在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlWriter" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteSurrogateCharEntityAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task WriteSurrogateCharEntityAsync (char lowChar, char highChar);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task WriteSurrogateCharEntityAsync(char lowChar, char highChar) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlWriter.WriteSurrogateCharEntityAsync(System.Char,System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function WriteSurrogateCharEntityAsync (lowChar As Char, highChar As Char) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task ^ WriteSurrogateCharEntityAsync(char lowChar, char highChar);" />
      <MemberSignature Language="F#" Value="abstract member WriteSurrogateCharEntityAsync : char * char -&gt; System.Threading.Tasks.Task&#xA;override this.WriteSurrogateCharEntityAsync : char * char -&gt; System.Threading.Tasks.Task" Usage="xmlWriter.WriteSurrogateCharEntityAsync (lowChar, highChar)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="lowChar" Type="System.Char" />
        <Parameter Name="highChar" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="lowChar">低代理项。 它必须是介于 0xDC00 和 0xDFFF 之间的值。</param>
        <param name="highChar">高代理项。 它必须是介于 0xD800 和 0xDBFF 之间的值。</param>
        <summary>为代理项字符对异步生成并写入代理项字符实体。</summary>
        <returns>表示 <see langword="WriteSurrogateCharEntity" /> 异步操作的任务。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 这是异步版本<xref:System.Xml.XmlWriter.WriteSurrogateCharEntity%2A>，具有相同功能。 若要使用此方法，必须设置<xref:System.Xml.XmlWriterSettings.Async%2A>标记，用于`true`。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">调用了 <see cref="T:System.Xml.XmlWriter" /> 异步方法，但未将 <see cref="P:System.Xml.XmlWriterSettings.Async" /> 标志设置为 <see langword="true" />。 在这种情况下，将引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“如果要使用异步方法，请将 XmlWriterSettings.Async 设置为 true”。</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/db854f91-ccef-4035-ae4d-0911fde808c7">使用 Async 和 Await 的异步编程（C# 和 Visual Basic）</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteValue">
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <exception cref="T:System.InvalidOperationException">在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlWriter" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”</exception>
        <summary>写入单一的简单类型化值。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Xml.XmlWriter.WriteValue%2A>方法接受公共语言运行时 (CLR) 简单类型化值，将其转换为其字符串表示形式根据 XML 架构定义语言 (XSD) 数据类型转换规则，并将其缩小写入使用<xref:System.Xml.XmlWriter.WriteString%2A>方法。 这使您可以使用最小重新分析开销间传递数据时的简单类型值的管道<xref:System.Xml.XPath.XPathDocument>， <xref:System.Xml.XmlReader>，和<xref:System.Xml.XmlWriter>对象。 处理 CLR 简单类型时，此功能也非常有用和<xref:System.Xml.XmlWriter>实例。 您可以调用<xref:System.Xml.XmlWriter.WriteValue%2A>方法来写入而不是使用中的方法的类型化的值<xref:System.Xml.XmlConvert>类写出之前将类型化的数据转换为字符串值。  
  
 对于异步操作，将转换的返回值<xref:System.Xml.XmlWriter.WriteValue%2A>与字符串和使用<xref:System.Xml.XmlWriter.WriteStringAsync%2A>方法。  
  
 下表显示的默认 CLR 类型对应的 XSD 数据类型。  
  
 如果 CLR 对象是列表类型，例如 <xref:System.Collections.IEnumerable>、<xref:System.Collections.IList> 或 <xref:System.Collections.ICollection>，将作为值类型数组对待。  
  
|CLR 类型|默认 XSD 数据类型|  
|--------------|---------------------------|  
|<xref:System.Boolean?displayProperty=nameWithType>|xsd:boolean|  
|<xref:System.Byte?displayProperty=nameWithType>**|xsd:integer|  
|<xref:System.Byte?displayProperty=nameWithType> 数组|xsd:base64Binary|  
|<xref:System.Char?displayProperty=nameWithType>**|xsd:string|  
|<xref:System.DateTime?displayProperty=nameWithType>|xsd:dateTime|  
|<xref:System.Decimal?displayProperty=nameWithType>|xsd:decimal|  
|<xref:System.Double?displayProperty=nameWithType>|xsd:double|  
|<xref:System.Int16?displayProperty=nameWithType>**|xsd:integer|  
|<xref:System.Int32?displayProperty=nameWithType>|xsd:integer|  
|<xref:System.Int64?displayProperty=nameWithType>|xsd:integer|  
|<xref:System.Single?displayProperty=nameWithType>|xsd:float|  
|<xref:System.String?displayProperty=nameWithType>|xsd:string|  
|<xref:System.IO.TextReader?displayProperty=nameWithType>|xsd:string|  
|<xref:System.IO.BinaryReader?displayProperty=nameWithType>|xsd:base64Binary|  
  
 **这些类型不符合 CLS。 它们不具有相应<xref:System.Xml.XmlWriter.WriteValue%2A>方法。  
  
 如果继续多次调用 <xref:System.Xml.XmlWriter.WriteValue%2A>，值不会通过空格分隔。 必须在调用 <xref:System.Xml.XmlWriter.WriteWhitespace%2A> 之间调用 <xref:System.Xml.XmlWriter.WriteValue%2A>，以插入空白。  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteValue">
      <MemberSignature Language="C#" Value="public virtual void WriteValue (bool value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void WriteValue(bool value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlWriter.WriteValue(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub WriteValue (value As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void WriteValue(bool value);" />
      <MemberSignature Language="F#" Value="abstract member WriteValue : bool -&gt; unit&#xA;override this.WriteValue : bool -&gt; unit" Usage="xmlWriter.WriteValue value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="value">要写入的 <see cref="T:System.Boolean" /> 值。</param>
        <summary>写入 <see cref="T:System.Boolean" /> 值。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法接受公共语言运行时对象，并将输入的值转换为使用 XML 架构定义语言 (XSD) 数据类型转换规则的所需的输出类型。  
  
 在调用 <xref:System.Xml.XmlWriter.WriteValue%2A> 方法时，<xref:System.Xml.XmlWriter> 根据 XML 架构 (XSD) 数据类型定义将值转换为其字符串表示形式并使用 <xref:System.Xml.XmlWriter.WriteString%2A> 方法写出。  
  
 如果继续多次调用 <xref:System.Xml.XmlWriter.WriteValue%2A>，值不会通过空格分隔。 必须在调用 <xref:System.Xml.XmlWriter.WriteWhitespace%2A> 之间调用 <xref:System.Xml.XmlWriter.WriteValue%2A>，以插入空白。 传递到数组类型<xref:System.Xml.XmlWriter.WriteValue%28System.Object%29?displayProperty=nameWithType>重载来写出非重复值的数组。  
  
 如果在调用此方法<xref:System.Xml.XmlWriter>实例纯文本，类型化的值序列化为文本的输出。  
  
 对于异步操作，此方法的返回值转换为字符串，并使用<xref:System.Xml.XmlWriter.WriteStringAsync%2A>方法。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">指定了无效值。</exception>
        <exception cref="T:System.InvalidOperationException">在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlWriter" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteValue">
      <MemberSignature Language="C#" Value="public virtual void WriteValue (DateTime value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void WriteValue(valuetype System.DateTime value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlWriter.WriteValue(System.DateTime)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub WriteValue (value As DateTime)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void WriteValue(DateTime value);" />
      <MemberSignature Language="F#" Value="abstract member WriteValue : DateTime -&gt; unit&#xA;override this.WriteValue : DateTime -&gt; unit" Usage="xmlWriter.WriteValue value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.DateTime" />
      </Parameters>
      <Docs>
        <param name="value">要写入的 <see cref="T:System.DateTime" /> 值。</param>
        <summary>写入 <see cref="T:System.DateTime" /> 值。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法接受公共语言运行时对象，并将输入的值转换为使用 XML 架构定义语言 (XSD) 数据类型转换规则的所需的输出类型。  
  
 在调用 <xref:System.Xml.XmlWriter.WriteValue%2A> 方法时，<xref:System.Xml.XmlWriter> 根据 XML 架构 (XSD) 数据类型定义将值转换为其字符串表示形式并使用 <xref:System.Xml.XmlWriter.WriteString%2A> 方法写出。  
  
 如果继续多次调用 <xref:System.Xml.XmlWriter.WriteValue%2A>，值不会通过空格分隔。 必须在调用 <xref:System.Xml.XmlWriter.WriteWhitespace%2A> 之间调用 <xref:System.Xml.XmlWriter.WriteValue%2A>，以插入空白。 传递到数组类型<xref:System.Xml.XmlWriter.WriteValue%28System.Object%29?displayProperty=nameWithType>重载来写出非重复值的数组。  
  
 如果在调用此方法<xref:System.Xml.XmlWriter>实例纯文本，类型化的值序列化为文本的输出。  
  
 对于异步操作，此方法的返回值转换为字符串，并使用<xref:System.Xml.XmlWriter.WriteStringAsync%2A>方法。  
  
   
  
## Examples  
 下面的示例编写书节点使用类型化的数据。  
  
 [!code-csharp[XmlWriter_v2#1](~/samples/snippets/csharp/VS_Snippets_Data/XmlWriter_v2/CS/writer_v2.cs#1)]
 [!code-vb[XmlWriter_v2#1](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlWriter_v2/VB/writer_v2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">指定了无效值。</exception>
        <exception cref="T:System.InvalidOperationException">在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlWriter" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteValue">
      <MemberSignature Language="C#" Value="public virtual void WriteValue (DateTimeOffset value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void WriteValue(valuetype System.DateTimeOffset value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlWriter.WriteValue(System.DateTimeOffset)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub WriteValue (value As DateTimeOffset)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void WriteValue(DateTimeOffset value);" />
      <MemberSignature Language="F#" Value="abstract member WriteValue : DateTimeOffset -&gt; unit&#xA;override this.WriteValue : DateTimeOffset -&gt; unit" Usage="xmlWriter.WriteValue value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.DateTimeOffset" />
      </Parameters>
      <Docs>
        <param name="value">要写入的 <see cref="T:System.DateTimeOffset" /> 值。</param>
        <summary>写入 <see cref="T:System.DateTimeOffset" /> 值。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 对于异步操作，此方法的返回值转换为字符串，并使用<xref:System.Xml.XmlWriter.WriteStringAsync%2A>方法。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlWriter" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteValue">
      <MemberSignature Language="C#" Value="public virtual void WriteValue (decimal value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void WriteValue(valuetype System.Decimal value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlWriter.WriteValue(System.Decimal)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub WriteValue (value As Decimal)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void WriteValue(System::Decimal value);" />
      <MemberSignature Language="F#" Value="abstract member WriteValue : decimal -&gt; unit&#xA;override this.WriteValue : decimal -&gt; unit" Usage="xmlWriter.WriteValue value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="value">要写入的 <see cref="T:System.Decimal" /> 值。</param>
        <summary>写入 <see cref="T:System.Decimal" /> 值。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法接受公共语言运行时对象，并将输入的值转换为使用 XML 架构定义语言 (XSD) 数据类型转换规则的所需的输出类型。  
  
 在调用 <xref:System.Xml.XmlWriter.WriteValue%2A> 方法时，<xref:System.Xml.XmlWriter> 根据 XML 架构 (XSD) 数据类型定义将值转换为其字符串表示形式并使用 <xref:System.Xml.XmlWriter.WriteString%2A> 方法写出。  
  
 如果继续多次调用 <xref:System.Xml.XmlWriter.WriteValue%2A>，值不会通过空格分隔。 必须在调用 <xref:System.Xml.XmlWriter.WriteWhitespace%2A> 之间调用 <xref:System.Xml.XmlWriter.WriteValue%2A>，以插入空白。 传递到数组类型<xref:System.Xml.XmlWriter.WriteValue%28System.Object%29?displayProperty=nameWithType>重载来写出非重复值的数组。  
  
 如果在调用此方法<xref:System.Xml.XmlWriter>实例纯文本，类型化的值序列化为文本的输出。  
  
 对于异步操作，此方法的返回值转换为字符串，并使用<xref:System.Xml.XmlWriter.WriteStringAsync%2A>方法。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">指定了无效值。</exception>
        <exception cref="T:System.InvalidOperationException">在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlWriter" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteValue">
      <MemberSignature Language="C#" Value="public virtual void WriteValue (double value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void WriteValue(float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlWriter.WriteValue(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub WriteValue (value As Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void WriteValue(double value);" />
      <MemberSignature Language="F#" Value="abstract member WriteValue : double -&gt; unit&#xA;override this.WriteValue : double -&gt; unit" Usage="xmlWriter.WriteValue value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="value">要写入的 <see cref="T:System.Double" /> 值。</param>
        <summary>写入 <see cref="T:System.Double" /> 值。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法接受公共语言运行时对象，并将输入的值转换为使用 XML 架构定义语言 (XSD) 数据类型转换规则的所需的输出类型。  
  
 在调用 <xref:System.Xml.XmlWriter.WriteValue%2A> 方法时，<xref:System.Xml.XmlWriter> 根据 XML 架构 (XSD) 数据类型定义将值转换为其字符串表示形式并使用 <xref:System.Xml.XmlWriter.WriteString%2A> 方法写出。  
  
 如果继续多次调用 <xref:System.Xml.XmlWriter.WriteValue%2A>，值不会通过空格分隔。 必须在调用 <xref:System.Xml.XmlWriter.WriteWhitespace%2A> 之间调用 <xref:System.Xml.XmlWriter.WriteValue%2A>，以插入空白。 传递到数组类型<xref:System.Xml.XmlWriter.WriteValue%28System.Object%29?displayProperty=nameWithType>重载来写出非重复值的数组。  
  
 如果在调用此方法<xref:System.Xml.XmlWriter>实例纯文本，类型化的值序列化为文本的输出。  
  
 对于异步操作，此方法的返回值转换为字符串，并使用<xref:System.Xml.XmlWriter.WriteStringAsync%2A>方法。  
  
   
  
## Examples  
 下面的示例编写书节点使用类型化的数据。  
  
 [!code-csharp[XmlWriter_v2#1](~/samples/snippets/csharp/VS_Snippets_Data/XmlWriter_v2/CS/writer_v2.cs#1)]
 [!code-vb[XmlWriter_v2#1](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlWriter_v2/VB/writer_v2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">指定了无效值。</exception>
        <exception cref="T:System.InvalidOperationException">在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlWriter" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteValue">
      <MemberSignature Language="C#" Value="public virtual void WriteValue (int value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void WriteValue(int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlWriter.WriteValue(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub WriteValue (value As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void WriteValue(int value);" />
      <MemberSignature Language="F#" Value="abstract member WriteValue : int -&gt; unit&#xA;override this.WriteValue : int -&gt; unit" Usage="xmlWriter.WriteValue value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">要写入的 <see cref="T:System.Int32" /> 值。</param>
        <summary>写入 <see cref="T:System.Int32" /> 值。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法接受公共语言运行时对象，并将输入的值转换为使用 XML 架构定义语言 (XSD) 数据类型转换规则的所需的输出类型。  
  
 在调用 <xref:System.Xml.XmlWriter.WriteValue%2A> 方法时，<xref:System.Xml.XmlWriter> 根据 XML 架构 (XSD) 数据类型定义将值转换为其字符串表示形式并使用 <xref:System.Xml.XmlWriter.WriteString%2A> 方法写出。  
  
 如果继续多次调用 <xref:System.Xml.XmlWriter.WriteValue%2A>，值不会通过空格分隔。 必须在调用 <xref:System.Xml.XmlWriter.WriteWhitespace%2A> 之间调用 <xref:System.Xml.XmlWriter.WriteValue%2A>，以插入空白。 传递到数组类型<xref:System.Xml.XmlWriter.WriteValue%28System.Object%29?displayProperty=nameWithType>重载来写出非重复值的数组。  
  
 如果在调用此方法<xref:System.Xml.XmlWriter>实例纯文本，类型化的值序列化为文本的输出。  
  
 对于异步操作，此方法的返回值转换为字符串，并使用<xref:System.Xml.XmlWriter.WriteStringAsync%2A>方法。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">指定了无效值。</exception>
        <exception cref="T:System.InvalidOperationException">在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlWriter" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteValue">
      <MemberSignature Language="C#" Value="public virtual void WriteValue (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void WriteValue(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlWriter.WriteValue(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub WriteValue (value As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void WriteValue(long value);" />
      <MemberSignature Language="F#" Value="abstract member WriteValue : int64 -&gt; unit&#xA;override this.WriteValue : int64 -&gt; unit" Usage="xmlWriter.WriteValue value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value">要写入的 <see cref="T:System.Int64" /> 值。</param>
        <summary>写入 <see cref="T:System.Int64" /> 值。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法接受公共语言运行时对象，并将输入的值转换为使用 XML 架构定义语言 (XSD) 数据类型转换规则的所需的输出类型。  
  
 在调用 <xref:System.Xml.XmlWriter.WriteValue%2A> 方法时，<xref:System.Xml.XmlWriter> 根据 XML 架构 (XSD) 数据类型定义将值转换为其字符串表示形式并使用 <xref:System.Xml.XmlWriter.WriteString%2A> 方法写出。  
  
 如果继续多次调用 <xref:System.Xml.XmlWriter.WriteValue%2A>，值不会通过空格分隔。 必须在调用 <xref:System.Xml.XmlWriter.WriteWhitespace%2A> 之间调用 <xref:System.Xml.XmlWriter.WriteValue%2A>，以插入空白。 传递到数组类型<xref:System.Xml.XmlWriter.WriteValue%28System.Object%29?displayProperty=nameWithType>重载来写出非重复值的数组。  
  
 如果在调用此方法<xref:System.Xml.XmlWriter>实例纯文本，类型化的值序列化为文本的输出。  
  
 对于异步操作，此方法的返回值转换为字符串，并使用<xref:System.Xml.XmlWriter.WriteStringAsync%2A>方法。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">指定了无效值。</exception>
        <exception cref="T:System.InvalidOperationException">在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlWriter" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteValue">
      <MemberSignature Language="C#" Value="public virtual void WriteValue (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void WriteValue(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlWriter.WriteValue(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub WriteValue (value As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void WriteValue(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="abstract member WriteValue : obj -&gt; unit&#xA;override this.WriteValue : obj -&gt; unit" Usage="xmlWriter.WriteValue value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">要写入的对象值。  
  
 **注意**：随着 .NET Framework 3.5 的发布，该方法接受将 <see cref="T:System.DateTimeOffset" /> 作为参数。</param>
        <summary>写入对象值。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法接受公共语言运行时 (CLR) 对象，并将输入的值转换为使用 XML 架构定义语言 (XSD) 数据类型转换规则的所需的输出类型。  
  
 如果 CLR 对象是列表类型等<xref:System.Collections.IEnumerable>， <xref:System.Collections.IList>，或<xref:System.Collections.ICollection>，它将被视为值类型的数组。 <xref:System.Xml.XmlWriter>将为其字符串表示形式根据 XML 架构 (XSD) 数据类型值规则，并将其写出使用<xref:System.Xml.XmlWriter.WriteString%2A>方法。  
  
 如果在调用此方法<xref:System.Xml.XmlWriter>实例纯文本，类型化的值序列化为文本的输出。  
  
 对于异步操作，此方法的返回值转换为字符串，并使用<xref:System.Xml.XmlWriter.WriteStringAsync%2A>方法。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">指定了无效值。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlWriter" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteValue">
      <MemberSignature Language="C#" Value="public virtual void WriteValue (float value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void WriteValue(float32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlWriter.WriteValue(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub WriteValue (value As Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void WriteValue(float value);" />
      <MemberSignature Language="F#" Value="abstract member WriteValue : single -&gt; unit&#xA;override this.WriteValue : single -&gt; unit" Usage="xmlWriter.WriteValue value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="value">要写入的单精度浮点数。</param>
        <summary>写入一个单精度浮点数。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法接受公共语言运行时对象，并将输入的值转换为使用 XML 架构定义语言 (XSD) 数据类型转换规则的所需的输出类型。  
  
 在调用 <xref:System.Xml.XmlWriter.WriteValue%2A> 方法时，<xref:System.Xml.XmlWriter> 根据 XML 架构 (XSD) 数据类型定义将值转换为其字符串表示形式并使用 <xref:System.Xml.XmlWriter.WriteString%2A> 方法写出。  
  
 如果继续多次调用 <xref:System.Xml.XmlWriter.WriteValue%2A>，值不会通过空格分隔。 必须在调用 <xref:System.Xml.XmlWriter.WriteWhitespace%2A> 之间调用 <xref:System.Xml.XmlWriter.WriteValue%2A>，以插入空白。 传递到数组类型<xref:System.Xml.XmlWriter.WriteValue%28System.Object%29?displayProperty=nameWithType>重载来写出非重复值的数组。  
  
 如果在调用此方法<xref:System.Xml.XmlWriter>实例纯文本，类型化的值序列化为文本的输出。  
  
 对于异步操作，此方法的返回值转换为字符串，并使用<xref:System.Xml.XmlWriter.WriteStringAsync%2A>方法。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">指定了无效值。</exception>
        <exception cref="T:System.InvalidOperationException">在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlWriter" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteValue">
      <MemberSignature Language="C#" Value="public virtual void WriteValue (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void WriteValue(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlWriter.WriteValue(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub WriteValue (value As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void WriteValue(System::String ^ value);" />
      <MemberSignature Language="F#" Value="abstract member WriteValue : string -&gt; unit&#xA;override this.WriteValue : string -&gt; unit" Usage="xmlWriter.WriteValue value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">要写入的 <see cref="T:System.String" /> 值。</param>
        <summary>写入 <see cref="T:System.String" /> 值。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法接受公共语言运行时对象，并将输入的值转换为使用 XML 架构定义语言 (XSD) 数据类型转换规则的所需的输出类型。  
  
 如果继续多次调用 <xref:System.Xml.XmlWriter.WriteValue%2A>，值不会通过空格分隔。 必须在调用 <xref:System.Xml.XmlWriter.WriteWhitespace%2A> 之间调用 <xref:System.Xml.XmlWriter.WriteValue%2A>，以插入空白。 传递到数组类型<xref:System.Xml.XmlWriter.WriteValue%28System.Object%29?displayProperty=nameWithType>重载来写出非重复值的数组。  
  
 如果在调用此方法<xref:System.Xml.XmlWriter>实例纯文本，类型化的值序列化为文本的输出。  
  
 对于异步操作，使用<xref:System.Xml.XmlWriter.WriteStringAsync%2A>方法。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">指定了无效值。</exception>
        <exception cref="T:System.InvalidOperationException">在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlWriter" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteWhitespace">
      <MemberSignature Language="C#" Value="public abstract void WriteWhitespace (string ws);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void WriteWhitespace(string ws) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlWriter.WriteWhitespace(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Sub WriteWhitespace (ws As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void WriteWhitespace(System::String ^ ws);" />
      <MemberSignature Language="F#" Value="abstract member WriteWhitespace : string -&gt; unit" Usage="xmlWriter.WriteWhitespace ws" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ws" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="ws">空格字符的字符串。</param>
        <summary>当在派生类中被重写时，写出给定的空白区域。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法用于手动格式化文档。  
  
 此方法的异步版本，请参阅<xref:System.Xml.XmlWriter.WriteWhitespaceAsync%2A>。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">字符串包含非空白字符。</exception>
        <exception cref="T:System.InvalidOperationException">在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlWriter" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteWhitespaceAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task WriteWhitespaceAsync (string ws);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task WriteWhitespaceAsync(string ws) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlWriter.WriteWhitespaceAsync(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function WriteWhitespaceAsync (ws As String) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task ^ WriteWhitespaceAsync(System::String ^ ws);" />
      <MemberSignature Language="F#" Value="abstract member WriteWhitespaceAsync : string -&gt; System.Threading.Tasks.Task&#xA;override this.WriteWhitespaceAsync : string -&gt; System.Threading.Tasks.Task" Usage="xmlWriter.WriteWhitespaceAsync ws" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ws" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="ws">空格字符的字符串。</param>
        <summary>异步写出给定的空白区域。</summary>
        <returns>表示 <see langword="WriteWhitespace" /> 异步操作的任务。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 这是异步版本<xref:System.Xml.XmlWriter.WriteWhitespace%2A>，具有相同功能。 若要使用此方法，必须设置<xref:System.Xml.XmlWriterSettings.Async%2A>标记，用于`true`。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">调用了 <see cref="T:System.Xml.XmlWriter" /> 异步方法，但未将 <see cref="P:System.Xml.XmlWriterSettings.Async" /> 标志设置为 <see langword="true" />。 在这种情况下，将引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“如果要使用异步方法，请将 XmlWriterSettings.Async 设置为 true”。</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/db854f91-ccef-4035-ae4d-0911fde808c7">使用 Async 和 Await 的异步编程（C# 和 Visual Basic）</related>
      </Docs>
    </Member>
    <Member MemberName="XmlLang">
      <MemberSignature Language="C#" Value="public virtual string XmlLang { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string XmlLang" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlWriter.XmlLang" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property XmlLang As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ XmlLang { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.XmlLang : string" Usage="System.Xml.XmlWriter.XmlLang" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当在派生类中被重写时，获取当前的 <see langword="xml:lang" /> 范围。</summary>
        <value>当前 <see langword="xml:lang" /> 范围。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此属性允许一个要找出在什么状态另一个组件已离开编写器的组件。 例如，可能是一个组件希望告知另一要生成哪些语言的帮助文本。 语言信息传递通过编写`xml:lang`属性。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlWriter" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”</exception>
      </Docs>
    </Member>
    <Member MemberName="XmlSpace">
      <MemberSignature Language="C#" Value="public virtual System.Xml.XmlSpace XmlSpace { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Xml.XmlSpace XmlSpace" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlWriter.XmlSpace" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property XmlSpace As XmlSpace" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Xml::XmlSpace XmlSpace { System::Xml::XmlSpace get(); };" />
      <MemberSignature Language="F#" Value="member this.XmlSpace : System.Xml.XmlSpace" Usage="System.Xml.XmlWriter.XmlSpace" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlSpace</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当在派生类中被重写时，获取表示当前 <see langword="xml:space" /> 范围的 <see cref="T:System.Xml.XmlSpace" />。</summary>
        <value>一个表示当前 <see langword="XmlSpace" /> 范围的 <see langword="xml:space" />。  
  
 <list type="table"><listheader><term> “值” 
 </term><description> 含义 
 </description></listheader><item><term><see langword="None" /></term><description> 如果不存在 <see langword="xml:space" /> 范围，则此为默认值。  
  
 </description></item><item><term><see langword="Default" /></term><description> 当前范围为 <see langword="xml:space" />="default"。  
  
 </description></item><item><term><see langword="Preserve" /></term><description> 当前范围为 <see langword="xml:space" />="preserve"。  
  
 </description></item></list></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 这样，若要了解所处的状态的另一个组件已离开的编写器中的一个组件。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlWriter" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”</exception>
      </Docs>
    </Member>
  </Members>
</Type>